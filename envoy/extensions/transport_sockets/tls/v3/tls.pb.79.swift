// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/transport_sockets/tls/v3/tls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common TLS context settings.
  ///
  /// .. attention::
  ///
  ///   Server certificate verification is not enabled by default. Configure
  ///   :ref:`trusted_ca<envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
  ///   verification.
  public var commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext {
    get {return _commonTlsContext ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext()}
    set {_commonTlsContext = newValue}
  }
  /// Returns true if `commonTlsContext` has been explicitly set.
  public var hasCommonTlsContext: Bool {return self._commonTlsContext != nil}
  /// Clears the value of `commonTlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearCommonTlsContext() {self._commonTlsContext = nil}

  /// SNI string to use when creating TLS backend connections.
  public var sni: String = String()

  /// If true, server-initiated TLS renegotiation will be allowed.
  ///
  /// .. attention::
  ///
  ///   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
  public var allowRenegotiation: Bool = false

  /// Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
  /// for TLSv1.2 and older) to store for the purpose of session resumption.
  ///
  /// Defaults to 1, setting this to 0 disables session resumption.
  public var maxSessionKeys: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxSessionKeys ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxSessionKeys = newValue}
  }
  /// Returns true if `maxSessionKeys` has been explicitly set.
  public var hasMaxSessionKeys: Bool {return self._maxSessionKeys != nil}
  /// Clears the value of `maxSessionKeys`. Subsequent reads from it will return its default value.
  public mutating func clearMaxSessionKeys() {self._maxSessionKeys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext? = nil
  fileprivate var _maxSessionKeys: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#next-free-field: 8]
public struct Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common TLS context settings.
  public var commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext {
    get {return _commonTlsContext ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext()}
    set {_commonTlsContext = newValue}
  }
  /// Returns true if `commonTlsContext` has been explicitly set.
  public var hasCommonTlsContext: Bool {return self._commonTlsContext != nil}
  /// Clears the value of `commonTlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearCommonTlsContext() {self._commonTlsContext = nil}

  /// If specified, Envoy will reject connections without a valid client
  /// certificate.
  public var requireClientCertificate: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _requireClientCertificate ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_requireClientCertificate = newValue}
  }
  /// Returns true if `requireClientCertificate` has been explicitly set.
  public var hasRequireClientCertificate: Bool {return self._requireClientCertificate != nil}
  /// Clears the value of `requireClientCertificate`. Subsequent reads from it will return its default value.
  public mutating func clearRequireClientCertificate() {self._requireClientCertificate = nil}

  /// If specified, Envoy will reject connections without a valid and matching SNI.
  /// [#not-implemented-hide:]
  public var requireSni: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _requireSni ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_requireSni = newValue}
  }
  /// Returns true if `requireSni` has been explicitly set.
  public var hasRequireSni: Bool {return self._requireSni != nil}
  /// Clears the value of `requireSni`. Subsequent reads from it will return its default value.
  public mutating func clearRequireSni() {self._requireSni = nil}

  public var sessionTicketKeysType: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OneOf_SessionTicketKeysType? = nil

  /// TLS session ticket key settings.
  public var sessionTicketKeys: Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys {
    get {
      if case .sessionTicketKeys(let v)? = sessionTicketKeysType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys()
    }
    set {sessionTicketKeysType = .sessionTicketKeys(newValue)}
  }

  /// Config for fetching TLS session ticket keys via SDS API.
  public var sessionTicketKeysSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
    get {
      if case .sessionTicketKeysSdsSecretConfig(let v)? = sessionTicketKeysType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()
    }
    set {sessionTicketKeysType = .sessionTicketKeysSdsSecretConfig(newValue)}
  }

  /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
  /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
  /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
  /// the keys specified through either :ref:`session_ticket_keys <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
  /// or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
  /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
  /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
  /// implication that sessions cannot be resumed across hot restarts or on different hosts.
  public var disableStatelessSessionResumption: Bool {
    get {
      if case .disableStatelessSessionResumption(let v)? = sessionTicketKeysType {return v}
      return false
    }
    set {sessionTicketKeysType = .disableStatelessSessionResumption(newValue)}
  }

  /// If specified, session_timeout will change maximum lifetime (in seconds) of TLS session
  /// Currently this value is used as a hint to `TLS session ticket lifetime (for TLSv1.2)
  /// <https://tools.ietf.org/html/rfc5077#section-5.6>`
  /// only seconds could be specified (fractional seconds are going to be ignored).
  public var sessionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _sessionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_sessionTimeout = newValue}
  }
  /// Returns true if `sessionTimeout` has been explicitly set.
  public var hasSessionTimeout: Bool {return self._sessionTimeout != nil}
  /// Clears the value of `sessionTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearSessionTimeout() {self._sessionTimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SessionTicketKeysType: Equatable {
    /// TLS session ticket key settings.
    case sessionTicketKeys(Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys)
    /// Config for fetching TLS session ticket keys via SDS API.
    case sessionTicketKeysSdsSecretConfig(Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig)
    /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    /// the keys specified through either :ref:`session_ticket_keys <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
    /// or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
    /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    /// implication that sessions cannot be resumed across hot restarts or on different hosts.
    case disableStatelessSessionResumption(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OneOf_SessionTicketKeysType, rhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OneOf_SessionTicketKeysType) -> Bool {
      switch (lhs, rhs) {
      case (.sessionTicketKeys(let l), .sessionTicketKeys(let r)): return l == r
      case (.sessionTicketKeysSdsSecretConfig(let l), .sessionTicketKeysSdsSecretConfig(let r)): return l == r
      case (.disableStatelessSessionResumption(let l), .disableStatelessSessionResumption(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext? = nil
  fileprivate var _requireClientCertificate: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _requireSni: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _sessionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// TLS context shared by both client and server TLS contexts.
/// [#next-free-field: 11]
public struct Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLS protocol versions, cipher suites etc.
  public var tlsParams: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters {
    get {return _tlsParams ?? Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters()}
    set {_tlsParams = newValue}
  }
  /// Returns true if `tlsParams` has been explicitly set.
  public var hasTlsParams: Bool {return self._tlsParams != nil}
  /// Clears the value of `tlsParams`. Subsequent reads from it will return its default value.
  public mutating func clearTlsParams() {self._tlsParams = nil}

  /// :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
  /// same context to allow both RSA and ECDSA certificates.
  ///
  /// Only a single TLS certificate is supported in client contexts. In server contexts, the first
  /// RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
  /// used for clients that support ECDSA.
  public var tlsCertificates: [Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate] = []

  /// Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
  /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  public var tlsCertificateSdsSecretConfigs: [Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig] = []

  /// Certificate provider for fetching TLS certificates.
  /// [#not-implemented-hide:]
  public var tlsCertificateCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider {
    get {return _tlsCertificateCertificateProvider ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider()}
    set {_tlsCertificateCertificateProvider = newValue}
  }
  /// Returns true if `tlsCertificateCertificateProvider` has been explicitly set.
  public var hasTlsCertificateCertificateProvider: Bool {return self._tlsCertificateCertificateProvider != nil}
  /// Clears the value of `tlsCertificateCertificateProvider`. Subsequent reads from it will return its default value.
  public mutating func clearTlsCertificateCertificateProvider() {self._tlsCertificateCertificateProvider = nil}

  public var validationContextType: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.OneOf_ValidationContextType? = nil

  /// How to validate peer certificates.
  public var validationContext: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext {
    get {
      if case .validationContext(let v)? = validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext()
    }
    set {validationContextType = .validationContext(newValue)}
  }

  /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
  /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  public var validationContextSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
    get {
      if case .validationContextSdsSecretConfig(let v)? = validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()
    }
    set {validationContextType = .validationContextSdsSecretConfig(newValue)}
  }

  /// Combined certificate validation context holds a default CertificateValidationContext
  /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
  /// and default CertificateValidationContext are merged into a new CertificateValidationContext
  /// for validation. This merge is done by Message::MergeFrom(), so dynamic
  /// CertificateValidationContext overwrites singular fields in default
  /// CertificateValidationContext, and concatenates repeated fields to default
  /// CertificateValidationContext, and logical OR is applied to boolean fields.
  public var combinedValidationContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext {
    get {
      if case .combinedValidationContext(let v)? = validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext()
    }
    set {validationContextType = .combinedValidationContext(newValue)}
  }

  /// Certificate provider for fetching validation context.
  /// [#not-implemented-hide:]
  public var validationContextCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider {
    get {
      if case .validationContextCertificateProvider(let v)? = validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider()
    }
    set {validationContextType = .validationContextCertificateProvider(newValue)}
  }

  /// Supplies the list of ALPN protocols that the listener should expose. In
  /// practice this is likely to be set to one of two values (see the
  /// :ref:`codec_type
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
  /// parameter in the HTTP connection manager for more information):
  ///
  /// * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
  /// * "http/1.1" If the listener is only going to support HTTP/1.1.
  ///
  /// There is no default for this parameter. If empty, Envoy will not expose ALPN.
  public var alpnProtocols: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ValidationContextType: Equatable {
    /// How to validate peer certificates.
    case validationContext(Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext)
    /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    case validationContextSdsSecretConfig(Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig)
    /// Combined certificate validation context holds a default CertificateValidationContext
    /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
    /// and default CertificateValidationContext are merged into a new CertificateValidationContext
    /// for validation. This merge is done by Message::MergeFrom(), so dynamic
    /// CertificateValidationContext overwrites singular fields in default
    /// CertificateValidationContext, and concatenates repeated fields to default
    /// CertificateValidationContext, and logical OR is applied to boolean fields.
    case combinedValidationContext(Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext)
    /// Certificate provider for fetching validation context.
    /// [#not-implemented-hide:]
    case validationContextCertificateProvider(Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.OneOf_ValidationContextType, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.OneOf_ValidationContextType) -> Bool {
      switch (lhs, rhs) {
      case (.validationContext(let l), .validationContext(let r)): return l == r
      case (.validationContextSdsSecretConfig(let l), .validationContextSdsSecretConfig(let r)): return l == r
      case (.combinedValidationContext(let l), .combinedValidationContext(let r)): return l == r
      case (.validationContextCertificateProvider(let l), .validationContextCertificateProvider(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Config for Certificate provider to get certificates. This provider should allow certificates to be
  /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  public struct CertificateProvider {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    /// a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
    public var name: String = String()

    /// Provider specific config.
    /// Note: an implementation is expected to dedup multiple instances of the same config
    /// to maintain a single certificate-provider instance. The sharing can happen, for
    /// example, among multiple clusters or between the tls_certificate and validation_context
    /// certificate providers of a cluster.
    /// This config could be supplied inline or (in future) a named xDS resource.
    public var config: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider.OneOf_Config? = nil

    public var typedConfig: Envoy_Config_Core_V3_TypedExtensionConfig {
      get {
        if case .typedConfig(let v)? = config {return v}
        return Envoy_Config_Core_V3_TypedExtensionConfig()
      }
      set {config = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Provider specific config.
    /// Note: an implementation is expected to dedup multiple instances of the same config
    /// to maintain a single certificate-provider instance. The sharing can happen, for
    /// example, among multiple clusters or between the tls_certificate and validation_context
    /// certificate providers of a cluster.
    /// This config could be supplied inline or (in future) a named xDS resource.
    public enum OneOf_Config: Equatable {
      case typedConfig(Envoy_Config_Core_V3_TypedExtensionConfig)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider.OneOf_Config, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider.OneOf_Config) -> Bool {
        switch (lhs, rhs) {
        case (.typedConfig(let l), .typedConfig(let r)): return l == r
        }
      }
    #endif
    }

    public init() {}
  }

  public struct CombinedCertificateValidationContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How to validate peer certificates.
    public var defaultValidationContext: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext {
      get {return _defaultValidationContext ?? Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext()}
      set {_defaultValidationContext = newValue}
    }
    /// Returns true if `defaultValidationContext` has been explicitly set.
    public var hasDefaultValidationContext: Bool {return self._defaultValidationContext != nil}
    /// Clears the value of `defaultValidationContext`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultValidationContext() {self._defaultValidationContext = nil}

    /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    /// Only to be used when validation_context_certificate_provider is not used.
    public var validationContextSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
      get {return _validationContextSdsSecretConfig ?? Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()}
      set {_validationContextSdsSecretConfig = newValue}
    }
    /// Returns true if `validationContextSdsSecretConfig` has been explicitly set.
    public var hasValidationContextSdsSecretConfig: Bool {return self._validationContextSdsSecretConfig != nil}
    /// Clears the value of `validationContextSdsSecretConfig`. Subsequent reads from it will return its default value.
    public mutating func clearValidationContextSdsSecretConfig() {self._validationContextSdsSecretConfig = nil}

    /// Certificate provider for fetching validation context - only to be used when
    /// validation_context_sds_secret_config is not used.
    /// [#not-implemented-hide:]
    public var validationContextCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider {
      get {return _validationContextCertificateProvider ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider()}
      set {_validationContextCertificateProvider = newValue}
    }
    /// Returns true if `validationContextCertificateProvider` has been explicitly set.
    public var hasValidationContextCertificateProvider: Bool {return self._validationContextCertificateProvider != nil}
    /// Clears the value of `validationContextCertificateProvider`. Subsequent reads from it will return its default value.
    public mutating func clearValidationContextCertificateProvider() {self._validationContextCertificateProvider = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _defaultValidationContext: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext? = nil
    fileprivate var _validationContextSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig? = nil
    fileprivate var _validationContextCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider? = nil
  }

  public init() {}

  fileprivate var _tlsParams: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters? = nil
  fileprivate var _tlsCertificateCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.transport_sockets.tls.v3"

extension Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_tls_context"),
    2: .same(proto: "sni"),
    3: .standard(proto: "allow_renegotiation"),
    4: .standard(proto: "max_session_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._commonTlsContext)
      case 2: try decoder.decodeSingularStringField(value: &self.sni)
      case 3: try decoder.decodeSingularBoolField(value: &self.allowRenegotiation)
      case 4: try decoder.decodeSingularMessageField(value: &self._maxSessionKeys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commonTlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.sni.isEmpty {
      try visitor.visitSingularStringField(value: self.sni, fieldNumber: 2)
    }
    if self.allowRenegotiation != false {
      try visitor.visitSingularBoolField(value: self.allowRenegotiation, fieldNumber: 3)
    }
    if let v = self._maxSessionKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext) -> Bool {
    if lhs._commonTlsContext != rhs._commonTlsContext {return false}
    if lhs.sni != rhs.sni {return false}
    if lhs.allowRenegotiation != rhs.allowRenegotiation {return false}
    if lhs._maxSessionKeys != rhs._maxSessionKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownstreamTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_tls_context"),
    2: .standard(proto: "require_client_certificate"),
    3: .standard(proto: "require_sni"),
    4: .standard(proto: "session_ticket_keys"),
    5: .standard(proto: "session_ticket_keys_sds_secret_config"),
    7: .standard(proto: "disable_stateless_session_resumption"),
    6: .standard(proto: "session_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._commonTlsContext)
      case 2: try decoder.decodeSingularMessageField(value: &self._requireClientCertificate)
      case 3: try decoder.decodeSingularMessageField(value: &self._requireSni)
      case 4:
        var v: Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys?
        if let current = self.sessionTicketKeysType {
          try decoder.handleConflictingOneOf()
          if case .sessionTicketKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sessionTicketKeysType = .sessionTicketKeys(v)}
      case 5:
        var v: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig?
        if let current = self.sessionTicketKeysType {
          try decoder.handleConflictingOneOf()
          if case .sessionTicketKeysSdsSecretConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sessionTicketKeysType = .sessionTicketKeysSdsSecretConfig(v)}
      case 6: try decoder.decodeSingularMessageField(value: &self._sessionTimeout)
      case 7:
        if self.sessionTicketKeysType != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.sessionTicketKeysType = .disableStatelessSessionResumption(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commonTlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._requireClientCertificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._requireSni {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    switch self.sessionTicketKeysType {
    case .sessionTicketKeys(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .sessionTicketKeysSdsSecretConfig(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case nil: break
    default: break
    }
    if let v = self._sessionTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if case .disableStatelessSessionResumption(let v)? = self.sessionTicketKeysType {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext) -> Bool {
    if lhs._commonTlsContext != rhs._commonTlsContext {return false}
    if lhs._requireClientCertificate != rhs._requireClientCertificate {return false}
    if lhs._requireSni != rhs._requireSni {return false}
    if lhs.sessionTicketKeysType != rhs.sessionTicketKeysType {return false}
    if lhs._sessionTimeout != rhs._sessionTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tls_params"),
    2: .standard(proto: "tls_certificates"),
    6: .standard(proto: "tls_certificate_sds_secret_configs"),
    9: .standard(proto: "tls_certificate_certificate_provider"),
    3: .standard(proto: "validation_context"),
    7: .standard(proto: "validation_context_sds_secret_config"),
    8: .standard(proto: "combined_validation_context"),
    10: .standard(proto: "validation_context_certificate_provider"),
    4: .standard(proto: "alpn_protocols"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._tlsParams)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.tlsCertificates)
      case 3:
        var v: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext?
        if let current = self.validationContextType {
          try decoder.handleConflictingOneOf()
          if case .validationContext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.validationContextType = .validationContext(v)}
      case 4: try decoder.decodeRepeatedStringField(value: &self.alpnProtocols)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.tlsCertificateSdsSecretConfigs)
      case 7:
        var v: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig?
        if let current = self.validationContextType {
          try decoder.handleConflictingOneOf()
          if case .validationContextSdsSecretConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.validationContextType = .validationContextSdsSecretConfig(v)}
      case 8:
        var v: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext?
        if let current = self.validationContextType {
          try decoder.handleConflictingOneOf()
          if case .combinedValidationContext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.validationContextType = .combinedValidationContext(v)}
      case 9: try decoder.decodeSingularMessageField(value: &self._tlsCertificateCertificateProvider)
      case 10:
        var v: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider?
        if let current = self.validationContextType {
          try decoder.handleConflictingOneOf()
          if case .validationContextCertificateProvider(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.validationContextType = .validationContextCertificateProvider(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tlsParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.tlsCertificates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tlsCertificates, fieldNumber: 2)
    }
    if case .validationContext(let v)? = self.validationContextType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.alpnProtocols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.alpnProtocols, fieldNumber: 4)
    }
    if !self.tlsCertificateSdsSecretConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tlsCertificateSdsSecretConfigs, fieldNumber: 6)
    }
    switch self.validationContextType {
    case .validationContextSdsSecretConfig(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    case .combinedValidationContext(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    case nil: break
    default: break
    }
    if let v = self._tlsCertificateCertificateProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if case .validationContextCertificateProvider(let v)? = self.validationContextType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext) -> Bool {
    if lhs._tlsParams != rhs._tlsParams {return false}
    if lhs.tlsCertificates != rhs.tlsCertificates {return false}
    if lhs.tlsCertificateSdsSecretConfigs != rhs.tlsCertificateSdsSecretConfigs {return false}
    if lhs._tlsCertificateCertificateProvider != rhs._tlsCertificateCertificateProvider {return false}
    if lhs.validationContextType != rhs.validationContextType {return false}
    if lhs.alpnProtocols != rhs.alpnProtocols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.protoMessageName + ".CertificateProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2:
        var v: Envoy_Config_Core_V3_TypedExtensionConfig?
        if let current = self.config {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.config = .typedConfig(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.protoMessageName + ".CombinedCertificateValidationContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_validation_context"),
    2: .standard(proto: "validation_context_sds_secret_config"),
    3: .standard(proto: "validation_context_certificate_provider"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._defaultValidationContext)
      case 2: try decoder.decodeSingularMessageField(value: &self._validationContextSdsSecretConfig)
      case 3: try decoder.decodeSingularMessageField(value: &self._validationContextCertificateProvider)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._defaultValidationContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._validationContextSdsSecretConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._validationContextCertificateProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext) -> Bool {
    if lhs._defaultValidationContext != rhs._defaultValidationContext {return false}
    if lhs._validationContextSdsSecretConfig != rhs._validationContextSdsSecretConfig {return false}
    if lhs._validationContextCertificateProvider != rhs._validationContextCertificateProvider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

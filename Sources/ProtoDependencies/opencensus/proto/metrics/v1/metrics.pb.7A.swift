// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opencensus/proto/metrics/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018, OpenCensus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This package describes the Metrics data model. It is currently experimental
// but may eventually become the wire format for metrics. Please see
// https://github.com/census-instrumentation/opencensus-specs/blob/master/stats/Metrics.md
// for more details.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines a Metric which has one or more timeseries.
public struct Opencensus_Proto_Metrics_V1_Metric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The descriptor of the Metric.
  /// TODO(issue #152): consider only sending the name of descriptor for
  /// optimization.
  public var metricDescriptor: Opencensus_Proto_Metrics_V1_MetricDescriptor {
    get {return _metricDescriptor ?? Opencensus_Proto_Metrics_V1_MetricDescriptor()}
    set {_metricDescriptor = newValue}
  }
  /// Returns true if `metricDescriptor` has been explicitly set.
  public var hasMetricDescriptor: Bool {return self._metricDescriptor != nil}
  /// Clears the value of `metricDescriptor`. Subsequent reads from it will return its default value.
  public mutating func clearMetricDescriptor() {self._metricDescriptor = nil}

  /// One or more timeseries for a single metric, where each timeseries has
  /// one or more points.
  public var timeseries: [Opencensus_Proto_Metrics_V1_TimeSeries] = []

  /// The resource for the metric. If unset, it may be set to a default value
  /// provided for a sequence of messages in an RPC stream.
  public var resource: Opencensus_Proto_Resource_V1_Resource {
    get {return _resource ?? Opencensus_Proto_Resource_V1_Resource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metricDescriptor: Opencensus_Proto_Metrics_V1_MetricDescriptor? = nil
  fileprivate var _resource: Opencensus_Proto_Resource_V1_Resource? = nil
}

/// Defines a metric type and its schema.
public struct Opencensus_Proto_Metrics_V1_MetricDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The metric type, including its DNS name prefix. It must be unique.
  public var name: String = String()

  /// A detailed description of the metric, which can be used in documentation.
  public var description_p: String = String()

  /// The unit in which the metric value is reported. Follows the format
  /// described by http://unitsofmeasure.org/ucum.html.
  public var unit: String = String()

  public var type: Opencensus_Proto_Metrics_V1_MetricDescriptor.TypeEnum = .unspecified

  /// The label keys associated with the metric descriptor.
  public var labelKeys: [Opencensus_Proto_Metrics_V1_LabelKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The kind of metric. It describes how the data is reported.
  ///
  /// A gauge is an instantaneous measurement of a value.
  ///
  /// A cumulative measurement is a value accumulated over a time interval. In
  /// a time series, cumulative measurements should have the same start time,
  /// increasing values and increasing end times, until an event resets the
  /// cumulative value to zero and sets a new start time for the following
  /// points.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not use this default value.
    case unspecified // = 0

    /// Integer gauge. The value can go both up and down.
    case gaugeInt64 // = 1

    /// Floating point gauge. The value can go both up and down.
    case gaugeDouble // = 2

    /// Distribution gauge measurement. The count and sum can go both up and
    /// down. Recorded values are always >= 0.
    /// Used in scenarios like a snapshot of time the current items in a queue
    /// have spent there.
    case gaugeDistribution // = 3

    /// Integer cumulative measurement. The value cannot decrease, if resets
    /// then the start_time should also be reset.
    case cumulativeInt64 // = 4

    /// Floating point cumulative measurement. The value cannot decrease, if
    /// resets then the start_time should also be reset. Recorded values are
    /// always >= 0.
    case cumulativeDouble // = 5

    /// Distribution cumulative measurement. The count and sum cannot decrease,
    /// if resets then the start_time should also be reset.
    case cumulativeDistribution // = 6

    /// Some frameworks implemented Histograms as a summary of observations
    /// (usually things like request durations and response sizes). While it
    /// also provides a total count of observations and a sum of all observed
    /// values, it calculates configurable percentiles over a sliding time
    /// window. This is not recommended, since it cannot be aggregated.
    case summary // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .gaugeInt64
      case 2: self = .gaugeDouble
      case 3: self = .gaugeDistribution
      case 4: self = .cumulativeInt64
      case 5: self = .cumulativeDouble
      case 6: self = .cumulativeDistribution
      case 7: self = .summary
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .gaugeInt64: return 1
      case .gaugeDouble: return 2
      case .gaugeDistribution: return 3
      case .cumulativeInt64: return 4
      case .cumulativeDouble: return 5
      case .cumulativeDistribution: return 6
      case .summary: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Opencensus_Proto_Metrics_V1_MetricDescriptor.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencensus_Proto_Metrics_V1_MetricDescriptor.TypeEnum] = [
    .unspecified,
    .gaugeInt64,
    .gaugeDouble,
    .gaugeDistribution,
    .cumulativeInt64,
    .cumulativeDouble,
    .cumulativeDistribution,
    .summary,
  ]
}

#endif  // swift(>=4.2)

/// Defines a label key associated with a metric descriptor.
public struct Opencensus_Proto_Metrics_V1_LabelKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key for the label.
  public var key: String = String()

  /// A human-readable description of what this label key represents.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of data points that describes the time-varying values
/// of a metric.
public struct Opencensus_Proto_Metrics_V1_TimeSeries {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must be present for cumulative metrics. The time when the cumulative value
  /// was reset to zero. Exclusive. The cumulative value is over the time interval
  /// (start_timestamp, timestamp]. If not specified, the backend can use the
  /// previous recorded value.
  public var startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTimestamp = newValue}
  }
  /// Returns true if `startTimestamp` has been explicitly set.
  public var hasStartTimestamp: Bool {return self._startTimestamp != nil}
  /// Clears the value of `startTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimestamp() {self._startTimestamp = nil}

  /// The set of label values that uniquely identify this timeseries. Applies to
  /// all points. The order of label values must match that of label keys in the
  /// metric descriptor.
  public var labelValues: [Opencensus_Proto_Metrics_V1_LabelValue] = []

  /// The data points of this timeseries. Point.value type MUST match the
  /// MetricDescriptor.type.
  public var points: [Opencensus_Proto_Metrics_V1_Point] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Opencensus_Proto_Metrics_V1_LabelValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value for the label.
  public var value: String = String()

  /// If false the value field is ignored and considered not set.
  /// This is used to differentiate a missing label from an empty string.
  public var hasValue_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A timestamped measurement.
public struct Opencensus_Proto_Metrics_V1_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The moment when this point was recorded. Inclusive.
  /// If not specified, the timestamp will be decided by the backend.
  public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// The actual point value.
  public var value: Opencensus_Proto_Metrics_V1_Point.OneOf_Value? = nil

  /// A 64-bit integer.
  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = value {return v}
      return 0
    }
    set {value = .int64Value(newValue)}
  }

  /// A 64-bit double-precision floating-point number.
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = value {return v}
      return 0
    }
    set {value = .doubleValue(newValue)}
  }

  /// A distribution value.
  public var distributionValue: Opencensus_Proto_Metrics_V1_DistributionValue {
    get {
      if case .distributionValue(let v)? = value {return v}
      return Opencensus_Proto_Metrics_V1_DistributionValue()
    }
    set {value = .distributionValue(newValue)}
  }

  /// A summary value. This is not recommended, since it cannot be aggregated.
  public var summaryValue: Opencensus_Proto_Metrics_V1_SummaryValue {
    get {
      if case .summaryValue(let v)? = value {return v}
      return Opencensus_Proto_Metrics_V1_SummaryValue()
    }
    set {value = .summaryValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The actual point value.
  public enum OneOf_Value: Equatable {
    /// A 64-bit integer.
    case int64Value(Int64)
    /// A 64-bit double-precision floating-point number.
    case doubleValue(Double)
    /// A distribution value.
    case distributionValue(Opencensus_Proto_Metrics_V1_DistributionValue)
    /// A summary value. This is not recommended, since it cannot be aggregated.
    case summaryValue(Opencensus_Proto_Metrics_V1_SummaryValue)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencensus_Proto_Metrics_V1_Point.OneOf_Value, rhs: Opencensus_Proto_Metrics_V1_Point.OneOf_Value) -> Bool {
      switch (lhs, rhs) {
      case (.int64Value(let l), .int64Value(let r)): return l == r
      case (.doubleValue(let l), .doubleValue(let r)): return l == r
      case (.distributionValue(let l), .distributionValue(let r)): return l == r
      case (.summaryValue(let l), .summaryValue(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Distribution contains summary statistics for a population of values. It
/// optionally contains a histogram representing the distribution of those
/// values across a set of buckets.
public struct Opencensus_Proto_Metrics_V1_DistributionValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of values in the population. Must be non-negative. This value
  /// must equal the sum of the values in bucket_counts if a histogram is
  /// provided.
  public var count: Int64 = 0

  /// The sum of the values in the population. If count is zero then this field
  /// must be zero.
  public var sum: Double = 0

  /// The sum of squared deviations from the mean of the values in the
  /// population. For values x_i this is:
  ///
  ///     Sum[i=1..n]((x_i - mean)^2)
  ///
  /// Knuth, "The Art of Computer Programming", Vol. 2, page 323, 3rd edition
  /// describes Welford's method for accumulating this sum in one pass.
  ///
  /// If count is zero then this field must be zero.
  public var sumOfSquaredDeviation: Double = 0

  /// Don't change bucket boundaries within a TimeSeries if your backend doesn't
  /// support this.
  /// TODO(issue #152): consider not required to send bucket options for
  /// optimization.
  public var bucketOptions: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions {
    get {return _bucketOptions ?? Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions()}
    set {_bucketOptions = newValue}
  }
  /// Returns true if `bucketOptions` has been explicitly set.
  public var hasBucketOptions: Bool {return self._bucketOptions != nil}
  /// Clears the value of `bucketOptions`. Subsequent reads from it will return its default value.
  public mutating func clearBucketOptions() {self._bucketOptions = nil}

  /// If the distribution does not have a histogram, then omit this field.
  /// If there is a histogram, then the sum of the values in the Bucket counts
  /// must equal the value in the count field of the distribution.
  public var buckets: [Opencensus_Proto_Metrics_V1_DistributionValue.Bucket] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A Distribution may optionally contain a histogram of the values in the
  /// population. The bucket boundaries for that histogram are described by
  /// BucketOptions.
  ///
  /// If bucket_options has no type, then there is no histogram associated with
  /// the Distribution.
  public struct BucketOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.OneOf_Type? = nil

    /// Bucket with explicit bounds.
    public var explicit: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit {
      get {
        if case .explicit(let v)? = type {return v}
        return Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit()
      }
      set {type = .explicit(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Type: Equatable {
      /// Bucket with explicit bounds.
      case explicit(Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit)

    #if !swift(>=4.1)
      public static func ==(lhs: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.OneOf_Type, rhs: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.OneOf_Type) -> Bool {
        switch (lhs, rhs) {
        case (.explicit(let l), .explicit(let r)): return l == r
        }
      }
    #endif
    }

    /// Specifies a set of buckets with arbitrary upper-bounds.
    /// This defines size(bounds) + 1 (= N) buckets. The boundaries for bucket
    /// index i are:
    ///
    /// [0, bucket_bounds[i]) for i == 0
    /// [bucket_bounds[i-1], bucket_bounds[i]) for 0 < i < N-1
    /// [bucket_bounds[i], +infinity) for i == N-1
    public struct Explicit {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The values must be strictly increasing and > 0.
      public var bounds: [Double] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct Bucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of values in each bucket of the histogram, as described in
    /// bucket_bounds.
    public var count: Int64 = 0

    /// If the distribution does not have a histogram, then omit this field.
    public var exemplar: Opencensus_Proto_Metrics_V1_DistributionValue.Exemplar {
      get {return _exemplar ?? Opencensus_Proto_Metrics_V1_DistributionValue.Exemplar()}
      set {_exemplar = newValue}
    }
    /// Returns true if `exemplar` has been explicitly set.
    public var hasExemplar: Bool {return self._exemplar != nil}
    /// Clears the value of `exemplar`. Subsequent reads from it will return its default value.
    public mutating func clearExemplar() {self._exemplar = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _exemplar: Opencensus_Proto_Metrics_V1_DistributionValue.Exemplar? = nil
  }

  /// Exemplars are example points that may be used to annotate aggregated
  /// Distribution values. They are metadata that gives information about a
  /// particular value added to a Distribution bucket.
  public struct Exemplar {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Value of the exemplar point. It determines which bucket the exemplar
    /// belongs to.
    public var value: Double = 0

    /// The observation (sampling) time of the above value.
    public var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_timestamp = newValue}
    }
    /// Returns true if `timestamp` has been explicitly set.
    public var hasTimestamp: Bool {return self._timestamp != nil}
    /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
    public mutating func clearTimestamp() {self._timestamp = nil}

    /// Contextual information about the example value.
    public var attachments: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _bucketOptions: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions? = nil
}

/// The start_timestamp only applies to the count and sum in the SummaryValue.
public struct Opencensus_Proto_Metrics_V1_SummaryValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The total number of recorded values since start_time. Optional since
  /// some systems don't expose this.
  public var count: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _count ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  public var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  public mutating func clearCount() {self._count = nil}

  /// The total sum of recorded values since start_time. Optional since some
  /// systems don't expose this. If count is zero then this field must be zero.
  /// This field must be unset if the sum is not available.
  public var sum: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _sum ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_sum = newValue}
  }
  /// Returns true if `sum` has been explicitly set.
  public var hasSum: Bool {return self._sum != nil}
  /// Clears the value of `sum`. Subsequent reads from it will return its default value.
  public mutating func clearSum() {self._sum = nil}

  /// Values calculated over an arbitrary time window.
  public var snapshot: Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot {
    get {return _snapshot ?? Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  public var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  public mutating func clearSnapshot() {self._snapshot = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The values in this message can be reset at arbitrary unknown times, with
  /// the requirement that all of them are reset at the same time.
  public struct Snapshot {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of values in the snapshot. Optional since some systems don't
    /// expose this.
    public var count: SwiftProtobuf.Google_Protobuf_Int64Value {
      get {return _count ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    public var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    public mutating func clearCount() {self._count = nil}

    /// The sum of values in the snapshot. Optional since some systems don't
    /// expose this. If count is zero then this field must be zero or not set
    /// (if not supported).
    public var sum: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {return _sum ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    public var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    public mutating func clearSum() {self._sum = nil}

    /// A list of values at different percentiles of the distribution calculated
    /// from the current snapshot. The percentiles must be strictly increasing.
    public var percentileValues: [Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot.ValueAtPercentile] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents the value at a given percentile of a distribution.
    public struct ValueAtPercentile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The percentile of a distribution. Must be in the interval
      /// (0.0, 100.0].
      public var percentile: Double = 0

      /// The value at the given percentile of a distribution.
      public var value: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _count: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
    fileprivate var _sum: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  }

  public init() {}

  fileprivate var _count: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _sum: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  fileprivate var _snapshot: Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencensus.proto.metrics.v1"

extension Opencensus_Proto_Metrics_V1_Metric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_descriptor"),
    2: .same(proto: "timeseries"),
    3: .same(proto: "resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._metricDescriptor)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.timeseries)
      case 3: try decoder.decodeSingularMessageField(value: &self._resource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metricDescriptor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.timeseries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeseries, fieldNumber: 2)
    }
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_Metric, rhs: Opencensus_Proto_Metrics_V1_Metric) -> Bool {
    if lhs._metricDescriptor != rhs._metricDescriptor {return false}
    if lhs.timeseries != rhs.timeseries {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_MetricDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetricDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "unit"),
    4: .same(proto: "type"),
    5: .standard(proto: "label_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularStringField(value: &self.unit)
      case 4: try decoder.decodeSingularEnumField(value: &self.type)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.labelKeys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 3)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.labelKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelKeys, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_MetricDescriptor, rhs: Opencensus_Proto_Metrics_V1_MetricDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.type != rhs.type {return false}
    if lhs.labelKeys != rhs.labelKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_MetricDescriptor.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "GAUGE_INT64"),
    2: .same(proto: "GAUGE_DOUBLE"),
    3: .same(proto: "GAUGE_DISTRIBUTION"),
    4: .same(proto: "CUMULATIVE_INT64"),
    5: .same(proto: "CUMULATIVE_DOUBLE"),
    6: .same(proto: "CUMULATIVE_DISTRIBUTION"),
    7: .same(proto: "SUMMARY"),
  ]
}

extension Opencensus_Proto_Metrics_V1_LabelKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_LabelKey, rhs: Opencensus_Proto_Metrics_V1_LabelKey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_TimeSeries: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeries"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_timestamp"),
    2: .standard(proto: "label_values"),
    3: .same(proto: "points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._startTimestamp)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.labelValues)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.points)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.labelValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelValues, fieldNumber: 2)
    }
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_TimeSeries, rhs: Opencensus_Proto_Metrics_V1_TimeSeries) -> Bool {
    if lhs._startTimestamp != rhs._startTimestamp {return false}
    if lhs.labelValues != rhs.labelValues {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_LabelValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "has_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.value)
      case 2: try decoder.decodeSingularBoolField(value: &self.hasValue_p)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.hasValue_p != false {
      try visitor.visitSingularBoolField(value: self.hasValue_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_LabelValue, rhs: Opencensus_Proto_Metrics_V1_LabelValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.hasValue_p != rhs.hasValue_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .standard(proto: "int64_value"),
    3: .standard(proto: "double_value"),
    4: .standard(proto: "distribution_value"),
    5: .standard(proto: "summary_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 2:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .int64Value(v)}
      case 3:
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.value = .doubleValue(v)}
      case 4:
        var v: Opencensus_Proto_Metrics_V1_DistributionValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .distributionValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .distributionValue(v)}
      case 5:
        var v: Opencensus_Proto_Metrics_V1_SummaryValue?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .summaryValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .summaryValue(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    switch self.value {
    case .int64Value(let v)?:
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    case .doubleValue(let v)?:
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    case .distributionValue(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .summaryValue(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_Point, rhs: Opencensus_Proto_Metrics_V1_Point) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_DistributionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributionValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "sum"),
    3: .standard(proto: "sum_of_squared_deviation"),
    4: .standard(proto: "bucket_options"),
    5: .same(proto: "buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.count)
      case 2: try decoder.decodeSingularDoubleField(value: &self.sum)
      case 3: try decoder.decodeSingularDoubleField(value: &self.sumOfSquaredDeviation)
      case 4: try decoder.decodeSingularMessageField(value: &self._bucketOptions)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.buckets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.sum != 0 {
      try visitor.visitSingularDoubleField(value: self.sum, fieldNumber: 2)
    }
    if self.sumOfSquaredDeviation != 0 {
      try visitor.visitSingularDoubleField(value: self.sumOfSquaredDeviation, fieldNumber: 3)
    }
    if let v = self._bucketOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.buckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buckets, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_DistributionValue, rhs: Opencensus_Proto_Metrics_V1_DistributionValue) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.sum != rhs.sum {return false}
    if lhs.sumOfSquaredDeviation != rhs.sumOfSquaredDeviation {return false}
    if lhs._bucketOptions != rhs._bucketOptions {return false}
    if lhs.buckets != rhs.buckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Metrics_V1_DistributionValue.protoMessageName + ".BucketOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "explicit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .explicit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .explicit(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .explicit(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions, rhs: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.protoMessageName + ".Explicit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bounds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedDoubleField(value: &self.bounds)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bounds.isEmpty {
      try visitor.visitPackedDoubleField(value: self.bounds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit, rhs: Opencensus_Proto_Metrics_V1_DistributionValue.BucketOptions.Explicit) -> Bool {
    if lhs.bounds != rhs.bounds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_DistributionValue.Bucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Metrics_V1_DistributionValue.protoMessageName + ".Bucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "exemplar"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.count)
      case 2: try decoder.decodeSingularMessageField(value: &self._exemplar)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if let v = self._exemplar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_DistributionValue.Bucket, rhs: Opencensus_Proto_Metrics_V1_DistributionValue.Bucket) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs._exemplar != rhs._exemplar {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_DistributionValue.Exemplar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Metrics_V1_DistributionValue.protoMessageName + ".Exemplar"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "timestamp"),
    3: .same(proto: "attachments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.value)
      case 2: try decoder.decodeSingularMessageField(value: &self._timestamp)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attachments)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.attachments.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attachments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_DistributionValue.Exemplar, rhs: Opencensus_Proto_Metrics_V1_DistributionValue.Exemplar) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_SummaryValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SummaryValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "sum"),
    3: .same(proto: "snapshot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._count)
      case 2: try decoder.decodeSingularMessageField(value: &self._sum)
      case 3: try decoder.decodeSingularMessageField(value: &self._snapshot)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._count {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_SummaryValue, rhs: Opencensus_Proto_Metrics_V1_SummaryValue) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Metrics_V1_SummaryValue.protoMessageName + ".Snapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "sum"),
    3: .standard(proto: "percentile_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._count)
      case 2: try decoder.decodeSingularMessageField(value: &self._sum)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.percentileValues)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._count {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.percentileValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.percentileValues, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot, rhs: Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.percentileValues != rhs.percentileValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot.ValueAtPercentile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot.protoMessageName + ".ValueAtPercentile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentile"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.percentile)
      case 2: try decoder.decodeSingularDoubleField(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.percentile != 0 {
      try visitor.visitSingularDoubleField(value: self.percentile, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot.ValueAtPercentile, rhs: Opencensus_Proto_Metrics_V1_SummaryValue.Snapshot.ValueAtPercentile) -> Bool {
    if lhs.percentile != rhs.percentile {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

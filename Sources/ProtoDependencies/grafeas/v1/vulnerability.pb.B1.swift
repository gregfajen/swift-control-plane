// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: grafeas/v1/vulnerability.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Note provider assigned severity/impact ranking.
public enum Grafeas_V1_Severity: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown.
  case unspecified // = 0

  /// Minimal severity.
  case minimal // = 1

  /// Low severity.
  case low // = 2

  /// Medium severity.
  case medium // = 3

  /// High severity.
  case high // = 4

  /// Critical severity.
  case critical // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .minimal
    case 2: self = .low
    case 3: self = .medium
    case 4: self = .high
    case 5: self = .critical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .minimal: return 1
    case .low: return 2
    case .medium: return 3
    case .high: return 4
    case .critical: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grafeas_V1_Severity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Grafeas_V1_Severity] = [
    .unspecified,
    .minimal,
    .low,
    .medium,
    .high,
    .critical,
  ]
}

#endif  // swift(>=4.2)

/// A security vulnerability that can be found in resources.
public struct Grafeas_V1_VulnerabilityNote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The CVSS score of this vulnerability. CVSS score is on a scale of 0 - 10
  /// where 0 indicates low severity and 10 indicates high severity.
  public var cvssScore: Float = 0

  /// The note provider assigned severity of this vulnerability.
  public var severity: Grafeas_V1_Severity = .unspecified

  /// Details of all known distros and packages affected by this vulnerability.
  public var details: [Grafeas_V1_VulnerabilityNote.Detail] = []

  /// The full description of the CVSSv3 for this vulnerability.
  public var cvssV3: Grafeas_V1_CVSSv3 {
    get {return _cvssV3 ?? Grafeas_V1_CVSSv3()}
    set {_cvssV3 = newValue}
  }
  /// Returns true if `cvssV3` has been explicitly set.
  public var hasCvssV3: Bool {return self._cvssV3 != nil}
  /// Clears the value of `cvssV3`. Subsequent reads from it will return its default value.
  public mutating func clearCvssV3() {self._cvssV3 = nil}

  /// Windows details get their own format because the information format and
  /// model don't match a normal detail. Specifically Windows updates are done as
  /// patches, thus Windows vulnerabilities really are a missing package, rather
  /// than a package being at an incorrect version.
  public var windowsDetails: [Grafeas_V1_VulnerabilityNote.WindowsDetail] = []

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  public var sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _sourceUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_sourceUpdateTime = newValue}
  }
  /// Returns true if `sourceUpdateTime` has been explicitly set.
  public var hasSourceUpdateTime: Bool {return self._sourceUpdateTime != nil}
  /// Clears the value of `sourceUpdateTime`. Subsequent reads from it will return its default value.
  public mutating func clearSourceUpdateTime() {self._sourceUpdateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A detail for a distro and package affected by this vulnerability and its
  /// associated fix (if one is available).
  public struct Detail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The distro assigned severity of this vulnerability.
    public var severityName: String = String()

    /// A vendor-specific description of this vulnerability.
    public var description_p: String = String()

    /// The type of package; whether native or non native (e.g., ruby gems,
    /// node.js packages, etc.).
    public var packageType: String = String()

    /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
    /// vulnerability affects.
    public var affectedCpeUri: String = String()

    /// Required. The package this vulnerability affects.
    public var affectedPackage: String = String()

    /// The version number at the start of an interval in which this
    /// vulnerability exists. A vulnerability can affect a package between
    /// version numbers that are disjoint sets of intervals (example:
    /// [1.0.0-1.1.0], [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be
    /// represented in its own Detail. If a specific affected version is provided
    /// by a vulnerability database, affected_version_start and
    /// affected_version_end will be the same in that Detail.
    public var affectedVersionStart: Grafeas_V1_Version {
      get {return _affectedVersionStart ?? Grafeas_V1_Version()}
      set {_affectedVersionStart = newValue}
    }
    /// Returns true if `affectedVersionStart` has been explicitly set.
    public var hasAffectedVersionStart: Bool {return self._affectedVersionStart != nil}
    /// Clears the value of `affectedVersionStart`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedVersionStart() {self._affectedVersionStart = nil}

    /// The version number at the end of an interval in which this vulnerability
    /// exists. A vulnerability can affect a package between version numbers
    /// that are disjoint sets of intervals (example: [1.0.0-1.1.0],
    /// [2.4.6-2.4.8] and [4.5.6-4.6.8]) each of which will be represented in its
    /// own Detail. If a specific affected version is provided by a vulnerability
    /// database, affected_version_start and affected_version_end will be the
    /// same in that Detail.
    public var affectedVersionEnd: Grafeas_V1_Version {
      get {return _affectedVersionEnd ?? Grafeas_V1_Version()}
      set {_affectedVersionEnd = newValue}
    }
    /// Returns true if `affectedVersionEnd` has been explicitly set.
    public var hasAffectedVersionEnd: Bool {return self._affectedVersionEnd != nil}
    /// Clears the value of `affectedVersionEnd`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedVersionEnd() {self._affectedVersionEnd = nil}

    /// The distro recommended [CPE URI](https://cpe.mitre.org/specification/)
    /// to update to that contains a fix for this vulnerability. It is possible
    /// for this to be different from the affected_cpe_uri.
    public var fixedCpeUri: String = String()

    /// The distro recommended package to update to that contains a fix for this
    /// vulnerability. It is possible for this to be different from the
    /// affected_package.
    public var fixedPackage: String = String()

    /// The distro recommended version to update to that contains a
    /// fix for this vulnerability. Setting this to VersionKind.MAXIMUM means no
    /// such version is yet available.
    public var fixedVersion: Grafeas_V1_Version {
      get {return _fixedVersion ?? Grafeas_V1_Version()}
      set {_fixedVersion = newValue}
    }
    /// Returns true if `fixedVersion` has been explicitly set.
    public var hasFixedVersion: Bool {return self._fixedVersion != nil}
    /// Clears the value of `fixedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearFixedVersion() {self._fixedVersion = nil}

    /// Whether this detail is obsolete. Occurrences are expected not to point to
    /// obsolete details.
    public var isObsolete: Bool = false

    /// The time this information was last changed at the source. This is an
    /// upstream timestamp from the underlying information source - e.g. Ubuntu
    /// security tracker.
    public var sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _sourceUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_sourceUpdateTime = newValue}
    }
    /// Returns true if `sourceUpdateTime` has been explicitly set.
    public var hasSourceUpdateTime: Bool {return self._sourceUpdateTime != nil}
    /// Clears the value of `sourceUpdateTime`. Subsequent reads from it will return its default value.
    public mutating func clearSourceUpdateTime() {self._sourceUpdateTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _affectedVersionStart: Grafeas_V1_Version? = nil
    fileprivate var _affectedVersionEnd: Grafeas_V1_Version? = nil
    fileprivate var _fixedVersion: Grafeas_V1_Version? = nil
    fileprivate var _sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public struct WindowsDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
    /// vulnerability affects.
    public var cpeUri: String = String()

    /// Required. The name of this vulnerability.
    public var name: String = String()

    /// The description of this vulnerability.
    public var description_p: String = String()

    /// Required. The names of the KBs which have hotfixes to mitigate this
    /// vulnerability. Note that there may be multiple hotfixes (and thus
    /// multiple KBs) that mitigate a given vulnerability. Currently any listed
    /// KBs presence is considered a fix.
    public var fixingKbs: [Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct KnowledgeBase {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The KB name (generally of the form KB[0-9]+ (e.g., KB123456)).
      public var name: String = String()

      /// A link to the KB in the [Windows update catalog]
      /// (https://www.catalog.update.microsoft.com/).
      public var url: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _cvssV3: Grafeas_V1_CVSSv3? = nil
  fileprivate var _sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// An occurrence of a severity vulnerability on a resource.
public struct Grafeas_V1_VulnerabilityOccurrence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of package; whether native or non native (e.g., ruby gems, node.js
  /// packages, etc.).
  public var type: String = String()

  /// Output only. The note provider assigned severity of this vulnerability.
  public var severity: Grafeas_V1_Severity = .unspecified

  /// Output only. The CVSS score of this vulnerability. CVSS score is on a
  /// scale of 0 - 10 where 0 indicates low severity and 10 indicates high
  /// severity.
  public var cvssScore: Float = 0

  /// Required. The set of affected locations and their fixes (if available)
  /// within the associated resource.
  public var packageIssue: [Grafeas_V1_VulnerabilityOccurrence.PackageIssue] = []

  /// Output only. A one sentence description of this vulnerability.
  public var shortDescription: String = String()

  /// Output only. A detailed description of this vulnerability.
  public var longDescription: String = String()

  /// Output only. URLs related to this vulnerability.
  public var relatedUrls: [Grafeas_V1_RelatedUrl] = []

  /// The distro assigned severity for this vulnerability when it is available,
  /// otherwise this is the note provider assigned severity.
  public var effectiveSeverity: Grafeas_V1_Severity = .unspecified

  /// Output only. Whether at least one of the affected packages has a fix
  /// available.
  public var fixAvailable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A detail for a distro and package this vulnerability occurrence was found
  /// in and its associated fix (if one is available).
  public struct PackageIssue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The [CPE URI](https://cpe.mitre.org/specification/) this
    /// vulnerability was found in.
    public var affectedCpeUri: String = String()

    /// Required. The package this vulnerability was found in.
    public var affectedPackage: String = String()

    /// Required. The version of the package that is installed on the resource
    /// affected by this vulnerability.
    public var affectedVersion: Grafeas_V1_Version {
      get {return _affectedVersion ?? Grafeas_V1_Version()}
      set {_affectedVersion = newValue}
    }
    /// Returns true if `affectedVersion` has been explicitly set.
    public var hasAffectedVersion: Bool {return self._affectedVersion != nil}
    /// Clears the value of `affectedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedVersion() {self._affectedVersion = nil}

    /// The [CPE URI](https://cpe.mitre.org/specification/) this vulnerability
    /// was fixed in. It is possible for this to be different from the
    /// affected_cpe_uri.
    public var fixedCpeUri: String = String()

    /// The package this vulnerability was fixed in. It is possible for this to
    /// be different from the affected_package.
    public var fixedPackage: String = String()

    /// Required. The version of the package this vulnerability was fixed in.
    /// Setting this to VersionKind.MAXIMUM means no fix is yet available.
    public var fixedVersion: Grafeas_V1_Version {
      get {return _fixedVersion ?? Grafeas_V1_Version()}
      set {_fixedVersion = newValue}
    }
    /// Returns true if `fixedVersion` has been explicitly set.
    public var hasFixedVersion: Bool {return self._fixedVersion != nil}
    /// Clears the value of `fixedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearFixedVersion() {self._fixedVersion = nil}

    /// Output only. Whether a fix is available for this package.
    public var fixAvailable: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _affectedVersion: Grafeas_V1_Version? = nil
    fileprivate var _fixedVersion: Grafeas_V1_Version? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grafeas.v1"

extension Grafeas_V1_Severity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEVERITY_UNSPECIFIED"),
    1: .same(proto: "MINIMAL"),
    2: .same(proto: "LOW"),
    3: .same(proto: "MEDIUM"),
    4: .same(proto: "HIGH"),
    5: .same(proto: "CRITICAL"),
  ]
}

extension Grafeas_V1_VulnerabilityNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VulnerabilityNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cvss_score"),
    2: .same(proto: "severity"),
    3: .same(proto: "details"),
    4: .standard(proto: "cvss_v3"),
    5: .standard(proto: "windows_details"),
    6: .standard(proto: "source_update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFloatField(value: &self.cvssScore)
      case 2: try decoder.decodeSingularEnumField(value: &self.severity)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.details)
      case 4: try decoder.decodeSingularMessageField(value: &self._cvssV3)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.windowsDetails)
      case 6: try decoder.decodeSingularMessageField(value: &self._sourceUpdateTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cvssScore != 0 {
      try visitor.visitSingularFloatField(value: self.cvssScore, fieldNumber: 1)
    }
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 3)
    }
    if let v = self._cvssV3 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.windowsDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.windowsDetails, fieldNumber: 5)
    }
    if let v = self._sourceUpdateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote, rhs: Grafeas_V1_VulnerabilityNote) -> Bool {
    if lhs.cvssScore != rhs.cvssScore {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.details != rhs.details {return false}
    if lhs._cvssV3 != rhs._cvssV3 {return false}
    if lhs.windowsDetails != rhs.windowsDetails {return false}
    if lhs._sourceUpdateTime != rhs._sourceUpdateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityNote.Detail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityNote.protoMessageName + ".Detail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "severity_name"),
    2: .same(proto: "description"),
    3: .standard(proto: "package_type"),
    4: .standard(proto: "affected_cpe_uri"),
    5: .standard(proto: "affected_package"),
    6: .standard(proto: "affected_version_start"),
    7: .standard(proto: "affected_version_end"),
    8: .standard(proto: "fixed_cpe_uri"),
    9: .standard(proto: "fixed_package"),
    10: .standard(proto: "fixed_version"),
    11: .standard(proto: "is_obsolete"),
    12: .standard(proto: "source_update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.severityName)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularStringField(value: &self.packageType)
      case 4: try decoder.decodeSingularStringField(value: &self.affectedCpeUri)
      case 5: try decoder.decodeSingularStringField(value: &self.affectedPackage)
      case 6: try decoder.decodeSingularMessageField(value: &self._affectedVersionStart)
      case 7: try decoder.decodeSingularMessageField(value: &self._affectedVersionEnd)
      case 8: try decoder.decodeSingularStringField(value: &self.fixedCpeUri)
      case 9: try decoder.decodeSingularStringField(value: &self.fixedPackage)
      case 10: try decoder.decodeSingularMessageField(value: &self._fixedVersion)
      case 11: try decoder.decodeSingularBoolField(value: &self.isObsolete)
      case 12: try decoder.decodeSingularMessageField(value: &self._sourceUpdateTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.severityName.isEmpty {
      try visitor.visitSingularStringField(value: self.severityName, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.packageType.isEmpty {
      try visitor.visitSingularStringField(value: self.packageType, fieldNumber: 3)
    }
    if !self.affectedCpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedCpeUri, fieldNumber: 4)
    }
    if !self.affectedPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedPackage, fieldNumber: 5)
    }
    if let v = self._affectedVersionStart {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._affectedVersionEnd {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.fixedCpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedCpeUri, fieldNumber: 8)
    }
    if !self.fixedPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedPackage, fieldNumber: 9)
    }
    if let v = self._fixedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if self.isObsolete != false {
      try visitor.visitSingularBoolField(value: self.isObsolete, fieldNumber: 11)
    }
    if let v = self._sourceUpdateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote.Detail, rhs: Grafeas_V1_VulnerabilityNote.Detail) -> Bool {
    if lhs.severityName != rhs.severityName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.packageType != rhs.packageType {return false}
    if lhs.affectedCpeUri != rhs.affectedCpeUri {return false}
    if lhs.affectedPackage != rhs.affectedPackage {return false}
    if lhs._affectedVersionStart != rhs._affectedVersionStart {return false}
    if lhs._affectedVersionEnd != rhs._affectedVersionEnd {return false}
    if lhs.fixedCpeUri != rhs.fixedCpeUri {return false}
    if lhs.fixedPackage != rhs.fixedPackage {return false}
    if lhs._fixedVersion != rhs._fixedVersion {return false}
    if lhs.isObsolete != rhs.isObsolete {return false}
    if lhs._sourceUpdateTime != rhs._sourceUpdateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityNote.WindowsDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityNote.protoMessageName + ".WindowsDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpe_uri"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "fixing_kbs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cpeUri)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.fixingKbs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.cpeUri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.fixingKbs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fixingKbs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote.WindowsDetail, rhs: Grafeas_V1_VulnerabilityNote.WindowsDetail) -> Bool {
    if lhs.cpeUri != rhs.cpeUri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.fixingKbs != rhs.fixingKbs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityNote.WindowsDetail.protoMessageName + ".KnowledgeBase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.url)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase, rhs: Grafeas_V1_VulnerabilityNote.WindowsDetail.KnowledgeBase) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityOccurrence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VulnerabilityOccurrence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "severity"),
    3: .standard(proto: "cvss_score"),
    4: .standard(proto: "package_issue"),
    5: .standard(proto: "short_description"),
    6: .standard(proto: "long_description"),
    7: .standard(proto: "related_urls"),
    8: .standard(proto: "effective_severity"),
    9: .standard(proto: "fix_available"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeSingularEnumField(value: &self.severity)
      case 3: try decoder.decodeSingularFloatField(value: &self.cvssScore)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.packageIssue)
      case 5: try decoder.decodeSingularStringField(value: &self.shortDescription)
      case 6: try decoder.decodeSingularStringField(value: &self.longDescription)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.relatedUrls)
      case 8: try decoder.decodeSingularEnumField(value: &self.effectiveSeverity)
      case 9: try decoder.decodeSingularBoolField(value: &self.fixAvailable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if self.cvssScore != 0 {
      try visitor.visitSingularFloatField(value: self.cvssScore, fieldNumber: 3)
    }
    if !self.packageIssue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packageIssue, fieldNumber: 4)
    }
    if !self.shortDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.shortDescription, fieldNumber: 5)
    }
    if !self.longDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.longDescription, fieldNumber: 6)
    }
    if !self.relatedUrls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relatedUrls, fieldNumber: 7)
    }
    if self.effectiveSeverity != .unspecified {
      try visitor.visitSingularEnumField(value: self.effectiveSeverity, fieldNumber: 8)
    }
    if self.fixAvailable != false {
      try visitor.visitSingularBoolField(value: self.fixAvailable, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityOccurrence, rhs: Grafeas_V1_VulnerabilityOccurrence) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.cvssScore != rhs.cvssScore {return false}
    if lhs.packageIssue != rhs.packageIssue {return false}
    if lhs.shortDescription != rhs.shortDescription {return false}
    if lhs.longDescription != rhs.longDescription {return false}
    if lhs.relatedUrls != rhs.relatedUrls {return false}
    if lhs.effectiveSeverity != rhs.effectiveSeverity {return false}
    if lhs.fixAvailable != rhs.fixAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1_VulnerabilityOccurrence.PackageIssue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1_VulnerabilityOccurrence.protoMessageName + ".PackageIssue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "affected_cpe_uri"),
    2: .standard(proto: "affected_package"),
    3: .standard(proto: "affected_version"),
    4: .standard(proto: "fixed_cpe_uri"),
    5: .standard(proto: "fixed_package"),
    6: .standard(proto: "fixed_version"),
    7: .standard(proto: "fix_available"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.affectedCpeUri)
      case 2: try decoder.decodeSingularStringField(value: &self.affectedPackage)
      case 3: try decoder.decodeSingularMessageField(value: &self._affectedVersion)
      case 4: try decoder.decodeSingularStringField(value: &self.fixedCpeUri)
      case 5: try decoder.decodeSingularStringField(value: &self.fixedPackage)
      case 6: try decoder.decodeSingularMessageField(value: &self._fixedVersion)
      case 7: try decoder.decodeSingularBoolField(value: &self.fixAvailable)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.affectedCpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedCpeUri, fieldNumber: 1)
    }
    if !self.affectedPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.affectedPackage, fieldNumber: 2)
    }
    if let v = self._affectedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.fixedCpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedCpeUri, fieldNumber: 4)
    }
    if !self.fixedPackage.isEmpty {
      try visitor.visitSingularStringField(value: self.fixedPackage, fieldNumber: 5)
    }
    if let v = self._fixedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.fixAvailable != false {
      try visitor.visitSingularBoolField(value: self.fixAvailable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1_VulnerabilityOccurrence.PackageIssue, rhs: Grafeas_V1_VulnerabilityOccurrence.PackageIssue) -> Bool {
    if lhs.affectedCpeUri != rhs.affectedCpeUri {return false}
    if lhs.affectedPackage != rhs.affectedPackage {return false}
    if lhs._affectedVersion != rhs._affectedVersion {return false}
    if lhs.fixedCpeUri != rhs.fixedCpeUri {return false}
    if lhs.fixedPackage != rhs.fixedPackage {return false}
    if lhs._fixedVersion != rhs._fixedVersion {return false}
    if lhs.fixAvailable != rhs.fixAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/http/compressor/v3/compressor.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 7]
public struct Envoy_Extensions_Filters_Http_Compressor_V3_Compressor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum response length, in bytes, which will trigger compression. The default value is 30.
  public var contentLength: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _contentLength ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_contentLength = newValue}
  }
  /// Returns true if `contentLength` has been explicitly set.
  public var hasContentLength: Bool {return self._contentLength != nil}
  /// Clears the value of `contentLength`. Subsequent reads from it will return its default value.
  public mutating func clearContentLength() {self._contentLength = nil}

  /// Set of strings that allows specifying which mime-types yield compression; e.g.,
  /// application/json, text/html, etc. When this field is not defined, compression will be applied
  /// to the following mime-types: "application/javascript", "application/json",
  /// "application/xhtml+xml", "image/svg+xml", "text/css", "text/html", "text/plain", "text/xml"
  /// and their synonyms.
  public var contentType: [String] = []

  /// If true, disables compression when the response contains an etag header. When it is false, the
  /// filter will preserve weak etags and remove the ones that require strong validation.
  public var disableOnEtagHeader: Bool = false

  /// If true, removes accept-encoding from the request headers before dispatching it to the upstream
  /// so that responses do not get compressed before reaching the filter.
  /// .. attention:
  ///
  ///    To avoid interfering with other compression filters in the same chain use this option in
  ///    the filter closest to the upstream.
  public var removeAcceptEncodingHeader: Bool = false

  /// Runtime flag that controls whether the filter is enabled or not. If set to false, the
  /// filter will operate as a pass-through filter. If not specified, defaults to enabled.
  public var runtimeEnabled: Envoy_Config_Core_V3_RuntimeFeatureFlag {
    get {return _runtimeEnabled ?? Envoy_Config_Core_V3_RuntimeFeatureFlag()}
    set {_runtimeEnabled = newValue}
  }
  /// Returns true if `runtimeEnabled` has been explicitly set.
  public var hasRuntimeEnabled: Bool {return self._runtimeEnabled != nil}
  /// Clears the value of `runtimeEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearRuntimeEnabled() {self._runtimeEnabled = nil}

  /// A compressor library to use for compression. Currently only
  /// :ref:`envoy.filters.http.compressor.gzip<envoy_api_msg_extensions.compression.gzip.compressor.v3.Gzip>`
  /// is included in Envoy.
  /// This field is ignored if used in the context of the gzip http-filter, but is mandatory otherwise.
  public var compressorLibrary: Envoy_Config_Core_V3_TypedExtensionConfig {
    get {return _compressorLibrary ?? Envoy_Config_Core_V3_TypedExtensionConfig()}
    set {_compressorLibrary = newValue}
  }
  /// Returns true if `compressorLibrary` has been explicitly set.
  public var hasCompressorLibrary: Bool {return self._compressorLibrary != nil}
  /// Clears the value of `compressorLibrary`. Subsequent reads from it will return its default value.
  public mutating func clearCompressorLibrary() {self._compressorLibrary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contentLength: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _runtimeEnabled: Envoy_Config_Core_V3_RuntimeFeatureFlag? = nil
  fileprivate var _compressorLibrary: Envoy_Config_Core_V3_TypedExtensionConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.http.compressor.v3"

extension Envoy_Extensions_Filters_Http_Compressor_V3_Compressor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Compressor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_length"),
    2: .standard(proto: "content_type"),
    3: .standard(proto: "disable_on_etag_header"),
    4: .standard(proto: "remove_accept_encoding_header"),
    5: .standard(proto: "runtime_enabled"),
    6: .standard(proto: "compressor_library"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._contentLength)
      case 2: try decoder.decodeRepeatedStringField(value: &self.contentType)
      case 3: try decoder.decodeSingularBoolField(value: &self.disableOnEtagHeader)
      case 4: try decoder.decodeSingularBoolField(value: &self.removeAcceptEncodingHeader)
      case 5: try decoder.decodeSingularMessageField(value: &self._runtimeEnabled)
      case 6: try decoder.decodeSingularMessageField(value: &self._compressorLibrary)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contentLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.contentType.isEmpty {
      try visitor.visitRepeatedStringField(value: self.contentType, fieldNumber: 2)
    }
    if self.disableOnEtagHeader != false {
      try visitor.visitSingularBoolField(value: self.disableOnEtagHeader, fieldNumber: 3)
    }
    if self.removeAcceptEncodingHeader != false {
      try visitor.visitSingularBoolField(value: self.removeAcceptEncodingHeader, fieldNumber: 4)
    }
    if let v = self._runtimeEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._compressorLibrary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Compressor_V3_Compressor, rhs: Envoy_Extensions_Filters_Http_Compressor_V3_Compressor) -> Bool {
    if lhs._contentLength != rhs._contentLength {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.disableOnEtagHeader != rhs.disableOnEtagHeader {return false}
    if lhs.removeAcceptEncodingHeader != rhs.removeAcceptEncodingHeader {return false}
    if lhs._runtimeEnabled != rhs._runtimeEnabled {return false}
    if lhs._compressorLibrary != rhs._compressorLibrary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

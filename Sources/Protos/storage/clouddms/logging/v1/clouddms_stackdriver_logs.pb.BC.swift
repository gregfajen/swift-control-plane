// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: storage/clouddms/logging/v1/clouddms_stackdriver_logs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The database engines.
public enum Storage_Clouddms_Logging_V1_DatabaseEngine: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The source database engine of the migration job is unknown.
  case unspecified // = 0

  /// The source engine is MySQL.
  case mysql // = 1

  /// The source engine is PostgreSQL.
  case postgresql // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mysql
    case 2: self = .postgresql
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mysql: return 1
    case .postgresql: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Storage_Clouddms_Logging_V1_DatabaseEngine: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_DatabaseEngine] = [
    .unspecified,
    .mysql,
    .postgresql,
  ]
}

#endif  // swift(>=4.2)

/// The database providers.
public enum Storage_Clouddms_Logging_V1_DatabaseProvider: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The database provider is unknown.
  case unspecified // = 0

  /// CloudSQL runs the database.
  case cloudsql // = 1

  /// RDS runs the database.
  case rds // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .cloudsql
    case 2: self = .rds
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .cloudsql: return 1
    case .rds: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Storage_Clouddms_Logging_V1_DatabaseProvider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_DatabaseProvider] = [
    .unspecified,
    .cloudsql,
    .rds,
  ]
}

#endif  // swift(>=4.2)

/// A message defining the database engine and provider.
public struct Storage_Clouddms_Logging_V1_DatabaseType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database provider.
  public var provider: Storage_Clouddms_Logging_V1_DatabaseProvider = .unspecified

  /// The database engine.
  public var engine: Storage_Clouddms_Logging_V1_DatabaseEngine = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Migration job as stored in Stackdriver logs.
/// NEXT_TAG = 36.
public struct Storage_Clouddms_Logging_V1_LoggedMigrationJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique identifier for a migration job.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Labels.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// The display name.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// The current migration job state.
  public var state: Storage_Clouddms_Logging_V1_LoggedMigrationJob.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The current migration job phase.
  public var phase: Storage_Clouddms_Logging_V1_LoggedMigrationJob.Phase {
    get {return _storage._phase}
    set {_uniqueStorage()._phase = newValue}
  }

  /// The migration job type.
  public var type: Storage_Clouddms_Logging_V1_LoggedMigrationJob.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// An optional dump path (gs://[BUCKET_NAME]/[OBJECT_NAME]).
  public var dumpPath: String {
    get {return _storage._dumpPath}
    set {_uniqueStorage()._dumpPath = newValue}
  }

  /// The migration job source connection profile name.
  public var source: String {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  /// The migration job destination connection profile name.
  public var destination: String {
    get {return _storage._destination}
    set {_uniqueStorage()._destination = newValue}
  }

  /// the migration job duration in seconds.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  /// Type of connectivity to source database.
  public var connectivityType: Storage_Clouddms_Logging_V1_LoggedMigrationJob.ConnectivityType {
    get {return _storage._connectivityType}
    set {_uniqueStorage()._connectivityType = newValue}
  }

  /// The error details in case of state FAILED.
  public var error: Google_Rpc_Status {
    get {return _storage._error ?? Google_Rpc_Status()}
    set {_uniqueStorage()._error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return _storage._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {_uniqueStorage()._error = nil}

  /// The time when this migration job was completed. Should only be set when the
  /// phase of the migration job is COMPLETED.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// The indicative source database.
  public var sourceDatabase: Storage_Clouddms_Logging_V1_DatabaseType {
    get {return _storage._sourceDatabase ?? Storage_Clouddms_Logging_V1_DatabaseType()}
    set {_uniqueStorage()._sourceDatabase = newValue}
  }
  /// Returns true if `sourceDatabase` has been explicitly set.
  public var hasSourceDatabase: Bool {return _storage._sourceDatabase != nil}
  /// Clears the value of `sourceDatabase`. Subsequent reads from it will return its default value.
  public mutating func clearSourceDatabase() {_uniqueStorage()._sourceDatabase = nil}

  /// The indicative destination database.
  public var destinationDatabase: Storage_Clouddms_Logging_V1_DatabaseType {
    get {return _storage._destinationDatabase ?? Storage_Clouddms_Logging_V1_DatabaseType()}
    set {_uniqueStorage()._destinationDatabase = newValue}
  }
  /// Returns true if `destinationDatabase` has been explicitly set.
  public var hasDestinationDatabase: Bool {return _storage._destinationDatabase != nil}
  /// Clears the value of `destinationDatabase`. Subsequent reads from it will return its default value.
  public mutating func clearDestinationDatabase() {_uniqueStorage()._destinationDatabase = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The migration job states enum.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the migration job is unknown.
    case unspecified // = 0

    /// The migration job is down for maintenance.
    case maintenance // = 1

    /// The migration job is in draft mode and fully editable.
    case draft // = 2

    /// The migration job is being created.
    case creating // = 3

    /// The migration job is created, not started and is fully editable.
    case notStarted // = 4

    /// The migration job is running
    case running // = 5

    /// The migration job failed.
    case failed // = 6

    /// The migration job has been completed.
    case completed // = 7

    /// The migration job is being deleted.
    case deleting // = 8

    /// The migration job is being stopped.
    case stopping // = 9

    /// The migration job is currently stopped.
    case stopped // = 10

    /// The migration job has been deleted.
    case deleted // = 11

    /// The migration job is being updated.
    case updating // = 12

    /// The migration job is starting.
    case starting // = 13

    /// The migration job is restarting.
    case restarting // = 14

    /// The migration job is resuming.
    case resuming // = 15
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .maintenance
      case 2: self = .draft
      case 3: self = .creating
      case 4: self = .notStarted
      case 5: self = .running
      case 6: self = .failed
      case 7: self = .completed
      case 8: self = .deleting
      case 9: self = .stopping
      case 10: self = .stopped
      case 11: self = .deleted
      case 12: self = .updating
      case 13: self = .starting
      case 14: self = .restarting
      case 15: self = .resuming
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .maintenance: return 1
      case .draft: return 2
      case .creating: return 3
      case .notStarted: return 4
      case .running: return 5
      case .failed: return 6
      case .completed: return 7
      case .deleting: return 8
      case .stopping: return 9
      case .stopped: return 10
      case .deleted: return 11
      case .updating: return 12
      case .starting: return 13
      case .restarting: return 14
      case .resuming: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The migration job phases enum.
  public enum Phase: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The phase of the migration job is unknown.
    case unspecified // = 0

    /// The migration job is in the full dump phase.
    case fullDump // = 1

    /// The migration job is CDC phase.
    case cdc // = 2

    /// The migration job is running the promote phase.
    case promoteInProgress // = 3

    /// Only RDS flow - waiting for source writes to stop
    case waitingForSourceWritesToStop // = 4

    /// Only RDS flow - the sources writes stopped, waiting for dump to begin
    case preparingTheDump // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .fullDump
      case 2: self = .cdc
      case 3: self = .promoteInProgress
      case 4: self = .waitingForSourceWritesToStop
      case 5: self = .preparingTheDump
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .fullDump: return 1
      case .cdc: return 2
      case .promoteInProgress: return 3
      case .waitingForSourceWritesToStop: return 4
      case .preparingTheDump: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The migration job types.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The type of the migration job is unknown.
    case unspecified // = 0

    /// The migration job is a one time migration.
    case oneTime // = 1

    /// The migration job is a continuous migration.
    case continuous // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .oneTime
      case 2: self = .continuous
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .oneTime: return 1
      case .continuous: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Type of connectivity to source database.
  public enum ConnectivityType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No data defined.
    case unspecified // = 0

    /// Connect using static IO
    case staticIp // = 1

    /// Use reverse SSH connectivity.
    case reverseSsh // = 2

    /// Use VPC Peering connectivity.
    case vpcPeering // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .staticIp
      case 2: self = .reverseSsh
      case 3: self = .vpcPeering
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .staticIp: return 1
      case .reverseSsh: return 2
      case .vpcPeering: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_LoggedMigrationJob.State] = [
    .unspecified,
    .maintenance,
    .draft,
    .creating,
    .notStarted,
    .running,
    .failed,
    .completed,
    .deleting,
    .stopping,
    .stopped,
    .deleted,
    .updating,
    .starting,
    .restarting,
    .resuming,
  ]
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.Phase: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_LoggedMigrationJob.Phase] = [
    .unspecified,
    .fullDump,
    .cdc,
    .promoteInProgress,
    .waitingForSourceWritesToStop,
    .preparingTheDump,
  ]
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_LoggedMigrationJob.TypeEnum] = [
    .unspecified,
    .oneTime,
    .continuous,
  ]
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.ConnectivityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_LoggedMigrationJob.ConnectivityType] = [
    .unspecified,
    .staticIp,
    .reverseSsh,
    .vpcPeering,
  ]
}

#endif  // swift(>=4.2)

/// An MySQL database connection profile.
public struct Storage_Clouddms_Logging_V1_MySqlConnectionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database version.
  public var version: Storage_Clouddms_Logging_V1_MySqlConnectionProfile.Version = .unspecified

  /// The Cloud SQL id for a Cloud SQL instance.
  public var cloudSqlID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The MySQL database version.
  public enum Version: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified version.
    case unspecified // = 0

    /// MySQL 5.5.
    case v55 // = 1

    /// MySQL 5.6.
    case v56 // = 2

    /// MySQL 5.7.
    case v57 // = 3

    /// MySQL 8.0.
    case v80 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .v55
      case 2: self = .v56
      case 3: self = .v57
      case 4: self = .v80
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .v55: return 1
      case .v56: return 2
      case .v57: return 3
      case .v80: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Storage_Clouddms_Logging_V1_MySqlConnectionProfile.Version: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_MySqlConnectionProfile.Version] = [
    .unspecified,
    .v55,
    .v56,
    .v57,
    .v80,
  ]
}

#endif  // swift(>=4.2)

/// An PostgreSQL connection profile.
public struct Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database version.
  public var version: Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile.Version = .unspecified

  /// The Cloud SQL id for a Cloud SQL instance.
  public var cloudSqlID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The PostgreSQL database version.
  public enum Version: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified version.
    case unspecified // = 0

    /// PostgreSQL 9.6.
    case v96 // = 1

    /// PostgreSQL 11.
    case v11 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .v96
      case 2: self = .v11
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .v96: return 1
      case .v11: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile.Version: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile.Version] = [
    .unspecified,
    .v96,
    .v11,
  ]
}

#endif  // swift(>=4.2)

/// A CloudSQL connection profile.
public struct Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Cloud SQL id.
  public var cloudSqlID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An producer connection profile definition.
/// NEXT_TAG = 18.
public struct Storage_Clouddms_Logging_V1_LoggedConnectionProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique identifier for a connection profile.
  public var name: String = String()

  /// Labels.
  public var labels: Dictionary<String,String> = [:]

  /// The current connection profile state.
  public var state: Storage_Clouddms_Logging_V1_LoggedConnectionProfile.State = .unspecified

  /// The display name.
  public var displayName: String = String()

  /// The connection profile definition
  public var connectionProfile: Storage_Clouddms_Logging_V1_LoggedConnectionProfile.OneOf_ConnectionProfile? = nil

  /// A MySQL database connection profile.
  public var mysql: Storage_Clouddms_Logging_V1_MySqlConnectionProfile {
    get {
      if case .mysql(let v)? = connectionProfile {return v}
      return Storage_Clouddms_Logging_V1_MySqlConnectionProfile()
    }
    set {connectionProfile = .mysql(newValue)}
  }

  /// A PostgreSQL database connection profile.
  public var postgresql: Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile {
    get {
      if case .postgresql(let v)? = connectionProfile {return v}
      return Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile()
    }
    set {connectionProfile = .postgresql(newValue)}
  }

  /// A CloudSQL database connection profile.
  public var cloudsql: Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile {
    get {
      if case .cloudsql(let v)? = connectionProfile {return v}
      return Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile()
    }
    set {connectionProfile = .cloudsql(newValue)}
  }

  /// The error details in case of state FAILED.
  public var error: Google_Rpc_Status {
    get {return _error ?? Google_Rpc_Status()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  /// The database provider.
  public var provider: Storage_Clouddms_Logging_V1_DatabaseProvider = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The connection profile definition
  public enum OneOf_ConnectionProfile: Equatable {
    /// A MySQL database connection profile.
    case mysql(Storage_Clouddms_Logging_V1_MySqlConnectionProfile)
    /// A PostgreSQL database connection profile.
    case postgresql(Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile)
    /// A CloudSQL database connection profile.
    case cloudsql(Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile)

  #if !swift(>=4.1)
    public static func ==(lhs: Storage_Clouddms_Logging_V1_LoggedConnectionProfile.OneOf_ConnectionProfile, rhs: Storage_Clouddms_Logging_V1_LoggedConnectionProfile.OneOf_ConnectionProfile) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.mysql, .mysql): return {
        guard case .mysql(let l) = lhs, case .mysql(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.postgresql, .postgresql): return {
        guard case .postgresql(let l) = lhs, case .postgresql(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cloudsql, .cloudsql): return {
        guard case .cloudsql(let l) = lhs, case .cloudsql(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The connection profile states enum.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the connection profile is unknown.
    case unspecified // = 0

    /// The connection profile is in draft mode and fully editable.
    case draft // = 1

    /// The connection profile is being created.
    case creating // = 2

    /// The connection profile is ready.
    case ready // = 3

    /// The connection profile is being updated.
    case updating // = 4

    /// The connection profile is being deleted.
    case deleting // = 5

    /// The connection profile has been deleted.
    case deleted // = 6

    /// The last action on the connection profile failed.
    case failed // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .draft
      case 2: self = .creating
      case 3: self = .ready
      case 4: self = .updating
      case 5: self = .deleting
      case 6: self = .deleted
      case 7: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .draft: return 1
      case .creating: return 2
      case .ready: return 3
      case .updating: return 4
      case .deleting: return 5
      case .deleted: return 6
      case .failed: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _error: Google_Rpc_Status? = nil
}

#if swift(>=4.2)

extension Storage_Clouddms_Logging_V1_LoggedConnectionProfile.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Storage_Clouddms_Logging_V1_LoggedConnectionProfile.State] = [
    .unspecified,
    .draft,
    .creating,
    .ready,
    .updating,
    .deleting,
    .deleted,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// Log definition for Migration Job event
public struct Storage_Clouddms_Logging_V1_MigrationJobEventLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The migration job resource
  public var migrationJob: Storage_Clouddms_Logging_V1_LoggedMigrationJob {
    get {return _migrationJob ?? Storage_Clouddms_Logging_V1_LoggedMigrationJob()}
    set {_migrationJob = newValue}
  }
  /// Returns true if `migrationJob` has been explicitly set.
  public var hasMigrationJob: Bool {return self._migrationJob != nil}
  /// Clears the value of `migrationJob`. Subsequent reads from it will return its default value.
  public mutating func clearMigrationJob() {self._migrationJob = nil}

  /// Timestamp of the event
  public var occurrenceTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _occurrenceTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_occurrenceTimestamp = newValue}
  }
  /// Returns true if `occurrenceTimestamp` has been explicitly set.
  public var hasOccurrenceTimestamp: Bool {return self._occurrenceTimestamp != nil}
  /// Clears the value of `occurrenceTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearOccurrenceTimestamp() {self._occurrenceTimestamp = nil}

  /// Event code
  public var code: Int32 = 0

  /// Event message
  public var textMessage: String = String()

  /// Original event data
  public var originalCause: Storage_Clouddms_Logging_V1_MigrationJobEventLog.OneOf_OriginalCause? = nil

  /// Original event code
  public var originalCode: Int32 {
    get {
      if case .originalCode(let v)? = originalCause {return v}
      return 0
    }
    set {originalCause = .originalCode(newValue)}
  }

  /// Original event message
  public var originalMessage: String {
    get {
      if case .originalMessage(let v)? = originalCause {return v}
      return String()
    }
    set {originalCause = .originalMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Original event data
  public enum OneOf_OriginalCause: Equatable {
    /// Original event code
    case originalCode(Int32)
    /// Original event message
    case originalMessage(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Storage_Clouddms_Logging_V1_MigrationJobEventLog.OneOf_OriginalCause, rhs: Storage_Clouddms_Logging_V1_MigrationJobEventLog.OneOf_OriginalCause) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.originalCode, .originalCode): return {
        guard case .originalCode(let l) = lhs, case .originalCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.originalMessage, .originalMessage): return {
        guard case .originalMessage(let l) = lhs, case .originalMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _migrationJob: Storage_Clouddms_Logging_V1_LoggedMigrationJob? = nil
  fileprivate var _occurrenceTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Log definition for Connection Profile event
public struct Storage_Clouddms_Logging_V1_ConnectionProfileEventLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The connection profilr resource
  public var connectionProfile: Storage_Clouddms_Logging_V1_LoggedConnectionProfile {
    get {return _connectionProfile ?? Storage_Clouddms_Logging_V1_LoggedConnectionProfile()}
    set {_connectionProfile = newValue}
  }
  /// Returns true if `connectionProfile` has been explicitly set.
  public var hasConnectionProfile: Bool {return self._connectionProfile != nil}
  /// Clears the value of `connectionProfile`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionProfile() {self._connectionProfile = nil}

  /// Timestamp of the event
  public var occurrenceTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _occurrenceTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_occurrenceTimestamp = newValue}
  }
  /// Returns true if `occurrenceTimestamp` has been explicitly set.
  public var hasOccurrenceTimestamp: Bool {return self._occurrenceTimestamp != nil}
  /// Clears the value of `occurrenceTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearOccurrenceTimestamp() {self._occurrenceTimestamp = nil}

  /// Event code
  public var code: Int32 = 0

  /// Event message
  public var textMessage: String = String()

  /// Original event data
  public var originalCause: Storage_Clouddms_Logging_V1_ConnectionProfileEventLog.OneOf_OriginalCause? = nil

  /// Original event code
  public var originalCode: Int32 {
    get {
      if case .originalCode(let v)? = originalCause {return v}
      return 0
    }
    set {originalCause = .originalCode(newValue)}
  }

  /// Original event message
  public var originalMessage: String {
    get {
      if case .originalMessage(let v)? = originalCause {return v}
      return String()
    }
    set {originalCause = .originalMessage(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Original event data
  public enum OneOf_OriginalCause: Equatable {
    /// Original event code
    case originalCode(Int32)
    /// Original event message
    case originalMessage(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Storage_Clouddms_Logging_V1_ConnectionProfileEventLog.OneOf_OriginalCause, rhs: Storage_Clouddms_Logging_V1_ConnectionProfileEventLog.OneOf_OriginalCause) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.originalCode, .originalCode): return {
        guard case .originalCode(let l) = lhs, case .originalCode(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.originalMessage, .originalMessage): return {
        guard case .originalMessage(let l) = lhs, case .originalMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _connectionProfile: Storage_Clouddms_Logging_V1_LoggedConnectionProfile? = nil
  fileprivate var _occurrenceTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "storage.clouddms.logging.v1"

extension Storage_Clouddms_Logging_V1_DatabaseEngine: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATABASE_ENGINE_UNSPECIFIED"),
    1: .same(proto: "MYSQL"),
    2: .same(proto: "POSTGRESQL"),
  ]
}

extension Storage_Clouddms_Logging_V1_DatabaseProvider: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATABASE_PROVIDER_UNSPECIFIED"),
    1: .same(proto: "CLOUDSQL"),
    2: .same(proto: "RDS"),
  ]
}

extension Storage_Clouddms_Logging_V1_DatabaseType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatabaseType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "engine"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.provider) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.engine) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.provider != .unspecified {
      try visitor.visitSingularEnumField(value: self.provider, fieldNumber: 1)
    }
    if self.engine != .unspecified {
      try visitor.visitSingularEnumField(value: self.engine, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_DatabaseType, rhs: Storage_Clouddms_Logging_V1_DatabaseType) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.engine != rhs.engine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoggedMigrationJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "labels"),
    3: .standard(proto: "display_name"),
    4: .same(proto: "state"),
    5: .same(proto: "phase"),
    6: .same(proto: "type"),
    7: .standard(proto: "dump_path"),
    8: .same(proto: "source"),
    9: .same(proto: "destination"),
    10: .same(proto: "duration"),
    11: .standard(proto: "connectivity_type"),
    12: .same(proto: "error"),
    13: .standard(proto: "end_time"),
    14: .standard(proto: "source_database"),
    15: .standard(proto: "destination_database"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _displayName: String = String()
    var _state: Storage_Clouddms_Logging_V1_LoggedMigrationJob.State = .unspecified
    var _phase: Storage_Clouddms_Logging_V1_LoggedMigrationJob.Phase = .unspecified
    var _type: Storage_Clouddms_Logging_V1_LoggedMigrationJob.TypeEnum = .unspecified
    var _dumpPath: String = String()
    var _source: String = String()
    var _destination: String = String()
    var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _connectivityType: Storage_Clouddms_Logging_V1_LoggedMigrationJob.ConnectivityType = .unspecified
    var _error: Google_Rpc_Status? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _sourceDatabase: Storage_Clouddms_Logging_V1_DatabaseType? = nil
    var _destinationDatabase: Storage_Clouddms_Logging_V1_DatabaseType? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _labels = source._labels
      _displayName = source._displayName
      _state = source._state
      _phase = source._phase
      _type = source._type
      _dumpPath = source._dumpPath
      _source = source._source
      _destination = source._destination
      _duration = source._duration
      _connectivityType = source._connectivityType
      _error = source._error
      _endTime = source._endTime
      _sourceDatabase = source._sourceDatabase
      _destinationDatabase = source._destinationDatabase
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._phase) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._dumpPath) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._destination) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._duration) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._connectivityType) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._error) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._sourceDatabase) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._destinationDatabase) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 2)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 3)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 4)
      }
      if _storage._phase != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._phase, fieldNumber: 5)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 6)
      }
      if !_storage._dumpPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dumpPath, fieldNumber: 7)
      }
      if !_storage._source.isEmpty {
        try visitor.visitSingularStringField(value: _storage._source, fieldNumber: 8)
      }
      if !_storage._destination.isEmpty {
        try visitor.visitSingularStringField(value: _storage._destination, fieldNumber: 9)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if _storage._connectivityType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._connectivityType, fieldNumber: 11)
      }
      if let v = _storage._error {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._sourceDatabase {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._destinationDatabase {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_LoggedMigrationJob, rhs: Storage_Clouddms_Logging_V1_LoggedMigrationJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._phase != rhs_storage._phase {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._dumpPath != rhs_storage._dumpPath {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._connectivityType != rhs_storage._connectivityType {return false}
        if _storage._error != rhs_storage._error {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._sourceDatabase != rhs_storage._sourceDatabase {return false}
        if _storage._destinationDatabase != rhs_storage._destinationDatabase {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "MAINTENANCE"),
    2: .same(proto: "DRAFT"),
    3: .same(proto: "CREATING"),
    4: .same(proto: "NOT_STARTED"),
    5: .same(proto: "RUNNING"),
    6: .same(proto: "FAILED"),
    7: .same(proto: "COMPLETED"),
    8: .same(proto: "DELETING"),
    9: .same(proto: "STOPPING"),
    10: .same(proto: "STOPPED"),
    11: .same(proto: "DELETED"),
    12: .same(proto: "UPDATING"),
    13: .same(proto: "STARTING"),
    14: .same(proto: "RESTARTING"),
    15: .same(proto: "RESUMING"),
  ]
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.Phase: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PHASE_UNSPECIFIED"),
    1: .same(proto: "FULL_DUMP"),
    2: .same(proto: "CDC"),
    3: .same(proto: "PROMOTE_IN_PROGRESS"),
    4: .same(proto: "WAITING_FOR_SOURCE_WRITES_TO_STOP"),
    5: .same(proto: "PREPARING_THE_DUMP"),
  ]
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "ONE_TIME"),
    2: .same(proto: "CONTINUOUS"),
  ]
}

extension Storage_Clouddms_Logging_V1_LoggedMigrationJob.ConnectivityType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONNECTIVITY_TYPE_UNSPECIFIED"),
    1: .same(proto: "STATIC_IP"),
    2: .same(proto: "REVERSE_SSH"),
    3: .same(proto: "VPC_PEERING"),
  ]
}

extension Storage_Clouddms_Logging_V1_MySqlConnectionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MySqlConnectionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "cloud_sql_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cloudSqlID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != .unspecified {
      try visitor.visitSingularEnumField(value: self.version, fieldNumber: 1)
    }
    if !self.cloudSqlID.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudSqlID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_MySqlConnectionProfile, rhs: Storage_Clouddms_Logging_V1_MySqlConnectionProfile) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.cloudSqlID != rhs.cloudSqlID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_MySqlConnectionProfile.Version: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_UNSPECIFIED"),
    1: .same(proto: "V5_5"),
    2: .same(proto: "V5_6"),
    3: .same(proto: "V5_7"),
    4: .same(proto: "V8_0"),
  ]
}

extension Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostgreSqlConnectionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "cloud_sql_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cloudSqlID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != .unspecified {
      try visitor.visitSingularEnumField(value: self.version, fieldNumber: 1)
    }
    if !self.cloudSqlID.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudSqlID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile, rhs: Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.cloudSqlID != rhs.cloudSqlID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile.Version: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_UNSPECIFIED"),
    1: .same(proto: "V9_6"),
    2: .same(proto: "V11"),
  ]
}

extension Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudSqlConnectionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_sql_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cloudSqlID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cloudSqlID.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudSqlID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile, rhs: Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile) -> Bool {
    if lhs.cloudSqlID != rhs.cloudSqlID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_LoggedConnectionProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoggedConnectionProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "labels"),
    3: .same(proto: "state"),
    4: .standard(proto: "display_name"),
    100: .same(proto: "mysql"),
    101: .same(proto: "postgresql"),
    102: .same(proto: "cloudsql"),
    5: .same(proto: "error"),
    6: .same(proto: "provider"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.provider) }()
      case 100: try {
        var v: Storage_Clouddms_Logging_V1_MySqlConnectionProfile?
        if let current = self.connectionProfile {
          try decoder.handleConflictingOneOf()
          if case .mysql(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.connectionProfile = .mysql(v)}
      }()
      case 101: try {
        var v: Storage_Clouddms_Logging_V1_PostgreSqlConnectionProfile?
        if let current = self.connectionProfile {
          try decoder.handleConflictingOneOf()
          if case .postgresql(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.connectionProfile = .postgresql(v)}
      }()
      case 102: try {
        var v: Storage_Clouddms_Logging_V1_CloudSqlConnectionProfile?
        if let current = self.connectionProfile {
          try decoder.handleConflictingOneOf()
          if case .cloudsql(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.connectionProfile = .cloudsql(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 4)
    }
    if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.provider != .unspecified {
      try visitor.visitSingularEnumField(value: self.provider, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.connectionProfile {
    case .mysql?: try {
      guard case .mysql(let v)? = self.connectionProfile else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .postgresql?: try {
      guard case .postgresql(let v)? = self.connectionProfile else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case .cloudsql?: try {
      guard case .cloudsql(let v)? = self.connectionProfile else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_LoggedConnectionProfile, rhs: Storage_Clouddms_Logging_V1_LoggedConnectionProfile) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.state != rhs.state {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.connectionProfile != rhs.connectionProfile {return false}
    if lhs._error != rhs._error {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_LoggedConnectionProfile.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "DRAFT"),
    2: .same(proto: "CREATING"),
    3: .same(proto: "READY"),
    4: .same(proto: "UPDATING"),
    5: .same(proto: "DELETING"),
    6: .same(proto: "DELETED"),
    7: .same(proto: "FAILED"),
  ]
}

extension Storage_Clouddms_Logging_V1_MigrationJobEventLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MigrationJobEventLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "migration_job"),
    2: .standard(proto: "occurrence_timestamp"),
    3: .same(proto: "code"),
    4: .standard(proto: "text_message"),
    200: .standard(proto: "original_code"),
    201: .standard(proto: "original_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._migrationJob) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._occurrenceTimestamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.textMessage) }()
      case 200: try {
        if self.originalCause != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.originalCause = .originalCode(v)}
      }()
      case 201: try {
        if self.originalCause != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.originalCause = .originalMessage(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._migrationJob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._occurrenceTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 3)
    }
    if !self.textMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.textMessage, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.originalCause {
    case .originalCode?: try {
      guard case .originalCode(let v)? = self.originalCause else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 200)
    }()
    case .originalMessage?: try {
      guard case .originalMessage(let v)? = self.originalCause else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 201)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_MigrationJobEventLog, rhs: Storage_Clouddms_Logging_V1_MigrationJobEventLog) -> Bool {
    if lhs._migrationJob != rhs._migrationJob {return false}
    if lhs._occurrenceTimestamp != rhs._occurrenceTimestamp {return false}
    if lhs.code != rhs.code {return false}
    if lhs.textMessage != rhs.textMessage {return false}
    if lhs.originalCause != rhs.originalCause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Storage_Clouddms_Logging_V1_ConnectionProfileEventLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionProfileEventLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "connection_profile"),
    2: .standard(proto: "occurrence_timestamp"),
    3: .same(proto: "code"),
    4: .standard(proto: "text_message"),
    200: .standard(proto: "original_code"),
    201: .standard(proto: "original_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connectionProfile) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._occurrenceTimestamp) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.textMessage) }()
      case 200: try {
        if self.originalCause != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.originalCause = .originalCode(v)}
      }()
      case 201: try {
        if self.originalCause != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.originalCause = .originalMessage(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._connectionProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._occurrenceTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 3)
    }
    if !self.textMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.textMessage, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.originalCause {
    case .originalCode?: try {
      guard case .originalCode(let v)? = self.originalCause else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 200)
    }()
    case .originalMessage?: try {
      guard case .originalMessage(let v)? = self.originalCause else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 201)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Storage_Clouddms_Logging_V1_ConnectionProfileEventLog, rhs: Storage_Clouddms_Logging_V1_ConnectionProfileEventLog) -> Bool {
    if lhs._connectionProfile != rhs._connectionProfile {return false}
    if lhs._occurrenceTimestamp != rhs._occurrenceTimestamp {return false}
    if lhs.code != rhs.code {return false}
    if lhs.textMessage != rhs.textMessage {return false}
    if lhs.originalCause != rhs.originalCause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

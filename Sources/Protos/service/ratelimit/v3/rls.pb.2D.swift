// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/service/ratelimit/v3/rls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Main message for a rate limit request. The rate limit service is designed to be fully generic
/// in the sense that it can operate on arbitrary hierarchical key/value pairs. The loaded
/// configuration will parse the request and find the most specific limit to apply. In addition,
/// a RateLimitRequest can contain multiple "descriptors" to limit on. When multiple descriptors
/// are provided, the server will limit on *ALL* of them and return an OVER_LIMIT response if any
/// of them are over limit. This enables more complex application level rate limiting scenarios
/// if desired.
public struct Envoy_Service_Ratelimit_V3_RateLimitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All rate limit requests must specify a domain. This enables the configuration to be per
  /// application without fear of overlap. E.g., "envoy".
  public var domain: String = String()

  /// All rate limit requests must specify at least one RateLimitDescriptor. Each descriptor is
  /// processed by the service (see below). If any of the descriptors are over limit, the entire
  /// request is considered to be over limit.
  public var descriptors: [Envoy_Extensions_Common_Ratelimit_V3_RateLimitDescriptor] = []

  /// Rate limit requests can optionally specify the number of hits a request adds to the matched
  /// limit. If the value is not set in the message, a request increases the matched limit by 1.
  public var hitsAddend: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response from a ShouldRateLimit call.
public struct Envoy_Service_Ratelimit_V3_RateLimitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The overall response code which takes into account all of the descriptors that were passed
  /// in the RateLimitRequest message.
  public var overallCode: Envoy_Service_Ratelimit_V3_RateLimitResponse.Code = .unknown

  /// A list of DescriptorStatus messages which matches the length of the descriptor list passed
  /// in the RateLimitRequest. This can be used by the caller to determine which individual
  /// descriptors failed and/or what the currently configured limits are for all of them.
  public var statuses: [Envoy_Service_Ratelimit_V3_RateLimitResponse.DescriptorStatus] = []

  /// A list of headers to add to the response
  public var responseHeadersToAdd: [Envoy_Config_Core_V3_HeaderValue] = []

  /// A list of headers to add to the request when forwarded
  public var requestHeadersToAdd: [Envoy_Config_Core_V3_HeaderValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The response code is not known.
    case unknown // = 0

    /// The response code to notify that the number of requests are under limit.
    case ok // = 1

    /// The response code to notify that the number of requests are over limit.
    case overLimit // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .ok
      case 2: self = .overLimit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .ok: return 1
      case .overLimit: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Defines an actual rate limit in terms of requests per unit of time and the unit itself.
  public struct RateLimit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A name or description of this limit.
    public var name: String = String()

    /// The number of requests per unit of time.
    public var requestsPerUnit: UInt32 = 0

    /// The unit of time.
    public var unit: Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit.Unit = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Unit: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The time unit is not known.
      case unknown // = 0

      /// The time unit representing a second.
      case second // = 1

      /// The time unit representing a minute.
      case minute // = 2

      /// The time unit representing an hour.
      case hour // = 3

      /// The time unit representing a day.
      case day // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .second
        case 2: self = .minute
        case 3: self = .hour
        case 4: self = .day
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .second: return 1
        case .minute: return 2
        case .hour: return 3
        case .day: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct DescriptorStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The response code for an individual descriptor.
    public var code: Envoy_Service_Ratelimit_V3_RateLimitResponse.Code = .unknown

    /// The current limit as configured by the server. Useful for debugging, etc.
    public var currentLimit: Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit {
      get {return _currentLimit ?? Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit()}
      set {_currentLimit = newValue}
    }
    /// Returns true if `currentLimit` has been explicitly set.
    public var hasCurrentLimit: Bool {return self._currentLimit != nil}
    /// Clears the value of `currentLimit`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentLimit() {self._currentLimit = nil}

    /// The limit remaining in the current time unit.
    public var limitRemaining: UInt32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _currentLimit: Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Service_Ratelimit_V3_RateLimitResponse.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Service_Ratelimit_V3_RateLimitResponse.Code] = [
    .unknown,
    .ok,
    .overLimit,
  ]
}

extension Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit.Unit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit.Unit] = [
    .unknown,
    .second,
    .minute,
    .hour,
    .day,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.service.ratelimit.v3"

extension Envoy_Service_Ratelimit_V3_RateLimitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateLimitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "domain"),
    2: .same(proto: "descriptors"),
    3: .standard(proto: "hits_addend"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.domain)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.descriptors)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.hitsAddend)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.domain.isEmpty {
      try visitor.visitSingularStringField(value: self.domain, fieldNumber: 1)
    }
    if !self.descriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.descriptors, fieldNumber: 2)
    }
    if self.hitsAddend != 0 {
      try visitor.visitSingularUInt32Field(value: self.hitsAddend, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Ratelimit_V3_RateLimitRequest, rhs: Envoy_Service_Ratelimit_V3_RateLimitRequest) -> Bool {
    if lhs.domain != rhs.domain {return false}
    if lhs.descriptors != rhs.descriptors {return false}
    if lhs.hitsAddend != rhs.hitsAddend {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Ratelimit_V3_RateLimitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateLimitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overall_code"),
    2: .same(proto: "statuses"),
    3: .standard(proto: "response_headers_to_add"),
    4: .standard(proto: "request_headers_to_add"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.overallCode)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.statuses)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.responseHeadersToAdd)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.requestHeadersToAdd)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overallCode != .unknown {
      try visitor.visitSingularEnumField(value: self.overallCode, fieldNumber: 1)
    }
    if !self.statuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statuses, fieldNumber: 2)
    }
    if !self.responseHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeadersToAdd, fieldNumber: 3)
    }
    if !self.requestHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeadersToAdd, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Ratelimit_V3_RateLimitResponse, rhs: Envoy_Service_Ratelimit_V3_RateLimitResponse) -> Bool {
    if lhs.overallCode != rhs.overallCode {return false}
    if lhs.statuses != rhs.statuses {return false}
    if lhs.responseHeadersToAdd != rhs.responseHeadersToAdd {return false}
    if lhs.requestHeadersToAdd != rhs.requestHeadersToAdd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Ratelimit_V3_RateLimitResponse.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "OK"),
    2: .same(proto: "OVER_LIMIT"),
  ]
}

extension Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Service_Ratelimit_V3_RateLimitResponse.protoMessageName + ".RateLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    1: .standard(proto: "requests_per_unit"),
    2: .same(proto: "unit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.requestsPerUnit)
      case 2: try decoder.decodeSingularEnumField(value: &self.unit)
      case 3: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestsPerUnit != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestsPerUnit, fieldNumber: 1)
    }
    if self.unit != .unknown {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit, rhs: Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.requestsPerUnit != rhs.requestsPerUnit {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Ratelimit_V3_RateLimitResponse.RateLimit.Unit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SECOND"),
    2: .same(proto: "MINUTE"),
    3: .same(proto: "HOUR"),
    4: .same(proto: "DAY"),
  ]
}

extension Envoy_Service_Ratelimit_V3_RateLimitResponse.DescriptorStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Service_Ratelimit_V3_RateLimitResponse.protoMessageName + ".DescriptorStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "current_limit"),
    3: .standard(proto: "limit_remaining"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.code)
      case 2: try decoder.decodeSingularMessageField(value: &self._currentLimit)
      case 3: try decoder.decodeSingularUInt32Field(value: &self.limitRemaining)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if let v = self._currentLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.limitRemaining != 0 {
      try visitor.visitSingularUInt32Field(value: self.limitRemaining, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Ratelimit_V3_RateLimitResponse.DescriptorStatus, rhs: Envoy_Service_Ratelimit_V3_RateLimitResponse.DescriptorStatus) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._currentLimit != rhs._currentLimit {return false}
    if lhs.limitRemaining != rhs.limitRemaining {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

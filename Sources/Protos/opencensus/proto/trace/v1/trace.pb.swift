// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: opencensus/proto/trace/v1/trace.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017, OpenCensus Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A span represents a single operation within a trace. Spans can be
/// nested to form a trace tree. Spans may also be linked to other spans
/// from the same or different trace. And form graphs. Often, a trace
/// contains a root span that describes the end-to-end latency, and one
/// or more subspans for its sub-operations. A trace can also contain
/// multiple root spans, or none at all. Spans do not need to be
/// contiguous - there may be gaps or overlaps between spans in a trace.
///
/// The next id is 17.
/// TODO(bdrutu): Add an example.
public struct Opencensus_Proto_Trace_V1_Span {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for a trace. All spans from the same trace share
  /// the same `trace_id`. The ID is a 16-byte array. An ID with all zeroes
  /// is considered invalid.
  ///
  /// This field is semantically required. Receiver should generate new
  /// random trace_id if empty or invalid trace_id was received.
  ///
  /// This field is required.
  public var traceID: Data {
    get {return _storage._traceID}
    set {_uniqueStorage()._traceID = newValue}
  }

  /// A unique identifier for a span within a trace, assigned when the span
  /// is created. The ID is an 8-byte array. An ID with all zeroes is considered
  /// invalid.
  ///
  /// This field is semantically required. Receiver should generate new
  /// random span_id if empty or invalid span_id was received.
  ///
  /// This field is required.
  public var spanID: Data {
    get {return _storage._spanID}
    set {_uniqueStorage()._spanID = newValue}
  }

  /// The Tracestate on the span.
  public var tracestate: Opencensus_Proto_Trace_V1_Span.Tracestate {
    get {return _storage._tracestate ?? Opencensus_Proto_Trace_V1_Span.Tracestate()}
    set {_uniqueStorage()._tracestate = newValue}
  }
  /// Returns true if `tracestate` has been explicitly set.
  public var hasTracestate: Bool {return _storage._tracestate != nil}
  /// Clears the value of `tracestate`. Subsequent reads from it will return its default value.
  public mutating func clearTracestate() {_uniqueStorage()._tracestate = nil}

  /// The `span_id` of this span's parent span. If this is a root span, then this
  /// field must be empty. The ID is an 8-byte array.
  public var parentSpanID: Data {
    get {return _storage._parentSpanID}
    set {_uniqueStorage()._parentSpanID = newValue}
  }

  /// A description of the span's operation.
  ///
  /// For example, the name can be a qualified method name or a file name
  /// and a line number where the operation is called. A best practice is to use
  /// the same display name at the same call point in an application.
  /// This makes it easier to correlate spans in different traces.
  ///
  /// This field is semantically required to be set to non-empty string.
  /// When null or empty string received - receiver may use string "name"
  /// as a replacement. There might be smarted algorithms implemented by
  /// receiver to fix the empty span name.
  ///
  /// This field is required.
  public var name: Opencensus_Proto_Trace_V1_TruncatableString {
    get {return _storage._name ?? Opencensus_Proto_Trace_V1_TruncatableString()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {_uniqueStorage()._name = nil}

  /// Distinguishes between spans generated in a particular context. For example,
  /// two spans with the same name may be distinguished using `CLIENT` (caller)
  /// and `SERVER` (callee) to identify queueing latency associated with the span.
  public var kind: Opencensus_Proto_Trace_V1_Span.SpanKind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// The start time of the span. On the client side, this is the time kept by
  /// the local machine where the span execution starts. On the server side, this
  /// is the time when the server's application handler starts running.
  ///
  /// This field is semantically required. When not set on receive -
  /// receiver should set it to the value of end_time field if it was
  /// set. Or to the current time if neither was set. It is important to
  /// keep end_time > start_time for consistency.
  ///
  /// This field is required.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// The end time of the span. On the client side, this is the time kept by
  /// the local machine where the span execution ends. On the server side, this
  /// is the time when the server application handler stops running.
  ///
  /// This field is semantically required. When not set on receive -
  /// receiver should set it to start_time value. It is important to
  /// keep end_time > start_time for consistency.
  ///
  /// This field is required.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// A set of attributes on the span.
  public var attributes: Opencensus_Proto_Trace_V1_Span.Attributes {
    get {return _storage._attributes ?? Opencensus_Proto_Trace_V1_Span.Attributes()}
    set {_uniqueStorage()._attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  public var hasAttributes: Bool {return _storage._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  public mutating func clearAttributes() {_uniqueStorage()._attributes = nil}

  /// A stack trace captured at the start of the span.
  public var stackTrace: Opencensus_Proto_Trace_V1_StackTrace {
    get {return _storage._stackTrace ?? Opencensus_Proto_Trace_V1_StackTrace()}
    set {_uniqueStorage()._stackTrace = newValue}
  }
  /// Returns true if `stackTrace` has been explicitly set.
  public var hasStackTrace: Bool {return _storage._stackTrace != nil}
  /// Clears the value of `stackTrace`. Subsequent reads from it will return its default value.
  public mutating func clearStackTrace() {_uniqueStorage()._stackTrace = nil}

  /// The included time events.
  public var timeEvents: Opencensus_Proto_Trace_V1_Span.TimeEvents {
    get {return _storage._timeEvents ?? Opencensus_Proto_Trace_V1_Span.TimeEvents()}
    set {_uniqueStorage()._timeEvents = newValue}
  }
  /// Returns true if `timeEvents` has been explicitly set.
  public var hasTimeEvents: Bool {return _storage._timeEvents != nil}
  /// Clears the value of `timeEvents`. Subsequent reads from it will return its default value.
  public mutating func clearTimeEvents() {_uniqueStorage()._timeEvents = nil}

  /// The included links.
  public var links: Opencensus_Proto_Trace_V1_Span.Links {
    get {return _storage._links ?? Opencensus_Proto_Trace_V1_Span.Links()}
    set {_uniqueStorage()._links = newValue}
  }
  /// Returns true if `links` has been explicitly set.
  public var hasLinks: Bool {return _storage._links != nil}
  /// Clears the value of `links`. Subsequent reads from it will return its default value.
  public mutating func clearLinks() {_uniqueStorage()._links = nil}

  /// An optional final status for this span. Semantically when Status
  /// wasn't set it is means span ended without errors and assume
  /// Status.Ok (code = 0).
  public var status: Opencensus_Proto_Trace_V1_Status {
    get {return _storage._status ?? Opencensus_Proto_Trace_V1_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// An optional resource that is associated with this span. If not set, this span 
  /// should be part of a batch that does include the resource information, unless resource 
  /// information is unknown.
  public var resource: Opencensus_Proto_Resource_V1_Resource {
    get {return _storage._resource ?? Opencensus_Proto_Resource_V1_Resource()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// A highly recommended but not required flag that identifies when a
  /// trace crosses a process boundary. True when the parent_span belongs
  /// to the same process as the current span. This flag is most commonly
  /// used to indicate the need to adjust time as clocks in different
  /// processes may not be synchronized.
  public var sameProcessAsParentSpan: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._sameProcessAsParentSpan ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._sameProcessAsParentSpan = newValue}
  }
  /// Returns true if `sameProcessAsParentSpan` has been explicitly set.
  public var hasSameProcessAsParentSpan: Bool {return _storage._sameProcessAsParentSpan != nil}
  /// Clears the value of `sameProcessAsParentSpan`. Subsequent reads from it will return its default value.
  public mutating func clearSameProcessAsParentSpan() {_uniqueStorage()._sameProcessAsParentSpan = nil}

  /// An optional number of child spans that were generated while this span
  /// was active. If set, allows an implementation to detect missing child spans.
  public var childSpanCount: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._childSpanCount ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._childSpanCount = newValue}
  }
  /// Returns true if `childSpanCount` has been explicitly set.
  public var hasChildSpanCount: Bool {return _storage._childSpanCount != nil}
  /// Clears the value of `childSpanCount`. Subsequent reads from it will return its default value.
  public mutating func clearChildSpanCount() {_uniqueStorage()._childSpanCount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of span. Can be used to specify additional relationships between spans
  /// in addition to a parent/child relationship.
  public enum SpanKind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Indicates that the span covers server-side handling of an RPC or other
    /// remote network request.
    case server // = 1

    /// Indicates that the span covers the client-side wrapper around an RPC or
    /// other remote request.
    case client // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .server
      case 2: self = .client
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .server: return 1
      case .client: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// This field conveys information about request position in multiple distributed tracing graphs.
  /// It is a list of Tracestate.Entry with a maximum of 32 members in the list.
  ///
  /// See the https://github.com/w3c/distributed-tracing for more details about this field.
  public struct Tracestate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A list of entries that represent the Tracestate.
    public var entries: [Opencensus_Proto_Trace_V1_Span.Tracestate.Entry] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Entry {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The key must begin with a lowercase letter, and can only contain
      /// lowercase letters 'a'-'z', digits '0'-'9', underscores '_', dashes
      /// '-', asterisks '*', and forward slashes '/'.
      public var key: String = String()

      /// The value is opaque string up to 256 characters printable ASCII
      /// RFC0020 characters (i.e., the range 0x20 to 0x7E) except ',' and '='.
      /// Note that this also excludes tabs, newlines, carriage returns, etc.
      public var value: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// A set of attributes, each with a key and a value.
  public struct Attributes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The set of attributes. The value can be a string, an integer, a double
    /// or the Boolean values `true` or `false`. Note, global attributes like 
    /// server name can be set as tags using resource API. Examples of attributes:
    ///
    ///     "/http/user_agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36"
    ///     "/http/server_latency": 300
    ///     "abc.com/myattribute": true
    ///     "abc.com/score": 10.239
    public var attributeMap: Dictionary<String,Opencensus_Proto_Trace_V1_AttributeValue> = [:]

    /// The number of attributes that were discarded. Attributes can be discarded
    /// because their keys are too long or because there are too many attributes.
    /// If this value is 0, then no attributes were dropped.
    public var droppedAttributesCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A time-stamped annotation or message event in the Span.
  public struct TimeEvent {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The time the event occurred.
    public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {self._time = nil}

    /// A `TimeEvent` can contain either an `Annotation` object or a
    /// `MessageEvent` object, but not both.
    public var value: Opencensus_Proto_Trace_V1_Span.TimeEvent.OneOf_Value? = nil

    /// A text annotation with a set of attributes.
    public var annotation: Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation {
      get {
        if case .annotation(let v)? = value {return v}
        return Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation()
      }
      set {value = .annotation(newValue)}
    }

    /// An event describing a message sent/received between Spans.
    public var messageEvent: Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent {
      get {
        if case .messageEvent(let v)? = value {return v}
        return Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent()
      }
      set {value = .messageEvent(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A `TimeEvent` can contain either an `Annotation` object or a
    /// `MessageEvent` object, but not both.
    public enum OneOf_Value: Equatable {
      /// A text annotation with a set of attributes.
      case annotation(Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation)
      /// An event describing a message sent/received between Spans.
      case messageEvent(Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent)

    #if !swift(>=4.1)
      public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.TimeEvent.OneOf_Value, rhs: Opencensus_Proto_Trace_V1_Span.TimeEvent.OneOf_Value) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.annotation, .annotation): return {
          guard case .annotation(let l) = lhs, case .annotation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.messageEvent, .messageEvent): return {
          guard case .messageEvent(let l) = lhs, case .messageEvent(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// A text annotation with a set of attributes.
    public struct Annotation {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A user-supplied message describing the event.
      public var description_p: Opencensus_Proto_Trace_V1_TruncatableString {
        get {return _description_p ?? Opencensus_Proto_Trace_V1_TruncatableString()}
        set {_description_p = newValue}
      }
      /// Returns true if `description_p` has been explicitly set.
      public var hasDescription_p: Bool {return self._description_p != nil}
      /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
      public mutating func clearDescription_p() {self._description_p = nil}

      /// A set of attributes on the annotation.
      public var attributes: Opencensus_Proto_Trace_V1_Span.Attributes {
        get {return _attributes ?? Opencensus_Proto_Trace_V1_Span.Attributes()}
        set {_attributes = newValue}
      }
      /// Returns true if `attributes` has been explicitly set.
      public var hasAttributes: Bool {return self._attributes != nil}
      /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
      public mutating func clearAttributes() {self._attributes = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _description_p: Opencensus_Proto_Trace_V1_TruncatableString? = nil
      fileprivate var _attributes: Opencensus_Proto_Trace_V1_Span.Attributes? = nil
    }

    /// An event describing a message sent/received between Spans.
    public struct MessageEvent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The type of MessageEvent. Indicates whether the message was sent or
      /// received.
      public var type: Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent.TypeEnum = .unspecified

      /// An identifier for the MessageEvent's message that can be used to match
      /// SENT and RECEIVED MessageEvents. For example, this field could
      /// represent a sequence ID for a streaming RPC. It is recommended to be
      /// unique within a Span.
      public var id: UInt64 = 0

      /// The number of uncompressed bytes sent or received.
      public var uncompressedSize: UInt64 = 0

      /// The number of compressed bytes sent or received. If zero, assumed to
      /// be the same size as uncompressed.
      public var compressedSize: UInt64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Indicates whether the message was sent or received.
      public enum TypeEnum: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Unknown event type.
        case unspecified // = 0

        /// Indicates a sent message.
        case sent // = 1

        /// Indicates a received message.
        case received // = 2
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .sent
          case 2: self = .received
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .sent: return 1
          case .received: return 2
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}

    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// A collection of `TimeEvent`s. A `TimeEvent` is a time-stamped annotation
  /// on the span, consisting of either user-supplied key-value pairs, or
  /// details of a message sent/received between Spans.
  public struct TimeEvents {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A collection of `TimeEvent`s.
    public var timeEvent: [Opencensus_Proto_Trace_V1_Span.TimeEvent] = []

    /// The number of dropped annotations in all the included time events.
    /// If the value is 0, then no annotations were dropped.
    public var droppedAnnotationsCount: Int32 = 0

    /// The number of dropped message events in all the included time events.
    /// If the value is 0, then no message events were dropped.
    public var droppedMessageEventsCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A pointer from the current span to another span in the same trace or in a
  /// different trace. For example, this can be used in batching operations,
  /// where a single batch handler processes multiple requests from different
  /// traces or when the handler receives a request from a different project.
  public struct Link {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier of a trace that this linked span is part of. The ID is a 
    /// 16-byte array.
    public var traceID: Data = Data()

    /// A unique identifier for the linked span. The ID is an 8-byte array.
    public var spanID: Data = Data()

    /// The relationship of the current span relative to the linked span.
    public var type: Opencensus_Proto_Trace_V1_Span.Link.TypeEnum = .unspecified

    /// A set of attributes on the link.
    public var attributes: Opencensus_Proto_Trace_V1_Span.Attributes {
      get {return _attributes ?? Opencensus_Proto_Trace_V1_Span.Attributes()}
      set {_attributes = newValue}
    }
    /// Returns true if `attributes` has been explicitly set.
    public var hasAttributes: Bool {return self._attributes != nil}
    /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
    public mutating func clearAttributes() {self._attributes = nil}

    /// The Tracestate associated with the link.
    public var tracestate: Opencensus_Proto_Trace_V1_Span.Tracestate {
      get {return _tracestate ?? Opencensus_Proto_Trace_V1_Span.Tracestate()}
      set {_tracestate = newValue}
    }
    /// Returns true if `tracestate` has been explicitly set.
    public var hasTracestate: Bool {return self._tracestate != nil}
    /// Clears the value of `tracestate`. Subsequent reads from it will return its default value.
    public mutating func clearTracestate() {self._tracestate = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The relationship of the current span relative to the linked span: child,
    /// parent, or unspecified.
    public enum TypeEnum: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The relationship of the two spans is unknown, or known but other
      /// than parent-child.
      case unspecified // = 0

      /// The linked span is a child of the current span.
      case childLinkedSpan // = 1

      /// The linked span is a parent of the current span.
      case parentLinkedSpan // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .childLinkedSpan
        case 2: self = .parentLinkedSpan
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .childLinkedSpan: return 1
        case .parentLinkedSpan: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _attributes: Opencensus_Proto_Trace_V1_Span.Attributes? = nil
    fileprivate var _tracestate: Opencensus_Proto_Trace_V1_Span.Tracestate? = nil
  }

  /// A collection of links, which are references from this span to a span
  /// in the same or different trace.
  public struct Links {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A collection of links.
    public var link: [Opencensus_Proto_Trace_V1_Span.Link] = []

    /// The number of dropped links after the maximum size was enforced. If
    /// this value is 0, then no links were dropped.
    public var droppedLinksCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Opencensus_Proto_Trace_V1_Span.SpanKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencensus_Proto_Trace_V1_Span.SpanKind] = [
    .unspecified,
    .server,
    .client,
  ]
}

extension Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent.TypeEnum] = [
    .unspecified,
    .sent,
    .received,
  ]
}

extension Opencensus_Proto_Trace_V1_Span.Link.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Opencensus_Proto_Trace_V1_Span.Link.TypeEnum] = [
    .unspecified,
    .childLinkedSpan,
    .parentLinkedSpan,
  ]
}

#endif  // swift(>=4.2)

/// The `Status` type defines a logical error model that is suitable for different
/// programming environments, including REST APIs and RPC APIs. This proto's fields
/// are a subset of those of
/// [google.rpc.Status](https://github.com/googleapis/googleapis/blob/master/google/rpc/status.proto),
/// which is used by [gRPC](https://github.com/grpc).
public struct Opencensus_Proto_Trace_V1_Status {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The status code. This is optional field. It is safe to assume 0 (OK)
  /// when not set.
  public var code: Int32 = 0

  /// A developer-facing error message, which should be in English.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The value of an Attribute.
public struct Opencensus_Proto_Trace_V1_AttributeValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the value.
  public var value: Opencensus_Proto_Trace_V1_AttributeValue.OneOf_Value? = nil

  /// A string up to 256 bytes long.
  public var stringValue: Opencensus_Proto_Trace_V1_TruncatableString {
    get {
      if case .stringValue(let v)? = value {return v}
      return Opencensus_Proto_Trace_V1_TruncatableString()
    }
    set {value = .stringValue(newValue)}
  }

  /// A 64-bit signed integer.
  public var intValue: Int64 {
    get {
      if case .intValue(let v)? = value {return v}
      return 0
    }
    set {value = .intValue(newValue)}
  }

  /// A Boolean value represented by `true` or `false`.
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  /// A double value.
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = value {return v}
      return 0
    }
    set {value = .doubleValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of the value.
  public enum OneOf_Value: Equatable {
    /// A string up to 256 bytes long.
    case stringValue(Opencensus_Proto_Trace_V1_TruncatableString)
    /// A 64-bit signed integer.
    case intValue(Int64)
    /// A Boolean value represented by `true` or `false`.
    case boolValue(Bool)
    /// A double value.
    case doubleValue(Double)

  #if !swift(>=4.1)
    public static func ==(lhs: Opencensus_Proto_Trace_V1_AttributeValue.OneOf_Value, rhs: Opencensus_Proto_Trace_V1_AttributeValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intValue, .intValue): return {
        guard case .intValue(let l) = lhs, case .intValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The call stack which originated this span.
public struct Opencensus_Proto_Trace_V1_StackTrace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stack frames in this stack trace.
  public var stackFrames: Opencensus_Proto_Trace_V1_StackTrace.StackFrames {
    get {return _stackFrames ?? Opencensus_Proto_Trace_V1_StackTrace.StackFrames()}
    set {_stackFrames = newValue}
  }
  /// Returns true if `stackFrames` has been explicitly set.
  public var hasStackFrames: Bool {return self._stackFrames != nil}
  /// Clears the value of `stackFrames`. Subsequent reads from it will return its default value.
  public mutating func clearStackFrames() {self._stackFrames = nil}

  /// The hash ID is used to conserve network bandwidth for duplicate
  /// stack traces within a single trace.
  ///
  /// Often multiple spans will have identical stack traces.
  /// The first occurrence of a stack trace should contain both
  /// `stack_frames` and a value in `stack_trace_hash_id`.
  ///
  /// Subsequent spans within the same request can refer
  /// to that stack trace by setting only `stack_trace_hash_id`.
  ///
  /// TODO: describe how to deal with the case where stack_trace_hash_id is
  /// zero because it was not set.
  public var stackTraceHashID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single stack frame in a stack trace.
  public struct StackFrame {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The fully-qualified name that uniquely identifies the function or
    /// method that is active in this frame.
    public var functionName: Opencensus_Proto_Trace_V1_TruncatableString {
      get {return _functionName ?? Opencensus_Proto_Trace_V1_TruncatableString()}
      set {_functionName = newValue}
    }
    /// Returns true if `functionName` has been explicitly set.
    public var hasFunctionName: Bool {return self._functionName != nil}
    /// Clears the value of `functionName`. Subsequent reads from it will return its default value.
    public mutating func clearFunctionName() {self._functionName = nil}

    /// An un-mangled function name, if `function_name` is
    /// [mangled](http://www.avabodh.com/cxxin/namemangling.html). The name can
    /// be fully qualified.
    public var originalFunctionName: Opencensus_Proto_Trace_V1_TruncatableString {
      get {return _originalFunctionName ?? Opencensus_Proto_Trace_V1_TruncatableString()}
      set {_originalFunctionName = newValue}
    }
    /// Returns true if `originalFunctionName` has been explicitly set.
    public var hasOriginalFunctionName: Bool {return self._originalFunctionName != nil}
    /// Clears the value of `originalFunctionName`. Subsequent reads from it will return its default value.
    public mutating func clearOriginalFunctionName() {self._originalFunctionName = nil}

    /// The name of the source file where the function call appears.
    public var fileName: Opencensus_Proto_Trace_V1_TruncatableString {
      get {return _fileName ?? Opencensus_Proto_Trace_V1_TruncatableString()}
      set {_fileName = newValue}
    }
    /// Returns true if `fileName` has been explicitly set.
    public var hasFileName: Bool {return self._fileName != nil}
    /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
    public mutating func clearFileName() {self._fileName = nil}

    /// The line number in `file_name` where the function call appears.
    public var lineNumber: Int64 = 0

    /// The column number where the function call appears, if available.
    /// This is important in JavaScript because of its anonymous functions.
    public var columnNumber: Int64 = 0

    /// The binary module from where the code was loaded.
    public var loadModule: Opencensus_Proto_Trace_V1_Module {
      get {return _loadModule ?? Opencensus_Proto_Trace_V1_Module()}
      set {_loadModule = newValue}
    }
    /// Returns true if `loadModule` has been explicitly set.
    public var hasLoadModule: Bool {return self._loadModule != nil}
    /// Clears the value of `loadModule`. Subsequent reads from it will return its default value.
    public mutating func clearLoadModule() {self._loadModule = nil}

    /// The version of the deployed source code.
    public var sourceVersion: Opencensus_Proto_Trace_V1_TruncatableString {
      get {return _sourceVersion ?? Opencensus_Proto_Trace_V1_TruncatableString()}
      set {_sourceVersion = newValue}
    }
    /// Returns true if `sourceVersion` has been explicitly set.
    public var hasSourceVersion: Bool {return self._sourceVersion != nil}
    /// Clears the value of `sourceVersion`. Subsequent reads from it will return its default value.
    public mutating func clearSourceVersion() {self._sourceVersion = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _functionName: Opencensus_Proto_Trace_V1_TruncatableString? = nil
    fileprivate var _originalFunctionName: Opencensus_Proto_Trace_V1_TruncatableString? = nil
    fileprivate var _fileName: Opencensus_Proto_Trace_V1_TruncatableString? = nil
    fileprivate var _loadModule: Opencensus_Proto_Trace_V1_Module? = nil
    fileprivate var _sourceVersion: Opencensus_Proto_Trace_V1_TruncatableString? = nil
  }

  /// A collection of stack frames, which can be truncated.
  public struct StackFrames {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Stack frames in this call stack.
    public var frame: [Opencensus_Proto_Trace_V1_StackTrace.StackFrame] = []

    /// The number of stack frames that were dropped because there
    /// were too many stack frames.
    /// If this value is 0, then no stack frames were dropped.
    public var droppedFramesCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _stackFrames: Opencensus_Proto_Trace_V1_StackTrace.StackFrames? = nil
}

/// A description of a binary module.
public struct Opencensus_Proto_Trace_V1_Module {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: document the meaning of this field.
  /// For example: main binary, kernel modules, and dynamic libraries
  /// such as libc.so, sharedlib.so.
  public var module: Opencensus_Proto_Trace_V1_TruncatableString {
    get {return _module ?? Opencensus_Proto_Trace_V1_TruncatableString()}
    set {_module = newValue}
  }
  /// Returns true if `module` has been explicitly set.
  public var hasModule: Bool {return self._module != nil}
  /// Clears the value of `module`. Subsequent reads from it will return its default value.
  public mutating func clearModule() {self._module = nil}

  /// A unique identifier for the module, usually a hash of its
  /// contents.
  public var buildID: Opencensus_Proto_Trace_V1_TruncatableString {
    get {return _buildID ?? Opencensus_Proto_Trace_V1_TruncatableString()}
    set {_buildID = newValue}
  }
  /// Returns true if `buildID` has been explicitly set.
  public var hasBuildID: Bool {return self._buildID != nil}
  /// Clears the value of `buildID`. Subsequent reads from it will return its default value.
  public mutating func clearBuildID() {self._buildID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _module: Opencensus_Proto_Trace_V1_TruncatableString? = nil
  fileprivate var _buildID: Opencensus_Proto_Trace_V1_TruncatableString? = nil
}

/// A string that might be shortened to a specified length.
public struct Opencensus_Proto_Trace_V1_TruncatableString {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The shortened string. For example, if the original string was 500 bytes long and
  /// the limit of the string was 128 bytes, then this value contains the first 128
  /// bytes of the 500-byte string. Note that truncation always happens on a
  /// character boundary, to ensure that a truncated string is still valid UTF-8.
  /// Because it may contain multi-byte characters, the size of the truncated string
  /// may be less than the truncation limit.
  public var value: String = String()

  /// The number of bytes removed from the original string. If this
  /// value is 0, then the string was not shortened.
  public var truncatedByteCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "opencensus.proto.trace.v1"

extension Opencensus_Proto_Trace_V1_Span: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Span"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
    15: .same(proto: "tracestate"),
    3: .standard(proto: "parent_span_id"),
    4: .same(proto: "name"),
    14: .same(proto: "kind"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
    7: .same(proto: "attributes"),
    8: .standard(proto: "stack_trace"),
    9: .standard(proto: "time_events"),
    10: .same(proto: "links"),
    11: .same(proto: "status"),
    16: .same(proto: "resource"),
    12: .standard(proto: "same_process_as_parent_span"),
    13: .standard(proto: "child_span_count"),
  ]

  fileprivate class _StorageClass {
    var _traceID: Data = Data()
    var _spanID: Data = Data()
    var _tracestate: Opencensus_Proto_Trace_V1_Span.Tracestate? = nil
    var _parentSpanID: Data = Data()
    var _name: Opencensus_Proto_Trace_V1_TruncatableString? = nil
    var _kind: Opencensus_Proto_Trace_V1_Span.SpanKind = .unspecified
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attributes: Opencensus_Proto_Trace_V1_Span.Attributes? = nil
    var _stackTrace: Opencensus_Proto_Trace_V1_StackTrace? = nil
    var _timeEvents: Opencensus_Proto_Trace_V1_Span.TimeEvents? = nil
    var _links: Opencensus_Proto_Trace_V1_Span.Links? = nil
    var _status: Opencensus_Proto_Trace_V1_Status? = nil
    var _resource: Opencensus_Proto_Resource_V1_Resource? = nil
    var _sameProcessAsParentSpan: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _childSpanCount: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _traceID = source._traceID
      _spanID = source._spanID
      _tracestate = source._tracestate
      _parentSpanID = source._parentSpanID
      _name = source._name
      _kind = source._kind
      _startTime = source._startTime
      _endTime = source._endTime
      _attributes = source._attributes
      _stackTrace = source._stackTrace
      _timeEvents = source._timeEvents
      _links = source._links
      _status = source._status
      _resource = source._resource
      _sameProcessAsParentSpan = source._sameProcessAsParentSpan
      _childSpanCount = source._childSpanCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._traceID) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._spanID) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._parentSpanID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._attributes) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._stackTrace) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._timeEvents) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._links) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sameProcessAsParentSpan) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._childSpanCount) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tracestate) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._traceID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._traceID, fieldNumber: 1)
      }
      if !_storage._spanID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._spanID, fieldNumber: 2)
      }
      if !_storage._parentSpanID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._parentSpanID, fieldNumber: 3)
      }
      if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._attributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._stackTrace {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._timeEvents {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._links {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._sameProcessAsParentSpan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._childSpanCount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if _storage._kind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 14)
      }
      if let v = _storage._tracestate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span, rhs: Opencensus_Proto_Trace_V1_Span) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._traceID != rhs_storage._traceID {return false}
        if _storage._spanID != rhs_storage._spanID {return false}
        if _storage._tracestate != rhs_storage._tracestate {return false}
        if _storage._parentSpanID != rhs_storage._parentSpanID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        if _storage._stackTrace != rhs_storage._stackTrace {return false}
        if _storage._timeEvents != rhs_storage._timeEvents {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._sameProcessAsParentSpan != rhs_storage._sameProcessAsParentSpan {return false}
        if _storage._childSpanCount != rhs_storage._childSpanCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.SpanKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAN_KIND_UNSPECIFIED"),
    1: .same(proto: "SERVER"),
    2: .same(proto: "CLIENT"),
  ]
}

extension Opencensus_Proto_Trace_V1_Span.Tracestate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.protoMessageName + ".Tracestate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.Tracestate, rhs: Opencensus_Proto_Trace_V1_Span.Tracestate) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.Tracestate.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.Tracestate.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.Tracestate.Entry, rhs: Opencensus_Proto_Trace_V1_Span.Tracestate.Entry) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.Attributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.protoMessageName + ".Attributes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attribute_map"),
    2: .standard(proto: "dropped_attributes_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencensus_Proto_Trace_V1_AttributeValue>.self, value: &self.attributeMap) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedAttributesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attributeMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Opencensus_Proto_Trace_V1_AttributeValue>.self, value: self.attributeMap, fieldNumber: 1)
    }
    if self.droppedAttributesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedAttributesCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.Attributes, rhs: Opencensus_Proto_Trace_V1_Span.Attributes) -> Bool {
    if lhs.attributeMap != rhs.attributeMap {return false}
    if lhs.droppedAttributesCount != rhs.droppedAttributesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.TimeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.protoMessageName + ".TimeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "annotation"),
    3: .standard(proto: "message_event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try {
        var v: Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .annotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .annotation(v)}
      }()
      case 3: try {
        var v: Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .messageEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .messageEvent(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .annotation?: try {
      guard case .annotation(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .messageEvent?: try {
      guard case .messageEvent(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.TimeEvent, rhs: Opencensus_Proto_Trace_V1_Span.TimeEvent) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.TimeEvent.protoMessageName + ".Annotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation, rhs: Opencensus_Proto_Trace_V1_Span.TimeEvent.Annotation) -> Bool {
    if lhs._description_p != rhs._description_p {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.TimeEvent.protoMessageName + ".MessageEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "uncompressed_size"),
    4: .standard(proto: "compressed_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.uncompressedSize) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.compressedSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 2)
    }
    if self.uncompressedSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.uncompressedSize, fieldNumber: 3)
    }
    if self.compressedSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.compressedSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent, rhs: Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.uncompressedSize != rhs.uncompressedSize {return false}
    if lhs.compressedSize != rhs.compressedSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.TimeEvent.MessageEvent.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "SENT"),
    2: .same(proto: "RECEIVED"),
  ]
}

extension Opencensus_Proto_Trace_V1_Span.TimeEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.protoMessageName + ".TimeEvents"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_event"),
    2: .standard(proto: "dropped_annotations_count"),
    3: .standard(proto: "dropped_message_events_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.timeEvent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedAnnotationsCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.droppedMessageEventsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timeEvent.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeEvent, fieldNumber: 1)
    }
    if self.droppedAnnotationsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedAnnotationsCount, fieldNumber: 2)
    }
    if self.droppedMessageEventsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedMessageEventsCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.TimeEvents, rhs: Opencensus_Proto_Trace_V1_Span.TimeEvents) -> Bool {
    if lhs.timeEvent != rhs.timeEvent {return false}
    if lhs.droppedAnnotationsCount != rhs.droppedAnnotationsCount {return false}
    if lhs.droppedMessageEventsCount != rhs.droppedMessageEventsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.protoMessageName + ".Link"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "span_id"),
    3: .same(proto: "type"),
    4: .same(proto: "attributes"),
    5: .same(proto: "tracestate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.traceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.spanID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._tracestate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traceID.isEmpty {
      try visitor.visitSingularBytesField(value: self.traceID, fieldNumber: 1)
    }
    if !self.spanID.isEmpty {
      try visitor.visitSingularBytesField(value: self.spanID, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._tracestate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.Link, rhs: Opencensus_Proto_Trace_V1_Span.Link) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spanID != rhs.spanID {return false}
    if lhs.type != rhs.type {return false}
    if lhs._attributes != rhs._attributes {return false}
    if lhs._tracestate != rhs._tracestate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Span.Link.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "CHILD_LINKED_SPAN"),
    2: .same(proto: "PARENT_LINKED_SPAN"),
  ]
}

extension Opencensus_Proto_Trace_V1_Span.Links: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_Span.protoMessageName + ".Links"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "link"),
    2: .standard(proto: "dropped_links_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.link) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedLinksCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.link.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.link, fieldNumber: 1)
    }
    if self.droppedLinksCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedLinksCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Span.Links, rhs: Opencensus_Proto_Trace_V1_Span.Links) -> Bool {
    if lhs.link != rhs.link {return false}
    if lhs.droppedLinksCount != rhs.droppedLinksCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Status: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Status"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Status, rhs: Opencensus_Proto_Trace_V1_Status) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_AttributeValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_value"),
    2: .standard(proto: "int_value"),
    3: .standard(proto: "bool_value"),
    4: .standard(proto: "double_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Opencensus_Proto_Trace_V1_TruncatableString?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .stringValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .stringValue(v)}
      }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .intValue(v)}
      }()
      case 3: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .boolValue(v)}
      }()
      case 4: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.value = .doubleValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .intValue?: try {
      guard case .intValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_AttributeValue, rhs: Opencensus_Proto_Trace_V1_AttributeValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_StackTrace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StackTrace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stack_frames"),
    2: .standard(proto: "stack_trace_hash_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stackFrames) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.stackTraceHashID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stackFrames {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.stackTraceHashID != 0 {
      try visitor.visitSingularUInt64Field(value: self.stackTraceHashID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_StackTrace, rhs: Opencensus_Proto_Trace_V1_StackTrace) -> Bool {
    if lhs._stackFrames != rhs._stackFrames {return false}
    if lhs.stackTraceHashID != rhs.stackTraceHashID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_StackTrace.StackFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_StackTrace.protoMessageName + ".StackFrame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "function_name"),
    2: .standard(proto: "original_function_name"),
    3: .standard(proto: "file_name"),
    4: .standard(proto: "line_number"),
    5: .standard(proto: "column_number"),
    6: .standard(proto: "load_module"),
    7: .standard(proto: "source_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._functionName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._originalFunctionName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._fileName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lineNumber) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.columnNumber) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._loadModule) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sourceVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._functionName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._originalFunctionName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._fileName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.lineNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.lineNumber, fieldNumber: 4)
    }
    if self.columnNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.columnNumber, fieldNumber: 5)
    }
    if let v = self._loadModule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._sourceVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_StackTrace.StackFrame, rhs: Opencensus_Proto_Trace_V1_StackTrace.StackFrame) -> Bool {
    if lhs._functionName != rhs._functionName {return false}
    if lhs._originalFunctionName != rhs._originalFunctionName {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs.lineNumber != rhs.lineNumber {return false}
    if lhs.columnNumber != rhs.columnNumber {return false}
    if lhs._loadModule != rhs._loadModule {return false}
    if lhs._sourceVersion != rhs._sourceVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_StackTrace.StackFrames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Opencensus_Proto_Trace_V1_StackTrace.protoMessageName + ".StackFrames"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "frame"),
    2: .standard(proto: "dropped_frames_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.frame) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.droppedFramesCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frame.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frame, fieldNumber: 1)
    }
    if self.droppedFramesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.droppedFramesCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_StackTrace.StackFrames, rhs: Opencensus_Proto_Trace_V1_StackTrace.StackFrames) -> Bool {
    if lhs.frame != rhs.frame {return false}
    if lhs.droppedFramesCount != rhs.droppedFramesCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_Module: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Module"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "module"),
    2: .standard(proto: "build_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._module) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._buildID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._module {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._buildID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_Module, rhs: Opencensus_Proto_Trace_V1_Module) -> Bool {
    if lhs._module != rhs._module {return false}
    if lhs._buildID != rhs._buildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Opencensus_Proto_Trace_V1_TruncatableString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TruncatableString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .standard(proto: "truncated_byte_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.truncatedByteCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.truncatedByteCount != 0 {
      try visitor.visitSingularInt32Field(value: self.truncatedByteCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Opencensus_Proto_Trace_V1_TruncatableString, rhs: Opencensus_Proto_Trace_V1_TruncatableString) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.truncatedByteCount != rhs.truncatedByteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

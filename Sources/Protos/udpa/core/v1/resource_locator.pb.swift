// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: udpa/core/v1/resource_locator.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// UDPA resource locators identify a UDPA resource name and instruct the
/// data-plane load balancer on how the resource may be located.
///
/// Resource locators have a canonical udpa:// URI representation:
///
///   udpa://{authority}/{type_url}/{id/*}?{context_params}{#directive,*}
///
/// where context_params take the form of URI query parameters.
///
/// Resource locators have a similar canonical http:// URI representation:
///
///   http://{authority}/{type_url}/{id/*}?{context_params}{#directive,*}
///
/// Resource locators also have a simplified file:// URI representation:
///
///   file:///{id/*}{#directive,*}
public struct Udpa_Core_V1_ResourceLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URI scheme.
  public var scheme: Udpa_Core_V1_ResourceLocator.Scheme = .udpa

  /// Opaque identifiers for the resource. These are effectively concatenated
  /// with ‘/’ to form the non-query param path as resource ID. This may end
  /// with ‘*’ for glob collection references.
  public var id: [String] = []

  /// Logical authority for resource (not necessarily transport network address).
  /// Authorities are opaque in the UDPA API, data-plane load balancers will map
  /// them to concrete network transports such as an xDS management server, e.g.
  /// via envoy.config.core.v3.ConfigSource.
  public var authority: String = String()

  /// Fully qualified resource type (as in type URL without types.googleapis.com/
  /// prefix).
  public var resourceType: String = String()

  public var contextParamSpecifier: Udpa_Core_V1_ResourceLocator.OneOf_ContextParamSpecifier? = nil

  /// Additional parameters that can be used to select resource variants.
  /// Matches must be exact, i.e. all context parameters must match exactly and
  /// there must be no additional context parameters set on the matched
  /// resource.
  public var exactContext: Udpa_Core_V1_ContextParams {
    get {
      if case .exactContext(let v)? = contextParamSpecifier {return v}
      return Udpa_Core_V1_ContextParams()
    }
    set {contextParamSpecifier = .exactContext(newValue)}
  }

  /// A list of directives that appear in the UDPA resource locator #fragment.
  ///
  /// When encoding to URI form, directives are percent encoded with comma
  /// separation.
  public var directives: [Udpa_Core_V1_ResourceLocator.Directive] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ContextParamSpecifier: Equatable {
    /// Additional parameters that can be used to select resource variants.
    /// Matches must be exact, i.e. all context parameters must match exactly and
    /// there must be no additional context parameters set on the matched
    /// resource.
    case exactContext(Udpa_Core_V1_ContextParams)

  #if !swift(>=4.1)
    public static func ==(lhs: Udpa_Core_V1_ResourceLocator.OneOf_ContextParamSpecifier, rhs: Udpa_Core_V1_ResourceLocator.OneOf_ContextParamSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exactContext, .exactContext): return {
        guard case .exactContext(let l) = lhs, case .exactContext(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public enum Scheme: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case udpa // = 0
    case http // = 1
    case file // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .udpa
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .udpa
      case 1: self = .http
      case 2: self = .file
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .udpa: return 0
      case .http: return 1
      case .file: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Directives provide information to data-plane load balancers on how UDPA
  /// resource names are to be interpreted and potentially further resolved. For
  /// example, they may provide alternative resource locators for when primary
  /// resolution fails. Directives are not part of resource names and do not
  /// appear in a xDS transport discovery request.
  ///
  /// When encoding to URIs, directives take the form:
  ///
  /// <directive name>=<string representation of directive value>
  ///
  /// For example, we can have alt=udpa://foo/bar or entry=some%20thing. Each
  /// directive value type may have its own string encoding, in the case of
  /// ResourceLocator there is a recursive URI encoding.
  ///
  /// Percent encoding applies to the URI encoding of the directive value.
  /// Multiple directives are comma-separated, so the reserved characters that
  /// require percent encoding in a directive value are [',', '#', '[', ']',
  /// '%']. These are the RFC3986 fragment reserved characters with the addition
  /// of the UDPA scheme specific ','. See
  /// https://tools.ietf.org/html/rfc3986#page-49 for further details on URI ABNF
  /// and reserved characters.
  public struct Directive {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var directive: Udpa_Core_V1_ResourceLocator.Directive.OneOf_Directive? = nil

    /// An alternative resource locator for fallback if the resource is
    /// unavailable. For example, take the resource locator:
    ///
    ///   udpa://foo/some-type/some-route-table#alt=udpa://bar/some-type/another-route-table
    ///
    /// If the data-plane load balancer is unable to reach `foo` to fetch the
    /// resource, it will fallback to `bar`. Alternative resources do not need
    /// to have equivalent content, but they should be functional substitutes.
    public var alt: Udpa_Core_V1_ResourceLocator {
      get {
        if case .alt(let v)? = directive {return v}
        return Udpa_Core_V1_ResourceLocator()
      }
      set {directive = .alt(newValue)}
    }

    /// List collections support inlining of resources via the entry field in
    /// Resource. These inlined Resource objects may have an optional name
    /// field specified. When specified, the entry directive allows
    /// UdpaResourceLocator to directly reference these inlined resources, e.g.
    /// udpa://.../foo#entry=bar.
    public var entry: String {
      get {
        if case .entry(let v)? = directive {return v}
        return String()
      }
      set {directive = .entry(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Directive: Equatable {
      /// An alternative resource locator for fallback if the resource is
      /// unavailable. For example, take the resource locator:
      ///
      ///   udpa://foo/some-type/some-route-table#alt=udpa://bar/some-type/another-route-table
      ///
      /// If the data-plane load balancer is unable to reach `foo` to fetch the
      /// resource, it will fallback to `bar`. Alternative resources do not need
      /// to have equivalent content, but they should be functional substitutes.
      case alt(Udpa_Core_V1_ResourceLocator)
      /// List collections support inlining of resources via the entry field in
      /// Resource. These inlined Resource objects may have an optional name
      /// field specified. When specified, the entry directive allows
      /// UdpaResourceLocator to directly reference these inlined resources, e.g.
      /// udpa://.../foo#entry=bar.
      case entry(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Udpa_Core_V1_ResourceLocator.Directive.OneOf_Directive, rhs: Udpa_Core_V1_ResourceLocator.Directive.OneOf_Directive) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.alt, .alt): return {
          guard case .alt(let l) = lhs, case .alt(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.entry, .entry): return {
          guard case .entry(let l) = lhs, case .entry(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Udpa_Core_V1_ResourceLocator.Scheme: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Udpa_Core_V1_ResourceLocator.Scheme] = [
    .udpa,
    .http,
    .file,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "udpa.core.v1"

extension Udpa_Core_V1_ResourceLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceLocator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scheme"),
    2: .same(proto: "id"),
    3: .same(proto: "authority"),
    4: .standard(proto: "resource_type"),
    5: .standard(proto: "exact_context"),
    6: .same(proto: "directives"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.scheme) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 5: try {
        var v: Udpa_Core_V1_ContextParams?
        if let current = self.contextParamSpecifier {
          try decoder.handleConflictingOneOf()
          if case .exactContext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.contextParamSpecifier = .exactContext(v)}
      }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.directives) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheme != .udpa {
      try visitor.visitSingularEnumField(value: self.scheme, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitRepeatedStringField(value: self.id, fieldNumber: 2)
    }
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 3)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 4)
    }
    if case .exactContext(let v)? = self.contextParamSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.directives.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directives, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Udpa_Core_V1_ResourceLocator, rhs: Udpa_Core_V1_ResourceLocator) -> Bool {
    if lhs.scheme != rhs.scheme {return false}
    if lhs.id != rhs.id {return false}
    if lhs.authority != rhs.authority {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.contextParamSpecifier != rhs.contextParamSpecifier {return false}
    if lhs.directives != rhs.directives {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Udpa_Core_V1_ResourceLocator.Scheme: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UDPA"),
    1: .same(proto: "HTTP"),
    2: .same(proto: "FILE"),
  ]
}

extension Udpa_Core_V1_ResourceLocator.Directive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Udpa_Core_V1_ResourceLocator.protoMessageName + ".Directive"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alt"),
    2: .same(proto: "entry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Udpa_Core_V1_ResourceLocator?
        if let current = self.directive {
          try decoder.handleConflictingOneOf()
          if case .alt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.directive = .alt(v)}
      }()
      case 2: try {
        if self.directive != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.directive = .entry(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.directive {
    case .alt?: try {
      guard case .alt(let v)? = self.directive else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .entry?: try {
      guard case .entry(let v)? = self.directive else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Udpa_Core_V1_ResourceLocator.Directive, rhs: Udpa_Core_V1_ResourceLocator.Directive) -> Bool {
    if lhs.directive != rhs.directive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

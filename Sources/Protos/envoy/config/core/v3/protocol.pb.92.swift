// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/core/v3/protocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#not-implemented-hide:]
public struct Envoy_Config_Core_V3_TcpProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Envoy_Config_Core_V3_UpstreamHttpProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
  /// upstream connections based on the downstream HTTP host/authority header, as seen by the
  /// :ref:`router filter <config_http_filters_router>`.
  public var autoSni: Bool = false

  /// Automatic validate upstream presented certificate for new upstream connections based on the
  /// downstream HTTP host/authority header, as seen by the
  /// :ref:`router filter <config_http_filters_router>`.
  /// This field is intended to set with `auto_sni` field.
  public var autoSanValidation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [#next-free-field: 6]
public struct Envoy_Config_Core_V3_HttpProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The idle timeout for connections. The idle timeout is defined as the
  /// period in which there are no active requests. When the
  /// idle timeout is reached the connection will be closed. If the connection is an HTTP/2
  /// downstream connection a drain sequence will occur prior to closing the connection, see
  /// :ref:`drain_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
  /// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
  /// If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
  ///
  /// .. warning::
  ///   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  ///   FIN packets, etc.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return self._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {self._idleTimeout = nil}

  /// The maximum duration of a connection. The duration is defined as a period since a connection
  /// was established. If not set, there is no max duration. When max_connection_duration is reached
  /// the connection will be closed. Drain sequence will occur prior to closing the connection if
  /// if's applicable. See :ref:`drain_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
  /// Note: not implemented for upstream connections.
  public var maxConnectionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxConnectionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxConnectionDuration = newValue}
  }
  /// Returns true if `maxConnectionDuration` has been explicitly set.
  public var hasMaxConnectionDuration: Bool {return self._maxConnectionDuration != nil}
  /// Clears the value of `maxConnectionDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConnectionDuration() {self._maxConnectionDuration = nil}

  /// The maximum number of headers. If unconfigured, the default
  /// maximum number of request headers allowed is 100. Requests that exceed this limit will receive
  /// a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
  public var maxHeadersCount: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxHeadersCount ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxHeadersCount = newValue}
  }
  /// Returns true if `maxHeadersCount` has been explicitly set.
  public var hasMaxHeadersCount: Bool {return self._maxHeadersCount != nil}
  /// Clears the value of `maxHeadersCount`. Subsequent reads from it will return its default value.
  public mutating func clearMaxHeadersCount() {self._maxHeadersCount = nil}

  /// Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
  /// reset independent of any other timeouts. If not specified, this value is not set.
  public var maxStreamDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxStreamDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxStreamDuration = newValue}
  }
  /// Returns true if `maxStreamDuration` has been explicitly set.
  public var hasMaxStreamDuration: Bool {return self._maxStreamDuration != nil}
  /// Clears the value of `maxStreamDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxStreamDuration() {self._maxStreamDuration = nil}

  /// Action to take when a client request with a header name containing underscore characters is received.
  /// If this setting is not specified, the value defaults to ALLOW.
  /// Note: upstream responses are not affected by this setting.
  public var headersWithUnderscoresAction: Envoy_Config_Core_V3_HttpProtocolOptions.HeadersWithUnderscoresAction = .allow

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Action to take when Envoy receives client request with header names containing underscore
  /// characters.
  /// Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
  /// as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
  /// characters.
  public enum HeadersWithUnderscoresAction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow headers with underscores. This is the default behavior.
    case allow // = 0

    /// Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
    /// end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
    /// is incremented for each rejected request.
    case rejectRequest // = 1

    /// Drop the header with name containing underscores. The header is dropped before the filter chain is
    /// invoked and as such filters will not see dropped headers. The
    /// "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
    case dropHeader // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .allow
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allow
      case 1: self = .rejectRequest
      case 2: self = .dropHeader
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allow: return 0
      case .rejectRequest: return 1
      case .dropHeader: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxConnectionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxHeadersCount: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxStreamDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Envoy_Config_Core_V3_HttpProtocolOptions.HeadersWithUnderscoresAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Core_V3_HttpProtocolOptions.HeadersWithUnderscoresAction] = [
    .allow,
    .rejectRequest,
    .dropHeader,
  ]
}

#endif  // swift(>=4.2)

/// [#next-free-field: 8]
public struct Envoy_Config_Core_V3_Http1ProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Handle HTTP requests with absolute URLs in the requests. These requests
  /// are generally sent by clients to forward/explicit proxies. This allows clients to configure
  /// envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
  /// *http_proxy* environment variable.
  public var allowAbsoluteURL: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _allowAbsoluteURL ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_allowAbsoluteURL = newValue}
  }
  /// Returns true if `allowAbsoluteURL` has been explicitly set.
  public var hasAllowAbsoluteURL: Bool {return self._allowAbsoluteURL != nil}
  /// Clears the value of `allowAbsoluteURL`. Subsequent reads from it will return its default value.
  public mutating func clearAllowAbsoluteURL() {self._allowAbsoluteURL = nil}

  /// Handle incoming HTTP/1.0 and HTTP 0.9 requests.
  /// This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
  /// style connect logic, dechunking, and handling lack of client host iff
  /// *default_host_for_http_10* is configured.
  public var acceptHTTP10: Bool = false

  /// A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
  /// Envoy does not otherwise support HTTP/1.0 without a Host header.
  /// This is a no-op if *accept_http_10* is not true.
  public var defaultHostForHTTP10: String = String()

  /// Describes how the keys for response headers should be formatted. By default, all header keys
  /// are lower cased.
  public var headerKeyFormat: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat {
    get {return _headerKeyFormat ?? Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat()}
    set {_headerKeyFormat = newValue}
  }
  /// Returns true if `headerKeyFormat` has been explicitly set.
  public var hasHeaderKeyFormat: Bool {return self._headerKeyFormat != nil}
  /// Clears the value of `headerKeyFormat`. Subsequent reads from it will return its default value.
  public mutating func clearHeaderKeyFormat() {self._headerKeyFormat = nil}

  /// Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
  ///
  /// .. attention::
  ///
  ///   Note that this only happens when Envoy is chunk encoding which occurs when:
  ///   - The request is HTTP/1.1.
  ///   - Is neither a HEAD only request nor a HTTP Upgrade.
  ///   - Not a response to a HEAD request.
  ///   - The content length header is not present.
  public var enableTrailers: Bool = false

  /// Allows Envoy to process requests/responses with both `Content-Length` and `Transfer-Encoding`
  /// headers set. By default such messages are rejected, but if option is enabled - Envoy will
  /// remove Content-Length header and process message.
  /// See `RFC7230, sec. 3.3.3 <https://tools.ietf.org/html/rfc7230#section-3.3.3>` for details.
  ///
  /// .. attention::
  ///   Enabling this option might lead to request smuggling vulnerability, especially if traffic
  ///   is proxied via multiple layers of proxies.
  public var allowChunkedLength: Bool = false

  /// Allows invalid HTTP messaging. When this option is false, then Envoy will terminate
  /// HTTP/1.1 connections upon receiving an invalid HTTP message. However,
  /// when this option is true, then Envoy will leave the HTTP/1.1 connection
  /// open where possible.
  /// If set, this overrides any HCM :ref:`stream_error_on_invalid_http_messaging
  /// <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`.
  public var overrideStreamErrorOnInvalidHTTPMessage: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _overrideStreamErrorOnInvalidHTTPMessage ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_overrideStreamErrorOnInvalidHTTPMessage = newValue}
  }
  /// Returns true if `overrideStreamErrorOnInvalidHTTPMessage` has been explicitly set.
  public var hasOverrideStreamErrorOnInvalidHTTPMessage: Bool {return self._overrideStreamErrorOnInvalidHTTPMessage != nil}
  /// Clears the value of `overrideStreamErrorOnInvalidHTTPMessage`. Subsequent reads from it will return its default value.
  public mutating func clearOverrideStreamErrorOnInvalidHTTPMessage() {self._overrideStreamErrorOnInvalidHTTPMessage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct HeaderKeyFormat {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var headerFormat: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.OneOf_HeaderFormat? = nil

    /// Formats the header by proper casing words: the first character and any character following
    /// a special character will be capitalized if it's an alpha character. For example,
    /// "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
    /// Note that while this results in most headers following conventional casing, certain headers
    /// are not covered. For example, the "TE" header will be formatted as "Te".
    public var properCaseWords: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords {
      get {
        if case .properCaseWords(let v)? = headerFormat {return v}
        return Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords()
      }
      set {headerFormat = .properCaseWords(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_HeaderFormat: Equatable {
      /// Formats the header by proper casing words: the first character and any character following
      /// a special character will be capitalized if it's an alpha character. For example,
      /// "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
      /// Note that while this results in most headers following conventional casing, certain headers
      /// are not covered. For example, the "TE" header will be formatted as "Te".
      case properCaseWords(Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.OneOf_HeaderFormat, rhs: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.OneOf_HeaderFormat) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.properCaseWords, .properCaseWords): return {
          guard case .properCaseWords(let l) = lhs, case .properCaseWords(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public struct ProperCaseWords {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _allowAbsoluteURL: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _headerKeyFormat: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat? = nil
  fileprivate var _overrideStreamErrorOnInvalidHTTPMessage: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Envoy_Config_Core_V3_KeepaliveSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Send HTTP/2 PING frames at this period, in order to test that the connection is still alive.
  public var interval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _interval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  public var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  public mutating func clearInterval() {self._interval = nil}

  /// How long to wait for a response to a keepalive PING. If a response is not received within this
  /// time period, the connection will be aborted.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// A random jitter amount as a percentage of interval that will be added to each interval.
  /// A value of zero means there will be no jitter.
  /// The default value is 15%.
  public var intervalJitter: Envoy_Type_V3_Percent {
    get {return _intervalJitter ?? Envoy_Type_V3_Percent()}
    set {_intervalJitter = newValue}
  }
  /// Returns true if `intervalJitter` has been explicitly set.
  public var hasIntervalJitter: Bool {return self._intervalJitter != nil}
  /// Clears the value of `intervalJitter`. Subsequent reads from it will return its default value.
  public mutating func clearIntervalJitter() {self._intervalJitter = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _intervalJitter: Envoy_Type_V3_Percent? = nil
}

/// [#next-free-field: 16]
public struct Envoy_Config_Core_V3_Http2ProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
  /// (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
  /// range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
  /// compression.
  public var hpackTableSize: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._hpackTableSize ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._hpackTableSize = newValue}
  }
  /// Returns true if `hpackTableSize` has been explicitly set.
  public var hasHpackTableSize: Bool {return _storage._hpackTableSize != nil}
  /// Clears the value of `hpackTableSize`. Subsequent reads from it will return its default value.
  public mutating func clearHpackTableSize() {_uniqueStorage()._hpackTableSize = nil}

  /// `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
  /// allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
  /// and defaults to 2147483647.
  ///
  /// For upstream connections, this also limits how many streams Envoy will initiate concurrently
  /// on a single connection. If the limit is reached, Envoy may queue requests or establish
  /// additional connections (as allowed per circuit breaker limits).
  public var maxConcurrentStreams: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxConcurrentStreams ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxConcurrentStreams = newValue}
  }
  /// Returns true if `maxConcurrentStreams` has been explicitly set.
  public var hasMaxConcurrentStreams: Bool {return _storage._maxConcurrentStreams != nil}
  /// Clears the value of `maxConcurrentStreams`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConcurrentStreams() {_uniqueStorage()._maxConcurrentStreams = nil}

  /// `Initial stream-level flow-control window
  /// <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
  /// (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
  /// (256 * 1024 * 1024).
  ///
  /// NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
  /// window size now, so it's also the minimum.
  ///
  /// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
  /// HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
  /// stop the flow of data to the codec buffers.
  public var initialStreamWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._initialStreamWindowSize ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._initialStreamWindowSize = newValue}
  }
  /// Returns true if `initialStreamWindowSize` has been explicitly set.
  public var hasInitialStreamWindowSize: Bool {return _storage._initialStreamWindowSize != nil}
  /// Clears the value of `initialStreamWindowSize`. Subsequent reads from it will return its default value.
  public mutating func clearInitialStreamWindowSize() {_uniqueStorage()._initialStreamWindowSize = nil}

  /// Similar to *initial_stream_window_size*, but for connection-level flow-control
  /// window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
  public var initialConnectionWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._initialConnectionWindowSize ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._initialConnectionWindowSize = newValue}
  }
  /// Returns true if `initialConnectionWindowSize` has been explicitly set.
  public var hasInitialConnectionWindowSize: Bool {return _storage._initialConnectionWindowSize != nil}
  /// Clears the value of `initialConnectionWindowSize`. Subsequent reads from it will return its default value.
  public mutating func clearInitialConnectionWindowSize() {_uniqueStorage()._initialConnectionWindowSize = nil}

  /// Allows proxying Websocket and other upgrades over H2 connect.
  public var allowConnect: Bool {
    get {return _storage._allowConnect}
    set {_uniqueStorage()._allowConnect = newValue}
  }

  /// [#not-implemented-hide:] Hiding until envoy has full metadata support.
  /// Still under implementation. DO NOT USE.
  ///
  /// Allows metadata. See [metadata
  /// docs](https://github.com/envoyproxy/envoy/blob/master/source/docs/h2_metadata.md) for more
  /// information.
  public var allowMetadata: Bool {
    get {return _storage._allowMetadata}
    set {_uniqueStorage()._allowMetadata = newValue}
  }

  /// Limit the number of pending outbound downstream frames of all types (frames that are waiting to
  /// be written into the socket). Exceeding this limit triggers flood mitigation and connection is
  /// terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
  /// to flood mitigation. The default limit is 10000.
  /// NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
  /// `envoy.reloadable_features.upstream_http2_flood_checks` flag.
  public var maxOutboundFrames: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxOutboundFrames ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxOutboundFrames = newValue}
  }
  /// Returns true if `maxOutboundFrames` has been explicitly set.
  public var hasMaxOutboundFrames: Bool {return _storage._maxOutboundFrames != nil}
  /// Clears the value of `maxOutboundFrames`. Subsequent reads from it will return its default value.
  public mutating func clearMaxOutboundFrames() {_uniqueStorage()._maxOutboundFrames = nil}

  /// Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
  /// preventing high memory utilization when receiving continuous stream of these frames. Exceeding
  /// this limit triggers flood mitigation and connection is terminated. The
  /// ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
  /// mitigation. The default limit is 1000.
  /// NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
  /// `envoy.reloadable_features.upstream_http2_flood_checks` flag.
  public var maxOutboundControlFrames: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxOutboundControlFrames ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxOutboundControlFrames = newValue}
  }
  /// Returns true if `maxOutboundControlFrames` has been explicitly set.
  public var hasMaxOutboundControlFrames: Bool {return _storage._maxOutboundControlFrames != nil}
  /// Clears the value of `maxOutboundControlFrames`. Subsequent reads from it will return its default value.
  public mutating func clearMaxOutboundControlFrames() {_uniqueStorage()._maxOutboundControlFrames = nil}

  /// Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
  /// empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
  /// might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
  /// stat tracks the number of connections terminated due to flood mitigation.
  /// Setting this to 0 will terminate connection upon receiving first frame with an empty payload
  /// and no end stream flag. The default limit is 1.
  /// NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
  /// `envoy.reloadable_features.upstream_http2_flood_checks` flag.
  public var maxConsecutiveInboundFramesWithEmptyPayload: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxConsecutiveInboundFramesWithEmptyPayload ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxConsecutiveInboundFramesWithEmptyPayload = newValue}
  }
  /// Returns true if `maxConsecutiveInboundFramesWithEmptyPayload` has been explicitly set.
  public var hasMaxConsecutiveInboundFramesWithEmptyPayload: Bool {return _storage._maxConsecutiveInboundFramesWithEmptyPayload != nil}
  /// Clears the value of `maxConsecutiveInboundFramesWithEmptyPayload`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConsecutiveInboundFramesWithEmptyPayload() {_uniqueStorage()._maxConsecutiveInboundFramesWithEmptyPayload = nil}

  /// Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
  /// of PRIORITY frames received over the lifetime of connection exceeds the value calculated
  /// using this formula::
  ///
  ///     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
  ///
  /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
  /// the number of connections terminated due to flood mitigation. The default limit is 100.
  /// NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
  /// `envoy.reloadable_features.upstream_http2_flood_checks` flag.
  public var maxInboundPriorityFramesPerStream: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxInboundPriorityFramesPerStream ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxInboundPriorityFramesPerStream = newValue}
  }
  /// Returns true if `maxInboundPriorityFramesPerStream` has been explicitly set.
  public var hasMaxInboundPriorityFramesPerStream: Bool {return _storage._maxInboundPriorityFramesPerStream != nil}
  /// Clears the value of `maxInboundPriorityFramesPerStream`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInboundPriorityFramesPerStream() {_uniqueStorage()._maxInboundPriorityFramesPerStream = nil}

  /// Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
  /// of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
  /// using this formula::
  ///
  ///     1 + 2 * (inbound_streams +
  ///              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
  ///
  /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
  /// the number of connections terminated due to flood mitigation. The default limit is 10.
  /// Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
  /// but more complex implementations that try to estimate available bandwidth require at least 2.
  /// NOTE: flood and abuse mitigation for upstream connections is presently enabled by the
  /// `envoy.reloadable_features.upstream_http2_flood_checks` flag.
  public var maxInboundWindowUpdateFramesPerDataFrameSent: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxInboundWindowUpdateFramesPerDataFrameSent ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxInboundWindowUpdateFramesPerDataFrameSent = newValue}
  }
  /// Returns true if `maxInboundWindowUpdateFramesPerDataFrameSent` has been explicitly set.
  public var hasMaxInboundWindowUpdateFramesPerDataFrameSent: Bool {return _storage._maxInboundWindowUpdateFramesPerDataFrameSent != nil}
  /// Clears the value of `maxInboundWindowUpdateFramesPerDataFrameSent`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInboundWindowUpdateFramesPerDataFrameSent() {_uniqueStorage()._maxInboundWindowUpdateFramesPerDataFrameSent = nil}

  /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
  /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
  /// when this option is enabled, only the offending stream is terminated.
  ///
  /// This is overridden by HCM :ref:`stream_error_on_invalid_http_messaging
  /// <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
  /// iff present.
  ///
  /// This is deprecated in favor of :ref:`override_stream_error_on_invalid_http_message
  /// <envoy_v3_api_field_config.core.v3.Http2ProtocolOptions.override_stream_error_on_invalid_http_message>`
  ///
  /// See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
  public var streamErrorOnInvalidHTTPMessaging: Bool {
    get {return _storage._streamErrorOnInvalidHTTPMessaging}
    set {_uniqueStorage()._streamErrorOnInvalidHTTPMessaging = newValue}
  }

  /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
  /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
  /// when this option is enabled, only the offending stream is terminated.
  ///
  /// This overrides any HCM :ref:`stream_error_on_invalid_http_messaging
  /// <envoy_v3_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_error_on_invalid_http_message>`
  ///
  /// See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
  public var overrideStreamErrorOnInvalidHTTPMessage: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._overrideStreamErrorOnInvalidHTTPMessage ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._overrideStreamErrorOnInvalidHTTPMessage = newValue}
  }
  /// Returns true if `overrideStreamErrorOnInvalidHTTPMessage` has been explicitly set.
  public var hasOverrideStreamErrorOnInvalidHTTPMessage: Bool {return _storage._overrideStreamErrorOnInvalidHTTPMessage != nil}
  /// Clears the value of `overrideStreamErrorOnInvalidHTTPMessage`. Subsequent reads from it will return its default value.
  public mutating func clearOverrideStreamErrorOnInvalidHTTPMessage() {_uniqueStorage()._overrideStreamErrorOnInvalidHTTPMessage = nil}

  /// [#not-implemented-hide:]
  /// Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
  ///
  /// 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
  /// Envoy.
  ///
  /// 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
  /// 'allow_connect'.
  ///
  /// Note that custom parameters specified through this field can not also be set in the
  /// corresponding named parameters:
  ///
  /// .. code-block:: text
  ///
  ///   ID    Field Name
  ///   ----------------
  ///   0x1   hpack_table_size
  ///   0x3   max_concurrent_streams
  ///   0x4   initial_stream_window_size
  ///
  /// Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
  /// between custom parameters with the same identifier will trigger a failure.
  ///
  /// See `IANA HTTP/2 Settings
  /// <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
  /// standardized identifiers.
  public var customSettingsParameters: [Envoy_Config_Core_V3_Http2ProtocolOptions.SettingsParameter] {
    get {return _storage._customSettingsParameters}
    set {_uniqueStorage()._customSettingsParameters = newValue}
  }

  /// Send HTTP/2 PING frames to verify that the connection is still healthy. If the remote peer
  /// does not respond within the configured timeout, the connection will be aborted.
  public var connectionKeepalive: Envoy_Config_Core_V3_KeepaliveSettings {
    get {return _storage._connectionKeepalive ?? Envoy_Config_Core_V3_KeepaliveSettings()}
    set {_uniqueStorage()._connectionKeepalive = newValue}
  }
  /// Returns true if `connectionKeepalive` has been explicitly set.
  public var hasConnectionKeepalive: Bool {return _storage._connectionKeepalive != nil}
  /// Clears the value of `connectionKeepalive`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionKeepalive() {_uniqueStorage()._connectionKeepalive = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines a parameter to be sent in the SETTINGS frame.
  /// See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
  public struct SettingsParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The 16 bit parameter identifier.
    public var identifier: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _identifier ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    public var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    public mutating func clearIdentifier() {self._identifier = nil}

    /// The 32 bit parameter value.
    public var value: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _value ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _identifier: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _value: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// [#not-implemented-hide:]
public struct Envoy_Config_Core_V3_GrpcProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var http2ProtocolOptions: Envoy_Config_Core_V3_Http2ProtocolOptions {
    get {return _http2ProtocolOptions ?? Envoy_Config_Core_V3_Http2ProtocolOptions()}
    set {_http2ProtocolOptions = newValue}
  }
  /// Returns true if `http2ProtocolOptions` has been explicitly set.
  public var hasHTTP2ProtocolOptions: Bool {return self._http2ProtocolOptions != nil}
  /// Clears the value of `http2ProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearHTTP2ProtocolOptions() {self._http2ProtocolOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _http2ProtocolOptions: Envoy_Config_Core_V3_Http2ProtocolOptions? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.core.v3"

extension Envoy_Config_Core_V3_TcpProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TcpProtocolOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_TcpProtocolOptions, rhs: Envoy_Config_Core_V3_TcpProtocolOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_UpstreamHttpProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamHttpProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_sni"),
    2: .standard(proto: "auto_san_validation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.autoSni) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.autoSanValidation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.autoSni != false {
      try visitor.visitSingularBoolField(value: self.autoSni, fieldNumber: 1)
    }
    if self.autoSanValidation != false {
      try visitor.visitSingularBoolField(value: self.autoSanValidation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_UpstreamHttpProtocolOptions, rhs: Envoy_Config_Core_V3_UpstreamHttpProtocolOptions) -> Bool {
    if lhs.autoSni != rhs.autoSni {return false}
    if lhs.autoSanValidation != rhs.autoSanValidation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_HttpProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "idle_timeout"),
    3: .standard(proto: "max_connection_duration"),
    2: .standard(proto: "max_headers_count"),
    4: .standard(proto: "max_stream_duration"),
    5: .standard(proto: "headers_with_underscores_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idleTimeout) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxHeadersCount) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxConnectionDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxStreamDuration) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.headersWithUnderscoresAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._idleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxHeadersCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._maxConnectionDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._maxStreamDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.headersWithUnderscoresAction != .allow {
      try visitor.visitSingularEnumField(value: self.headersWithUnderscoresAction, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_HttpProtocolOptions, rhs: Envoy_Config_Core_V3_HttpProtocolOptions) -> Bool {
    if lhs._idleTimeout != rhs._idleTimeout {return false}
    if lhs._maxConnectionDuration != rhs._maxConnectionDuration {return false}
    if lhs._maxHeadersCount != rhs._maxHeadersCount {return false}
    if lhs._maxStreamDuration != rhs._maxStreamDuration {return false}
    if lhs.headersWithUnderscoresAction != rhs.headersWithUnderscoresAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_HttpProtocolOptions.HeadersWithUnderscoresAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW"),
    1: .same(proto: "REJECT_REQUEST"),
    2: .same(proto: "DROP_HEADER"),
  ]
}

extension Envoy_Config_Core_V3_Http1ProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Http1ProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_absolute_url"),
    2: .standard(proto: "accept_http_10"),
    3: .standard(proto: "default_host_for_http_10"),
    4: .standard(proto: "header_key_format"),
    5: .standard(proto: "enable_trailers"),
    6: .standard(proto: "allow_chunked_length"),
    7: .standard(proto: "override_stream_error_on_invalid_http_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._allowAbsoluteURL) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.acceptHTTP10) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultHostForHTTP10) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._headerKeyFormat) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableTrailers) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.allowChunkedLength) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._overrideStreamErrorOnInvalidHTTPMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._allowAbsoluteURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.acceptHTTP10 != false {
      try visitor.visitSingularBoolField(value: self.acceptHTTP10, fieldNumber: 2)
    }
    if !self.defaultHostForHTTP10.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultHostForHTTP10, fieldNumber: 3)
    }
    if let v = self._headerKeyFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.enableTrailers != false {
      try visitor.visitSingularBoolField(value: self.enableTrailers, fieldNumber: 5)
    }
    if self.allowChunkedLength != false {
      try visitor.visitSingularBoolField(value: self.allowChunkedLength, fieldNumber: 6)
    }
    if let v = self._overrideStreamErrorOnInvalidHTTPMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Http1ProtocolOptions, rhs: Envoy_Config_Core_V3_Http1ProtocolOptions) -> Bool {
    if lhs._allowAbsoluteURL != rhs._allowAbsoluteURL {return false}
    if lhs.acceptHTTP10 != rhs.acceptHTTP10 {return false}
    if lhs.defaultHostForHTTP10 != rhs.defaultHostForHTTP10 {return false}
    if lhs._headerKeyFormat != rhs._headerKeyFormat {return false}
    if lhs.enableTrailers != rhs.enableTrailers {return false}
    if lhs.allowChunkedLength != rhs.allowChunkedLength {return false}
    if lhs._overrideStreamErrorOnInvalidHTTPMessage != rhs._overrideStreamErrorOnInvalidHTTPMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Core_V3_Http1ProtocolOptions.protoMessageName + ".HeaderKeyFormat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proper_case_words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords?
        if let current = self.headerFormat {
          try decoder.handleConflictingOneOf()
          if case .properCaseWords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.headerFormat = .properCaseWords(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .properCaseWords(let v)? = self.headerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat, rhs: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat) -> Bool {
    if lhs.headerFormat != rhs.headerFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.protoMessageName + ".ProperCaseWords"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords, rhs: Envoy_Config_Core_V3_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_KeepaliveSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeepaliveSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .same(proto: "timeout"),
    3: .standard(proto: "interval_jitter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._interval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._intervalJitter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._interval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._intervalJitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_KeepaliveSettings, rhs: Envoy_Config_Core_V3_KeepaliveSettings) -> Bool {
    if lhs._interval != rhs._interval {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._intervalJitter != rhs._intervalJitter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Http2ProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Http2ProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hpack_table_size"),
    2: .standard(proto: "max_concurrent_streams"),
    3: .standard(proto: "initial_stream_window_size"),
    4: .standard(proto: "initial_connection_window_size"),
    5: .standard(proto: "allow_connect"),
    6: .standard(proto: "allow_metadata"),
    7: .standard(proto: "max_outbound_frames"),
    8: .standard(proto: "max_outbound_control_frames"),
    9: .standard(proto: "max_consecutive_inbound_frames_with_empty_payload"),
    10: .standard(proto: "max_inbound_priority_frames_per_stream"),
    11: .standard(proto: "max_inbound_window_update_frames_per_data_frame_sent"),
    12: .standard(proto: "stream_error_on_invalid_http_messaging"),
    14: .standard(proto: "override_stream_error_on_invalid_http_message"),
    13: .standard(proto: "custom_settings_parameters"),
    15: .standard(proto: "connection_keepalive"),
  ]

  fileprivate class _StorageClass {
    var _hpackTableSize: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _maxConcurrentStreams: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _initialStreamWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _initialConnectionWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _allowConnect: Bool = false
    var _allowMetadata: Bool = false
    var _maxOutboundFrames: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _maxOutboundControlFrames: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _maxConsecutiveInboundFramesWithEmptyPayload: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _maxInboundPriorityFramesPerStream: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _maxInboundWindowUpdateFramesPerDataFrameSent: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _streamErrorOnInvalidHTTPMessaging: Bool = false
    var _overrideStreamErrorOnInvalidHTTPMessage: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _customSettingsParameters: [Envoy_Config_Core_V3_Http2ProtocolOptions.SettingsParameter] = []
    var _connectionKeepalive: Envoy_Config_Core_V3_KeepaliveSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _hpackTableSize = source._hpackTableSize
      _maxConcurrentStreams = source._maxConcurrentStreams
      _initialStreamWindowSize = source._initialStreamWindowSize
      _initialConnectionWindowSize = source._initialConnectionWindowSize
      _allowConnect = source._allowConnect
      _allowMetadata = source._allowMetadata
      _maxOutboundFrames = source._maxOutboundFrames
      _maxOutboundControlFrames = source._maxOutboundControlFrames
      _maxConsecutiveInboundFramesWithEmptyPayload = source._maxConsecutiveInboundFramesWithEmptyPayload
      _maxInboundPriorityFramesPerStream = source._maxInboundPriorityFramesPerStream
      _maxInboundWindowUpdateFramesPerDataFrameSent = source._maxInboundWindowUpdateFramesPerDataFrameSent
      _streamErrorOnInvalidHTTPMessaging = source._streamErrorOnInvalidHTTPMessaging
      _overrideStreamErrorOnInvalidHTTPMessage = source._overrideStreamErrorOnInvalidHTTPMessage
      _customSettingsParameters = source._customSettingsParameters
      _connectionKeepalive = source._connectionKeepalive
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._hpackTableSize) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._maxConcurrentStreams) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._initialStreamWindowSize) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._initialConnectionWindowSize) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._allowConnect) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._allowMetadata) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._maxOutboundFrames) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._maxOutboundControlFrames) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._maxConsecutiveInboundFramesWithEmptyPayload) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._maxInboundPriorityFramesPerStream) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._maxInboundWindowUpdateFramesPerDataFrameSent) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._streamErrorOnInvalidHTTPMessaging) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._customSettingsParameters) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._overrideStreamErrorOnInvalidHTTPMessage) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._connectionKeepalive) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._hpackTableSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._maxConcurrentStreams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._initialStreamWindowSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._initialConnectionWindowSize {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._allowConnect != false {
        try visitor.visitSingularBoolField(value: _storage._allowConnect, fieldNumber: 5)
      }
      if _storage._allowMetadata != false {
        try visitor.visitSingularBoolField(value: _storage._allowMetadata, fieldNumber: 6)
      }
      if let v = _storage._maxOutboundFrames {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._maxOutboundControlFrames {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._maxConsecutiveInboundFramesWithEmptyPayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._maxInboundPriorityFramesPerStream {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._maxInboundWindowUpdateFramesPerDataFrameSent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._streamErrorOnInvalidHTTPMessaging != false {
        try visitor.visitSingularBoolField(value: _storage._streamErrorOnInvalidHTTPMessaging, fieldNumber: 12)
      }
      if !_storage._customSettingsParameters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customSettingsParameters, fieldNumber: 13)
      }
      if let v = _storage._overrideStreamErrorOnInvalidHTTPMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._connectionKeepalive {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Http2ProtocolOptions, rhs: Envoy_Config_Core_V3_Http2ProtocolOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hpackTableSize != rhs_storage._hpackTableSize {return false}
        if _storage._maxConcurrentStreams != rhs_storage._maxConcurrentStreams {return false}
        if _storage._initialStreamWindowSize != rhs_storage._initialStreamWindowSize {return false}
        if _storage._initialConnectionWindowSize != rhs_storage._initialConnectionWindowSize {return false}
        if _storage._allowConnect != rhs_storage._allowConnect {return false}
        if _storage._allowMetadata != rhs_storage._allowMetadata {return false}
        if _storage._maxOutboundFrames != rhs_storage._maxOutboundFrames {return false}
        if _storage._maxOutboundControlFrames != rhs_storage._maxOutboundControlFrames {return false}
        if _storage._maxConsecutiveInboundFramesWithEmptyPayload != rhs_storage._maxConsecutiveInboundFramesWithEmptyPayload {return false}
        if _storage._maxInboundPriorityFramesPerStream != rhs_storage._maxInboundPriorityFramesPerStream {return false}
        if _storage._maxInboundWindowUpdateFramesPerDataFrameSent != rhs_storage._maxInboundWindowUpdateFramesPerDataFrameSent {return false}
        if _storage._streamErrorOnInvalidHTTPMessaging != rhs_storage._streamErrorOnInvalidHTTPMessaging {return false}
        if _storage._overrideStreamErrorOnInvalidHTTPMessage != rhs_storage._overrideStreamErrorOnInvalidHTTPMessage {return false}
        if _storage._customSettingsParameters != rhs_storage._customSettingsParameters {return false}
        if _storage._connectionKeepalive != rhs_storage._connectionKeepalive {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Http2ProtocolOptions.SettingsParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Core_V3_Http2ProtocolOptions.protoMessageName + ".SettingsParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Http2ProtocolOptions.SettingsParameter, rhs: Envoy_Config_Core_V3_Http2ProtocolOptions.SettingsParameter) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_GrpcProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrpcProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http2_protocol_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._http2ProtocolOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._http2ProtocolOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_GrpcProtocolOptions, rhs: Envoy_Config_Core_V3_GrpcProtocolOptions) -> Bool {
    if lhs._http2ProtocolOptions != rhs._http2ProtocolOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

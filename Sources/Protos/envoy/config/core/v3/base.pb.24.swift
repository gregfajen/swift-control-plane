// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/core/v3/base.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Envoy supports :ref:`upstream priority routing
/// <arch_overview_http_routing_priority>` both at the route and the virtual
/// cluster level. The current priority implementation uses different connection
/// pool and circuit breaking settings for each priority level. This means that
/// even for HTTP/2 requests, two physical connections will be used to an
/// upstream host. In the future Envoy will likely support true HTTP/2 priority
/// over a single upstream connection.
public enum Envoy_Config_Core_V3_RoutingPriority: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case `default` // = 0
  case high // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .default
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .default: return 0
    case .high: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Envoy_Config_Core_V3_RoutingPriority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Core_V3_RoutingPriority] = [
    .default,
    .high,
  ]
}

#endif  // swift(>=4.2)

/// HTTP request method.
public enum Envoy_Config_Core_V3_RequestMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case methodUnspecified // = 0
  case get // = 1
  case head // = 2
  case post // = 3
  case put // = 4
  case delete // = 5
  case connect // = 6
  case options // = 7
  case trace // = 8
  case patch // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .methodUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .methodUnspecified
    case 1: self = .get
    case 2: self = .head
    case 3: self = .post
    case 4: self = .put
    case 5: self = .delete
    case 6: self = .connect
    case 7: self = .options
    case 8: self = .trace
    case 9: self = .patch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .methodUnspecified: return 0
    case .get: return 1
    case .head: return 2
    case .post: return 3
    case .put: return 4
    case .delete: return 5
    case .connect: return 6
    case .options: return 7
    case .trace: return 8
    case .patch: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Envoy_Config_Core_V3_RequestMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Core_V3_RequestMethod] = [
    .methodUnspecified,
    .get,
    .head,
    .post,
    .put,
    .delete,
    .connect,
    .options,
    .trace,
    .patch,
  ]
}

#endif  // swift(>=4.2)

/// Identifies the direction of the traffic relative to the local Envoy.
public enum Envoy_Config_Core_V3_TrafficDirection: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default option is unspecified.
  case unspecified // = 0

  /// The transport is used for incoming traffic.
  case inbound // = 1

  /// The transport is used for outgoing traffic.
  case outbound // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .inbound
    case 2: self = .outbound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .inbound: return 1
    case .outbound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Envoy_Config_Core_V3_TrafficDirection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Core_V3_TrafficDirection] = [
    .unspecified,
    .inbound,
    .outbound,
  ]
}

#endif  // swift(>=4.2)

/// Identifies location of where either Envoy runs or where upstream hosts run.
public struct Envoy_Config_Core_V3_Locality {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Region this :ref:`zone <envoy_api_field_config.core.v3.Locality.zone>` belongs to.
  public var region: String = String()

  /// Defines the local service zone where Envoy is running. Though optional, it
  /// should be set if discovery service routing is used and the discovery
  /// service exposes :ref:`zone data <envoy_api_field_config.endpoint.v3.LocalityLbEndpoints.locality>`,
  /// either in this message or via :option:`--service-zone`. The meaning of zone
  /// is context dependent, e.g. `Availability Zone (AZ)
  /// <https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html>`_
  /// on AWS, `Zone <https://cloud.google.com/compute/docs/regions-zones/>`_ on
  /// GCP, etc.
  public var zone: String = String()

  /// When used for locality of upstream hosts, this field further splits zone
  /// into smaller chunks of sub-zones so they can be load balanced
  /// independently.
  public var subZone: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BuildVersion combines SemVer version of extension with free-form build information
/// (i.e. 'alpha', 'private-build') as a set of strings.
public struct Envoy_Config_Core_V3_BuildVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SemVer version of extension.
  public var version: Envoy_Type_V3_SemanticVersion {
    get {return _version ?? Envoy_Type_V3_SemanticVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  /// Free-form build information.
  /// Envoy defines several well known keys in the source/common/version/version.h file
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Envoy_Type_V3_SemanticVersion? = nil
  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Version and identification for an Envoy extension.
/// [#next-free-field: 6]
public struct Envoy_Config_Core_V3_Extension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is the name of the Envoy filter as specified in the Envoy
  /// configuration, e.g. envoy.filters.http.router, com.acme.widget.
  public var name: String = String()

  /// Category of the extension.
  /// Extension category names use reverse DNS notation. For instance "envoy.filters.listener"
  /// for Envoy's built-in listener filters or "com.acme.filters.http" for HTTP filters from
  /// acme.com vendor.
  /// [#comment:TODO(yanavlasov): Link to the doc with existing envoy category names.]
  public var category: String = String()

  /// [#not-implemented-hide:] Type descriptor of extension configuration proto.
  /// [#comment:TODO(yanavlasov): Link to the doc with existing configuration protos.]
  /// [#comment:TODO(yanavlasov): Add tests when PR #9391 lands.]
  public var typeDescriptor: String = String()

  /// The version is a property of the extension and maintained independently
  /// of other extensions and the Envoy API.
  /// This field is not set when extension did not provide version information.
  public var version: Envoy_Config_Core_V3_BuildVersion {
    get {return _version ?? Envoy_Config_Core_V3_BuildVersion()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  /// Indicates that the extension is present but was disabled via dynamic configuration.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Envoy_Config_Core_V3_BuildVersion? = nil
}

/// Identifies a specific Envoy instance. The node identifier is presented to the
/// management server, which may use this identifier to distinguish per Envoy
/// configuration for serving.
/// [#next-free-field: 12]
public struct Envoy_Config_Core_V3_Node {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An opaque node identifier for the Envoy node. This also provides the local
  /// service node name. It should be set if any of the following features are
  /// used: :ref:`statsd <arch_overview_statistics>`, :ref:`CDS
  /// <config_cluster_manager_cds>`, and :ref:`HTTP tracing
  /// <arch_overview_tracing>`, either in this message or via
  /// :option:`--service-node`.
  public var id: String = String()

  /// Defines the local service cluster name where Envoy is running. Though
  /// optional, it should be set if any of the following features are used:
  /// :ref:`statsd <arch_overview_statistics>`, :ref:`health check cluster
  /// verification
  /// <envoy_api_field_config.core.v3.HealthCheck.HttpHealthCheck.service_name_matcher>`,
  /// :ref:`runtime override directory <envoy_api_msg_config.bootstrap.v3.Runtime>`,
  /// :ref:`user agent addition
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.add_user_agent>`,
  /// :ref:`HTTP global rate limiting <config_http_filters_rate_limit>`,
  /// :ref:`CDS <config_cluster_manager_cds>`, and :ref:`HTTP tracing
  /// <arch_overview_tracing>`, either in this message or via
  /// :option:`--service-cluster`.
  public var cluster: String = String()

  /// Opaque metadata extending the node identifier. Envoy will pass this
  /// directly to the management server.
  public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Locality specifying where the Envoy instance is running.
  public var locality: Envoy_Config_Core_V3_Locality {
    get {return _locality ?? Envoy_Config_Core_V3_Locality()}
    set {_locality = newValue}
  }
  /// Returns true if `locality` has been explicitly set.
  public var hasLocality: Bool {return self._locality != nil}
  /// Clears the value of `locality`. Subsequent reads from it will return its default value.
  public mutating func clearLocality() {self._locality = nil}

  /// Free-form string that identifies the entity requesting config.
  /// E.g. "envoy" or "grpc"
  public var userAgentName: String = String()

  public var userAgentVersionType: Envoy_Config_Core_V3_Node.OneOf_UserAgentVersionType? = nil

  /// Free-form string that identifies the version of the entity requesting config.
  /// E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
  public var userAgentVersion: String {
    get {
      if case .userAgentVersion(let v)? = userAgentVersionType {return v}
      return String()
    }
    set {userAgentVersionType = .userAgentVersion(newValue)}
  }

  /// Structured version of the entity requesting config.
  public var userAgentBuildVersion: Envoy_Config_Core_V3_BuildVersion {
    get {
      if case .userAgentBuildVersion(let v)? = userAgentVersionType {return v}
      return Envoy_Config_Core_V3_BuildVersion()
    }
    set {userAgentVersionType = .userAgentBuildVersion(newValue)}
  }

  /// List of extensions and their versions supported by the node.
  public var extensions: [Envoy_Config_Core_V3_Extension] = []

  /// Client feature support list. These are well known features described
  /// in the Envoy API repository for a given major version of an API. Client features
  /// use reverse DNS naming scheme, for example `com.acme.feature`.
  /// See :ref:`the list of features <client_features>` that xDS client may
  /// support.
  public var clientFeatures: [String] = []

  /// Known listening ports on the node as a generic hint to the management server
  /// for filtering :ref:`listeners <config_listeners>` to be returned. For example,
  /// if there is a listener bound to port 80, the list can optionally contain the
  /// SocketAddress `(0.0.0.0,80)`. The field is optional and just a hint.
  public var listeningAddresses: [Envoy_Config_Core_V3_Address] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_UserAgentVersionType: Equatable {
    /// Free-form string that identifies the version of the entity requesting config.
    /// E.g. "1.12.2" or "abcd1234", or "SpecialEnvoyBuild"
    case userAgentVersion(String)
    /// Structured version of the entity requesting config.
    case userAgentBuildVersion(Envoy_Config_Core_V3_BuildVersion)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Core_V3_Node.OneOf_UserAgentVersionType, rhs: Envoy_Config_Core_V3_Node.OneOf_UserAgentVersionType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userAgentVersion, .userAgentVersion): return {
        guard case .userAgentVersion(let l) = lhs, case .userAgentVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userAgentBuildVersion, .userAgentBuildVersion): return {
        guard case .userAgentBuildVersion(let l) = lhs, case .userAgentBuildVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _locality: Envoy_Config_Core_V3_Locality? = nil
}

/// Metadata provides additional inputs to filters based on matched listeners,
/// filter chains, routes and endpoints. It is structured as a map, usually from
/// filter name (in reverse DNS format) to metadata specific to the filter. Metadata
/// key-values for a filter are merged as connection and request handling occurs,
/// with later values for the same key overriding earlier values.
///
/// An example use of metadata is providing additional values to
/// http_connection_manager in the envoy.http_connection_manager.access_log
/// namespace.
///
/// Another example use of metadata is to per service config info in cluster metadata, which may get
/// consumed by multiple filters.
///
/// For load balancing, Metadata provides a means to subset cluster endpoints.
/// Endpoints have a Metadata object associated and routes contain a Metadata
/// object to match against. There are some well defined metadata used today for
/// this purpose:
///
/// * ``{"envoy.lb": {"canary": <bool> }}`` This indicates the canary status of an
///   endpoint and is also used during header processing
///   (x-envoy-upstream-canary) and for stats purposes.
/// [#next-major-version: move to type/metadata/v2]
public struct Envoy_Config_Core_V3_Metadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key is the reverse DNS filter name, e.g. com.acme.widget. The envoy.*
  /// namespace is reserved for Envoy's built-in filters.
  public var filterMetadata: Dictionary<String,SwiftProtobuf.Google_Protobuf_Struct> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Runtime derived uint32 with a default when not specified.
public struct Envoy_Config_Core_V3_RuntimeUInt32 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Default value if runtime value is not available.
  public var defaultValue: UInt32 = 0

  /// Runtime key to get value for comparison. This value is used if defined.
  public var runtimeKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Runtime derived percentage with a default when not specified.
public struct Envoy_Config_Core_V3_RuntimePercent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Default value if runtime value is not available.
  public var defaultValue: Envoy_Type_V3_Percent {
    get {return _defaultValue ?? Envoy_Type_V3_Percent()}
    set {_defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return self._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {self._defaultValue = nil}

  /// Runtime key to get value for comparison. This value is used if defined.
  public var runtimeKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _defaultValue: Envoy_Type_V3_Percent? = nil
}

/// Runtime derived double with a default when not specified.
public struct Envoy_Config_Core_V3_RuntimeDouble {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Default value if runtime value is not available.
  public var defaultValue: Double = 0

  /// Runtime key to get value for comparison. This value is used if defined.
  public var runtimeKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Runtime derived bool with a default when not specified.
public struct Envoy_Config_Core_V3_RuntimeFeatureFlag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Default value if runtime value is not available.
  public var defaultValue: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _defaultValue ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return self._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {self._defaultValue = nil}

  /// Runtime key to get value for comparison. This value is used if defined. The boolean value must
  /// be represented via its
  /// `canonical JSON encoding <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
  public var runtimeKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _defaultValue: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Header name/value pair.
public struct Envoy_Config_Core_V3_HeaderValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header name.
  public var key: String = String()

  /// Header value.
  ///
  /// The same :ref:`format specifier <config_access_log_format>` as used for
  /// :ref:`HTTP access logging <config_access_log>` applies here, however
  /// unknown header values are replaced with the empty string instead of `-`.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Header name/value pair plus option to control append behavior.
public struct Envoy_Config_Core_V3_HeaderValueOption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Header name/value pair that this option applies to.
  public var header: Envoy_Config_Core_V3_HeaderValue {
    get {return _header ?? Envoy_Config_Core_V3_HeaderValue()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Should the value be appended? If true (default), the value is appended to
  /// existing values. Otherwise it replaces any existing values.
  public var append: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _append ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_append = newValue}
  }
  /// Returns true if `append` has been explicitly set.
  public var hasAppend: Bool {return self._append != nil}
  /// Clears the value of `append`. Subsequent reads from it will return its default value.
  public mutating func clearAppend() {self._append = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Envoy_Config_Core_V3_HeaderValue? = nil
  fileprivate var _append: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Wrapper for a set of headers.
public struct Envoy_Config_Core_V3_HeaderMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var headers: [Envoy_Config_Core_V3_HeaderValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Data source consisting of either a file or an inline value.
public struct Envoy_Config_Core_V3_DataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var specifier: Envoy_Config_Core_V3_DataSource.OneOf_Specifier? = nil

  /// Local filesystem data source.
  public var filename: String {
    get {
      if case .filename(let v)? = specifier {return v}
      return String()
    }
    set {specifier = .filename(newValue)}
  }

  /// Bytes inlined in the configuration.
  public var inlineBytes: Data {
    get {
      if case .inlineBytes(let v)? = specifier {return v}
      return Data()
    }
    set {specifier = .inlineBytes(newValue)}
  }

  /// String inlined in the configuration.
  public var inlineString: String {
    get {
      if case .inlineString(let v)? = specifier {return v}
      return String()
    }
    set {specifier = .inlineString(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Specifier: Equatable {
    /// Local filesystem data source.
    case filename(String)
    /// Bytes inlined in the configuration.
    case inlineBytes(Data)
    /// String inlined in the configuration.
    case inlineString(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Core_V3_DataSource.OneOf_Specifier, rhs: Envoy_Config_Core_V3_DataSource.OneOf_Specifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.filename, .filename): return {
        guard case .filename(let l) = lhs, case .filename(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inlineBytes, .inlineBytes): return {
        guard case .inlineBytes(let l) = lhs, case .inlineBytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inlineString, .inlineString): return {
        guard case .inlineString(let l) = lhs, case .inlineString(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The message specifies the retry policy of remote data source when fetching fails.
public struct Envoy_Config_Core_V3_RetryPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies parameters that control :ref:`retry backoff strategy <envoy_api_msg_config.core.v3.BackoffStrategy>`.
  /// This parameter is optional, in which case the default base interval is 1000 milliseconds. The
  /// default maximum interval is 10 times the base interval.
  public var retryBackOff: Envoy_Config_Core_V3_BackoffStrategy {
    get {return _retryBackOff ?? Envoy_Config_Core_V3_BackoffStrategy()}
    set {_retryBackOff = newValue}
  }
  /// Returns true if `retryBackOff` has been explicitly set.
  public var hasRetryBackOff: Bool {return self._retryBackOff != nil}
  /// Clears the value of `retryBackOff`. Subsequent reads from it will return its default value.
  public mutating func clearRetryBackOff() {self._retryBackOff = nil}

  /// Specifies the allowed number of retries. This parameter is optional and
  /// defaults to 1.
  public var numRetries: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _numRetries ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_numRetries = newValue}
  }
  /// Returns true if `numRetries` has been explicitly set.
  public var hasNumRetries: Bool {return self._numRetries != nil}
  /// Clears the value of `numRetries`. Subsequent reads from it will return its default value.
  public mutating func clearNumRetries() {self._numRetries = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _retryBackOff: Envoy_Config_Core_V3_BackoffStrategy? = nil
  fileprivate var _numRetries: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// The message specifies how to fetch data from remote and how to verify it.
public struct Envoy_Config_Core_V3_RemoteDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP URI to fetch the remote data.
  public var httpUri: Envoy_Config_Core_V3_HttpUri {
    get {return _httpUri ?? Envoy_Config_Core_V3_HttpUri()}
    set {_httpUri = newValue}
  }
  /// Returns true if `httpUri` has been explicitly set.
  public var hasHTTPUri: Bool {return self._httpUri != nil}
  /// Clears the value of `httpUri`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPUri() {self._httpUri = nil}

  /// SHA256 string for verifying data.
  public var sha256: String = String()

  /// Retry policy for fetching remote data.
  public var retryPolicy: Envoy_Config_Core_V3_RetryPolicy {
    get {return _retryPolicy ?? Envoy_Config_Core_V3_RetryPolicy()}
    set {_retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  public var hasRetryPolicy: Bool {return self._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicy() {self._retryPolicy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _httpUri: Envoy_Config_Core_V3_HttpUri? = nil
  fileprivate var _retryPolicy: Envoy_Config_Core_V3_RetryPolicy? = nil
}

/// Async data source which support async data fetch.
public struct Envoy_Config_Core_V3_AsyncDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var specifier: Envoy_Config_Core_V3_AsyncDataSource.OneOf_Specifier? = nil

  /// Local async data source.
  public var local: Envoy_Config_Core_V3_DataSource {
    get {
      if case .local(let v)? = specifier {return v}
      return Envoy_Config_Core_V3_DataSource()
    }
    set {specifier = .local(newValue)}
  }

  /// Remote async data source.
  public var remote: Envoy_Config_Core_V3_RemoteDataSource {
    get {
      if case .remote(let v)? = specifier {return v}
      return Envoy_Config_Core_V3_RemoteDataSource()
    }
    set {specifier = .remote(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Specifier: Equatable {
    /// Local async data source.
    case local(Envoy_Config_Core_V3_DataSource)
    /// Remote async data source.
    case remote(Envoy_Config_Core_V3_RemoteDataSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Core_V3_AsyncDataSource.OneOf_Specifier, rhs: Envoy_Config_Core_V3_AsyncDataSource.OneOf_Specifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.local, .local): return {
        guard case .local(let l) = lhs, case .local(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remote, .remote): return {
        guard case .remote(let l) = lhs, case .remote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Configuration for transport socket in :ref:`listeners <config_listeners>` and
/// :ref:`clusters <envoy_api_msg_config.cluster.v3.Cluster>`. If the configuration is
/// empty, a default transport socket implementation and configuration will be
/// chosen based on the platform and existence of tls_context.
public struct Envoy_Config_Core_V3_TransportSocket {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the transport socket to instantiate. The name must match a supported transport
  /// socket implementation.
  public var name: String = String()

  /// Implementation specific configuration which depends on the implementation being instantiated.
  /// See the supported transport socket implementations for further documentation.
  public var configType: Envoy_Config_Core_V3_TransportSocket.OneOf_ConfigType? = nil

  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .typedConfig(let v)? = configType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {configType = .typedConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Implementation specific configuration which depends on the implementation being instantiated.
  /// See the supported transport socket implementations for further documentation.
  public enum OneOf_ConfigType: Equatable {
    case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Core_V3_TransportSocket.OneOf_ConfigType, rhs: Envoy_Config_Core_V3_TransportSocket.OneOf_ConfigType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.typedConfig, .typedConfig): return {
        guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Runtime derived FractionalPercent with defaults for when the numerator or denominator is not
/// specified via a runtime key.
///
/// .. note::
///
///   Parsing of the runtime key's data is implemented such that it may be represented as a
///   :ref:`FractionalPercent <envoy_api_msg_type.v3.FractionalPercent>` proto represented as JSON/YAML
///   and may also be represented as an integer with the assumption that the value is an integral
///   percentage out of 100. For instance, a runtime key lookup returning the value "42" would parse
///   as a `FractionalPercent` whose numerator is 42 and denominator is HUNDRED.
public struct Envoy_Config_Core_V3_RuntimeFractionalPercent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Default value if the runtime value's for the numerator/denominator keys are not available.
  public var defaultValue: Envoy_Type_V3_FractionalPercent {
    get {return _defaultValue ?? Envoy_Type_V3_FractionalPercent()}
    set {_defaultValue = newValue}
  }
  /// Returns true if `defaultValue` has been explicitly set.
  public var hasDefaultValue: Bool {return self._defaultValue != nil}
  /// Clears the value of `defaultValue`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultValue() {self._defaultValue = nil}

  /// Runtime key for a YAML representation of a FractionalPercent.
  public var runtimeKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _defaultValue: Envoy_Type_V3_FractionalPercent? = nil
}

/// Identifies a specific ControlPlane instance that Envoy is connected to.
public struct Envoy_Config_Core_V3_ControlPlane {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An opaque control plane identifier that uniquely identifies an instance
  /// of control plane. This can be used to identify which control plane instance,
  /// the Envoy is connected to.
  public var identifier: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.core.v3"

extension Envoy_Config_Core_V3_RoutingPriority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "HIGH"),
  ]
}

extension Envoy_Config_Core_V3_RequestMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METHOD_UNSPECIFIED"),
    1: .same(proto: "GET"),
    2: .same(proto: "HEAD"),
    3: .same(proto: "POST"),
    4: .same(proto: "PUT"),
    5: .same(proto: "DELETE"),
    6: .same(proto: "CONNECT"),
    7: .same(proto: "OPTIONS"),
    8: .same(proto: "TRACE"),
    9: .same(proto: "PATCH"),
  ]
}

extension Envoy_Config_Core_V3_TrafficDirection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "INBOUND"),
    2: .same(proto: "OUTBOUND"),
  ]
}

extension Envoy_Config_Core_V3_Locality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Locality"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "zone"),
    3: .standard(proto: "sub_zone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subZone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.subZone.isEmpty {
      try visitor.visitSingularStringField(value: self.subZone, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Locality, rhs: Envoy_Config_Core_V3_Locality) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.subZone != rhs.subZone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_BuildVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_BuildVersion, rhs: Envoy_Config_Core_V3_BuildVersion) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Extension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Extension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "category"),
    3: .standard(proto: "type_descriptor"),
    4: .same(proto: "version"),
    5: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.typeDescriptor) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 2)
    }
    if !self.typeDescriptor.isEmpty {
      try visitor.visitSingularStringField(value: self.typeDescriptor, fieldNumber: 3)
    }
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Extension, rhs: Envoy_Config_Core_V3_Extension) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.category != rhs.category {return false}
    if lhs.typeDescriptor != rhs.typeDescriptor {return false}
    if lhs._version != rhs._version {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "cluster"),
    3: .same(proto: "metadata"),
    4: .same(proto: "locality"),
    6: .standard(proto: "user_agent_name"),
    7: .standard(proto: "user_agent_version"),
    8: .standard(proto: "user_agent_build_version"),
    9: .same(proto: "extensions"),
    10: .standard(proto: "client_features"),
    11: .standard(proto: "listening_addresses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._locality) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userAgentName) }()
      case 7: try {
        if self.userAgentVersionType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.userAgentVersionType = .userAgentVersion(v)}
      }()
      case 8: try {
        var v: Envoy_Config_Core_V3_BuildVersion?
        if let current = self.userAgentVersionType {
          try decoder.handleConflictingOneOf()
          if case .userAgentBuildVersion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.userAgentVersionType = .userAgentBuildVersion(v)}
      }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.extensions) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.clientFeatures) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.listeningAddresses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 2)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._locality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.userAgentName.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgentName, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.userAgentVersionType {
    case .userAgentVersion?: try {
      guard case .userAgentVersion(let v)? = self.userAgentVersionType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    case .userAgentBuildVersion?: try {
      guard case .userAgentBuildVersion(let v)? = self.userAgentVersionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    if !self.extensions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extensions, fieldNumber: 9)
    }
    if !self.clientFeatures.isEmpty {
      try visitor.visitRepeatedStringField(value: self.clientFeatures, fieldNumber: 10)
    }
    if !self.listeningAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listeningAddresses, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Node, rhs: Envoy_Config_Core_V3_Node) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.cluster != rhs.cluster {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._locality != rhs._locality {return false}
    if lhs.userAgentName != rhs.userAgentName {return false}
    if lhs.userAgentVersionType != rhs.userAgentVersionType {return false}
    if lhs.extensions != rhs.extensions {return false}
    if lhs.clientFeatures != rhs.clientFeatures {return false}
    if lhs.listeningAddresses != rhs.listeningAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "filter_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Struct>.self, value: &self.filterMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filterMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Struct>.self, value: self.filterMetadata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_Metadata, rhs: Envoy_Config_Core_V3_Metadata) -> Bool {
    if lhs.filterMetadata != rhs.filterMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RuntimeUInt32: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeUInt32"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "default_value"),
    3: .standard(proto: "runtime_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.defaultValue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runtimeKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.defaultValue != 0 {
      try visitor.visitSingularUInt32Field(value: self.defaultValue, fieldNumber: 2)
    }
    if !self.runtimeKey.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RuntimeUInt32, rhs: Envoy_Config_Core_V3_RuntimeUInt32) -> Bool {
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.runtimeKey != rhs.runtimeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RuntimePercent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimePercent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_value"),
    2: .standard(proto: "runtime_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._defaultValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.runtimeKey.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RuntimePercent, rhs: Envoy_Config_Core_V3_RuntimePercent) -> Bool {
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.runtimeKey != rhs.runtimeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RuntimeDouble: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeDouble"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_value"),
    2: .standard(proto: "runtime_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.defaultValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.defaultValue != 0 {
      try visitor.visitSingularDoubleField(value: self.defaultValue, fieldNumber: 1)
    }
    if !self.runtimeKey.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RuntimeDouble, rhs: Envoy_Config_Core_V3_RuntimeDouble) -> Bool {
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.runtimeKey != rhs.runtimeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RuntimeFeatureFlag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeFeatureFlag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_value"),
    2: .standard(proto: "runtime_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._defaultValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.runtimeKey.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RuntimeFeatureFlag, rhs: Envoy_Config_Core_V3_RuntimeFeatureFlag) -> Bool {
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.runtimeKey != rhs.runtimeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_HeaderValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeaderValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_HeaderValue, rhs: Envoy_Config_Core_V3_HeaderValue) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_HeaderValueOption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeaderValueOption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "append"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._append) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._append {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_HeaderValueOption, rhs: Envoy_Config_Core_V3_HeaderValueOption) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs._append != rhs._append {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_HeaderMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeaderMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_HeaderMap, rhs: Envoy_Config_Core_V3_HeaderMap) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_DataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filename"),
    2: .standard(proto: "inline_bytes"),
    3: .standard(proto: "inline_string"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.specifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.specifier = .filename(v)}
      }()
      case 2: try {
        if self.specifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.specifier = .inlineBytes(v)}
      }()
      case 3: try {
        if self.specifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.specifier = .inlineString(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.specifier {
    case .filename?: try {
      guard case .filename(let v)? = self.specifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .inlineBytes?: try {
      guard case .inlineBytes(let v)? = self.specifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .inlineString?: try {
      guard case .inlineString(let v)? = self.specifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_DataSource, rhs: Envoy_Config_Core_V3_DataSource) -> Bool {
    if lhs.specifier != rhs.specifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_back_off"),
    2: .standard(proto: "num_retries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._retryBackOff) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._numRetries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._retryBackOff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._numRetries {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RetryPolicy, rhs: Envoy_Config_Core_V3_RetryPolicy) -> Bool {
    if lhs._retryBackOff != rhs._retryBackOff {return false}
    if lhs._numRetries != rhs._numRetries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RemoteDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteDataSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http_uri"),
    2: .same(proto: "sha256"),
    3: .standard(proto: "retry_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._httpUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sha256) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._retryPolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._httpUri {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.sha256.isEmpty {
      try visitor.visitSingularStringField(value: self.sha256, fieldNumber: 2)
    }
    if let v = self._retryPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RemoteDataSource, rhs: Envoy_Config_Core_V3_RemoteDataSource) -> Bool {
    if lhs._httpUri != rhs._httpUri {return false}
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs._retryPolicy != rhs._retryPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_AsyncDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsyncDataSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "remote"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Config_Core_V3_DataSource?
        if let current = self.specifier {
          try decoder.handleConflictingOneOf()
          if case .local(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.specifier = .local(v)}
      }()
      case 2: try {
        var v: Envoy_Config_Core_V3_RemoteDataSource?
        if let current = self.specifier {
          try decoder.handleConflictingOneOf()
          if case .remote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.specifier = .remote(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.specifier {
    case .local?: try {
      guard case .local(let v)? = self.specifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .remote?: try {
      guard case .remote(let v)? = self.specifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_AsyncDataSource, rhs: Envoy_Config_Core_V3_AsyncDataSource) -> Bool {
    if lhs.specifier != rhs.specifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_TransportSocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransportSocket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_TransportSocket, rhs: Envoy_Config_Core_V3_TransportSocket) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_RuntimeFractionalPercent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeFractionalPercent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_value"),
    2: .standard(proto: "runtime_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._defaultValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.runtimeKey.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_RuntimeFractionalPercent, rhs: Envoy_Config_Core_V3_RuntimeFractionalPercent) -> Bool {
    if lhs._defaultValue != rhs._defaultValue {return false}
    if lhs.runtimeKey != rhs.runtimeKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V3_ControlPlane: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ControlPlane"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V3_ControlPlane, rhs: Envoy_Config_Core_V3_ControlPlane) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

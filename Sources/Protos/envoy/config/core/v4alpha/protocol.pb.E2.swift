// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/core/v4alpha/protocol.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#not-implemented-hide:]
public struct Envoy_Config_Core_V4alpha_TcpProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Envoy_Config_Core_V4alpha_UpstreamHttpProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set transport socket `SNI <https://en.wikipedia.org/wiki/Server_Name_Indication>`_ for new
  /// upstream connections based on the downstream HTTP host/authority header, as seen by the
  /// :ref:`router filter <config_http_filters_router>`.
  public var autoSni: Bool = false

  /// Automatic validate upstream presented certificate for new upstream connections based on the
  /// downstream HTTP host/authority header, as seen by the
  /// :ref:`router filter <config_http_filters_router>`.
  /// This field is intended to set with `auto_sni` field.
  public var autoSanValidation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [#next-free-field: 6]
public struct Envoy_Config_Core_V4alpha_HttpProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The idle timeout for connections. The idle timeout is defined as the
  /// period in which there are no active requests. When the
  /// idle timeout is reached the connection will be closed. If the connection is an HTTP/2
  /// downstream connection a drain sequence will occur prior to closing the connection, see
  /// :ref:`drain_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.drain_timeout>`.
  /// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
  /// If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
  ///
  /// .. warning::
  ///   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  ///   FIN packets, etc.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return self._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {self._idleTimeout = nil}

  /// The maximum duration of a connection. The duration is defined as a period since a connection
  /// was established. If not set, there is no max duration. When max_connection_duration is reached
  /// the connection will be closed. Drain sequence will occur prior to closing the connection if
  /// if's applicable. See :ref:`drain_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.drain_timeout>`.
  /// Note: not implemented for upstream connections.
  public var maxConnectionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxConnectionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxConnectionDuration = newValue}
  }
  /// Returns true if `maxConnectionDuration` has been explicitly set.
  public var hasMaxConnectionDuration: Bool {return self._maxConnectionDuration != nil}
  /// Clears the value of `maxConnectionDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConnectionDuration() {self._maxConnectionDuration = nil}

  /// The maximum number of headers. If unconfigured, the default
  /// maximum number of request headers allowed is 100. Requests that exceed this limit will receive
  /// a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
  public var maxHeadersCount: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxHeadersCount ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxHeadersCount = newValue}
  }
  /// Returns true if `maxHeadersCount` has been explicitly set.
  public var hasMaxHeadersCount: Bool {return self._maxHeadersCount != nil}
  /// Clears the value of `maxHeadersCount`. Subsequent reads from it will return its default value.
  public mutating func clearMaxHeadersCount() {self._maxHeadersCount = nil}

  /// Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
  /// reset independent of any other timeouts. If not specified, this value is not set.
  public var maxStreamDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxStreamDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxStreamDuration = newValue}
  }
  /// Returns true if `maxStreamDuration` has been explicitly set.
  public var hasMaxStreamDuration: Bool {return self._maxStreamDuration != nil}
  /// Clears the value of `maxStreamDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxStreamDuration() {self._maxStreamDuration = nil}

  /// Action to take when a client request with a header name containing underscore characters is received.
  /// If this setting is not specified, the value defaults to ALLOW.
  /// Note: upstream responses are not affected by this setting.
  public var headersWithUnderscoresAction: Envoy_Config_Core_V4alpha_HttpProtocolOptions.HeadersWithUnderscoresAction = .allow

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Action to take when Envoy receives client request with header names containing underscore
  /// characters.
  /// Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
  /// as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
  /// characters.
  public enum HeadersWithUnderscoresAction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Allow headers with underscores. This is the default behavior.
    case allow // = 0

    /// Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
    /// end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
    /// is incremented for each rejected request.
    case rejectRequest // = 1

    /// Drop the header with name containing underscores. The header is dropped before the filter chain is
    /// invoked and as such filters will not see dropped headers. The
    /// "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
    case dropHeader // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .allow
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allow
      case 1: self = .rejectRequest
      case 2: self = .dropHeader
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allow: return 0
      case .rejectRequest: return 1
      case .dropHeader: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxConnectionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxHeadersCount: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxStreamDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Envoy_Config_Core_V4alpha_HttpProtocolOptions.HeadersWithUnderscoresAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Core_V4alpha_HttpProtocolOptions.HeadersWithUnderscoresAction] = [
    .allow,
    .rejectRequest,
    .dropHeader,
  ]
}

#endif  // swift(>=4.2)

/// [#next-free-field: 6]
public struct Envoy_Config_Core_V4alpha_Http1ProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Handle HTTP requests with absolute URLs in the requests. These requests
  /// are generally sent by clients to forward/explicit proxies. This allows clients to configure
  /// envoy as their HTTP proxy. In Unix, for example, this is typically done by setting the
  /// *http_proxy* environment variable.
  public var allowAbsoluteURL: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _allowAbsoluteURL ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_allowAbsoluteURL = newValue}
  }
  /// Returns true if `allowAbsoluteURL` has been explicitly set.
  public var hasAllowAbsoluteURL: Bool {return self._allowAbsoluteURL != nil}
  /// Clears the value of `allowAbsoluteURL`. Subsequent reads from it will return its default value.
  public mutating func clearAllowAbsoluteURL() {self._allowAbsoluteURL = nil}

  /// Handle incoming HTTP/1.0 and HTTP 0.9 requests.
  /// This is off by default, and not fully standards compliant. There is support for pre-HTTP/1.1
  /// style connect logic, dechunking, and handling lack of client host iff
  /// *default_host_for_http_10* is configured.
  public var acceptHTTP10: Bool = false

  /// A default host for HTTP/1.0 requests. This is highly suggested if *accept_http_10* is true as
  /// Envoy does not otherwise support HTTP/1.0 without a Host header.
  /// This is a no-op if *accept_http_10* is not true.
  public var defaultHostForHTTP10: String = String()

  /// Describes how the keys for response headers should be formatted. By default, all header keys
  /// are lower cased.
  public var headerKeyFormat: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat {
    get {return _headerKeyFormat ?? Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat()}
    set {_headerKeyFormat = newValue}
  }
  /// Returns true if `headerKeyFormat` has been explicitly set.
  public var hasHeaderKeyFormat: Bool {return self._headerKeyFormat != nil}
  /// Clears the value of `headerKeyFormat`. Subsequent reads from it will return its default value.
  public mutating func clearHeaderKeyFormat() {self._headerKeyFormat = nil}

  /// Enables trailers for HTTP/1. By default the HTTP/1 codec drops proxied trailers.
  ///
  /// .. attention::
  ///
  ///   Note that this only happens when Envoy is chunk encoding which occurs when:
  ///   - The request is HTTP/1.1.
  ///   - Is neither a HEAD only request nor a HTTP Upgrade.
  ///   - Not a response to a HEAD request.
  ///   - The content length header is not present.
  public var enableTrailers: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct HeaderKeyFormat {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var headerFormat: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.OneOf_HeaderFormat? = nil

    /// Formats the header by proper casing words: the first character and any character following
    /// a special character will be capitalized if it's an alpha character. For example,
    /// "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
    /// Note that while this results in most headers following conventional casing, certain headers
    /// are not covered. For example, the "TE" header will be formatted as "Te".
    public var properCaseWords: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords {
      get {
        if case .properCaseWords(let v)? = headerFormat {return v}
        return Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords()
      }
      set {headerFormat = .properCaseWords(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_HeaderFormat: Equatable {
      /// Formats the header by proper casing words: the first character and any character following
      /// a special character will be capitalized if it's an alpha character. For example,
      /// "content-type" becomes "Content-Type", and "foo$b#$are" becomes "Foo$B#$Are".
      /// Note that while this results in most headers following conventional casing, certain headers
      /// are not covered. For example, the "TE" header will be formatted as "Te".
      case properCaseWords(Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.OneOf_HeaderFormat, rhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.OneOf_HeaderFormat) -> Bool {
        switch (lhs, rhs) {
        case (.properCaseWords(let l), .properCaseWords(let r)): return l == r
        }
      }
    #endif
    }

    public struct ProperCaseWords {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _allowAbsoluteURL: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _headerKeyFormat: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat? = nil
}

/// [#next-free-field: 14]
public struct Envoy_Config_Core_V4alpha_Http2ProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `Maximum table size <https://httpwg.org/specs/rfc7541.html#rfc.section.4.2>`_
  /// (in octets) that the encoder is permitted to use for the dynamic HPACK table. Valid values
  /// range from 0 to 4294967295 (2^32 - 1) and defaults to 4096. 0 effectively disables header
  /// compression.
  public var hpackTableSize: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _hpackTableSize ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_hpackTableSize = newValue}
  }
  /// Returns true if `hpackTableSize` has been explicitly set.
  public var hasHpackTableSize: Bool {return self._hpackTableSize != nil}
  /// Clears the value of `hpackTableSize`. Subsequent reads from it will return its default value.
  public mutating func clearHpackTableSize() {self._hpackTableSize = nil}

  /// `Maximum concurrent streams <https://httpwg.org/specs/rfc7540.html#rfc.section.5.1.2>`_
  /// allowed for peer on one HTTP/2 connection. Valid values range from 1 to 2147483647 (2^31 - 1)
  /// and defaults to 2147483647.
  ///
  /// For upstream connections, this also limits how many streams Envoy will initiate concurrently
  /// on a single connection. If the limit is reached, Envoy may queue requests or establish
  /// additional connections (as allowed per circuit breaker limits).
  public var maxConcurrentStreams: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxConcurrentStreams ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxConcurrentStreams = newValue}
  }
  /// Returns true if `maxConcurrentStreams` has been explicitly set.
  public var hasMaxConcurrentStreams: Bool {return self._maxConcurrentStreams != nil}
  /// Clears the value of `maxConcurrentStreams`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConcurrentStreams() {self._maxConcurrentStreams = nil}

  /// `Initial stream-level flow-control window
  /// <https://httpwg.org/specs/rfc7540.html#rfc.section.6.9.2>`_ size. Valid values range from 65535
  /// (2^16 - 1, HTTP/2 default) to 2147483647 (2^31 - 1, HTTP/2 maximum) and defaults to 268435456
  /// (256 * 1024 * 1024).
  ///
  /// NOTE: 65535 is the initial window size from HTTP/2 spec. We only support increasing the default
  /// window size now, so it's also the minimum.
  ///
  /// This field also acts as a soft limit on the number of bytes Envoy will buffer per-stream in the
  /// HTTP/2 codec buffers. Once the buffer reaches this pointer, watermark callbacks will fire to
  /// stop the flow of data to the codec buffers.
  public var initialStreamWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _initialStreamWindowSize ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_initialStreamWindowSize = newValue}
  }
  /// Returns true if `initialStreamWindowSize` has been explicitly set.
  public var hasInitialStreamWindowSize: Bool {return self._initialStreamWindowSize != nil}
  /// Clears the value of `initialStreamWindowSize`. Subsequent reads from it will return its default value.
  public mutating func clearInitialStreamWindowSize() {self._initialStreamWindowSize = nil}

  /// Similar to *initial_stream_window_size*, but for connection-level flow-control
  /// window. Currently, this has the same minimum/maximum/default as *initial_stream_window_size*.
  public var initialConnectionWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _initialConnectionWindowSize ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_initialConnectionWindowSize = newValue}
  }
  /// Returns true if `initialConnectionWindowSize` has been explicitly set.
  public var hasInitialConnectionWindowSize: Bool {return self._initialConnectionWindowSize != nil}
  /// Clears the value of `initialConnectionWindowSize`. Subsequent reads from it will return its default value.
  public mutating func clearInitialConnectionWindowSize() {self._initialConnectionWindowSize = nil}

  /// Allows proxying Websocket and other upgrades over H2 connect.
  public var allowConnect: Bool = false

  /// [#not-implemented-hide:] Hiding until envoy has full metadata support.
  /// Still under implementation. DO NOT USE.
  ///
  /// Allows metadata. See [metadata
  /// docs](https://github.com/envoyproxy/envoy/blob/master/source/docs/h2_metadata.md) for more
  /// information.
  public var allowMetadata: Bool = false

  /// Limit the number of pending outbound downstream frames of all types (frames that are waiting to
  /// be written into the socket). Exceeding this limit triggers flood mitigation and connection is
  /// terminated. The ``http2.outbound_flood`` stat tracks the number of terminated connections due
  /// to flood mitigation. The default limit is 10000.
  /// [#comment:TODO: implement same limits for upstream outbound frames as well.]
  public var maxOutboundFrames: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxOutboundFrames ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxOutboundFrames = newValue}
  }
  /// Returns true if `maxOutboundFrames` has been explicitly set.
  public var hasMaxOutboundFrames: Bool {return self._maxOutboundFrames != nil}
  /// Clears the value of `maxOutboundFrames`. Subsequent reads from it will return its default value.
  public mutating func clearMaxOutboundFrames() {self._maxOutboundFrames = nil}

  /// Limit the number of pending outbound downstream frames of types PING, SETTINGS and RST_STREAM,
  /// preventing high memory utilization when receiving continuous stream of these frames. Exceeding
  /// this limit triggers flood mitigation and connection is terminated. The
  /// ``http2.outbound_control_flood`` stat tracks the number of terminated connections due to flood
  /// mitigation. The default limit is 1000.
  /// [#comment:TODO: implement same limits for upstream outbound frames as well.]
  public var maxOutboundControlFrames: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxOutboundControlFrames ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxOutboundControlFrames = newValue}
  }
  /// Returns true if `maxOutboundControlFrames` has been explicitly set.
  public var hasMaxOutboundControlFrames: Bool {return self._maxOutboundControlFrames != nil}
  /// Clears the value of `maxOutboundControlFrames`. Subsequent reads from it will return its default value.
  public mutating func clearMaxOutboundControlFrames() {self._maxOutboundControlFrames = nil}

  /// Limit the number of consecutive inbound frames of types HEADERS, CONTINUATION and DATA with an
  /// empty payload and no end stream flag. Those frames have no legitimate use and are abusive, but
  /// might be a result of a broken HTTP/2 implementation. The `http2.inbound_empty_frames_flood``
  /// stat tracks the number of connections terminated due to flood mitigation.
  /// Setting this to 0 will terminate connection upon receiving first frame with an empty payload
  /// and no end stream flag. The default limit is 1.
  /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
  public var maxConsecutiveInboundFramesWithEmptyPayload: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxConsecutiveInboundFramesWithEmptyPayload ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxConsecutiveInboundFramesWithEmptyPayload = newValue}
  }
  /// Returns true if `maxConsecutiveInboundFramesWithEmptyPayload` has been explicitly set.
  public var hasMaxConsecutiveInboundFramesWithEmptyPayload: Bool {return self._maxConsecutiveInboundFramesWithEmptyPayload != nil}
  /// Clears the value of `maxConsecutiveInboundFramesWithEmptyPayload`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConsecutiveInboundFramesWithEmptyPayload() {self._maxConsecutiveInboundFramesWithEmptyPayload = nil}

  /// Limit the number of inbound PRIORITY frames allowed per each opened stream. If the number
  /// of PRIORITY frames received over the lifetime of connection exceeds the value calculated
  /// using this formula::
  ///
  ///     max_inbound_priority_frames_per_stream * (1 + inbound_streams)
  ///
  /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
  /// the number of connections terminated due to flood mitigation. The default limit is 100.
  /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
  public var maxInboundPriorityFramesPerStream: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxInboundPriorityFramesPerStream ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxInboundPriorityFramesPerStream = newValue}
  }
  /// Returns true if `maxInboundPriorityFramesPerStream` has been explicitly set.
  public var hasMaxInboundPriorityFramesPerStream: Bool {return self._maxInboundPriorityFramesPerStream != nil}
  /// Clears the value of `maxInboundPriorityFramesPerStream`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInboundPriorityFramesPerStream() {self._maxInboundPriorityFramesPerStream = nil}

  /// Limit the number of inbound WINDOW_UPDATE frames allowed per DATA frame sent. If the number
  /// of WINDOW_UPDATE frames received over the lifetime of connection exceeds the value calculated
  /// using this formula::
  ///
  ///     1 + 2 * (inbound_streams +
  ///              max_inbound_window_update_frames_per_data_frame_sent * outbound_data_frames)
  ///
  /// the connection is terminated. The ``http2.inbound_priority_frames_flood`` stat tracks
  /// the number of connections terminated due to flood mitigation. The default limit is 10.
  /// Setting this to 1 should be enough to support HTTP/2 implementations with basic flow control,
  /// but more complex implementations that try to estimate available bandwidth require at least 2.
  /// [#comment:TODO: implement same limits for upstream inbound frames as well.]
  public var maxInboundWindowUpdateFramesPerDataFrameSent: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxInboundWindowUpdateFramesPerDataFrameSent ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxInboundWindowUpdateFramesPerDataFrameSent = newValue}
  }
  /// Returns true if `maxInboundWindowUpdateFramesPerDataFrameSent` has been explicitly set.
  public var hasMaxInboundWindowUpdateFramesPerDataFrameSent: Bool {return self._maxInboundWindowUpdateFramesPerDataFrameSent != nil}
  /// Clears the value of `maxInboundWindowUpdateFramesPerDataFrameSent`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInboundWindowUpdateFramesPerDataFrameSent() {self._maxInboundWindowUpdateFramesPerDataFrameSent = nil}

  /// Allows invalid HTTP messaging and headers. When this option is disabled (default), then
  /// the whole HTTP/2 connection is terminated upon receiving invalid HEADERS frame. However,
  /// when this option is enabled, only the offending stream is terminated.
  ///
  /// See `RFC7540, sec. 8.1 <https://tools.ietf.org/html/rfc7540#section-8.1>`_ for details.
  public var streamErrorOnInvalidHTTPMessaging: Bool = false

  /// [#not-implemented-hide:]
  /// Specifies SETTINGS frame parameters to be sent to the peer, with two exceptions:
  ///
  /// 1. SETTINGS_ENABLE_PUSH (0x2) is not configurable as HTTP/2 server push is not supported by
  /// Envoy.
  ///
  /// 2. SETTINGS_ENABLE_CONNECT_PROTOCOL (0x8) is only configurable through the named field
  /// 'allow_connect'.
  ///
  /// Note that custom parameters specified through this field can not also be set in the
  /// corresponding named parameters:
  ///
  /// .. code-block:: text
  ///
  ///   ID    Field Name
  ///   ----------------
  ///   0x1   hpack_table_size
  ///   0x3   max_concurrent_streams
  ///   0x4   initial_stream_window_size
  ///
  /// Collisions will trigger config validation failure on load/update. Likewise, inconsistencies
  /// between custom parameters with the same identifier will trigger a failure.
  ///
  /// See `IANA HTTP/2 Settings
  /// <https://www.iana.org/assignments/http2-parameters/http2-parameters.xhtml#settings>`_ for
  /// standardized identifiers.
  public var customSettingsParameters: [Envoy_Config_Core_V4alpha_Http2ProtocolOptions.SettingsParameter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines a parameter to be sent in the SETTINGS frame.
  /// See `RFC7540, sec. 6.5.1 <https://tools.ietf.org/html/rfc7540#section-6.5.1>`_ for details.
  public struct SettingsParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The 16 bit parameter identifier.
    public var identifier: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _identifier ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_identifier = newValue}
    }
    /// Returns true if `identifier` has been explicitly set.
    public var hasIdentifier: Bool {return self._identifier != nil}
    /// Clears the value of `identifier`. Subsequent reads from it will return its default value.
    public mutating func clearIdentifier() {self._identifier = nil}

    /// The 32 bit parameter value.
    public var value: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _value ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_value = newValue}
    }
    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool {return self._value != nil}
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() {self._value = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _identifier: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _value: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  }

  public init() {}

  fileprivate var _hpackTableSize: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxConcurrentStreams: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _initialStreamWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _initialConnectionWindowSize: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxOutboundFrames: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxOutboundControlFrames: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxConsecutiveInboundFramesWithEmptyPayload: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxInboundPriorityFramesPerStream: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxInboundWindowUpdateFramesPerDataFrameSent: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#not-implemented-hide:]
public struct Envoy_Config_Core_V4alpha_GrpcProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var http2ProtocolOptions: Envoy_Config_Core_V4alpha_Http2ProtocolOptions {
    get {return _http2ProtocolOptions ?? Envoy_Config_Core_V4alpha_Http2ProtocolOptions()}
    set {_http2ProtocolOptions = newValue}
  }
  /// Returns true if `http2ProtocolOptions` has been explicitly set.
  public var hasHTTP2ProtocolOptions: Bool {return self._http2ProtocolOptions != nil}
  /// Clears the value of `http2ProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearHTTP2ProtocolOptions() {self._http2ProtocolOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _http2ProtocolOptions: Envoy_Config_Core_V4alpha_Http2ProtocolOptions? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.core.v4alpha"

extension Envoy_Config_Core_V4alpha_TcpProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TcpProtocolOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_TcpProtocolOptions, rhs: Envoy_Config_Core_V4alpha_TcpProtocolOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_UpstreamHttpProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamHttpProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_sni"),
    2: .standard(proto: "auto_san_validation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.autoSni)
      case 2: try decoder.decodeSingularBoolField(value: &self.autoSanValidation)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.autoSni != false {
      try visitor.visitSingularBoolField(value: self.autoSni, fieldNumber: 1)
    }
    if self.autoSanValidation != false {
      try visitor.visitSingularBoolField(value: self.autoSanValidation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_UpstreamHttpProtocolOptions, rhs: Envoy_Config_Core_V4alpha_UpstreamHttpProtocolOptions) -> Bool {
    if lhs.autoSni != rhs.autoSni {return false}
    if lhs.autoSanValidation != rhs.autoSanValidation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_HttpProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "idle_timeout"),
    3: .standard(proto: "max_connection_duration"),
    2: .standard(proto: "max_headers_count"),
    4: .standard(proto: "max_stream_duration"),
    5: .standard(proto: "headers_with_underscores_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._idleTimeout)
      case 2: try decoder.decodeSingularMessageField(value: &self._maxHeadersCount)
      case 3: try decoder.decodeSingularMessageField(value: &self._maxConnectionDuration)
      case 4: try decoder.decodeSingularMessageField(value: &self._maxStreamDuration)
      case 5: try decoder.decodeSingularEnumField(value: &self.headersWithUnderscoresAction)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._idleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxHeadersCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._maxConnectionDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._maxStreamDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.headersWithUnderscoresAction != .allow {
      try visitor.visitSingularEnumField(value: self.headersWithUnderscoresAction, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_HttpProtocolOptions, rhs: Envoy_Config_Core_V4alpha_HttpProtocolOptions) -> Bool {
    if lhs._idleTimeout != rhs._idleTimeout {return false}
    if lhs._maxConnectionDuration != rhs._maxConnectionDuration {return false}
    if lhs._maxHeadersCount != rhs._maxHeadersCount {return false}
    if lhs._maxStreamDuration != rhs._maxStreamDuration {return false}
    if lhs.headersWithUnderscoresAction != rhs.headersWithUnderscoresAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_HttpProtocolOptions.HeadersWithUnderscoresAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW"),
    1: .same(proto: "REJECT_REQUEST"),
    2: .same(proto: "DROP_HEADER"),
  ]
}

extension Envoy_Config_Core_V4alpha_Http1ProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Http1ProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_absolute_url"),
    2: .standard(proto: "accept_http_10"),
    3: .standard(proto: "default_host_for_http_10"),
    4: .standard(proto: "header_key_format"),
    5: .standard(proto: "enable_trailers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._allowAbsoluteURL)
      case 2: try decoder.decodeSingularBoolField(value: &self.acceptHTTP10)
      case 3: try decoder.decodeSingularStringField(value: &self.defaultHostForHTTP10)
      case 4: try decoder.decodeSingularMessageField(value: &self._headerKeyFormat)
      case 5: try decoder.decodeSingularBoolField(value: &self.enableTrailers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._allowAbsoluteURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.acceptHTTP10 != false {
      try visitor.visitSingularBoolField(value: self.acceptHTTP10, fieldNumber: 2)
    }
    if !self.defaultHostForHTTP10.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultHostForHTTP10, fieldNumber: 3)
    }
    if let v = self._headerKeyFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.enableTrailers != false {
      try visitor.visitSingularBoolField(value: self.enableTrailers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions, rhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions) -> Bool {
    if lhs._allowAbsoluteURL != rhs._allowAbsoluteURL {return false}
    if lhs.acceptHTTP10 != rhs.acceptHTTP10 {return false}
    if lhs.defaultHostForHTTP10 != rhs.defaultHostForHTTP10 {return false}
    if lhs._headerKeyFormat != rhs._headerKeyFormat {return false}
    if lhs.enableTrailers != rhs.enableTrailers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Core_V4alpha_Http1ProtocolOptions.protoMessageName + ".HeaderKeyFormat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proper_case_words"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords?
        if let current = self.headerFormat {
          try decoder.handleConflictingOneOf()
          if case .properCaseWords(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.headerFormat = .properCaseWords(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .properCaseWords(let v)? = self.headerFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat, rhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat) -> Bool {
    if lhs.headerFormat != rhs.headerFormat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.protoMessageName + ".ProperCaseWords"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords, rhs: Envoy_Config_Core_V4alpha_Http1ProtocolOptions.HeaderKeyFormat.ProperCaseWords) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_Http2ProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Http2ProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hpack_table_size"),
    2: .standard(proto: "max_concurrent_streams"),
    3: .standard(proto: "initial_stream_window_size"),
    4: .standard(proto: "initial_connection_window_size"),
    5: .standard(proto: "allow_connect"),
    6: .standard(proto: "allow_metadata"),
    7: .standard(proto: "max_outbound_frames"),
    8: .standard(proto: "max_outbound_control_frames"),
    9: .standard(proto: "max_consecutive_inbound_frames_with_empty_payload"),
    10: .standard(proto: "max_inbound_priority_frames_per_stream"),
    11: .standard(proto: "max_inbound_window_update_frames_per_data_frame_sent"),
    12: .standard(proto: "stream_error_on_invalid_http_messaging"),
    13: .standard(proto: "custom_settings_parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._hpackTableSize)
      case 2: try decoder.decodeSingularMessageField(value: &self._maxConcurrentStreams)
      case 3: try decoder.decodeSingularMessageField(value: &self._initialStreamWindowSize)
      case 4: try decoder.decodeSingularMessageField(value: &self._initialConnectionWindowSize)
      case 5: try decoder.decodeSingularBoolField(value: &self.allowConnect)
      case 6: try decoder.decodeSingularBoolField(value: &self.allowMetadata)
      case 7: try decoder.decodeSingularMessageField(value: &self._maxOutboundFrames)
      case 8: try decoder.decodeSingularMessageField(value: &self._maxOutboundControlFrames)
      case 9: try decoder.decodeSingularMessageField(value: &self._maxConsecutiveInboundFramesWithEmptyPayload)
      case 10: try decoder.decodeSingularMessageField(value: &self._maxInboundPriorityFramesPerStream)
      case 11: try decoder.decodeSingularMessageField(value: &self._maxInboundWindowUpdateFramesPerDataFrameSent)
      case 12: try decoder.decodeSingularBoolField(value: &self.streamErrorOnInvalidHTTPMessaging)
      case 13: try decoder.decodeRepeatedMessageField(value: &self.customSettingsParameters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._hpackTableSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxConcurrentStreams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._initialStreamWindowSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._initialConnectionWindowSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.allowConnect != false {
      try visitor.visitSingularBoolField(value: self.allowConnect, fieldNumber: 5)
    }
    if self.allowMetadata != false {
      try visitor.visitSingularBoolField(value: self.allowMetadata, fieldNumber: 6)
    }
    if let v = self._maxOutboundFrames {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._maxOutboundControlFrames {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._maxConsecutiveInboundFramesWithEmptyPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._maxInboundPriorityFramesPerStream {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._maxInboundWindowUpdateFramesPerDataFrameSent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if self.streamErrorOnInvalidHTTPMessaging != false {
      try visitor.visitSingularBoolField(value: self.streamErrorOnInvalidHTTPMessaging, fieldNumber: 12)
    }
    if !self.customSettingsParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customSettingsParameters, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_Http2ProtocolOptions, rhs: Envoy_Config_Core_V4alpha_Http2ProtocolOptions) -> Bool {
    if lhs._hpackTableSize != rhs._hpackTableSize {return false}
    if lhs._maxConcurrentStreams != rhs._maxConcurrentStreams {return false}
    if lhs._initialStreamWindowSize != rhs._initialStreamWindowSize {return false}
    if lhs._initialConnectionWindowSize != rhs._initialConnectionWindowSize {return false}
    if lhs.allowConnect != rhs.allowConnect {return false}
    if lhs.allowMetadata != rhs.allowMetadata {return false}
    if lhs._maxOutboundFrames != rhs._maxOutboundFrames {return false}
    if lhs._maxOutboundControlFrames != rhs._maxOutboundControlFrames {return false}
    if lhs._maxConsecutiveInboundFramesWithEmptyPayload != rhs._maxConsecutiveInboundFramesWithEmptyPayload {return false}
    if lhs._maxInboundPriorityFramesPerStream != rhs._maxInboundPriorityFramesPerStream {return false}
    if lhs._maxInboundWindowUpdateFramesPerDataFrameSent != rhs._maxInboundWindowUpdateFramesPerDataFrameSent {return false}
    if lhs.streamErrorOnInvalidHTTPMessaging != rhs.streamErrorOnInvalidHTTPMessaging {return false}
    if lhs.customSettingsParameters != rhs.customSettingsParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_Http2ProtocolOptions.SettingsParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Core_V4alpha_Http2ProtocolOptions.protoMessageName + ".SettingsParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identifier"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._identifier)
      case 2: try decoder.decodeSingularMessageField(value: &self._value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._identifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_Http2ProtocolOptions.SettingsParameter, rhs: Envoy_Config_Core_V4alpha_Http2ProtocolOptions.SettingsParameter) -> Bool {
    if lhs._identifier != rhs._identifier {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Core_V4alpha_GrpcProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrpcProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http2_protocol_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._http2ProtocolOptions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._http2ProtocolOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Core_V4alpha_GrpcProtocolOptions, rhs: Envoy_Config_Core_V4alpha_GrpcProtocolOptions) -> Bool {
    if lhs._http2ProtocolOptions != rhs._http2ProtocolOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

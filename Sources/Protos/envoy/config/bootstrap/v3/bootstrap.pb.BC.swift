// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/bootstrap/v3/bootstrap.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
/// [#next-free-field: 28]
public struct Envoy_Config_Bootstrap_V3_Bootstrap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Node identity to present to the management server and for instance
  /// identification purposes (e.g. in generated headers).
  public var node: Envoy_Config_Core_V3_Node {
    get {return _storage._node ?? Envoy_Config_Core_V3_Node()}
    set {_uniqueStorage()._node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return _storage._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {_uniqueStorage()._node = nil}

  /// A list of :ref:`Node <envoy_v3_api_msg_config.core.v3.Node>` field names
  /// that will be included in the context parameters of the effective
  /// *UdpaResourceLocator* that is sent in a discovery request when resource
  /// locators are used for LDS/CDS. Any non-string field will have its JSON
  /// encoding set as the context parameter value, with the exception of
  /// metadata, which will be flattened (see example below). The supported field
  /// names are:
  /// - "cluster"
  /// - "id"
  /// - "locality.region"
  /// - "locality.sub_zone"
  /// - "locality.zone"
  /// - "metadata"
  /// - "user_agent_build_version.metadata"
  /// - "user_agent_build_version.version"
  /// - "user_agent_name"
  /// - "user_agent_version"
  ///
  /// The node context parameters act as a base layer dictionary for the context
  /// parameters (i.e. more specific resource specific context parameters will
  /// override). Field names will be prefixed with “udpa.node.” when included in
  /// context parameters.
  ///
  /// For example, if node_context_params is ``["user_agent_name", "metadata"]``,
  /// the implied context parameters might be::
  ///
  ///   node.user_agent_name: "envoy"
  ///   node.metadata.foo: "{\"bar\": \"baz\"}"
  ///   node.metadata.some: "42"
  ///   node.metadata.thing: "\"thing\""
  ///
  /// [#not-implemented-hide:]
  public var nodeContextParams: [String] {
    get {return _storage._nodeContextParams}
    set {_uniqueStorage()._nodeContextParams = newValue}
  }

  /// Statically specified resources.
  public var staticResources: Envoy_Config_Bootstrap_V3_Bootstrap.StaticResources {
    get {return _storage._staticResources ?? Envoy_Config_Bootstrap_V3_Bootstrap.StaticResources()}
    set {_uniqueStorage()._staticResources = newValue}
  }
  /// Returns true if `staticResources` has been explicitly set.
  public var hasStaticResources: Bool {return _storage._staticResources != nil}
  /// Clears the value of `staticResources`. Subsequent reads from it will return its default value.
  public mutating func clearStaticResources() {_uniqueStorage()._staticResources = nil}

  /// xDS configuration sources.
  public var dynamicResources: Envoy_Config_Bootstrap_V3_Bootstrap.DynamicResources {
    get {return _storage._dynamicResources ?? Envoy_Config_Bootstrap_V3_Bootstrap.DynamicResources()}
    set {_uniqueStorage()._dynamicResources = newValue}
  }
  /// Returns true if `dynamicResources` has been explicitly set.
  public var hasDynamicResources: Bool {return _storage._dynamicResources != nil}
  /// Clears the value of `dynamicResources`. Subsequent reads from it will return its default value.
  public mutating func clearDynamicResources() {_uniqueStorage()._dynamicResources = nil}

  /// Configuration for the cluster manager which owns all upstream clusters
  /// within the server.
  public var clusterManager: Envoy_Config_Bootstrap_V3_ClusterManager {
    get {return _storage._clusterManager ?? Envoy_Config_Bootstrap_V3_ClusterManager()}
    set {_uniqueStorage()._clusterManager = newValue}
  }
  /// Returns true if `clusterManager` has been explicitly set.
  public var hasClusterManager: Bool {return _storage._clusterManager != nil}
  /// Clears the value of `clusterManager`. Subsequent reads from it will return its default value.
  public mutating func clearClusterManager() {_uniqueStorage()._clusterManager = nil}

  /// Health discovery service config option.
  /// (:ref:`core.ApiConfigSource <envoy_api_msg_config.core.v3.ApiConfigSource>`)
  public var hdsConfig: Envoy_Config_Core_V3_ApiConfigSource {
    get {return _storage._hdsConfig ?? Envoy_Config_Core_V3_ApiConfigSource()}
    set {_uniqueStorage()._hdsConfig = newValue}
  }
  /// Returns true if `hdsConfig` has been explicitly set.
  public var hasHdsConfig: Bool {return _storage._hdsConfig != nil}
  /// Clears the value of `hdsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearHdsConfig() {_uniqueStorage()._hdsConfig = nil}

  /// Optional file system path to search for startup flag files.
  public var flagsPath: String {
    get {return _storage._flagsPath}
    set {_uniqueStorage()._flagsPath = newValue}
  }

  /// Optional set of stats sinks.
  public var statsSinks: [Envoy_Config_Metrics_V3_StatsSink] {
    get {return _storage._statsSinks}
    set {_uniqueStorage()._statsSinks = newValue}
  }

  /// Configuration for internal processing of stats.
  public var statsConfig: Envoy_Config_Metrics_V3_StatsConfig {
    get {return _storage._statsConfig ?? Envoy_Config_Metrics_V3_StatsConfig()}
    set {_uniqueStorage()._statsConfig = newValue}
  }
  /// Returns true if `statsConfig` has been explicitly set.
  public var hasStatsConfig: Bool {return _storage._statsConfig != nil}
  /// Clears the value of `statsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearStatsConfig() {_uniqueStorage()._statsConfig = nil}

  /// Optional duration between flushes to configured stats sinks. For
  /// performance reasons Envoy latches counters and only flushes counters and
  /// gauges at a periodic interval. If not specified the default is 5000ms (5
  /// seconds).
  /// Duration must be at least 1ms and at most 5 min.
  public var statsFlushInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._statsFlushInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._statsFlushInterval = newValue}
  }
  /// Returns true if `statsFlushInterval` has been explicitly set.
  public var hasStatsFlushInterval: Bool {return _storage._statsFlushInterval != nil}
  /// Clears the value of `statsFlushInterval`. Subsequent reads from it will return its default value.
  public mutating func clearStatsFlushInterval() {_uniqueStorage()._statsFlushInterval = nil}

  /// Optional watchdog configuration.
  /// This is for a single watchdog configuration for the entire system.
  /// Deprecated in favor of *watchdogs* which has finer granularity.
  public var watchdog: Envoy_Config_Bootstrap_V3_Watchdog {
    get {return _storage._watchdog ?? Envoy_Config_Bootstrap_V3_Watchdog()}
    set {_uniqueStorage()._watchdog = newValue}
  }
  /// Returns true if `watchdog` has been explicitly set.
  public var hasWatchdog: Bool {return _storage._watchdog != nil}
  /// Clears the value of `watchdog`. Subsequent reads from it will return its default value.
  public mutating func clearWatchdog() {_uniqueStorage()._watchdog = nil}

  /// Optional watchdogs configuration.
  /// This is used for specifying different watchdogs for the different subsystems.
  public var watchdogs: Envoy_Config_Bootstrap_V3_Watchdogs {
    get {return _storage._watchdogs ?? Envoy_Config_Bootstrap_V3_Watchdogs()}
    set {_uniqueStorage()._watchdogs = newValue}
  }
  /// Returns true if `watchdogs` has been explicitly set.
  public var hasWatchdogs: Bool {return _storage._watchdogs != nil}
  /// Clears the value of `watchdogs`. Subsequent reads from it will return its default value.
  public mutating func clearWatchdogs() {_uniqueStorage()._watchdogs = nil}

  /// Configuration for an external tracing provider.
  ///
  /// .. attention::
  ///  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
  ///  <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.provider>`.
  public var tracing: Envoy_Config_Trace_V3_Tracing {
    get {return _storage._tracing ?? Envoy_Config_Trace_V3_Tracing()}
    set {_uniqueStorage()._tracing = newValue}
  }
  /// Returns true if `tracing` has been explicitly set.
  public var hasTracing: Bool {return _storage._tracing != nil}
  /// Clears the value of `tracing`. Subsequent reads from it will return its default value.
  public mutating func clearTracing() {_uniqueStorage()._tracing = nil}

  /// Configuration for the runtime configuration provider. If not
  /// specified, a “null” provider will be used which will result in all defaults
  /// being used.
  public var layeredRuntime: Envoy_Config_Bootstrap_V3_LayeredRuntime {
    get {return _storage._layeredRuntime ?? Envoy_Config_Bootstrap_V3_LayeredRuntime()}
    set {_uniqueStorage()._layeredRuntime = newValue}
  }
  /// Returns true if `layeredRuntime` has been explicitly set.
  public var hasLayeredRuntime: Bool {return _storage._layeredRuntime != nil}
  /// Clears the value of `layeredRuntime`. Subsequent reads from it will return its default value.
  public mutating func clearLayeredRuntime() {_uniqueStorage()._layeredRuntime = nil}

  /// Configuration for the local administration HTTP server.
  public var admin: Envoy_Config_Bootstrap_V3_Admin {
    get {return _storage._admin ?? Envoy_Config_Bootstrap_V3_Admin()}
    set {_uniqueStorage()._admin = newValue}
  }
  /// Returns true if `admin` has been explicitly set.
  public var hasAdmin: Bool {return _storage._admin != nil}
  /// Clears the value of `admin`. Subsequent reads from it will return its default value.
  public mutating func clearAdmin() {_uniqueStorage()._admin = nil}

  /// Optional overload manager configuration.
  public var overloadManager: Envoy_Config_Overload_V3_OverloadManager {
    get {return _storage._overloadManager ?? Envoy_Config_Overload_V3_OverloadManager()}
    set {_uniqueStorage()._overloadManager = newValue}
  }
  /// Returns true if `overloadManager` has been explicitly set.
  public var hasOverloadManager: Bool {return _storage._overloadManager != nil}
  /// Clears the value of `overloadManager`. Subsequent reads from it will return its default value.
  public mutating func clearOverloadManager() {_uniqueStorage()._overloadManager = nil}

  /// Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
  /// Note that this records a value for each iteration of the event loop on every thread. This
  /// should normally be minimal overhead, but when using
  /// :ref:`statsd <envoy_api_msg_config.metrics.v3.StatsdSink>`, it will send each observed value
  /// over the wire individually because the statsd protocol doesn't have any way to represent a
  /// histogram summary. Be aware that this can be a very large volume of data.
  public var enableDispatcherStats: Bool {
    get {return _storage._enableDispatcherStats}
    set {_uniqueStorage()._enableDispatcherStats = newValue}
  }

  /// Optional string which will be used in lieu of x-envoy in prefixing headers.
  ///
  /// For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
  /// transformed into x-foo-retry-on etc.
  ///
  /// Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
  /// headers Envoy will trust for core code and core extensions only. Be VERY careful making
  /// changes to this string, especially in multi-layer Envoy deployments or deployments using
  /// extensions which are not upstream.
  public var headerPrefix: String {
    get {return _storage._headerPrefix}
    set {_uniqueStorage()._headerPrefix = newValue}
  }

  /// Optional proxy version which will be used to set the value of :ref:`server.version statistic
  /// <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
  /// :ref:`stats sinks <envoy_api_msg_config.metrics.v3.StatsSink>`.
  public var statsServerVersionOverride: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._statsServerVersionOverride ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._statsServerVersionOverride = newValue}
  }
  /// Returns true if `statsServerVersionOverride` has been explicitly set.
  public var hasStatsServerVersionOverride: Bool {return _storage._statsServerVersionOverride != nil}
  /// Clears the value of `statsServerVersionOverride`. Subsequent reads from it will return its default value.
  public mutating func clearStatsServerVersionOverride() {_uniqueStorage()._statsServerVersionOverride = nil}

  /// Always use TCP queries instead of UDP queries for DNS lookups.
  /// This may be overridden on a per-cluster basis in cds_config,
  /// when :ref:`dns_resolvers <envoy_api_field_config.cluster.v3.Cluster.dns_resolvers>` and
  /// :ref:`use_tcp_for_dns_lookups <envoy_api_field_config.cluster.v3.Cluster.use_tcp_for_dns_lookups>` are
  /// specified.
  /// Setting this value causes failure if the
  /// ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
  /// server startup. Apple' API only uses UDP for DNS resolution.
  public var useTcpForDnsLookups: Bool {
    get {return _storage._useTcpForDnsLookups}
    set {_uniqueStorage()._useTcpForDnsLookups = newValue}
  }

  /// Specifies optional bootstrap extensions to be instantiated at startup time.
  /// Each item contains extension specific configuration.
  public var bootstrapExtensions: [Envoy_Config_Core_V3_TypedExtensionConfig] {
    get {return _storage._bootstrapExtensions}
    set {_uniqueStorage()._bootstrapExtensions = newValue}
  }

  /// Configuration sources that will participate in
  /// *udpa.core.v1.ResourceLocator* authority resolution. The algorithm is as
  /// follows:
  /// 1. The authority field is taken from the *udpa.core.v1.ResourceLocator*, call
  ///    this *resource_authority*.
  /// 2. *resource_authority* is compared against the authorities in any peer
  ///    *ConfigSource*. The peer *ConfigSource* is the configuration source
  ///    message which would have been used unconditionally for resolution
  ///    with opaque resource names. If there is a match with an authority, the
  ///    peer *ConfigSource* message is used.
  /// 3. *resource_authority* is compared sequentially with the authorities in
  ///    each configuration source in *config_sources*. The first *ConfigSource*
  ///    to match wins.
  /// 4. As a fallback, if no configuration source matches, then
  ///    *default_config_source* is used.
  /// 5. If *default_config_source* is not specified, resolution fails.
  /// [#not-implemented-hide:]
  public var configSources: [Envoy_Config_Core_V3_ConfigSource] {
    get {return _storage._configSources}
    set {_uniqueStorage()._configSources = newValue}
  }

  /// Default configuration source for *udpa.core.v1.ResourceLocator* if all
  /// other resolution fails.
  /// [#not-implemented-hide:]
  public var defaultConfigSource: Envoy_Config_Core_V3_ConfigSource {
    get {return _storage._defaultConfigSource ?? Envoy_Config_Core_V3_ConfigSource()}
    set {_uniqueStorage()._defaultConfigSource = newValue}
  }
  /// Returns true if `defaultConfigSource` has been explicitly set.
  public var hasDefaultConfigSource: Bool {return _storage._defaultConfigSource != nil}
  /// Clears the value of `defaultConfigSource`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultConfigSource() {_uniqueStorage()._defaultConfigSource = nil}

  /// Optional overriding of default socket interface. The value must be the name of one of the
  /// socket interface factories initialized through a bootstrap extension
  public var defaultSocketInterface: String {
    get {return _storage._defaultSocketInterface}
    set {_uniqueStorage()._defaultSocketInterface = newValue}
  }

  /// Global map of CertificateProvider instances. These instances are referred to by name in the
  /// :ref:`CommonTlsContext.CertificateProviderInstance.instance_name
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CommonTlsContext.CertificateProviderInstance.instance_name>`
  /// field.
  /// [#not-implemented-hide:]
  public var certificateProviderInstances: Dictionary<String,Envoy_Config_Core_V3_TypedExtensionConfig> {
    get {return _storage._certificateProviderInstances}
    set {_uniqueStorage()._certificateProviderInstances = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct StaticResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Static :ref:`Listeners <envoy_api_msg_config.listener.v3.Listener>`. These listeners are
    /// available regardless of LDS configuration.
    public var listeners: [Envoy_Config_Listener_V3_Listener] = []

    /// If a network based configuration source is specified for :ref:`cds_config
    /// <envoy_api_field_config.bootstrap.v3.Bootstrap.DynamicResources.cds_config>`, it's necessary
    /// to have some initial cluster definitions available to allow Envoy to know
    /// how to speak to the management server. These cluster definitions may not
    /// use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
    /// IP or DNS-based).
    public var clusters: [Envoy_Config_Cluster_V3_Cluster] = []

    /// These static secrets can be used by :ref:`SdsSecretConfig
    /// <envoy_api_msg_extensions.transport_sockets.tls.v3.SdsSecretConfig>`
    public var secrets: [Envoy_Extensions_TransportSockets_Tls_V3_Secret] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// [#next-free-field: 7]
  public struct DynamicResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// All :ref:`Listeners <envoy_api_msg_config.listener.v3.Listener>` are provided by a single
    /// :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
    public var ldsConfig: Envoy_Config_Core_V3_ConfigSource {
      get {return _storage._ldsConfig ?? Envoy_Config_Core_V3_ConfigSource()}
      set {_uniqueStorage()._ldsConfig = newValue}
    }
    /// Returns true if `ldsConfig` has been explicitly set.
    public var hasLdsConfig: Bool {return _storage._ldsConfig != nil}
    /// Clears the value of `ldsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearLdsConfig() {_uniqueStorage()._ldsConfig = nil}

    /// Resource locator for listener collection.
    /// [#not-implemented-hide:]
    public var ldsResourcesLocator: Udpa_Core_V1_ResourceLocator {
      get {return _storage._ldsResourcesLocator ?? Udpa_Core_V1_ResourceLocator()}
      set {_uniqueStorage()._ldsResourcesLocator = newValue}
    }
    /// Returns true if `ldsResourcesLocator` has been explicitly set.
    public var hasLdsResourcesLocator: Bool {return _storage._ldsResourcesLocator != nil}
    /// Clears the value of `ldsResourcesLocator`. Subsequent reads from it will return its default value.
    public mutating func clearLdsResourcesLocator() {_uniqueStorage()._ldsResourcesLocator = nil}

    /// All post-bootstrap :ref:`Cluster <envoy_api_msg_config.cluster.v3.Cluster>` definitions are
    /// provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
    /// configuration source.
    public var cdsConfig: Envoy_Config_Core_V3_ConfigSource {
      get {return _storage._cdsConfig ?? Envoy_Config_Core_V3_ConfigSource()}
      set {_uniqueStorage()._cdsConfig = newValue}
    }
    /// Returns true if `cdsConfig` has been explicitly set.
    public var hasCdsConfig: Bool {return _storage._cdsConfig != nil}
    /// Clears the value of `cdsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearCdsConfig() {_uniqueStorage()._cdsConfig = nil}

    /// Resource locator for cluster collection.
    /// [#not-implemented-hide:]
    public var cdsResourcesLocator: Udpa_Core_V1_ResourceLocator {
      get {return _storage._cdsResourcesLocator ?? Udpa_Core_V1_ResourceLocator()}
      set {_uniqueStorage()._cdsResourcesLocator = newValue}
    }
    /// Returns true if `cdsResourcesLocator` has been explicitly set.
    public var hasCdsResourcesLocator: Bool {return _storage._cdsResourcesLocator != nil}
    /// Clears the value of `cdsResourcesLocator`. Subsequent reads from it will return its default value.
    public mutating func clearCdsResourcesLocator() {_uniqueStorage()._cdsResourcesLocator = nil}

    /// A single :ref:`ADS <config_overview_ads>` source may be optionally
    /// specified. This must have :ref:`api_type
    /// <envoy_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
    /// <envoy_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`. Only
    /// :ref:`ConfigSources <envoy_api_msg_config.core.v3.ConfigSource>` that have
    /// the :ref:`ads <envoy_api_field_config.core.v3.ConfigSource.ads>` field set will be
    /// streamed on the ADS channel.
    public var adsConfig: Envoy_Config_Core_V3_ApiConfigSource {
      get {return _storage._adsConfig ?? Envoy_Config_Core_V3_ApiConfigSource()}
      set {_uniqueStorage()._adsConfig = newValue}
    }
    /// Returns true if `adsConfig` has been explicitly set.
    public var hasAdsConfig: Bool {return _storage._adsConfig != nil}
    /// Clears the value of `adsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearAdsConfig() {_uniqueStorage()._adsConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Administration interface :ref:`operations documentation
/// <operations_admin_interface>`.
public struct Envoy_Config_Bootstrap_V3_Admin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path to write the access log for the administration server. If no
  /// access log is desired specify ‘/dev/null’. This is only required if
  /// :ref:`address <envoy_api_field_config.bootstrap.v3.Admin.address>` is set.
  public var accessLogPath: String = String()

  /// The cpu profiler output path for the administration server. If no profile
  /// path is specified, the default is ‘/var/log/envoy/envoy.prof’.
  public var profilePath: String = String()

  /// The TCP address that the administration server will listen on.
  /// If not specified, Envoy will not start an administration server.
  public var address: Envoy_Config_Core_V3_Address {
    get {return _address ?? Envoy_Config_Core_V3_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  /// Additional socket options that may not be present in Envoy source code or
  /// precompiled binaries.
  public var socketOptions: [Envoy_Config_Core_V3_SocketOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Envoy_Config_Core_V3_Address? = nil
}

/// Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
public struct Envoy_Config_Bootstrap_V3_ClusterManager {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the local cluster (i.e., the cluster that owns the Envoy running
  /// this configuration). In order to enable :ref:`zone aware routing
  /// <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
  /// If *local_cluster_name* is defined then :ref:`clusters
  /// <envoy_api_msg_config.cluster.v3.Cluster>` must be defined in the :ref:`Bootstrap
  /// static cluster resources
  /// <envoy_api_field_config.bootstrap.v3.Bootstrap.StaticResources.clusters>`. This is unrelated to
  /// the :option:`--service-cluster` option which does not `affect zone aware
  /// routing <https://github.com/envoyproxy/envoy/issues/774>`_.
  public var localClusterName: String {
    get {return _storage._localClusterName}
    set {_uniqueStorage()._localClusterName = newValue}
  }

  /// Optional global configuration for outlier detection.
  public var outlierDetection: Envoy_Config_Bootstrap_V3_ClusterManager.OutlierDetection {
    get {return _storage._outlierDetection ?? Envoy_Config_Bootstrap_V3_ClusterManager.OutlierDetection()}
    set {_uniqueStorage()._outlierDetection = newValue}
  }
  /// Returns true if `outlierDetection` has been explicitly set.
  public var hasOutlierDetection: Bool {return _storage._outlierDetection != nil}
  /// Clears the value of `outlierDetection`. Subsequent reads from it will return its default value.
  public mutating func clearOutlierDetection() {_uniqueStorage()._outlierDetection = nil}

  /// Optional configuration used to bind newly established upstream connections.
  /// This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
  public var upstreamBindConfig: Envoy_Config_Core_V3_BindConfig {
    get {return _storage._upstreamBindConfig ?? Envoy_Config_Core_V3_BindConfig()}
    set {_uniqueStorage()._upstreamBindConfig = newValue}
  }
  /// Returns true if `upstreamBindConfig` has been explicitly set.
  public var hasUpstreamBindConfig: Bool {return _storage._upstreamBindConfig != nil}
  /// Clears the value of `upstreamBindConfig`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamBindConfig() {_uniqueStorage()._upstreamBindConfig = nil}

  /// A management server endpoint to stream load stats to via
  /// *StreamLoadStats*. This must have :ref:`api_type
  /// <envoy_api_field_config.core.v3.ApiConfigSource.api_type>` :ref:`GRPC
  /// <envoy_api_enum_value_config.core.v3.ApiConfigSource.ApiType.GRPC>`.
  public var loadStatsConfig: Envoy_Config_Core_V3_ApiConfigSource {
    get {return _storage._loadStatsConfig ?? Envoy_Config_Core_V3_ApiConfigSource()}
    set {_uniqueStorage()._loadStatsConfig = newValue}
  }
  /// Returns true if `loadStatsConfig` has been explicitly set.
  public var hasLoadStatsConfig: Bool {return _storage._loadStatsConfig != nil}
  /// Clears the value of `loadStatsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearLoadStatsConfig() {_uniqueStorage()._loadStatsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct OutlierDetection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the path to the outlier event log.
    public var eventLogPath: String = String()

    /// [#not-implemented-hide:]
    /// The gRPC service for the outlier detection event service.
    /// If empty, outlier detection events won't be sent to a remote endpoint.
    public var eventService: Envoy_Config_Core_V3_EventServiceConfig {
      get {return _eventService ?? Envoy_Config_Core_V3_EventServiceConfig()}
      set {_eventService = newValue}
    }
    /// Returns true if `eventService` has been explicitly set.
    public var hasEventService: Bool {return self._eventService != nil}
    /// Clears the value of `eventService`. Subsequent reads from it will return its default value.
    public mutating func clearEventService() {self._eventService = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _eventService: Envoy_Config_Core_V3_EventServiceConfig? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Allows you to specify different watchdog configs for different subsystems.
/// This allows finer tuned policies for the watchdog. If a subsystem is omitted
/// the default values for that system will be used.
public struct Envoy_Config_Bootstrap_V3_Watchdogs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Watchdog for the main thread.
  public var mainThreadWatchdog: Envoy_Config_Bootstrap_V3_Watchdog {
    get {return _storage._mainThreadWatchdog ?? Envoy_Config_Bootstrap_V3_Watchdog()}
    set {_uniqueStorage()._mainThreadWatchdog = newValue}
  }
  /// Returns true if `mainThreadWatchdog` has been explicitly set.
  public var hasMainThreadWatchdog: Bool {return _storage._mainThreadWatchdog != nil}
  /// Clears the value of `mainThreadWatchdog`. Subsequent reads from it will return its default value.
  public mutating func clearMainThreadWatchdog() {_uniqueStorage()._mainThreadWatchdog = nil}

  /// Watchdog for the worker threads.
  public var workerWatchdog: Envoy_Config_Bootstrap_V3_Watchdog {
    get {return _storage._workerWatchdog ?? Envoy_Config_Bootstrap_V3_Watchdog()}
    set {_uniqueStorage()._workerWatchdog = newValue}
  }
  /// Returns true if `workerWatchdog` has been explicitly set.
  public var hasWorkerWatchdog: Bool {return _storage._workerWatchdog != nil}
  /// Clears the value of `workerWatchdog`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerWatchdog() {_uniqueStorage()._workerWatchdog = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Envoy process watchdog configuration. When configured, this monitors for
/// nonresponsive threads and kills the process after the configured thresholds.
/// See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
/// [#next-free-field: 8]
public struct Envoy_Config_Bootstrap_V3_Watchdog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Register actions that will fire on given WatchDog events.
  /// See *WatchDogAction* for priority of events.
  public var actions: [Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction] = []

  /// The duration after which Envoy counts a nonresponsive thread in the
  /// *watchdog_miss* statistic. If not specified the default is 200ms.
  public var missTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _missTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_missTimeout = newValue}
  }
  /// Returns true if `missTimeout` has been explicitly set.
  public var hasMissTimeout: Bool {return self._missTimeout != nil}
  /// Clears the value of `missTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMissTimeout() {self._missTimeout = nil}

  /// The duration after which Envoy counts a nonresponsive thread in the
  /// *watchdog_mega_miss* statistic. If not specified the default is
  /// 1000ms.
  public var megamissTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _megamissTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_megamissTimeout = newValue}
  }
  /// Returns true if `megamissTimeout` has been explicitly set.
  public var hasMegamissTimeout: Bool {return self._megamissTimeout != nil}
  /// Clears the value of `megamissTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMegamissTimeout() {self._megamissTimeout = nil}

  /// If a watched thread has been nonresponsive for this duration, assume a
  /// programming error and kill the entire Envoy process. Set to 0 to disable
  /// kill behavior. If not specified the default is 0 (disabled).
  public var killTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _killTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_killTimeout = newValue}
  }
  /// Returns true if `killTimeout` has been explicitly set.
  public var hasKillTimeout: Bool {return self._killTimeout != nil}
  /// Clears the value of `killTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearKillTimeout() {self._killTimeout = nil}

  /// Defines the maximum jitter used to adjust the *kill_timeout* if *kill_timeout* is
  /// enabled. Enabling this feature would help to reduce risk of synchronized
  /// watchdog kill events across proxies due to external triggers. Set to 0 to
  /// disable. If not specified the default is 0 (disabled).
  public var maxKillTimeoutJitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxKillTimeoutJitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxKillTimeoutJitter = newValue}
  }
  /// Returns true if `maxKillTimeoutJitter` has been explicitly set.
  public var hasMaxKillTimeoutJitter: Bool {return self._maxKillTimeoutJitter != nil}
  /// Clears the value of `maxKillTimeoutJitter`. Subsequent reads from it will return its default value.
  public mutating func clearMaxKillTimeoutJitter() {self._maxKillTimeoutJitter = nil}

  /// If max(2, ceil(registered_threads * Fraction(*multikill_threshold*)))
  /// threads have been nonresponsive for at least this duration kill the entire
  /// Envoy process. Set to 0 to disable this behavior. If not specified the
  /// default is 0 (disabled).
  public var multikillTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _multikillTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_multikillTimeout = newValue}
  }
  /// Returns true if `multikillTimeout` has been explicitly set.
  public var hasMultikillTimeout: Bool {return self._multikillTimeout != nil}
  /// Clears the value of `multikillTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMultikillTimeout() {self._multikillTimeout = nil}

  /// Sets the threshold for *multikill_timeout* in terms of the percentage of
  /// nonresponsive threads required for the *multikill_timeout*.
  /// If not specified the default is 0.
  public var multikillThreshold: Envoy_Type_V3_Percent {
    get {return _multikillThreshold ?? Envoy_Type_V3_Percent()}
    set {_multikillThreshold = newValue}
  }
  /// Returns true if `multikillThreshold` has been explicitly set.
  public var hasMultikillThreshold: Bool {return self._multikillThreshold != nil}
  /// Clears the value of `multikillThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearMultikillThreshold() {self._multikillThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct WatchdogAction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Extension specific configuration for the action.
    public var config: Envoy_Config_Core_V3_TypedExtensionConfig {
      get {return _config ?? Envoy_Config_Core_V3_TypedExtensionConfig()}
      set {_config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {return self._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {self._config = nil}

    public var event: Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction.WatchdogEvent = .unknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The events are fired in this order: KILL, MULTIKILL, MEGAMISS, MISS.
    /// Within an event type, actions execute in the order they are configured.
    /// For KILL/MULTIKILL there is a default PANIC that will run after the
    /// registered actions and kills the process if it wasn't already killed.
    /// It might be useful to specify several debug actions, and possibly an
    /// alternate FATAL action.
    public enum WatchdogEvent: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unknown // = 0
      case kill // = 1
      case multikill // = 2
      case megamiss // = 3
      case miss // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unknown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unknown
        case 1: self = .kill
        case 2: self = .multikill
        case 3: self = .megamiss
        case 4: self = .miss
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unknown: return 0
        case .kill: return 1
        case .multikill: return 2
        case .megamiss: return 3
        case .miss: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _config: Envoy_Config_Core_V3_TypedExtensionConfig? = nil
  }

  public init() {}

  fileprivate var _missTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _megamissTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _killTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxKillTimeoutJitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _multikillTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _multikillThreshold: Envoy_Type_V3_Percent? = nil
}

#if swift(>=4.2)

extension Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction.WatchdogEvent: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction.WatchdogEvent] = [
    .unknown,
    .kill,
    .multikill,
    .megamiss,
    .miss,
  ]
}

#endif  // swift(>=4.2)

/// Runtime :ref:`configuration overview <config_runtime>` (deprecated).
public struct Envoy_Config_Bootstrap_V3_Runtime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The implementation assumes that the file system tree is accessed via a
  /// symbolic link. An atomic link swap is used when a new tree should be
  /// switched to. This parameter specifies the path to the symbolic link. Envoy
  /// will watch the location for changes and reload the file system tree when
  /// they happen. If this parameter is not set, there will be no disk based
  /// runtime.
  public var symlinkRoot: String = String()

  /// Specifies the subdirectory to load within the root directory. This is
  /// useful if multiple systems share the same delivery mechanism. Envoy
  /// configuration elements can be contained in a dedicated subdirectory.
  public var subdirectory: String = String()

  /// Specifies an optional subdirectory to load within the root directory. If
  /// specified and the directory exists, configuration values within this
  /// directory will override those found in the primary subdirectory. This is
  /// useful when Envoy is deployed across many different types of servers.
  /// Sometimes it is useful to have a per service cluster directory for runtime
  /// configuration. See below for exactly how the override directory is used.
  public var overrideSubdirectory: String = String()

  /// Static base runtime. This will be :ref:`overridden
  /// <config_runtime_layering>` by other runtime layers, e.g.
  /// disk or admin. This follows the :ref:`runtime protobuf JSON representation
  /// encoding <config_runtime_proto_json>`.
  public var base: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _base ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _base: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// [#next-free-field: 6]
public struct Envoy_Config_Bootstrap_V3_RuntimeLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Descriptive name for the runtime layer. This is only used for the runtime
  /// :http:get:`/runtime` output.
  public var name: String = String()

  public var layerSpecifier: Envoy_Config_Bootstrap_V3_RuntimeLayer.OneOf_LayerSpecifier? = nil

  /// :ref:`Static runtime <config_runtime_bootstrap>` layer.
  /// This follows the :ref:`runtime protobuf JSON representation encoding
  /// <config_runtime_proto_json>`. Unlike static xDS resources, this static
  /// layer is overridable by later layers in the runtime virtual filesystem.
  public var staticLayer: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .staticLayer(let v)? = layerSpecifier {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {layerSpecifier = .staticLayer(newValue)}
  }

  public var diskLayer: Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer {
    get {
      if case .diskLayer(let v)? = layerSpecifier {return v}
      return Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer()
    }
    set {layerSpecifier = .diskLayer(newValue)}
  }

  public var adminLayer: Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer {
    get {
      if case .adminLayer(let v)? = layerSpecifier {return v}
      return Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer()
    }
    set {layerSpecifier = .adminLayer(newValue)}
  }

  public var rtdsLayer: Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer {
    get {
      if case .rtdsLayer(let v)? = layerSpecifier {return v}
      return Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer()
    }
    set {layerSpecifier = .rtdsLayer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_LayerSpecifier: Equatable {
    /// :ref:`Static runtime <config_runtime_bootstrap>` layer.
    /// This follows the :ref:`runtime protobuf JSON representation encoding
    /// <config_runtime_proto_json>`. Unlike static xDS resources, this static
    /// layer is overridable by later layers in the runtime virtual filesystem.
    case staticLayer(SwiftProtobuf.Google_Protobuf_Struct)
    case diskLayer(Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer)
    case adminLayer(Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer)
    case rtdsLayer(Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.OneOf_LayerSpecifier, rhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.OneOf_LayerSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.staticLayer, .staticLayer): return {
        guard case .staticLayer(let l) = lhs, case .staticLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diskLayer, .diskLayer): return {
        guard case .diskLayer(let l) = lhs, case .diskLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.adminLayer, .adminLayer): return {
        guard case .adminLayer(let l) = lhs, case .adminLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rtdsLayer, .rtdsLayer): return {
        guard case .rtdsLayer(let l) = lhs, case .rtdsLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// :ref:`Disk runtime <config_runtime_local_disk>` layer.
  public struct DiskLayer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The implementation assumes that the file system tree is accessed via a
    /// symbolic link. An atomic link swap is used when a new tree should be
    /// switched to. This parameter specifies the path to the symbolic link.
    /// Envoy will watch the location for changes and reload the file system tree
    /// when they happen. See documentation on runtime :ref:`atomicity
    /// <config_runtime_atomicity>` for further details on how reloads are
    /// treated.
    public var symlinkRoot: String = String()

    /// Specifies the subdirectory to load within the root directory. This is
    /// useful if multiple systems share the same delivery mechanism. Envoy
    /// configuration elements can be contained in a dedicated subdirectory.
    public var subdirectory: String = String()

    /// :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
    /// service cluster to the path under symlink root.
    public var appendServiceCluster: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// :ref:`Admin console runtime <config_runtime_admin>` layer.
  public struct AdminLayer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer.
  public struct RtdsLayer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource to subscribe to at *rtds_config* for the RTDS layer.
    public var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    /// Resource locator for RTDS layer. This is mutually exclusive to *name*.
    /// [#not-implemented-hide:]
    public var rtdsResourceLocator: Udpa_Core_V1_ResourceLocator {
      get {return _storage._rtdsResourceLocator ?? Udpa_Core_V1_ResourceLocator()}
      set {_uniqueStorage()._rtdsResourceLocator = newValue}
    }
    /// Returns true if `rtdsResourceLocator` has been explicitly set.
    public var hasRtdsResourceLocator: Bool {return _storage._rtdsResourceLocator != nil}
    /// Clears the value of `rtdsResourceLocator`. Subsequent reads from it will return its default value.
    public mutating func clearRtdsResourceLocator() {_uniqueStorage()._rtdsResourceLocator = nil}

    /// RTDS configuration source.
    public var rtdsConfig: Envoy_Config_Core_V3_ConfigSource {
      get {return _storage._rtdsConfig ?? Envoy_Config_Core_V3_ConfigSource()}
      set {_uniqueStorage()._rtdsConfig = newValue}
    }
    /// Returns true if `rtdsConfig` has been explicitly set.
    public var hasRtdsConfig: Bool {return _storage._rtdsConfig != nil}
    /// Clears the value of `rtdsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearRtdsConfig() {_uniqueStorage()._rtdsConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}
}

/// Runtime :ref:`configuration overview <config_runtime>`.
public struct Envoy_Config_Bootstrap_V3_LayeredRuntime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
  /// such that later layers in the list overlay earlier entries.
  public var layers: [Envoy_Config_Bootstrap_V3_RuntimeLayer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.bootstrap.v3"

extension Envoy_Config_Bootstrap_V3_Bootstrap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bootstrap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    26: .standard(proto: "node_context_params"),
    2: .standard(proto: "static_resources"),
    3: .standard(proto: "dynamic_resources"),
    4: .standard(proto: "cluster_manager"),
    14: .standard(proto: "hds_config"),
    5: .standard(proto: "flags_path"),
    6: .standard(proto: "stats_sinks"),
    13: .standard(proto: "stats_config"),
    7: .standard(proto: "stats_flush_interval"),
    8: .same(proto: "watchdog"),
    27: .same(proto: "watchdogs"),
    9: .same(proto: "tracing"),
    17: .standard(proto: "layered_runtime"),
    12: .same(proto: "admin"),
    15: .standard(proto: "overload_manager"),
    16: .standard(proto: "enable_dispatcher_stats"),
    18: .standard(proto: "header_prefix"),
    19: .standard(proto: "stats_server_version_override"),
    20: .standard(proto: "use_tcp_for_dns_lookups"),
    21: .standard(proto: "bootstrap_extensions"),
    22: .standard(proto: "config_sources"),
    23: .standard(proto: "default_config_source"),
    24: .standard(proto: "default_socket_interface"),
    25: .standard(proto: "certificate_provider_instances"),
  ]

  fileprivate class _StorageClass {
    var _node: Envoy_Config_Core_V3_Node? = nil
    var _nodeContextParams: [String] = []
    var _staticResources: Envoy_Config_Bootstrap_V3_Bootstrap.StaticResources? = nil
    var _dynamicResources: Envoy_Config_Bootstrap_V3_Bootstrap.DynamicResources? = nil
    var _clusterManager: Envoy_Config_Bootstrap_V3_ClusterManager? = nil
    var _hdsConfig: Envoy_Config_Core_V3_ApiConfigSource? = nil
    var _flagsPath: String = String()
    var _statsSinks: [Envoy_Config_Metrics_V3_StatsSink] = []
    var _statsConfig: Envoy_Config_Metrics_V3_StatsConfig? = nil
    var _statsFlushInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _watchdog: Envoy_Config_Bootstrap_V3_Watchdog? = nil
    var _watchdogs: Envoy_Config_Bootstrap_V3_Watchdogs? = nil
    var _tracing: Envoy_Config_Trace_V3_Tracing? = nil
    var _layeredRuntime: Envoy_Config_Bootstrap_V3_LayeredRuntime? = nil
    var _admin: Envoy_Config_Bootstrap_V3_Admin? = nil
    var _overloadManager: Envoy_Config_Overload_V3_OverloadManager? = nil
    var _enableDispatcherStats: Bool = false
    var _headerPrefix: String = String()
    var _statsServerVersionOverride: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _useTcpForDnsLookups: Bool = false
    var _bootstrapExtensions: [Envoy_Config_Core_V3_TypedExtensionConfig] = []
    var _configSources: [Envoy_Config_Core_V3_ConfigSource] = []
    var _defaultConfigSource: Envoy_Config_Core_V3_ConfigSource? = nil
    var _defaultSocketInterface: String = String()
    var _certificateProviderInstances: Dictionary<String,Envoy_Config_Core_V3_TypedExtensionConfig> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _node = source._node
      _nodeContextParams = source._nodeContextParams
      _staticResources = source._staticResources
      _dynamicResources = source._dynamicResources
      _clusterManager = source._clusterManager
      _hdsConfig = source._hdsConfig
      _flagsPath = source._flagsPath
      _statsSinks = source._statsSinks
      _statsConfig = source._statsConfig
      _statsFlushInterval = source._statsFlushInterval
      _watchdog = source._watchdog
      _watchdogs = source._watchdogs
      _tracing = source._tracing
      _layeredRuntime = source._layeredRuntime
      _admin = source._admin
      _overloadManager = source._overloadManager
      _enableDispatcherStats = source._enableDispatcherStats
      _headerPrefix = source._headerPrefix
      _statsServerVersionOverride = source._statsServerVersionOverride
      _useTcpForDnsLookups = source._useTcpForDnsLookups
      _bootstrapExtensions = source._bootstrapExtensions
      _configSources = source._configSources
      _defaultConfigSource = source._defaultConfigSource
      _defaultSocketInterface = source._defaultSocketInterface
      _certificateProviderInstances = source._certificateProviderInstances
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._node) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._staticResources) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dynamicResources) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clusterManager) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._flagsPath) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._statsSinks) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._statsFlushInterval) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._watchdog) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tracing) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._admin) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._statsConfig) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._hdsConfig) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._overloadManager) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._enableDispatcherStats) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._layeredRuntime) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._headerPrefix) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._statsServerVersionOverride) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._useTcpForDnsLookups) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._bootstrapExtensions) }()
        case 22: try { try decoder.decodeRepeatedMessageField(value: &_storage._configSources) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._defaultConfigSource) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._defaultSocketInterface) }()
        case 25: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Config_Core_V3_TypedExtensionConfig>.self, value: &_storage._certificateProviderInstances) }()
        case 26: try { try decoder.decodeRepeatedStringField(value: &_storage._nodeContextParams) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._watchdogs) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._node {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._staticResources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._dynamicResources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clusterManager {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._flagsPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._flagsPath, fieldNumber: 5)
      }
      if !_storage._statsSinks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._statsSinks, fieldNumber: 6)
      }
      if let v = _storage._statsFlushInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._watchdog {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._tracing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._admin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._statsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._hdsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._overloadManager {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._enableDispatcherStats != false {
        try visitor.visitSingularBoolField(value: _storage._enableDispatcherStats, fieldNumber: 16)
      }
      if let v = _storage._layeredRuntime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._headerPrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._headerPrefix, fieldNumber: 18)
      }
      if let v = _storage._statsServerVersionOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if _storage._useTcpForDnsLookups != false {
        try visitor.visitSingularBoolField(value: _storage._useTcpForDnsLookups, fieldNumber: 20)
      }
      if !_storage._bootstrapExtensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._bootstrapExtensions, fieldNumber: 21)
      }
      if !_storage._configSources.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._configSources, fieldNumber: 22)
      }
      if let v = _storage._defaultConfigSource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if !_storage._defaultSocketInterface.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultSocketInterface, fieldNumber: 24)
      }
      if !_storage._certificateProviderInstances.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Config_Core_V3_TypedExtensionConfig>.self, value: _storage._certificateProviderInstances, fieldNumber: 25)
      }
      if !_storage._nodeContextParams.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._nodeContextParams, fieldNumber: 26)
      }
      if let v = _storage._watchdogs {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Bootstrap, rhs: Envoy_Config_Bootstrap_V3_Bootstrap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._node != rhs_storage._node {return false}
        if _storage._nodeContextParams != rhs_storage._nodeContextParams {return false}
        if _storage._staticResources != rhs_storage._staticResources {return false}
        if _storage._dynamicResources != rhs_storage._dynamicResources {return false}
        if _storage._clusterManager != rhs_storage._clusterManager {return false}
        if _storage._hdsConfig != rhs_storage._hdsConfig {return false}
        if _storage._flagsPath != rhs_storage._flagsPath {return false}
        if _storage._statsSinks != rhs_storage._statsSinks {return false}
        if _storage._statsConfig != rhs_storage._statsConfig {return false}
        if _storage._statsFlushInterval != rhs_storage._statsFlushInterval {return false}
        if _storage._watchdog != rhs_storage._watchdog {return false}
        if _storage._watchdogs != rhs_storage._watchdogs {return false}
        if _storage._tracing != rhs_storage._tracing {return false}
        if _storage._layeredRuntime != rhs_storage._layeredRuntime {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._overloadManager != rhs_storage._overloadManager {return false}
        if _storage._enableDispatcherStats != rhs_storage._enableDispatcherStats {return false}
        if _storage._headerPrefix != rhs_storage._headerPrefix {return false}
        if _storage._statsServerVersionOverride != rhs_storage._statsServerVersionOverride {return false}
        if _storage._useTcpForDnsLookups != rhs_storage._useTcpForDnsLookups {return false}
        if _storage._bootstrapExtensions != rhs_storage._bootstrapExtensions {return false}
        if _storage._configSources != rhs_storage._configSources {return false}
        if _storage._defaultConfigSource != rhs_storage._defaultConfigSource {return false}
        if _storage._defaultSocketInterface != rhs_storage._defaultSocketInterface {return false}
        if _storage._certificateProviderInstances != rhs_storage._certificateProviderInstances {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Bootstrap.StaticResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_Bootstrap.protoMessageName + ".StaticResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listeners"),
    2: .same(proto: "clusters"),
    3: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listeners) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listeners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listeners, fieldNumber: 1)
    }
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 2)
    }
    if !self.secrets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secrets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Bootstrap.StaticResources, rhs: Envoy_Config_Bootstrap_V3_Bootstrap.StaticResources) -> Bool {
    if lhs.listeners != rhs.listeners {return false}
    if lhs.clusters != rhs.clusters {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Bootstrap.DynamicResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_Bootstrap.protoMessageName + ".DynamicResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lds_config"),
    5: .standard(proto: "lds_resources_locator"),
    2: .standard(proto: "cds_config"),
    6: .standard(proto: "cds_resources_locator"),
    3: .standard(proto: "ads_config"),
  ]

  fileprivate class _StorageClass {
    var _ldsConfig: Envoy_Config_Core_V3_ConfigSource? = nil
    var _ldsResourcesLocator: Udpa_Core_V1_ResourceLocator? = nil
    var _cdsConfig: Envoy_Config_Core_V3_ConfigSource? = nil
    var _cdsResourcesLocator: Udpa_Core_V1_ResourceLocator? = nil
    var _adsConfig: Envoy_Config_Core_V3_ApiConfigSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ldsConfig = source._ldsConfig
      _ldsResourcesLocator = source._ldsResourcesLocator
      _cdsConfig = source._cdsConfig
      _cdsResourcesLocator = source._cdsResourcesLocator
      _adsConfig = source._adsConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._ldsConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cdsConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._adsConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._ldsResourcesLocator) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._cdsResourcesLocator) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ldsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._cdsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._adsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._ldsResourcesLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._cdsResourcesLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Bootstrap.DynamicResources, rhs: Envoy_Config_Bootstrap_V3_Bootstrap.DynamicResources) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ldsConfig != rhs_storage._ldsConfig {return false}
        if _storage._ldsResourcesLocator != rhs_storage._ldsResourcesLocator {return false}
        if _storage._cdsConfig != rhs_storage._cdsConfig {return false}
        if _storage._cdsResourcesLocator != rhs_storage._cdsResourcesLocator {return false}
        if _storage._adsConfig != rhs_storage._adsConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Admin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Admin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_log_path"),
    2: .standard(proto: "profile_path"),
    3: .same(proto: "address"),
    4: .standard(proto: "socket_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessLogPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.profilePath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.socketOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLogPath.isEmpty {
      try visitor.visitSingularStringField(value: self.accessLogPath, fieldNumber: 1)
    }
    if !self.profilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePath, fieldNumber: 2)
    }
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.socketOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.socketOptions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Admin, rhs: Envoy_Config_Bootstrap_V3_Admin) -> Bool {
    if lhs.accessLogPath != rhs.accessLogPath {return false}
    if lhs.profilePath != rhs.profilePath {return false}
    if lhs._address != rhs._address {return false}
    if lhs.socketOptions != rhs.socketOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_ClusterManager: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterManager"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_cluster_name"),
    2: .standard(proto: "outlier_detection"),
    3: .standard(proto: "upstream_bind_config"),
    4: .standard(proto: "load_stats_config"),
  ]

  fileprivate class _StorageClass {
    var _localClusterName: String = String()
    var _outlierDetection: Envoy_Config_Bootstrap_V3_ClusterManager.OutlierDetection? = nil
    var _upstreamBindConfig: Envoy_Config_Core_V3_BindConfig? = nil
    var _loadStatsConfig: Envoy_Config_Core_V3_ApiConfigSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localClusterName = source._localClusterName
      _outlierDetection = source._outlierDetection
      _upstreamBindConfig = source._upstreamBindConfig
      _loadStatsConfig = source._loadStatsConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._localClusterName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._outlierDetection) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._upstreamBindConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._loadStatsConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._localClusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localClusterName, fieldNumber: 1)
      }
      if let v = _storage._outlierDetection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._upstreamBindConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._loadStatsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_ClusterManager, rhs: Envoy_Config_Bootstrap_V3_ClusterManager) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localClusterName != rhs_storage._localClusterName {return false}
        if _storage._outlierDetection != rhs_storage._outlierDetection {return false}
        if _storage._upstreamBindConfig != rhs_storage._upstreamBindConfig {return false}
        if _storage._loadStatsConfig != rhs_storage._loadStatsConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_ClusterManager.OutlierDetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_ClusterManager.protoMessageName + ".OutlierDetection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_log_path"),
    2: .standard(proto: "event_service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventLogPath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._eventService) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventLogPath.isEmpty {
      try visitor.visitSingularStringField(value: self.eventLogPath, fieldNumber: 1)
    }
    if let v = self._eventService {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_ClusterManager.OutlierDetection, rhs: Envoy_Config_Bootstrap_V3_ClusterManager.OutlierDetection) -> Bool {
    if lhs.eventLogPath != rhs.eventLogPath {return false}
    if lhs._eventService != rhs._eventService {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Watchdogs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Watchdogs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "main_thread_watchdog"),
    2: .standard(proto: "worker_watchdog"),
  ]

  fileprivate class _StorageClass {
    var _mainThreadWatchdog: Envoy_Config_Bootstrap_V3_Watchdog? = nil
    var _workerWatchdog: Envoy_Config_Bootstrap_V3_Watchdog? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _mainThreadWatchdog = source._mainThreadWatchdog
      _workerWatchdog = source._workerWatchdog
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._mainThreadWatchdog) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workerWatchdog) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._mainThreadWatchdog {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._workerWatchdog {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Watchdogs, rhs: Envoy_Config_Bootstrap_V3_Watchdogs) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mainThreadWatchdog != rhs_storage._mainThreadWatchdog {return false}
        if _storage._workerWatchdog != rhs_storage._workerWatchdog {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Watchdog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Watchdog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "actions"),
    1: .standard(proto: "miss_timeout"),
    2: .standard(proto: "megamiss_timeout"),
    3: .standard(proto: "kill_timeout"),
    6: .standard(proto: "max_kill_timeout_jitter"),
    4: .standard(proto: "multikill_timeout"),
    5: .standard(proto: "multikill_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._missTimeout) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._megamissTimeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._killTimeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._multikillTimeout) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._multikillThreshold) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._maxKillTimeoutJitter) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._missTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._megamissTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._killTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._multikillTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._multikillThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._maxKillTimeoutJitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Watchdog, rhs: Envoy_Config_Bootstrap_V3_Watchdog) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs._missTimeout != rhs._missTimeout {return false}
    if lhs._megamissTimeout != rhs._megamissTimeout {return false}
    if lhs._killTimeout != rhs._killTimeout {return false}
    if lhs._maxKillTimeoutJitter != rhs._maxKillTimeoutJitter {return false}
    if lhs._multikillTimeout != rhs._multikillTimeout {return false}
    if lhs._multikillThreshold != rhs._multikillThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_Watchdog.protoMessageName + ".WatchdogAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.event != .unknown {
      try visitor.visitSingularEnumField(value: self.event, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction, rhs: Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_Watchdog.WatchdogAction.WatchdogEvent: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "KILL"),
    2: .same(proto: "MULTIKILL"),
    3: .same(proto: "MEGAMISS"),
    4: .same(proto: "MISS"),
  ]
}

extension Envoy_Config_Bootstrap_V3_Runtime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Runtime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symlink_root"),
    2: .same(proto: "subdirectory"),
    3: .standard(proto: "override_subdirectory"),
    4: .same(proto: "base"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symlinkRoot) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subdirectory) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.overrideSubdirectory) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symlinkRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.symlinkRoot, fieldNumber: 1)
    }
    if !self.subdirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.subdirectory, fieldNumber: 2)
    }
    if !self.overrideSubdirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.overrideSubdirectory, fieldNumber: 3)
    }
    if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_Runtime, rhs: Envoy_Config_Bootstrap_V3_Runtime) -> Bool {
    if lhs.symlinkRoot != rhs.symlinkRoot {return false}
    if lhs.subdirectory != rhs.subdirectory {return false}
    if lhs.overrideSubdirectory != rhs.overrideSubdirectory {return false}
    if lhs._base != rhs._base {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_RuntimeLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "static_layer"),
    3: .standard(proto: "disk_layer"),
    4: .standard(proto: "admin_layer"),
    5: .standard(proto: "rtds_layer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .staticLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .staticLayer(v)}
      }()
      case 3: try {
        var v: Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .diskLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .diskLayer(v)}
      }()
      case 4: try {
        var v: Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .adminLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .adminLayer(v)}
      }()
      case 5: try {
        var v: Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .rtdsLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .rtdsLayer(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.layerSpecifier {
    case .staticLayer?: try {
      guard case .staticLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .diskLayer?: try {
      guard case .diskLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .adminLayer?: try {
      guard case .adminLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rtdsLayer?: try {
      guard case .rtdsLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_RuntimeLayer, rhs: Envoy_Config_Bootstrap_V3_RuntimeLayer) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.layerSpecifier != rhs.layerSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_RuntimeLayer.protoMessageName + ".DiskLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symlink_root"),
    3: .same(proto: "subdirectory"),
    2: .standard(proto: "append_service_cluster"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symlinkRoot) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.appendServiceCluster) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subdirectory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symlinkRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.symlinkRoot, fieldNumber: 1)
    }
    if self.appendServiceCluster != false {
      try visitor.visitSingularBoolField(value: self.appendServiceCluster, fieldNumber: 2)
    }
    if !self.subdirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.subdirectory, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer, rhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.DiskLayer) -> Bool {
    if lhs.symlinkRoot != rhs.symlinkRoot {return false}
    if lhs.subdirectory != rhs.subdirectory {return false}
    if lhs.appendServiceCluster != rhs.appendServiceCluster {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_RuntimeLayer.protoMessageName + ".AdminLayer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer, rhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.AdminLayer) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V3_RuntimeLayer.protoMessageName + ".RtdsLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "rtds_resource_locator"),
    2: .standard(proto: "rtds_config"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _rtdsResourceLocator: Udpa_Core_V1_ResourceLocator? = nil
    var _rtdsConfig: Envoy_Config_Core_V3_ConfigSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _rtdsResourceLocator = source._rtdsResourceLocator
      _rtdsConfig = source._rtdsConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._rtdsConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._rtdsResourceLocator) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._rtdsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._rtdsResourceLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer, rhs: Envoy_Config_Bootstrap_V3_RuntimeLayer.RtdsLayer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._rtdsResourceLocator != rhs_storage._rtdsResourceLocator {return false}
        if _storage._rtdsConfig != rhs_storage._rtdsConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V3_LayeredRuntime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LayeredRuntime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V3_LayeredRuntime, rhs: Envoy_Config_Bootstrap_V3_LayeredRuntime) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

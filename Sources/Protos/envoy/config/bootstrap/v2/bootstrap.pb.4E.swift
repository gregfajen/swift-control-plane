// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/bootstrap/v2/bootstrap.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Bootstrap :ref:`configuration overview <config_overview_bootstrap>`.
/// [#next-free-field: 21]
public struct Envoy_Config_Bootstrap_V2_Bootstrap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Node identity to present to the management server and for instance
  /// identification purposes (e.g. in generated headers).
  public var node: Envoy_Api_V2_Core_Node {
    get {return _storage._node ?? Envoy_Api_V2_Core_Node()}
    set {_uniqueStorage()._node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return _storage._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {_uniqueStorage()._node = nil}

  /// Statically specified resources.
  public var staticResources: Envoy_Config_Bootstrap_V2_Bootstrap.StaticResources {
    get {return _storage._staticResources ?? Envoy_Config_Bootstrap_V2_Bootstrap.StaticResources()}
    set {_uniqueStorage()._staticResources = newValue}
  }
  /// Returns true if `staticResources` has been explicitly set.
  public var hasStaticResources: Bool {return _storage._staticResources != nil}
  /// Clears the value of `staticResources`. Subsequent reads from it will return its default value.
  public mutating func clearStaticResources() {_uniqueStorage()._staticResources = nil}

  /// xDS configuration sources.
  public var dynamicResources: Envoy_Config_Bootstrap_V2_Bootstrap.DynamicResources {
    get {return _storage._dynamicResources ?? Envoy_Config_Bootstrap_V2_Bootstrap.DynamicResources()}
    set {_uniqueStorage()._dynamicResources = newValue}
  }
  /// Returns true if `dynamicResources` has been explicitly set.
  public var hasDynamicResources: Bool {return _storage._dynamicResources != nil}
  /// Clears the value of `dynamicResources`. Subsequent reads from it will return its default value.
  public mutating func clearDynamicResources() {_uniqueStorage()._dynamicResources = nil}

  /// Configuration for the cluster manager which owns all upstream clusters
  /// within the server.
  public var clusterManager: Envoy_Config_Bootstrap_V2_ClusterManager {
    get {return _storage._clusterManager ?? Envoy_Config_Bootstrap_V2_ClusterManager()}
    set {_uniqueStorage()._clusterManager = newValue}
  }
  /// Returns true if `clusterManager` has been explicitly set.
  public var hasClusterManager: Bool {return _storage._clusterManager != nil}
  /// Clears the value of `clusterManager`. Subsequent reads from it will return its default value.
  public mutating func clearClusterManager() {_uniqueStorage()._clusterManager = nil}

  /// Health discovery service config option.
  /// (:ref:`core.ApiConfigSource <envoy_api_msg_core.ApiConfigSource>`)
  public var hdsConfig: Envoy_Api_V2_Core_ApiConfigSource {
    get {return _storage._hdsConfig ?? Envoy_Api_V2_Core_ApiConfigSource()}
    set {_uniqueStorage()._hdsConfig = newValue}
  }
  /// Returns true if `hdsConfig` has been explicitly set.
  public var hasHdsConfig: Bool {return _storage._hdsConfig != nil}
  /// Clears the value of `hdsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearHdsConfig() {_uniqueStorage()._hdsConfig = nil}

  /// Optional file system path to search for startup flag files.
  public var flagsPath: String {
    get {return _storage._flagsPath}
    set {_uniqueStorage()._flagsPath = newValue}
  }

  /// Optional set of stats sinks.
  public var statsSinks: [Envoy_Config_Metrics_V2_StatsSink] {
    get {return _storage._statsSinks}
    set {_uniqueStorage()._statsSinks = newValue}
  }

  /// Configuration for internal processing of stats.
  public var statsConfig: Envoy_Config_Metrics_V2_StatsConfig {
    get {return _storage._statsConfig ?? Envoy_Config_Metrics_V2_StatsConfig()}
    set {_uniqueStorage()._statsConfig = newValue}
  }
  /// Returns true if `statsConfig` has been explicitly set.
  public var hasStatsConfig: Bool {return _storage._statsConfig != nil}
  /// Clears the value of `statsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearStatsConfig() {_uniqueStorage()._statsConfig = nil}

  /// Optional duration between flushes to configured stats sinks. For
  /// performance reasons Envoy latches counters and only flushes counters and
  /// gauges at a periodic interval. If not specified the default is 5000ms (5
  /// seconds).
  /// Duration must be at least 1ms and at most 5 min.
  public var statsFlushInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._statsFlushInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._statsFlushInterval = newValue}
  }
  /// Returns true if `statsFlushInterval` has been explicitly set.
  public var hasStatsFlushInterval: Bool {return _storage._statsFlushInterval != nil}
  /// Clears the value of `statsFlushInterval`. Subsequent reads from it will return its default value.
  public mutating func clearStatsFlushInterval() {_uniqueStorage()._statsFlushInterval = nil}

  /// Optional watchdog configuration.
  public var watchdog: Envoy_Config_Bootstrap_V2_Watchdog {
    get {return _storage._watchdog ?? Envoy_Config_Bootstrap_V2_Watchdog()}
    set {_uniqueStorage()._watchdog = newValue}
  }
  /// Returns true if `watchdog` has been explicitly set.
  public var hasWatchdog: Bool {return _storage._watchdog != nil}
  /// Clears the value of `watchdog`. Subsequent reads from it will return its default value.
  public mutating func clearWatchdog() {_uniqueStorage()._watchdog = nil}

  /// Configuration for an external tracing provider.
  ///
  /// .. attention::
  ///  This field has been deprecated in favor of :ref:`HttpConnectionManager.Tracing.provider
  ///  <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.Tracing.provider>`.
  public var tracing: Envoy_Config_Trace_V2_Tracing {
    get {return _storage._tracing ?? Envoy_Config_Trace_V2_Tracing()}
    set {_uniqueStorage()._tracing = newValue}
  }
  /// Returns true if `tracing` has been explicitly set.
  public var hasTracing: Bool {return _storage._tracing != nil}
  /// Clears the value of `tracing`. Subsequent reads from it will return its default value.
  public mutating func clearTracing() {_uniqueStorage()._tracing = nil}

  /// Configuration for the runtime configuration provider (deprecated). If not
  /// specified, a “null” provider will be used which will result in all defaults
  /// being used.
  public var runtime: Envoy_Config_Bootstrap_V2_Runtime {
    get {return _storage._runtime ?? Envoy_Config_Bootstrap_V2_Runtime()}
    set {_uniqueStorage()._runtime = newValue}
  }
  /// Returns true if `runtime` has been explicitly set.
  public var hasRuntime: Bool {return _storage._runtime != nil}
  /// Clears the value of `runtime`. Subsequent reads from it will return its default value.
  public mutating func clearRuntime() {_uniqueStorage()._runtime = nil}

  /// Configuration for the runtime configuration provider. If not
  /// specified, a “null” provider will be used which will result in all defaults
  /// being used.
  public var layeredRuntime: Envoy_Config_Bootstrap_V2_LayeredRuntime {
    get {return _storage._layeredRuntime ?? Envoy_Config_Bootstrap_V2_LayeredRuntime()}
    set {_uniqueStorage()._layeredRuntime = newValue}
  }
  /// Returns true if `layeredRuntime` has been explicitly set.
  public var hasLayeredRuntime: Bool {return _storage._layeredRuntime != nil}
  /// Clears the value of `layeredRuntime`. Subsequent reads from it will return its default value.
  public mutating func clearLayeredRuntime() {_uniqueStorage()._layeredRuntime = nil}

  /// Configuration for the local administration HTTP server.
  public var admin: Envoy_Config_Bootstrap_V2_Admin {
    get {return _storage._admin ?? Envoy_Config_Bootstrap_V2_Admin()}
    set {_uniqueStorage()._admin = newValue}
  }
  /// Returns true if `admin` has been explicitly set.
  public var hasAdmin: Bool {return _storage._admin != nil}
  /// Clears the value of `admin`. Subsequent reads from it will return its default value.
  public mutating func clearAdmin() {_uniqueStorage()._admin = nil}

  /// Optional overload manager configuration.
  public var overloadManager: Envoy_Config_Overload_V2alpha_OverloadManager {
    get {return _storage._overloadManager ?? Envoy_Config_Overload_V2alpha_OverloadManager()}
    set {_uniqueStorage()._overloadManager = newValue}
  }
  /// Returns true if `overloadManager` has been explicitly set.
  public var hasOverloadManager: Bool {return _storage._overloadManager != nil}
  /// Clears the value of `overloadManager`. Subsequent reads from it will return its default value.
  public mutating func clearOverloadManager() {_uniqueStorage()._overloadManager = nil}

  /// Enable :ref:`stats for event dispatcher <operations_performance>`, defaults to false.
  /// Note that this records a value for each iteration of the event loop on every thread. This
  /// should normally be minimal overhead, but when using
  /// :ref:`statsd <envoy_api_msg_config.metrics.v2.StatsdSink>`, it will send each observed value
  /// over the wire individually because the statsd protocol doesn't have any way to represent a
  /// histogram summary. Be aware that this can be a very large volume of data.
  public var enableDispatcherStats: Bool {
    get {return _storage._enableDispatcherStats}
    set {_uniqueStorage()._enableDispatcherStats = newValue}
  }

  /// Optional string which will be used in lieu of x-envoy in prefixing headers.
  ///
  /// For example, if this string is present and set to X-Foo, then x-envoy-retry-on will be
  /// transformed into x-foo-retry-on etc.
  ///
  /// Note this applies to the headers Envoy will generate, the headers Envoy will sanitize, and the
  /// headers Envoy will trust for core code and core extensions only. Be VERY careful making
  /// changes to this string, especially in multi-layer Envoy deployments or deployments using
  /// extensions which are not upstream.
  public var headerPrefix: String {
    get {return _storage._headerPrefix}
    set {_uniqueStorage()._headerPrefix = newValue}
  }

  /// Optional proxy version which will be used to set the value of :ref:`server.version statistic
  /// <server_statistics>` if specified. Envoy will not process this value, it will be sent as is to
  /// :ref:`stats sinks <envoy_api_msg_config.metrics.v2.StatsSink>`.
  public var statsServerVersionOverride: SwiftProtobuf.Google_Protobuf_UInt64Value {
    get {return _storage._statsServerVersionOverride ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
    set {_uniqueStorage()._statsServerVersionOverride = newValue}
  }
  /// Returns true if `statsServerVersionOverride` has been explicitly set.
  public var hasStatsServerVersionOverride: Bool {return _storage._statsServerVersionOverride != nil}
  /// Clears the value of `statsServerVersionOverride`. Subsequent reads from it will return its default value.
  public mutating func clearStatsServerVersionOverride() {_uniqueStorage()._statsServerVersionOverride = nil}

  /// Always use TCP queries instead of UDP queries for DNS lookups.
  /// This may be overridden on a per-cluster basis in cds_config,
  /// when :ref:`dns_resolvers <envoy_api_field_Cluster.dns_resolvers>` and
  /// :ref:`use_tcp_for_dns_lookups <envoy_api_field_Cluster.use_tcp_for_dns_lookups>` are
  /// specified.
  /// Setting this value causes failure if the
  /// ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
  /// server startup. Apple' API only uses UDP for DNS resolution.
  public var useTcpForDnsLookups: Bool {
    get {return _storage._useTcpForDnsLookups}
    set {_uniqueStorage()._useTcpForDnsLookups = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct StaticResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Static :ref:`Listeners <envoy_api_msg_Listener>`. These listeners are
    /// available regardless of LDS configuration.
    public var listeners: [Envoy_Api_V2_Listener] = []

    /// If a network based configuration source is specified for :ref:`cds_config
    /// <envoy_api_field_config.bootstrap.v2.Bootstrap.DynamicResources.cds_config>`, it's necessary
    /// to have some initial cluster definitions available to allow Envoy to know
    /// how to speak to the management server. These cluster definitions may not
    /// use :ref:`EDS <arch_overview_dynamic_config_eds>` (i.e. they should be static
    /// IP or DNS-based).
    public var clusters: [Envoy_Api_V2_Cluster] = []

    /// These static secrets can be used by :ref:`SdsSecretConfig
    /// <envoy_api_msg_auth.SdsSecretConfig>`
    public var secrets: [Envoy_Api_V2_Auth_Secret] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct DynamicResources {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// All :ref:`Listeners <envoy_api_msg_Listener>` are provided by a single
    /// :ref:`LDS <arch_overview_dynamic_config_lds>` configuration source.
    public var ldsConfig: Envoy_Api_V2_Core_ConfigSource {
      get {return _storage._ldsConfig ?? Envoy_Api_V2_Core_ConfigSource()}
      set {_uniqueStorage()._ldsConfig = newValue}
    }
    /// Returns true if `ldsConfig` has been explicitly set.
    public var hasLdsConfig: Bool {return _storage._ldsConfig != nil}
    /// Clears the value of `ldsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearLdsConfig() {_uniqueStorage()._ldsConfig = nil}

    /// All post-bootstrap :ref:`Cluster <envoy_api_msg_Cluster>` definitions are
    /// provided by a single :ref:`CDS <arch_overview_dynamic_config_cds>`
    /// configuration source.
    public var cdsConfig: Envoy_Api_V2_Core_ConfigSource {
      get {return _storage._cdsConfig ?? Envoy_Api_V2_Core_ConfigSource()}
      set {_uniqueStorage()._cdsConfig = newValue}
    }
    /// Returns true if `cdsConfig` has been explicitly set.
    public var hasCdsConfig: Bool {return _storage._cdsConfig != nil}
    /// Clears the value of `cdsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearCdsConfig() {_uniqueStorage()._cdsConfig = nil}

    /// A single :ref:`ADS <config_overview_ads>` source may be optionally
    /// specified. This must have :ref:`api_type
    /// <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
    /// <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`. Only
    /// :ref:`ConfigSources <envoy_api_msg_core.ConfigSource>` that have
    /// the :ref:`ads <envoy_api_field_core.ConfigSource.ads>` field set will be
    /// streamed on the ADS channel.
    public var adsConfig: Envoy_Api_V2_Core_ApiConfigSource {
      get {return _storage._adsConfig ?? Envoy_Api_V2_Core_ApiConfigSource()}
      set {_uniqueStorage()._adsConfig = newValue}
    }
    /// Returns true if `adsConfig` has been explicitly set.
    public var hasAdsConfig: Bool {return _storage._adsConfig != nil}
    /// Clears the value of `adsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearAdsConfig() {_uniqueStorage()._adsConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Administration interface :ref:`operations documentation
/// <operations_admin_interface>`.
public struct Envoy_Config_Bootstrap_V2_Admin {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path to write the access log for the administration server. If no
  /// access log is desired specify ‘/dev/null’. This is only required if
  /// :ref:`address <envoy_api_field_config.bootstrap.v2.Admin.address>` is set.
  public var accessLogPath: String = String()

  /// The cpu profiler output path for the administration server. If no profile
  /// path is specified, the default is ‘/var/log/envoy/envoy.prof’.
  public var profilePath: String = String()

  /// The TCP address that the administration server will listen on.
  /// If not specified, Envoy will not start an administration server.
  public var address: Envoy_Api_V2_Core_Address {
    get {return _address ?? Envoy_Api_V2_Core_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  /// Additional socket options that may not be present in Envoy source code or
  /// precompiled binaries.
  public var socketOptions: [Envoy_Api_V2_Core_SocketOption] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Envoy_Api_V2_Core_Address? = nil
}

/// Cluster manager :ref:`architecture overview <arch_overview_cluster_manager>`.
public struct Envoy_Config_Bootstrap_V2_ClusterManager {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the local cluster (i.e., the cluster that owns the Envoy running
  /// this configuration). In order to enable :ref:`zone aware routing
  /// <arch_overview_load_balancing_zone_aware_routing>` this option must be set.
  /// If *local_cluster_name* is defined then :ref:`clusters
  /// <envoy_api_msg_Cluster>` must be defined in the :ref:`Bootstrap
  /// static cluster resources
  /// <envoy_api_field_config.bootstrap.v2.Bootstrap.StaticResources.clusters>`. This is unrelated to
  /// the :option:`--service-cluster` option which does not `affect zone aware
  /// routing <https://github.com/envoyproxy/envoy/issues/774>`_.
  public var localClusterName: String {
    get {return _storage._localClusterName}
    set {_uniqueStorage()._localClusterName = newValue}
  }

  /// Optional global configuration for outlier detection.
  public var outlierDetection: Envoy_Config_Bootstrap_V2_ClusterManager.OutlierDetection {
    get {return _storage._outlierDetection ?? Envoy_Config_Bootstrap_V2_ClusterManager.OutlierDetection()}
    set {_uniqueStorage()._outlierDetection = newValue}
  }
  /// Returns true if `outlierDetection` has been explicitly set.
  public var hasOutlierDetection: Bool {return _storage._outlierDetection != nil}
  /// Clears the value of `outlierDetection`. Subsequent reads from it will return its default value.
  public mutating func clearOutlierDetection() {_uniqueStorage()._outlierDetection = nil}

  /// Optional configuration used to bind newly established upstream connections.
  /// This may be overridden on a per-cluster basis by upstream_bind_config in the cds_config.
  public var upstreamBindConfig: Envoy_Api_V2_Core_BindConfig {
    get {return _storage._upstreamBindConfig ?? Envoy_Api_V2_Core_BindConfig()}
    set {_uniqueStorage()._upstreamBindConfig = newValue}
  }
  /// Returns true if `upstreamBindConfig` has been explicitly set.
  public var hasUpstreamBindConfig: Bool {return _storage._upstreamBindConfig != nil}
  /// Clears the value of `upstreamBindConfig`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamBindConfig() {_uniqueStorage()._upstreamBindConfig = nil}

  /// A management server endpoint to stream load stats to via
  /// *StreamLoadStats*. This must have :ref:`api_type
  /// <envoy_api_field_core.ApiConfigSource.api_type>` :ref:`GRPC
  /// <envoy_api_enum_value_core.ApiConfigSource.ApiType.GRPC>`.
  public var loadStatsConfig: Envoy_Api_V2_Core_ApiConfigSource {
    get {return _storage._loadStatsConfig ?? Envoy_Api_V2_Core_ApiConfigSource()}
    set {_uniqueStorage()._loadStatsConfig = newValue}
  }
  /// Returns true if `loadStatsConfig` has been explicitly set.
  public var hasLoadStatsConfig: Bool {return _storage._loadStatsConfig != nil}
  /// Clears the value of `loadStatsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearLoadStatsConfig() {_uniqueStorage()._loadStatsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct OutlierDetection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the path to the outlier event log.
    public var eventLogPath: String = String()

    /// [#not-implemented-hide:]
    /// The gRPC service for the outlier detection event service.
    /// If empty, outlier detection events won't be sent to a remote endpoint.
    public var eventService: Envoy_Api_V2_Core_EventServiceConfig {
      get {return _eventService ?? Envoy_Api_V2_Core_EventServiceConfig()}
      set {_eventService = newValue}
    }
    /// Returns true if `eventService` has been explicitly set.
    public var hasEventService: Bool {return self._eventService != nil}
    /// Clears the value of `eventService`. Subsequent reads from it will return its default value.
    public mutating func clearEventService() {self._eventService = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _eventService: Envoy_Api_V2_Core_EventServiceConfig? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Envoy process watchdog configuration. When configured, this monitors for
/// nonresponsive threads and kills the process after the configured thresholds.
/// See the :ref:`watchdog documentation <operations_performance_watchdog>` for more information.
public struct Envoy_Config_Bootstrap_V2_Watchdog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The duration after which Envoy counts a nonresponsive thread in the
  /// *watchdog_miss* statistic. If not specified the default is 200ms.
  public var missTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _missTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_missTimeout = newValue}
  }
  /// Returns true if `missTimeout` has been explicitly set.
  public var hasMissTimeout: Bool {return self._missTimeout != nil}
  /// Clears the value of `missTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMissTimeout() {self._missTimeout = nil}

  /// The duration after which Envoy counts a nonresponsive thread in the
  /// *watchdog_mega_miss* statistic. If not specified the default is
  /// 1000ms.
  public var megamissTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _megamissTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_megamissTimeout = newValue}
  }
  /// Returns true if `megamissTimeout` has been explicitly set.
  public var hasMegamissTimeout: Bool {return self._megamissTimeout != nil}
  /// Clears the value of `megamissTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMegamissTimeout() {self._megamissTimeout = nil}

  /// If a watched thread has been nonresponsive for this duration, assume a
  /// programming error and kill the entire Envoy process. Set to 0 to disable
  /// kill behavior. If not specified the default is 0 (disabled).
  public var killTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _killTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_killTimeout = newValue}
  }
  /// Returns true if `killTimeout` has been explicitly set.
  public var hasKillTimeout: Bool {return self._killTimeout != nil}
  /// Clears the value of `killTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearKillTimeout() {self._killTimeout = nil}

  /// If at least two watched threads have been nonresponsive for at least this
  /// duration assume a true deadlock and kill the entire Envoy process. Set to 0
  /// to disable this behavior. If not specified the default is 0 (disabled).
  public var multikillTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _multikillTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_multikillTimeout = newValue}
  }
  /// Returns true if `multikillTimeout` has been explicitly set.
  public var hasMultikillTimeout: Bool {return self._multikillTimeout != nil}
  /// Clears the value of `multikillTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMultikillTimeout() {self._multikillTimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _missTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _megamissTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _killTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _multikillTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Runtime :ref:`configuration overview <config_runtime>` (deprecated).
public struct Envoy_Config_Bootstrap_V2_Runtime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The implementation assumes that the file system tree is accessed via a
  /// symbolic link. An atomic link swap is used when a new tree should be
  /// switched to. This parameter specifies the path to the symbolic link. Envoy
  /// will watch the location for changes and reload the file system tree when
  /// they happen. If this parameter is not set, there will be no disk based
  /// runtime.
  public var symlinkRoot: String = String()

  /// Specifies the subdirectory to load within the root directory. This is
  /// useful if multiple systems share the same delivery mechanism. Envoy
  /// configuration elements can be contained in a dedicated subdirectory.
  public var subdirectory: String = String()

  /// Specifies an optional subdirectory to load within the root directory. If
  /// specified and the directory exists, configuration values within this
  /// directory will override those found in the primary subdirectory. This is
  /// useful when Envoy is deployed across many different types of servers.
  /// Sometimes it is useful to have a per service cluster directory for runtime
  /// configuration. See below for exactly how the override directory is used.
  public var overrideSubdirectory: String = String()

  /// Static base runtime. This will be :ref:`overridden
  /// <config_runtime_layering>` by other runtime layers, e.g.
  /// disk or admin. This follows the :ref:`runtime protobuf JSON representation
  /// encoding <config_runtime_proto_json>`.
  public var base: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _base ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  public var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  public mutating func clearBase() {self._base = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _base: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// [#next-free-field: 6]
public struct Envoy_Config_Bootstrap_V2_RuntimeLayer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Descriptive name for the runtime layer. This is only used for the runtime
  /// :http:get:`/runtime` output.
  public var name: String = String()

  public var layerSpecifier: Envoy_Config_Bootstrap_V2_RuntimeLayer.OneOf_LayerSpecifier? = nil

  /// :ref:`Static runtime <config_runtime_bootstrap>` layer.
  /// This follows the :ref:`runtime protobuf JSON representation encoding
  /// <config_runtime_proto_json>`. Unlike static xDS resources, this static
  /// layer is overridable by later layers in the runtime virtual filesystem.
  public var staticLayer: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .staticLayer(let v)? = layerSpecifier {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {layerSpecifier = .staticLayer(newValue)}
  }

  public var diskLayer: Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer {
    get {
      if case .diskLayer(let v)? = layerSpecifier {return v}
      return Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer()
    }
    set {layerSpecifier = .diskLayer(newValue)}
  }

  public var adminLayer: Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer {
    get {
      if case .adminLayer(let v)? = layerSpecifier {return v}
      return Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer()
    }
    set {layerSpecifier = .adminLayer(newValue)}
  }

  public var rtdsLayer: Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer {
    get {
      if case .rtdsLayer(let v)? = layerSpecifier {return v}
      return Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer()
    }
    set {layerSpecifier = .rtdsLayer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_LayerSpecifier: Equatable {
    /// :ref:`Static runtime <config_runtime_bootstrap>` layer.
    /// This follows the :ref:`runtime protobuf JSON representation encoding
    /// <config_runtime_proto_json>`. Unlike static xDS resources, this static
    /// layer is overridable by later layers in the runtime virtual filesystem.
    case staticLayer(SwiftProtobuf.Google_Protobuf_Struct)
    case diskLayer(Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer)
    case adminLayer(Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer)
    case rtdsLayer(Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.OneOf_LayerSpecifier, rhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.OneOf_LayerSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.staticLayer, .staticLayer): return {
        guard case .staticLayer(let l) = lhs, case .staticLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diskLayer, .diskLayer): return {
        guard case .diskLayer(let l) = lhs, case .diskLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.adminLayer, .adminLayer): return {
        guard case .adminLayer(let l) = lhs, case .adminLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rtdsLayer, .rtdsLayer): return {
        guard case .rtdsLayer(let l) = lhs, case .rtdsLayer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// :ref:`Disk runtime <config_runtime_local_disk>` layer.
  public struct DiskLayer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The implementation assumes that the file system tree is accessed via a
    /// symbolic link. An atomic link swap is used when a new tree should be
    /// switched to. This parameter specifies the path to the symbolic link.
    /// Envoy will watch the location for changes and reload the file system tree
    /// when they happen. See documentation on runtime :ref:`atomicity
    /// <config_runtime_atomicity>` for further details on how reloads are
    /// treated.
    public var symlinkRoot: String = String()

    /// Specifies the subdirectory to load within the root directory. This is
    /// useful if multiple systems share the same delivery mechanism. Envoy
    /// configuration elements can be contained in a dedicated subdirectory.
    public var subdirectory: String = String()

    /// :ref:`Append <config_runtime_local_disk_service_cluster_subdirs>` the
    /// service cluster to the path under symlink root.
    public var appendServiceCluster: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// :ref:`Admin console runtime <config_runtime_admin>` layer.
  public struct AdminLayer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// :ref:`Runtime Discovery Service (RTDS) <config_runtime_rtds>` layer.
  public struct RtdsLayer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource to subscribe to at *rtds_config* for the RTDS layer.
    public var name: String = String()

    /// RTDS configuration source.
    public var rtdsConfig: Envoy_Api_V2_Core_ConfigSource {
      get {return _rtdsConfig ?? Envoy_Api_V2_Core_ConfigSource()}
      set {_rtdsConfig = newValue}
    }
    /// Returns true if `rtdsConfig` has been explicitly set.
    public var hasRtdsConfig: Bool {return self._rtdsConfig != nil}
    /// Clears the value of `rtdsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearRtdsConfig() {self._rtdsConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _rtdsConfig: Envoy_Api_V2_Core_ConfigSource? = nil
  }

  public init() {}
}

/// Runtime :ref:`configuration overview <config_runtime>`.
public struct Envoy_Config_Bootstrap_V2_LayeredRuntime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The :ref:`layers <config_runtime_layering>` of the runtime. This is ordered
  /// such that later layers in the list overlay earlier entries.
  public var layers: [Envoy_Config_Bootstrap_V2_RuntimeLayer] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.bootstrap.v2"

extension Envoy_Config_Bootstrap_V2_Bootstrap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Bootstrap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .standard(proto: "static_resources"),
    3: .standard(proto: "dynamic_resources"),
    4: .standard(proto: "cluster_manager"),
    14: .standard(proto: "hds_config"),
    5: .standard(proto: "flags_path"),
    6: .standard(proto: "stats_sinks"),
    13: .standard(proto: "stats_config"),
    7: .standard(proto: "stats_flush_interval"),
    8: .same(proto: "watchdog"),
    9: .same(proto: "tracing"),
    11: .same(proto: "runtime"),
    17: .standard(proto: "layered_runtime"),
    12: .same(proto: "admin"),
    15: .standard(proto: "overload_manager"),
    16: .standard(proto: "enable_dispatcher_stats"),
    18: .standard(proto: "header_prefix"),
    19: .standard(proto: "stats_server_version_override"),
    20: .standard(proto: "use_tcp_for_dns_lookups"),
  ]

  fileprivate class _StorageClass {
    var _node: Envoy_Api_V2_Core_Node? = nil
    var _staticResources: Envoy_Config_Bootstrap_V2_Bootstrap.StaticResources? = nil
    var _dynamicResources: Envoy_Config_Bootstrap_V2_Bootstrap.DynamicResources? = nil
    var _clusterManager: Envoy_Config_Bootstrap_V2_ClusterManager? = nil
    var _hdsConfig: Envoy_Api_V2_Core_ApiConfigSource? = nil
    var _flagsPath: String = String()
    var _statsSinks: [Envoy_Config_Metrics_V2_StatsSink] = []
    var _statsConfig: Envoy_Config_Metrics_V2_StatsConfig? = nil
    var _statsFlushInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _watchdog: Envoy_Config_Bootstrap_V2_Watchdog? = nil
    var _tracing: Envoy_Config_Trace_V2_Tracing? = nil
    var _runtime: Envoy_Config_Bootstrap_V2_Runtime? = nil
    var _layeredRuntime: Envoy_Config_Bootstrap_V2_LayeredRuntime? = nil
    var _admin: Envoy_Config_Bootstrap_V2_Admin? = nil
    var _overloadManager: Envoy_Config_Overload_V2alpha_OverloadManager? = nil
    var _enableDispatcherStats: Bool = false
    var _headerPrefix: String = String()
    var _statsServerVersionOverride: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    var _useTcpForDnsLookups: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _node = source._node
      _staticResources = source._staticResources
      _dynamicResources = source._dynamicResources
      _clusterManager = source._clusterManager
      _hdsConfig = source._hdsConfig
      _flagsPath = source._flagsPath
      _statsSinks = source._statsSinks
      _statsConfig = source._statsConfig
      _statsFlushInterval = source._statsFlushInterval
      _watchdog = source._watchdog
      _tracing = source._tracing
      _runtime = source._runtime
      _layeredRuntime = source._layeredRuntime
      _admin = source._admin
      _overloadManager = source._overloadManager
      _enableDispatcherStats = source._enableDispatcherStats
      _headerPrefix = source._headerPrefix
      _statsServerVersionOverride = source._statsServerVersionOverride
      _useTcpForDnsLookups = source._useTcpForDnsLookups
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._node) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._staticResources) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dynamicResources) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._clusterManager) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._flagsPath) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._statsSinks) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._statsFlushInterval) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._watchdog) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tracing) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._runtime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._admin) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._statsConfig) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._hdsConfig) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._overloadManager) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._enableDispatcherStats) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._layeredRuntime) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._headerPrefix) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._statsServerVersionOverride) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._useTcpForDnsLookups) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._node {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._staticResources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._dynamicResources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._clusterManager {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._flagsPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._flagsPath, fieldNumber: 5)
      }
      if !_storage._statsSinks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._statsSinks, fieldNumber: 6)
      }
      if let v = _storage._statsFlushInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._watchdog {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._tracing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._runtime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._admin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._statsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._hdsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._overloadManager {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._enableDispatcherStats != false {
        try visitor.visitSingularBoolField(value: _storage._enableDispatcherStats, fieldNumber: 16)
      }
      if let v = _storage._layeredRuntime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._headerPrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._headerPrefix, fieldNumber: 18)
      }
      if let v = _storage._statsServerVersionOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if _storage._useTcpForDnsLookups != false {
        try visitor.visitSingularBoolField(value: _storage._useTcpForDnsLookups, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_Bootstrap, rhs: Envoy_Config_Bootstrap_V2_Bootstrap) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._node != rhs_storage._node {return false}
        if _storage._staticResources != rhs_storage._staticResources {return false}
        if _storage._dynamicResources != rhs_storage._dynamicResources {return false}
        if _storage._clusterManager != rhs_storage._clusterManager {return false}
        if _storage._hdsConfig != rhs_storage._hdsConfig {return false}
        if _storage._flagsPath != rhs_storage._flagsPath {return false}
        if _storage._statsSinks != rhs_storage._statsSinks {return false}
        if _storage._statsConfig != rhs_storage._statsConfig {return false}
        if _storage._statsFlushInterval != rhs_storage._statsFlushInterval {return false}
        if _storage._watchdog != rhs_storage._watchdog {return false}
        if _storage._tracing != rhs_storage._tracing {return false}
        if _storage._runtime != rhs_storage._runtime {return false}
        if _storage._layeredRuntime != rhs_storage._layeredRuntime {return false}
        if _storage._admin != rhs_storage._admin {return false}
        if _storage._overloadManager != rhs_storage._overloadManager {return false}
        if _storage._enableDispatcherStats != rhs_storage._enableDispatcherStats {return false}
        if _storage._headerPrefix != rhs_storage._headerPrefix {return false}
        if _storage._statsServerVersionOverride != rhs_storage._statsServerVersionOverride {return false}
        if _storage._useTcpForDnsLookups != rhs_storage._useTcpForDnsLookups {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_Bootstrap.StaticResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V2_Bootstrap.protoMessageName + ".StaticResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "listeners"),
    2: .same(proto: "clusters"),
    3: .same(proto: "secrets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.listeners) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.secrets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listeners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listeners, fieldNumber: 1)
    }
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 2)
    }
    if !self.secrets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secrets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_Bootstrap.StaticResources, rhs: Envoy_Config_Bootstrap_V2_Bootstrap.StaticResources) -> Bool {
    if lhs.listeners != rhs.listeners {return false}
    if lhs.clusters != rhs.clusters {return false}
    if lhs.secrets != rhs.secrets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_Bootstrap.DynamicResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V2_Bootstrap.protoMessageName + ".DynamicResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "lds_config"),
    2: .standard(proto: "cds_config"),
    3: .standard(proto: "ads_config"),
  ]

  fileprivate class _StorageClass {
    var _ldsConfig: Envoy_Api_V2_Core_ConfigSource? = nil
    var _cdsConfig: Envoy_Api_V2_Core_ConfigSource? = nil
    var _adsConfig: Envoy_Api_V2_Core_ApiConfigSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _ldsConfig = source._ldsConfig
      _cdsConfig = source._cdsConfig
      _adsConfig = source._adsConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._ldsConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cdsConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._adsConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._ldsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._cdsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._adsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_Bootstrap.DynamicResources, rhs: Envoy_Config_Bootstrap_V2_Bootstrap.DynamicResources) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._ldsConfig != rhs_storage._ldsConfig {return false}
        if _storage._cdsConfig != rhs_storage._cdsConfig {return false}
        if _storage._adsConfig != rhs_storage._adsConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_Admin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Admin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_log_path"),
    2: .standard(proto: "profile_path"),
    3: .same(proto: "address"),
    4: .standard(proto: "socket_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessLogPath) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.profilePath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.socketOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessLogPath.isEmpty {
      try visitor.visitSingularStringField(value: self.accessLogPath, fieldNumber: 1)
    }
    if !self.profilePath.isEmpty {
      try visitor.visitSingularStringField(value: self.profilePath, fieldNumber: 2)
    }
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.socketOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.socketOptions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_Admin, rhs: Envoy_Config_Bootstrap_V2_Admin) -> Bool {
    if lhs.accessLogPath != rhs.accessLogPath {return false}
    if lhs.profilePath != rhs.profilePath {return false}
    if lhs._address != rhs._address {return false}
    if lhs.socketOptions != rhs.socketOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_ClusterManager: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterManager"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_cluster_name"),
    2: .standard(proto: "outlier_detection"),
    3: .standard(proto: "upstream_bind_config"),
    4: .standard(proto: "load_stats_config"),
  ]

  fileprivate class _StorageClass {
    var _localClusterName: String = String()
    var _outlierDetection: Envoy_Config_Bootstrap_V2_ClusterManager.OutlierDetection? = nil
    var _upstreamBindConfig: Envoy_Api_V2_Core_BindConfig? = nil
    var _loadStatsConfig: Envoy_Api_V2_Core_ApiConfigSource? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _localClusterName = source._localClusterName
      _outlierDetection = source._outlierDetection
      _upstreamBindConfig = source._upstreamBindConfig
      _loadStatsConfig = source._loadStatsConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._localClusterName) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._outlierDetection) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._upstreamBindConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._loadStatsConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._localClusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localClusterName, fieldNumber: 1)
      }
      if let v = _storage._outlierDetection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._upstreamBindConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._loadStatsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_ClusterManager, rhs: Envoy_Config_Bootstrap_V2_ClusterManager) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._localClusterName != rhs_storage._localClusterName {return false}
        if _storage._outlierDetection != rhs_storage._outlierDetection {return false}
        if _storage._upstreamBindConfig != rhs_storage._upstreamBindConfig {return false}
        if _storage._loadStatsConfig != rhs_storage._loadStatsConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_ClusterManager.OutlierDetection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V2_ClusterManager.protoMessageName + ".OutlierDetection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_log_path"),
    2: .standard(proto: "event_service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventLogPath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._eventService) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventLogPath.isEmpty {
      try visitor.visitSingularStringField(value: self.eventLogPath, fieldNumber: 1)
    }
    if let v = self._eventService {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_ClusterManager.OutlierDetection, rhs: Envoy_Config_Bootstrap_V2_ClusterManager.OutlierDetection) -> Bool {
    if lhs.eventLogPath != rhs.eventLogPath {return false}
    if lhs._eventService != rhs._eventService {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_Watchdog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Watchdog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "miss_timeout"),
    2: .standard(proto: "megamiss_timeout"),
    3: .standard(proto: "kill_timeout"),
    4: .standard(proto: "multikill_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._missTimeout) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._megamissTimeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._killTimeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._multikillTimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._missTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._megamissTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._killTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._multikillTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_Watchdog, rhs: Envoy_Config_Bootstrap_V2_Watchdog) -> Bool {
    if lhs._missTimeout != rhs._missTimeout {return false}
    if lhs._megamissTimeout != rhs._megamissTimeout {return false}
    if lhs._killTimeout != rhs._killTimeout {return false}
    if lhs._multikillTimeout != rhs._multikillTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_Runtime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Runtime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symlink_root"),
    2: .same(proto: "subdirectory"),
    3: .standard(proto: "override_subdirectory"),
    4: .same(proto: "base"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symlinkRoot) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subdirectory) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.overrideSubdirectory) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._base) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symlinkRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.symlinkRoot, fieldNumber: 1)
    }
    if !self.subdirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.subdirectory, fieldNumber: 2)
    }
    if !self.overrideSubdirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.overrideSubdirectory, fieldNumber: 3)
    }
    if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_Runtime, rhs: Envoy_Config_Bootstrap_V2_Runtime) -> Bool {
    if lhs.symlinkRoot != rhs.symlinkRoot {return false}
    if lhs.subdirectory != rhs.subdirectory {return false}
    if lhs.overrideSubdirectory != rhs.overrideSubdirectory {return false}
    if lhs._base != rhs._base {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_RuntimeLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "static_layer"),
    3: .standard(proto: "disk_layer"),
    4: .standard(proto: "admin_layer"),
    5: .standard(proto: "rtds_layer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .staticLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .staticLayer(v)}
      }()
      case 3: try {
        var v: Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .diskLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .diskLayer(v)}
      }()
      case 4: try {
        var v: Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .adminLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .adminLayer(v)}
      }()
      case 5: try {
        var v: Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer?
        if let current = self.layerSpecifier {
          try decoder.handleConflictingOneOf()
          if case .rtdsLayer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.layerSpecifier = .rtdsLayer(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.layerSpecifier {
    case .staticLayer?: try {
      guard case .staticLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .diskLayer?: try {
      guard case .diskLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .adminLayer?: try {
      guard case .adminLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rtdsLayer?: try {
      guard case .rtdsLayer(let v)? = self.layerSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_RuntimeLayer, rhs: Envoy_Config_Bootstrap_V2_RuntimeLayer) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.layerSpecifier != rhs.layerSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V2_RuntimeLayer.protoMessageName + ".DiskLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "symlink_root"),
    3: .same(proto: "subdirectory"),
    2: .standard(proto: "append_service_cluster"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symlinkRoot) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.appendServiceCluster) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subdirectory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symlinkRoot.isEmpty {
      try visitor.visitSingularStringField(value: self.symlinkRoot, fieldNumber: 1)
    }
    if self.appendServiceCluster != false {
      try visitor.visitSingularBoolField(value: self.appendServiceCluster, fieldNumber: 2)
    }
    if !self.subdirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.subdirectory, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer, rhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.DiskLayer) -> Bool {
    if lhs.symlinkRoot != rhs.symlinkRoot {return false}
    if lhs.subdirectory != rhs.subdirectory {return false}
    if lhs.appendServiceCluster != rhs.appendServiceCluster {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V2_RuntimeLayer.protoMessageName + ".AdminLayer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer, rhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.AdminLayer) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Bootstrap_V2_RuntimeLayer.protoMessageName + ".RtdsLayer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "rtds_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rtdsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._rtdsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer, rhs: Envoy_Config_Bootstrap_V2_RuntimeLayer.RtdsLayer) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._rtdsConfig != rhs._rtdsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Bootstrap_V2_LayeredRuntime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LayeredRuntime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "layers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Bootstrap_V2_LayeredRuntime, rhs: Envoy_Config_Bootstrap_V2_LayeredRuntime) -> Bool {
    if lhs.layers != rhs.layers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/metrics/v3/stats.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration for pluggable stats sinks.
public struct Envoy_Config_Metrics_V3_StatsSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the stats sink to instantiate. The name must match a supported
  /// stats sink. The built-in stats sinks are:
  ///
  /// * :ref:`envoy.stat_sinks.statsd <envoy_api_msg_config.metrics.v3.StatsdSink>`
  /// * :ref:`envoy.stat_sinks.dog_statsd <envoy_api_msg_config.metrics.v3.DogStatsdSink>`
  /// * :ref:`envoy.stat_sinks.metrics_service <envoy_api_msg_config.metrics.v3.MetricsServiceConfig>`
  /// * :ref:`envoy.stat_sinks.hystrix <envoy_api_msg_config.metrics.v3.HystrixSink>`
  ///
  /// Sinks optionally support tagged/multiple dimensional metrics.
  public var name: String = String()

  /// Stats sink specific configuration which depends on the sink being instantiated. See
  /// :ref:`StatsdSink <envoy_api_msg_config.metrics.v3.StatsdSink>` for an example.
  public var configType: Envoy_Config_Metrics_V3_StatsSink.OneOf_ConfigType? = nil

  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .typedConfig(let v)? = configType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {configType = .typedConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stats sink specific configuration which depends on the sink being instantiated. See
  /// :ref:`StatsdSink <envoy_api_msg_config.metrics.v3.StatsdSink>` for an example.
  public enum OneOf_ConfigType: Equatable {
    case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Metrics_V3_StatsSink.OneOf_ConfigType, rhs: Envoy_Config_Metrics_V3_StatsSink.OneOf_ConfigType) -> Bool {
      switch (lhs, rhs) {
      case (.typedConfig(let l), .typedConfig(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}
}

/// Statistics configuration such as tagging.
public struct Envoy_Config_Metrics_V3_StatsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Each stat name is iteratively processed through these tag specifiers.
  /// When a tag is matched, the first capture group is removed from the name so
  /// later :ref:`TagSpecifiers <envoy_api_msg_config.metrics.v3.TagSpecifier>` cannot match that
  /// same portion of the match.
  public var statsTags: [Envoy_Config_Metrics_V3_TagSpecifier] = []

  /// Use all default tag regexes specified in Envoy. These can be combined with
  /// custom tags specified in :ref:`stats_tags
  /// <envoy_api_field_config.metrics.v3.StatsConfig.stats_tags>`. They will be processed before
  /// the custom tags.
  ///
  /// .. note::
  ///
  ///   If any default tags are specified twice, the config will be considered
  ///   invalid.
  ///
  /// See :repo:`well_known_names.h <source/common/config/well_known_names.h>` for a list of the
  /// default tags in Envoy.
  ///
  /// If not provided, the value is assumed to be true.
  public var useAllDefaultTags: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _useAllDefaultTags ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_useAllDefaultTags = newValue}
  }
  /// Returns true if `useAllDefaultTags` has been explicitly set.
  public var hasUseAllDefaultTags: Bool {return self._useAllDefaultTags != nil}
  /// Clears the value of `useAllDefaultTags`. Subsequent reads from it will return its default value.
  public mutating func clearUseAllDefaultTags() {self._useAllDefaultTags = nil}

  /// Inclusion/exclusion matcher for stat name creation. If not provided, all stats are instantiated
  /// as normal. Preventing the instantiation of certain families of stats can improve memory
  /// performance for Envoys running especially large configs.
  ///
  /// .. warning::
  ///   Excluding stats may affect Envoy's behavior in undocumented ways. See
  ///   `issue #8771 <https://github.com/envoyproxy/envoy/issues/8771>`_ for more information.
  ///   If any unexpected behavior changes are observed, please open a new issue immediately.
  public var statsMatcher: Envoy_Config_Metrics_V3_StatsMatcher {
    get {return _statsMatcher ?? Envoy_Config_Metrics_V3_StatsMatcher()}
    set {_statsMatcher = newValue}
  }
  /// Returns true if `statsMatcher` has been explicitly set.
  public var hasStatsMatcher: Bool {return self._statsMatcher != nil}
  /// Clears the value of `statsMatcher`. Subsequent reads from it will return its default value.
  public mutating func clearStatsMatcher() {self._statsMatcher = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _useAllDefaultTags: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _statsMatcher: Envoy_Config_Metrics_V3_StatsMatcher? = nil
}

/// Configuration for disabling stat instantiation.
public struct Envoy_Config_Metrics_V3_StatsMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statsMatcher: Envoy_Config_Metrics_V3_StatsMatcher.OneOf_StatsMatcher? = nil

  /// If `reject_all` is true, then all stats are disabled. If `reject_all` is false, then all
  /// stats are enabled.
  public var rejectAll: Bool {
    get {
      if case .rejectAll(let v)? = statsMatcher {return v}
      return false
    }
    set {statsMatcher = .rejectAll(newValue)}
  }

  /// Exclusive match. All stats are enabled except for those matching one of the supplied
  /// StringMatcher protos.
  public var exclusionList: Envoy_Type_Matcher_V3_ListStringMatcher {
    get {
      if case .exclusionList(let v)? = statsMatcher {return v}
      return Envoy_Type_Matcher_V3_ListStringMatcher()
    }
    set {statsMatcher = .exclusionList(newValue)}
  }

  /// Inclusive match. No stats are enabled except for those matching one of the supplied
  /// StringMatcher protos.
  public var inclusionList: Envoy_Type_Matcher_V3_ListStringMatcher {
    get {
      if case .inclusionList(let v)? = statsMatcher {return v}
      return Envoy_Type_Matcher_V3_ListStringMatcher()
    }
    set {statsMatcher = .inclusionList(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StatsMatcher: Equatable {
    /// If `reject_all` is true, then all stats are disabled. If `reject_all` is false, then all
    /// stats are enabled.
    case rejectAll(Bool)
    /// Exclusive match. All stats are enabled except for those matching one of the supplied
    /// StringMatcher protos.
    case exclusionList(Envoy_Type_Matcher_V3_ListStringMatcher)
    /// Inclusive match. No stats are enabled except for those matching one of the supplied
    /// StringMatcher protos.
    case inclusionList(Envoy_Type_Matcher_V3_ListStringMatcher)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Metrics_V3_StatsMatcher.OneOf_StatsMatcher, rhs: Envoy_Config_Metrics_V3_StatsMatcher.OneOf_StatsMatcher) -> Bool {
      switch (lhs, rhs) {
      case (.rejectAll(let l), .rejectAll(let r)): return l == r
      case (.exclusionList(let l), .exclusionList(let r)): return l == r
      case (.inclusionList(let l), .inclusionList(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Designates a tag name and value pair. The value may be either a fixed value
/// or a regex providing the value via capture groups. The specified tag will be
/// unconditionally set if a fixed value, otherwise it will only be set if one
/// or more capture groups in the regex match.
public struct Envoy_Config_Metrics_V3_TagSpecifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attaches an identifier to the tag values to identify the tag being in the
  /// sink. Envoy has a set of default names and regexes to extract dynamic
  /// portions of existing stats, which can be found in :repo:`well_known_names.h
  /// <source/common/config/well_known_names.h>` in the Envoy repository. If a :ref:`tag_name
  /// <envoy_api_field_config.metrics.v3.TagSpecifier.tag_name>` is provided in the config and
  /// neither :ref:`regex <envoy_api_field_config.metrics.v3.TagSpecifier.regex>` or
  /// :ref:`fixed_value <envoy_api_field_config.metrics.v3.TagSpecifier.fixed_value>` were specified,
  /// Envoy will attempt to find that name in its set of defaults and use the accompanying regex.
  ///
  /// .. note::
  ///
  ///   It is invalid to specify the same tag name twice in a config.
  public var tagName: String = String()

  public var tagValue: Envoy_Config_Metrics_V3_TagSpecifier.OneOf_TagValue? = nil

  /// Designates a tag to strip from the tag extracted name and provide as a named
  /// tag value for all statistics. This will only occur if any part of the name
  /// matches the regex provided with one or more capture groups.
  ///
  /// The first capture group identifies the portion of the name to remove. The
  /// second capture group (which will normally be nested inside the first) will
  /// designate the value of the tag for the statistic. If no second capture
  /// group is provided, the first will also be used to set the value of the tag.
  /// All other capture groups will be ignored.
  ///
  /// Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
  /// one tag specifier:
  ///
  /// .. code-block:: json
  ///
  ///   {
  ///     "tag_name": "envoy.cluster_name",
  ///     "regex": "^cluster\.((.+?)\.)"
  ///   }
  ///
  /// Note that the regex will remove ``foo_cluster.`` making the tag extracted
  /// name ``cluster.upstream_rq_timeout`` and the tag value for
  /// ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
  /// ``.`` character because of the second capture group).
  ///
  /// Example 2. a stat name
  /// ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
  /// tag specifiers:
  ///
  /// .. code-block:: json
  ///
  ///   [
  ///     {
  ///       "tag_name": "envoy.http_user_agent",
  ///       "regex": "^http(?=\.).*?\.user_agent\.((.+?)\.)\w+?$"
  ///     },
  ///     {
  ///       "tag_name": "envoy.http_conn_manager_prefix",
  ///       "regex": "^http\.((.*?)\.)"
  ///     }
  ///   ]
  ///
  /// The two regexes of the specifiers will be processed in the definition order.
  ///
  /// The first regex will remove ``ios.``, leaving the tag extracted name
  /// ``http.connection_manager_1.user_agent.downstream_cx_total``. The tag
  /// ``envoy.http_user_agent`` will be added with tag value ``ios``.
  ///
  /// The second regex will remove ``connection_manager_1.`` from the tag
  /// extracted name produced by the first regex
  /// ``http.connection_manager_1.user_agent.downstream_cx_total``, leaving
  /// ``http.user_agent.downstream_cx_total`` as the tag extracted name. The tag
  /// ``envoy.http_conn_manager_prefix`` will be added with the tag value
  /// ``connection_manager_1``.
  public var regex: String {
    get {
      if case .regex(let v)? = tagValue {return v}
      return String()
    }
    set {tagValue = .regex(newValue)}
  }

  /// Specifies a fixed tag value for the ``tag_name``.
  public var fixedValue: String {
    get {
      if case .fixedValue(let v)? = tagValue {return v}
      return String()
    }
    set {tagValue = .fixedValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TagValue: Equatable {
    /// Designates a tag to strip from the tag extracted name and provide as a named
    /// tag value for all statistics. This will only occur if any part of the name
    /// matches the regex provided with one or more capture groups.
    ///
    /// The first capture group identifies the portion of the name to remove. The
    /// second capture group (which will normally be nested inside the first) will
    /// designate the value of the tag for the statistic. If no second capture
    /// group is provided, the first will also be used to set the value of the tag.
    /// All other capture groups will be ignored.
    ///
    /// Example 1. a stat name ``cluster.foo_cluster.upstream_rq_timeout`` and
    /// one tag specifier:
    ///
    /// .. code-block:: json
    ///
    ///   {
    ///     "tag_name": "envoy.cluster_name",
    ///     "regex": "^cluster\.((.+?)\.)"
    ///   }
    ///
    /// Note that the regex will remove ``foo_cluster.`` making the tag extracted
    /// name ``cluster.upstream_rq_timeout`` and the tag value for
    /// ``envoy.cluster_name`` will be ``foo_cluster`` (note: there will be no
    /// ``.`` character because of the second capture group).
    ///
    /// Example 2. a stat name
    /// ``http.connection_manager_1.user_agent.ios.downstream_cx_total`` and two
    /// tag specifiers:
    ///
    /// .. code-block:: json
    ///
    ///   [
    ///     {
    ///       "tag_name": "envoy.http_user_agent",
    ///       "regex": "^http(?=\.).*?\.user_agent\.((.+?)\.)\w+?$"
    ///     },
    ///     {
    ///       "tag_name": "envoy.http_conn_manager_prefix",
    ///       "regex": "^http\.((.*?)\.)"
    ///     }
    ///   ]
    ///
    /// The two regexes of the specifiers will be processed in the definition order.
    ///
    /// The first regex will remove ``ios.``, leaving the tag extracted name
    /// ``http.connection_manager_1.user_agent.downstream_cx_total``. The tag
    /// ``envoy.http_user_agent`` will be added with tag value ``ios``.
    ///
    /// The second regex will remove ``connection_manager_1.`` from the tag
    /// extracted name produced by the first regex
    /// ``http.connection_manager_1.user_agent.downstream_cx_total``, leaving
    /// ``http.user_agent.downstream_cx_total`` as the tag extracted name. The tag
    /// ``envoy.http_conn_manager_prefix`` will be added with the tag value
    /// ``connection_manager_1``.
    case regex(String)
    /// Specifies a fixed tag value for the ``tag_name``.
    case fixedValue(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Metrics_V3_TagSpecifier.OneOf_TagValue, rhs: Envoy_Config_Metrics_V3_TagSpecifier.OneOf_TagValue) -> Bool {
      switch (lhs, rhs) {
      case (.regex(let l), .regex(let r)): return l == r
      case (.fixedValue(let l), .fixedValue(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Stats configuration proto schema for built-in *envoy.stat_sinks.statsd* sink. This sink does not support
/// tagged metrics.
/// [#extension: envoy.stat_sinks.statsd]
public struct Envoy_Config_Metrics_V3_StatsdSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var statsdSpecifier: Envoy_Config_Metrics_V3_StatsdSink.OneOf_StatsdSpecifier? = nil

  /// The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
  /// compliant listener. If specified, statistics will be flushed to this
  /// address.
  public var address: Envoy_Config_Core_V3_Address {
    get {
      if case .address(let v)? = statsdSpecifier {return v}
      return Envoy_Config_Core_V3_Address()
    }
    set {statsdSpecifier = .address(newValue)}
  }

  /// The name of a cluster that is running a TCP `statsd
  /// <https://github.com/etsy/statsd>`_ compliant listener. If specified,
  /// Envoy will connect to this cluster to flush statistics.
  public var tcpClusterName: String {
    get {
      if case .tcpClusterName(let v)? = statsdSpecifier {return v}
      return String()
    }
    set {statsdSpecifier = .tcpClusterName(newValue)}
  }

  /// Optional custom prefix for StatsdSink. If
  /// specified, this will override the default prefix.
  /// For example:
  ///
  /// .. code-block:: json
  ///
  ///   {
  ///     "prefix" : "envoy-prod"
  ///   }
  ///
  /// will change emitted stats to
  ///
  /// .. code-block:: cpp
  ///
  ///   envoy-prod.test_counter:1|c
  ///   envoy-prod.test_timer:5|ms
  ///
  /// Note that the default prefix, "envoy", will be used if a prefix is not
  /// specified.
  ///
  /// Stats with default prefix:
  ///
  /// .. code-block:: cpp
  ///
  ///   envoy.test_counter:1|c
  ///   envoy.test_timer:5|ms
  public var prefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_StatsdSpecifier: Equatable {
    /// The UDP address of a running `statsd <https://github.com/etsy/statsd>`_
    /// compliant listener. If specified, statistics will be flushed to this
    /// address.
    case address(Envoy_Config_Core_V3_Address)
    /// The name of a cluster that is running a TCP `statsd
    /// <https://github.com/etsy/statsd>`_ compliant listener. If specified,
    /// Envoy will connect to this cluster to flush statistics.
    case tcpClusterName(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Metrics_V3_StatsdSink.OneOf_StatsdSpecifier, rhs: Envoy_Config_Metrics_V3_StatsdSink.OneOf_StatsdSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.address(let l), .address(let r)): return l == r
      case (.tcpClusterName(let l), .tcpClusterName(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Stats configuration proto schema for built-in *envoy.stat_sinks.dog_statsd* sink.
/// The sink emits stats with `DogStatsD <https://docs.datadoghq.com/guides/dogstatsd/>`_
/// compatible tags. Tags are configurable via :ref:`StatsConfig
/// <envoy_api_msg_config.metrics.v3.StatsConfig>`.
/// [#extension: envoy.stat_sinks.dog_statsd]
public struct Envoy_Config_Metrics_V3_DogStatsdSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dogStatsdSpecifier: Envoy_Config_Metrics_V3_DogStatsdSink.OneOf_DogStatsdSpecifier? = nil

  /// The UDP address of a running DogStatsD compliant listener. If specified,
  /// statistics will be flushed to this address.
  public var address: Envoy_Config_Core_V3_Address {
    get {
      if case .address(let v)? = dogStatsdSpecifier {return v}
      return Envoy_Config_Core_V3_Address()
    }
    set {dogStatsdSpecifier = .address(newValue)}
  }

  /// Optional custom metric name prefix. See :ref:`StatsdSink's prefix field
  /// <envoy_api_field_config.metrics.v3.StatsdSink.prefix>` for more details.
  public var prefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_DogStatsdSpecifier: Equatable {
    /// The UDP address of a running DogStatsD compliant listener. If specified,
    /// statistics will be flushed to this address.
    case address(Envoy_Config_Core_V3_Address)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Metrics_V3_DogStatsdSink.OneOf_DogStatsdSpecifier, rhs: Envoy_Config_Metrics_V3_DogStatsdSink.OneOf_DogStatsdSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.address(let l), .address(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}
}

/// Stats configuration proto schema for built-in *envoy.stat_sinks.hystrix* sink.
/// The sink emits stats in `text/event-stream
/// <https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events>`_
/// formatted stream for use by `Hystrix dashboard
/// <https://github.com/Netflix-Skunkworks/hystrix-dashboard/wiki>`_.
///
/// Note that only a single HystrixSink should be configured.
///
/// Streaming is started through an admin endpoint :http:get:`/hystrix_event_stream`.
/// [#extension: envoy.stat_sinks.hystrix]
public struct Envoy_Config_Metrics_V3_HystrixSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of buckets the rolling statistical window is divided into.
  ///
  /// Each time the sink is flushed, all relevant Envoy statistics are sampled and
  /// added to the rolling window (removing the oldest samples in the window
  /// in the process). The sink then outputs the aggregate statistics across the
  /// current rolling window to the event stream(s).
  ///
  /// rolling_window(ms) = stats_flush_interval(ms) * num_of_buckets
  ///
  /// More detailed explanation can be found in `Hystrix wiki
  /// <https://github.com/Netflix/Hystrix/wiki/Metrics-and-Monitoring#hystrixrollingnumber>`_.
  public var numBuckets: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.metrics.v3"

extension Envoy_Config_Metrics_V3_StatsSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatsSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3:
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_StatsSink, rhs: Envoy_Config_Metrics_V3_StatsSink) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Metrics_V3_StatsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stats_tags"),
    2: .standard(proto: "use_all_default_tags"),
    3: .standard(proto: "stats_matcher"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.statsTags)
      case 2: try decoder.decodeSingularMessageField(value: &self._useAllDefaultTags)
      case 3: try decoder.decodeSingularMessageField(value: &self._statsMatcher)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statsTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statsTags, fieldNumber: 1)
    }
    if let v = self._useAllDefaultTags {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._statsMatcher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_StatsConfig, rhs: Envoy_Config_Metrics_V3_StatsConfig) -> Bool {
    if lhs.statsTags != rhs.statsTags {return false}
    if lhs._useAllDefaultTags != rhs._useAllDefaultTags {return false}
    if lhs._statsMatcher != rhs._statsMatcher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Metrics_V3_StatsMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatsMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reject_all"),
    2: .standard(proto: "exclusion_list"),
    3: .standard(proto: "inclusion_list"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.statsMatcher != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.statsMatcher = .rejectAll(v)}
      case 2:
        var v: Envoy_Type_Matcher_V3_ListStringMatcher?
        if let current = self.statsMatcher {
          try decoder.handleConflictingOneOf()
          if case .exclusionList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.statsMatcher = .exclusionList(v)}
      case 3:
        var v: Envoy_Type_Matcher_V3_ListStringMatcher?
        if let current = self.statsMatcher {
          try decoder.handleConflictingOneOf()
          if case .inclusionList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.statsMatcher = .inclusionList(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.statsMatcher {
    case .rejectAll(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    case .exclusionList(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .inclusionList(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_StatsMatcher, rhs: Envoy_Config_Metrics_V3_StatsMatcher) -> Bool {
    if lhs.statsMatcher != rhs.statsMatcher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Metrics_V3_TagSpecifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagSpecifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tag_name"),
    2: .same(proto: "regex"),
    3: .standard(proto: "fixed_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.tagName)
      case 2:
        if self.tagValue != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.tagValue = .regex(v)}
      case 3:
        if self.tagValue != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.tagValue = .fixedValue(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tagName.isEmpty {
      try visitor.visitSingularStringField(value: self.tagName, fieldNumber: 1)
    }
    switch self.tagValue {
    case .regex(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .fixedValue(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_TagSpecifier, rhs: Envoy_Config_Metrics_V3_TagSpecifier) -> Bool {
    if lhs.tagName != rhs.tagName {return false}
    if lhs.tagValue != rhs.tagValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Metrics_V3_StatsdSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatsdSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "tcp_cluster_name"),
    3: .same(proto: "prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Config_Core_V3_Address?
        if let current = self.statsdSpecifier {
          try decoder.handleConflictingOneOf()
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.statsdSpecifier = .address(v)}
      case 2:
        if self.statsdSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.statsdSpecifier = .tcpClusterName(v)}
      case 3: try decoder.decodeSingularStringField(value: &self.prefix)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.statsdSpecifier {
    case .address(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .tcpClusterName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_StatsdSink, rhs: Envoy_Config_Metrics_V3_StatsdSink) -> Bool {
    if lhs.statsdSpecifier != rhs.statsdSpecifier {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Metrics_V3_DogStatsdSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DogStatsdSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    3: .same(proto: "prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Config_Core_V3_Address?
        if let current = self.dogStatsdSpecifier {
          try decoder.handleConflictingOneOf()
          if case .address(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dogStatsdSpecifier = .address(v)}
      case 3: try decoder.decodeSingularStringField(value: &self.prefix)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .address(let v)? = self.dogStatsdSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_DogStatsdSink, rhs: Envoy_Config_Metrics_V3_DogStatsdSink) -> Bool {
    if lhs.dogStatsdSpecifier != rhs.dogStatsdSpecifier {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Metrics_V3_HystrixSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HystrixSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.numBuckets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBuckets != 0 {
      try visitor.visitSingularInt64Field(value: self.numBuckets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Metrics_V3_HystrixSink, rhs: Envoy_Config_Metrics_V3_HystrixSink) -> Bool {
    if lhs.numBuckets != rhs.numBuckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

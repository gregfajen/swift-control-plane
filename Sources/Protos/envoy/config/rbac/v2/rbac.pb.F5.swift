// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/rbac/v2/rbac.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Role Based Access Control (RBAC) provides service-level and method-level access control for a
/// service. RBAC policies are additive. The policies are examined in order. A request is allowed
/// once a matching policy is found (suppose the `action` is ALLOW).
///
/// Here is an example of RBAC configuration. It has two policies:
///
/// * Service account "cluster.local/ns/default/sa/admin" has full access to the service, and so
///   does "cluster.local/ns/default/sa/superuser".
///
/// * Any user can read ("GET") the service at paths with prefix "/products", so long as the
///   destination port is either 80 or 443.
///
///  .. code-block:: yaml
///
///   action: ALLOW
///   policies:
///     "service-admin":
///       permissions:
///         - any: true
///       principals:
///         - authenticated:
///             principal_name:
///               exact: "cluster.local/ns/default/sa/admin"
///         - authenticated:
///             principal_name:
///               exact: "cluster.local/ns/default/sa/superuser"
///     "product-viewer":
///       permissions:
///           - and_rules:
///               rules:
///                 - header: { name: ":method", exact_match: "GET" }
///                 - url_path:
///                     path: { prefix: "/products" }
///                 - or_rules:
///                     rules:
///                       - destination_port: 80
///                       - destination_port: 443
///       principals:
///         - any: true
public struct Envoy_Config_Rbac_V2_RBAC {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The action to take if a policy matches. The request is allowed if and only if:
  ///
  ///   * `action` is "ALLOWED" and at least one policy matches
  ///   * `action` is "DENY" and none of the policies match
  public var action: Envoy_Config_Rbac_V2_RBAC.Action = .allow

  /// Maps from policy name to policy. A match occurs when at least one policy matches the request.
  public var policies: Dictionary<String,Envoy_Config_Rbac_V2_Policy> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Should we do safe-list or block-list style access control?
  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The policies grant access to principals. The rest is denied. This is safe-list style
    /// access control. This is the default type.
    case allow // = 0

    /// The policies deny access to principals. The rest is allowed. This is block-list style
    /// access control.
    case deny // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .allow
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allow
      case 1: self = .deny
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .allow: return 0
      case .deny: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Config_Rbac_V2_RBAC.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Rbac_V2_RBAC.Action] = [
    .allow,
    .deny,
  ]
}

#endif  // swift(>=4.2)

/// Policy specifies a role and the principals that are assigned/denied the role. A policy matches if
/// and only if at least one of its permissions match the action taking place AND at least one of its
/// principals match the downstream AND the condition is true if specified.
public struct Envoy_Config_Rbac_V2_Policy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The set of permissions that define a role. Each permission is matched with OR
  /// semantics. To match all actions for this policy, a single Permission with the `any` field set
  /// to true should be used.
  public var permissions: [Envoy_Config_Rbac_V2_Permission] = []

  /// Required. The set of principals that are assigned/denied the role based on “action”. Each
  /// principal is matched with OR semantics. To match all downstreams for this policy, a single
  /// Principal with the `any` field set to true should be used.
  public var principals: [Envoy_Config_Rbac_V2_Principal] = []

  /// An optional symbolic expression specifying an access control
  /// :ref:`condition <arch_overview_condition>`. The condition is combined
  /// with the permissions and the principals as a clause with AND semantics.
  public var condition: Google_Api_Expr_V1alpha1_Expr {
    get {return _condition ?? Google_Api_Expr_V1alpha1_Expr()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _condition: Google_Api_Expr_V1alpha1_Expr? = nil
}

/// Permission defines an action (or actions) that a principal can take.
/// [#next-free-field: 11]
public struct Envoy_Config_Rbac_V2_Permission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rule: OneOf_Rule? {
    get {return _storage._rule}
    set {_uniqueStorage()._rule = newValue}
  }

  /// A set of rules that all must match in order to define the action.
  public var andRules: Envoy_Config_Rbac_V2_Permission.Set {
    get {
      if case .andRules(let v)? = _storage._rule {return v}
      return Envoy_Config_Rbac_V2_Permission.Set()
    }
    set {_uniqueStorage()._rule = .andRules(newValue)}
  }

  /// A set of rules where at least one must match in order to define the action.
  public var orRules: Envoy_Config_Rbac_V2_Permission.Set {
    get {
      if case .orRules(let v)? = _storage._rule {return v}
      return Envoy_Config_Rbac_V2_Permission.Set()
    }
    set {_uniqueStorage()._rule = .orRules(newValue)}
  }

  /// When any is set, it matches any action.
  public var any: Bool {
    get {
      if case .any(let v)? = _storage._rule {return v}
      return false
    }
    set {_uniqueStorage()._rule = .any(newValue)}
  }

  /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
  /// available for HTTP request.
  /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
  /// field if you want to match the URL path without the query and fragment string.
  public var header: Envoy_Api_V2_Route_HeaderMatcher {
    get {
      if case .header(let v)? = _storage._rule {return v}
      return Envoy_Api_V2_Route_HeaderMatcher()
    }
    set {_uniqueStorage()._rule = .header(newValue)}
  }

  /// A URL path on the incoming HTTP request. Only available for HTTP.
  public var urlPath: Envoy_Type_Matcher_PathMatcher {
    get {
      if case .urlPath(let v)? = _storage._rule {return v}
      return Envoy_Type_Matcher_PathMatcher()
    }
    set {_uniqueStorage()._rule = .urlPath(newValue)}
  }

  /// A CIDR block that describes the destination IP.
  public var destinationIp: Envoy_Api_V2_Core_CidrRange {
    get {
      if case .destinationIp(let v)? = _storage._rule {return v}
      return Envoy_Api_V2_Core_CidrRange()
    }
    set {_uniqueStorage()._rule = .destinationIp(newValue)}
  }

  /// A port number that describes the destination port connecting to.
  public var destinationPort: UInt32 {
    get {
      if case .destinationPort(let v)? = _storage._rule {return v}
      return 0
    }
    set {_uniqueStorage()._rule = .destinationPort(newValue)}
  }

  /// Metadata that describes additional information about the action.
  public var metadata: Envoy_Type_Matcher_MetadataMatcher {
    get {
      if case .metadata(let v)? = _storage._rule {return v}
      return Envoy_Type_Matcher_MetadataMatcher()
    }
    set {_uniqueStorage()._rule = .metadata(newValue)}
  }

  /// Negates matching the provided permission. For instance, if the value of `not_rule` would
  /// match, this permission would not match. Conversely, if the value of `not_rule` would not
  /// match, this permission would match.
  public var notRule: Envoy_Config_Rbac_V2_Permission {
    get {
      if case .notRule(let v)? = _storage._rule {return v}
      return Envoy_Config_Rbac_V2_Permission()
    }
    set {_uniqueStorage()._rule = .notRule(newValue)}
  }

  /// The request server from the client's connection request. This is
  /// typically TLS SNI.
  ///
  /// .. attention::
  ///
  ///   The behavior of this field may be affected by how Envoy is configured
  ///   as explained below.
  ///
  ///   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
  ///     filter is not added, and if a `FilterChainMatch` is not defined for
  ///     the :ref:`server name <envoy_api_field_listener.FilterChainMatch.server_names>`,
  ///     a TLS connection's requested SNI server name will be treated as if it
  ///     wasn't present.
  ///
  ///   * A :ref:`listener filter <arch_overview_listener_filters>` may
  ///     overwrite a connection's requested server name within Envoy.
  ///
  /// Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
  /// setup SNI.
  public var requestedServerName: Envoy_Type_Matcher_StringMatcher {
    get {
      if case .requestedServerName(let v)? = _storage._rule {return v}
      return Envoy_Type_Matcher_StringMatcher()
    }
    set {_uniqueStorage()._rule = .requestedServerName(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rule: Equatable {
    /// A set of rules that all must match in order to define the action.
    case andRules(Envoy_Config_Rbac_V2_Permission.Set)
    /// A set of rules where at least one must match in order to define the action.
    case orRules(Envoy_Config_Rbac_V2_Permission.Set)
    /// When any is set, it matches any action.
    case any(Bool)
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    /// field if you want to match the URL path without the query and fragment string.
    case header(Envoy_Api_V2_Route_HeaderMatcher)
    /// A URL path on the incoming HTTP request. Only available for HTTP.
    case urlPath(Envoy_Type_Matcher_PathMatcher)
    /// A CIDR block that describes the destination IP.
    case destinationIp(Envoy_Api_V2_Core_CidrRange)
    /// A port number that describes the destination port connecting to.
    case destinationPort(UInt32)
    /// Metadata that describes additional information about the action.
    case metadata(Envoy_Type_Matcher_MetadataMatcher)
    /// Negates matching the provided permission. For instance, if the value of `not_rule` would
    /// match, this permission would not match. Conversely, if the value of `not_rule` would not
    /// match, this permission would match.
    case notRule(Envoy_Config_Rbac_V2_Permission)
    /// The request server from the client's connection request. This is
    /// typically TLS SNI.
    ///
    /// .. attention::
    ///
    ///   The behavior of this field may be affected by how Envoy is configured
    ///   as explained below.
    ///
    ///   * If the :ref:`TLS Inspector <config_listener_filters_tls_inspector>`
    ///     filter is not added, and if a `FilterChainMatch` is not defined for
    ///     the :ref:`server name <envoy_api_field_listener.FilterChainMatch.server_names>`,
    ///     a TLS connection's requested SNI server name will be treated as if it
    ///     wasn't present.
    ///
    ///   * A :ref:`listener filter <arch_overview_listener_filters>` may
    ///     overwrite a connection's requested server name within Envoy.
    ///
    /// Please refer to :ref:`this FAQ entry <faq_how_to_setup_sni>` to learn to
    /// setup SNI.
    case requestedServerName(Envoy_Type_Matcher_StringMatcher)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Rbac_V2_Permission.OneOf_Rule, rhs: Envoy_Config_Rbac_V2_Permission.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.andRules, .andRules): return {
        guard case .andRules(let l) = lhs, case .andRules(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orRules, .orRules): return {
        guard case .orRules(let l) = lhs, case .orRules(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.any, .any): return {
        guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.header, .header): return {
        guard case .header(let l) = lhs, case .header(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.urlPath, .urlPath): return {
        guard case .urlPath(let l) = lhs, case .urlPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destinationIp, .destinationIp): return {
        guard case .destinationIp(let l) = lhs, case .destinationIp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.destinationPort, .destinationPort): return {
        guard case .destinationPort(let l) = lhs, case .destinationPort(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metadata, .metadata): return {
        guard case .metadata(let l) = lhs, case .metadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notRule, .notRule): return {
        guard case .notRule(let l) = lhs, case .notRule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestedServerName, .requestedServerName): return {
        guard case .requestedServerName(let l) = lhs, case .requestedServerName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Used in the `and_rules` and `or_rules` fields in the `rule` oneof. Depending on the context,
  /// each are applied with the associated behavior.
  public struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var rules: [Envoy_Config_Rbac_V2_Permission] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Principal defines an identity or a group of identities for a downstream subject.
/// [#next-free-field: 12]
public struct Envoy_Config_Rbac_V2_Principal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifier: OneOf_Identifier? {
    get {return _storage._identifier}
    set {_uniqueStorage()._identifier = newValue}
  }

  /// A set of identifiers that all must match in order to define the downstream.
  public var andIds: Envoy_Config_Rbac_V2_Principal.Set {
    get {
      if case .andIds(let v)? = _storage._identifier {return v}
      return Envoy_Config_Rbac_V2_Principal.Set()
    }
    set {_uniqueStorage()._identifier = .andIds(newValue)}
  }

  /// A set of identifiers at least one must match in order to define the downstream.
  public var orIds: Envoy_Config_Rbac_V2_Principal.Set {
    get {
      if case .orIds(let v)? = _storage._identifier {return v}
      return Envoy_Config_Rbac_V2_Principal.Set()
    }
    set {_uniqueStorage()._identifier = .orIds(newValue)}
  }

  /// When any is set, it matches any downstream.
  public var any: Bool {
    get {
      if case .any(let v)? = _storage._identifier {return v}
      return false
    }
    set {_uniqueStorage()._identifier = .any(newValue)}
  }

  /// Authenticated attributes that identify the downstream.
  public var authenticated: Envoy_Config_Rbac_V2_Principal.Authenticated {
    get {
      if case .authenticated(let v)? = _storage._identifier {return v}
      return Envoy_Config_Rbac_V2_Principal.Authenticated()
    }
    set {_uniqueStorage()._identifier = .authenticated(newValue)}
  }

  /// A CIDR block that describes the downstream IP.
  /// This address will honor proxy protocol, but will not honor XFF.
  public var sourceIp: Envoy_Api_V2_Core_CidrRange {
    get {
      if case .sourceIp(let v)? = _storage._identifier {return v}
      return Envoy_Api_V2_Core_CidrRange()
    }
    set {_uniqueStorage()._identifier = .sourceIp(newValue)}
  }

  /// A CIDR block that describes the downstream remote/origin address.
  /// Note: This is always the physical peer even if the
  /// :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
  /// from for example the x-forwarder-for header, proxy protocol, etc.
  public var directRemoteIp: Envoy_Api_V2_Core_CidrRange {
    get {
      if case .directRemoteIp(let v)? = _storage._identifier {return v}
      return Envoy_Api_V2_Core_CidrRange()
    }
    set {_uniqueStorage()._identifier = .directRemoteIp(newValue)}
  }

  /// A CIDR block that describes the downstream remote/origin address.
  /// Note: This may not be the physical peer and could be different from the
  /// :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
  /// E.g, if the remote ip is inferred from for example the x-forwarder-for header,
  /// proxy protocol, etc.
  public var remoteIp: Envoy_Api_V2_Core_CidrRange {
    get {
      if case .remoteIp(let v)? = _storage._identifier {return v}
      return Envoy_Api_V2_Core_CidrRange()
    }
    set {_uniqueStorage()._identifier = .remoteIp(newValue)}
  }

  /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
  /// available for HTTP request.
  /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
  /// field if you want to match the URL path without the query and fragment string.
  public var header: Envoy_Api_V2_Route_HeaderMatcher {
    get {
      if case .header(let v)? = _storage._identifier {return v}
      return Envoy_Api_V2_Route_HeaderMatcher()
    }
    set {_uniqueStorage()._identifier = .header(newValue)}
  }

  /// A URL path on the incoming HTTP request. Only available for HTTP.
  public var urlPath: Envoy_Type_Matcher_PathMatcher {
    get {
      if case .urlPath(let v)? = _storage._identifier {return v}
      return Envoy_Type_Matcher_PathMatcher()
    }
    set {_uniqueStorage()._identifier = .urlPath(newValue)}
  }

  /// Metadata that describes additional information about the principal.
  public var metadata: Envoy_Type_Matcher_MetadataMatcher {
    get {
      if case .metadata(let v)? = _storage._identifier {return v}
      return Envoy_Type_Matcher_MetadataMatcher()
    }
    set {_uniqueStorage()._identifier = .metadata(newValue)}
  }

  /// Negates matching the provided principal. For instance, if the value of `not_id` would match,
  /// this principal would not match. Conversely, if the value of `not_id` would not match, this
  /// principal would match.
  public var notID: Envoy_Config_Rbac_V2_Principal {
    get {
      if case .notID(let v)? = _storage._identifier {return v}
      return Envoy_Config_Rbac_V2_Principal()
    }
    set {_uniqueStorage()._identifier = .notID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Identifier: Equatable {
    /// A set of identifiers that all must match in order to define the downstream.
    case andIds(Envoy_Config_Rbac_V2_Principal.Set)
    /// A set of identifiers at least one must match in order to define the downstream.
    case orIds(Envoy_Config_Rbac_V2_Principal.Set)
    /// When any is set, it matches any downstream.
    case any(Bool)
    /// Authenticated attributes that identify the downstream.
    case authenticated(Envoy_Config_Rbac_V2_Principal.Authenticated)
    /// A CIDR block that describes the downstream IP.
    /// This address will honor proxy protocol, but will not honor XFF.
    case sourceIp(Envoy_Api_V2_Core_CidrRange)
    /// A CIDR block that describes the downstream remote/origin address.
    /// Note: This is always the physical peer even if the
    /// :ref:`remote_ip <envoy_api_field_config.rbac.v2.Principal.remote_ip>` is inferred
    /// from for example the x-forwarder-for header, proxy protocol, etc.
    case directRemoteIp(Envoy_Api_V2_Core_CidrRange)
    /// A CIDR block that describes the downstream remote/origin address.
    /// Note: This may not be the physical peer and could be different from the
    /// :ref:`direct_remote_ip <envoy_api_field_config.rbac.v2.Principal.direct_remote_ip>`.
    /// E.g, if the remote ip is inferred from for example the x-forwarder-for header,
    /// proxy protocol, etc.
    case remoteIp(Envoy_Api_V2_Core_CidrRange)
    /// A header (or pseudo-header such as :path or :method) on the incoming HTTP request. Only
    /// available for HTTP request.
    /// Note: the pseudo-header :path includes the query and fragment string. Use the `url_path`
    /// field if you want to match the URL path without the query and fragment string.
    case header(Envoy_Api_V2_Route_HeaderMatcher)
    /// A URL path on the incoming HTTP request. Only available for HTTP.
    case urlPath(Envoy_Type_Matcher_PathMatcher)
    /// Metadata that describes additional information about the principal.
    case metadata(Envoy_Type_Matcher_MetadataMatcher)
    /// Negates matching the provided principal. For instance, if the value of `not_id` would match,
    /// this principal would not match. Conversely, if the value of `not_id` would not match, this
    /// principal would match.
    case notID(Envoy_Config_Rbac_V2_Principal)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Rbac_V2_Principal.OneOf_Identifier, rhs: Envoy_Config_Rbac_V2_Principal.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.andIds, .andIds): return {
        guard case .andIds(let l) = lhs, case .andIds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orIds, .orIds): return {
        guard case .orIds(let l) = lhs, case .orIds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.any, .any): return {
        guard case .any(let l) = lhs, case .any(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.authenticated, .authenticated): return {
        guard case .authenticated(let l) = lhs, case .authenticated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sourceIp, .sourceIp): return {
        guard case .sourceIp(let l) = lhs, case .sourceIp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directRemoteIp, .directRemoteIp): return {
        guard case .directRemoteIp(let l) = lhs, case .directRemoteIp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remoteIp, .remoteIp): return {
        guard case .remoteIp(let l) = lhs, case .remoteIp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.header, .header): return {
        guard case .header(let l) = lhs, case .header(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.urlPath, .urlPath): return {
        guard case .urlPath(let l) = lhs, case .urlPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metadata, .metadata): return {
        guard case .metadata(let l) = lhs, case .metadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notID, .notID): return {
        guard case .notID(let l) = lhs, case .notID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Used in the `and_ids` and `or_ids` fields in the `identifier` oneof. Depending on the context,
  /// each are applied with the associated behavior.
  public struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var ids: [Envoy_Config_Rbac_V2_Principal] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Authentication attributes for a downstream.
  public struct Authenticated {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the principal. If set, The URI SAN or DNS SAN in that order is used from the
    /// certificate, otherwise the subject field is used. If unset, it applies to any user that is
    /// authenticated.
    public var principalName: Envoy_Type_Matcher_StringMatcher {
      get {return _principalName ?? Envoy_Type_Matcher_StringMatcher()}
      set {_principalName = newValue}
    }
    /// Returns true if `principalName` has been explicitly set.
    public var hasPrincipalName: Bool {return self._principalName != nil}
    /// Clears the value of `principalName`. Subsequent reads from it will return its default value.
    public mutating func clearPrincipalName() {self._principalName = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _principalName: Envoy_Type_Matcher_StringMatcher? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.rbac.v2"

extension Envoy_Config_Rbac_V2_RBAC: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RBAC"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "policies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Config_Rbac_V2_Policy>.self, value: &self.policies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.action != .allow {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    if !self.policies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Config_Rbac_V2_Policy>.self, value: self.policies, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_RBAC, rhs: Envoy_Config_Rbac_V2_RBAC) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.policies != rhs.policies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Rbac_V2_RBAC.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW"),
    1: .same(proto: "DENY"),
  ]
}

extension Envoy_Config_Rbac_V2_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
    2: .same(proto: "principals"),
    3: .same(proto: "condition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.principals) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    if !self.principals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.principals, fieldNumber: 2)
    }
    if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_Policy, rhs: Envoy_Config_Rbac_V2_Policy) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.principals != rhs.principals {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Rbac_V2_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "and_rules"),
    2: .standard(proto: "or_rules"),
    3: .same(proto: "any"),
    4: .same(proto: "header"),
    10: .standard(proto: "url_path"),
    5: .standard(proto: "destination_ip"),
    6: .standard(proto: "destination_port"),
    7: .same(proto: "metadata"),
    8: .standard(proto: "not_rule"),
    9: .standard(proto: "requested_server_name"),
  ]

  fileprivate class _StorageClass {
    var _rule: Envoy_Config_Rbac_V2_Permission.OneOf_Rule?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Envoy_Config_Rbac_V2_Permission.Set?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .andRules(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .andRules(v)}
        }()
        case 2: try {
          var v: Envoy_Config_Rbac_V2_Permission.Set?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .orRules(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .orRules(v)}
        }()
        case 3: try {
          if _storage._rule != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._rule = .any(v)}
        }()
        case 4: try {
          var v: Envoy_Api_V2_Route_HeaderMatcher?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .header(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .header(v)}
        }()
        case 5: try {
          var v: Envoy_Api_V2_Core_CidrRange?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .destinationIp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .destinationIp(v)}
        }()
        case 6: try {
          if _storage._rule != nil {try decoder.handleConflictingOneOf()}
          var v: UInt32?
          try decoder.decodeSingularUInt32Field(value: &v)
          if let v = v {_storage._rule = .destinationPort(v)}
        }()
        case 7: try {
          var v: Envoy_Type_Matcher_MetadataMatcher?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .metadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .metadata(v)}
        }()
        case 8: try {
          var v: Envoy_Config_Rbac_V2_Permission?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .notRule(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .notRule(v)}
        }()
        case 9: try {
          var v: Envoy_Type_Matcher_StringMatcher?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .requestedServerName(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .requestedServerName(v)}
        }()
        case 10: try {
          var v: Envoy_Type_Matcher_PathMatcher?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .urlPath(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .urlPath(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._rule {
      case .andRules?: try {
        guard case .andRules(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .orRules?: try {
        guard case .orRules(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .any?: try {
        guard case .any(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }()
      case .header?: try {
        guard case .header(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .destinationIp?: try {
        guard case .destinationIp(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .destinationPort?: try {
        guard case .destinationPort(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
      }()
      case .metadata?: try {
        guard case .metadata(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .notRule?: try {
        guard case .notRule(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .requestedServerName?: try {
        guard case .requestedServerName(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .urlPath?: try {
        guard case .urlPath(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_Permission, rhs: Envoy_Config_Rbac_V2_Permission) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Rbac_V2_Permission.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Rbac_V2_Permission.protoMessageName + ".Set"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_Permission.Set, rhs: Envoy_Config_Rbac_V2_Permission.Set) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Rbac_V2_Principal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Principal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "and_ids"),
    2: .standard(proto: "or_ids"),
    3: .same(proto: "any"),
    4: .same(proto: "authenticated"),
    5: .standard(proto: "source_ip"),
    10: .standard(proto: "direct_remote_ip"),
    11: .standard(proto: "remote_ip"),
    6: .same(proto: "header"),
    9: .standard(proto: "url_path"),
    7: .same(proto: "metadata"),
    8: .standard(proto: "not_id"),
  ]

  fileprivate class _StorageClass {
    var _identifier: Envoy_Config_Rbac_V2_Principal.OneOf_Identifier?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identifier = source._identifier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Envoy_Config_Rbac_V2_Principal.Set?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .andIds(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .andIds(v)}
        }()
        case 2: try {
          var v: Envoy_Config_Rbac_V2_Principal.Set?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .orIds(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .orIds(v)}
        }()
        case 3: try {
          if _storage._identifier != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._identifier = .any(v)}
        }()
        case 4: try {
          var v: Envoy_Config_Rbac_V2_Principal.Authenticated?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .authenticated(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .authenticated(v)}
        }()
        case 5: try {
          var v: Envoy_Api_V2_Core_CidrRange?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .sourceIp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .sourceIp(v)}
        }()
        case 6: try {
          var v: Envoy_Api_V2_Route_HeaderMatcher?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .header(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .header(v)}
        }()
        case 7: try {
          var v: Envoy_Type_Matcher_MetadataMatcher?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .metadata(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .metadata(v)}
        }()
        case 8: try {
          var v: Envoy_Config_Rbac_V2_Principal?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .notID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .notID(v)}
        }()
        case 9: try {
          var v: Envoy_Type_Matcher_PathMatcher?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .urlPath(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .urlPath(v)}
        }()
        case 10: try {
          var v: Envoy_Api_V2_Core_CidrRange?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .directRemoteIp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .directRemoteIp(v)}
        }()
        case 11: try {
          var v: Envoy_Api_V2_Core_CidrRange?
          if let current = _storage._identifier {
            try decoder.handleConflictingOneOf()
            if case .remoteIp(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._identifier = .remoteIp(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._identifier {
      case .andIds?: try {
        guard case .andIds(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .orIds?: try {
        guard case .orIds(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .any?: try {
        guard case .any(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      }()
      case .authenticated?: try {
        guard case .authenticated(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .sourceIp?: try {
        guard case .sourceIp(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .header?: try {
        guard case .header(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .metadata?: try {
        guard case .metadata(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .notID?: try {
        guard case .notID(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .urlPath?: try {
        guard case .urlPath(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .directRemoteIp?: try {
        guard case .directRemoteIp(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .remoteIp?: try {
        guard case .remoteIp(let v)? = _storage._identifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_Principal, rhs: Envoy_Config_Rbac_V2_Principal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identifier != rhs_storage._identifier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Rbac_V2_Principal.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Rbac_V2_Principal.protoMessageName + ".Set"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_Principal.Set, rhs: Envoy_Config_Rbac_V2_Principal.Set) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Rbac_V2_Principal.Authenticated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Rbac_V2_Principal.protoMessageName + ".Authenticated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "principal_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._principalName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._principalName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Rbac_V2_Principal.Authenticated, rhs: Envoy_Config_Rbac_V2_Principal.Authenticated) -> Bool {
    if lhs._principalName != rhs._principalName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

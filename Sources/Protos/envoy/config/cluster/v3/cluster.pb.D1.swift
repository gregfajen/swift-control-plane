// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/cluster/v3/cluster.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration for a single upstream cluster.
/// [#next-free-field: 48]
public struct Envoy_Config_Cluster_V3_Cluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration to use different transport sockets for different endpoints.
  /// The entry of *envoy.transport_socket_match* in the
  /// :ref:`LbEndpoint.Metadata <envoy_api_field_config.endpoint.v3.LbEndpoint.metadata>`
  /// is used to match against the transport sockets as they appear in the list. The first
  /// :ref:`match <envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` is used.
  /// For example, with the following match
  ///
  /// .. code-block:: yaml
  ///
  ///  transport_socket_matches:
  ///  - name: "enableMTLS"
  ///    match:
  ///      acceptMTLS: true
  ///    transport_socket:
  ///      name: envoy.transport_sockets.tls
  ///      config: { ... } # tls socket configuration
  ///  - name: "defaultToPlaintext"
  ///    match: {}
  ///    transport_socket:
  ///      name: envoy.transport_sockets.raw_buffer
  ///
  /// Connections to the endpoints whose metadata value under *envoy.transport_socket_match*
  /// having "acceptMTLS"/"true" key/value pair use the "enableMTLS" socket configuration.
  ///
  /// If a :ref:`socket match <envoy_api_msg_config.cluster.v3.Cluster.TransportSocketMatch>` with empty match
  /// criteria is provided, that always match any endpoint. For example, the "defaultToPlaintext"
  /// socket match in case above.
  ///
  /// If an endpoint metadata's value under *envoy.transport_socket_match* does not match any
  /// *TransportSocketMatch*, socket configuration fallbacks to use the *tls_context* or
  /// *transport_socket* specified in this cluster.
  ///
  /// This field allows gradual and flexible transport socket configuration changes.
  ///
  /// The metadata of endpoints in EDS can indicate transport socket capabilities. For example,
  /// an endpoint's metadata can have two key value pairs as "acceptMTLS": "true",
  /// "acceptPlaintext": "true". While some other endpoints, only accepting plaintext traffic
  /// has "acceptPlaintext": "true" metadata information.
  ///
  /// Then the xDS server can configure the CDS to a client, Envoy A, to send mutual TLS
  /// traffic for endpoints with "acceptMTLS": "true", by adding a corresponding
  /// *TransportSocketMatch* in this field. Other client Envoys receive CDS without
  /// *transport_socket_match* set, and still send plain text traffic to the same cluster.
  ///
  /// This field can be used to specify custom transport socket configurations for health
  /// checks by adding matching key/value pairs in a health check's
  /// :ref:`transport socket match criteria <envoy_api_field_config.core.v3.HealthCheck.transport_socket_match_criteria>` field.
  ///
  /// [#comment:TODO(incfly): add a detailed architecture doc on intended usage.]
  public var transportSocketMatches: [Envoy_Config_Cluster_V3_Cluster.TransportSocketMatch] {
    get {return _storage._transportSocketMatches}
    set {_uniqueStorage()._transportSocketMatches = newValue}
  }

  /// Supplies the name of the cluster which must be unique across all clusters.
  /// The cluster name is used when emitting
  /// :ref:`statistics <config_cluster_manager_cluster_stats>` if :ref:`alt_stat_name
  /// <envoy_api_field_config.cluster.v3.Cluster.alt_stat_name>` is not provided.
  /// Any ``:`` in the cluster name will be converted to ``_`` when emitting statistics.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// An optional alternative to the cluster name to be used while emitting stats.
  /// Any ``:`` in the name will be converted to ``_`` when emitting statistics. This should not be
  /// confused with :ref:`Router Filter Header
  /// <config_http_filters_router_x-envoy-upstream-alt-stat-name>`.
  public var altStatName: String {
    get {return _storage._altStatName}
    set {_uniqueStorage()._altStatName = newValue}
  }

  public var clusterDiscoveryType: OneOf_ClusterDiscoveryType? {
    get {return _storage._clusterDiscoveryType}
    set {_uniqueStorage()._clusterDiscoveryType = newValue}
  }

  /// The :ref:`service discovery type <arch_overview_service_discovery_types>`
  /// to use for resolving the cluster.
  public var type: Envoy_Config_Cluster_V3_Cluster.DiscoveryType {
    get {
      if case .type(let v)? = _storage._clusterDiscoveryType {return v}
      return .static
    }
    set {_uniqueStorage()._clusterDiscoveryType = .type(newValue)}
  }

  /// The custom cluster type.
  public var clusterType: Envoy_Config_Cluster_V3_Cluster.CustomClusterType {
    get {
      if case .clusterType(let v)? = _storage._clusterDiscoveryType {return v}
      return Envoy_Config_Cluster_V3_Cluster.CustomClusterType()
    }
    set {_uniqueStorage()._clusterDiscoveryType = .clusterType(newValue)}
  }

  /// Configuration to use for EDS updates for the Cluster.
  public var edsClusterConfig: Envoy_Config_Cluster_V3_Cluster.EdsClusterConfig {
    get {return _storage._edsClusterConfig ?? Envoy_Config_Cluster_V3_Cluster.EdsClusterConfig()}
    set {_uniqueStorage()._edsClusterConfig = newValue}
  }
  /// Returns true if `edsClusterConfig` has been explicitly set.
  public var hasEdsClusterConfig: Bool {return _storage._edsClusterConfig != nil}
  /// Clears the value of `edsClusterConfig`. Subsequent reads from it will return its default value.
  public mutating func clearEdsClusterConfig() {_uniqueStorage()._edsClusterConfig = nil}

  /// The timeout for new network connections to hosts in the cluster.
  public var connectTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._connectTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._connectTimeout = newValue}
  }
  /// Returns true if `connectTimeout` has been explicitly set.
  public var hasConnectTimeout: Bool {return _storage._connectTimeout != nil}
  /// Clears the value of `connectTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearConnectTimeout() {_uniqueStorage()._connectTimeout = nil}

  /// Soft limit on size of the clusterâ€™s connections read and write buffers. If
  /// unspecified, an implementation defined default is applied (1MiB).
  public var perConnectionBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._perConnectionBufferLimitBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._perConnectionBufferLimitBytes = newValue}
  }
  /// Returns true if `perConnectionBufferLimitBytes` has been explicitly set.
  public var hasPerConnectionBufferLimitBytes: Bool {return _storage._perConnectionBufferLimitBytes != nil}
  /// Clears the value of `perConnectionBufferLimitBytes`. Subsequent reads from it will return its default value.
  public mutating func clearPerConnectionBufferLimitBytes() {_uniqueStorage()._perConnectionBufferLimitBytes = nil}

  /// The :ref:`load balancer type <arch_overview_load_balancing_types>` to use
  /// when picking a host in the cluster.
  public var lbPolicy: Envoy_Config_Cluster_V3_Cluster.LbPolicy {
    get {return _storage._lbPolicy}
    set {_uniqueStorage()._lbPolicy = newValue}
  }

  /// Setting this is required for specifying members of
  /// :ref:`STATIC<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STATIC>`,
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  /// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` clusters.
  /// This field supersedes the *hosts* field in the v2 API.
  ///
  /// .. attention::
  ///
  ///   Setting this allows non-EDS cluster types to contain embedded EDS equivalent
  ///   :ref:`endpoint assignments<envoy_api_msg_config.endpoint.v3.ClusterLoadAssignment>`.
  public var loadAssignment: Envoy_Config_Endpoint_V3_ClusterLoadAssignment {
    get {return _storage._loadAssignment ?? Envoy_Config_Endpoint_V3_ClusterLoadAssignment()}
    set {_uniqueStorage()._loadAssignment = newValue}
  }
  /// Returns true if `loadAssignment` has been explicitly set.
  public var hasLoadAssignment: Bool {return _storage._loadAssignment != nil}
  /// Clears the value of `loadAssignment`. Subsequent reads from it will return its default value.
  public mutating func clearLoadAssignment() {_uniqueStorage()._loadAssignment = nil}

  /// Optional :ref:`active health checking <arch_overview_health_checking>`
  /// configuration for the cluster. If no
  /// configuration is specified no health checking will be done and all cluster
  /// members will be considered healthy at all times.
  public var healthChecks: [Envoy_Config_Core_V3_HealthCheck] {
    get {return _storage._healthChecks}
    set {_uniqueStorage()._healthChecks = newValue}
  }

  /// Optional maximum requests for a single upstream connection. This parameter
  /// is respected by both the HTTP/1.1 and HTTP/2 connection pool
  /// implementations. If not specified, there is no limit. Setting this
  /// parameter to 1 will effectively disable keep alive.
  public var maxRequestsPerConnection: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxRequestsPerConnection ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxRequestsPerConnection = newValue}
  }
  /// Returns true if `maxRequestsPerConnection` has been explicitly set.
  public var hasMaxRequestsPerConnection: Bool {return _storage._maxRequestsPerConnection != nil}
  /// Clears the value of `maxRequestsPerConnection`. Subsequent reads from it will return its default value.
  public mutating func clearMaxRequestsPerConnection() {_uniqueStorage()._maxRequestsPerConnection = nil}

  /// Optional :ref:`circuit breaking <arch_overview_circuit_break>` for the cluster.
  public var circuitBreakers: Envoy_Config_Cluster_V3_CircuitBreakers {
    get {return _storage._circuitBreakers ?? Envoy_Config_Cluster_V3_CircuitBreakers()}
    set {_uniqueStorage()._circuitBreakers = newValue}
  }
  /// Returns true if `circuitBreakers` has been explicitly set.
  public var hasCircuitBreakers: Bool {return _storage._circuitBreakers != nil}
  /// Clears the value of `circuitBreakers`. Subsequent reads from it will return its default value.
  public mutating func clearCircuitBreakers() {_uniqueStorage()._circuitBreakers = nil}

  /// HTTP protocol options that are applied only to upstream HTTP connections.
  /// These options apply to all HTTP versions.
  public var upstreamHTTPProtocolOptions: Envoy_Config_Core_V3_UpstreamHttpProtocolOptions {
    get {return _storage._upstreamHTTPProtocolOptions ?? Envoy_Config_Core_V3_UpstreamHttpProtocolOptions()}
    set {_uniqueStorage()._upstreamHTTPProtocolOptions = newValue}
  }
  /// Returns true if `upstreamHTTPProtocolOptions` has been explicitly set.
  public var hasUpstreamHTTPProtocolOptions: Bool {return _storage._upstreamHTTPProtocolOptions != nil}
  /// Clears the value of `upstreamHTTPProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamHTTPProtocolOptions() {_uniqueStorage()._upstreamHTTPProtocolOptions = nil}

  /// Additional options when handling HTTP requests upstream. These options will be applicable to
  /// both HTTP1 and HTTP2 requests.
  public var commonHTTPProtocolOptions: Envoy_Config_Core_V3_HttpProtocolOptions {
    get {return _storage._commonHTTPProtocolOptions ?? Envoy_Config_Core_V3_HttpProtocolOptions()}
    set {_uniqueStorage()._commonHTTPProtocolOptions = newValue}
  }
  /// Returns true if `commonHTTPProtocolOptions` has been explicitly set.
  public var hasCommonHTTPProtocolOptions: Bool {return _storage._commonHTTPProtocolOptions != nil}
  /// Clears the value of `commonHTTPProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearCommonHTTPProtocolOptions() {_uniqueStorage()._commonHTTPProtocolOptions = nil}

  /// Additional options when handling HTTP1 requests.
  public var httpProtocolOptions: Envoy_Config_Core_V3_Http1ProtocolOptions {
    get {return _storage._httpProtocolOptions ?? Envoy_Config_Core_V3_Http1ProtocolOptions()}
    set {_uniqueStorage()._httpProtocolOptions = newValue}
  }
  /// Returns true if `httpProtocolOptions` has been explicitly set.
  public var hasHTTPProtocolOptions: Bool {return _storage._httpProtocolOptions != nil}
  /// Clears the value of `httpProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPProtocolOptions() {_uniqueStorage()._httpProtocolOptions = nil}

  /// Even if default HTTP2 protocol options are desired, this field must be
  /// set so that Envoy will assume that the upstream supports HTTP/2 when
  /// making new HTTP connection pool connections. Currently, Envoy only
  /// supports prior knowledge for upstream connections. Even if TLS is used
  /// with ALPN, `http2_protocol_options` must be specified. As an aside this allows HTTP/2
  /// connections to happen over plain text.
  public var http2ProtocolOptions: Envoy_Config_Core_V3_Http2ProtocolOptions {
    get {return _storage._http2ProtocolOptions ?? Envoy_Config_Core_V3_Http2ProtocolOptions()}
    set {_uniqueStorage()._http2ProtocolOptions = newValue}
  }
  /// Returns true if `http2ProtocolOptions` has been explicitly set.
  public var hasHTTP2ProtocolOptions: Bool {return _storage._http2ProtocolOptions != nil}
  /// Clears the value of `http2ProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearHTTP2ProtocolOptions() {_uniqueStorage()._http2ProtocolOptions = nil}

  /// The extension_protocol_options field is used to provide extension-specific protocol options
  /// for upstream connections. The key should match the extension filter name, such as
  /// "envoy.filters.network.thrift_proxy". See the extension's documentation for details on
  /// specific options.
  public var typedExtensionProtocolOptions: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> {
    get {return _storage._typedExtensionProtocolOptions}
    set {_uniqueStorage()._typedExtensionProtocolOptions = newValue}
  }

  /// If the DNS refresh rate is specified and the cluster type is either
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  /// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  /// this value is used as the clusterâ€™s DNS refresh
  /// rate. The value configured must be at least 1ms. If this setting is not specified, the
  /// value defaults to 5000ms. For cluster types other than
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  /// and :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
  /// this setting is ignored.
  public var dnsRefreshRate: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._dnsRefreshRate ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._dnsRefreshRate = newValue}
  }
  /// Returns true if `dnsRefreshRate` has been explicitly set.
  public var hasDnsRefreshRate: Bool {return _storage._dnsRefreshRate != nil}
  /// Clears the value of `dnsRefreshRate`. Subsequent reads from it will return its default value.
  public mutating func clearDnsRefreshRate() {_uniqueStorage()._dnsRefreshRate = nil}

  /// If the DNS failure refresh rate is specified and the cluster type is either
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  /// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  /// this is used as the clusterâ€™s DNS refresh rate when requests are failing. If this setting is
  /// not specified, the failure refresh rate defaults to the DNS refresh rate. For cluster types
  /// other than :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
  /// :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>` this setting is
  /// ignored.
  public var dnsFailureRefreshRate: Envoy_Config_Cluster_V3_Cluster.RefreshRate {
    get {return _storage._dnsFailureRefreshRate ?? Envoy_Config_Cluster_V3_Cluster.RefreshRate()}
    set {_uniqueStorage()._dnsFailureRefreshRate = newValue}
  }
  /// Returns true if `dnsFailureRefreshRate` has been explicitly set.
  public var hasDnsFailureRefreshRate: Bool {return _storage._dnsFailureRefreshRate != nil}
  /// Clears the value of `dnsFailureRefreshRate`. Subsequent reads from it will return its default value.
  public mutating func clearDnsFailureRefreshRate() {_uniqueStorage()._dnsFailureRefreshRate = nil}

  /// Optional configuration for setting cluster's DNS refresh rate. If the value is set to true,
  /// cluster's DNS refresh rate will be set to resource record's TTL which comes from DNS
  /// resolution.
  public var respectDnsTtl: Bool {
    get {return _storage._respectDnsTtl}
    set {_uniqueStorage()._respectDnsTtl = newValue}
  }

  /// The DNS IP address resolution policy. If this setting is not specified, the
  /// value defaults to
  /// :ref:`AUTO<envoy_api_enum_value_config.cluster.v3.Cluster.DnsLookupFamily.AUTO>`.
  public var dnsLookupFamily: Envoy_Config_Cluster_V3_Cluster.DnsLookupFamily {
    get {return _storage._dnsLookupFamily}
    set {_uniqueStorage()._dnsLookupFamily = newValue}
  }

  /// If DNS resolvers are specified and the cluster type is either
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`,
  /// or :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  /// this value is used to specify the clusterâ€™s dns resolvers.
  /// If this setting is not specified, the value defaults to the default
  /// resolver, which uses /etc/resolv.conf for configuration. For cluster types
  /// other than
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>`
  /// and :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`
  /// this setting is ignored.
  public var dnsResolvers: [Envoy_Config_Core_V3_Address] {
    get {return _storage._dnsResolvers}
    set {_uniqueStorage()._dnsResolvers = newValue}
  }

  /// [#next-major-version: Reconcile DNS options in a single message.]
  /// Always use TCP queries instead of UDP queries for DNS lookups.
  public var useTcpForDnsLookups: Bool {
    get {return _storage._useTcpForDnsLookups}
    set {_uniqueStorage()._useTcpForDnsLookups = newValue}
  }

  /// If specified, outlier detection will be enabled for this upstream cluster.
  /// Each of the configuration values can be overridden via
  /// :ref:`runtime values <config_cluster_manager_cluster_runtime_outlier_detection>`.
  public var outlierDetection: Envoy_Config_Cluster_V3_OutlierDetection {
    get {return _storage._outlierDetection ?? Envoy_Config_Cluster_V3_OutlierDetection()}
    set {_uniqueStorage()._outlierDetection = newValue}
  }
  /// Returns true if `outlierDetection` has been explicitly set.
  public var hasOutlierDetection: Bool {return _storage._outlierDetection != nil}
  /// Clears the value of `outlierDetection`. Subsequent reads from it will return its default value.
  public mutating func clearOutlierDetection() {_uniqueStorage()._outlierDetection = nil}

  /// The interval for removing stale hosts from a cluster type
  /// :ref:`ORIGINAL_DST<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`.
  /// Hosts are considered stale if they have not been used
  /// as upstream destinations during this interval. New hosts are added
  /// to original destination clusters on demand as new connections are
  /// redirected to Envoy, causing the number of hosts in the cluster to
  /// grow over time. Hosts that are not stale (they are actively used as
  /// destinations) are kept in the cluster, which allows connections to
  /// them remain open, saving the latency that would otherwise be spent
  /// on opening new connections. If this setting is not specified, the
  /// value defaults to 5000ms. For cluster types other than
  /// :ref:`ORIGINAL_DST<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.ORIGINAL_DST>`
  /// this setting is ignored.
  public var cleanupInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._cleanupInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._cleanupInterval = newValue}
  }
  /// Returns true if `cleanupInterval` has been explicitly set.
  public var hasCleanupInterval: Bool {return _storage._cleanupInterval != nil}
  /// Clears the value of `cleanupInterval`. Subsequent reads from it will return its default value.
  public mutating func clearCleanupInterval() {_uniqueStorage()._cleanupInterval = nil}

  /// Optional configuration used to bind newly established upstream connections.
  /// This overrides any bind_config specified in the bootstrap proto.
  /// If the address and port are empty, no bind will be performed.
  public var upstreamBindConfig: Envoy_Config_Core_V3_BindConfig {
    get {return _storage._upstreamBindConfig ?? Envoy_Config_Core_V3_BindConfig()}
    set {_uniqueStorage()._upstreamBindConfig = newValue}
  }
  /// Returns true if `upstreamBindConfig` has been explicitly set.
  public var hasUpstreamBindConfig: Bool {return _storage._upstreamBindConfig != nil}
  /// Clears the value of `upstreamBindConfig`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamBindConfig() {_uniqueStorage()._upstreamBindConfig = nil}

  /// Configuration for load balancing subsetting.
  public var lbSubsetConfig: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig {
    get {return _storage._lbSubsetConfig ?? Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig()}
    set {_uniqueStorage()._lbSubsetConfig = newValue}
  }
  /// Returns true if `lbSubsetConfig` has been explicitly set.
  public var hasLbSubsetConfig: Bool {return _storage._lbSubsetConfig != nil}
  /// Clears the value of `lbSubsetConfig`. Subsequent reads from it will return its default value.
  public mutating func clearLbSubsetConfig() {_uniqueStorage()._lbSubsetConfig = nil}

  /// Optional configuration for the load balancing algorithm selected by
  /// LbPolicy. Currently only
  /// :ref:`RING_HASH<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>` and
  /// :ref:`LEAST_REQUEST<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  /// has additional configuration options.
  /// Specifying ring_hash_lb_config or least_request_lb_config without setting the corresponding
  /// LbPolicy will generate an error at runtime.
  public var lbConfig: OneOf_LbConfig? {
    get {return _storage._lbConfig}
    set {_uniqueStorage()._lbConfig = newValue}
  }

  /// Optional configuration for the Ring Hash load balancing policy.
  public var ringHashLbConfig: Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig {
    get {
      if case .ringHashLbConfig(let v)? = _storage._lbConfig {return v}
      return Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig()
    }
    set {_uniqueStorage()._lbConfig = .ringHashLbConfig(newValue)}
  }

  /// Optional configuration for the Original Destination load balancing policy.
  public var originalDstLbConfig: Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig {
    get {
      if case .originalDstLbConfig(let v)? = _storage._lbConfig {return v}
      return Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig()
    }
    set {_uniqueStorage()._lbConfig = .originalDstLbConfig(newValue)}
  }

  /// Optional configuration for the LeastRequest load balancing policy.
  public var leastRequestLbConfig: Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig {
    get {
      if case .leastRequestLbConfig(let v)? = _storage._lbConfig {return v}
      return Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig()
    }
    set {_uniqueStorage()._lbConfig = .leastRequestLbConfig(newValue)}
  }

  /// Common configuration for all load balancer implementations.
  public var commonLbConfig: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig {
    get {return _storage._commonLbConfig ?? Envoy_Config_Cluster_V3_Cluster.CommonLbConfig()}
    set {_uniqueStorage()._commonLbConfig = newValue}
  }
  /// Returns true if `commonLbConfig` has been explicitly set.
  public var hasCommonLbConfig: Bool {return _storage._commonLbConfig != nil}
  /// Clears the value of `commonLbConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCommonLbConfig() {_uniqueStorage()._commonLbConfig = nil}

  /// Optional custom transport socket implementation to use for upstream connections.
  /// To setup TLS, set a transport socket with name `tls` and
  /// :ref:`UpstreamTlsContexts <envoy_api_msg_extensions.transport_sockets.tls.v3.UpstreamTlsContext>` in the `typed_config`.
  /// If no transport socket configuration is specified, new connections
  /// will be set up with plaintext.
  public var transportSocket: Envoy_Config_Core_V3_TransportSocket {
    get {return _storage._transportSocket ?? Envoy_Config_Core_V3_TransportSocket()}
    set {_uniqueStorage()._transportSocket = newValue}
  }
  /// Returns true if `transportSocket` has been explicitly set.
  public var hasTransportSocket: Bool {return _storage._transportSocket != nil}
  /// Clears the value of `transportSocket`. Subsequent reads from it will return its default value.
  public mutating func clearTransportSocket() {_uniqueStorage()._transportSocket = nil}

  /// The Metadata field can be used to provide additional information about the
  /// cluster. It can be used for stats, logging, and varying filter behavior.
  /// Fields should use reverse DNS notation to denote which entity within Envoy
  /// will need the information. For instance, if the metadata is intended for
  /// the Router filter, the filter name should be specified as *envoy.filters.http.router*.
  public var metadata: Envoy_Config_Core_V3_Metadata {
    get {return _storage._metadata ?? Envoy_Config_Core_V3_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Determines how Envoy selects the protocol used to speak to upstream hosts.
  public var protocolSelection: Envoy_Config_Cluster_V3_Cluster.ClusterProtocolSelection {
    get {return _storage._protocolSelection}
    set {_uniqueStorage()._protocolSelection = newValue}
  }

  /// Optional options for upstream connections.
  public var upstreamConnectionOptions: Envoy_Config_Cluster_V3_UpstreamConnectionOptions {
    get {return _storage._upstreamConnectionOptions ?? Envoy_Config_Cluster_V3_UpstreamConnectionOptions()}
    set {_uniqueStorage()._upstreamConnectionOptions = newValue}
  }
  /// Returns true if `upstreamConnectionOptions` has been explicitly set.
  public var hasUpstreamConnectionOptions: Bool {return _storage._upstreamConnectionOptions != nil}
  /// Clears the value of `upstreamConnectionOptions`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamConnectionOptions() {_uniqueStorage()._upstreamConnectionOptions = nil}

  /// If an upstream host becomes unhealthy (as determined by the configured health checks
  /// or outlier detection), immediately close all connections to the failed host.
  ///
  /// .. note::
  ///
  ///   This is currently only supported for connections created by tcp_proxy.
  ///
  /// .. note::
  ///
  ///   The current implementation of this feature closes all connections immediately when
  ///   the unhealthy status is detected. If there are a large number of connections open
  ///   to an upstream host that becomes unhealthy, Envoy may spend a substantial amount of
  ///   time exclusively closing these connections, and not processing any other traffic.
  public var closeConnectionsOnHostHealthFailure: Bool {
    get {return _storage._closeConnectionsOnHostHealthFailure}
    set {_uniqueStorage()._closeConnectionsOnHostHealthFailure = newValue}
  }

  /// If set to true, Envoy will ignore the health value of a host when processing its removal
  /// from service discovery. This means that if active health checking is used, Envoy will *not*
  /// wait for the endpoint to go unhealthy before removing it.
  public var ignoreHealthOnHostRemoval: Bool {
    get {return _storage._ignoreHealthOnHostRemoval}
    set {_uniqueStorage()._ignoreHealthOnHostRemoval = newValue}
  }

  /// An (optional) network filter chain, listed in the order the filters should be applied.
  /// The chain will be applied to all outgoing connections that Envoy makes to the upstream
  /// servers of this cluster.
  public var filters: [Envoy_Config_Cluster_V3_Filter] {
    get {return _storage._filters}
    set {_uniqueStorage()._filters = newValue}
  }

  /// [#not-implemented-hide:] New mechanism for LB policy configuration. Used only if the
  /// :ref:`lb_policy<envoy_api_field_config.cluster.v3.Cluster.lb_policy>` field has the value
  /// :ref:`LOAD_BALANCING_POLICY_CONFIG<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LOAD_BALANCING_POLICY_CONFIG>`.
  public var loadBalancingPolicy: Envoy_Config_Cluster_V3_LoadBalancingPolicy {
    get {return _storage._loadBalancingPolicy ?? Envoy_Config_Cluster_V3_LoadBalancingPolicy()}
    set {_uniqueStorage()._loadBalancingPolicy = newValue}
  }
  /// Returns true if `loadBalancingPolicy` has been explicitly set.
  public var hasLoadBalancingPolicy: Bool {return _storage._loadBalancingPolicy != nil}
  /// Clears the value of `loadBalancingPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearLoadBalancingPolicy() {_uniqueStorage()._loadBalancingPolicy = nil}

  /// [#not-implemented-hide:]
  /// If present, tells the client where to send load reports via LRS. If not present, the
  /// client will fall back to a client-side default, which may be either (a) don't send any
  /// load reports or (b) send load reports for all clusters to a single default server
  /// (which may be configured in the bootstrap file).
  ///
  /// Note that if multiple clusters point to the same LRS server, the client may choose to
  /// create a separate stream for each cluster or it may choose to coalesce the data for
  /// multiple clusters onto a single stream. Either way, the client must make sure to send
  /// the data for any given cluster on no more than one stream.
  ///
  /// [#next-major-version: In the v3 API, we should consider restructuring this somehow,
  /// maybe by allowing LRS to go on the ADS stream, or maybe by moving some of the negotiation
  /// from the LRS stream here.]
  public var lrsServer: Envoy_Config_Core_V3_ConfigSource {
    get {return _storage._lrsServer ?? Envoy_Config_Core_V3_ConfigSource()}
    set {_uniqueStorage()._lrsServer = newValue}
  }
  /// Returns true if `lrsServer` has been explicitly set.
  public var hasLrsServer: Bool {return _storage._lrsServer != nil}
  /// Clears the value of `lrsServer`. Subsequent reads from it will return its default value.
  public mutating func clearLrsServer() {_uniqueStorage()._lrsServer = nil}

  /// If track_timeout_budgets is true, the :ref:`timeout budget histograms
  /// <config_cluster_manager_cluster_stats_timeout_budgets>` will be published for each
  /// request. These show what percentage of a request's per try and global timeout was used. A value
  /// of 0 would indicate that none of the timeout was used or that the timeout was infinite. A value
  /// of 100 would indicate that the request took the entirety of the timeout given to it.
  public var trackTimeoutBudgets: Bool {
    get {return _storage._trackTimeoutBudgets}
    set {_uniqueStorage()._trackTimeoutBudgets = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterDiscoveryType: Equatable {
    /// The :ref:`service discovery type <arch_overview_service_discovery_types>`
    /// to use for resolving the cluster.
    case type(Envoy_Config_Cluster_V3_Cluster.DiscoveryType)
    /// The custom cluster type.
    case clusterType(Envoy_Config_Cluster_V3_Cluster.CustomClusterType)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.OneOf_ClusterDiscoveryType, rhs: Envoy_Config_Cluster_V3_Cluster.OneOf_ClusterDiscoveryType) -> Bool {
      switch (lhs, rhs) {
      case (.type(let l), .type(let r)): return l == r
      case (.clusterType(let l), .clusterType(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Optional configuration for the load balancing algorithm selected by
  /// LbPolicy. Currently only
  /// :ref:`RING_HASH<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.RING_HASH>` and
  /// :ref:`LEAST_REQUEST<envoy_api_enum_value_config.cluster.v3.Cluster.LbPolicy.LEAST_REQUEST>`
  /// has additional configuration options.
  /// Specifying ring_hash_lb_config or least_request_lb_config without setting the corresponding
  /// LbPolicy will generate an error at runtime.
  public enum OneOf_LbConfig: Equatable {
    /// Optional configuration for the Ring Hash load balancing policy.
    case ringHashLbConfig(Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig)
    /// Optional configuration for the Original Destination load balancing policy.
    case originalDstLbConfig(Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig)
    /// Optional configuration for the LeastRequest load balancing policy.
    case leastRequestLbConfig(Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.OneOf_LbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.OneOf_LbConfig) -> Bool {
      switch (lhs, rhs) {
      case (.ringHashLbConfig(let l), .ringHashLbConfig(let r)): return l == r
      case (.originalDstLbConfig(let l), .originalDstLbConfig(let r)): return l == r
      case (.leastRequestLbConfig(let l), .leastRequestLbConfig(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Refer to :ref:`service discovery type <arch_overview_service_discovery_types>`
  /// for an explanation on each type.
  public enum DiscoveryType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Refer to the :ref:`static discovery type<arch_overview_service_discovery_types_static>`
    /// for an explanation.
    case `static` // = 0

    /// Refer to the :ref:`strict DNS discovery
    /// type<arch_overview_service_discovery_types_strict_dns>`
    /// for an explanation.
    case strictDns // = 1

    /// Refer to the :ref:`logical DNS discovery
    /// type<arch_overview_service_discovery_types_logical_dns>`
    /// for an explanation.
    case logicalDns // = 2

    /// Refer to the :ref:`service discovery type<arch_overview_service_discovery_types_eds>`
    /// for an explanation.
    case eds // = 3

    /// Refer to the :ref:`original destination discovery
    /// type<arch_overview_service_discovery_types_original_destination>`
    /// for an explanation.
    case originalDst // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .static
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .static
      case 1: self = .strictDns
      case 2: self = .logicalDns
      case 3: self = .eds
      case 4: self = .originalDst
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .static: return 0
      case .strictDns: return 1
      case .logicalDns: return 2
      case .eds: return 3
      case .originalDst: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Refer to :ref:`load balancer type <arch_overview_load_balancing_types>` architecture
  /// overview section for information on each type.
  public enum LbPolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Refer to the :ref:`round robin load balancing
    /// policy<arch_overview_load_balancing_types_round_robin>`
    /// for an explanation.
    case roundRobin // = 0

    /// Refer to the :ref:`least request load balancing
    /// policy<arch_overview_load_balancing_types_least_request>`
    /// for an explanation.
    case leastRequest // = 1

    /// Refer to the :ref:`ring hash load balancing
    /// policy<arch_overview_load_balancing_types_ring_hash>`
    /// for an explanation.
    case ringHash // = 2

    /// Refer to the :ref:`random load balancing
    /// policy<arch_overview_load_balancing_types_random>`
    /// for an explanation.
    case random // = 3

    /// Refer to the :ref:`Maglev load balancing policy<arch_overview_load_balancing_types_maglev>`
    /// for an explanation.
    case maglev // = 5

    /// This load balancer type must be specified if the configured cluster provides a cluster
    /// specific load balancer. Consult the configured cluster's documentation for whether to set
    /// this option or not.
    case clusterProvided // = 6

    /// [#not-implemented-hide:] Use the new :ref:`load_balancing_policy
    /// <envoy_api_field_config.cluster.v3.Cluster.load_balancing_policy>` field to determine the LB policy.
    /// [#next-major-version: In the v3 API, we should consider deprecating the lb_policy field
    /// and instead using the new load_balancing_policy field as the one and only mechanism for
    /// configuring this.]
    case loadBalancingPolicyConfig // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .roundRobin
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .roundRobin
      case 1: self = .leastRequest
      case 2: self = .ringHash
      case 3: self = .random
      case 5: self = .maglev
      case 6: self = .clusterProvided
      case 7: self = .loadBalancingPolicyConfig
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .roundRobin: return 0
      case .leastRequest: return 1
      case .ringHash: return 2
      case .random: return 3
      case .maglev: return 5
      case .clusterProvided: return 6
      case .loadBalancingPolicyConfig: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// When V4_ONLY is selected, the DNS resolver will only perform a lookup for
  /// addresses in the IPv4 family. If V6_ONLY is selected, the DNS resolver will
  /// only perform a lookup for addresses in the IPv6 family. If AUTO is
  /// specified, the DNS resolver will first perform a lookup for addresses in
  /// the IPv6 family and fallback to a lookup for addresses in the IPv4 family.
  /// For cluster types other than
  /// :ref:`STRICT_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.STRICT_DNS>` and
  /// :ref:`LOGICAL_DNS<envoy_api_enum_value_config.cluster.v3.Cluster.DiscoveryType.LOGICAL_DNS>`,
  /// this setting is
  /// ignored.
  public enum DnsLookupFamily: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case auto // = 0
    case v4Only // = 1
    case v6Only // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .auto
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .auto
      case 1: self = .v4Only
      case 2: self = .v6Only
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .auto: return 0
      case .v4Only: return 1
      case .v6Only: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ClusterProtocolSelection: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Cluster can only operate on one of the possible upstream protocols (HTTP1.1, HTTP2).
    /// If :ref:`http2_protocol_options <envoy_api_field_config.cluster.v3.Cluster.http2_protocol_options>` are
    /// present, HTTP2 will be used, otherwise HTTP1.1 will be used.
    case useConfiguredProtocol // = 0

    /// Use HTTP1.1 or HTTP2, depending on which one is used on the downstream connection.
    case useDownstreamProtocol // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .useConfiguredProtocol
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .useConfiguredProtocol
      case 1: self = .useDownstreamProtocol
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .useConfiguredProtocol: return 0
      case .useDownstreamProtocol: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// TransportSocketMatch specifies what transport socket config will be used
  /// when the match conditions are satisfied.
  public struct TransportSocketMatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the match, used in stats generation.
    public var name: String = String()

    /// Optional endpoint metadata match criteria.
    /// The connection to the endpoint with metadata matching what is set in this field
    /// will use the transport socket configuration specified here.
    /// The endpoint's metadata entry in *envoy.transport_socket_match* is used to match
    /// against the values specified in this field.
    public var match: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _match ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_match = newValue}
    }
    /// Returns true if `match` has been explicitly set.
    public var hasMatch: Bool {return self._match != nil}
    /// Clears the value of `match`. Subsequent reads from it will return its default value.
    public mutating func clearMatch() {self._match = nil}

    /// The configuration of the transport socket.
    public var transportSocket: Envoy_Config_Core_V3_TransportSocket {
      get {return _transportSocket ?? Envoy_Config_Core_V3_TransportSocket()}
      set {_transportSocket = newValue}
    }
    /// Returns true if `transportSocket` has been explicitly set.
    public var hasTransportSocket: Bool {return self._transportSocket != nil}
    /// Clears the value of `transportSocket`. Subsequent reads from it will return its default value.
    public mutating func clearTransportSocket() {self._transportSocket = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _match: SwiftProtobuf.Google_Protobuf_Struct? = nil
    fileprivate var _transportSocket: Envoy_Config_Core_V3_TransportSocket? = nil
  }

  /// Extended cluster type.
  public struct CustomClusterType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of the cluster to instantiate. The name must match a supported cluster type.
    public var name: String = String()

    /// Cluster specific configuration which depends on the cluster being instantiated.
    /// See the supported cluster for further documentation.
    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {return _typedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_typedConfig = newValue}
    }
    /// Returns true if `typedConfig` has been explicitly set.
    public var hasTypedConfig: Bool {return self._typedConfig != nil}
    /// Clears the value of `typedConfig`. Subsequent reads from it will return its default value.
    public mutating func clearTypedConfig() {self._typedConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _typedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  /// Only valid when discovery type is EDS.
  public struct EdsClusterConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Configuration for the source of EDS updates for this Cluster.
    public var edsConfig: Envoy_Config_Core_V3_ConfigSource {
      get {return _edsConfig ?? Envoy_Config_Core_V3_ConfigSource()}
      set {_edsConfig = newValue}
    }
    /// Returns true if `edsConfig` has been explicitly set.
    public var hasEdsConfig: Bool {return self._edsConfig != nil}
    /// Clears the value of `edsConfig`. Subsequent reads from it will return its default value.
    public mutating func clearEdsConfig() {self._edsConfig = nil}

    /// Optional alternative to cluster name to present to EDS. This does not
    /// have the same restrictions as cluster name, i.e. it may be arbitrary
    /// length.
    public var serviceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _edsConfig: Envoy_Config_Core_V3_ConfigSource? = nil
  }

  /// Optionally divide the endpoints in this cluster into subsets defined by
  /// endpoint metadata and selected by route and weighted cluster metadata.
  /// [#next-free-field: 8]
  public struct LbSubsetConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The behavior used when no endpoint subset matches the selected route's
    /// metadata. The value defaults to
    /// :ref:`NO_FALLBACK<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
    public var fallbackPolicy: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy = .noFallback

    /// Specifies the default subset of endpoints used during fallback if
    /// fallback_policy is
    /// :ref:`DEFAULT_SUBSET<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.DEFAULT_SUBSET>`.
    /// Each field in default_subset is
    /// compared to the matching LbEndpoint.Metadata under the *envoy.lb*
    /// namespace. It is valid for no hosts to match, in which case the behavior
    /// is the same as a fallback_policy of
    /// :ref:`NO_FALLBACK<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetFallbackPolicy.NO_FALLBACK>`.
    public var defaultSubset: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _defaultSubset ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_defaultSubset = newValue}
    }
    /// Returns true if `defaultSubset` has been explicitly set.
    public var hasDefaultSubset: Bool {return self._defaultSubset != nil}
    /// Clears the value of `defaultSubset`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultSubset() {self._defaultSubset = nil}

    /// For each entry, LbEndpoint.Metadata's
    /// *envoy.lb* namespace is traversed and a subset is created for each unique
    /// combination of key and value. For example:
    ///
    /// .. code-block:: json
    ///
    ///   { "subset_selectors": [
    ///       { "keys": [ "version" ] },
    ///       { "keys": [ "stage", "hardware_type" ] }
    ///   ]}
    ///
    /// A subset is matched when the metadata from the selected route and
    /// weighted cluster contains the same keys and values as the subset's
    /// metadata. The same host may appear in multiple subsets.
    public var subsetSelectors: [Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector] = []

    /// If true, routing to subsets will take into account the localities and locality weights of the
    /// endpoints when making the routing decision.
    ///
    /// There are some potential pitfalls associated with enabling this feature, as the resulting
    /// traffic split after applying both a subset match and locality weights might be undesirable.
    ///
    /// Consider for example a situation in which you have 50/50 split across two localities X/Y
    /// which have 100 hosts each without subsetting. If the subset LB results in X having only 1
    /// host selected but Y having 100, then a lot more load is being dumped on the single host in X
    /// than originally anticipated in the load balancing assignment delivered via EDS.
    public var localityWeightAware: Bool = false

    /// When used with locality_weight_aware, scales the weight of each locality by the ratio
    /// of hosts in the subset vs hosts in the original subset. This aims to even out the load
    /// going to an individual locality if said locality is disproportionately affected by the
    /// subset predicate.
    public var scaleLocalityWeight: Bool = false

    /// If true, when a fallback policy is configured and its corresponding subset fails to find
    /// a host this will cause any host to be selected instead.
    ///
    /// This is useful when using the default subset as the fallback policy, given the default
    /// subset might become empty. With this option enabled, if that happens the LB will attempt
    /// to select a host from the entire cluster.
    public var panicModeAny: Bool = false

    /// If true, metadata specified for a metadata key will be matched against the corresponding
    /// endpoint metadata if the endpoint metadata matches the value exactly OR it is a list value
    /// and any of the elements in the list matches the criteria.
    public var listAsAny: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If NO_FALLBACK is selected, a result
    /// equivalent to no healthy hosts is reported. If ANY_ENDPOINT is selected,
    /// any cluster endpoint may be returned (subject to policy, health checks,
    /// etc). If DEFAULT_SUBSET is selected, load balancing is performed over the
    /// endpoints matching the values from the default_subset field.
    public enum LbSubsetFallbackPolicy: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case noFallback // = 0
      case anyEndpoint // = 1
      case defaultSubset // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .noFallback
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .noFallback
        case 1: self = .anyEndpoint
        case 2: self = .defaultSubset
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .noFallback: return 0
        case .anyEndpoint: return 1
        case .defaultSubset: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Specifications for subsets.
    public struct LbSubsetSelector {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// List of keys to match with the weighted cluster metadata.
      public var keys: [String] = []

      /// The behavior used when no endpoint subset matches the selected route's
      /// metadata.
      public var fallbackPolicy: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy = .notDefined

      /// Subset of
      /// :ref:`keys<envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` used by
      /// :ref:`KEYS_SUBSET<envoy_api_enum_value_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy.KEYS_SUBSET>`
      /// fallback policy.
      /// It has to be a non empty list if KEYS_SUBSET fallback policy is selected.
      /// For any other fallback policy the parameter is not used and should not be set.
      /// Only values also present in
      /// :ref:`keys<envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.keys>` are allowed, but
      /// `fallback_keys_subset` cannot be equal to `keys`.
      public var fallbackKeysSubset: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Allows to override top level fallback policy per selector.
      public enum LbSubsetSelectorFallbackPolicy: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// If NOT_DEFINED top level config fallback policy is used instead.
        case notDefined // = 0

        /// If NO_FALLBACK is selected, a result equivalent to no healthy hosts is reported.
        case noFallback // = 1

        /// If ANY_ENDPOINT is selected, any cluster endpoint may be returned
        /// (subject to policy, health checks, etc).
        case anyEndpoint // = 2

        /// If DEFAULT_SUBSET is selected, load balancing is performed over the
        /// endpoints matching the values from the default_subset field.
        case defaultSubset // = 3

        /// If KEYS_SUBSET is selected, subset selector matching is performed again with metadata
        /// keys reduced to
        /// :ref:`fallback_keys_subset<envoy_api_field_config.cluster.v3.Cluster.LbSubsetConfig.LbSubsetSelector.fallback_keys_subset>`.
        /// It allows for a fallback to a different, less specific selector if some of the keys of
        /// the selector are considered optional.
        case keysSubset // = 4
        case UNRECOGNIZED(Int)

        public init() {
          self = .notDefined
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .notDefined
          case 1: self = .noFallback
          case 2: self = .anyEndpoint
          case 3: self = .defaultSubset
          case 4: self = .keysSubset
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .notDefined: return 0
          case .noFallback: return 1
          case .anyEndpoint: return 2
          case .defaultSubset: return 3
          case .keysSubset: return 4
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}

    fileprivate var _defaultSubset: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  /// Specific configuration for the LeastRequest load balancing policy.
  public struct LeastRequestLbConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of random healthy hosts from which the host with the fewest active requests will
    /// be chosen. Defaults to 2 so that we perform two-choice selection if the field is not set.
    public var choiceCount: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _choiceCount ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_choiceCount = newValue}
    }
    /// Returns true if `choiceCount` has been explicitly set.
    public var hasChoiceCount: Bool {return self._choiceCount != nil}
    /// Clears the value of `choiceCount`. Subsequent reads from it will return its default value.
    public mutating func clearChoiceCount() {self._choiceCount = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _choiceCount: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  }

  /// Specific configuration for the :ref:`RingHash<arch_overview_load_balancing_types_ring_hash>`
  /// load balancing policy.
  public struct RingHashLbConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Minimum hash ring size. The larger the ring is (that is, the more hashes there are for each
    /// provided host) the better the request distribution will reflect the desired weights. Defaults
    /// to 1024 entries, and limited to 8M entries. See also
    /// :ref:`maximum_ring_size<envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.maximum_ring_size>`.
    public var minimumRingSize: SwiftProtobuf.Google_Protobuf_UInt64Value {
      get {return _minimumRingSize ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
      set {_minimumRingSize = newValue}
    }
    /// Returns true if `minimumRingSize` has been explicitly set.
    public var hasMinimumRingSize: Bool {return self._minimumRingSize != nil}
    /// Clears the value of `minimumRingSize`. Subsequent reads from it will return its default value.
    public mutating func clearMinimumRingSize() {self._minimumRingSize = nil}

    /// The hash function used to hash hosts onto the ketama ring. The value defaults to
    /// :ref:`XX_HASH<envoy_api_enum_value_config.cluster.v3.Cluster.RingHashLbConfig.HashFunction.XX_HASH>`.
    public var hashFunction: Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig.HashFunction = .xxHash

    /// Maximum hash ring size. Defaults to 8M entries, and limited to 8M entries, but can be lowered
    /// to further constrain resource use. See also
    /// :ref:`minimum_ring_size<envoy_api_field_config.cluster.v3.Cluster.RingHashLbConfig.minimum_ring_size>`.
    public var maximumRingSize: SwiftProtobuf.Google_Protobuf_UInt64Value {
      get {return _maximumRingSize ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
      set {_maximumRingSize = newValue}
    }
    /// Returns true if `maximumRingSize` has been explicitly set.
    public var hasMaximumRingSize: Bool {return self._maximumRingSize != nil}
    /// Clears the value of `maximumRingSize`. Subsequent reads from it will return its default value.
    public mutating func clearMaximumRingSize() {self._maximumRingSize = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The hash function used to hash hosts onto the ketama ring.
    public enum HashFunction: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Use `xxHash <https://github.com/Cyan4973/xxHash>`_, this is the default hash function.
      case xxHash // = 0

      /// Use `MurmurHash2 <https://sites.google.com/site/murmurhash/>`_, this is compatible with
      /// std:hash<string> in GNU libstdc++ 3.4.20 or above. This is typically the case when compiled
      /// on Linux and not macOS.
      case murmurHash2 // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .xxHash
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .xxHash
        case 1: self = .murmurHash2
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .xxHash: return 0
        case .murmurHash2: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _minimumRingSize: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    fileprivate var _maximumRingSize: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
  }

  /// Specific configuration for the
  /// :ref:`Original Destination <arch_overview_load_balancing_types_original_destination>`
  /// load balancing policy.
  public struct OriginalDstLbConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// When true, :ref:`x-envoy-original-dst-host
    /// <config_http_conn_man_headers_x-envoy-original-dst-host>` can be used to override destination
    /// address.
    ///
    /// .. attention::
    ///
    ///   This header isn't sanitized by default, so enabling this feature allows HTTP clients to
    ///   route traffic to arbitrary hosts and/or ports, which may have serious security
    ///   consequences.
    public var useHTTPHeader: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Common configuration for all load balancer implementations.
  /// [#next-free-field: 8]
  public struct CommonLbConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Configures the :ref:`healthy panic threshold <arch_overview_load_balancing_panic_threshold>`.
    /// If not specified, the default is 50%.
    /// To disable panic mode, set to 0%.
    ///
    /// .. note::
    ///   The specified percent will be truncated to the nearest 1%.
    public var healthyPanicThreshold: Envoy_Type_V3_Percent {
      get {return _healthyPanicThreshold ?? Envoy_Type_V3_Percent()}
      set {_healthyPanicThreshold = newValue}
    }
    /// Returns true if `healthyPanicThreshold` has been explicitly set.
    public var hasHealthyPanicThreshold: Bool {return self._healthyPanicThreshold != nil}
    /// Clears the value of `healthyPanicThreshold`. Subsequent reads from it will return its default value.
    public mutating func clearHealthyPanicThreshold() {self._healthyPanicThreshold = nil}

    public var localityConfigSpecifier: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.OneOf_LocalityConfigSpecifier? = nil

    public var zoneAwareLbConfig: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig {
      get {
        if case .zoneAwareLbConfig(let v)? = localityConfigSpecifier {return v}
        return Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig()
      }
      set {localityConfigSpecifier = .zoneAwareLbConfig(newValue)}
    }

    public var localityWeightedLbConfig: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig {
      get {
        if case .localityWeightedLbConfig(let v)? = localityConfigSpecifier {return v}
        return Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig()
      }
      set {localityConfigSpecifier = .localityWeightedLbConfig(newValue)}
    }

    /// If set, all health check/weight/metadata updates that happen within this duration will be
    /// merged and delivered in one shot when the duration expires. The start of the duration is when
    /// the first update happens. This is useful for big clusters, with potentially noisy deploys
    /// that might trigger excessive CPU usage due to a constant stream of healthcheck state changes
    /// or metadata updates. The first set of updates to be seen apply immediately (e.g.: a new
    /// cluster). Please always keep in mind that the use of sandbox technologies may change this
    /// behavior.
    ///
    /// If this is not set, we default to a merge window of 1000ms. To disable it, set the merge
    /// window to 0.
    ///
    /// Note: merging does not apply to cluster membership changes (e.g.: adds/removes); this is
    /// because merging those updates isn't currently safe. See
    /// https://github.com/envoyproxy/envoy/pull/3941.
    public var updateMergeWindow: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _updateMergeWindow ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_updateMergeWindow = newValue}
    }
    /// Returns true if `updateMergeWindow` has been explicitly set.
    public var hasUpdateMergeWindow: Bool {return self._updateMergeWindow != nil}
    /// Clears the value of `updateMergeWindow`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMergeWindow() {self._updateMergeWindow = nil}

    /// If set to true, Envoy will not consider new hosts when computing load balancing weights until
    /// they have been health checked for the first time. This will have no effect unless
    /// active health checking is also configured.
    ///
    /// Ignoring a host means that for any load balancing calculations that adjust weights based
    /// on the ratio of eligible hosts and total hosts (priority spillover, locality weighting and
    /// panic mode) Envoy will exclude these hosts in the denominator.
    ///
    /// For example, with hosts in two priorities P0 and P1, where P0 looks like
    /// {healthy, unhealthy (new), unhealthy (new)}
    /// and where P1 looks like
    /// {healthy, healthy}
    /// all traffic will still hit P0, as 1 / (3 - 2) = 1.
    ///
    /// Enabling this will allow scaling up the number of hosts for a given cluster without entering
    /// panic mode or triggering priority spillover, assuming the hosts pass the first health check.
    ///
    /// If panic mode is triggered, new hosts are still eligible for traffic; they simply do not
    /// contribute to the calculation when deciding whether panic mode is enabled or not.
    public var ignoreNewHostsUntilFirstHc: Bool = false

    /// If set to `true`, the cluster manager will drain all existing
    /// connections to upstream hosts whenever hosts are added or removed from the cluster.
    public var closeConnectionsOnHostSetChange: Bool = false

    ///Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
    public var consistentHashingLbConfig: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ConsistentHashingLbConfig {
      get {return _consistentHashingLbConfig ?? Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ConsistentHashingLbConfig()}
      set {_consistentHashingLbConfig = newValue}
    }
    /// Returns true if `consistentHashingLbConfig` has been explicitly set.
    public var hasConsistentHashingLbConfig: Bool {return self._consistentHashingLbConfig != nil}
    /// Clears the value of `consistentHashingLbConfig`. Subsequent reads from it will return its default value.
    public mutating func clearConsistentHashingLbConfig() {self._consistentHashingLbConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_LocalityConfigSpecifier: Equatable {
      case zoneAwareLbConfig(Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig)
      case localityWeightedLbConfig(Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.OneOf_LocalityConfigSpecifier, rhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.OneOf_LocalityConfigSpecifier) -> Bool {
        switch (lhs, rhs) {
        case (.zoneAwareLbConfig(let l), .zoneAwareLbConfig(let r)): return l == r
        case (.localityWeightedLbConfig(let l), .localityWeightedLbConfig(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// Configuration for :ref:`zone aware routing
    /// <arch_overview_load_balancing_zone_aware_routing>`.
    public struct ZoneAwareLbConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Configures percentage of requests that will be considered for zone aware routing
      /// if zone aware routing is configured. If not specified, the default is 100%.
      /// * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
      /// * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
      public var routingEnabled: Envoy_Type_V3_Percent {
        get {return _routingEnabled ?? Envoy_Type_V3_Percent()}
        set {_routingEnabled = newValue}
      }
      /// Returns true if `routingEnabled` has been explicitly set.
      public var hasRoutingEnabled: Bool {return self._routingEnabled != nil}
      /// Clears the value of `routingEnabled`. Subsequent reads from it will return its default value.
      public mutating func clearRoutingEnabled() {self._routingEnabled = nil}

      /// Configures minimum upstream cluster size required for zone aware routing
      /// If upstream cluster size is less than specified, zone aware routing is not performed
      /// even if zone aware routing is configured. If not specified, the default is 6.
      /// * :ref:`runtime values <config_cluster_manager_cluster_runtime_zone_routing>`.
      /// * :ref:`Zone aware routing support <arch_overview_load_balancing_zone_aware_routing>`.
      public var minClusterSize: SwiftProtobuf.Google_Protobuf_UInt64Value {
        get {return _minClusterSize ?? SwiftProtobuf.Google_Protobuf_UInt64Value()}
        set {_minClusterSize = newValue}
      }
      /// Returns true if `minClusterSize` has been explicitly set.
      public var hasMinClusterSize: Bool {return self._minClusterSize != nil}
      /// Clears the value of `minClusterSize`. Subsequent reads from it will return its default value.
      public mutating func clearMinClusterSize() {self._minClusterSize = nil}

      /// If set to true, Envoy will not consider any hosts when the cluster is in :ref:`panic
      /// mode<arch_overview_load_balancing_panic_threshold>`. Instead, the cluster will fail all
      /// requests as if all hosts are unhealthy. This can help avoid potentially overwhelming a
      /// failing service.
      public var failTrafficOnPanic: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _routingEnabled: Envoy_Type_V3_Percent? = nil
      fileprivate var _minClusterSize: SwiftProtobuf.Google_Protobuf_UInt64Value? = nil
    }

    /// Configuration for :ref:`locality weighted load balancing
    /// <arch_overview_load_balancing_locality_weighted_lb>`
    public struct LocalityWeightedLbConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Common Configuration for all consistent hashing load balancers (MaglevLb, RingHashLb, etc.)
    public struct ConsistentHashingLbConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// If set to `true`, the cluster will use hostname instead of the resolved
      /// address as the key to consistently hash to an upstream host. Only valid for StrictDNS clusters with hostnames which resolve to a single IP address.
      public var useHostnameForHashing: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _healthyPanicThreshold: Envoy_Type_V3_Percent? = nil
    fileprivate var _updateMergeWindow: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _consistentHashingLbConfig: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ConsistentHashingLbConfig? = nil
  }

  public struct RefreshRate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the base interval between refreshes. This parameter is required and must be greater
    /// than zero and less than
    /// :ref:`max_interval <envoy_api_field_config.cluster.v3.Cluster.RefreshRate.max_interval>`.
    public var baseInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _baseInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_baseInterval = newValue}
    }
    /// Returns true if `baseInterval` has been explicitly set.
    public var hasBaseInterval: Bool {return self._baseInterval != nil}
    /// Clears the value of `baseInterval`. Subsequent reads from it will return its default value.
    public mutating func clearBaseInterval() {self._baseInterval = nil}

    /// Specifies the maximum interval between refreshes. This parameter is optional, but must be
    /// greater than or equal to the
    /// :ref:`base_interval <envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`  if set. The default
    /// is 10 times the :ref:`base_interval <envoy_api_field_config.cluster.v3.Cluster.RefreshRate.base_interval>`.
    public var maxInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxInterval = newValue}
    }
    /// Returns true if `maxInterval` has been explicitly set.
    public var hasMaxInterval: Bool {return self._maxInterval != nil}
    /// Clears the value of `maxInterval`. Subsequent reads from it will return its default value.
    public mutating func clearMaxInterval() {self._maxInterval = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _baseInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _maxInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Cluster_V3_Cluster.DiscoveryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.DiscoveryType] = [
    .static,
    .strictDns,
    .logicalDns,
    .eds,
    .originalDst,
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.LbPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.LbPolicy] = [
    .roundRobin,
    .leastRequest,
    .ringHash,
    .random,
    .maglev,
    .clusterProvided,
    .loadBalancingPolicyConfig,
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.DnsLookupFamily: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.DnsLookupFamily] = [
    .auto,
    .v4Only,
    .v6Only,
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.ClusterProtocolSelection: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.ClusterProtocolSelection] = [
    .useConfiguredProtocol,
    .useDownstreamProtocol,
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy] = [
    .noFallback,
    .anyEndpoint,
    .defaultSubset,
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy] = [
    .notDefined,
    .noFallback,
    .anyEndpoint,
    .defaultSubset,
    .keysSubset,
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig.HashFunction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig.HashFunction] = [
    .xxHash,
    .murmurHash2,
  ]
}

#endif  // swift(>=4.2)

/// [#not-implemented-hide:] Extensible load balancing policy configuration.
///
/// Every LB policy defined via this mechanism will be identified via a unique name using reverse
/// DNS notation. If the policy needs configuration parameters, it must define a message for its
/// own configuration, which will be stored in the config field. The name of the policy will tell
/// clients which type of message they should expect to see in the config field.
///
/// Note that there are cases where it is useful to be able to independently select LB policies
/// for choosing a locality and for choosing an endpoint within that locality. For example, a
/// given deployment may always use the same policy to choose the locality, but for choosing the
/// endpoint within the locality, some clusters may use weighted-round-robin, while others may
/// use some sort of session-based balancing.
///
/// This can be accomplished via hierarchical LB policies, where the parent LB policy creates a
/// child LB policy for each locality. For each request, the parent chooses the locality and then
/// delegates to the child policy for that locality to choose the endpoint within the locality.
///
/// To facilitate this, the config message for the top-level LB policy may include a field of
/// type LoadBalancingPolicy that specifies the child policy.
public struct Envoy_Config_Cluster_V3_LoadBalancingPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Each client will iterate over the list in order and stop at the first policy that it
  /// supports. This provides a mechanism for starting to use new LB policies that are not yet
  /// supported by all clients.
  public var policies: [Envoy_Config_Cluster_V3_LoadBalancingPolicy.Policy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Policy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The name of the LB policy.
    public var name: String = String()

    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {return _typedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_typedConfig = newValue}
    }
    /// Returns true if `typedConfig` has been explicitly set.
    public var hasTypedConfig: Bool {return self._typedConfig != nil}
    /// Clears the value of `typedConfig`. Subsequent reads from it will return its default value.
    public mutating func clearTypedConfig() {self._typedConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _typedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  public init() {}
}

/// An extensible structure containing the address Envoy should bind to when
/// establishing upstream connections.
public struct Envoy_Config_Cluster_V3_UpstreamBindConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address Envoy should bind to when establishing upstream connections.
  public var sourceAddress: Envoy_Config_Core_V3_Address {
    get {return _sourceAddress ?? Envoy_Config_Core_V3_Address()}
    set {_sourceAddress = newValue}
  }
  /// Returns true if `sourceAddress` has been explicitly set.
  public var hasSourceAddress: Bool {return self._sourceAddress != nil}
  /// Clears the value of `sourceAddress`. Subsequent reads from it will return its default value.
  public mutating func clearSourceAddress() {self._sourceAddress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sourceAddress: Envoy_Config_Core_V3_Address? = nil
}

public struct Envoy_Config_Cluster_V3_UpstreamConnectionOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
  public var tcpKeepalive: Envoy_Config_Core_V3_TcpKeepalive {
    get {return _tcpKeepalive ?? Envoy_Config_Core_V3_TcpKeepalive()}
    set {_tcpKeepalive = newValue}
  }
  /// Returns true if `tcpKeepalive` has been explicitly set.
  public var hasTcpKeepalive: Bool {return self._tcpKeepalive != nil}
  /// Clears the value of `tcpKeepalive`. Subsequent reads from it will return its default value.
  public mutating func clearTcpKeepalive() {self._tcpKeepalive = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tcpKeepalive: Envoy_Config_Core_V3_TcpKeepalive? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.cluster.v3"

extension Envoy_Config_Cluster_V3_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    43: .standard(proto: "transport_socket_matches"),
    1: .same(proto: "name"),
    28: .standard(proto: "alt_stat_name"),
    2: .same(proto: "type"),
    38: .standard(proto: "cluster_type"),
    3: .standard(proto: "eds_cluster_config"),
    4: .standard(proto: "connect_timeout"),
    5: .standard(proto: "per_connection_buffer_limit_bytes"),
    6: .standard(proto: "lb_policy"),
    33: .standard(proto: "load_assignment"),
    8: .standard(proto: "health_checks"),
    9: .standard(proto: "max_requests_per_connection"),
    10: .standard(proto: "circuit_breakers"),
    46: .standard(proto: "upstream_http_protocol_options"),
    29: .standard(proto: "common_http_protocol_options"),
    13: .standard(proto: "http_protocol_options"),
    14: .standard(proto: "http2_protocol_options"),
    36: .standard(proto: "typed_extension_protocol_options"),
    16: .standard(proto: "dns_refresh_rate"),
    44: .standard(proto: "dns_failure_refresh_rate"),
    39: .standard(proto: "respect_dns_ttl"),
    17: .standard(proto: "dns_lookup_family"),
    18: .standard(proto: "dns_resolvers"),
    45: .standard(proto: "use_tcp_for_dns_lookups"),
    19: .standard(proto: "outlier_detection"),
    20: .standard(proto: "cleanup_interval"),
    21: .standard(proto: "upstream_bind_config"),
    22: .standard(proto: "lb_subset_config"),
    23: .standard(proto: "ring_hash_lb_config"),
    34: .standard(proto: "original_dst_lb_config"),
    37: .standard(proto: "least_request_lb_config"),
    27: .standard(proto: "common_lb_config"),
    24: .standard(proto: "transport_socket"),
    25: .same(proto: "metadata"),
    26: .standard(proto: "protocol_selection"),
    30: .standard(proto: "upstream_connection_options"),
    31: .standard(proto: "close_connections_on_host_health_failure"),
    32: .standard(proto: "ignore_health_on_host_removal"),
    40: .same(proto: "filters"),
    41: .standard(proto: "load_balancing_policy"),
    42: .standard(proto: "lrs_server"),
    47: .standard(proto: "track_timeout_budgets"),
  ]

  fileprivate class _StorageClass {
    var _transportSocketMatches: [Envoy_Config_Cluster_V3_Cluster.TransportSocketMatch] = []
    var _name: String = String()
    var _altStatName: String = String()
    var _clusterDiscoveryType: Envoy_Config_Cluster_V3_Cluster.OneOf_ClusterDiscoveryType?
    var _edsClusterConfig: Envoy_Config_Cluster_V3_Cluster.EdsClusterConfig? = nil
    var _connectTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _perConnectionBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _lbPolicy: Envoy_Config_Cluster_V3_Cluster.LbPolicy = .roundRobin
    var _loadAssignment: Envoy_Config_Endpoint_V3_ClusterLoadAssignment? = nil
    var _healthChecks: [Envoy_Config_Core_V3_HealthCheck] = []
    var _maxRequestsPerConnection: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _circuitBreakers: Envoy_Config_Cluster_V3_CircuitBreakers? = nil
    var _upstreamHTTPProtocolOptions: Envoy_Config_Core_V3_UpstreamHttpProtocolOptions? = nil
    var _commonHTTPProtocolOptions: Envoy_Config_Core_V3_HttpProtocolOptions? = nil
    var _httpProtocolOptions: Envoy_Config_Core_V3_Http1ProtocolOptions? = nil
    var _http2ProtocolOptions: Envoy_Config_Core_V3_Http2ProtocolOptions? = nil
    var _typedExtensionProtocolOptions: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]
    var _dnsRefreshRate: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _dnsFailureRefreshRate: Envoy_Config_Cluster_V3_Cluster.RefreshRate? = nil
    var _respectDnsTtl: Bool = false
    var _dnsLookupFamily: Envoy_Config_Cluster_V3_Cluster.DnsLookupFamily = .auto
    var _dnsResolvers: [Envoy_Config_Core_V3_Address] = []
    var _useTcpForDnsLookups: Bool = false
    var _outlierDetection: Envoy_Config_Cluster_V3_OutlierDetection? = nil
    var _cleanupInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _upstreamBindConfig: Envoy_Config_Core_V3_BindConfig? = nil
    var _lbSubsetConfig: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig? = nil
    var _lbConfig: Envoy_Config_Cluster_V3_Cluster.OneOf_LbConfig?
    var _commonLbConfig: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig? = nil
    var _transportSocket: Envoy_Config_Core_V3_TransportSocket? = nil
    var _metadata: Envoy_Config_Core_V3_Metadata? = nil
    var _protocolSelection: Envoy_Config_Cluster_V3_Cluster.ClusterProtocolSelection = .useConfiguredProtocol
    var _upstreamConnectionOptions: Envoy_Config_Cluster_V3_UpstreamConnectionOptions? = nil
    var _closeConnectionsOnHostHealthFailure: Bool = false
    var _ignoreHealthOnHostRemoval: Bool = false
    var _filters: [Envoy_Config_Cluster_V3_Filter] = []
    var _loadBalancingPolicy: Envoy_Config_Cluster_V3_LoadBalancingPolicy? = nil
    var _lrsServer: Envoy_Config_Core_V3_ConfigSource? = nil
    var _trackTimeoutBudgets: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _transportSocketMatches = source._transportSocketMatches
      _name = source._name
      _altStatName = source._altStatName
      _clusterDiscoveryType = source._clusterDiscoveryType
      _edsClusterConfig = source._edsClusterConfig
      _connectTimeout = source._connectTimeout
      _perConnectionBufferLimitBytes = source._perConnectionBufferLimitBytes
      _lbPolicy = source._lbPolicy
      _loadAssignment = source._loadAssignment
      _healthChecks = source._healthChecks
      _maxRequestsPerConnection = source._maxRequestsPerConnection
      _circuitBreakers = source._circuitBreakers
      _upstreamHTTPProtocolOptions = source._upstreamHTTPProtocolOptions
      _commonHTTPProtocolOptions = source._commonHTTPProtocolOptions
      _httpProtocolOptions = source._httpProtocolOptions
      _http2ProtocolOptions = source._http2ProtocolOptions
      _typedExtensionProtocolOptions = source._typedExtensionProtocolOptions
      _dnsRefreshRate = source._dnsRefreshRate
      _dnsFailureRefreshRate = source._dnsFailureRefreshRate
      _respectDnsTtl = source._respectDnsTtl
      _dnsLookupFamily = source._dnsLookupFamily
      _dnsResolvers = source._dnsResolvers
      _useTcpForDnsLookups = source._useTcpForDnsLookups
      _outlierDetection = source._outlierDetection
      _cleanupInterval = source._cleanupInterval
      _upstreamBindConfig = source._upstreamBindConfig
      _lbSubsetConfig = source._lbSubsetConfig
      _lbConfig = source._lbConfig
      _commonLbConfig = source._commonLbConfig
      _transportSocket = source._transportSocket
      _metadata = source._metadata
      _protocolSelection = source._protocolSelection
      _upstreamConnectionOptions = source._upstreamConnectionOptions
      _closeConnectionsOnHostHealthFailure = source._closeConnectionsOnHostHealthFailure
      _ignoreHealthOnHostRemoval = source._ignoreHealthOnHostRemoval
      _filters = source._filters
      _loadBalancingPolicy = source._loadBalancingPolicy
      _lrsServer = source._lrsServer
      _trackTimeoutBudgets = source._trackTimeoutBudgets
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2:
          if _storage._clusterDiscoveryType != nil {try decoder.handleConflictingOneOf()}
          var v: Envoy_Config_Cluster_V3_Cluster.DiscoveryType?
          try decoder.decodeSingularEnumField(value: &v)
          if let v = v {_storage._clusterDiscoveryType = .type(v)}
        case 3: try decoder.decodeSingularMessageField(value: &_storage._edsClusterConfig)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._connectTimeout)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._perConnectionBufferLimitBytes)
        case 6: try decoder.decodeSingularEnumField(value: &_storage._lbPolicy)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._healthChecks)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._maxRequestsPerConnection)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._circuitBreakers)
        case 13: try decoder.decodeSingularMessageField(value: &_storage._httpProtocolOptions)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._http2ProtocolOptions)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._dnsRefreshRate)
        case 17: try decoder.decodeSingularEnumField(value: &_storage._dnsLookupFamily)
        case 18: try decoder.decodeRepeatedMessageField(value: &_storage._dnsResolvers)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._outlierDetection)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._cleanupInterval)
        case 21: try decoder.decodeSingularMessageField(value: &_storage._upstreamBindConfig)
        case 22: try decoder.decodeSingularMessageField(value: &_storage._lbSubsetConfig)
        case 23:
          var v: Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig?
          if let current = _storage._lbConfig {
            try decoder.handleConflictingOneOf()
            if case .ringHashLbConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lbConfig = .ringHashLbConfig(v)}
        case 24: try decoder.decodeSingularMessageField(value: &_storage._transportSocket)
        case 25: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 26: try decoder.decodeSingularEnumField(value: &_storage._protocolSelection)
        case 27: try decoder.decodeSingularMessageField(value: &_storage._commonLbConfig)
        case 28: try decoder.decodeSingularStringField(value: &_storage._altStatName)
        case 29: try decoder.decodeSingularMessageField(value: &_storage._commonHTTPProtocolOptions)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._upstreamConnectionOptions)
        case 31: try decoder.decodeSingularBoolField(value: &_storage._closeConnectionsOnHostHealthFailure)
        case 32: try decoder.decodeSingularBoolField(value: &_storage._ignoreHealthOnHostRemoval)
        case 33: try decoder.decodeSingularMessageField(value: &_storage._loadAssignment)
        case 34:
          var v: Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig?
          if let current = _storage._lbConfig {
            try decoder.handleConflictingOneOf()
            if case .originalDstLbConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lbConfig = .originalDstLbConfig(v)}
        case 36: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &_storage._typedExtensionProtocolOptions)
        case 37:
          var v: Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig?
          if let current = _storage._lbConfig {
            try decoder.handleConflictingOneOf()
            if case .leastRequestLbConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._lbConfig = .leastRequestLbConfig(v)}
        case 38:
          var v: Envoy_Config_Cluster_V3_Cluster.CustomClusterType?
          if let current = _storage._clusterDiscoveryType {
            try decoder.handleConflictingOneOf()
            if case .clusterType(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._clusterDiscoveryType = .clusterType(v)}
        case 39: try decoder.decodeSingularBoolField(value: &_storage._respectDnsTtl)
        case 40: try decoder.decodeRepeatedMessageField(value: &_storage._filters)
        case 41: try decoder.decodeSingularMessageField(value: &_storage._loadBalancingPolicy)
        case 42: try decoder.decodeSingularMessageField(value: &_storage._lrsServer)
        case 43: try decoder.decodeRepeatedMessageField(value: &_storage._transportSocketMatches)
        case 44: try decoder.decodeSingularMessageField(value: &_storage._dnsFailureRefreshRate)
        case 45: try decoder.decodeSingularBoolField(value: &_storage._useTcpForDnsLookups)
        case 46: try decoder.decodeSingularMessageField(value: &_storage._upstreamHTTPProtocolOptions)
        case 47: try decoder.decodeSingularBoolField(value: &_storage._trackTimeoutBudgets)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if case .type(let v)? = _storage._clusterDiscoveryType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._edsClusterConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._connectTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._perConnectionBufferLimitBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._lbPolicy != .roundRobin {
        try visitor.visitSingularEnumField(value: _storage._lbPolicy, fieldNumber: 6)
      }
      if !_storage._healthChecks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._healthChecks, fieldNumber: 8)
      }
      if let v = _storage._maxRequestsPerConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._circuitBreakers {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._httpProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._http2ProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._dnsRefreshRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if _storage._dnsLookupFamily != .auto {
        try visitor.visitSingularEnumField(value: _storage._dnsLookupFamily, fieldNumber: 17)
      }
      if !_storage._dnsResolvers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._dnsResolvers, fieldNumber: 18)
      }
      if let v = _storage._outlierDetection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._cleanupInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._upstreamBindConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._lbSubsetConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if case .ringHashLbConfig(let v)? = _storage._lbConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._transportSocket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if _storage._protocolSelection != .useConfiguredProtocol {
        try visitor.visitSingularEnumField(value: _storage._protocolSelection, fieldNumber: 26)
      }
      if let v = _storage._commonLbConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if !_storage._altStatName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._altStatName, fieldNumber: 28)
      }
      if let v = _storage._commonHTTPProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._upstreamConnectionOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if _storage._closeConnectionsOnHostHealthFailure != false {
        try visitor.visitSingularBoolField(value: _storage._closeConnectionsOnHostHealthFailure, fieldNumber: 31)
      }
      if _storage._ignoreHealthOnHostRemoval != false {
        try visitor.visitSingularBoolField(value: _storage._ignoreHealthOnHostRemoval, fieldNumber: 32)
      }
      if let v = _storage._loadAssignment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if case .originalDstLbConfig(let v)? = _storage._lbConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
      if !_storage._typedExtensionProtocolOptions.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: _storage._typedExtensionProtocolOptions, fieldNumber: 36)
      }
      if case .leastRequestLbConfig(let v)? = _storage._lbConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }
      if case .clusterType(let v)? = _storage._clusterDiscoveryType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }
      if _storage._respectDnsTtl != false {
        try visitor.visitSingularBoolField(value: _storage._respectDnsTtl, fieldNumber: 39)
      }
      if !_storage._filters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._filters, fieldNumber: 40)
      }
      if let v = _storage._loadBalancingPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }
      if let v = _storage._lrsServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }
      if !_storage._transportSocketMatches.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._transportSocketMatches, fieldNumber: 43)
      }
      if let v = _storage._dnsFailureRefreshRate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }
      if _storage._useTcpForDnsLookups != false {
        try visitor.visitSingularBoolField(value: _storage._useTcpForDnsLookups, fieldNumber: 45)
      }
      if let v = _storage._upstreamHTTPProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }
      if _storage._trackTimeoutBudgets != false {
        try visitor.visitSingularBoolField(value: _storage._trackTimeoutBudgets, fieldNumber: 47)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster, rhs: Envoy_Config_Cluster_V3_Cluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._transportSocketMatches != rhs_storage._transportSocketMatches {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._altStatName != rhs_storage._altStatName {return false}
        if _storage._clusterDiscoveryType != rhs_storage._clusterDiscoveryType {return false}
        if _storage._edsClusterConfig != rhs_storage._edsClusterConfig {return false}
        if _storage._connectTimeout != rhs_storage._connectTimeout {return false}
        if _storage._perConnectionBufferLimitBytes != rhs_storage._perConnectionBufferLimitBytes {return false}
        if _storage._lbPolicy != rhs_storage._lbPolicy {return false}
        if _storage._loadAssignment != rhs_storage._loadAssignment {return false}
        if _storage._healthChecks != rhs_storage._healthChecks {return false}
        if _storage._maxRequestsPerConnection != rhs_storage._maxRequestsPerConnection {return false}
        if _storage._circuitBreakers != rhs_storage._circuitBreakers {return false}
        if _storage._upstreamHTTPProtocolOptions != rhs_storage._upstreamHTTPProtocolOptions {return false}
        if _storage._commonHTTPProtocolOptions != rhs_storage._commonHTTPProtocolOptions {return false}
        if _storage._httpProtocolOptions != rhs_storage._httpProtocolOptions {return false}
        if _storage._http2ProtocolOptions != rhs_storage._http2ProtocolOptions {return false}
        if _storage._typedExtensionProtocolOptions != rhs_storage._typedExtensionProtocolOptions {return false}
        if _storage._dnsRefreshRate != rhs_storage._dnsRefreshRate {return false}
        if _storage._dnsFailureRefreshRate != rhs_storage._dnsFailureRefreshRate {return false}
        if _storage._respectDnsTtl != rhs_storage._respectDnsTtl {return false}
        if _storage._dnsLookupFamily != rhs_storage._dnsLookupFamily {return false}
        if _storage._dnsResolvers != rhs_storage._dnsResolvers {return false}
        if _storage._useTcpForDnsLookups != rhs_storage._useTcpForDnsLookups {return false}
        if _storage._outlierDetection != rhs_storage._outlierDetection {return false}
        if _storage._cleanupInterval != rhs_storage._cleanupInterval {return false}
        if _storage._upstreamBindConfig != rhs_storage._upstreamBindConfig {return false}
        if _storage._lbSubsetConfig != rhs_storage._lbSubsetConfig {return false}
        if _storage._lbConfig != rhs_storage._lbConfig {return false}
        if _storage._commonLbConfig != rhs_storage._commonLbConfig {return false}
        if _storage._transportSocket != rhs_storage._transportSocket {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._protocolSelection != rhs_storage._protocolSelection {return false}
        if _storage._upstreamConnectionOptions != rhs_storage._upstreamConnectionOptions {return false}
        if _storage._closeConnectionsOnHostHealthFailure != rhs_storage._closeConnectionsOnHostHealthFailure {return false}
        if _storage._ignoreHealthOnHostRemoval != rhs_storage._ignoreHealthOnHostRemoval {return false}
        if _storage._filters != rhs_storage._filters {return false}
        if _storage._loadBalancingPolicy != rhs_storage._loadBalancingPolicy {return false}
        if _storage._lrsServer != rhs_storage._lrsServer {return false}
        if _storage._trackTimeoutBudgets != rhs_storage._trackTimeoutBudgets {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.DiscoveryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATIC"),
    1: .same(proto: "STRICT_DNS"),
    2: .same(proto: "LOGICAL_DNS"),
    3: .same(proto: "EDS"),
    4: .same(proto: "ORIGINAL_DST"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.LbPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROUND_ROBIN"),
    1: .same(proto: "LEAST_REQUEST"),
    2: .same(proto: "RING_HASH"),
    3: .same(proto: "RANDOM"),
    5: .same(proto: "MAGLEV"),
    6: .same(proto: "CLUSTER_PROVIDED"),
    7: .same(proto: "LOAD_BALANCING_POLICY_CONFIG"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.DnsLookupFamily: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO"),
    1: .same(proto: "V4_ONLY"),
    2: .same(proto: "V6_ONLY"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.ClusterProtocolSelection: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USE_CONFIGURED_PROTOCOL"),
    1: .same(proto: "USE_DOWNSTREAM_PROTOCOL"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.TransportSocketMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".TransportSocketMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "match"),
    3: .standard(proto: "transport_socket"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._match)
      case 3: try decoder.decodeSingularMessageField(value: &self._transportSocket)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._match {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._transportSocket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.TransportSocketMatch, rhs: Envoy_Config_Cluster_V3_Cluster.TransportSocketMatch) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._match != rhs._match {return false}
    if lhs._transportSocket != rhs._transportSocket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.CustomClusterType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".CustomClusterType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._typedConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._typedConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.CustomClusterType, rhs: Envoy_Config_Cluster_V3_Cluster.CustomClusterType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._typedConfig != rhs._typedConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.EdsClusterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".EdsClusterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "eds_config"),
    2: .standard(proto: "service_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._edsConfig)
      case 2: try decoder.decodeSingularStringField(value: &self.serviceName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._edsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.EdsClusterConfig, rhs: Envoy_Config_Cluster_V3_Cluster.EdsClusterConfig) -> Bool {
    if lhs._edsConfig != rhs._edsConfig {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".LbSubsetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fallback_policy"),
    2: .standard(proto: "default_subset"),
    3: .standard(proto: "subset_selectors"),
    4: .standard(proto: "locality_weight_aware"),
    5: .standard(proto: "scale_locality_weight"),
    6: .standard(proto: "panic_mode_any"),
    7: .standard(proto: "list_as_any"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.fallbackPolicy)
      case 2: try decoder.decodeSingularMessageField(value: &self._defaultSubset)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.subsetSelectors)
      case 4: try decoder.decodeSingularBoolField(value: &self.localityWeightAware)
      case 5: try decoder.decodeSingularBoolField(value: &self.scaleLocalityWeight)
      case 6: try decoder.decodeSingularBoolField(value: &self.panicModeAny)
      case 7: try decoder.decodeSingularBoolField(value: &self.listAsAny)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fallbackPolicy != .noFallback {
      try visitor.visitSingularEnumField(value: self.fallbackPolicy, fieldNumber: 1)
    }
    if let v = self._defaultSubset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.subsetSelectors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subsetSelectors, fieldNumber: 3)
    }
    if self.localityWeightAware != false {
      try visitor.visitSingularBoolField(value: self.localityWeightAware, fieldNumber: 4)
    }
    if self.scaleLocalityWeight != false {
      try visitor.visitSingularBoolField(value: self.scaleLocalityWeight, fieldNumber: 5)
    }
    if self.panicModeAny != false {
      try visitor.visitSingularBoolField(value: self.panicModeAny, fieldNumber: 6)
    }
    if self.listAsAny != false {
      try visitor.visitSingularBoolField(value: self.listAsAny, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig, rhs: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig) -> Bool {
    if lhs.fallbackPolicy != rhs.fallbackPolicy {return false}
    if lhs._defaultSubset != rhs._defaultSubset {return false}
    if lhs.subsetSelectors != rhs.subsetSelectors {return false}
    if lhs.localityWeightAware != rhs.localityWeightAware {return false}
    if lhs.scaleLocalityWeight != rhs.scaleLocalityWeight {return false}
    if lhs.panicModeAny != rhs.panicModeAny {return false}
    if lhs.listAsAny != rhs.listAsAny {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetFallbackPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_FALLBACK"),
    1: .same(proto: "ANY_ENDPOINT"),
    2: .same(proto: "DEFAULT_SUBSET"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.protoMessageName + ".LbSubsetSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .standard(proto: "fallback_policy"),
    3: .standard(proto: "fallback_keys_subset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.keys)
      case 2: try decoder.decodeSingularEnumField(value: &self.fallbackPolicy)
      case 3: try decoder.decodeRepeatedStringField(value: &self.fallbackKeysSubset)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.keys, fieldNumber: 1)
    }
    if self.fallbackPolicy != .notDefined {
      try visitor.visitSingularEnumField(value: self.fallbackPolicy, fieldNumber: 2)
    }
    if !self.fallbackKeysSubset.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fallbackKeysSubset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector, rhs: Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.fallbackPolicy != rhs.fallbackPolicy {return false}
    if lhs.fallbackKeysSubset != rhs.fallbackKeysSubset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.LbSubsetConfig.LbSubsetSelector.LbSubsetSelectorFallbackPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_DEFINED"),
    1: .same(proto: "NO_FALLBACK"),
    2: .same(proto: "ANY_ENDPOINT"),
    3: .same(proto: "DEFAULT_SUBSET"),
    4: .same(proto: "KEYS_SUBSET"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".LeastRequestLbConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "choice_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._choiceCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._choiceCount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.LeastRequestLbConfig) -> Bool {
    if lhs._choiceCount != rhs._choiceCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".RingHashLbConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_ring_size"),
    3: .standard(proto: "hash_function"),
    4: .standard(proto: "maximum_ring_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._minimumRingSize)
      case 3: try decoder.decodeSingularEnumField(value: &self.hashFunction)
      case 4: try decoder.decodeSingularMessageField(value: &self._maximumRingSize)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._minimumRingSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.hashFunction != .xxHash {
      try visitor.visitSingularEnumField(value: self.hashFunction, fieldNumber: 3)
    }
    if let v = self._maximumRingSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig) -> Bool {
    if lhs._minimumRingSize != rhs._minimumRingSize {return false}
    if lhs.hashFunction != rhs.hashFunction {return false}
    if lhs._maximumRingSize != rhs._maximumRingSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.RingHashLbConfig.HashFunction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "XX_HASH"),
    1: .same(proto: "MURMUR_HASH_2"),
  ]
}

extension Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".OriginalDstLbConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_http_header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.useHTTPHeader)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useHTTPHeader != false {
      try visitor.visitSingularBoolField(value: self.useHTTPHeader, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.OriginalDstLbConfig) -> Bool {
    if lhs.useHTTPHeader != rhs.useHTTPHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.CommonLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".CommonLbConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "healthy_panic_threshold"),
    2: .standard(proto: "zone_aware_lb_config"),
    3: .standard(proto: "locality_weighted_lb_config"),
    4: .standard(proto: "update_merge_window"),
    5: .standard(proto: "ignore_new_hosts_until_first_hc"),
    6: .standard(proto: "close_connections_on_host_set_change"),
    7: .standard(proto: "consistent_hashing_lb_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._healthyPanicThreshold)
      case 2:
        var v: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig?
        if let current = self.localityConfigSpecifier {
          try decoder.handleConflictingOneOf()
          if case .zoneAwareLbConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.localityConfigSpecifier = .zoneAwareLbConfig(v)}
      case 3:
        var v: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig?
        if let current = self.localityConfigSpecifier {
          try decoder.handleConflictingOneOf()
          if case .localityWeightedLbConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.localityConfigSpecifier = .localityWeightedLbConfig(v)}
      case 4: try decoder.decodeSingularMessageField(value: &self._updateMergeWindow)
      case 5: try decoder.decodeSingularBoolField(value: &self.ignoreNewHostsUntilFirstHc)
      case 6: try decoder.decodeSingularBoolField(value: &self.closeConnectionsOnHostSetChange)
      case 7: try decoder.decodeSingularMessageField(value: &self._consistentHashingLbConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._healthyPanicThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    switch self.localityConfigSpecifier {
    case .zoneAwareLbConfig(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .localityWeightedLbConfig(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    }
    if let v = self._updateMergeWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.ignoreNewHostsUntilFirstHc != false {
      try visitor.visitSingularBoolField(value: self.ignoreNewHostsUntilFirstHc, fieldNumber: 5)
    }
    if self.closeConnectionsOnHostSetChange != false {
      try visitor.visitSingularBoolField(value: self.closeConnectionsOnHostSetChange, fieldNumber: 6)
    }
    if let v = self._consistentHashingLbConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig) -> Bool {
    if lhs._healthyPanicThreshold != rhs._healthyPanicThreshold {return false}
    if lhs.localityConfigSpecifier != rhs.localityConfigSpecifier {return false}
    if lhs._updateMergeWindow != rhs._updateMergeWindow {return false}
    if lhs.ignoreNewHostsUntilFirstHc != rhs.ignoreNewHostsUntilFirstHc {return false}
    if lhs.closeConnectionsOnHostSetChange != rhs.closeConnectionsOnHostSetChange {return false}
    if lhs._consistentHashingLbConfig != rhs._consistentHashingLbConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.protoMessageName + ".ZoneAwareLbConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "routing_enabled"),
    2: .standard(proto: "min_cluster_size"),
    3: .standard(proto: "fail_traffic_on_panic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._routingEnabled)
      case 2: try decoder.decodeSingularMessageField(value: &self._minClusterSize)
      case 3: try decoder.decodeSingularBoolField(value: &self.failTrafficOnPanic)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._routingEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._minClusterSize {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.failTrafficOnPanic != false {
      try visitor.visitSingularBoolField(value: self.failTrafficOnPanic, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ZoneAwareLbConfig) -> Bool {
    if lhs._routingEnabled != rhs._routingEnabled {return false}
    if lhs._minClusterSize != rhs._minClusterSize {return false}
    if lhs.failTrafficOnPanic != rhs.failTrafficOnPanic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.protoMessageName + ".LocalityWeightedLbConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.LocalityWeightedLbConfig) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ConsistentHashingLbConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.protoMessageName + ".ConsistentHashingLbConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_hostname_for_hashing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.useHostnameForHashing)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useHostnameForHashing != false {
      try visitor.visitSingularBoolField(value: self.useHostnameForHashing, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ConsistentHashingLbConfig, rhs: Envoy_Config_Cluster_V3_Cluster.CommonLbConfig.ConsistentHashingLbConfig) -> Bool {
    if lhs.useHostnameForHashing != rhs.useHostnameForHashing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_Cluster.RefreshRate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_Cluster.protoMessageName + ".RefreshRate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_interval"),
    2: .standard(proto: "max_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._baseInterval)
      case 2: try decoder.decodeSingularMessageField(value: &self._maxInterval)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_Cluster.RefreshRate, rhs: Envoy_Config_Cluster_V3_Cluster.RefreshRate) -> Bool {
    if lhs._baseInterval != rhs._baseInterval {return false}
    if lhs._maxInterval != rhs._maxInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_LoadBalancingPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LoadBalancingPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.policies)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.policies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.policies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_LoadBalancingPolicy, rhs: Envoy_Config_Cluster_V3_LoadBalancingPolicy) -> Bool {
    if lhs.policies != rhs.policies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_LoadBalancingPolicy.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Cluster_V3_LoadBalancingPolicy.protoMessageName + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularMessageField(value: &self._typedConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._typedConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_LoadBalancingPolicy.Policy, rhs: Envoy_Config_Cluster_V3_LoadBalancingPolicy.Policy) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._typedConfig != rhs._typedConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_UpstreamBindConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamBindConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._sourceAddress)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._sourceAddress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_UpstreamBindConfig, rhs: Envoy_Config_Cluster_V3_UpstreamBindConfig) -> Bool {
    if lhs._sourceAddress != rhs._sourceAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Cluster_V3_UpstreamConnectionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamConnectionOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tcp_keepalive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._tcpKeepalive)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tcpKeepalive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Cluster_V3_UpstreamConnectionOptions, rhs: Envoy_Config_Cluster_V3_UpstreamConnectionOptions) -> Bool {
    if lhs._tcpKeepalive != rhs._tcpKeepalive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

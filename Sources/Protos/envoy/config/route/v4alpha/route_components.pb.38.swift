// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/route/v4alpha/route_components.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The top level element in the routing configuration is a virtual host. Each virtual host has
/// a logical name as well as a set of domains that get routed to it based on the incoming request's
/// host header. This allows a single listener to service multiple top level domain path trees. Once
/// a virtual host is selected based on the domain, the routes are processed in order to see which
/// upstream cluster to route to or whether to perform a redirect.
/// [#next-free-field: 21]
public struct Envoy_Config_Route_V4alpha_VirtualHost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The logical name of the virtual host. This is used when emitting certain
  /// statistics but is not relevant for routing.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A list of domains (host/authority header) that will be matched to this
  /// virtual host. Wildcard hosts are supported in the suffix or prefix form.
  ///
  /// Domain search order:
  ///  1. Exact domain names: ``www.foo.com``.
  ///  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
  ///  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
  ///  4. Special wildcard ``*`` matching any domain.
  ///
  /// .. note::
  ///
  ///   The wildcard will not match the empty string.
  ///   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
  ///   The longest wildcards match first.
  ///   Only a single virtual host in the entire route configuration can match on ``*``. A domain
  ///   must be unique across all virtual hosts or the config will fail to load.
  ///
  /// Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
  public var domains: [String] {
    get {return _storage._domains}
    set {_uniqueStorage()._domains = newValue}
  }

  /// The list of routes that will be matched, in order, for incoming requests.
  /// The first route that matches will be used.
  public var routes: [Envoy_Config_Route_V4alpha_Route] {
    get {return _storage._routes}
    set {_uniqueStorage()._routes = newValue}
  }

  /// Specifies the type of TLS enforcement the virtual host expects. If this option is not
  /// specified, there is no TLS requirement for the virtual host.
  public var requireTls: Envoy_Config_Route_V4alpha_VirtualHost.TlsRequirementType {
    get {return _storage._requireTls}
    set {_uniqueStorage()._requireTls = newValue}
  }

  /// A list of virtual clusters defined for this virtual host. Virtual clusters
  /// are used for additional statistics gathering.
  public var virtualClusters: [Envoy_Config_Route_V4alpha_VirtualCluster] {
    get {return _storage._virtualClusters}
    set {_uniqueStorage()._virtualClusters = newValue}
  }

  /// Specifies a set of rate limit configurations that will be applied to the
  /// virtual host.
  public var rateLimits: [Envoy_Config_Route_V4alpha_RateLimit] {
    get {return _storage._rateLimits}
    set {_uniqueStorage()._rateLimits = newValue}
  }

  /// Specifies a list of HTTP headers that should be added to each request
  /// handled by this virtual host. Headers specified at this level are applied
  /// after headers from enclosed :ref:`envoy_api_msg_config.route.v4alpha.Route` and before headers from the
  /// enclosing :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration`. For more information, including
  /// details on header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] {
    get {return _storage._requestHeadersToAdd}
    set {_uniqueStorage()._requestHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each request
  /// handled by this virtual host.
  public var requestHeadersToRemove: [String] {
    get {return _storage._requestHeadersToRemove}
    set {_uniqueStorage()._requestHeadersToRemove = newValue}
  }

  /// Specifies a list of HTTP headers that should be added to each response
  /// handled by this virtual host. Headers specified at this level are applied
  /// after headers from enclosed :ref:`envoy_api_msg_config.route.v4alpha.Route` and before headers from the
  /// enclosing :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration`. For more information, including
  /// details on header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] {
    get {return _storage._responseHeadersToAdd}
    set {_uniqueStorage()._responseHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each response
  /// handled by this virtual host.
  public var responseHeadersToRemove: [String] {
    get {return _storage._responseHeadersToRemove}
    set {_uniqueStorage()._responseHeadersToRemove = newValue}
  }

  /// Indicates that the virtual host has a CORS policy.
  public var cors: Envoy_Config_Route_V4alpha_CorsPolicy {
    get {return _storage._cors ?? Envoy_Config_Route_V4alpha_CorsPolicy()}
    set {_uniqueStorage()._cors = newValue}
  }
  /// Returns true if `cors` has been explicitly set.
  public var hasCors: Bool {return _storage._cors != nil}
  /// Clears the value of `cors`. Subsequent reads from it will return its default value.
  public mutating func clearCors() {_uniqueStorage()._cors = nil}

  /// The per_filter_config field can be used to provide virtual host-specific
  /// configurations for filters. The key should match the filter name, such as
  /// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
  /// specific; see the :ref:`HTTP filter documentation <config_http_filters>`
  /// for if and how it is utilized.
  public var typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> {
    get {return _storage._typedPerFilterConfig}
    set {_uniqueStorage()._typedPerFilterConfig = newValue}
  }

  /// Decides whether the :ref:`x-envoy-attempt-count
  /// <config_http_filters_router_x-envoy-attempt-count>` header should be included
  /// in the upstream request. Setting this option will cause it to override any existing header
  /// value, so in the case of two Envoys on the request path with this option enabled, the upstream
  /// will see the attempt count as perceived by the second Envoy. Defaults to false.
  /// This header is unaffected by the
  /// :ref:`suppress_envoy_headers
  /// <envoy_api_field_extensions.filters.http.router.v4alpha.Router.suppress_envoy_headers>` flag.
  ///
  /// [#next-major-version: rename to include_attempt_count_in_request.]
  public var includeRequestAttemptCount: Bool {
    get {return _storage._includeRequestAttemptCount}
    set {_uniqueStorage()._includeRequestAttemptCount = newValue}
  }

  /// Decides whether the :ref:`x-envoy-attempt-count
  /// <config_http_filters_router_x-envoy-attempt-count>` header should be included
  /// in the downstream response. Setting this option will cause the router to override any existing header
  /// value, so in the case of two Envoys on the request path with this option enabled, the downstream
  /// will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
  /// This header is unaffected by the
  /// :ref:`suppress_envoy_headers
  /// <envoy_api_field_extensions.filters.http.router.v4alpha.Router.suppress_envoy_headers>` flag.
  public var includeAttemptCountInResponse: Bool {
    get {return _storage._includeAttemptCountInResponse}
    set {_uniqueStorage()._includeAttemptCountInResponse = newValue}
  }

  /// Indicates the retry policy for all routes in this virtual host. Note that setting a
  /// route level entry will take precedence over this config and it'll be treated
  /// independently (e.g.: values are not inherited).
  public var retryPolicy: Envoy_Config_Route_V4alpha_RetryPolicy {
    get {return _storage._retryPolicy ?? Envoy_Config_Route_V4alpha_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  public var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// [#not-implemented-hide:]
  /// Specifies the configuration for retry policy extension. Note that setting a route level entry
  /// will take precedence over this config and it'll be treated independently (e.g.: values are not
  /// inherited). :ref:`Retry policy <envoy_api_field_config.route.v4alpha.VirtualHost.retry_policy>` should not be
  /// set if this field is used.
  public var retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._retryPolicyTypedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._retryPolicyTypedConfig = newValue}
  }
  /// Returns true if `retryPolicyTypedConfig` has been explicitly set.
  public var hasRetryPolicyTypedConfig: Bool {return _storage._retryPolicyTypedConfig != nil}
  /// Clears the value of `retryPolicyTypedConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicyTypedConfig() {_uniqueStorage()._retryPolicyTypedConfig = nil}

  /// Indicates the hedge policy for all routes in this virtual host. Note that setting a
  /// route level entry will take precedence over this config and it'll be treated
  /// independently (e.g.: values are not inherited).
  public var hedgePolicy: Envoy_Config_Route_V4alpha_HedgePolicy {
    get {return _storage._hedgePolicy ?? Envoy_Config_Route_V4alpha_HedgePolicy()}
    set {_uniqueStorage()._hedgePolicy = newValue}
  }
  /// Returns true if `hedgePolicy` has been explicitly set.
  public var hasHedgePolicy: Bool {return _storage._hedgePolicy != nil}
  /// Clears the value of `hedgePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearHedgePolicy() {_uniqueStorage()._hedgePolicy = nil}

  /// The maximum bytes which will be buffered for retries and shadowing.
  /// If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
  /// value of this and the listener per_connection_buffer_limit_bytes.
  public var perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._perRequestBufferLimitBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._perRequestBufferLimitBytes = newValue}
  }
  /// Returns true if `perRequestBufferLimitBytes` has been explicitly set.
  public var hasPerRequestBufferLimitBytes: Bool {return _storage._perRequestBufferLimitBytes != nil}
  /// Clears the value of `perRequestBufferLimitBytes`. Subsequent reads from it will return its default value.
  public mutating func clearPerRequestBufferLimitBytes() {_uniqueStorage()._perRequestBufferLimitBytes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TlsRequirementType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No TLS requirement for the virtual host.
    case none // = 0

    /// External requests must use TLS. If a request is external and it is not
    /// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
    case externalOnly // = 1

    /// All requests must use TLS. If a request is not using TLS, a 301 redirect
    /// will be sent telling the client to use HTTPS.
    case all // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .externalOnly
      case 2: self = .all
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .externalOnly: return 1
      case .all: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Route_V4alpha_VirtualHost.TlsRequirementType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V4alpha_VirtualHost.TlsRequirementType] = [
    .none,
    .externalOnly,
    .all,
  ]
}

#endif  // swift(>=4.2)

/// A filter-defined action type.
public struct Envoy_Config_Route_V4alpha_FilterAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: SwiftProtobuf.Google_Protobuf_Any {
    get {return _action ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// A route is both a specification of how to match a request as well as an indication of what to do
/// next (e.g., redirect, forward, rewrite, etc.).
///
/// .. attention::
///
///   Envoy supports routing on HTTP method via :ref:`header matching
///   <envoy_api_msg_config.route.v4alpha.HeaderMatcher>`.
/// [#next-free-field: 18]
public struct Envoy_Config_Route_V4alpha_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name for the route.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Route matching parameters.
  public var match: Envoy_Config_Route_V4alpha_RouteMatch {
    get {return _storage._match ?? Envoy_Config_Route_V4alpha_RouteMatch()}
    set {_uniqueStorage()._match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return _storage._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {_uniqueStorage()._match = nil}

  public var action: OneOf_Action? {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// Route request to some upstream cluster.
  public var route: Envoy_Config_Route_V4alpha_RouteAction {
    get {
      if case .route(let v)? = _storage._action {return v}
      return Envoy_Config_Route_V4alpha_RouteAction()
    }
    set {_uniqueStorage()._action = .route(newValue)}
  }

  /// Return a redirect.
  public var redirect: Envoy_Config_Route_V4alpha_RedirectAction {
    get {
      if case .redirect(let v)? = _storage._action {return v}
      return Envoy_Config_Route_V4alpha_RedirectAction()
    }
    set {_uniqueStorage()._action = .redirect(newValue)}
  }

  /// Return an arbitrary HTTP response directly, without proxying.
  public var directResponse: Envoy_Config_Route_V4alpha_DirectResponseAction {
    get {
      if case .directResponse(let v)? = _storage._action {return v}
      return Envoy_Config_Route_V4alpha_DirectResponseAction()
    }
    set {_uniqueStorage()._action = .directResponse(newValue)}
  }

  /// [#not-implemented-hide:]
  /// If true, a filter will define the action (e.g., it could dynamically generate the
  /// RouteAction).
  /// [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
  /// implemented]
  public var filterAction: Envoy_Config_Route_V4alpha_FilterAction {
    get {
      if case .filterAction(let v)? = _storage._action {return v}
      return Envoy_Config_Route_V4alpha_FilterAction()
    }
    set {_uniqueStorage()._action = .filterAction(newValue)}
  }

  /// The Metadata field can be used to provide additional information
  /// about the route. It can be used for configuration, stats, and logging.
  /// The metadata should go under the filter namespace that will need it.
  /// For instance, if the metadata is intended for the Router filter,
  /// the filter name should be specified as *envoy.filters.http.router*.
  public var metadata: Envoy_Config_Core_V4alpha_Metadata {
    get {return _storage._metadata ?? Envoy_Config_Core_V4alpha_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Decorator for the matched route.
  public var decorator: Envoy_Config_Route_V4alpha_Decorator {
    get {return _storage._decorator ?? Envoy_Config_Route_V4alpha_Decorator()}
    set {_uniqueStorage()._decorator = newValue}
  }
  /// Returns true if `decorator` has been explicitly set.
  public var hasDecorator: Bool {return _storage._decorator != nil}
  /// Clears the value of `decorator`. Subsequent reads from it will return its default value.
  public mutating func clearDecorator() {_uniqueStorage()._decorator = nil}

  /// The typed_per_filter_config field can be used to provide route-specific
  /// configurations for filters. The key should match the filter name, such as
  /// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
  /// specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
  /// if and how it is utilized.
  public var typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> {
    get {return _storage._typedPerFilterConfig}
    set {_uniqueStorage()._typedPerFilterConfig = newValue}
  }

  /// Specifies a set of headers that will be added to requests matching this
  /// route. Headers specified at this level are applied before headers from the
  /// enclosing :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost` and
  /// :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration`. For more information, including details on
  /// header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] {
    get {return _storage._requestHeadersToAdd}
    set {_uniqueStorage()._requestHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each request
  /// matching this route.
  public var requestHeadersToRemove: [String] {
    get {return _storage._requestHeadersToRemove}
    set {_uniqueStorage()._requestHeadersToRemove = newValue}
  }

  /// Specifies a set of headers that will be added to responses to requests
  /// matching this route. Headers specified at this level are applied before
  /// headers from the enclosing :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost` and
  /// :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration`. For more information, including
  /// details on header value syntax, see the documentation on
  /// :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
  public var responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] {
    get {return _storage._responseHeadersToAdd}
    set {_uniqueStorage()._responseHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each response
  /// to requests matching this route.
  public var responseHeadersToRemove: [String] {
    get {return _storage._responseHeadersToRemove}
    set {_uniqueStorage()._responseHeadersToRemove = newValue}
  }

  /// Presence of the object defines whether the connection manager's tracing configuration
  /// is overridden by this route specific instance.
  public var tracing: Envoy_Config_Route_V4alpha_Tracing {
    get {return _storage._tracing ?? Envoy_Config_Route_V4alpha_Tracing()}
    set {_uniqueStorage()._tracing = newValue}
  }
  /// Returns true if `tracing` has been explicitly set.
  public var hasTracing: Bool {return _storage._tracing != nil}
  /// Clears the value of `tracing`. Subsequent reads from it will return its default value.
  public mutating func clearTracing() {_uniqueStorage()._tracing = nil}

  /// The maximum bytes which will be buffered for retries and shadowing.
  /// If set, the bytes actually buffered will be the minimum value of this and the
  /// listener per_connection_buffer_limit_bytes.
  public var perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._perRequestBufferLimitBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._perRequestBufferLimitBytes = newValue}
  }
  /// Returns true if `perRequestBufferLimitBytes` has been explicitly set.
  public var hasPerRequestBufferLimitBytes: Bool {return _storage._perRequestBufferLimitBytes != nil}
  /// Clears the value of `perRequestBufferLimitBytes`. Subsequent reads from it will return its default value.
  public mutating func clearPerRequestBufferLimitBytes() {_uniqueStorage()._perRequestBufferLimitBytes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    /// Route request to some upstream cluster.
    case route(Envoy_Config_Route_V4alpha_RouteAction)
    /// Return a redirect.
    case redirect(Envoy_Config_Route_V4alpha_RedirectAction)
    /// Return an arbitrary HTTP response directly, without proxying.
    case directResponse(Envoy_Config_Route_V4alpha_DirectResponseAction)
    /// [#not-implemented-hide:]
    /// If true, a filter will define the action (e.g., it could dynamically generate the
    /// RouteAction).
    /// [#comment: TODO(samflattery): Remove cleanup in route_fuzz_test.cc when
    /// implemented]
    case filterAction(Envoy_Config_Route_V4alpha_FilterAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_Route.OneOf_Action, rhs: Envoy_Config_Route_V4alpha_Route.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.route, .route): return {
        guard case .route(let l) = lhs, case .route(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.redirect, .redirect): return {
        guard case .redirect(let l) = lhs, case .redirect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.directResponse, .directResponse): return {
        guard case .directResponse(let l) = lhs, case .directResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filterAction, .filterAction): return {
        guard case .filterAction(let l) = lhs, case .filterAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Compared to the :ref:`cluster <envoy_api_field_config.route.v4alpha.RouteAction.cluster>` field that specifies a
/// single upstream cluster as the target of a request, the :ref:`weighted_clusters
/// <envoy_api_field_config.route.v4alpha.RouteAction.weighted_clusters>` option allows for specification of
/// multiple upstream clusters along with weights that indicate the percentage of
/// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
/// weights.
public struct Envoy_Config_Route_V4alpha_WeightedCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies one or more upstream clusters associated with the route.
  public var clusters: [Envoy_Config_Route_V4alpha_WeightedCluster.ClusterWeight] = []

  /// Specifies the total weight across all clusters. The sum of all cluster weights must equal this
  /// value, which must be greater than 0. Defaults to 100.
  public var totalWeight: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _totalWeight ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_totalWeight = newValue}
  }
  /// Returns true if `totalWeight` has been explicitly set.
  public var hasTotalWeight: Bool {return self._totalWeight != nil}
  /// Clears the value of `totalWeight`. Subsequent reads from it will return its default value.
  public mutating func clearTotalWeight() {self._totalWeight = nil}

  /// Specifies the runtime key prefix that should be used to construct the
  /// runtime keys associated with each cluster. When the *runtime_key_prefix* is
  /// specified, the router will look for weights associated with each upstream
  /// cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
  /// *cluster[i]* denotes an entry in the clusters array field. If the runtime
  /// key for the cluster does not exist, the value specified in the
  /// configuration file will be used as the default weight. See the :ref:`runtime documentation
  /// <operations_runtime>` for how key names map to the underlying implementation.
  public var runtimeKeyPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// [#next-free-field: 11]
  public struct ClusterWeight {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the upstream cluster. The cluster must exist in the
    /// :ref:`cluster manager configuration <config_cluster_manager>`.
    public var name: String = String()

    /// An integer between 0 and :ref:`total_weight
    /// <envoy_api_field_config.route.v4alpha.WeightedCluster.total_weight>`. When a request matches the route,
    /// the choice of an upstream cluster is determined by its weight. The sum of weights across all
    /// entries in the clusters array must add up to the total_weight, which defaults to 100.
    public var weight: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _weight ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_weight = newValue}
    }
    /// Returns true if `weight` has been explicitly set.
    public var hasWeight: Bool {return self._weight != nil}
    /// Clears the value of `weight`. Subsequent reads from it will return its default value.
    public mutating func clearWeight() {self._weight = nil}

    /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    /// the upstream cluster with metadata matching what is set in this field will be considered for
    /// load balancing. Note that this will be merged with what's provided in
    /// :ref:`RouteAction.metadata_match <envoy_api_field_config.route.v4alpha.RouteAction.metadata_match>`, with
    /// values here taking precedence. The filter name should be specified as *envoy.lb*.
    public var metadataMatch: Envoy_Config_Core_V4alpha_Metadata {
      get {return _metadataMatch ?? Envoy_Config_Core_V4alpha_Metadata()}
      set {_metadataMatch = newValue}
    }
    /// Returns true if `metadataMatch` has been explicitly set.
    public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
    /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
    public mutating func clearMetadataMatch() {self._metadataMatch = nil}

    /// Specifies a list of headers to be added to requests when this cluster is selected
    /// through the enclosing :ref:`envoy_api_msg_config.route.v4alpha.RouteAction`.
    /// Headers specified at this level are applied before headers from the enclosing
    /// :ref:`envoy_api_msg_config.route.v4alpha.Route`, :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost`, and
    /// :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// <config_http_conn_man_headers_custom_request_headers>`.
    public var requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []

    /// Specifies a list of HTTP headers that should be removed from each request when
    /// this cluster is selected through the enclosing :ref:`envoy_api_msg_config.route.v4alpha.RouteAction`.
    public var requestHeadersToRemove: [String] = []

    /// Specifies a list of headers to be added to responses when this cluster is selected
    /// through the enclosing :ref:`envoy_api_msg_config.route.v4alpha.RouteAction`.
    /// Headers specified at this level are applied before headers from the enclosing
    /// :ref:`envoy_api_msg_config.route.v4alpha.Route`, :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost`, and
    /// :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// <config_http_conn_man_headers_custom_request_headers>`.
    public var responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []

    /// Specifies a list of headers to be removed from responses when this cluster is selected
    /// through the enclosing :ref:`envoy_api_msg_config.route.v4alpha.RouteAction`.
    public var responseHeadersToRemove: [String] = []

    /// The per_filter_config field can be used to provide weighted cluster-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation <config_http_filters>`
    /// for if and how it is utilized.
    public var typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _weight: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _metadataMatch: Envoy_Config_Core_V4alpha_Metadata? = nil
  }

  public init() {}

  fileprivate var _totalWeight: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#next-free-field: 13]
public struct Envoy_Config_Route_V4alpha_RouteMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pathSpecifier: Envoy_Config_Route_V4alpha_RouteMatch.OneOf_PathSpecifier? = nil

  /// If specified, the route is a prefix rule meaning that the prefix must
  /// match the beginning of the *:path* header.
  public var prefix: String {
    get {
      if case .prefix(let v)? = pathSpecifier {return v}
      return String()
    }
    set {pathSpecifier = .prefix(newValue)}
  }

  /// If specified, the route is an exact path rule meaning that the path must
  /// exactly match the *:path* header once the query string is removed.
  public var path: String {
    get {
      if case .path(let v)? = pathSpecifier {return v}
      return String()
    }
    set {pathSpecifier = .path(newValue)}
  }

  /// If specified, the route is a regular expression rule meaning that the
  /// regex must match the *:path* header once the query string is removed. The entire path
  /// (without the query string) must match the regex. The rule will not match if only a
  /// subsequence of the *:path* header matches the regex.
  ///
  /// [#next-major-version: In the v3 API we should redo how path specification works such
  /// that we utilize StringMatcher, and additionally have consistent options around whether we
  /// strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
  /// to deprecate the existing options. We should even consider whether we want to do away with
  /// path_specifier entirely and just rely on a set of header matchers which can already match
  /// on :path, etc. The issue with that is it is unclear how to generically deal with query string
  /// stripping. This needs more thought.]
  public var safeRegex: Envoy_Type_Matcher_V4alpha_RegexMatcher {
    get {
      if case .safeRegex(let v)? = pathSpecifier {return v}
      return Envoy_Type_Matcher_V4alpha_RegexMatcher()
    }
    set {pathSpecifier = .safeRegex(newValue)}
  }

  /// If this is used as the matcher, the matcher will only match CONNECT requests.
  /// Note that this will not match HTTP/2 upgrade-style CONNECT requests
  /// (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
  /// upgrades.
  /// This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
  /// where Extended CONNECT requests may have a path, the path matchers will work if
  /// there is a path present.
  /// Note that CONNECT support is currently considered alpha in Envoy.
  /// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
  public var connectMatcher: Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher {
    get {
      if case .connectMatcher(let v)? = pathSpecifier {return v}
      return Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher()
    }
    set {pathSpecifier = .connectMatcher(newValue)}
  }

  /// Indicates that prefix/path matching should be case sensitive. The default
  /// is true.
  public var caseSensitive: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _caseSensitive ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_caseSensitive = newValue}
  }
  /// Returns true if `caseSensitive` has been explicitly set.
  public var hasCaseSensitive: Bool {return self._caseSensitive != nil}
  /// Clears the value of `caseSensitive`. Subsequent reads from it will return its default value.
  public mutating func clearCaseSensitive() {self._caseSensitive = nil}

  /// Indicates that the route should additionally match on a runtime key. Every time the route
  /// is considered for a match, it must also fall under the percentage of matches indicated by
  /// this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
  /// number is <= the value of the numerator N, or if the key is not present, the default
  /// value, the router continues to evaluate the remaining match criteria. A runtime_fraction
  /// route configuration can be used to roll out route changes in a gradual manner without full
  /// code/config deploys. Refer to the :ref:`traffic shifting
  /// <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
  ///
  /// .. note::
  ///
  ///    Parsing this field is implemented such that the runtime key's data may be represented
  ///    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
  ///    integer with the assumption that the value is an integral percentage out of 100. For
  ///    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
  ///    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
  public var runtimeFraction: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent {
    get {return _runtimeFraction ?? Envoy_Config_Core_V4alpha_RuntimeFractionalPercent()}
    set {_runtimeFraction = newValue}
  }
  /// Returns true if `runtimeFraction` has been explicitly set.
  public var hasRuntimeFraction: Bool {return self._runtimeFraction != nil}
  /// Clears the value of `runtimeFraction`. Subsequent reads from it will return its default value.
  public mutating func clearRuntimeFraction() {self._runtimeFraction = nil}

  /// Specifies a set of headers that the route should match on. The router will
  /// check the requestâ€™s headers against all the specified headers in the route
  /// config. A match will happen if all the headers in the route are present in
  /// the request with the same values (or based on presence if the value field
  /// is not in the config).
  public var headers: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

  /// Specifies a set of URL query parameters on which the route should
  /// match. The router will check the query string from the *path* header
  /// against all the specified query parameters. If the number of specified
  /// query parameters is nonzero, they all must match the *path* header's
  /// query string for a match to occur.
  public var queryParameters: [Envoy_Config_Route_V4alpha_QueryParameterMatcher] = []

  /// If specified, only gRPC requests will be matched. The router will check
  /// that the content-type header has a application/grpc or one of the various
  /// application/grpc+ values.
  public var grpc: Envoy_Config_Route_V4alpha_RouteMatch.GrpcRouteMatchOptions {
    get {return _grpc ?? Envoy_Config_Route_V4alpha_RouteMatch.GrpcRouteMatchOptions()}
    set {_grpc = newValue}
  }
  /// Returns true if `grpc` has been explicitly set.
  public var hasGrpc: Bool {return self._grpc != nil}
  /// Clears the value of `grpc`. Subsequent reads from it will return its default value.
  public mutating func clearGrpc() {self._grpc = nil}

  /// If specified, the client tls context will be matched against the defined
  /// match options.
  ///
  /// [#next-major-version: unify with RBAC]
  public var tlsContext: Envoy_Config_Route_V4alpha_RouteMatch.TlsContextMatchOptions {
    get {return _tlsContext ?? Envoy_Config_Route_V4alpha_RouteMatch.TlsContextMatchOptions()}
    set {_tlsContext = newValue}
  }
  /// Returns true if `tlsContext` has been explicitly set.
  public var hasTlsContext: Bool {return self._tlsContext != nil}
  /// Clears the value of `tlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearTlsContext() {self._tlsContext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PathSpecifier: Equatable {
    /// If specified, the route is a prefix rule meaning that the prefix must
    /// match the beginning of the *:path* header.
    case prefix(String)
    /// If specified, the route is an exact path rule meaning that the path must
    /// exactly match the *:path* header once the query string is removed.
    case path(String)
    /// If specified, the route is a regular expression rule meaning that the
    /// regex must match the *:path* header once the query string is removed. The entire path
    /// (without the query string) must match the regex. The rule will not match if only a
    /// subsequence of the *:path* header matches the regex.
    ///
    /// [#next-major-version: In the v3 API we should redo how path specification works such
    /// that we utilize StringMatcher, and additionally have consistent options around whether we
    /// strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    /// to deprecate the existing options. We should even consider whether we want to do away with
    /// path_specifier entirely and just rely on a set of header matchers which can already match
    /// on :path, etc. The issue with that is it is unclear how to generically deal with query string
    /// stripping. This needs more thought.]
    case safeRegex(Envoy_Type_Matcher_V4alpha_RegexMatcher)
    /// If this is used as the matcher, the matcher will only match CONNECT requests.
    /// Note that this will not match HTTP/2 upgrade-style CONNECT requests
    /// (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
    /// upgrades.
    /// This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
    /// where Extended CONNECT requests may have a path, the path matchers will work if
    /// there is a path present.
    /// Note that CONNECT support is currently considered alpha in Envoy.
    /// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
    case connectMatcher(Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteMatch.OneOf_PathSpecifier, rhs: Envoy_Config_Route_V4alpha_RouteMatch.OneOf_PathSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.prefix, .prefix): return {
        guard case .prefix(let l) = lhs, case .prefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.path, .path): return {
        guard case .path(let l) = lhs, case .path(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.safeRegex, .safeRegex): return {
        guard case .safeRegex(let l) = lhs, case .safeRegex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.connectMatcher, .connectMatcher): return {
        guard case .connectMatcher(let l) = lhs, case .connectMatcher(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct GrpcRouteMatchOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TlsContextMatchOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If specified, the route will match against whether or not a certificate is presented.
    /// If not specified, certificate presentation status (true or false) will not be considered when route matching.
    public var presented: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _presented ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_presented = newValue}
    }
    /// Returns true if `presented` has been explicitly set.
    public var hasPresented: Bool {return self._presented != nil}
    /// Clears the value of `presented`. Subsequent reads from it will return its default value.
    public mutating func clearPresented() {self._presented = nil}

    /// If specified, the route will match against whether or not a certificate is validated.
    /// If not specified, certificate validation status (true or false) will not be considered when route matching.
    public var validated: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _validated ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_validated = newValue}
    }
    /// Returns true if `validated` has been explicitly set.
    public var hasValidated: Bool {return self._validated != nil}
    /// Clears the value of `validated`. Subsequent reads from it will return its default value.
    public mutating func clearValidated() {self._validated = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _presented: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _validated: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  /// An extensible message for matching CONNECT requests.
  public struct ConnectMatcher {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _caseSensitive: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _runtimeFraction: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent? = nil
  fileprivate var _grpc: Envoy_Config_Route_V4alpha_RouteMatch.GrpcRouteMatchOptions? = nil
  fileprivate var _tlsContext: Envoy_Config_Route_V4alpha_RouteMatch.TlsContextMatchOptions? = nil
}

/// [#next-free-field: 12]
public struct Envoy_Config_Route_V4alpha_CorsPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies string patterns that match allowed origins. An origin is allowed if any of the
  /// string matchers match.
  public var allowOriginStringMatch: [Envoy_Type_Matcher_V4alpha_StringMatcher] = []

  /// Specifies the content for the *access-control-allow-methods* header.
  public var allowMethods: String = String()

  /// Specifies the content for the *access-control-allow-headers* header.
  public var allowHeaders: String = String()

  /// Specifies the content for the *access-control-expose-headers* header.
  public var exposeHeaders: String = String()

  /// Specifies the content for the *access-control-max-age* header.
  public var maxAge: String = String()

  /// Specifies whether the resource allows credentials.
  public var allowCredentials: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _allowCredentials ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_allowCredentials = newValue}
  }
  /// Returns true if `allowCredentials` has been explicitly set.
  public var hasAllowCredentials: Bool {return self._allowCredentials != nil}
  /// Clears the value of `allowCredentials`. Subsequent reads from it will return its default value.
  public mutating func clearAllowCredentials() {self._allowCredentials = nil}

  public var enabledSpecifier: Envoy_Config_Route_V4alpha_CorsPolicy.OneOf_EnabledSpecifier? = nil

  /// Specifies the % of requests for which the CORS filter is enabled.
  ///
  /// If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
  /// filter will be enabled for 100% of the requests.
  ///
  /// If :ref:`runtime_key <envoy_api_field_config.core.v4alpha.RuntimeFractionalPercent.runtime_key>` is
  /// specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
  public var filterEnabled: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent {
    get {
      if case .filterEnabled(let v)? = enabledSpecifier {return v}
      return Envoy_Config_Core_V4alpha_RuntimeFractionalPercent()
    }
    set {enabledSpecifier = .filterEnabled(newValue)}
  }

  /// Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
  /// enforced.
  ///
  /// This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
  /// fields have to explicitly disable the filter in order for this setting to take effect.
  ///
  /// If :ref:`runtime_key <envoy_api_field_config.core.v4alpha.RuntimeFractionalPercent.runtime_key>` is specified,
  /// Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
  /// and track the request's *Origin* to determine if it's valid but will not enforce any policies.
  public var shadowEnabled: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent {
    get {return _shadowEnabled ?? Envoy_Config_Core_V4alpha_RuntimeFractionalPercent()}
    set {_shadowEnabled = newValue}
  }
  /// Returns true if `shadowEnabled` has been explicitly set.
  public var hasShadowEnabled: Bool {return self._shadowEnabled != nil}
  /// Clears the value of `shadowEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearShadowEnabled() {self._shadowEnabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_EnabledSpecifier: Equatable {
    /// Specifies the % of requests for which the CORS filter is enabled.
    ///
    /// If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
    /// filter will be enabled for 100% of the requests.
    ///
    /// If :ref:`runtime_key <envoy_api_field_config.core.v4alpha.RuntimeFractionalPercent.runtime_key>` is
    /// specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
    case filterEnabled(Envoy_Config_Core_V4alpha_RuntimeFractionalPercent)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_CorsPolicy.OneOf_EnabledSpecifier, rhs: Envoy_Config_Route_V4alpha_CorsPolicy.OneOf_EnabledSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.filterEnabled, .filterEnabled): return {
        guard case .filterEnabled(let l) = lhs, case .filterEnabled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _allowCredentials: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _shadowEnabled: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent? = nil
}

/// [#next-free-field: 37]
public struct Envoy_Config_Route_V4alpha_RouteAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterSpecifier: OneOf_ClusterSpecifier? {
    get {return _storage._clusterSpecifier}
    set {_uniqueStorage()._clusterSpecifier = newValue}
  }

  /// Indicates the upstream cluster to which the request should be routed
  /// to.
  public var cluster: String {
    get {
      if case .cluster(let v)? = _storage._clusterSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._clusterSpecifier = .cluster(newValue)}
  }

  /// Envoy will determine the cluster to route to by reading the value of the
  /// HTTP header named by cluster_header from the request headers. If the
  /// header is not found or the referenced cluster does not exist, Envoy will
  /// return a 404 response.
  ///
  /// .. attention::
  ///
  ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
  ///   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
  ///
  /// .. note::
  ///
  ///   If the header appears multiple times only the first value is used.
  public var clusterHeader: String {
    get {
      if case .clusterHeader(let v)? = _storage._clusterSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._clusterSpecifier = .clusterHeader(newValue)}
  }

  /// Multiple upstream clusters can be specified for a given route. The
  /// request is routed to one of the upstream clusters based on weights
  /// assigned to each cluster. See
  /// :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
  /// for additional documentation.
  public var weightedClusters: Envoy_Config_Route_V4alpha_WeightedCluster {
    get {
      if case .weightedClusters(let v)? = _storage._clusterSpecifier {return v}
      return Envoy_Config_Route_V4alpha_WeightedCluster()
    }
    set {_uniqueStorage()._clusterSpecifier = .weightedClusters(newValue)}
  }

  /// The HTTP status code to use when configured cluster is not found.
  /// The default response code is 503 Service Unavailable.
  public var clusterNotFoundResponseCode: Envoy_Config_Route_V4alpha_RouteAction.ClusterNotFoundResponseCode {
    get {return _storage._clusterNotFoundResponseCode}
    set {_uniqueStorage()._clusterNotFoundResponseCode = newValue}
  }

  /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
  /// in the upstream cluster with metadata matching what's set in this field will be considered
  /// for load balancing. If using :ref:`weighted_clusters
  /// <envoy_api_field_config.route.v4alpha.RouteAction.weighted_clusters>`, metadata will be merged, with values
  /// provided there taking precedence. The filter name should be specified as *envoy.lb*.
  public var metadataMatch: Envoy_Config_Core_V4alpha_Metadata {
    get {return _storage._metadataMatch ?? Envoy_Config_Core_V4alpha_Metadata()}
    set {_uniqueStorage()._metadataMatch = newValue}
  }
  /// Returns true if `metadataMatch` has been explicitly set.
  public var hasMetadataMatch: Bool {return _storage._metadataMatch != nil}
  /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataMatch() {_uniqueStorage()._metadataMatch = nil}

  /// Indicates that during forwarding, the matched prefix (or path) should be
  /// swapped with this value. This option allows application URLs to be rooted
  /// at a different path from those exposed at the reverse proxy layer. The router filter will
  /// place the original path before rewrite into the :ref:`x-envoy-original-path
  /// <config_http_filters_router_x-envoy-original-path>` header.
  ///
  /// Only one of *prefix_rewrite* or
  /// :ref:`regex_rewrite <envoy_api_field_config.route.v4alpha.RouteAction.regex_rewrite>`
  /// may be specified.
  ///
  /// .. attention::
  ///
  ///   Pay careful attention to the use of trailing slashes in the
  ///   :ref:`route's match <envoy_api_field_config.route.v4alpha.Route.match>` prefix value.
  ///   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
  ///   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
  ///   :ref:`Route <envoy_api_msg_config.route.v4alpha.Route>`, as shown by the below config entries:
  ///
  ///   .. code-block:: yaml
  ///
  ///     - match:
  ///         prefix: "/prefix/"
  ///       route:
  ///         prefix_rewrite: "/"
  ///     - match:
  ///         prefix: "/prefix"
  ///       route:
  ///         prefix_rewrite: "/"
  ///
  ///   Having above entries in the config, requests to */prefix* will be stripped to */*, while
  ///   requests to */prefix/etc* will be stripped to */etc*.
  public var prefixRewrite: String {
    get {return _storage._prefixRewrite}
    set {_uniqueStorage()._prefixRewrite = newValue}
  }

  /// Indicates that during forwarding, portions of the path that match the
  /// pattern should be rewritten, even allowing the substitution of capture
  /// groups from the pattern into the new path as specified by the rewrite
  /// substitution string. This is useful to allow application paths to be
  /// rewritten in a way that is aware of segments with variable content like
  /// identifiers. The router filter will place the original path as it was
  /// before the rewrite into the :ref:`x-envoy-original-path
  /// <config_http_filters_router_x-envoy-original-path>` header.
  ///
  /// Only one of :ref:`prefix_rewrite <envoy_api_field_config.route.v4alpha.RouteAction.prefix_rewrite>`
  /// or *regex_rewrite* may be specified.
  ///
  /// Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
  ///
  /// * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
  ///   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
  ///   into ``/v1/api/instance/foo``.
  ///
  /// * The pattern ``one`` paired with a substitution string of ``two`` would
  ///   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
  ///
  /// * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
  ///   ``\1two\2`` would replace only the first occurrence of ``one``,
  ///   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
  ///
  /// * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
  ///   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
  ///   ``/aaa/yyy/bbb``.
  public var regexRewrite: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute {
    get {return _storage._regexRewrite ?? Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute()}
    set {_uniqueStorage()._regexRewrite = newValue}
  }
  /// Returns true if `regexRewrite` has been explicitly set.
  public var hasRegexRewrite: Bool {return _storage._regexRewrite != nil}
  /// Clears the value of `regexRewrite`. Subsequent reads from it will return its default value.
  public mutating func clearRegexRewrite() {_uniqueStorage()._regexRewrite = nil}

  public var hostRewriteSpecifier: OneOf_HostRewriteSpecifier? {
    get {return _storage._hostRewriteSpecifier}
    set {_uniqueStorage()._hostRewriteSpecifier = newValue}
  }

  /// Indicates that during forwarding, the host header will be swapped with
  /// this value.
  public var hostRewriteLiteral: String {
    get {
      if case .hostRewriteLiteral(let v)? = _storage._hostRewriteSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .hostRewriteLiteral(newValue)}
  }

  /// Indicates that during forwarding, the host header will be swapped with
  /// the hostname of the upstream host chosen by the cluster manager. This
  /// option is applicable only when the destination cluster for a route is of
  /// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
  /// types has no effect.
  public var autoHostRewrite: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {
      if case .autoHostRewrite(let v)? = _storage._hostRewriteSpecifier {return v}
      return SwiftProtobuf.Google_Protobuf_BoolValue()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .autoHostRewrite(newValue)}
  }

  /// Indicates that during forwarding, the host header will be swapped with the content of given
  /// downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
  /// If header value is empty, host header is left intact.
  ///
  /// .. attention::
  ///
  ///   Pay attention to the potential security implications of using this option. Provided header
  ///   must come from trusted source.
  ///
  /// .. note::
  ///
  ///   If the header appears multiple times only the first value is used.
  public var hostRewriteHeader: String {
    get {
      if case .hostRewriteHeader(let v)? = _storage._hostRewriteSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .hostRewriteHeader(newValue)}
  }

  /// Indicates that during forwarding, the host header will be swapped with
  /// the result of the regex substitution executed on path value with query and fragment removed.
  /// This is useful for transitioning variable content between path segment and subdomain.
  ///
  /// For example with the following config:
  ///
  ///   .. code-block:: yaml
  ///
  ///     host_rewrite_path_regex:
  ///       pattern:
  ///         google_re2: {}
  ///         regex: "^/(.+)/.+$"
  ///       substitution: \1
  ///
  /// Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`.
  public var hostRewritePathRegex: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute {
    get {
      if case .hostRewritePathRegex(let v)? = _storage._hostRewriteSpecifier {return v}
      return Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .hostRewritePathRegex(newValue)}
  }

  /// Specifies the upstream timeout for the route. If not specified, the default is 15s. This
  /// spans between the point at which the entire downstream request (i.e. end-of-stream) has been
  /// processed and when the upstream response has been completely processed. A value of 0 will
  /// disable the route's timeout.
  ///
  /// .. note::
  ///
  ///   This timeout includes all retries. See also
  ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
  ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
  ///   :ref:`retry overview <arch_overview_http_routing_retry>`.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
  /// although the connection manager wide :ref:`stream_idle_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.stream_idle_timeout>`
  /// will still apply. A value of 0 will completely disable the route's idle timeout, even if a
  /// connection manager stream idle timeout is configured.
  ///
  /// The idle timeout is distinct to :ref:`timeout
  /// <envoy_api_field_config.route.v4alpha.RouteAction.timeout>`, which provides an upper bound
  /// on the upstream response time; :ref:`idle_timeout
  /// <envoy_api_field_config.route.v4alpha.RouteAction.idle_timeout>` instead bounds the amount
  /// of time the request's stream may be idle.
  ///
  /// After header decoding, the idle timeout will apply on downstream and
  /// upstream request events. Each time an encode/decode event for headers or
  /// data is processed for the stream, the timer will be reset. If the timeout
  /// fires, the stream is terminated with a 408 Request Timeout error code if no
  /// upstream response header has been received, otherwise a stream reset
  /// occurs.
  ///
  /// If the :ref:`overload action <config_overload_manager_overload_actions>` "envoy.overload_actions.reduce_timeouts"
  /// is configured, this timeout is scaled according to the value for
  /// :ref:`HTTP_DOWNSTREAM_CONNECTION_IDLE <envoy_api_enum_value_config.overload.v3.ScaleTimersOverloadActionConfig.TimerType.HTTP_DOWNSTREAM_CONNECTION_IDLE>`.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return _storage._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {_uniqueStorage()._idleTimeout = nil}

  /// Indicates that the route has a retry policy. Note that if this is set,
  /// it'll take precedence over the virtual host level retry policy entirely
  /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
  public var retryPolicy: Envoy_Config_Route_V4alpha_RetryPolicy {
    get {return _storage._retryPolicy ?? Envoy_Config_Route_V4alpha_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  public var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// [#not-implemented-hide:]
  /// Specifies the configuration for retry policy extension. Note that if this is set, it'll take
  /// precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
  /// most internal one becomes the enforced policy). :ref:`Retry policy <envoy_api_field_config.route.v4alpha.VirtualHost.retry_policy>`
  /// should not be set if this field is used.
  public var retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._retryPolicyTypedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._retryPolicyTypedConfig = newValue}
  }
  /// Returns true if `retryPolicyTypedConfig` has been explicitly set.
  public var hasRetryPolicyTypedConfig: Bool {return _storage._retryPolicyTypedConfig != nil}
  /// Clears the value of `retryPolicyTypedConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicyTypedConfig() {_uniqueStorage()._retryPolicyTypedConfig = nil}

  /// Indicates that the route has request mirroring policies.
  public var requestMirrorPolicies: [Envoy_Config_Route_V4alpha_RouteAction.RequestMirrorPolicy] {
    get {return _storage._requestMirrorPolicies}
    set {_uniqueStorage()._requestMirrorPolicies = newValue}
  }

  /// Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
  public var priority: Envoy_Config_Core_V4alpha_RoutingPriority {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  /// Specifies a set of rate limit configurations that could be applied to the
  /// route.
  public var rateLimits: [Envoy_Config_Route_V4alpha_RateLimit] {
    get {return _storage._rateLimits}
    set {_uniqueStorage()._rateLimits = newValue}
  }

  /// Specifies a list of hash policies to use for ring hash load balancing. Each
  /// hash policy is evaluated individually and the combined result is used to
  /// route the request. The method of combination is deterministic such that
  /// identical lists of hash policies will produce the same hash. Since a hash
  /// policy examines specific parts of a request, it can fail to produce a hash
  /// (i.e. if the hashed header is not present). If (and only if) all configured
  /// hash policies fail to generate a hash, no hash will be produced for
  /// the route. In this case, the behavior is the same as if no hash policies
  /// were specified (i.e. the ring hash load balancer will choose a random
  /// backend). If a hash policy has the "terminal" attribute set to true, and
  /// there is already a hash generated, the hash is returned immediately,
  /// ignoring the rest of the hash policy list.
  public var hashPolicy: [Envoy_Config_Route_V4alpha_RouteAction.HashPolicy] {
    get {return _storage._hashPolicy}
    set {_uniqueStorage()._hashPolicy = newValue}
  }

  /// Indicates that the route has a CORS policy.
  public var cors: Envoy_Config_Route_V4alpha_CorsPolicy {
    get {return _storage._cors ?? Envoy_Config_Route_V4alpha_CorsPolicy()}
    set {_uniqueStorage()._cors = newValue}
  }
  /// Returns true if `cors` has been explicitly set.
  public var hasCors: Bool {return _storage._cors != nil}
  /// Clears the value of `cors`. Subsequent reads from it will return its default value.
  public mutating func clearCors() {_uniqueStorage()._cors = nil}

  public var upgradeConfigs: [Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig] {
    get {return _storage._upgradeConfigs}
    set {_uniqueStorage()._upgradeConfigs = newValue}
  }

  /// If present, Envoy will try to follow an upstream redirect response instead of proxying the
  /// response back to the downstream. An upstream redirect response is defined
  /// by :ref:`redirect_response_codes
  /// <envoy_api_field_config.route.v4alpha.InternalRedirectPolicy.redirect_response_codes>`.
  public var internalRedirectPolicy: Envoy_Config_Route_V4alpha_InternalRedirectPolicy {
    get {return _storage._internalRedirectPolicy ?? Envoy_Config_Route_V4alpha_InternalRedirectPolicy()}
    set {_uniqueStorage()._internalRedirectPolicy = newValue}
  }
  /// Returns true if `internalRedirectPolicy` has been explicitly set.
  public var hasInternalRedirectPolicy: Bool {return _storage._internalRedirectPolicy != nil}
  /// Clears the value of `internalRedirectPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInternalRedirectPolicy() {_uniqueStorage()._internalRedirectPolicy = nil}

  /// Indicates that the route has a hedge policy. Note that if this is set,
  /// it'll take precedence over the virtual host level hedge policy entirely
  /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
  public var hedgePolicy: Envoy_Config_Route_V4alpha_HedgePolicy {
    get {return _storage._hedgePolicy ?? Envoy_Config_Route_V4alpha_HedgePolicy()}
    set {_uniqueStorage()._hedgePolicy = newValue}
  }
  /// Returns true if `hedgePolicy` has been explicitly set.
  public var hasHedgePolicy: Bool {return _storage._hedgePolicy != nil}
  /// Clears the value of `hedgePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearHedgePolicy() {_uniqueStorage()._hedgePolicy = nil}

  /// Specifies the maximum stream duration for this route.
  public var maxStreamDuration: Envoy_Config_Route_V4alpha_RouteAction.MaxStreamDuration {
    get {return _storage._maxStreamDuration ?? Envoy_Config_Route_V4alpha_RouteAction.MaxStreamDuration()}
    set {_uniqueStorage()._maxStreamDuration = newValue}
  }
  /// Returns true if `maxStreamDuration` has been explicitly set.
  public var hasMaxStreamDuration: Bool {return _storage._maxStreamDuration != nil}
  /// Clears the value of `maxStreamDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxStreamDuration() {_uniqueStorage()._maxStreamDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterSpecifier: Equatable {
    /// Indicates the upstream cluster to which the request should be routed
    /// to.
    case cluster(String)
    /// Envoy will determine the cluster to route to by reading the value of the
    /// HTTP header named by cluster_header from the request headers. If the
    /// header is not found or the referenced cluster does not exist, Envoy will
    /// return a 404 response.
    ///
    /// .. attention::
    ///
    ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
    ///   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
    ///
    /// .. note::
    ///
    ///   If the header appears multiple times only the first value is used.
    case clusterHeader(String)
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster. See
    /// :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
    /// for additional documentation.
    case weightedClusters(Envoy_Config_Route_V4alpha_WeightedCluster)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.OneOf_ClusterSpecifier, rhs: Envoy_Config_Route_V4alpha_RouteAction.OneOf_ClusterSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cluster, .cluster): return {
        guard case .cluster(let l) = lhs, case .cluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clusterHeader, .clusterHeader): return {
        guard case .clusterHeader(let l) = lhs, case .clusterHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weightedClusters, .weightedClusters): return {
        guard case .weightedClusters(let l) = lhs, case .weightedClusters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_HostRewriteSpecifier: Equatable {
    /// Indicates that during forwarding, the host header will be swapped with
    /// this value.
    case hostRewriteLiteral(String)
    /// Indicates that during forwarding, the host header will be swapped with
    /// the hostname of the upstream host chosen by the cluster manager. This
    /// option is applicable only when the destination cluster for a route is of
    /// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
    /// types has no effect.
    case autoHostRewrite(SwiftProtobuf.Google_Protobuf_BoolValue)
    /// Indicates that during forwarding, the host header will be swapped with the content of given
    /// downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
    /// If header value is empty, host header is left intact.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the potential security implications of using this option. Provided header
    ///   must come from trusted source.
    ///
    /// .. note::
    ///
    ///   If the header appears multiple times only the first value is used.
    case hostRewriteHeader(String)
    /// Indicates that during forwarding, the host header will be swapped with
    /// the result of the regex substitution executed on path value with query and fragment removed.
    /// This is useful for transitioning variable content between path segment and subdomain.
    ///
    /// For example with the following config:
    ///
    ///   .. code-block:: yaml
    ///
    ///     host_rewrite_path_regex:
    ///       pattern:
    ///         google_re2: {}
    ///         regex: "^/(.+)/.+$"
    ///       substitution: \1
    ///
    /// Would rewrite the host header to `envoyproxy.io` given the path `/envoyproxy.io/some/path`.
    case hostRewritePathRegex(Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.OneOf_HostRewriteSpecifier, rhs: Envoy_Config_Route_V4alpha_RouteAction.OneOf_HostRewriteSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hostRewriteLiteral, .hostRewriteLiteral): return {
        guard case .hostRewriteLiteral(let l) = lhs, case .hostRewriteLiteral(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autoHostRewrite, .autoHostRewrite): return {
        guard case .autoHostRewrite(let l) = lhs, case .autoHostRewrite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hostRewriteHeader, .hostRewriteHeader): return {
        guard case .hostRewriteHeader(let l) = lhs, case .hostRewriteHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hostRewritePathRegex, .hostRewritePathRegex): return {
        guard case .hostRewritePathRegex(let l) = lhs, case .hostRewritePathRegex(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ClusterNotFoundResponseCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// HTTP status code - 503 Service Unavailable.
    case serviceUnavailable // = 0

    /// HTTP status code - 404 Not Found.
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .serviceUnavailable
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .serviceUnavailable
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .serviceUnavailable: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The router is capable of shadowing traffic from one cluster to another. The current
  /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
  /// respond before returning the response from the primary cluster. All normal statistics are
  /// collected for the shadow cluster making this feature useful for testing.
  ///
  /// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
  /// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
  ///
  /// .. note::
  ///
  ///   Shadowing will not be triggered if the primary cluster does not exist.
  public struct RequestMirrorPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the cluster that requests will be mirrored to. The cluster must
    /// exist in the cluster manager configuration.
    public var cluster: String = String()

    /// If not specified, all requests to the target cluster will be mirrored.
    ///
    /// If specified, this field takes precedence over the `runtime_key` field and requests must also
    /// fall under the percentage of matches indicated by this field.
    ///
    /// For some fraction N/D, a random number in the range [0,D) is selected. If the
    /// number is <= the value of the numerator N, or if the key is not present, the default
    /// value, the request will be mirrored.
    public var runtimeFraction: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent {
      get {return _runtimeFraction ?? Envoy_Config_Core_V4alpha_RuntimeFractionalPercent()}
      set {_runtimeFraction = newValue}
    }
    /// Returns true if `runtimeFraction` has been explicitly set.
    public var hasRuntimeFraction: Bool {return self._runtimeFraction != nil}
    /// Clears the value of `runtimeFraction`. Subsequent reads from it will return its default value.
    public mutating func clearRuntimeFraction() {self._runtimeFraction = nil}

    /// Determines if the trace span should be sampled. Defaults to true.
    public var traceSampled: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _traceSampled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_traceSampled = newValue}
    }
    /// Returns true if `traceSampled` has been explicitly set.
    public var hasTraceSampled: Bool {return self._traceSampled != nil}
    /// Clears the value of `traceSampled`. Subsequent reads from it will return its default value.
    public mutating func clearTraceSampled() {self._traceSampled = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _runtimeFraction: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent? = nil
    fileprivate var _traceSampled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  /// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
  /// <arch_overview_load_balancing_types>`.
  /// [#next-free-field: 7]
  public struct HashPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var policySpecifier: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.OneOf_PolicySpecifier? = nil

    /// Header hash policy.
    public var header: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header {
      get {
        if case .header(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header()
      }
      set {policySpecifier = .header(newValue)}
    }

    /// Cookie hash policy.
    public var cookie: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie {
      get {
        if case .cookie(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie()
      }
      set {policySpecifier = .cookie(newValue)}
    }

    /// Connection properties hash policy.
    public var connectionProperties: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties {
      get {
        if case .connectionProperties(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties()
      }
      set {policySpecifier = .connectionProperties(newValue)}
    }

    /// Query parameter hash policy.
    public var queryParameter: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter {
      get {
        if case .queryParameter(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter()
      }
      set {policySpecifier = .queryParameter(newValue)}
    }

    /// Filter state hash policy.
    public var filterState: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState {
      get {
        if case .filterState(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState()
      }
      set {policySpecifier = .filterState(newValue)}
    }

    /// The flag that short-circuits the hash computing. This field provides a
    /// 'fallback' style of configuration: "if a terminal policy doesn't work,
    /// fallback to rest of the policy list", it saves time when the terminal
    /// policy works.
    ///
    /// If true, and there is already a hash computed, ignore rest of the
    /// list of hash polices.
    /// For example, if the following hash methods are configured:
    ///
    ///  ========= ========
    ///  specifier terminal
    ///  ========= ========
    ///  Header A  true
    ///  Header B  false
    ///  Header C  false
    ///  ========= ========
    ///
    /// The generateHash process ends if policy "header A" generates a hash, as
    /// it's a terminal policy.
    public var terminal: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_PolicySpecifier: Equatable {
      /// Header hash policy.
      case header(Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header)
      /// Cookie hash policy.
      case cookie(Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie)
      /// Connection properties hash policy.
      case connectionProperties(Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties)
      /// Query parameter hash policy.
      case queryParameter(Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter)
      /// Filter state hash policy.
      case filterState(Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.OneOf_PolicySpecifier, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.OneOf_PolicySpecifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.header, .header): return {
          guard case .header(let l) = lhs, case .header(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cookie, .cookie): return {
          guard case .cookie(let l) = lhs, case .cookie(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.connectionProperties, .connectionProperties): return {
          guard case .connectionProperties(let l) = lhs, case .connectionProperties(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.queryParameter, .queryParameter): return {
          guard case .queryParameter(let l) = lhs, case .queryParameter(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.filterState, .filterState): return {
          guard case .filterState(let l) = lhs, case .filterState(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct Header {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the request header that will be used to obtain the hash
      /// key. If the request header is not present, no hash will be produced.
      public var headerName: String = String()

      /// If specified, the request header value will be rewritten and used
      /// to produce the hash key.
      public var regexRewrite: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute {
        get {return _regexRewrite ?? Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute()}
        set {_regexRewrite = newValue}
      }
      /// Returns true if `regexRewrite` has been explicitly set.
      public var hasRegexRewrite: Bool {return self._regexRewrite != nil}
      /// Clears the value of `regexRewrite`. Subsequent reads from it will return its default value.
      public mutating func clearRegexRewrite() {self._regexRewrite = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _regexRewrite: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute? = nil
    }

    /// Envoy supports two types of cookie affinity:
    ///
    /// 1. Passive. Envoy takes a cookie that's present in the cookies header and
    ///    hashes on its value.
    ///
    /// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
    ///    on the first request from the client in its response to the client,
    ///    based on the endpoint the request gets sent to. The client then
    ///    presents this on the next and all subsequent requests. The hash of
    ///    this is sufficient to ensure these requests get sent to the same
    ///    endpoint. The cookie is generated by hashing the source and
    ///    destination ports and addresses so that multiple independent HTTP2
    ///    streams on the same connection will independently receive the same
    ///    cookie, even if they arrive at the Envoy simultaneously.
    public struct Cookie {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the cookie that will be used to obtain the hash key. If the
      /// cookie is not present and ttl below is not set, no hash will be
      /// produced.
      public var name: String = String()

      /// If specified, a cookie with the TTL will be generated if the cookie is
      /// not present. If the TTL is present and zero, the generated cookie will
      /// be a session cookie.
      public var ttl: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_ttl = newValue}
      }
      /// Returns true if `ttl` has been explicitly set.
      public var hasTtl: Bool {return self._ttl != nil}
      /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
      public mutating func clearTtl() {self._ttl = nil}

      /// The name of the path for the cookie. If no path is specified here, no path
      /// will be set for the cookie.
      public var path: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
    }

    public struct ConnectionProperties {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Hash on source IP address.
      public var sourceIp: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct QueryParameter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the URL query parameter that will be used to obtain the hash
      /// key. If the parameter is not present, no hash will be produced. Query
      /// parameter names are case-sensitive.
      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct FilterState {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the Object in the per-request filterState, which is an
      /// Envoy::Http::Hashable object. If there is no data associated with the key,
      /// or the stored object is not Envoy::Http::Hashable, no hash will be produced.
      public var key: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Allows enabling and disabling upgrades on a per-route basis.
  /// This overrides any enabled/disabled upgrade filter chain specified in the
  /// HttpConnectionManager
  /// :ref:`upgrade_configs
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.upgrade_configs>`
  /// but does not affect any custom filter chain specified there.
  public struct UpgradeConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The case-insensitive name of this upgrade, e.g. "websocket".
    /// For each upgrade type present in upgrade_configs, requests with
    /// Upgrade: [upgrade_type] will be proxied upstream.
    public var upgradeType: String = String()

    /// Determines if upgrades are available on this route. Defaults to true.
    public var enabled: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _enabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_enabled = newValue}
    }
    /// Returns true if `enabled` has been explicitly set.
    public var hasEnabled: Bool {return self._enabled != nil}
    /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
    public mutating func clearEnabled() {self._enabled = nil}

    /// Configuration for sending data upstream as a raw data payload. This is used for
    /// CONNECT requests, when forwarding CONNECT payload as raw TCP.
    /// Note that CONNECT support is currently considered alpha in Envoy.
    /// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
    public var connectConfig: Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.ConnectConfig {
      get {return _connectConfig ?? Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.ConnectConfig()}
      set {_connectConfig = newValue}
    }
    /// Returns true if `connectConfig` has been explicitly set.
    public var hasConnectConfig: Bool {return self._connectConfig != nil}
    /// Clears the value of `connectConfig`. Subsequent reads from it will return its default value.
    public mutating func clearConnectConfig() {self._connectConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Configuration for sending data upstream as a raw data payload. This is used for
    /// CONNECT requests, when forwarding CONNECT payload as raw TCP.
    public struct ConnectConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream.
      public var proxyProtocolConfig: Envoy_Config_Core_V4alpha_ProxyProtocolConfig {
        get {return _proxyProtocolConfig ?? Envoy_Config_Core_V4alpha_ProxyProtocolConfig()}
        set {_proxyProtocolConfig = newValue}
      }
      /// Returns true if `proxyProtocolConfig` has been explicitly set.
      public var hasProxyProtocolConfig: Bool {return self._proxyProtocolConfig != nil}
      /// Clears the value of `proxyProtocolConfig`. Subsequent reads from it will return its default value.
      public mutating func clearProxyProtocolConfig() {self._proxyProtocolConfig = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _proxyProtocolConfig: Envoy_Config_Core_V4alpha_ProxyProtocolConfig? = nil
    }

    public init() {}

    fileprivate var _enabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _connectConfig: Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.ConnectConfig? = nil
  }

  public struct MaxStreamDuration {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the maximum duration allowed for streams on the route. If not specified, the value
    /// from the :ref:`max_stream_duration
    /// <envoy_api_field_config.core.v4alpha.HttpProtocolOptions.max_stream_duration>` field in
    /// :ref:`HttpConnectionManager.common_http_protocol_options
    /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.common_http_protocol_options>`
    /// is used. If this field is set explicitly to zero, any
    /// HttpConnectionManager max_stream_duration timeout will be disabled for
    /// this route.
    public var maxStreamDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxStreamDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxStreamDuration = newValue}
    }
    /// Returns true if `maxStreamDuration` has been explicitly set.
    public var hasMaxStreamDuration: Bool {return self._maxStreamDuration != nil}
    /// Clears the value of `maxStreamDuration`. Subsequent reads from it will return its default value.
    public mutating func clearMaxStreamDuration() {self._maxStreamDuration = nil}

    /// If present, and the request contains a `grpc-timeout header
    /// <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, use that value as the
    /// *max_stream_duration*, but limit the applied timeout to the maximum value specified here.
    /// If set to 0, the `grpc-timeout` header is used without modification.
    public var grpcTimeoutHeaderMax: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _grpcTimeoutHeaderMax ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_grpcTimeoutHeaderMax = newValue}
    }
    /// Returns true if `grpcTimeoutHeaderMax` has been explicitly set.
    public var hasGrpcTimeoutHeaderMax: Bool {return self._grpcTimeoutHeaderMax != nil}
    /// Clears the value of `grpcTimeoutHeaderMax`. Subsequent reads from it will return its default value.
    public mutating func clearGrpcTimeoutHeaderMax() {self._grpcTimeoutHeaderMax = nil}

    /// If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by
    /// subtracting the provided duration from the header. This is useful for allowing Envoy to set
    /// its global timeout to be less than that of the deadline imposed by the calling client, which
    /// makes it more likely that Envoy will handle the timeout instead of having the call canceled
    /// by the client. If, after applying the offset, the resulting timeout is zero or negative,
    /// the stream will timeout immediately.
    public var grpcTimeoutHeaderOffset: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _grpcTimeoutHeaderOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_grpcTimeoutHeaderOffset = newValue}
    }
    /// Returns true if `grpcTimeoutHeaderOffset` has been explicitly set.
    public var hasGrpcTimeoutHeaderOffset: Bool {return self._grpcTimeoutHeaderOffset != nil}
    /// Clears the value of `grpcTimeoutHeaderOffset`. Subsequent reads from it will return its default value.
    public mutating func clearGrpcTimeoutHeaderOffset() {self._grpcTimeoutHeaderOffset = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _maxStreamDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _grpcTimeoutHeaderMax: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _grpcTimeoutHeaderOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Route_V4alpha_RouteAction.ClusterNotFoundResponseCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V4alpha_RouteAction.ClusterNotFoundResponseCode] = [
    .serviceUnavailable,
    .notFound,
  ]
}

#endif  // swift(>=4.2)

/// HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
/// [#next-free-field: 12]
public struct Envoy_Config_Route_V4alpha_RetryPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the conditions under which retry takes place. These are the same
  /// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
  /// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
  public var retryOn: String {
    get {return _storage._retryOn}
    set {_uniqueStorage()._retryOn = newValue}
  }

  /// Specifies the allowed number of retries. This parameter is optional and
  /// defaults to 1. These are the same conditions documented for
  /// :ref:`config_http_filters_router_x-envoy-max-retries`.
  public var maxRetries: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxRetries ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxRetries = newValue}
  }
  /// Returns true if `maxRetries` has been explicitly set.
  public var hasMaxRetries: Bool {return _storage._maxRetries != nil}
  /// Clears the value of `maxRetries`. Subsequent reads from it will return its default value.
  public mutating func clearMaxRetries() {_uniqueStorage()._maxRetries = nil}

  /// Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
  /// same conditions documented for
  /// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
  ///
  /// .. note::
  ///
  ///   If left unspecified, Envoy will use the global
  ///   :ref:`route timeout <envoy_api_field_config.route.v4alpha.RouteAction.timeout>` for the request.
  ///   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
  ///   retry policy, a request that times out will not be retried as the total timeout budget
  ///   would have been exhausted.
  public var perTryTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._perTryTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._perTryTimeout = newValue}
  }
  /// Returns true if `perTryTimeout` has been explicitly set.
  public var hasPerTryTimeout: Bool {return _storage._perTryTimeout != nil}
  /// Clears the value of `perTryTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearPerTryTimeout() {_uniqueStorage()._perTryTimeout = nil}

  /// Specifies an implementation of a RetryPriority which is used to determine the
  /// distribution of load across priorities used for retries. Refer to
  /// :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
  public var retryPriority: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority {
    get {return _storage._retryPriority ?? Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority()}
    set {_uniqueStorage()._retryPriority = newValue}
  }
  /// Returns true if `retryPriority` has been explicitly set.
  public var hasRetryPriority: Bool {return _storage._retryPriority != nil}
  /// Clears the value of `retryPriority`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPriority() {_uniqueStorage()._retryPriority = nil}

  /// Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
  /// for retries. If any of the predicates reject the host, host selection will be reattempted.
  /// Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
  /// details.
  public var retryHostPredicate: [Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate] {
    get {return _storage._retryHostPredicate}
    set {_uniqueStorage()._retryHostPredicate = newValue}
  }

  /// The maximum number of times host selection will be reattempted before giving up, at which
  /// point the host that was last selected will be routed to. If unspecified, this will default to
  /// retrying once.
  public var hostSelectionRetryMaxAttempts: Int64 {
    get {return _storage._hostSelectionRetryMaxAttempts}
    set {_uniqueStorage()._hostSelectionRetryMaxAttempts = newValue}
  }

  /// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
  public var retriableStatusCodes: [UInt32] {
    get {return _storage._retriableStatusCodes}
    set {_uniqueStorage()._retriableStatusCodes = newValue}
  }

  /// Specifies parameters that control exponential retry back off. This parameter is optional, in which case the
  /// default base interval is 25 milliseconds or, if set, the current value of the
  /// `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
  /// the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
  /// describes Envoy's back-off algorithm.
  public var retryBackOff: Envoy_Config_Route_V4alpha_RetryPolicy.RetryBackOff {
    get {return _storage._retryBackOff ?? Envoy_Config_Route_V4alpha_RetryPolicy.RetryBackOff()}
    set {_uniqueStorage()._retryBackOff = newValue}
  }
  /// Returns true if `retryBackOff` has been explicitly set.
  public var hasRetryBackOff: Bool {return _storage._retryBackOff != nil}
  /// Clears the value of `retryBackOff`. Subsequent reads from it will return its default value.
  public mutating func clearRetryBackOff() {_uniqueStorage()._retryBackOff = nil}

  /// Specifies parameters that control a retry back-off strategy that is used
  /// when the request is rate limited by the upstream server. The server may
  /// return a response header like ``Retry-After`` or ``X-RateLimit-Reset`` to
  /// provide feedback to the client on how long to wait before retrying. If
  /// configured, this back-off strategy will be used instead of the
  /// default exponential back off strategy (configured using `retry_back_off`)
  /// whenever a response includes the matching headers.
  public var rateLimitedRetryBackOff: Envoy_Config_Route_V4alpha_RetryPolicy.RateLimitedRetryBackOff {
    get {return _storage._rateLimitedRetryBackOff ?? Envoy_Config_Route_V4alpha_RetryPolicy.RateLimitedRetryBackOff()}
    set {_uniqueStorage()._rateLimitedRetryBackOff = newValue}
  }
  /// Returns true if `rateLimitedRetryBackOff` has been explicitly set.
  public var hasRateLimitedRetryBackOff: Bool {return _storage._rateLimitedRetryBackOff != nil}
  /// Clears the value of `rateLimitedRetryBackOff`. Subsequent reads from it will return its default value.
  public mutating func clearRateLimitedRetryBackOff() {_uniqueStorage()._rateLimitedRetryBackOff = nil}

  /// HTTP response headers that trigger a retry if present in the response. A retry will be
  /// triggered if any of the header matches match the upstream response headers.
  /// The field is only consulted if 'retriable-headers' retry policy is active.
  public var retriableHeaders: [Envoy_Config_Route_V4alpha_HeaderMatcher] {
    get {return _storage._retriableHeaders}
    set {_uniqueStorage()._retriableHeaders = newValue}
  }

  /// HTTP headers which must be present in the request for retries to be attempted.
  public var retriableRequestHeaders: [Envoy_Config_Route_V4alpha_HeaderMatcher] {
    get {return _storage._retriableRequestHeaders}
    set {_uniqueStorage()._retriableRequestHeaders = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ResetHeaderFormat: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case seconds // = 0
    case unixTimestamp // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .seconds
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .seconds
      case 1: self = .unixTimestamp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .seconds: return 0
      case .unixTimestamp: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct RetryPriority {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var configType: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority.OneOf_ConfigType? = nil

    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {
        if case .typedConfig(let v)? = configType {return v}
        return SwiftProtobuf.Google_Protobuf_Any()
      }
      set {configType = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ConfigType: Equatable {
      case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority.OneOf_ConfigType, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority.OneOf_ConfigType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.typedConfig, .typedConfig): return {
          guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  public struct RetryHostPredicate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var configType: Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate.OneOf_ConfigType? = nil

    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {
        if case .typedConfig(let v)? = configType {return v}
        return SwiftProtobuf.Google_Protobuf_Any()
      }
      set {configType = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ConfigType: Equatable {
      case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate.OneOf_ConfigType, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate.OneOf_ConfigType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.typedConfig, .typedConfig): return {
          guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  public struct RetryBackOff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the base interval between retries. This parameter is required and must be greater
    /// than zero. Values less than 1 ms are rounded up to 1 ms.
    /// See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
    /// back-off algorithm.
    public var baseInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _baseInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_baseInterval = newValue}
    }
    /// Returns true if `baseInterval` has been explicitly set.
    public var hasBaseInterval: Bool {return self._baseInterval != nil}
    /// Clears the value of `baseInterval`. Subsequent reads from it will return its default value.
    public mutating func clearBaseInterval() {self._baseInterval = nil}

    /// Specifies the maximum interval between retries. This parameter is optional, but must be
    /// greater than or equal to the `base_interval` if set. The default is 10 times the
    /// `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
    /// of Envoy's back-off algorithm.
    public var maxInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxInterval = newValue}
    }
    /// Returns true if `maxInterval` has been explicitly set.
    public var hasMaxInterval: Bool {return self._maxInterval != nil}
    /// Clears the value of `maxInterval`. Subsequent reads from it will return its default value.
    public mutating func clearMaxInterval() {self._maxInterval = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _baseInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _maxInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public struct ResetHeader {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the reset header.
    ///
    /// .. note::
    ///
    ///   If the header appears multiple times only the first value is used.
    public var name: String = String()

    /// The format of the reset header.
    public var format: Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeaderFormat = .seconds

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A retry back-off strategy that applies when the upstream server rate limits
  /// the request.
  ///
  /// Given this configuration:
  ///
  /// .. code-block:: yaml
  ///
  ///   rate_limited_retry_back_off:
  ///     reset_headers:
  ///     - name: Retry-After
  ///       format: SECONDS
  ///     - name: X-RateLimit-Reset
  ///       format: UNIX_TIMESTAMP
  ///     max_interval: "300s"
  ///
  /// The following algorithm will apply:
  ///
  ///  1. If the response contains the header ``Retry-After`` its value must be on
  ///     the form ``120`` (an integer that represents the number of seconds to
  ///     wait before retrying). If so, this value is used as the back-off interval.
  ///  2. Otherwise, if the response contains the header ``X-RateLimit-Reset`` its
  ///     value must be on the form ``1595320702`` (an integer that represents the
  ///     point in time at which to retry, as a Unix timestamp in seconds). If so,
  ///     the current time is subtracted from this value and the result is used as
  ///     the back-off interval.
  ///  3. Otherwise, Envoy will use the default
  ///     :ref:`exponential back-off <envoy_v3_api_field_config.route.v3.RetryPolicy.retry_back_off>`
  ///     strategy.
  ///
  /// No matter which format is used, if the resulting back-off interval exceeds
  /// ``max_interval`` it is discarded and the next header in ``reset_headers``
  /// is tried. If a request timeout is configured for the route it will further
  /// limit how long the request will be allowed to run.
  ///
  /// To prevent many clients retrying at the same point in time jitter is added
  /// to the back-off interval, so the resulting interval is decided by taking:
  /// ``random(interval, interval * 1.5)``.
  ///
  /// .. attention::
  ///
  ///   Configuring ``rate_limited_retry_back_off`` will not by itself cause a request
  ///   to be retried. You will still need to configure the right retry policy to match
  ///   the responses from the upstream server.
  public struct RateLimitedRetryBackOff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the reset headers (like ``Retry-After`` or ``X-RateLimit-Reset``)
    /// to match against the response. Headers are tried in order, and matched case
    /// insensitive. The first header to be parsed successfully is used. If no headers
    /// match the default exponential back-off is used instead.
    public var resetHeaders: [Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeader] = []

    /// Specifies the maximum back off interval that Envoy will allow. If a reset
    /// header contains an interval longer than this then it will be discarded and
    /// the next header will be tried. Defaults to 300 seconds.
    public var maxInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxInterval = newValue}
    }
    /// Returns true if `maxInterval` has been explicitly set.
    public var hasMaxInterval: Bool {return self._maxInterval != nil}
    /// Clears the value of `maxInterval`. Subsequent reads from it will return its default value.
    public mutating func clearMaxInterval() {self._maxInterval = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _maxInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeaderFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeaderFormat] = [
    .seconds,
    .unixTimestamp,
  ]
}

#endif  // swift(>=4.2)

/// HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
public struct Envoy_Config_Route_V4alpha_HedgePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the number of initial requests that should be sent upstream.
  /// Must be at least 1.
  /// Defaults to 1.
  /// [#not-implemented-hide:]
  public var initialRequests: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _initialRequests ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_initialRequests = newValue}
  }
  /// Returns true if `initialRequests` has been explicitly set.
  public var hasInitialRequests: Bool {return self._initialRequests != nil}
  /// Clears the value of `initialRequests`. Subsequent reads from it will return its default value.
  public mutating func clearInitialRequests() {self._initialRequests = nil}

  /// Specifies a probability that an additional upstream request should be sent
  /// on top of what is specified by initial_requests.
  /// Defaults to 0.
  /// [#not-implemented-hide:]
  public var additionalRequestChance: Envoy_Type_V3_FractionalPercent {
    get {return _additionalRequestChance ?? Envoy_Type_V3_FractionalPercent()}
    set {_additionalRequestChance = newValue}
  }
  /// Returns true if `additionalRequestChance` has been explicitly set.
  public var hasAdditionalRequestChance: Bool {return self._additionalRequestChance != nil}
  /// Clears the value of `additionalRequestChance`. Subsequent reads from it will return its default value.
  public mutating func clearAdditionalRequestChance() {self._additionalRequestChance = nil}

  /// Indicates that a hedged request should be sent when the per-try timeout
  /// is hit. This will only occur if the retry policy also indicates that a
  /// timed out request should be retried.
  /// Once a timed out request is retried due to per try timeout, the router
  /// filter will ensure that it is not retried again even if the returned
  /// response headers would otherwise be retried according the specified
  /// :ref:`RetryPolicy <envoy_api_msg_config.route.v4alpha.RetryPolicy>`.
  /// Defaults to false.
  public var hedgeOnPerTryTimeout: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialRequests: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _additionalRequestChance: Envoy_Type_V3_FractionalPercent? = nil
}

/// [#next-free-field: 9]
public struct Envoy_Config_Route_V4alpha_RedirectAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When the scheme redirection take place, the following rules apply:
  ///  1. If the source URI scheme is `http` and the port is explicitly
  ///     set to `:80`, the port will be removed after the redirection
  ///  2. If the source URI scheme is `https` and the port is explicitly
  ///     set to `:443`, the port will be removed after the redirection
  public var schemeRewriteSpecifier: Envoy_Config_Route_V4alpha_RedirectAction.OneOf_SchemeRewriteSpecifier? = nil

  /// The scheme portion of the URL will be swapped with "https".
  public var httpsRedirect: Bool {
    get {
      if case .httpsRedirect(let v)? = schemeRewriteSpecifier {return v}
      return false
    }
    set {schemeRewriteSpecifier = .httpsRedirect(newValue)}
  }

  /// The scheme portion of the URL will be swapped with this value.
  public var schemeRedirect: String {
    get {
      if case .schemeRedirect(let v)? = schemeRewriteSpecifier {return v}
      return String()
    }
    set {schemeRewriteSpecifier = .schemeRedirect(newValue)}
  }

  /// The host portion of the URL will be swapped with this value.
  public var hostRedirect: String = String()

  /// The port value of the URL will be swapped with this value.
  public var portRedirect: UInt32 = 0

  public var pathRewriteSpecifier: Envoy_Config_Route_V4alpha_RedirectAction.OneOf_PathRewriteSpecifier? = nil

  /// The path portion of the URL will be swapped with this value.
  /// Please note that query string in path_redirect will override the
  /// request's query string and will not be stripped.
  ///
  /// For example, let's say we have the following routes:
  ///
  /// - match: { path: "/old-path-1" }
  ///   redirect: { path_redirect: "/new-path-1" }
  /// - match: { path: "/old-path-2" }
  ///   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
  /// - match: { path: "/old-path-3" }
  ///   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
  ///
  /// 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
  /// 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
  /// 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
  public var pathRedirect: String {
    get {
      if case .pathRedirect(let v)? = pathRewriteSpecifier {return v}
      return String()
    }
    set {pathRewriteSpecifier = .pathRedirect(newValue)}
  }

  /// Indicates that during redirection, the matched prefix (or path)
  /// should be swapped with this value. This option allows redirect URLs be dynamically created
  /// based on the request.
  ///
  /// .. attention::
  ///
  ///   Pay attention to the use of trailing slashes as mentioned in
  ///   :ref:`RouteAction's prefix_rewrite <envoy_api_field_config.route.v4alpha.RouteAction.prefix_rewrite>`.
  public var prefixRewrite: String {
    get {
      if case .prefixRewrite(let v)? = pathRewriteSpecifier {return v}
      return String()
    }
    set {pathRewriteSpecifier = .prefixRewrite(newValue)}
  }

  /// The HTTP status code to use in the redirect response. The default response
  /// code is MOVED_PERMANENTLY (301).
  public var responseCode: Envoy_Config_Route_V4alpha_RedirectAction.RedirectResponseCode = .movedPermanently

  /// Indicates that during redirection, the query portion of the URL will
  /// be removed. Default value is false.
  public var stripQuery: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// When the scheme redirection take place, the following rules apply:
  ///  1. If the source URI scheme is `http` and the port is explicitly
  ///     set to `:80`, the port will be removed after the redirection
  ///  2. If the source URI scheme is `https` and the port is explicitly
  ///     set to `:443`, the port will be removed after the redirection
  public enum OneOf_SchemeRewriteSpecifier: Equatable {
    /// The scheme portion of the URL will be swapped with "https".
    case httpsRedirect(Bool)
    /// The scheme portion of the URL will be swapped with this value.
    case schemeRedirect(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_RedirectAction.OneOf_SchemeRewriteSpecifier, rhs: Envoy_Config_Route_V4alpha_RedirectAction.OneOf_SchemeRewriteSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.httpsRedirect, .httpsRedirect): return {
        guard case .httpsRedirect(let l) = lhs, case .httpsRedirect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.schemeRedirect, .schemeRedirect): return {
        guard case .schemeRedirect(let l) = lhs, case .schemeRedirect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_PathRewriteSpecifier: Equatable {
    /// The path portion of the URL will be swapped with this value.
    /// Please note that query string in path_redirect will override the
    /// request's query string and will not be stripped.
    ///
    /// For example, let's say we have the following routes:
    ///
    /// - match: { path: "/old-path-1" }
    ///   redirect: { path_redirect: "/new-path-1" }
    /// - match: { path: "/old-path-2" }
    ///   redirect: { path_redirect: "/new-path-2", strip-query: "true" }
    /// - match: { path: "/old-path-3" }
    ///   redirect: { path_redirect: "/new-path-3?foo=1", strip_query: "true" }
    ///
    /// 1. if request uri is "/old-path-1?bar=1", users will be redirected to "/new-path-1?bar=1"
    /// 2. if request uri is "/old-path-2?bar=1", users will be redirected to "/new-path-2"
    /// 3. if request uri is "/old-path-3?bar=1", users will be redirected to "/new-path-3?foo=1"
    case pathRedirect(String)
    /// Indicates that during redirection, the matched prefix (or path)
    /// should be swapped with this value. This option allows redirect URLs be dynamically created
    /// based on the request.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the use of trailing slashes as mentioned in
    ///   :ref:`RouteAction's prefix_rewrite <envoy_api_field_config.route.v4alpha.RouteAction.prefix_rewrite>`.
    case prefixRewrite(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_RedirectAction.OneOf_PathRewriteSpecifier, rhs: Envoy_Config_Route_V4alpha_RedirectAction.OneOf_PathRewriteSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pathRedirect, .pathRedirect): return {
        guard case .pathRedirect(let l) = lhs, case .pathRedirect(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prefixRewrite, .prefixRewrite): return {
        guard case .prefixRewrite(let l) = lhs, case .prefixRewrite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum RedirectResponseCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Moved Permanently HTTP Status Code - 301.
    case movedPermanently // = 0

    /// Found HTTP Status Code - 302.
    case found // = 1

    /// See Other HTTP Status Code - 303.
    case seeOther // = 2

    /// Temporary Redirect HTTP Status Code - 307.
    case temporaryRedirect // = 3

    /// Permanent Redirect HTTP Status Code - 308.
    case permanentRedirect // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .movedPermanently
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .movedPermanently
      case 1: self = .found
      case 2: self = .seeOther
      case 3: self = .temporaryRedirect
      case 4: self = .permanentRedirect
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .movedPermanently: return 0
      case .found: return 1
      case .seeOther: return 2
      case .temporaryRedirect: return 3
      case .permanentRedirect: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Config_Route_V4alpha_RedirectAction.RedirectResponseCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V4alpha_RedirectAction.RedirectResponseCode] = [
    .movedPermanently,
    .found,
    .seeOther,
    .temporaryRedirect,
    .permanentRedirect,
  ]
}

#endif  // swift(>=4.2)

public struct Envoy_Config_Route_V4alpha_DirectResponseAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the HTTP response status to be returned.
  public var status: UInt32 = 0

  /// Specifies the content of the response body. If this setting is omitted,
  /// no body is included in the generated response.
  ///
  /// .. note::
  ///
  ///   Headers can be specified using *response_headers_to_add* in the enclosing
  ///   :ref:`envoy_api_msg_config.route.v4alpha.Route`, :ref:`envoy_api_msg_config.route.v4alpha.RouteConfiguration` or
  ///   :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost`.
  public var body: Envoy_Config_Core_V4alpha_DataSource {
    get {return _body ?? Envoy_Config_Core_V4alpha_DataSource()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Envoy_Config_Core_V4alpha_DataSource? = nil
}

public struct Envoy_Config_Route_V4alpha_Decorator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation name associated with the request matched to this route. If tracing is
  /// enabled, this information will be used as the span name reported for this request.
  ///
  /// .. note::
  ///
  ///   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
  ///   by the :ref:`x-envoy-decorator-operation
  ///   <config_http_filters_router_x-envoy-decorator-operation>` header.
  public var operation: String = String()

  /// Whether the decorated details should be propagated to the other party. The default is true.
  public var propagate: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _propagate ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_propagate = newValue}
  }
  /// Returns true if `propagate` has been explicitly set.
  public var hasPropagate: Bool {return self._propagate != nil}
  /// Clears the value of `propagate`. Subsequent reads from it will return its default value.
  public mutating func clearPropagate() {self._propagate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _propagate: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Envoy_Config_Route_V4alpha_Tracing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target percentage of requests managed by this HTTP connection manager that will be force
  /// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
  /// header is set. This field is a direct analog for the runtime variable
  /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
  /// <config_http_conn_man_runtime>`.
  /// Default: 100%
  public var clientSampling: Envoy_Type_V3_FractionalPercent {
    get {return _clientSampling ?? Envoy_Type_V3_FractionalPercent()}
    set {_clientSampling = newValue}
  }
  /// Returns true if `clientSampling` has been explicitly set.
  public var hasClientSampling: Bool {return self._clientSampling != nil}
  /// Clears the value of `clientSampling`. Subsequent reads from it will return its default value.
  public mutating func clearClientSampling() {self._clientSampling = nil}

  /// Target percentage of requests managed by this HTTP connection manager that will be randomly
  /// selected for trace generation, if not requested by the client or not forced. This field is
  /// a direct analog for the runtime variable 'tracing.random_sampling' in the
  /// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
  /// Default: 100%
  public var randomSampling: Envoy_Type_V3_FractionalPercent {
    get {return _randomSampling ?? Envoy_Type_V3_FractionalPercent()}
    set {_randomSampling = newValue}
  }
  /// Returns true if `randomSampling` has been explicitly set.
  public var hasRandomSampling: Bool {return self._randomSampling != nil}
  /// Clears the value of `randomSampling`. Subsequent reads from it will return its default value.
  public mutating func clearRandomSampling() {self._randomSampling = nil}

  /// Target percentage of requests managed by this HTTP connection manager that will be traced
  /// after all other sampling checks have been applied (client-directed, force tracing, random
  /// sampling). This field functions as an upper limit on the total configured sampling rate. For
  /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
  /// of client requests with the appropriate headers to be force traced. This field is a direct
  /// analog for the runtime variable 'tracing.global_enabled' in the
  /// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
  /// Default: 100%
  public var overallSampling: Envoy_Type_V3_FractionalPercent {
    get {return _overallSampling ?? Envoy_Type_V3_FractionalPercent()}
    set {_overallSampling = newValue}
  }
  /// Returns true if `overallSampling` has been explicitly set.
  public var hasOverallSampling: Bool {return self._overallSampling != nil}
  /// Clears the value of `overallSampling`. Subsequent reads from it will return its default value.
  public mutating func clearOverallSampling() {self._overallSampling = nil}

  /// A list of custom tags with unique tag name to create tags for the active span.
  /// It will take effect after merging with the :ref:`corresponding configuration
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.Tracing.custom_tags>`
  /// configured in the HTTP connection manager. If two tags with the same name are configured
  /// each in the HTTP connection manager and the route level, the one configured here takes
  /// priority.
  public var customTags: [Envoy_Type_Tracing_V3_CustomTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientSampling: Envoy_Type_V3_FractionalPercent? = nil
  fileprivate var _randomSampling: Envoy_Type_V3_FractionalPercent? = nil
  fileprivate var _overallSampling: Envoy_Type_V3_FractionalPercent? = nil
}

/// A virtual cluster is a way of specifying a regex matching rule against
/// certain important endpoints such that statistics are generated explicitly for
/// the matched requests. The reason this is useful is that when doing
/// prefix/path matching Envoy does not always know what the application
/// considers to be an endpoint. Thus, itâ€™s impossible for Envoy to generically
/// emit per endpoint statistics. However, often systems have highly critical
/// endpoints that they wish to get â€œperfectâ€ statistics on. Virtual cluster
/// statistics are perfect in the sense that they are emitted on the downstream
/// side such that they include network level failures.
///
/// Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
///
/// .. note::
///
///    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
///    every application endpoint. This is both not easily maintainable and as well the matching and
///    statistics output are not free.
public struct Envoy_Config_Route_V4alpha_VirtualCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies a list of header matchers to use for matching requests. Each specified header must
  /// match. The pseudo-headers `:path` and `:method` can be used to match the request path and
  /// method, respectively.
  public var headers: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

  /// Specifies the name of the virtual cluster. The virtual cluster name as well
  /// as the virtual host name are used when emitting statistics. The statistics are emitted by the
  /// router filter and are documented :ref:`here <config_http_filters_router_stats>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
public struct Envoy_Config_Route_V4alpha_RateLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Refers to the stage set in the filter. The rate limit configuration only
  /// applies to filters with the same stage number. The default stage number is
  /// 0.
  ///
  /// .. note::
  ///
  ///   The filter supports a range of 0 - 10 inclusively for stage numbers.
  public var stage: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _stage ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_stage = newValue}
  }
  /// Returns true if `stage` has been explicitly set.
  public var hasStage: Bool {return self._stage != nil}
  /// Clears the value of `stage`. Subsequent reads from it will return its default value.
  public mutating func clearStage() {self._stage = nil}

  /// The key to be set in runtime to disable this rate limit configuration.
  public var disableKey: String = String()

  /// A list of actions that are to be applied for this rate limit configuration.
  /// Order matters as the actions are processed sequentially and the descriptor
  /// is composed by appending descriptor entries in that sequence. If an action
  /// cannot append a descriptor entry, no descriptor is generated for the
  /// configuration. See :ref:`composing actions
  /// <config_http_filters_rate_limit_composing_actions>` for additional documentation.
  public var actions: [Envoy_Config_Route_V4alpha_RateLimit.Action] = []

  /// An optional limit override to be appended to the descriptor produced by this
  /// rate limit configuration. If the override value is invalid or cannot be resolved
  /// from metadata, no override is provided. See :ref:`rate limit override
  /// <config_http_filters_rate_limit_rate_limit_override>` for more information.
  public var limit: Envoy_Config_Route_V4alpha_RateLimit.Override {
    get {return _limit ?? Envoy_Config_Route_V4alpha_RateLimit.Override()}
    set {_limit = newValue}
  }
  /// Returns true if `limit` has been explicitly set.
  public var hasLimit: Bool {return self._limit != nil}
  /// Clears the value of `limit`. Subsequent reads from it will return its default value.
  public mutating func clearLimit() {self._limit = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// [#next-free-field: 9]
  public struct Action {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionSpecifier: Envoy_Config_Route_V4alpha_RateLimit.Action.OneOf_ActionSpecifier? = nil

    /// Rate limit on source cluster.
    public var sourceCluster: Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster {
      get {
        if case .sourceCluster(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster()
      }
      set {actionSpecifier = .sourceCluster(newValue)}
    }

    /// Rate limit on destination cluster.
    public var destinationCluster: Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster {
      get {
        if case .destinationCluster(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster()
      }
      set {actionSpecifier = .destinationCluster(newValue)}
    }

    /// Rate limit on request headers.
    public var requestHeaders: Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders {
      get {
        if case .requestHeaders(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders()
      }
      set {actionSpecifier = .requestHeaders(newValue)}
    }

    /// Rate limit on remote address.
    public var remoteAddress: Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress {
      get {
        if case .remoteAddress(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress()
      }
      set {actionSpecifier = .remoteAddress(newValue)}
    }

    /// Rate limit on a generic key.
    public var genericKey: Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey {
      get {
        if case .genericKey(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey()
      }
      set {actionSpecifier = .genericKey(newValue)}
    }

    /// Rate limit on the existence of request headers.
    public var headerValueMatch: Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch {
      get {
        if case .headerValueMatch(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch()
      }
      set {actionSpecifier = .headerValueMatch(newValue)}
    }

    /// Rate limit on metadata.
    public var metadata: Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData {
      get {
        if case .metadata(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData()
      }
      set {actionSpecifier = .metadata(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ActionSpecifier: Equatable {
      /// Rate limit on source cluster.
      case sourceCluster(Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster)
      /// Rate limit on destination cluster.
      case destinationCluster(Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster)
      /// Rate limit on request headers.
      case requestHeaders(Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders)
      /// Rate limit on remote address.
      case remoteAddress(Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress)
      /// Rate limit on a generic key.
      case genericKey(Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey)
      /// Rate limit on the existence of request headers.
      case headerValueMatch(Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch)
      /// Rate limit on metadata.
      case metadata(Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.OneOf_ActionSpecifier, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.OneOf_ActionSpecifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.sourceCluster, .sourceCluster): return {
          guard case .sourceCluster(let l) = lhs, case .sourceCluster(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.destinationCluster, .destinationCluster): return {
          guard case .destinationCluster(let l) = lhs, case .destinationCluster(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.requestHeaders, .requestHeaders): return {
          guard case .requestHeaders(let l) = lhs, case .requestHeaders(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.remoteAddress, .remoteAddress): return {
          guard case .remoteAddress(let l) = lhs, case .remoteAddress(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.genericKey, .genericKey): return {
          guard case .genericKey(let l) = lhs, case .genericKey(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.headerValueMatch, .headerValueMatch): return {
          guard case .headerValueMatch(let l) = lhs, case .headerValueMatch(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.metadata, .metadata): return {
          guard case .metadata(let l) = lhs, case .metadata(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("source_cluster", "<local service cluster>")
    ///
    /// <local service cluster> is derived from the :option:`--service-cluster` option.
    public struct SourceCluster {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("destination_cluster", "<routed target cluster>")
    ///
    /// Once a request matches against a route table rule, a routed cluster is determined by one of
    /// the following :ref:`route table configuration <envoy_api_msg_config.route.v4alpha.RouteConfiguration>`
    /// settings:
    ///
    /// * :ref:`cluster <envoy_api_field_config.route.v4alpha.RouteAction.cluster>` indicates the upstream cluster
    ///   to route to.
    /// * :ref:`weighted_clusters <envoy_api_field_config.route.v4alpha.RouteAction.weighted_clusters>`
    ///   chooses a cluster randomly from a set of clusters with attributed weight.
    /// * :ref:`cluster_header <envoy_api_field_config.route.v4alpha.RouteAction.cluster_header>` indicates which
    ///   header in the request contains the target cluster.
    public struct DestinationCluster {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended when a header contains a key that matches the
    /// *header_name*:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("<descriptor_key>", "<header_value_queried_from_header>")
    public struct RequestHeaders {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The header name to be queried from the request headers. The headerâ€™s
      /// value is used to populate the value of the descriptor entry for the
      /// descriptor_key.
      public var headerName: String = String()

      /// The key to use in the descriptor entry.
      public var descriptorKey: String = String()

      /// If set to true, Envoy skips the descriptor while calling rate limiting service
      /// when header is not present in the request. By default it skips calling the
      /// rate limiting service if this header is not present in the request.
      public var skipIfAbsent: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor and is populated using the
    /// trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("remote_address", "<trusted address from x-forwarded-for>")
    public struct RemoteAddress {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("generic_key", "<descriptor_value>")
    public struct GenericKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The value to use in the descriptor entry.
      public var descriptorValue: String = String()

      /// An optional key to use in the descriptor entry. If not set it defaults
      /// to 'generic_key' as the descriptor key.
      public var descriptorKey: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("header_match", "<descriptor_value>")
    public struct HeaderValueMatch {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The value to use in the descriptor entry.
      public var descriptorValue: String = String()

      /// If set to true, the action will append a descriptor entry when the
      /// request matches the headers. If set to false, the action will append a
      /// descriptor entry when the request does not match the headers. The
      /// default value is true.
      public var expectMatch: SwiftProtobuf.Google_Protobuf_BoolValue {
        get {return _expectMatch ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
        set {_expectMatch = newValue}
      }
      /// Returns true if `expectMatch` has been explicitly set.
      public var hasExpectMatch: Bool {return self._expectMatch != nil}
      /// Clears the value of `expectMatch`. Subsequent reads from it will return its default value.
      public mutating func clearExpectMatch() {self._expectMatch = nil}

      /// Specifies a set of headers that the rate limit action should match
      /// on. The action will check the requestâ€™s headers against all the
      /// specified headers in the config. A match will happen if all the
      /// headers in the config are present in the request with the same values
      /// (or based on presence if the value field is not in the config).
      public var headers: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _expectMatch: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    }

    /// The following descriptor entry is appended when the
    /// :ref:`dynamic metadata <well_known_dynamic_metadata>` contains a key value:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("<descriptor_key>", "<value_queried_from_dynamic_metadata>")
    ///
    /// .. attention::
    ///   This action has been deprecated in favor of the :ref:`metadata <envoy_api_msg_config.route.v4alpha.RateLimit.Action.MetaData>` action
    public struct DynamicMetaData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The key to use in the descriptor entry.
      public var descriptorKey: String = String()

      /// Metadata struct that defines the key and path to retrieve the string value. A match will
      /// only happen if the value in the dynamic metadata is of type string.
      public var metadataKey: Envoy_Type_Metadata_V3_MetadataKey {
        get {return _metadataKey ?? Envoy_Type_Metadata_V3_MetadataKey()}
        set {_metadataKey = newValue}
      }
      /// Returns true if `metadataKey` has been explicitly set.
      public var hasMetadataKey: Bool {return self._metadataKey != nil}
      /// Clears the value of `metadataKey`. Subsequent reads from it will return its default value.
      public mutating func clearMetadataKey() {self._metadataKey = nil}

      /// An optional value to use if *metadata_key* is empty. If not set and
      /// no value is present under the metadata_key then no descriptor is generated.
      public var defaultValue: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _metadataKey: Envoy_Type_Metadata_V3_MetadataKey? = nil
    }

    /// The following descriptor entry is appended when the metadata contains a key value:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("<descriptor_key>", "<value_queried_from_metadata>")
    public struct MetaData {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The key to use in the descriptor entry.
      public var descriptorKey: String = String()

      /// Metadata struct that defines the key and path to retrieve the string value. A match will
      /// only happen if the value in the metadata is of type string.
      public var metadataKey: Envoy_Type_Metadata_V3_MetadataKey {
        get {return _metadataKey ?? Envoy_Type_Metadata_V3_MetadataKey()}
        set {_metadataKey = newValue}
      }
      /// Returns true if `metadataKey` has been explicitly set.
      public var hasMetadataKey: Bool {return self._metadataKey != nil}
      /// Clears the value of `metadataKey`. Subsequent reads from it will return its default value.
      public mutating func clearMetadataKey() {self._metadataKey = nil}

      /// An optional value to use if *metadata_key* is empty. If not set and
      /// no value is present under the metadata_key then no descriptor is generated.
      public var defaultValue: String = String()

      /// Source of metadata
      public var source: Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData.Source = .dynamic

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum Source: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Query :ref:`dynamic metadata <well_known_dynamic_metadata>`
        case dynamic // = 0

        /// Query :ref:`route entry metadata <envoy_api_field_config.route.v4alpha.Route.metadata>`
        case routeEntry // = 1
        case UNRECOGNIZED(Int)

        public init() {
          self = .dynamic
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .dynamic
          case 1: self = .routeEntry
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .dynamic: return 0
          case .routeEntry: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}

      fileprivate var _metadataKey: Envoy_Type_Metadata_V3_MetadataKey? = nil
    }

    public init() {}
  }

  public struct Override {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var overrideSpecifier: Envoy_Config_Route_V4alpha_RateLimit.Override.OneOf_OverrideSpecifier? = nil

    /// Limit override from dynamic metadata.
    public var dynamicMetadata: Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata {
      get {
        if case .dynamicMetadata(let v)? = overrideSpecifier {return v}
        return Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata()
      }
      set {overrideSpecifier = .dynamicMetadata(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_OverrideSpecifier: Equatable {
      /// Limit override from dynamic metadata.
      case dynamicMetadata(Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Override.OneOf_OverrideSpecifier, rhs: Envoy_Config_Route_V4alpha_RateLimit.Override.OneOf_OverrideSpecifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.dynamicMetadata, .dynamicMetadata): return {
          guard case .dynamicMetadata(let l) = lhs, case .dynamicMetadata(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    /// Fetches the override from the dynamic metadata.
    public struct DynamicMetadata {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Metadata struct that defines the key and path to retrieve the struct value.
      /// The value must be a struct containing an integer "requests_per_unit" property
      /// and a "unit" property with a value parseable to :ref:`RateLimitUnit
      /// enum <envoy_api_enum_type.v3.RateLimitUnit>`
      public var metadataKey: Envoy_Type_Metadata_V3_MetadataKey {
        get {return _metadataKey ?? Envoy_Type_Metadata_V3_MetadataKey()}
        set {_metadataKey = newValue}
      }
      /// Returns true if `metadataKey` has been explicitly set.
      public var hasMetadataKey: Bool {return self._metadataKey != nil}
      /// Clears the value of `metadataKey`. Subsequent reads from it will return its default value.
      public mutating func clearMetadataKey() {self._metadataKey = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _metadataKey: Envoy_Type_Metadata_V3_MetadataKey? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _stage: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _limit: Envoy_Config_Route_V4alpha_RateLimit.Override? = nil
}

#if swift(>=4.2)

extension Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData.Source: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData.Source] = [
    .dynamic,
    .routeEntry,
  ]
}

#endif  // swift(>=4.2)

/// .. attention::
///
///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
///   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
///
/// .. attention::
///
///   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
///   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
///
///   .. code-block:: json
///
///     {
///       "name": ":method",
///       "exact_match": "POST"
///     }
///
/// .. attention::
///   In the absence of any header match specifier, match will default to :ref:`present_match
///   <envoy_api_field_config.route.v4alpha.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
///   <envoy_api_field_config.route.v4alpha.HeaderMatcher.name>` header will match, regardless of the header's
///   value.
///
///  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
/// [#next-free-field: 13]
public struct Envoy_Config_Route_V4alpha_HeaderMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the name of the header in the request.
  public var name: String = String()

  /// Specifies how the header match will be performed to route the request.
  public var headerMatchSpecifier: Envoy_Config_Route_V4alpha_HeaderMatcher.OneOf_HeaderMatchSpecifier? = nil

  /// If specified, header match will be performed based on the value of the header.
  public var exactMatch: String {
    get {
      if case .exactMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .exactMatch(newValue)}
  }

  /// If specified, this regex string is a regular expression rule which implies the entire request
  /// header value must match the regex. The rule will not match if only a subsequence of the
  /// request header value matches the regex.
  public var safeRegexMatch: Envoy_Type_Matcher_V4alpha_RegexMatcher {
    get {
      if case .safeRegexMatch(let v)? = headerMatchSpecifier {return v}
      return Envoy_Type_Matcher_V4alpha_RegexMatcher()
    }
    set {headerMatchSpecifier = .safeRegexMatch(newValue)}
  }

  /// If specified, header match will be performed based on range.
  /// The rule will match if the request header value is within this range.
  /// The entire request header value must represent an integer in base 10 notation: consisting of
  /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
  /// the header value does not represent an integer. Match will fail for empty values, floating
  /// point numbers or if only a subsequence of the header value is an integer.
  ///
  /// Examples:
  ///
  /// * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
  ///   "-1somestring"
  public var rangeMatch: Envoy_Type_V3_Int64Range {
    get {
      if case .rangeMatch(let v)? = headerMatchSpecifier {return v}
      return Envoy_Type_V3_Int64Range()
    }
    set {headerMatchSpecifier = .rangeMatch(newValue)}
  }

  /// If specified, header match will be performed based on whether the header is in the
  /// request.
  public var presentMatch: Bool {
    get {
      if case .presentMatch(let v)? = headerMatchSpecifier {return v}
      return false
    }
    set {headerMatchSpecifier = .presentMatch(newValue)}
  }

  /// If specified, header match will be performed based on the prefix of the header value.
  /// Note: empty prefix is not allowed, please use present_match instead.
  ///
  /// Examples:
  ///
  /// * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
  public var prefixMatch: String {
    get {
      if case .prefixMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .prefixMatch(newValue)}
  }

  /// If specified, header match will be performed based on the suffix of the header value.
  /// Note: empty suffix is not allowed, please use present_match instead.
  ///
  /// Examples:
  ///
  /// * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
  public var suffixMatch: String {
    get {
      if case .suffixMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .suffixMatch(newValue)}
  }

  /// If specified, header match will be performed based on whether the header value contains
  /// the given value or not.
  /// Note: empty contains match is not allowed, please use present_match instead.
  ///
  /// Examples:
  ///
  /// * The value *abcd* matches the value *xyzabcdpqr*, but not for *xyzbcdpqr*.
  public var containsMatch: String {
    get {
      if case .containsMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .containsMatch(newValue)}
  }

  /// If specified, the match result will be inverted before checking. Defaults to false.
  ///
  /// Examples:
  ///
  /// * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
  /// * The range [-10,0) will match the value -1, so it will not match when inverted.
  public var invertMatch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies how the header match will be performed to route the request.
  public enum OneOf_HeaderMatchSpecifier: Equatable {
    /// If specified, header match will be performed based on the value of the header.
    case exactMatch(String)
    /// If specified, this regex string is a regular expression rule which implies the entire request
    /// header value must match the regex. The rule will not match if only a subsequence of the
    /// request header value matches the regex.
    case safeRegexMatch(Envoy_Type_Matcher_V4alpha_RegexMatcher)
    /// If specified, header match will be performed based on range.
    /// The rule will match if the request header value is within this range.
    /// The entire request header value must represent an integer in base 10 notation: consisting of
    /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
    /// the header value does not represent an integer. Match will fail for empty values, floating
    /// point numbers or if only a subsequence of the header value is an integer.
    ///
    /// Examples:
    ///
    /// * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
    ///   "-1somestring"
    case rangeMatch(Envoy_Type_V3_Int64Range)
    /// If specified, header match will be performed based on whether the header is in the
    /// request.
    case presentMatch(Bool)
    /// If specified, header match will be performed based on the prefix of the header value.
    /// Note: empty prefix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
    case prefixMatch(String)
    /// If specified, header match will be performed based on the suffix of the header value.
    /// Note: empty suffix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
    case suffixMatch(String)
    /// If specified, header match will be performed based on whether the header value contains
    /// the given value or not.
    /// Note: empty contains match is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The value *abcd* matches the value *xyzabcdpqr*, but not for *xyzbcdpqr*.
    case containsMatch(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_HeaderMatcher.OneOf_HeaderMatchSpecifier, rhs: Envoy_Config_Route_V4alpha_HeaderMatcher.OneOf_HeaderMatchSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exactMatch, .exactMatch): return {
        guard case .exactMatch(let l) = lhs, case .exactMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.safeRegexMatch, .safeRegexMatch): return {
        guard case .safeRegexMatch(let l) = lhs, case .safeRegexMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rangeMatch, .rangeMatch): return {
        guard case .rangeMatch(let l) = lhs, case .rangeMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.presentMatch, .presentMatch): return {
        guard case .presentMatch(let l) = lhs, case .presentMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prefixMatch, .prefixMatch): return {
        guard case .prefixMatch(let l) = lhs, case .prefixMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.suffixMatch, .suffixMatch): return {
        guard case .suffixMatch(let l) = lhs, case .suffixMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.containsMatch, .containsMatch): return {
        guard case .containsMatch(let l) = lhs, case .containsMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Query parameter matching treats the query string of a request's :path header
/// as an ampersand-separated list of keys and/or key=value elements.
/// [#next-free-field: 7]
public struct Envoy_Config_Route_V4alpha_QueryParameterMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the name of a key that must be present in the requested
  /// *path*'s query string.
  public var name: String = String()

  public var queryParameterMatchSpecifier: Envoy_Config_Route_V4alpha_QueryParameterMatcher.OneOf_QueryParameterMatchSpecifier? = nil

  /// Specifies whether a query parameter value should match against a string.
  public var stringMatch: Envoy_Type_Matcher_V4alpha_StringMatcher {
    get {
      if case .stringMatch(let v)? = queryParameterMatchSpecifier {return v}
      return Envoy_Type_Matcher_V4alpha_StringMatcher()
    }
    set {queryParameterMatchSpecifier = .stringMatch(newValue)}
  }

  /// Specifies whether a query parameter should be present.
  public var presentMatch: Bool {
    get {
      if case .presentMatch(let v)? = queryParameterMatchSpecifier {return v}
      return false
    }
    set {queryParameterMatchSpecifier = .presentMatch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_QueryParameterMatchSpecifier: Equatable {
    /// Specifies whether a query parameter value should match against a string.
    case stringMatch(Envoy_Type_Matcher_V4alpha_StringMatcher)
    /// Specifies whether a query parameter should be present.
    case presentMatch(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V4alpha_QueryParameterMatcher.OneOf_QueryParameterMatchSpecifier, rhs: Envoy_Config_Route_V4alpha_QueryParameterMatcher.OneOf_QueryParameterMatchSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.stringMatch, .stringMatch): return {
        guard case .stringMatch(let l) = lhs, case .stringMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.presentMatch, .presentMatch): return {
        guard case .presentMatch(let l) = lhs, case .presentMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`.
public struct Envoy_Config_Route_V4alpha_InternalRedirectPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An internal redirect is not handled, unless the number of previous internal redirects that a
  /// downstream request has encountered is lower than this value.
  /// In the case where a downstream request is bounced among multiple routes by internal redirect,
  /// the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
  /// <envoy_api_field_config.route.v4alpha.RouteAction.internal_redirect_policy>`
  /// will pass the redirect back to downstream.
  ///
  /// If not specified, at most one redirect will be followed.
  public var maxInternalRedirects: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxInternalRedirects ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxInternalRedirects = newValue}
  }
  /// Returns true if `maxInternalRedirects` has been explicitly set.
  public var hasMaxInternalRedirects: Bool {return self._maxInternalRedirects != nil}
  /// Clears the value of `maxInternalRedirects`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInternalRedirects() {self._maxInternalRedirects = nil}

  /// Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
  /// only 302 will be treated as internal redirect.
  /// Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
  public var redirectResponseCodes: [UInt32] = []

  /// Specifies a list of predicates that are queried when an upstream response is deemed
  /// to trigger an internal redirect by all other criteria. Any predicate in the list can reject
  /// the redirect, causing the response to be proxied to downstream.
  public var predicates: [Envoy_Config_Core_V4alpha_TypedExtensionConfig] = []

  /// Allow internal redirect to follow a target URI with a different scheme than the value of
  /// x-forwarded-proto. The default is false.
  public var allowCrossSchemeRedirect: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxInternalRedirects: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.route.v4alpha"

extension Envoy_Config_Route_V4alpha_VirtualHost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VirtualHost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "domains"),
    3: .same(proto: "routes"),
    4: .standard(proto: "require_tls"),
    5: .standard(proto: "virtual_clusters"),
    6: .standard(proto: "rate_limits"),
    7: .standard(proto: "request_headers_to_add"),
    13: .standard(proto: "request_headers_to_remove"),
    10: .standard(proto: "response_headers_to_add"),
    11: .standard(proto: "response_headers_to_remove"),
    8: .same(proto: "cors"),
    15: .standard(proto: "typed_per_filter_config"),
    14: .standard(proto: "include_request_attempt_count"),
    19: .standard(proto: "include_attempt_count_in_response"),
    16: .standard(proto: "retry_policy"),
    20: .standard(proto: "retry_policy_typed_config"),
    17: .standard(proto: "hedge_policy"),
    18: .standard(proto: "per_request_buffer_limit_bytes"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _domains: [String] = []
    var _routes: [Envoy_Config_Route_V4alpha_Route] = []
    var _requireTls: Envoy_Config_Route_V4alpha_VirtualHost.TlsRequirementType = .none
    var _virtualClusters: [Envoy_Config_Route_V4alpha_VirtualCluster] = []
    var _rateLimits: [Envoy_Config_Route_V4alpha_RateLimit] = []
    var _requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []
    var _requestHeadersToRemove: [String] = []
    var _responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []
    var _responseHeadersToRemove: [String] = []
    var _cors: Envoy_Config_Route_V4alpha_CorsPolicy? = nil
    var _typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]
    var _includeRequestAttemptCount: Bool = false
    var _includeAttemptCountInResponse: Bool = false
    var _retryPolicy: Envoy_Config_Route_V4alpha_RetryPolicy? = nil
    var _retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _hedgePolicy: Envoy_Config_Route_V4alpha_HedgePolicy? = nil
    var _perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _domains = source._domains
      _routes = source._routes
      _requireTls = source._requireTls
      _virtualClusters = source._virtualClusters
      _rateLimits = source._rateLimits
      _requestHeadersToAdd = source._requestHeadersToAdd
      _requestHeadersToRemove = source._requestHeadersToRemove
      _responseHeadersToAdd = source._responseHeadersToAdd
      _responseHeadersToRemove = source._responseHeadersToRemove
      _cors = source._cors
      _typedPerFilterConfig = source._typedPerFilterConfig
      _includeRequestAttemptCount = source._includeRequestAttemptCount
      _includeAttemptCountInResponse = source._includeAttemptCountInResponse
      _retryPolicy = source._retryPolicy
      _retryPolicyTypedConfig = source._retryPolicyTypedConfig
      _hedgePolicy = source._hedgePolicy
      _perRequestBufferLimitBytes = source._perRequestBufferLimitBytes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._domains) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._routes) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._requireTls) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._virtualClusters) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._rateLimits) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestHeadersToAdd) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._cors) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._responseHeadersToAdd) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._responseHeadersToRemove) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._requestHeadersToRemove) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._includeRequestAttemptCount) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &_storage._typedPerFilterConfig) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._hedgePolicy) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._perRequestBufferLimitBytes) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._includeAttemptCountInResponse) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicyTypedConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._domains.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._domains, fieldNumber: 2)
      }
      if !_storage._routes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._routes, fieldNumber: 3)
      }
      if _storage._requireTls != .none {
        try visitor.visitSingularEnumField(value: _storage._requireTls, fieldNumber: 4)
      }
      if !_storage._virtualClusters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._virtualClusters, fieldNumber: 5)
      }
      if !_storage._rateLimits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rateLimits, fieldNumber: 6)
      }
      if !_storage._requestHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestHeadersToAdd, fieldNumber: 7)
      }
      if let v = _storage._cors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._responseHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._responseHeadersToAdd, fieldNumber: 10)
      }
      if !_storage._responseHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._responseHeadersToRemove, fieldNumber: 11)
      }
      if !_storage._requestHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requestHeadersToRemove, fieldNumber: 13)
      }
      if _storage._includeRequestAttemptCount != false {
        try visitor.visitSingularBoolField(value: _storage._includeRequestAttemptCount, fieldNumber: 14)
      }
      if !_storage._typedPerFilterConfig.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: _storage._typedPerFilterConfig, fieldNumber: 15)
      }
      if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._hedgePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._perRequestBufferLimitBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if _storage._includeAttemptCountInResponse != false {
        try visitor.visitSingularBoolField(value: _storage._includeAttemptCountInResponse, fieldNumber: 19)
      }
      if let v = _storage._retryPolicyTypedConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_VirtualHost, rhs: Envoy_Config_Route_V4alpha_VirtualHost) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._domains != rhs_storage._domains {return false}
        if _storage._routes != rhs_storage._routes {return false}
        if _storage._requireTls != rhs_storage._requireTls {return false}
        if _storage._virtualClusters != rhs_storage._virtualClusters {return false}
        if _storage._rateLimits != rhs_storage._rateLimits {return false}
        if _storage._requestHeadersToAdd != rhs_storage._requestHeadersToAdd {return false}
        if _storage._requestHeadersToRemove != rhs_storage._requestHeadersToRemove {return false}
        if _storage._responseHeadersToAdd != rhs_storage._responseHeadersToAdd {return false}
        if _storage._responseHeadersToRemove != rhs_storage._responseHeadersToRemove {return false}
        if _storage._cors != rhs_storage._cors {return false}
        if _storage._typedPerFilterConfig != rhs_storage._typedPerFilterConfig {return false}
        if _storage._includeRequestAttemptCount != rhs_storage._includeRequestAttemptCount {return false}
        if _storage._includeAttemptCountInResponse != rhs_storage._includeAttemptCountInResponse {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._retryPolicyTypedConfig != rhs_storage._retryPolicyTypedConfig {return false}
        if _storage._hedgePolicy != rhs_storage._hedgePolicy {return false}
        if _storage._perRequestBufferLimitBytes != rhs_storage._perRequestBufferLimitBytes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_VirtualHost.TlsRequirementType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "EXTERNAL_ONLY"),
    2: .same(proto: "ALL"),
  ]
}

extension Envoy_Config_Route_V4alpha_FilterAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_FilterAction, rhs: Envoy_Config_Route_V4alpha_FilterAction) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .same(proto: "name"),
    1: .same(proto: "match"),
    2: .same(proto: "route"),
    3: .same(proto: "redirect"),
    7: .standard(proto: "direct_response"),
    17: .standard(proto: "filter_action"),
    4: .same(proto: "metadata"),
    5: .same(proto: "decorator"),
    13: .standard(proto: "typed_per_filter_config"),
    9: .standard(proto: "request_headers_to_add"),
    12: .standard(proto: "request_headers_to_remove"),
    10: .standard(proto: "response_headers_to_add"),
    11: .standard(proto: "response_headers_to_remove"),
    15: .same(proto: "tracing"),
    16: .standard(proto: "per_request_buffer_limit_bytes"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _match: Envoy_Config_Route_V4alpha_RouteMatch? = nil
    var _action: Envoy_Config_Route_V4alpha_Route.OneOf_Action?
    var _metadata: Envoy_Config_Core_V4alpha_Metadata? = nil
    var _decorator: Envoy_Config_Route_V4alpha_Decorator? = nil
    var _typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]
    var _requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []
    var _requestHeadersToRemove: [String] = []
    var _responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []
    var _responseHeadersToRemove: [String] = []
    var _tracing: Envoy_Config_Route_V4alpha_Tracing? = nil
    var _perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _match = source._match
      _action = source._action
      _metadata = source._metadata
      _decorator = source._decorator
      _typedPerFilterConfig = source._typedPerFilterConfig
      _requestHeadersToAdd = source._requestHeadersToAdd
      _requestHeadersToRemove = source._requestHeadersToRemove
      _responseHeadersToAdd = source._responseHeadersToAdd
      _responseHeadersToRemove = source._responseHeadersToRemove
      _tracing = source._tracing
      _perRequestBufferLimitBytes = source._perRequestBufferLimitBytes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._match) }()
        case 2: try {
          var v: Envoy_Config_Route_V4alpha_RouteAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .route(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .route(v)}
        }()
        case 3: try {
          var v: Envoy_Config_Route_V4alpha_RedirectAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .redirect(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .redirect(v)}
        }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._decorator) }()
        case 7: try {
          var v: Envoy_Config_Route_V4alpha_DirectResponseAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .directResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .directResponse(v)}
        }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestHeadersToAdd) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._responseHeadersToAdd) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._responseHeadersToRemove) }()
        case 12: try { try decoder.decodeRepeatedStringField(value: &_storage._requestHeadersToRemove) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &_storage._typedPerFilterConfig) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tracing) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._perRequestBufferLimitBytes) }()
        case 17: try {
          var v: Envoy_Config_Route_V4alpha_FilterAction?
          if let current = _storage._action {
            try decoder.handleConflictingOneOf()
            if case .filterAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._action = .filterAction(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._match {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._action {
      case .route?: try {
        guard case .route(let v)? = _storage._action else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .redirect?: try {
        guard case .redirect(let v)? = _storage._action else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      default: break
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._decorator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if case .directResponse(let v)? = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._requestHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestHeadersToAdd, fieldNumber: 9)
      }
      if !_storage._responseHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._responseHeadersToAdd, fieldNumber: 10)
      }
      if !_storage._responseHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._responseHeadersToRemove, fieldNumber: 11)
      }
      if !_storage._requestHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requestHeadersToRemove, fieldNumber: 12)
      }
      if !_storage._typedPerFilterConfig.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: _storage._typedPerFilterConfig, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 14)
      }
      if let v = _storage._tracing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._perRequestBufferLimitBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if case .filterAction(let v)? = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_Route, rhs: Envoy_Config_Route_V4alpha_Route) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._match != rhs_storage._match {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._decorator != rhs_storage._decorator {return false}
        if _storage._typedPerFilterConfig != rhs_storage._typedPerFilterConfig {return false}
        if _storage._requestHeadersToAdd != rhs_storage._requestHeadersToAdd {return false}
        if _storage._requestHeadersToRemove != rhs_storage._requestHeadersToRemove {return false}
        if _storage._responseHeadersToAdd != rhs_storage._responseHeadersToAdd {return false}
        if _storage._responseHeadersToRemove != rhs_storage._responseHeadersToRemove {return false}
        if _storage._tracing != rhs_storage._tracing {return false}
        if _storage._perRequestBufferLimitBytes != rhs_storage._perRequestBufferLimitBytes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_WeightedCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WeightedCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
    3: .standard(proto: "total_weight"),
    2: .standard(proto: "runtime_key_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtimeKeyPrefix) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._totalWeight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    if !self.runtimeKeyPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKeyPrefix, fieldNumber: 2)
    }
    if let v = self._totalWeight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_WeightedCluster, rhs: Envoy_Config_Route_V4alpha_WeightedCluster) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs._totalWeight != rhs._totalWeight {return false}
    if lhs.runtimeKeyPrefix != rhs.runtimeKeyPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_WeightedCluster.ClusterWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_WeightedCluster.protoMessageName + ".ClusterWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "weight"),
    3: .standard(proto: "metadata_match"),
    4: .standard(proto: "request_headers_to_add"),
    9: .standard(proto: "request_headers_to_remove"),
    5: .standard(proto: "response_headers_to_add"),
    6: .standard(proto: "response_headers_to_remove"),
    10: .standard(proto: "typed_per_filter_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._weight) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadataMatch) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.requestHeadersToAdd) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.responseHeadersToAdd) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.responseHeadersToRemove) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.requestHeadersToRemove) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &self.typedPerFilterConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._weight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.requestHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeadersToAdd, fieldNumber: 4)
    }
    if !self.responseHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeadersToAdd, fieldNumber: 5)
    }
    if !self.responseHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.responseHeadersToRemove, fieldNumber: 6)
    }
    if !self.requestHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestHeadersToRemove, fieldNumber: 9)
    }
    if !self.typedPerFilterConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: self.typedPerFilterConfig, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_WeightedCluster.ClusterWeight, rhs: Envoy_Config_Route_V4alpha_WeightedCluster.ClusterWeight) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs.requestHeadersToAdd != rhs.requestHeadersToAdd {return false}
    if lhs.requestHeadersToRemove != rhs.requestHeadersToRemove {return false}
    if lhs.responseHeadersToAdd != rhs.responseHeadersToAdd {return false}
    if lhs.responseHeadersToRemove != rhs.responseHeadersToRemove {return false}
    if lhs.typedPerFilterConfig != rhs.typedPerFilterConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "path"),
    10: .standard(proto: "safe_regex"),
    12: .standard(proto: "connect_matcher"),
    4: .standard(proto: "case_sensitive"),
    9: .standard(proto: "runtime_fraction"),
    6: .same(proto: "headers"),
    7: .standard(proto: "query_parameters"),
    8: .same(proto: "grpc"),
    11: .standard(proto: "tls_context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.pathSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathSpecifier = .prefix(v)}
      }()
      case 2: try {
        if self.pathSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathSpecifier = .path(v)}
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._caseSensitive) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.queryParameters) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._grpc) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._runtimeFraction) }()
      case 10: try {
        var v: Envoy_Type_Matcher_V4alpha_RegexMatcher?
        if let current = self.pathSpecifier {
          try decoder.handleConflictingOneOf()
          if case .safeRegex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pathSpecifier = .safeRegex(v)}
      }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._tlsContext) }()
      case 12: try {
        var v: Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher?
        if let current = self.pathSpecifier {
          try decoder.handleConflictingOneOf()
          if case .connectMatcher(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pathSpecifier = .connectMatcher(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pathSpecifier {
    case .prefix?: try {
      guard case .prefix(let v)? = self.pathSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .path?: try {
      guard case .path(let v)? = self.pathSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    default: break
    }
    if let v = self._caseSensitive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 6)
    }
    if !self.queryParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queryParameters, fieldNumber: 7)
    }
    if let v = self._grpc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._runtimeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if case .safeRegex(let v)? = self.pathSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._tlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if case .connectMatcher(let v)? = self.pathSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteMatch, rhs: Envoy_Config_Route_V4alpha_RouteMatch) -> Bool {
    if lhs.pathSpecifier != rhs.pathSpecifier {return false}
    if lhs._caseSensitive != rhs._caseSensitive {return false}
    if lhs._runtimeFraction != rhs._runtimeFraction {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.queryParameters != rhs.queryParameters {return false}
    if lhs._grpc != rhs._grpc {return false}
    if lhs._tlsContext != rhs._tlsContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteMatch.GrpcRouteMatchOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteMatch.protoMessageName + ".GrpcRouteMatchOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteMatch.GrpcRouteMatchOptions, rhs: Envoy_Config_Route_V4alpha_RouteMatch.GrpcRouteMatchOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteMatch.TlsContextMatchOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteMatch.protoMessageName + ".TlsContextMatchOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presented"),
    2: .same(proto: "validated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._presented) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._presented {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._validated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteMatch.TlsContextMatchOptions, rhs: Envoy_Config_Route_V4alpha_RouteMatch.TlsContextMatchOptions) -> Bool {
    if lhs._presented != rhs._presented {return false}
    if lhs._validated != rhs._validated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteMatch.protoMessageName + ".ConnectMatcher"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher, rhs: Envoy_Config_Route_V4alpha_RouteMatch.ConnectMatcher) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_CorsPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CorsPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "allow_origin_string_match"),
    2: .standard(proto: "allow_methods"),
    3: .standard(proto: "allow_headers"),
    4: .standard(proto: "expose_headers"),
    5: .standard(proto: "max_age"),
    6: .standard(proto: "allow_credentials"),
    9: .standard(proto: "filter_enabled"),
    10: .standard(proto: "shadow_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.allowMethods) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.allowHeaders) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.exposeHeaders) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.maxAge) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._allowCredentials) }()
      case 9: try {
        var v: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent?
        if let current = self.enabledSpecifier {
          try decoder.handleConflictingOneOf()
          if case .filterEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.enabledSpecifier = .filterEnabled(v)}
      }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._shadowEnabled) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.allowOriginStringMatch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowMethods.isEmpty {
      try visitor.visitSingularStringField(value: self.allowMethods, fieldNumber: 2)
    }
    if !self.allowHeaders.isEmpty {
      try visitor.visitSingularStringField(value: self.allowHeaders, fieldNumber: 3)
    }
    if !self.exposeHeaders.isEmpty {
      try visitor.visitSingularStringField(value: self.exposeHeaders, fieldNumber: 4)
    }
    if !self.maxAge.isEmpty {
      try visitor.visitSingularStringField(value: self.maxAge, fieldNumber: 5)
    }
    if let v = self._allowCredentials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if case .filterEnabled(let v)? = self.enabledSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._shadowEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.allowOriginStringMatch.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowOriginStringMatch, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_CorsPolicy, rhs: Envoy_Config_Route_V4alpha_CorsPolicy) -> Bool {
    if lhs.allowOriginStringMatch != rhs.allowOriginStringMatch {return false}
    if lhs.allowMethods != rhs.allowMethods {return false}
    if lhs.allowHeaders != rhs.allowHeaders {return false}
    if lhs.exposeHeaders != rhs.exposeHeaders {return false}
    if lhs.maxAge != rhs.maxAge {return false}
    if lhs._allowCredentials != rhs._allowCredentials {return false}
    if lhs.enabledSpecifier != rhs.enabledSpecifier {return false}
    if lhs._shadowEnabled != rhs._shadowEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "cluster_header"),
    3: .standard(proto: "weighted_clusters"),
    20: .standard(proto: "cluster_not_found_response_code"),
    4: .standard(proto: "metadata_match"),
    5: .standard(proto: "prefix_rewrite"),
    32: .standard(proto: "regex_rewrite"),
    6: .standard(proto: "host_rewrite_literal"),
    7: .standard(proto: "auto_host_rewrite"),
    29: .standard(proto: "host_rewrite_header"),
    35: .standard(proto: "host_rewrite_path_regex"),
    8: .same(proto: "timeout"),
    24: .standard(proto: "idle_timeout"),
    9: .standard(proto: "retry_policy"),
    33: .standard(proto: "retry_policy_typed_config"),
    30: .standard(proto: "request_mirror_policies"),
    11: .same(proto: "priority"),
    13: .standard(proto: "rate_limits"),
    15: .standard(proto: "hash_policy"),
    17: .same(proto: "cors"),
    25: .standard(proto: "upgrade_configs"),
    34: .standard(proto: "internal_redirect_policy"),
    27: .standard(proto: "hedge_policy"),
    36: .standard(proto: "max_stream_duration"),
  ]

  fileprivate class _StorageClass {
    var _clusterSpecifier: Envoy_Config_Route_V4alpha_RouteAction.OneOf_ClusterSpecifier?
    var _clusterNotFoundResponseCode: Envoy_Config_Route_V4alpha_RouteAction.ClusterNotFoundResponseCode = .serviceUnavailable
    var _metadataMatch: Envoy_Config_Core_V4alpha_Metadata? = nil
    var _prefixRewrite: String = String()
    var _regexRewrite: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute? = nil
    var _hostRewriteSpecifier: Envoy_Config_Route_V4alpha_RouteAction.OneOf_HostRewriteSpecifier?
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Envoy_Config_Route_V4alpha_RetryPolicy? = nil
    var _retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _requestMirrorPolicies: [Envoy_Config_Route_V4alpha_RouteAction.RequestMirrorPolicy] = []
    var _priority: Envoy_Config_Core_V4alpha_RoutingPriority = .default
    var _rateLimits: [Envoy_Config_Route_V4alpha_RateLimit] = []
    var _hashPolicy: [Envoy_Config_Route_V4alpha_RouteAction.HashPolicy] = []
    var _cors: Envoy_Config_Route_V4alpha_CorsPolicy? = nil
    var _upgradeConfigs: [Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig] = []
    var _internalRedirectPolicy: Envoy_Config_Route_V4alpha_InternalRedirectPolicy? = nil
    var _hedgePolicy: Envoy_Config_Route_V4alpha_HedgePolicy? = nil
    var _maxStreamDuration: Envoy_Config_Route_V4alpha_RouteAction.MaxStreamDuration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clusterSpecifier = source._clusterSpecifier
      _clusterNotFoundResponseCode = source._clusterNotFoundResponseCode
      _metadataMatch = source._metadataMatch
      _prefixRewrite = source._prefixRewrite
      _regexRewrite = source._regexRewrite
      _hostRewriteSpecifier = source._hostRewriteSpecifier
      _timeout = source._timeout
      _idleTimeout = source._idleTimeout
      _retryPolicy = source._retryPolicy
      _retryPolicyTypedConfig = source._retryPolicyTypedConfig
      _requestMirrorPolicies = source._requestMirrorPolicies
      _priority = source._priority
      _rateLimits = source._rateLimits
      _hashPolicy = source._hashPolicy
      _cors = source._cors
      _upgradeConfigs = source._upgradeConfigs
      _internalRedirectPolicy = source._internalRedirectPolicy
      _hedgePolicy = source._hedgePolicy
      _maxStreamDuration = source._maxStreamDuration
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          if _storage._clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._clusterSpecifier = .cluster(v)}
        }()
        case 2: try {
          if _storage._clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._clusterSpecifier = .clusterHeader(v)}
        }()
        case 3: try {
          var v: Envoy_Config_Route_V4alpha_WeightedCluster?
          if let current = _storage._clusterSpecifier {
            try decoder.handleConflictingOneOf()
            if case .weightedClusters(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._clusterSpecifier = .weightedClusters(v)}
        }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._metadataMatch) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._prefixRewrite) }()
        case 6: try {
          if _storage._hostRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .hostRewriteLiteral(v)}
        }()
        case 7: try {
          var v: SwiftProtobuf.Google_Protobuf_BoolValue?
          if let current = _storage._hostRewriteSpecifier {
            try decoder.handleConflictingOneOf()
            if case .autoHostRewrite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .autoHostRewrite(v)}
        }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._priority) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._rateLimits) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._hashPolicy) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._cors) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._clusterNotFoundResponseCode) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._idleTimeout) }()
        case 25: try { try decoder.decodeRepeatedMessageField(value: &_storage._upgradeConfigs) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._hedgePolicy) }()
        case 29: try {
          if _storage._hostRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .hostRewriteHeader(v)}
        }()
        case 30: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestMirrorPolicies) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._regexRewrite) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicyTypedConfig) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._internalRedirectPolicy) }()
        case 35: try {
          var v: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute?
          if let current = _storage._hostRewriteSpecifier {
            try decoder.handleConflictingOneOf()
            if case .hostRewritePathRegex(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .hostRewritePathRegex(v)}
        }()
        case 36: try { try decoder.decodeSingularMessageField(value: &_storage._maxStreamDuration) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._clusterSpecifier {
      case .cluster?: try {
        guard case .cluster(let v)? = _storage._clusterSpecifier else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }()
      case .clusterHeader?: try {
        guard case .clusterHeader(let v)? = _storage._clusterSpecifier else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }()
      case .weightedClusters?: try {
        guard case .weightedClusters(let v)? = _storage._clusterSpecifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if let v = _storage._metadataMatch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._prefixRewrite.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prefixRewrite, fieldNumber: 5)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._hostRewriteSpecifier {
      case .hostRewriteLiteral?: try {
        guard case .hostRewriteLiteral(let v)? = _storage._hostRewriteSpecifier else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }()
      case .autoHostRewrite?: try {
        guard case .autoHostRewrite(let v)? = _storage._hostRewriteSpecifier else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      default: break
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._priority != .default {
        try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 11)
      }
      if !_storage._rateLimits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rateLimits, fieldNumber: 13)
      }
      if !_storage._hashPolicy.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hashPolicy, fieldNumber: 15)
      }
      if let v = _storage._cors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if _storage._clusterNotFoundResponseCode != .serviceUnavailable {
        try visitor.visitSingularEnumField(value: _storage._clusterNotFoundResponseCode, fieldNumber: 20)
      }
      if let v = _storage._idleTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if !_storage._upgradeConfigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._upgradeConfigs, fieldNumber: 25)
      }
      if let v = _storage._hedgePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if case .hostRewriteHeader(let v)? = _storage._hostRewriteSpecifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 29)
      }
      if !_storage._requestMirrorPolicies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestMirrorPolicies, fieldNumber: 30)
      }
      if let v = _storage._regexRewrite {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._retryPolicyTypedConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if let v = _storage._internalRedirectPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
      if case .hostRewritePathRegex(let v)? = _storage._hostRewriteSpecifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }
      if let v = _storage._maxStreamDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction, rhs: Envoy_Config_Route_V4alpha_RouteAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clusterSpecifier != rhs_storage._clusterSpecifier {return false}
        if _storage._clusterNotFoundResponseCode != rhs_storage._clusterNotFoundResponseCode {return false}
        if _storage._metadataMatch != rhs_storage._metadataMatch {return false}
        if _storage._prefixRewrite != rhs_storage._prefixRewrite {return false}
        if _storage._regexRewrite != rhs_storage._regexRewrite {return false}
        if _storage._hostRewriteSpecifier != rhs_storage._hostRewriteSpecifier {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._idleTimeout != rhs_storage._idleTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._retryPolicyTypedConfig != rhs_storage._retryPolicyTypedConfig {return false}
        if _storage._requestMirrorPolicies != rhs_storage._requestMirrorPolicies {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._rateLimits != rhs_storage._rateLimits {return false}
        if _storage._hashPolicy != rhs_storage._hashPolicy {return false}
        if _storage._cors != rhs_storage._cors {return false}
        if _storage._upgradeConfigs != rhs_storage._upgradeConfigs {return false}
        if _storage._internalRedirectPolicy != rhs_storage._internalRedirectPolicy {return false}
        if _storage._hedgePolicy != rhs_storage._hedgePolicy {return false}
        if _storage._maxStreamDuration != rhs_storage._maxStreamDuration {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.ClusterNotFoundResponseCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVICE_UNAVAILABLE"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Envoy_Config_Route_V4alpha_RouteAction.RequestMirrorPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.protoMessageName + ".RequestMirrorPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    3: .standard(proto: "runtime_fraction"),
    4: .standard(proto: "trace_sampled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._runtimeFraction) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._traceSampled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if let v = self._runtimeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._traceSampled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.RequestMirrorPolicy, rhs: Envoy_Config_Route_V4alpha_RouteAction.RequestMirrorPolicy) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs._runtimeFraction != rhs._runtimeFraction {return false}
    if lhs._traceSampled != rhs._traceSampled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.HashPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.protoMessageName + ".HashPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "cookie"),
    3: .standard(proto: "connection_properties"),
    5: .standard(proto: "query_parameter"),
    6: .standard(proto: "filter_state"),
    4: .same(proto: "terminal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .header(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .header(v)}
      }()
      case 2: try {
        var v: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .cookie(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .cookie(v)}
      }()
      case 3: try {
        var v: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .connectionProperties(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .connectionProperties(v)}
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.terminal) }()
      case 5: try {
        var v: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .queryParameter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .queryParameter(v)}
      }()
      case 6: try {
        var v: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .filterState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .filterState(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.policySpecifier {
    case .header?: try {
      guard case .header(let v)? = self.policySpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cookie?: try {
      guard case .cookie(let v)? = self.policySpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .connectionProperties?: try {
      guard case .connectionProperties(let v)? = self.policySpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if self.terminal != false {
      try visitor.visitSingularBoolField(value: self.terminal, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.policySpecifier {
    case .queryParameter?: try {
      guard case .queryParameter(let v)? = self.policySpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .filterState?: try {
      guard case .filterState(let v)? = self.policySpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy) -> Bool {
    if lhs.policySpecifier != rhs.policySpecifier {return false}
    if lhs.terminal != rhs.terminal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.protoMessageName + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "header_name"),
    2: .standard(proto: "regex_rewrite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.headerName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._regexRewrite) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headerName.isEmpty {
      try visitor.visitSingularStringField(value: self.headerName, fieldNumber: 1)
    }
    if let v = self._regexRewrite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Header) -> Bool {
    if lhs.headerName != rhs.headerName {return false}
    if lhs._regexRewrite != rhs._regexRewrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.protoMessageName + ".Cookie"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ttl"),
    3: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.Cookie) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._ttl != rhs._ttl {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.protoMessageName + ".ConnectionProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.sourceIp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceIp != false {
      try visitor.visitSingularBoolField(value: self.sourceIp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.ConnectionProperties) -> Bool {
    if lhs.sourceIp != rhs.sourceIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.protoMessageName + ".QueryParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.QueryParameter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.protoMessageName + ".FilterState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState, rhs: Envoy_Config_Route_V4alpha_RouteAction.HashPolicy.FilterState) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.protoMessageName + ".UpgradeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upgrade_type"),
    2: .same(proto: "enabled"),
    3: .standard(proto: "connect_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.upgradeType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._enabled) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._connectConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.upgradeType.isEmpty {
      try visitor.visitSingularStringField(value: self.upgradeType, fieldNumber: 1)
    }
    if let v = self._enabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._connectConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig, rhs: Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig) -> Bool {
    if lhs.upgradeType != rhs.upgradeType {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs._connectConfig != rhs._connectConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.ConnectConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.protoMessageName + ".ConnectConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proxy_protocol_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._proxyProtocolConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._proxyProtocolConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.ConnectConfig, rhs: Envoy_Config_Route_V4alpha_RouteAction.UpgradeConfig.ConnectConfig) -> Bool {
    if lhs._proxyProtocolConfig != rhs._proxyProtocolConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RouteAction.MaxStreamDuration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RouteAction.protoMessageName + ".MaxStreamDuration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_stream_duration"),
    2: .standard(proto: "grpc_timeout_header_max"),
    3: .standard(proto: "grpc_timeout_header_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._maxStreamDuration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._grpcTimeoutHeaderMax) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._grpcTimeoutHeaderOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._maxStreamDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._grpcTimeoutHeaderMax {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._grpcTimeoutHeaderOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteAction.MaxStreamDuration, rhs: Envoy_Config_Route_V4alpha_RouteAction.MaxStreamDuration) -> Bool {
    if lhs._maxStreamDuration != rhs._maxStreamDuration {return false}
    if lhs._grpcTimeoutHeaderMax != rhs._grpcTimeoutHeaderMax {return false}
    if lhs._grpcTimeoutHeaderOffset != rhs._grpcTimeoutHeaderOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_on"),
    2: .standard(proto: "max_retries"),
    3: .standard(proto: "per_try_timeout"),
    4: .standard(proto: "retry_priority"),
    5: .standard(proto: "retry_host_predicate"),
    6: .standard(proto: "host_selection_retry_max_attempts"),
    7: .standard(proto: "retriable_status_codes"),
    8: .standard(proto: "retry_back_off"),
    11: .standard(proto: "rate_limited_retry_back_off"),
    9: .standard(proto: "retriable_headers"),
    10: .standard(proto: "retriable_request_headers"),
  ]

  fileprivate class _StorageClass {
    var _retryOn: String = String()
    var _maxRetries: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _perTryTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPriority: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority? = nil
    var _retryHostPredicate: [Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate] = []
    var _hostSelectionRetryMaxAttempts: Int64 = 0
    var _retriableStatusCodes: [UInt32] = []
    var _retryBackOff: Envoy_Config_Route_V4alpha_RetryPolicy.RetryBackOff? = nil
    var _rateLimitedRetryBackOff: Envoy_Config_Route_V4alpha_RetryPolicy.RateLimitedRetryBackOff? = nil
    var _retriableHeaders: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []
    var _retriableRequestHeaders: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _retryOn = source._retryOn
      _maxRetries = source._maxRetries
      _perTryTimeout = source._perTryTimeout
      _retryPriority = source._retryPriority
      _retryHostPredicate = source._retryHostPredicate
      _hostSelectionRetryMaxAttempts = source._hostSelectionRetryMaxAttempts
      _retriableStatusCodes = source._retriableStatusCodes
      _retryBackOff = source._retryBackOff
      _rateLimitedRetryBackOff = source._rateLimitedRetryBackOff
      _retriableHeaders = source._retriableHeaders
      _retriableRequestHeaders = source._retriableRequestHeaders
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._retryOn) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._maxRetries) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._perTryTimeout) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._retryPriority) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._retryHostPredicate) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._hostSelectionRetryMaxAttempts) }()
        case 7: try { try decoder.decodeRepeatedUInt32Field(value: &_storage._retriableStatusCodes) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._retryBackOff) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._retriableHeaders) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._retriableRequestHeaders) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._rateLimitedRetryBackOff) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._retryOn.isEmpty {
        try visitor.visitSingularStringField(value: _storage._retryOn, fieldNumber: 1)
      }
      if let v = _storage._maxRetries {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._perTryTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._retryPriority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._retryHostPredicate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._retryHostPredicate, fieldNumber: 5)
      }
      if _storage._hostSelectionRetryMaxAttempts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._hostSelectionRetryMaxAttempts, fieldNumber: 6)
      }
      if !_storage._retriableStatusCodes.isEmpty {
        try visitor.visitPackedUInt32Field(value: _storage._retriableStatusCodes, fieldNumber: 7)
      }
      if let v = _storage._retryBackOff {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._retriableHeaders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._retriableHeaders, fieldNumber: 9)
      }
      if !_storage._retriableRequestHeaders.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._retriableRequestHeaders, fieldNumber: 10)
      }
      if let v = _storage._rateLimitedRetryBackOff {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy, rhs: Envoy_Config_Route_V4alpha_RetryPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._retryOn != rhs_storage._retryOn {return false}
        if _storage._maxRetries != rhs_storage._maxRetries {return false}
        if _storage._perTryTimeout != rhs_storage._perTryTimeout {return false}
        if _storage._retryPriority != rhs_storage._retryPriority {return false}
        if _storage._retryHostPredicate != rhs_storage._retryHostPredicate {return false}
        if _storage._hostSelectionRetryMaxAttempts != rhs_storage._hostSelectionRetryMaxAttempts {return false}
        if _storage._retriableStatusCodes != rhs_storage._retriableStatusCodes {return false}
        if _storage._retryBackOff != rhs_storage._retryBackOff {return false}
        if _storage._rateLimitedRetryBackOff != rhs_storage._rateLimitedRetryBackOff {return false}
        if _storage._retriableHeaders != rhs_storage._retriableHeaders {return false}
        if _storage._retriableRequestHeaders != rhs_storage._retriableRequestHeaders {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeaderFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SECONDS"),
    1: .same(proto: "UNIX_TIMESTAMP"),
  ]
}

extension Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RetryPolicy.protoMessageName + ".RetryPriority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryPriority) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RetryPolicy.protoMessageName + ".RetryHostPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryHostPredicate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RetryPolicy.RetryBackOff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RetryPolicy.protoMessageName + ".RetryBackOff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_interval"),
    2: .standard(proto: "max_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseInterval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryBackOff, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.RetryBackOff) -> Bool {
    if lhs._baseInterval != rhs._baseInterval {return false}
    if lhs._maxInterval != rhs._maxInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RetryPolicy.protoMessageName + ".ResetHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "format"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.format != .seconds {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeader, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.ResetHeader) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RetryPolicy.RateLimitedRetryBackOff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RetryPolicy.protoMessageName + ".RateLimitedRetryBackOff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reset_headers"),
    2: .standard(proto: "max_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resetHeaders) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resetHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resetHeaders, fieldNumber: 1)
    }
    if let v = self._maxInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RetryPolicy.RateLimitedRetryBackOff, rhs: Envoy_Config_Route_V4alpha_RetryPolicy.RateLimitedRetryBackOff) -> Bool {
    if lhs.resetHeaders != rhs.resetHeaders {return false}
    if lhs._maxInterval != rhs._maxInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_HedgePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HedgePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_requests"),
    2: .standard(proto: "additional_request_chance"),
    3: .standard(proto: "hedge_on_per_try_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._initialRequests) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._additionalRequestChance) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hedgeOnPerTryTimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._initialRequests {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._additionalRequestChance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.hedgeOnPerTryTimeout != false {
      try visitor.visitSingularBoolField(value: self.hedgeOnPerTryTimeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_HedgePolicy, rhs: Envoy_Config_Route_V4alpha_HedgePolicy) -> Bool {
    if lhs._initialRequests != rhs._initialRequests {return false}
    if lhs._additionalRequestChance != rhs._additionalRequestChance {return false}
    if lhs.hedgeOnPerTryTimeout != rhs.hedgeOnPerTryTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RedirectAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedirectAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "https_redirect"),
    7: .standard(proto: "scheme_redirect"),
    1: .standard(proto: "host_redirect"),
    8: .standard(proto: "port_redirect"),
    2: .standard(proto: "path_redirect"),
    5: .standard(proto: "prefix_rewrite"),
    3: .standard(proto: "response_code"),
    6: .standard(proto: "strip_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostRedirect) }()
      case 2: try {
        if self.pathRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathRewriteSpecifier = .pathRedirect(v)}
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.responseCode) }()
      case 4: try {
        if self.schemeRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.schemeRewriteSpecifier = .httpsRedirect(v)}
      }()
      case 5: try {
        if self.pathRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathRewriteSpecifier = .prefixRewrite(v)}
      }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.stripQuery) }()
      case 7: try {
        if self.schemeRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.schemeRewriteSpecifier = .schemeRedirect(v)}
      }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.portRedirect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostRedirect.isEmpty {
      try visitor.visitSingularStringField(value: self.hostRedirect, fieldNumber: 1)
    }
    if case .pathRedirect(let v)? = self.pathRewriteSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if self.responseCode != .movedPermanently {
      try visitor.visitSingularEnumField(value: self.responseCode, fieldNumber: 3)
    }
    if case .httpsRedirect(let v)? = self.schemeRewriteSpecifier {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if case .prefixRewrite(let v)? = self.pathRewriteSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if self.stripQuery != false {
      try visitor.visitSingularBoolField(value: self.stripQuery, fieldNumber: 6)
    }
    if case .schemeRedirect(let v)? = self.schemeRewriteSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if self.portRedirect != 0 {
      try visitor.visitSingularUInt32Field(value: self.portRedirect, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RedirectAction, rhs: Envoy_Config_Route_V4alpha_RedirectAction) -> Bool {
    if lhs.schemeRewriteSpecifier != rhs.schemeRewriteSpecifier {return false}
    if lhs.hostRedirect != rhs.hostRedirect {return false}
    if lhs.portRedirect != rhs.portRedirect {return false}
    if lhs.pathRewriteSpecifier != rhs.pathRewriteSpecifier {return false}
    if lhs.responseCode != rhs.responseCode {return false}
    if lhs.stripQuery != rhs.stripQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RedirectAction.RedirectResponseCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOVED_PERMANENTLY"),
    1: .same(proto: "FOUND"),
    2: .same(proto: "SEE_OTHER"),
    3: .same(proto: "TEMPORARY_REDIRECT"),
    4: .same(proto: "PERMANENT_REDIRECT"),
  ]
}

extension Envoy_Config_Route_V4alpha_DirectResponseAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirectResponseAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularUInt32Field(value: self.status, fieldNumber: 1)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_DirectResponseAction, rhs: Envoy_Config_Route_V4alpha_DirectResponseAction) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_Decorator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Decorator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "propagate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._propagate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 1)
    }
    if let v = self._propagate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_Decorator, rhs: Envoy_Config_Route_V4alpha_Decorator) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._propagate != rhs._propagate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_Tracing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tracing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_sampling"),
    2: .standard(proto: "random_sampling"),
    3: .standard(proto: "overall_sampling"),
    4: .standard(proto: "custom_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._clientSampling) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._randomSampling) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._overallSampling) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.customTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._clientSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._randomSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._overallSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.customTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customTags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_Tracing, rhs: Envoy_Config_Route_V4alpha_Tracing) -> Bool {
    if lhs._clientSampling != rhs._clientSampling {return false}
    if lhs._randomSampling != rhs._randomSampling {return false}
    if lhs._overallSampling != rhs._overallSampling {return false}
    if lhs.customTags != rhs.customTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_VirtualCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VirtualCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "headers"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_VirtualCluster, rhs: Envoy_Config_Route_V4alpha_VirtualCluster) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stage"),
    2: .standard(proto: "disable_key"),
    3: .same(proto: "actions"),
    4: .same(proto: "limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.disableKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._limit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.disableKey.isEmpty {
      try visitor.visitSingularStringField(value: self.disableKey, fieldNumber: 2)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 3)
    }
    if let v = self._limit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit, rhs: Envoy_Config_Route_V4alpha_RateLimit) -> Bool {
    if lhs._stage != rhs._stage {return false}
    if lhs.disableKey != rhs.disableKey {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs._limit != rhs._limit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.protoMessageName + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_cluster"),
    2: .standard(proto: "destination_cluster"),
    3: .standard(proto: "request_headers"),
    4: .standard(proto: "remote_address"),
    5: .standard(proto: "generic_key"),
    6: .standard(proto: "header_value_match"),
    8: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .sourceCluster(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .sourceCluster(v)}
      }()
      case 2: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .destinationCluster(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .destinationCluster(v)}
      }()
      case 3: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .requestHeaders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .requestHeaders(v)}
      }()
      case 4: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .remoteAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .remoteAddress(v)}
      }()
      case 5: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .genericKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .genericKey(v)}
      }()
      case 6: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .headerValueMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .headerValueMatch(v)}
      }()
      case 8: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .metadata(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.actionSpecifier {
    case .sourceCluster?: try {
      guard case .sourceCluster(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .destinationCluster?: try {
      guard case .destinationCluster(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .requestHeaders?: try {
      guard case .requestHeaders(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .remoteAddress?: try {
      guard case .remoteAddress(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .genericKey?: try {
      guard case .genericKey(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .headerValueMatch?: try {
      guard case .headerValueMatch(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .metadata?: try {
      guard case .metadata(let v)? = self.actionSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action) -> Bool {
    if lhs.actionSpecifier != rhs.actionSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".SourceCluster"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.SourceCluster) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".DestinationCluster"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.DestinationCluster) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".RequestHeaders"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "header_name"),
    2: .standard(proto: "descriptor_key"),
    3: .standard(proto: "skip_if_absent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.headerName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.descriptorKey) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipIfAbsent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headerName.isEmpty {
      try visitor.visitSingularStringField(value: self.headerName, fieldNumber: 1)
    }
    if !self.descriptorKey.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorKey, fieldNumber: 2)
    }
    if self.skipIfAbsent != false {
      try visitor.visitSingularBoolField(value: self.skipIfAbsent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.RequestHeaders) -> Bool {
    if lhs.headerName != rhs.headerName {return false}
    if lhs.descriptorKey != rhs.descriptorKey {return false}
    if lhs.skipIfAbsent != rhs.skipIfAbsent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".RemoteAddress"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.RemoteAddress) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".GenericKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "descriptor_value"),
    2: .standard(proto: "descriptor_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.descriptorValue) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.descriptorKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptorValue.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorValue, fieldNumber: 1)
    }
    if !self.descriptorKey.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.GenericKey) -> Bool {
    if lhs.descriptorValue != rhs.descriptorValue {return false}
    if lhs.descriptorKey != rhs.descriptorKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".HeaderValueMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "descriptor_value"),
    2: .standard(proto: "expect_match"),
    3: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.descriptorValue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expectMatch) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptorValue.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorValue, fieldNumber: 1)
    }
    if let v = self._expectMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.HeaderValueMatch) -> Bool {
    if lhs.descriptorValue != rhs.descriptorValue {return false}
    if lhs._expectMatch != rhs._expectMatch {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.DynamicMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".DynamicMetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "descriptor_key"),
    2: .standard(proto: "metadata_key"),
    3: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.descriptorKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadataKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptorKey.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorKey, fieldNumber: 1)
    }
    if let v = self._metadataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.DynamicMetaData, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.DynamicMetaData) -> Bool {
    if lhs.descriptorKey != rhs.descriptorKey {return false}
    if lhs._metadataKey != rhs._metadataKey {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Action.protoMessageName + ".MetaData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "descriptor_key"),
    2: .standard(proto: "metadata_key"),
    3: .standard(proto: "default_value"),
    4: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.descriptorKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadataKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptorKey.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorKey, fieldNumber: 1)
    }
    if let v = self._metadataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 3)
    }
    if self.source != .dynamic {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData, rhs: Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData) -> Bool {
    if lhs.descriptorKey != rhs.descriptorKey {return false}
    if lhs._metadataKey != rhs._metadataKey {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Action.MetaData.Source: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DYNAMIC"),
    1: .same(proto: "ROUTE_ENTRY"),
  ]
}

extension Envoy_Config_Route_V4alpha_RateLimit.Override: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.protoMessageName + ".Override"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dynamic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata?
        if let current = self.overrideSpecifier {
          try decoder.handleConflictingOneOf()
          if case .dynamicMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.overrideSpecifier = .dynamicMetadata(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .dynamicMetadata(let v)? = self.overrideSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Override, rhs: Envoy_Config_Route_V4alpha_RateLimit.Override) -> Bool {
    if lhs.overrideSpecifier != rhs.overrideSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V4alpha_RateLimit.Override.protoMessageName + ".DynamicMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metadata_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadataKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metadataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata, rhs: Envoy_Config_Route_V4alpha_RateLimit.Override.DynamicMetadata) -> Bool {
    if lhs._metadataKey != rhs._metadataKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_HeaderMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeaderMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .standard(proto: "exact_match"),
    11: .standard(proto: "safe_regex_match"),
    6: .standard(proto: "range_match"),
    7: .standard(proto: "present_match"),
    9: .standard(proto: "prefix_match"),
    10: .standard(proto: "suffix_match"),
    12: .standard(proto: "contains_match"),
    8: .standard(proto: "invert_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try {
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .exactMatch(v)}
      }()
      case 6: try {
        var v: Envoy_Type_V3_Int64Range?
        if let current = self.headerMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .rangeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.headerMatchSpecifier = .rangeMatch(v)}
      }()
      case 7: try {
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.headerMatchSpecifier = .presentMatch(v)}
      }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.invertMatch) }()
      case 9: try {
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .prefixMatch(v)}
      }()
      case 10: try {
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .suffixMatch(v)}
      }()
      case 11: try {
        var v: Envoy_Type_Matcher_V4alpha_RegexMatcher?
        if let current = self.headerMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .safeRegexMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.headerMatchSpecifier = .safeRegexMatch(v)}
      }()
      case 12: try {
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .containsMatch(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.headerMatchSpecifier {
    case .exactMatch?: try {
      guard case .exactMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .rangeMatch?: try {
      guard case .rangeMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .presentMatch?: try {
      guard case .presentMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if self.invertMatch != false {
      try visitor.visitSingularBoolField(value: self.invertMatch, fieldNumber: 8)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.headerMatchSpecifier {
    case .prefixMatch?: try {
      guard case .prefixMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }()
    case .suffixMatch?: try {
      guard case .suffixMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    }()
    case .safeRegexMatch?: try {
      guard case .safeRegexMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .containsMatch?: try {
      guard case .containsMatch(let v)? = self.headerMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_HeaderMatcher, rhs: Envoy_Config_Route_V4alpha_HeaderMatcher) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.headerMatchSpecifier != rhs.headerMatchSpecifier {return false}
    if lhs.invertMatch != rhs.invertMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_QueryParameterMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryParameterMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    5: .standard(proto: "string_match"),
    6: .standard(proto: "present_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try {
        var v: Envoy_Type_Matcher_V4alpha_StringMatcher?
        if let current = self.queryParameterMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .stringMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.queryParameterMatchSpecifier = .stringMatch(v)}
      }()
      case 6: try {
        if self.queryParameterMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.queryParameterMatchSpecifier = .presentMatch(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.queryParameterMatchSpecifier {
    case .stringMatch?: try {
      guard case .stringMatch(let v)? = self.queryParameterMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .presentMatch?: try {
      guard case .presentMatch(let v)? = self.queryParameterMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_QueryParameterMatcher, rhs: Envoy_Config_Route_V4alpha_QueryParameterMatcher) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.queryParameterMatchSpecifier != rhs.queryParameterMatchSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_InternalRedirectPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InternalRedirectPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_internal_redirects"),
    2: .standard(proto: "redirect_response_codes"),
    3: .same(proto: "predicates"),
    4: .standard(proto: "allow_cross_scheme_redirect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._maxInternalRedirects) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.redirectResponseCodes) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.predicates) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowCrossSchemeRedirect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._maxInternalRedirects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.redirectResponseCodes.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.redirectResponseCodes, fieldNumber: 2)
    }
    if !self.predicates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.predicates, fieldNumber: 3)
    }
    if self.allowCrossSchemeRedirect != false {
      try visitor.visitSingularBoolField(value: self.allowCrossSchemeRedirect, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_InternalRedirectPolicy, rhs: Envoy_Config_Route_V4alpha_InternalRedirectPolicy) -> Bool {
    if lhs._maxInternalRedirects != rhs._maxInternalRedirects {return false}
    if lhs.redirectResponseCodes != rhs.redirectResponseCodes {return false}
    if lhs.predicates != rhs.predicates {return false}
    if lhs.allowCrossSchemeRedirect != rhs.allowCrossSchemeRedirect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

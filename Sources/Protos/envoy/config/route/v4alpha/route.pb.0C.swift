// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/route/v4alpha/route.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 11]
public struct Envoy_Config_Route_V4alpha_RouteConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the route configuration. For example, it might match
  /// :ref:`route_config_name
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.Rds.route_config_name>` in
  /// :ref:`envoy_api_msg_extensions.filters.network.http_connection_manager.v4alpha.Rds`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// An array of virtual hosts that make up the route table.
  public var virtualHosts: [Envoy_Config_Route_V4alpha_VirtualHost] {
    get {return _storage._virtualHosts}
    set {_uniqueStorage()._virtualHosts = newValue}
  }

  /// An array of virtual hosts will be dynamically loaded via the VHDS API.
  /// Both *virtual_hosts* and *vhds* fields will be used when present. *virtual_hosts* can be used
  /// for a base routing table or for infrequently changing virtual hosts. *vhds* is used for
  /// on-demand discovery of virtual hosts. The contents of these two fields will be merged to
  /// generate a routing table for a given RouteConfiguration, with *vhds* derived configuration
  /// taking precedence.
  public var vhds: Envoy_Config_Route_V4alpha_Vhds {
    get {return _storage._vhds ?? Envoy_Config_Route_V4alpha_Vhds()}
    set {_uniqueStorage()._vhds = newValue}
  }
  /// Returns true if `vhds` has been explicitly set.
  public var hasVhds: Bool {return _storage._vhds != nil}
  /// Clears the value of `vhds`. Subsequent reads from it will return its default value.
  public mutating func clearVhds() {_uniqueStorage()._vhds = nil}

  /// Optionally specifies a list of HTTP headers that the connection manager
  /// will consider to be internal only. If they are found on external requests they will be cleaned
  /// prior to filter invocation. See :ref:`config_http_conn_man_headers_x-envoy-internal` for more
  /// information.
  public var internalOnlyHeaders: [String] {
    get {return _storage._internalOnlyHeaders}
    set {_uniqueStorage()._internalOnlyHeaders = newValue}
  }

  /// Specifies a list of HTTP headers that should be added to each response that
  /// the connection manager encodes. Headers specified at this level are applied
  /// after headers from any enclosed :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost` or
  /// :ref:`envoy_api_msg_config.route.v4alpha.RouteAction`. For more information, including details on
  /// header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] {
    get {return _storage._responseHeadersToAdd}
    set {_uniqueStorage()._responseHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each response
  /// that the connection manager encodes.
  public var responseHeadersToRemove: [String] {
    get {return _storage._responseHeadersToRemove}
    set {_uniqueStorage()._responseHeadersToRemove = newValue}
  }

  /// Specifies a list of HTTP headers that should be added to each request
  /// routed by the HTTP connection manager. Headers specified at this level are
  /// applied after headers from any enclosed :ref:`envoy_api_msg_config.route.v4alpha.VirtualHost` or
  /// :ref:`envoy_api_msg_config.route.v4alpha.RouteAction`. For more information, including details on
  /// header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] {
    get {return _storage._requestHeadersToAdd}
    set {_uniqueStorage()._requestHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each request
  /// routed by the HTTP connection manager.
  public var requestHeadersToRemove: [String] {
    get {return _storage._requestHeadersToRemove}
    set {_uniqueStorage()._requestHeadersToRemove = newValue}
  }

  /// By default, headers that should be added/removed are evaluated from most to least specific:
  ///
  /// * route level
  /// * virtual host level
  /// * connection manager level
  ///
  /// To allow setting overrides at the route or virtual host level, this order can be reversed
  /// by setting this option to true. Defaults to false.
  ///
  /// [#next-major-version: In the v3 API, this will default to true.]
  public var mostSpecificHeaderMutationsWins: Bool {
    get {return _storage._mostSpecificHeaderMutationsWins}
    set {_uniqueStorage()._mostSpecificHeaderMutationsWins = newValue}
  }

  /// An optional boolean that specifies whether the clusters that the route
  /// table refers to will be validated by the cluster manager. If set to true
  /// and a route refers to a non-existent cluster, the route table will not
  /// load. If set to false and a route refers to a non-existent cluster, the
  /// route table will load and the router filter will return a 404 if the route
  /// is selected at runtime. This setting defaults to true if the route table
  /// is statically defined via the :ref:`route_config
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.route_config>`
  /// option. This setting default to false if the route table is loaded dynamically via the
  /// :ref:`rds
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.rds>`
  /// option. Users may wish to override the default behavior in certain cases (for example when
  /// using CDS with a static route table).
  public var validateClusters: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._validateClusters ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._validateClusters = newValue}
  }
  /// Returns true if `validateClusters` has been explicitly set.
  public var hasValidateClusters: Bool {return _storage._validateClusters != nil}
  /// Clears the value of `validateClusters`. Subsequent reads from it will return its default value.
  public mutating func clearValidateClusters() {_uniqueStorage()._validateClusters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Envoy_Config_Route_V4alpha_Vhds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration source specifier for VHDS.
  public var configSource: Envoy_Config_Core_V4alpha_ConfigSource {
    get {return _configSource ?? Envoy_Config_Core_V4alpha_ConfigSource()}
    set {_configSource = newValue}
  }
  /// Returns true if `configSource` has been explicitly set.
  public var hasConfigSource: Bool {return self._configSource != nil}
  /// Clears the value of `configSource`. Subsequent reads from it will return its default value.
  public mutating func clearConfigSource() {self._configSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configSource: Envoy_Config_Core_V4alpha_ConfigSource? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.route.v4alpha"

extension Envoy_Config_Route_V4alpha_RouteConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "virtual_hosts"),
    9: .same(proto: "vhds"),
    3: .standard(proto: "internal_only_headers"),
    4: .standard(proto: "response_headers_to_add"),
    5: .standard(proto: "response_headers_to_remove"),
    6: .standard(proto: "request_headers_to_add"),
    8: .standard(proto: "request_headers_to_remove"),
    10: .standard(proto: "most_specific_header_mutations_wins"),
    7: .standard(proto: "validate_clusters"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _virtualHosts: [Envoy_Config_Route_V4alpha_VirtualHost] = []
    var _vhds: Envoy_Config_Route_V4alpha_Vhds? = nil
    var _internalOnlyHeaders: [String] = []
    var _responseHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []
    var _responseHeadersToRemove: [String] = []
    var _requestHeadersToAdd: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []
    var _requestHeadersToRemove: [String] = []
    var _mostSpecificHeaderMutationsWins: Bool = false
    var _validateClusters: SwiftProtobuf.Google_Protobuf_BoolValue? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _virtualHosts = source._virtualHosts
      _vhds = source._vhds
      _internalOnlyHeaders = source._internalOnlyHeaders
      _responseHeadersToAdd = source._responseHeadersToAdd
      _responseHeadersToRemove = source._responseHeadersToRemove
      _requestHeadersToAdd = source._requestHeadersToAdd
      _requestHeadersToRemove = source._requestHeadersToRemove
      _mostSpecificHeaderMutationsWins = source._mostSpecificHeaderMutationsWins
      _validateClusters = source._validateClusters
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._virtualHosts) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._internalOnlyHeaders) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._responseHeadersToAdd) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._responseHeadersToRemove) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._requestHeadersToAdd) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._validateClusters) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._requestHeadersToRemove) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._vhds) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._mostSpecificHeaderMutationsWins) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._virtualHosts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._virtualHosts, fieldNumber: 2)
      }
      if !_storage._internalOnlyHeaders.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._internalOnlyHeaders, fieldNumber: 3)
      }
      if !_storage._responseHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._responseHeadersToAdd, fieldNumber: 4)
      }
      if !_storage._responseHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._responseHeadersToRemove, fieldNumber: 5)
      }
      if !_storage._requestHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestHeadersToAdd, fieldNumber: 6)
      }
      if let v = _storage._validateClusters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._requestHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requestHeadersToRemove, fieldNumber: 8)
      }
      if let v = _storage._vhds {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._mostSpecificHeaderMutationsWins != false {
        try visitor.visitSingularBoolField(value: _storage._mostSpecificHeaderMutationsWins, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_RouteConfiguration, rhs: Envoy_Config_Route_V4alpha_RouteConfiguration) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._virtualHosts != rhs_storage._virtualHosts {return false}
        if _storage._vhds != rhs_storage._vhds {return false}
        if _storage._internalOnlyHeaders != rhs_storage._internalOnlyHeaders {return false}
        if _storage._responseHeadersToAdd != rhs_storage._responseHeadersToAdd {return false}
        if _storage._responseHeadersToRemove != rhs_storage._responseHeadersToRemove {return false}
        if _storage._requestHeadersToAdd != rhs_storage._requestHeadersToAdd {return false}
        if _storage._requestHeadersToRemove != rhs_storage._requestHeadersToRemove {return false}
        if _storage._mostSpecificHeaderMutationsWins != rhs_storage._mostSpecificHeaderMutationsWins {return false}
        if _storage._validateClusters != rhs_storage._validateClusters {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V4alpha_Vhds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vhds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._configSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._configSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V4alpha_Vhds, rhs: Envoy_Config_Route_V4alpha_Vhds) -> Bool {
    if lhs._configSource != rhs._configSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/route/v3/route.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 11]
public struct Envoy_Config_Route_V3_RouteConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the route configuration. For example, it might match
  /// :ref:`route_config_name
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.Rds.route_config_name>` in
  /// :ref:`envoy_api_msg_extensions.filters.network.http_connection_manager.v3.Rds`.
  public var name: String = String()

  /// An array of virtual hosts that make up the route table.
  public var virtualHosts: [Envoy_Config_Route_V3_VirtualHost] = []

  /// An array of virtual hosts will be dynamically loaded via the VHDS API.
  /// Both *virtual_hosts* and *vhds* fields will be used when present. *virtual_hosts* can be used
  /// for a base routing table or for infrequently changing virtual hosts. *vhds* is used for
  /// on-demand discovery of virtual hosts. The contents of these two fields will be merged to
  /// generate a routing table for a given RouteConfiguration, with *vhds* derived configuration
  /// taking precedence.
  public var vhds: Envoy_Config_Route_V3_Vhds {
    get {return _vhds ?? Envoy_Config_Route_V3_Vhds()}
    set {_vhds = newValue}
  }
  /// Returns true if `vhds` has been explicitly set.
  public var hasVhds: Bool {return self._vhds != nil}
  /// Clears the value of `vhds`. Subsequent reads from it will return its default value.
  public mutating func clearVhds() {self._vhds = nil}

  /// Optionally specifies a list of HTTP headers that the connection manager
  /// will consider to be internal only. If they are found on external requests they will be cleaned
  /// prior to filter invocation. See :ref:`config_http_conn_man_headers_x-envoy-internal` for more
  /// information.
  public var internalOnlyHeaders: [String] = []

  /// Specifies a list of HTTP headers that should be added to each response that
  /// the connection manager encodes. Headers specified at this level are applied
  /// after headers from any enclosed :ref:`envoy_api_msg_config.route.v3.VirtualHost` or
  /// :ref:`envoy_api_msg_config.route.v3.RouteAction`. For more information, including details on
  /// header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var responseHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []

  /// Specifies a list of HTTP headers that should be removed from each response
  /// that the connection manager encodes.
  public var responseHeadersToRemove: [String] = []

  /// Specifies a list of HTTP headers that should be added to each request
  /// routed by the HTTP connection manager. Headers specified at this level are
  /// applied after headers from any enclosed :ref:`envoy_api_msg_config.route.v3.VirtualHost` or
  /// :ref:`envoy_api_msg_config.route.v3.RouteAction`. For more information, including details on
  /// header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var requestHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []

  /// Specifies a list of HTTP headers that should be removed from each request
  /// routed by the HTTP connection manager.
  public var requestHeadersToRemove: [String] = []

  /// By default, headers that should be added/removed are evaluated from most to least specific:
  ///
  /// * route level
  /// * virtual host level
  /// * connection manager level
  ///
  /// To allow setting overrides at the route or virtual host level, this order can be reversed
  /// by setting this option to true. Defaults to false.
  ///
  /// [#next-major-version: In the v3 API, this will default to true.]
  public var mostSpecificHeaderMutationsWins: Bool = false

  /// An optional boolean that specifies whether the clusters that the route
  /// table refers to will be validated by the cluster manager. If set to true
  /// and a route refers to a non-existent cluster, the route table will not
  /// load. If set to false and a route refers to a non-existent cluster, the
  /// route table will load and the router filter will return a 404 if the route
  /// is selected at runtime. This setting defaults to true if the route table
  /// is statically defined via the :ref:`route_config
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.route_config>`
  /// option. This setting default to false if the route table is loaded dynamically via the
  /// :ref:`rds
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.rds>`
  /// option. Users may wish to override the default behavior in certain cases (for example when
  /// using CDS with a static route table).
  public var validateClusters: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _validateClusters ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_validateClusters = newValue}
  }
  /// Returns true if `validateClusters` has been explicitly set.
  public var hasValidateClusters: Bool {return self._validateClusters != nil}
  /// Clears the value of `validateClusters`. Subsequent reads from it will return its default value.
  public mutating func clearValidateClusters() {self._validateClusters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _vhds: Envoy_Config_Route_V3_Vhds? = nil
  fileprivate var _validateClusters: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Envoy_Config_Route_V3_Vhds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration source specifier for VHDS.
  public var configSource: Envoy_Config_Core_V3_ConfigSource {
    get {return _configSource ?? Envoy_Config_Core_V3_ConfigSource()}
    set {_configSource = newValue}
  }
  /// Returns true if `configSource` has been explicitly set.
  public var hasConfigSource: Bool {return self._configSource != nil}
  /// Clears the value of `configSource`. Subsequent reads from it will return its default value.
  public mutating func clearConfigSource() {self._configSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configSource: Envoy_Config_Core_V3_ConfigSource? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.route.v3"

extension Envoy_Config_Route_V3_RouteConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "virtual_hosts"),
    9: .same(proto: "vhds"),
    3: .standard(proto: "internal_only_headers"),
    4: .standard(proto: "response_headers_to_add"),
    5: .standard(proto: "response_headers_to_remove"),
    6: .standard(proto: "request_headers_to_add"),
    8: .standard(proto: "request_headers_to_remove"),
    10: .standard(proto: "most_specific_header_mutations_wins"),
    7: .standard(proto: "validate_clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.virtualHosts)
      case 3: try decoder.decodeRepeatedStringField(value: &self.internalOnlyHeaders)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.responseHeadersToAdd)
      case 5: try decoder.decodeRepeatedStringField(value: &self.responseHeadersToRemove)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.requestHeadersToAdd)
      case 7: try decoder.decodeSingularMessageField(value: &self._validateClusters)
      case 8: try decoder.decodeRepeatedStringField(value: &self.requestHeadersToRemove)
      case 9: try decoder.decodeSingularMessageField(value: &self._vhds)
      case 10: try decoder.decodeSingularBoolField(value: &self.mostSpecificHeaderMutationsWins)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.virtualHosts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.virtualHosts, fieldNumber: 2)
    }
    if !self.internalOnlyHeaders.isEmpty {
      try visitor.visitRepeatedStringField(value: self.internalOnlyHeaders, fieldNumber: 3)
    }
    if !self.responseHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeadersToAdd, fieldNumber: 4)
    }
    if !self.responseHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.responseHeadersToRemove, fieldNumber: 5)
    }
    if !self.requestHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeadersToAdd, fieldNumber: 6)
    }
    if let v = self._validateClusters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.requestHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestHeadersToRemove, fieldNumber: 8)
    }
    if let v = self._vhds {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if self.mostSpecificHeaderMutationsWins != false {
      try visitor.visitSingularBoolField(value: self.mostSpecificHeaderMutationsWins, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteConfiguration, rhs: Envoy_Config_Route_V3_RouteConfiguration) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.virtualHosts != rhs.virtualHosts {return false}
    if lhs._vhds != rhs._vhds {return false}
    if lhs.internalOnlyHeaders != rhs.internalOnlyHeaders {return false}
    if lhs.responseHeadersToAdd != rhs.responseHeadersToAdd {return false}
    if lhs.responseHeadersToRemove != rhs.responseHeadersToRemove {return false}
    if lhs.requestHeadersToAdd != rhs.requestHeadersToAdd {return false}
    if lhs.requestHeadersToRemove != rhs.requestHeadersToRemove {return false}
    if lhs.mostSpecificHeaderMutationsWins != rhs.mostSpecificHeaderMutationsWins {return false}
    if lhs._validateClusters != rhs._validateClusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_Vhds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vhds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._configSource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._configSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_Vhds, rhs: Envoy_Config_Route_V3_Vhds) -> Bool {
    if lhs._configSource != rhs._configSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/route/v3/route_components.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The top level element in the routing configuration is a virtual host. Each virtual host has
/// a logical name as well as a set of domains that get routed to it based on the incoming request's
/// host header. This allows a single listener to service multiple top level domain path trees. Once
/// a virtual host is selected based on the domain, the routes are processed in order to see which
/// upstream cluster to route to or whether to perform a redirect.
/// [#next-free-field: 21]
public struct Envoy_Config_Route_V3_VirtualHost {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The logical name of the virtual host. This is used when emitting certain
  /// statistics but is not relevant for routing.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A list of domains (host/authority header) that will be matched to this
  /// virtual host. Wildcard hosts are supported in the suffix or prefix form.
  ///
  /// Domain search order:
  ///  1. Exact domain names: ``www.foo.com``.
  ///  2. Suffix domain wildcards: ``*.foo.com`` or ``*-bar.foo.com``.
  ///  3. Prefix domain wildcards: ``foo.*`` or ``foo-*``.
  ///  4. Special wildcard ``*`` matching any domain.
  ///
  /// .. note::
  ///
  ///   The wildcard will not match the empty string.
  ///   e.g. ``*-bar.foo.com`` will match ``baz-bar.foo.com`` but not ``-bar.foo.com``.
  ///   The longest wildcards match first.
  ///   Only a single virtual host in the entire route configuration can match on ``*``. A domain
  ///   must be unique across all virtual hosts or the config will fail to load.
  ///
  /// Domains cannot contain control characters. This is validated by the well_known_regex HTTP_HEADER_VALUE.
  public var domains: [String] {
    get {return _storage._domains}
    set {_uniqueStorage()._domains = newValue}
  }

  /// The list of routes that will be matched, in order, for incoming requests.
  /// The first route that matches will be used.
  public var routes: [Envoy_Config_Route_V3_Route] {
    get {return _storage._routes}
    set {_uniqueStorage()._routes = newValue}
  }

  /// Specifies the type of TLS enforcement the virtual host expects. If this option is not
  /// specified, there is no TLS requirement for the virtual host.
  public var requireTls: Envoy_Config_Route_V3_VirtualHost.TlsRequirementType {
    get {return _storage._requireTls}
    set {_uniqueStorage()._requireTls = newValue}
  }

  /// A list of virtual clusters defined for this virtual host. Virtual clusters
  /// are used for additional statistics gathering.
  public var virtualClusters: [Envoy_Config_Route_V3_VirtualCluster] {
    get {return _storage._virtualClusters}
    set {_uniqueStorage()._virtualClusters = newValue}
  }

  /// Specifies a set of rate limit configurations that will be applied to the
  /// virtual host.
  public var rateLimits: [Envoy_Config_Route_V3_RateLimit] {
    get {return _storage._rateLimits}
    set {_uniqueStorage()._rateLimits = newValue}
  }

  /// Specifies a list of HTTP headers that should be added to each request
  /// handled by this virtual host. Headers specified at this level are applied
  /// after headers from enclosed :ref:`envoy_api_msg_config.route.v3.Route` and before headers from the
  /// enclosing :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including
  /// details on header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var requestHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] {
    get {return _storage._requestHeadersToAdd}
    set {_uniqueStorage()._requestHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each request
  /// handled by this virtual host.
  public var requestHeadersToRemove: [String] {
    get {return _storage._requestHeadersToRemove}
    set {_uniqueStorage()._requestHeadersToRemove = newValue}
  }

  /// Specifies a list of HTTP headers that should be added to each response
  /// handled by this virtual host. Headers specified at this level are applied
  /// after headers from enclosed :ref:`envoy_api_msg_config.route.v3.Route` and before headers from the
  /// enclosing :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including
  /// details on header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var responseHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] {
    get {return _storage._responseHeadersToAdd}
    set {_uniqueStorage()._responseHeadersToAdd = newValue}
  }

  /// Specifies a list of HTTP headers that should be removed from each response
  /// handled by this virtual host.
  public var responseHeadersToRemove: [String] {
    get {return _storage._responseHeadersToRemove}
    set {_uniqueStorage()._responseHeadersToRemove = newValue}
  }

  /// Indicates that the virtual host has a CORS policy.
  public var cors: Envoy_Config_Route_V3_CorsPolicy {
    get {return _storage._cors ?? Envoy_Config_Route_V3_CorsPolicy()}
    set {_uniqueStorage()._cors = newValue}
  }
  /// Returns true if `cors` has been explicitly set.
  public var hasCors: Bool {return _storage._cors != nil}
  /// Clears the value of `cors`. Subsequent reads from it will return its default value.
  public mutating func clearCors() {_uniqueStorage()._cors = nil}

  /// The per_filter_config field can be used to provide virtual host-specific
  /// configurations for filters. The key should match the filter name, such as
  /// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
  /// specific; see the :ref:`HTTP filter documentation <config_http_filters>`
  /// for if and how it is utilized.
  public var typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> {
    get {return _storage._typedPerFilterConfig}
    set {_uniqueStorage()._typedPerFilterConfig = newValue}
  }

  /// Decides whether the :ref:`x-envoy-attempt-count
  /// <config_http_filters_router_x-envoy-attempt-count>` header should be included
  /// in the upstream request. Setting this option will cause it to override any existing header
  /// value, so in the case of two Envoys on the request path with this option enabled, the upstream
  /// will see the attempt count as perceived by the second Envoy. Defaults to false.
  /// This header is unaffected by the
  /// :ref:`suppress_envoy_headers
  /// <envoy_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
  ///
  /// [#next-major-version: rename to include_attempt_count_in_request.]
  public var includeRequestAttemptCount: Bool {
    get {return _storage._includeRequestAttemptCount}
    set {_uniqueStorage()._includeRequestAttemptCount = newValue}
  }

  /// Decides whether the :ref:`x-envoy-attempt-count
  /// <config_http_filters_router_x-envoy-attempt-count>` header should be included
  /// in the downstream response. Setting this option will cause the router to override any existing header
  /// value, so in the case of two Envoys on the request path with this option enabled, the downstream
  /// will see the attempt count as perceived by the Envoy closest upstream from itself. Defaults to false.
  /// This header is unaffected by the
  /// :ref:`suppress_envoy_headers
  /// <envoy_api_field_extensions.filters.http.router.v3.Router.suppress_envoy_headers>` flag.
  public var includeAttemptCountInResponse: Bool {
    get {return _storage._includeAttemptCountInResponse}
    set {_uniqueStorage()._includeAttemptCountInResponse = newValue}
  }

  /// Indicates the retry policy for all routes in this virtual host. Note that setting a
  /// route level entry will take precedence over this config and it'll be treated
  /// independently (e.g.: values are not inherited).
  public var retryPolicy: Envoy_Config_Route_V3_RetryPolicy {
    get {return _storage._retryPolicy ?? Envoy_Config_Route_V3_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  public var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// [#not-implemented-hide:]
  /// Specifies the configuration for retry policy extension. Note that setting a route level entry
  /// will take precedence over this config and it'll be treated independently (e.g.: values are not
  /// inherited). :ref:`Retry policy <envoy_api_field_config.route.v3.VirtualHost.retry_policy>` should not be
  /// set if this field is used.
  public var retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._retryPolicyTypedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._retryPolicyTypedConfig = newValue}
  }
  /// Returns true if `retryPolicyTypedConfig` has been explicitly set.
  public var hasRetryPolicyTypedConfig: Bool {return _storage._retryPolicyTypedConfig != nil}
  /// Clears the value of `retryPolicyTypedConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicyTypedConfig() {_uniqueStorage()._retryPolicyTypedConfig = nil}

  /// Indicates the hedge policy for all routes in this virtual host. Note that setting a
  /// route level entry will take precedence over this config and it'll be treated
  /// independently (e.g.: values are not inherited).
  public var hedgePolicy: Envoy_Config_Route_V3_HedgePolicy {
    get {return _storage._hedgePolicy ?? Envoy_Config_Route_V3_HedgePolicy()}
    set {_uniqueStorage()._hedgePolicy = newValue}
  }
  /// Returns true if `hedgePolicy` has been explicitly set.
  public var hasHedgePolicy: Bool {return _storage._hedgePolicy != nil}
  /// Clears the value of `hedgePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearHedgePolicy() {_uniqueStorage()._hedgePolicy = nil}

  /// The maximum bytes which will be buffered for retries and shadowing.
  /// If set and a route-specific limit is not set, the bytes actually buffered will be the minimum
  /// value of this and the listener per_connection_buffer_limit_bytes.
  public var perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._perRequestBufferLimitBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._perRequestBufferLimitBytes = newValue}
  }
  /// Returns true if `perRequestBufferLimitBytes` has been explicitly set.
  public var hasPerRequestBufferLimitBytes: Bool {return _storage._perRequestBufferLimitBytes != nil}
  /// Clears the value of `perRequestBufferLimitBytes`. Subsequent reads from it will return its default value.
  public mutating func clearPerRequestBufferLimitBytes() {_uniqueStorage()._perRequestBufferLimitBytes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TlsRequirementType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No TLS requirement for the virtual host.
    case none // = 0

    /// External requests must use TLS. If a request is external and it is not
    /// using TLS, a 301 redirect will be sent telling the client to use HTTPS.
    case externalOnly // = 1

    /// All requests must use TLS. If a request is not using TLS, a 301 redirect
    /// will be sent telling the client to use HTTPS.
    case all // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .externalOnly
      case 2: self = .all
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .externalOnly: return 1
      case .all: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Route_V3_VirtualHost.TlsRequirementType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V3_VirtualHost.TlsRequirementType] = [
    .none,
    .externalOnly,
    .all,
  ]
}

#endif  // swift(>=4.2)

/// A filter-defined action type.
public struct Envoy_Config_Route_V3_FilterAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: SwiftProtobuf.Google_Protobuf_Any {
    get {return _action ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// A route is both a specification of how to match a request as well as an indication of what to do
/// next (e.g., redirect, forward, rewrite, etc.).
///
/// .. attention::
///
///   Envoy supports routing on HTTP method via :ref:`header matching
///   <envoy_api_msg_config.route.v3.HeaderMatcher>`.
/// [#next-free-field: 18]
public struct Envoy_Config_Route_V3_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name for the route.
  public var name: String = String()

  /// Route matching parameters.
  public var match: Envoy_Config_Route_V3_RouteMatch {
    get {return _match ?? Envoy_Config_Route_V3_RouteMatch()}
    set {_match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return self._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {self._match = nil}

  public var action: Envoy_Config_Route_V3_Route.OneOf_Action? = nil

  /// Route request to some upstream cluster.
  public var route: Envoy_Config_Route_V3_RouteAction {
    get {
      if case .route(let v)? = action {return v}
      return Envoy_Config_Route_V3_RouteAction()
    }
    set {action = .route(newValue)}
  }

  /// Return a redirect.
  public var redirect: Envoy_Config_Route_V3_RedirectAction {
    get {
      if case .redirect(let v)? = action {return v}
      return Envoy_Config_Route_V3_RedirectAction()
    }
    set {action = .redirect(newValue)}
  }

  /// Return an arbitrary HTTP response directly, without proxying.
  public var directResponse: Envoy_Config_Route_V3_DirectResponseAction {
    get {
      if case .directResponse(let v)? = action {return v}
      return Envoy_Config_Route_V3_DirectResponseAction()
    }
    set {action = .directResponse(newValue)}
  }

  /// [#not-implemented-hide:]
  /// If true, a filter will define the action (e.g., it could dynamically generate the
  /// RouteAction).
  public var filterAction: Envoy_Config_Route_V3_FilterAction {
    get {
      if case .filterAction(let v)? = action {return v}
      return Envoy_Config_Route_V3_FilterAction()
    }
    set {action = .filterAction(newValue)}
  }

  /// The Metadata field can be used to provide additional information
  /// about the route. It can be used for configuration, stats, and logging.
  /// The metadata should go under the filter namespace that will need it.
  /// For instance, if the metadata is intended for the Router filter,
  /// the filter name should be specified as *envoy.filters.http.router*.
  public var metadata: Envoy_Config_Core_V3_Metadata {
    get {return _metadata ?? Envoy_Config_Core_V3_Metadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// Decorator for the matched route.
  public var decorator: Envoy_Config_Route_V3_Decorator {
    get {return _decorator ?? Envoy_Config_Route_V3_Decorator()}
    set {_decorator = newValue}
  }
  /// Returns true if `decorator` has been explicitly set.
  public var hasDecorator: Bool {return self._decorator != nil}
  /// Clears the value of `decorator`. Subsequent reads from it will return its default value.
  public mutating func clearDecorator() {self._decorator = nil}

  /// The typed_per_filter_config field can be used to provide route-specific
  /// configurations for filters. The key should match the filter name, such as
  /// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
  /// specific; see the :ref:`HTTP filter documentation <config_http_filters>` for
  /// if and how it is utilized.
  public var typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]

  /// Specifies a set of headers that will be added to requests matching this
  /// route. Headers specified at this level are applied before headers from the
  /// enclosing :ref:`envoy_api_msg_config.route.v3.VirtualHost` and
  /// :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
  /// header value syntax, see the documentation on :ref:`custom request headers
  /// <config_http_conn_man_headers_custom_request_headers>`.
  public var requestHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []

  /// Specifies a list of HTTP headers that should be removed from each request
  /// matching this route.
  public var requestHeadersToRemove: [String] = []

  /// Specifies a set of headers that will be added to responses to requests
  /// matching this route. Headers specified at this level are applied before
  /// headers from the enclosing :ref:`envoy_api_msg_config.route.v3.VirtualHost` and
  /// :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including
  /// details on header value syntax, see the documentation on
  /// :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
  public var responseHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []

  /// Specifies a list of HTTP headers that should be removed from each response
  /// to requests matching this route.
  public var responseHeadersToRemove: [String] = []

  /// Presence of the object defines whether the connection manager's tracing configuration
  /// is overridden by this route specific instance.
  public var tracing: Envoy_Config_Route_V3_Tracing {
    get {return _tracing ?? Envoy_Config_Route_V3_Tracing()}
    set {_tracing = newValue}
  }
  /// Returns true if `tracing` has been explicitly set.
  public var hasTracing: Bool {return self._tracing != nil}
  /// Clears the value of `tracing`. Subsequent reads from it will return its default value.
  public mutating func clearTracing() {self._tracing = nil}

  /// The maximum bytes which will be buffered for retries and shadowing.
  /// If set, the bytes actually buffered will be the minimum value of this and the
  /// listener per_connection_buffer_limit_bytes.
  public var perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _perRequestBufferLimitBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_perRequestBufferLimitBytes = newValue}
  }
  /// Returns true if `perRequestBufferLimitBytes` has been explicitly set.
  public var hasPerRequestBufferLimitBytes: Bool {return self._perRequestBufferLimitBytes != nil}
  /// Clears the value of `perRequestBufferLimitBytes`. Subsequent reads from it will return its default value.
  public mutating func clearPerRequestBufferLimitBytes() {self._perRequestBufferLimitBytes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Action: Equatable {
    /// Route request to some upstream cluster.
    case route(Envoy_Config_Route_V3_RouteAction)
    /// Return a redirect.
    case redirect(Envoy_Config_Route_V3_RedirectAction)
    /// Return an arbitrary HTTP response directly, without proxying.
    case directResponse(Envoy_Config_Route_V3_DirectResponseAction)
    /// [#not-implemented-hide:]
    /// If true, a filter will define the action (e.g., it could dynamically generate the
    /// RouteAction).
    case filterAction(Envoy_Config_Route_V3_FilterAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_Route.OneOf_Action, rhs: Envoy_Config_Route_V3_Route.OneOf_Action) -> Bool {
      switch (lhs, rhs) {
      case (.route(let l), .route(let r)): return l == r
      case (.redirect(let l), .redirect(let r)): return l == r
      case (.directResponse(let l), .directResponse(let r)): return l == r
      case (.filterAction(let l), .filterAction(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _match: Envoy_Config_Route_V3_RouteMatch? = nil
  fileprivate var _metadata: Envoy_Config_Core_V3_Metadata? = nil
  fileprivate var _decorator: Envoy_Config_Route_V3_Decorator? = nil
  fileprivate var _tracing: Envoy_Config_Route_V3_Tracing? = nil
  fileprivate var _perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// Compared to the :ref:`cluster <envoy_api_field_config.route.v3.RouteAction.cluster>` field that specifies a
/// single upstream cluster as the target of a request, the :ref:`weighted_clusters
/// <envoy_api_field_config.route.v3.RouteAction.weighted_clusters>` option allows for specification of
/// multiple upstream clusters along with weights that indicate the percentage of
/// traffic to be forwarded to each cluster. The router selects an upstream cluster based on the
/// weights.
public struct Envoy_Config_Route_V3_WeightedCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies one or more upstream clusters associated with the route.
  public var clusters: [Envoy_Config_Route_V3_WeightedCluster.ClusterWeight] = []

  /// Specifies the total weight across all clusters. The sum of all cluster weights must equal this
  /// value, which must be greater than 0. Defaults to 100.
  public var totalWeight: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _totalWeight ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_totalWeight = newValue}
  }
  /// Returns true if `totalWeight` has been explicitly set.
  public var hasTotalWeight: Bool {return self._totalWeight != nil}
  /// Clears the value of `totalWeight`. Subsequent reads from it will return its default value.
  public mutating func clearTotalWeight() {self._totalWeight = nil}

  /// Specifies the runtime key prefix that should be used to construct the
  /// runtime keys associated with each cluster. When the *runtime_key_prefix* is
  /// specified, the router will look for weights associated with each upstream
  /// cluster under the key *runtime_key_prefix* + "." + *cluster[i].name* where
  /// *cluster[i]* denotes an entry in the clusters array field. If the runtime
  /// key for the cluster does not exist, the value specified in the
  /// configuration file will be used as the default weight. See the :ref:`runtime documentation
  /// <operations_runtime>` for how key names map to the underlying implementation.
  public var runtimeKeyPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// [#next-free-field: 11]
  public struct ClusterWeight {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the upstream cluster. The cluster must exist in the
    /// :ref:`cluster manager configuration <config_cluster_manager>`.
    public var name: String = String()

    /// An integer between 0 and :ref:`total_weight
    /// <envoy_api_field_config.route.v3.WeightedCluster.total_weight>`. When a request matches the route,
    /// the choice of an upstream cluster is determined by its weight. The sum of weights across all
    /// entries in the clusters array must add up to the total_weight, which defaults to 100.
    public var weight: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _weight ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_weight = newValue}
    }
    /// Returns true if `weight` has been explicitly set.
    public var hasWeight: Bool {return self._weight != nil}
    /// Clears the value of `weight`. Subsequent reads from it will return its default value.
    public mutating func clearWeight() {self._weight = nil}

    /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    /// the upstream cluster with metadata matching what is set in this field will be considered for
    /// load balancing. Note that this will be merged with what's provided in
    /// :ref:`RouteAction.metadata_match <envoy_api_field_config.route.v3.RouteAction.metadata_match>`, with
    /// values here taking precedence. The filter name should be specified as *envoy.lb*.
    public var metadataMatch: Envoy_Config_Core_V3_Metadata {
      get {return _metadataMatch ?? Envoy_Config_Core_V3_Metadata()}
      set {_metadataMatch = newValue}
    }
    /// Returns true if `metadataMatch` has been explicitly set.
    public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
    /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
    public mutating func clearMetadataMatch() {self._metadataMatch = nil}

    /// Specifies a list of headers to be added to requests when this cluster is selected
    /// through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`.
    /// Headers specified at this level are applied before headers from the enclosing
    /// :ref:`envoy_api_msg_config.route.v3.Route`, :ref:`envoy_api_msg_config.route.v3.VirtualHost`, and
    /// :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// <config_http_conn_man_headers_custom_request_headers>`.
    public var requestHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []

    /// Specifies a list of HTTP headers that should be removed from each request when
    /// this cluster is selected through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`.
    public var requestHeadersToRemove: [String] = []

    /// Specifies a list of headers to be added to responses when this cluster is selected
    /// through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`.
    /// Headers specified at this level are applied before headers from the enclosing
    /// :ref:`envoy_api_msg_config.route.v3.Route`, :ref:`envoy_api_msg_config.route.v3.VirtualHost`, and
    /// :ref:`envoy_api_msg_config.route.v3.RouteConfiguration`. For more information, including details on
    /// header value syntax, see the documentation on :ref:`custom request headers
    /// <config_http_conn_man_headers_custom_request_headers>`.
    public var responseHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []

    /// Specifies a list of headers to be removed from responses when this cluster is selected
    /// through the enclosing :ref:`envoy_api_msg_config.route.v3.RouteAction`.
    public var responseHeadersToRemove: [String] = []

    /// The per_filter_config field can be used to provide weighted cluster-specific
    /// configurations for filters. The key should match the filter name, such as
    /// *envoy.filters.http.buffer* for the HTTP buffer filter. Use of this field is filter
    /// specific; see the :ref:`HTTP filter documentation <config_http_filters>`
    /// for if and how it is utilized.
    public var typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _weight: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _metadataMatch: Envoy_Config_Core_V3_Metadata? = nil
  }

  public init() {}

  fileprivate var _totalWeight: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#next-free-field: 13]
public struct Envoy_Config_Route_V3_RouteMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pathSpecifier: Envoy_Config_Route_V3_RouteMatch.OneOf_PathSpecifier? = nil

  /// If specified, the route is a prefix rule meaning that the prefix must
  /// match the beginning of the *:path* header.
  public var prefix: String {
    get {
      if case .prefix(let v)? = pathSpecifier {return v}
      return String()
    }
    set {pathSpecifier = .prefix(newValue)}
  }

  /// If specified, the route is an exact path rule meaning that the path must
  /// exactly match the *:path* header once the query string is removed.
  public var path: String {
    get {
      if case .path(let v)? = pathSpecifier {return v}
      return String()
    }
    set {pathSpecifier = .path(newValue)}
  }

  /// If specified, the route is a regular expression rule meaning that the
  /// regex must match the *:path* header once the query string is removed. The entire path
  /// (without the query string) must match the regex. The rule will not match if only a
  /// subsequence of the *:path* header matches the regex.
  ///
  /// [#next-major-version: In the v3 API we should redo how path specification works such
  /// that we utilize StringMatcher, and additionally have consistent options around whether we
  /// strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
  /// to deprecate the existing options. We should even consider whether we want to do away with
  /// path_specifier entirely and just rely on a set of header matchers which can already match
  /// on :path, etc. The issue with that is it is unclear how to generically deal with query string
  /// stripping. This needs more thought.]
  public var safeRegex: Envoy_Type_Matcher_V3_RegexMatcher {
    get {
      if case .safeRegex(let v)? = pathSpecifier {return v}
      return Envoy_Type_Matcher_V3_RegexMatcher()
    }
    set {pathSpecifier = .safeRegex(newValue)}
  }

  /// If this is used as the matcher, the matcher will only match CONNECT requests.
  /// Note that this will not match HTTP/2 upgrade-style CONNECT requests
  /// (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
  /// upgrades.
  /// This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
  /// where CONNECT requests may have a path, the path matchers will work if
  /// there is a path present.
  /// Note that CONNECT support is currently considered alpha in Envoy.
  /// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
  public var connectMatcher: Envoy_Config_Route_V3_RouteMatch.ConnectMatcher {
    get {
      if case .connectMatcher(let v)? = pathSpecifier {return v}
      return Envoy_Config_Route_V3_RouteMatch.ConnectMatcher()
    }
    set {pathSpecifier = .connectMatcher(newValue)}
  }

  /// Indicates that prefix/path matching should be case insensitive. The default
  /// is true.
  public var caseSensitive: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _caseSensitive ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_caseSensitive = newValue}
  }
  /// Returns true if `caseSensitive` has been explicitly set.
  public var hasCaseSensitive: Bool {return self._caseSensitive != nil}
  /// Clears the value of `caseSensitive`. Subsequent reads from it will return its default value.
  public mutating func clearCaseSensitive() {self._caseSensitive = nil}

  /// Indicates that the route should additionally match on a runtime key. Every time the route
  /// is considered for a match, it must also fall under the percentage of matches indicated by
  /// this field. For some fraction N/D, a random number in the range [0,D) is selected. If the
  /// number is <= the value of the numerator N, or if the key is not present, the default
  /// value, the router continues to evaluate the remaining match criteria. A runtime_fraction
  /// route configuration can be used to roll out route changes in a gradual manner without full
  /// code/config deploys. Refer to the :ref:`traffic shifting
  /// <config_http_conn_man_route_table_traffic_splitting_shift>` docs for additional documentation.
  ///
  /// .. note::
  ///
  ///    Parsing this field is implemented such that the runtime key's data may be represented
  ///    as a FractionalPercent proto represented as JSON/YAML and may also be represented as an
  ///    integer with the assumption that the value is an integral percentage out of 100. For
  ///    instance, a runtime key lookup returning the value "42" would parse as a FractionalPercent
  ///    whose numerator is 42 and denominator is HUNDRED. This preserves legacy semantics.
  public var runtimeFraction: Envoy_Config_Core_V3_RuntimeFractionalPercent {
    get {return _runtimeFraction ?? Envoy_Config_Core_V3_RuntimeFractionalPercent()}
    set {_runtimeFraction = newValue}
  }
  /// Returns true if `runtimeFraction` has been explicitly set.
  public var hasRuntimeFraction: Bool {return self._runtimeFraction != nil}
  /// Clears the value of `runtimeFraction`. Subsequent reads from it will return its default value.
  public mutating func clearRuntimeFraction() {self._runtimeFraction = nil}

  /// Specifies a set of headers that the route should match on. The router will
  /// check the requestâ€™s headers against all the specified headers in the route
  /// config. A match will happen if all the headers in the route are present in
  /// the request with the same values (or based on presence if the value field
  /// is not in the config).
  public var headers: [Envoy_Config_Route_V3_HeaderMatcher] = []

  /// Specifies a set of URL query parameters on which the route should
  /// match. The router will check the query string from the *path* header
  /// against all the specified query parameters. If the number of specified
  /// query parameters is nonzero, they all must match the *path* header's
  /// query string for a match to occur.
  public var queryParameters: [Envoy_Config_Route_V3_QueryParameterMatcher] = []

  /// If specified, only gRPC requests will be matched. The router will check
  /// that the content-type header has a application/grpc or one of the various
  /// application/grpc+ values.
  public var grpc: Envoy_Config_Route_V3_RouteMatch.GrpcRouteMatchOptions {
    get {return _grpc ?? Envoy_Config_Route_V3_RouteMatch.GrpcRouteMatchOptions()}
    set {_grpc = newValue}
  }
  /// Returns true if `grpc` has been explicitly set.
  public var hasGrpc: Bool {return self._grpc != nil}
  /// Clears the value of `grpc`. Subsequent reads from it will return its default value.
  public mutating func clearGrpc() {self._grpc = nil}

  /// If specified, the client tls context will be matched against the defined
  /// match options.
  ///
  /// [#next-major-version: unify with RBAC]
  public var tlsContext: Envoy_Config_Route_V3_RouteMatch.TlsContextMatchOptions {
    get {return _tlsContext ?? Envoy_Config_Route_V3_RouteMatch.TlsContextMatchOptions()}
    set {_tlsContext = newValue}
  }
  /// Returns true if `tlsContext` has been explicitly set.
  public var hasTlsContext: Bool {return self._tlsContext != nil}
  /// Clears the value of `tlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearTlsContext() {self._tlsContext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PathSpecifier: Equatable {
    /// If specified, the route is a prefix rule meaning that the prefix must
    /// match the beginning of the *:path* header.
    case prefix(String)
    /// If specified, the route is an exact path rule meaning that the path must
    /// exactly match the *:path* header once the query string is removed.
    case path(String)
    /// If specified, the route is a regular expression rule meaning that the
    /// regex must match the *:path* header once the query string is removed. The entire path
    /// (without the query string) must match the regex. The rule will not match if only a
    /// subsequence of the *:path* header matches the regex.
    ///
    /// [#next-major-version: In the v3 API we should redo how path specification works such
    /// that we utilize StringMatcher, and additionally have consistent options around whether we
    /// strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    /// to deprecate the existing options. We should even consider whether we want to do away with
    /// path_specifier entirely and just rely on a set of header matchers which can already match
    /// on :path, etc. The issue with that is it is unclear how to generically deal with query string
    /// stripping. This needs more thought.]
    case safeRegex(Envoy_Type_Matcher_V3_RegexMatcher)
    /// If this is used as the matcher, the matcher will only match CONNECT requests.
    /// Note that this will not match HTTP/2 upgrade-style CONNECT requests
    /// (WebSocket and the like) as they are normalized in Envoy as HTTP/1.1 style
    /// upgrades.
    /// This is the only way to match CONNECT requests for HTTP/1.1. For HTTP/2,
    /// where CONNECT requests may have a path, the path matchers will work if
    /// there is a path present.
    /// Note that CONNECT support is currently considered alpha in Envoy.
    /// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
    case connectMatcher(Envoy_Config_Route_V3_RouteMatch.ConnectMatcher)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_RouteMatch.OneOf_PathSpecifier, rhs: Envoy_Config_Route_V3_RouteMatch.OneOf_PathSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.prefix(let l), .prefix(let r)): return l == r
      case (.path(let l), .path(let r)): return l == r
      case (.safeRegex(let l), .safeRegex(let r)): return l == r
      case (.connectMatcher(let l), .connectMatcher(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public struct GrpcRouteMatchOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct TlsContextMatchOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If specified, the route will match against whether or not a certificate is presented.
    /// If not specified, certificate presentation status (true or false) will not be considered when route matching.
    public var presented: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _presented ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_presented = newValue}
    }
    /// Returns true if `presented` has been explicitly set.
    public var hasPresented: Bool {return self._presented != nil}
    /// Clears the value of `presented`. Subsequent reads from it will return its default value.
    public mutating func clearPresented() {self._presented = nil}

    /// If specified, the route will match against whether or not a certificate is validated.
    /// If not specified, certificate validation status (true or false) will not be considered when route matching.
    public var validated: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _validated ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_validated = newValue}
    }
    /// Returns true if `validated` has been explicitly set.
    public var hasValidated: Bool {return self._validated != nil}
    /// Clears the value of `validated`. Subsequent reads from it will return its default value.
    public mutating func clearValidated() {self._validated = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _presented: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _validated: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  /// An extensible message for matching CONNECT requests.
  public struct ConnectMatcher {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _caseSensitive: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _runtimeFraction: Envoy_Config_Core_V3_RuntimeFractionalPercent? = nil
  fileprivate var _grpc: Envoy_Config_Route_V3_RouteMatch.GrpcRouteMatchOptions? = nil
  fileprivate var _tlsContext: Envoy_Config_Route_V3_RouteMatch.TlsContextMatchOptions? = nil
}

/// [#next-free-field: 12]
public struct Envoy_Config_Route_V3_CorsPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies string patterns that match allowed origins. An origin is allowed if any of the
  /// string matchers match.
  public var allowOriginStringMatch: [Envoy_Type_Matcher_V3_StringMatcher] = []

  /// Specifies the content for the *access-control-allow-methods* header.
  public var allowMethods: String = String()

  /// Specifies the content for the *access-control-allow-headers* header.
  public var allowHeaders: String = String()

  /// Specifies the content for the *access-control-expose-headers* header.
  public var exposeHeaders: String = String()

  /// Specifies the content for the *access-control-max-age* header.
  public var maxAge: String = String()

  /// Specifies whether the resource allows credentials.
  public var allowCredentials: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _allowCredentials ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_allowCredentials = newValue}
  }
  /// Returns true if `allowCredentials` has been explicitly set.
  public var hasAllowCredentials: Bool {return self._allowCredentials != nil}
  /// Clears the value of `allowCredentials`. Subsequent reads from it will return its default value.
  public mutating func clearAllowCredentials() {self._allowCredentials = nil}

  public var enabledSpecifier: Envoy_Config_Route_V3_CorsPolicy.OneOf_EnabledSpecifier? = nil

  /// Specifies the % of requests for which the CORS filter is enabled.
  ///
  /// If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
  /// filter will be enabled for 100% of the requests.
  ///
  /// If :ref:`runtime_key <envoy_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
  /// specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
  public var filterEnabled: Envoy_Config_Core_V3_RuntimeFractionalPercent {
    get {
      if case .filterEnabled(let v)? = enabledSpecifier {return v}
      return Envoy_Config_Core_V3_RuntimeFractionalPercent()
    }
    set {enabledSpecifier = .filterEnabled(newValue)}
  }

  /// Specifies the % of requests for which the CORS policies will be evaluated and tracked, but not
  /// enforced.
  ///
  /// This field is intended to be used when ``filter_enabled`` and ``enabled`` are off. One of those
  /// fields have to explicitly disable the filter in order for this setting to take effect.
  ///
  /// If :ref:`runtime_key <envoy_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is specified,
  /// Envoy will lookup the runtime key to get the percentage of requests for which it will evaluate
  /// and track the request's *Origin* to determine if it's valid but will not enforce any policies.
  public var shadowEnabled: Envoy_Config_Core_V3_RuntimeFractionalPercent {
    get {return _shadowEnabled ?? Envoy_Config_Core_V3_RuntimeFractionalPercent()}
    set {_shadowEnabled = newValue}
  }
  /// Returns true if `shadowEnabled` has been explicitly set.
  public var hasShadowEnabled: Bool {return self._shadowEnabled != nil}
  /// Clears the value of `shadowEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearShadowEnabled() {self._shadowEnabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_EnabledSpecifier: Equatable {
    /// Specifies the % of requests for which the CORS filter is enabled.
    ///
    /// If neither ``enabled``, ``filter_enabled``, nor ``shadow_enabled`` are specified, the CORS
    /// filter will be enabled for 100% of the requests.
    ///
    /// If :ref:`runtime_key <envoy_api_field_config.core.v3.RuntimeFractionalPercent.runtime_key>` is
    /// specified, Envoy will lookup the runtime key to get the percentage of requests to filter.
    case filterEnabled(Envoy_Config_Core_V3_RuntimeFractionalPercent)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_CorsPolicy.OneOf_EnabledSpecifier, rhs: Envoy_Config_Route_V3_CorsPolicy.OneOf_EnabledSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.filterEnabled(let l), .filterEnabled(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _allowCredentials: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _shadowEnabled: Envoy_Config_Core_V3_RuntimeFractionalPercent? = nil
}

/// [#next-free-field: 35]
public struct Envoy_Config_Route_V3_RouteAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterSpecifier: OneOf_ClusterSpecifier? {
    get {return _storage._clusterSpecifier}
    set {_uniqueStorage()._clusterSpecifier = newValue}
  }

  /// Indicates the upstream cluster to which the request should be routed
  /// to.
  public var cluster: String {
    get {
      if case .cluster(let v)? = _storage._clusterSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._clusterSpecifier = .cluster(newValue)}
  }

  /// Envoy will determine the cluster to route to by reading the value of the
  /// HTTP header named by cluster_header from the request headers. If the
  /// header is not found or the referenced cluster does not exist, Envoy will
  /// return a 404 response.
  ///
  /// .. attention::
  ///
  ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
  ///   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
  public var clusterHeader: String {
    get {
      if case .clusterHeader(let v)? = _storage._clusterSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._clusterSpecifier = .clusterHeader(newValue)}
  }

  /// Multiple upstream clusters can be specified for a given route. The
  /// request is routed to one of the upstream clusters based on weights
  /// assigned to each cluster. See
  /// :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
  /// for additional documentation.
  public var weightedClusters: Envoy_Config_Route_V3_WeightedCluster {
    get {
      if case .weightedClusters(let v)? = _storage._clusterSpecifier {return v}
      return Envoy_Config_Route_V3_WeightedCluster()
    }
    set {_uniqueStorage()._clusterSpecifier = .weightedClusters(newValue)}
  }

  /// The HTTP status code to use when configured cluster is not found.
  /// The default response code is 503 Service Unavailable.
  public var clusterNotFoundResponseCode: Envoy_Config_Route_V3_RouteAction.ClusterNotFoundResponseCode {
    get {return _storage._clusterNotFoundResponseCode}
    set {_uniqueStorage()._clusterNotFoundResponseCode = newValue}
  }

  /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
  /// in the upstream cluster with metadata matching what's set in this field will be considered
  /// for load balancing. If using :ref:`weighted_clusters
  /// <envoy_api_field_config.route.v3.RouteAction.weighted_clusters>`, metadata will be merged, with values
  /// provided there taking precedence. The filter name should be specified as *envoy.lb*.
  public var metadataMatch: Envoy_Config_Core_V3_Metadata {
    get {return _storage._metadataMatch ?? Envoy_Config_Core_V3_Metadata()}
    set {_uniqueStorage()._metadataMatch = newValue}
  }
  /// Returns true if `metadataMatch` has been explicitly set.
  public var hasMetadataMatch: Bool {return _storage._metadataMatch != nil}
  /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataMatch() {_uniqueStorage()._metadataMatch = nil}

  /// Indicates that during forwarding, the matched prefix (or path) should be
  /// swapped with this value. This option allows application URLs to be rooted
  /// at a different path from those exposed at the reverse proxy layer. The router filter will
  /// place the original path before rewrite into the :ref:`x-envoy-original-path
  /// <config_http_filters_router_x-envoy-original-path>` header.
  ///
  /// Only one of *prefix_rewrite* or
  /// :ref:`regex_rewrite <envoy_api_field_config.route.v3.RouteAction.regex_rewrite>`
  /// may be specified.
  ///
  /// .. attention::
  ///
  ///   Pay careful attention to the use of trailing slashes in the
  ///   :ref:`route's match <envoy_api_field_config.route.v3.Route.match>` prefix value.
  ///   Stripping a prefix from a path requires multiple Routes to handle all cases. For example,
  ///   rewriting */prefix* to */* and */prefix/etc* to */etc* cannot be done in a single
  ///   :ref:`Route <envoy_api_msg_config.route.v3.Route>`, as shown by the below config entries:
  ///
  ///   .. code-block:: yaml
  ///
  ///     - match:
  ///         prefix: "/prefix/"
  ///       route:
  ///         prefix_rewrite: "/"
  ///     - match:
  ///         prefix: "/prefix"
  ///       route:
  ///         prefix_rewrite: "/"
  ///
  ///   Having above entries in the config, requests to */prefix* will be stripped to */*, while
  ///   requests to */prefix/etc* will be stripped to */etc*.
  public var prefixRewrite: String {
    get {return _storage._prefixRewrite}
    set {_uniqueStorage()._prefixRewrite = newValue}
  }

  /// Indicates that during forwarding, portions of the path that match the
  /// pattern should be rewritten, even allowing the substitution of capture
  /// groups from the pattern into the new path as specified by the rewrite
  /// substitution string. This is useful to allow application paths to be
  /// rewritten in a way that is aware of segments with variable content like
  /// identifiers. The router filter will place the original path as it was
  /// before the rewrite into the :ref:`x-envoy-original-path
  /// <config_http_filters_router_x-envoy-original-path>` header.
  ///
  /// Only one of :ref:`prefix_rewrite <envoy_api_field_config.route.v3.RouteAction.prefix_rewrite>`
  /// or *regex_rewrite* may be specified.
  ///
  /// Examples using Google's `RE2 <https://github.com/google/re2>`_ engine:
  ///
  /// * The path pattern ``^/service/([^/]+)(/.*)$`` paired with a substitution
  ///   string of ``\2/instance/\1`` would transform ``/service/foo/v1/api``
  ///   into ``/v1/api/instance/foo``.
  ///
  /// * The pattern ``one`` paired with a substitution string of ``two`` would
  ///   transform ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/two/zzz``.
  ///
  /// * The pattern ``^(.*?)one(.*)$`` paired with a substitution string of
  ///   ``\1two\2`` would replace only the first occurrence of ``one``,
  ///   transforming path ``/xxx/one/yyy/one/zzz`` into ``/xxx/two/yyy/one/zzz``.
  ///
  /// * The pattern ``(?i)/xxx/`` paired with a substitution string of ``/yyy/``
  ///   would do a case-insensitive match and transform path ``/aaa/XxX/bbb`` to
  ///   ``/aaa/yyy/bbb``.
  public var regexRewrite: Envoy_Type_Matcher_V3_RegexMatchAndSubstitute {
    get {return _storage._regexRewrite ?? Envoy_Type_Matcher_V3_RegexMatchAndSubstitute()}
    set {_uniqueStorage()._regexRewrite = newValue}
  }
  /// Returns true if `regexRewrite` has been explicitly set.
  public var hasRegexRewrite: Bool {return _storage._regexRewrite != nil}
  /// Clears the value of `regexRewrite`. Subsequent reads from it will return its default value.
  public mutating func clearRegexRewrite() {_uniqueStorage()._regexRewrite = nil}

  public var hostRewriteSpecifier: OneOf_HostRewriteSpecifier? {
    get {return _storage._hostRewriteSpecifier}
    set {_uniqueStorage()._hostRewriteSpecifier = newValue}
  }

  /// Indicates that during forwarding, the host header will be swapped with
  /// this value.
  public var hostRewriteLiteral: String {
    get {
      if case .hostRewriteLiteral(let v)? = _storage._hostRewriteSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .hostRewriteLiteral(newValue)}
  }

  /// Indicates that during forwarding, the host header will be swapped with
  /// the hostname of the upstream host chosen by the cluster manager. This
  /// option is applicable only when the destination cluster for a route is of
  /// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
  /// types has no effect.
  public var autoHostRewrite: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {
      if case .autoHostRewrite(let v)? = _storage._hostRewriteSpecifier {return v}
      return SwiftProtobuf.Google_Protobuf_BoolValue()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .autoHostRewrite(newValue)}
  }

  /// Indicates that during forwarding, the host header will be swapped with the content of given
  /// downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
  /// If header value is empty, host header is left intact.
  ///
  /// .. attention::
  ///
  ///   Pay attention to the potential security implications of using this option. Provided header
  ///   must come from trusted source.
  public var hostRewriteHeader: String {
    get {
      if case .hostRewriteHeader(let v)? = _storage._hostRewriteSpecifier {return v}
      return String()
    }
    set {_uniqueStorage()._hostRewriteSpecifier = .hostRewriteHeader(newValue)}
  }

  /// Specifies the upstream timeout for the route. If not specified, the default is 15s. This
  /// spans between the point at which the entire downstream request (i.e. end-of-stream) has been
  /// processed and when the upstream response has been completely processed. A value of 0 will
  /// disable the route's timeout.
  ///
  /// .. note::
  ///
  ///   This timeout includes all retries. See also
  ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
  ///   :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
  ///   :ref:`retry overview <arch_overview_http_routing_retry>`.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Specifies the idle timeout for the route. If not specified, there is no per-route idle timeout,
  /// although the connection manager wide :ref:`stream_idle_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.stream_idle_timeout>`
  /// will still apply. A value of 0 will completely disable the route's idle timeout, even if a
  /// connection manager stream idle timeout is configured.
  ///
  /// The idle timeout is distinct to :ref:`timeout
  /// <envoy_api_field_config.route.v3.RouteAction.timeout>`, which provides an upper bound
  /// on the upstream response time; :ref:`idle_timeout
  /// <envoy_api_field_config.route.v3.RouteAction.idle_timeout>` instead bounds the amount
  /// of time the request's stream may be idle.
  ///
  /// After header decoding, the idle timeout will apply on downstream and
  /// upstream request events. Each time an encode/decode event for headers or
  /// data is processed for the stream, the timer will be reset. If the timeout
  /// fires, the stream is terminated with a 408 Request Timeout error code if no
  /// upstream response header has been received, otherwise a stream reset
  /// occurs.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return _storage._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {_uniqueStorage()._idleTimeout = nil}

  /// Indicates that the route has a retry policy. Note that if this is set,
  /// it'll take precedence over the virtual host level retry policy entirely
  /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
  public var retryPolicy: Envoy_Config_Route_V3_RetryPolicy {
    get {return _storage._retryPolicy ?? Envoy_Config_Route_V3_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  public var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// [#not-implemented-hide:]
  /// Specifies the configuration for retry policy extension. Note that if this is set, it'll take
  /// precedence over the virtual host level retry policy entirely (e.g.: policies are not merged,
  /// most internal one becomes the enforced policy). :ref:`Retry policy <envoy_api_field_config.route.v3.VirtualHost.retry_policy>`
  /// should not be set if this field is used.
  public var retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._retryPolicyTypedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._retryPolicyTypedConfig = newValue}
  }
  /// Returns true if `retryPolicyTypedConfig` has been explicitly set.
  public var hasRetryPolicyTypedConfig: Bool {return _storage._retryPolicyTypedConfig != nil}
  /// Clears the value of `retryPolicyTypedConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPolicyTypedConfig() {_uniqueStorage()._retryPolicyTypedConfig = nil}

  /// Indicates that the route has request mirroring policies.
  public var requestMirrorPolicies: [Envoy_Config_Route_V3_RouteAction.RequestMirrorPolicy] {
    get {return _storage._requestMirrorPolicies}
    set {_uniqueStorage()._requestMirrorPolicies = newValue}
  }

  /// Optionally specifies the :ref:`routing priority <arch_overview_http_routing_priority>`.
  public var priority: Envoy_Config_Core_V3_RoutingPriority {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  /// Specifies a set of rate limit configurations that could be applied to the
  /// route.
  public var rateLimits: [Envoy_Config_Route_V3_RateLimit] {
    get {return _storage._rateLimits}
    set {_uniqueStorage()._rateLimits = newValue}
  }

  /// Specifies if the rate limit filter should include the virtual host rate
  /// limits. By default, if the route configured rate limits, the virtual host
  /// :ref:`rate_limits <envoy_api_field_config.route.v3.VirtualHost.rate_limits>` are not applied to the
  /// request.
  public var includeVhRateLimits: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._includeVhRateLimits ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._includeVhRateLimits = newValue}
  }
  /// Returns true if `includeVhRateLimits` has been explicitly set.
  public var hasIncludeVhRateLimits: Bool {return _storage._includeVhRateLimits != nil}
  /// Clears the value of `includeVhRateLimits`. Subsequent reads from it will return its default value.
  public mutating func clearIncludeVhRateLimits() {_uniqueStorage()._includeVhRateLimits = nil}

  /// Specifies a list of hash policies to use for ring hash load balancing. Each
  /// hash policy is evaluated individually and the combined result is used to
  /// route the request. The method of combination is deterministic such that
  /// identical lists of hash policies will produce the same hash. Since a hash
  /// policy examines specific parts of a request, it can fail to produce a hash
  /// (i.e. if the hashed header is not present). If (and only if) all configured
  /// hash policies fail to generate a hash, no hash will be produced for
  /// the route. In this case, the behavior is the same as if no hash policies
  /// were specified (i.e. the ring hash load balancer will choose a random
  /// backend). If a hash policy has the "terminal" attribute set to true, and
  /// there is already a hash generated, the hash is returned immediately,
  /// ignoring the rest of the hash policy list.
  public var hashPolicy: [Envoy_Config_Route_V3_RouteAction.HashPolicy] {
    get {return _storage._hashPolicy}
    set {_uniqueStorage()._hashPolicy = newValue}
  }

  /// Indicates that the route has a CORS policy.
  public var cors: Envoy_Config_Route_V3_CorsPolicy {
    get {return _storage._cors ?? Envoy_Config_Route_V3_CorsPolicy()}
    set {_uniqueStorage()._cors = newValue}
  }
  /// Returns true if `cors` has been explicitly set.
  public var hasCors: Bool {return _storage._cors != nil}
  /// Clears the value of `cors`. Subsequent reads from it will return its default value.
  public mutating func clearCors() {_uniqueStorage()._cors = nil}

  /// If present, and the request is a gRPC request, use the
  /// `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_,
  /// or its default value (infinity) instead of
  /// :ref:`timeout <envoy_api_field_config.route.v3.RouteAction.timeout>`, but limit the applied timeout
  /// to the maximum value specified here. If configured as 0, the maximum allowed timeout for
  /// gRPC requests is infinity. If not configured at all, the `grpc-timeout` header is not used
  /// and gRPC requests time out like any other requests using
  /// :ref:`timeout <envoy_api_field_config.route.v3.RouteAction.timeout>` or its default.
  /// This can be used to prevent unexpected upstream request timeouts due to potentially long
  /// time gaps between gRPC request and response in gRPC streaming mode.
  ///
  /// .. note::
  ///
  ///    If a timeout is specified using :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`, it takes
  ///    precedence over `grpc-timeout header <https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md>`_, when
  ///    both are present. See also
  ///    :ref:`config_http_filters_router_x-envoy-upstream-rq-timeout-ms`,
  ///    :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms`, and the
  ///    :ref:`retry overview <arch_overview_http_routing_retry>`.
  public var maxGrpcTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._maxGrpcTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._maxGrpcTimeout = newValue}
  }
  /// Returns true if `maxGrpcTimeout` has been explicitly set.
  public var hasMaxGrpcTimeout: Bool {return _storage._maxGrpcTimeout != nil}
  /// Clears the value of `maxGrpcTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearMaxGrpcTimeout() {_uniqueStorage()._maxGrpcTimeout = nil}

  /// If present, Envoy will adjust the timeout provided by the `grpc-timeout` header by subtracting
  /// the provided duration from the header. This is useful in allowing Envoy to set its global
  /// timeout to be less than that of the deadline imposed by the calling client, which makes it more
  /// likely that Envoy will handle the timeout instead of having the call canceled by the client.
  /// The offset will only be applied if the provided grpc_timeout is greater than the offset. This
  /// ensures that the offset will only ever decrease the timeout and never set it to 0 (meaning
  /// infinity).
  public var grpcTimeoutOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._grpcTimeoutOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._grpcTimeoutOffset = newValue}
  }
  /// Returns true if `grpcTimeoutOffset` has been explicitly set.
  public var hasGrpcTimeoutOffset: Bool {return _storage._grpcTimeoutOffset != nil}
  /// Clears the value of `grpcTimeoutOffset`. Subsequent reads from it will return its default value.
  public mutating func clearGrpcTimeoutOffset() {_uniqueStorage()._grpcTimeoutOffset = nil}

  public var upgradeConfigs: [Envoy_Config_Route_V3_RouteAction.UpgradeConfig] {
    get {return _storage._upgradeConfigs}
    set {_uniqueStorage()._upgradeConfigs = newValue}
  }

  /// If present, Envoy will try to follow an upstream redirect response instead of proxying the
  /// response back to the downstream. An upstream redirect response is defined
  /// by :ref:`redirect_response_codes
  /// <envoy_api_field_config.route.v3.InternalRedirectPolicy.redirect_response_codes>`.
  public var internalRedirectPolicy: Envoy_Config_Route_V3_InternalRedirectPolicy {
    get {return _storage._internalRedirectPolicy ?? Envoy_Config_Route_V3_InternalRedirectPolicy()}
    set {_uniqueStorage()._internalRedirectPolicy = newValue}
  }
  /// Returns true if `internalRedirectPolicy` has been explicitly set.
  public var hasInternalRedirectPolicy: Bool {return _storage._internalRedirectPolicy != nil}
  /// Clears the value of `internalRedirectPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearInternalRedirectPolicy() {_uniqueStorage()._internalRedirectPolicy = nil}

  public var internalRedirectAction: Envoy_Config_Route_V3_RouteAction.InternalRedirectAction {
    get {return _storage._internalRedirectAction}
    set {_uniqueStorage()._internalRedirectAction = newValue}
  }

  /// An internal redirect is handled, iff the number of previous internal redirects that a
  /// downstream request has encountered is lower than this value, and
  /// :ref:`internal_redirect_action <envoy_api_field_config.route.v3.RouteAction.internal_redirect_action>`
  /// is set to :ref:`HANDLE_INTERNAL_REDIRECT
  /// <envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.HANDLE_INTERNAL_REDIRECT>`
  /// In the case where a downstream request is bounced among multiple routes by internal redirect,
  /// the first route that hits this threshold, or has
  /// :ref:`internal_redirect_action <envoy_api_field_config.route.v3.RouteAction.internal_redirect_action>`
  /// set to
  /// :ref:`PASS_THROUGH_INTERNAL_REDIRECT
  /// <envoy_api_enum_value_config.route.v3.RouteAction.InternalRedirectAction.PASS_THROUGH_INTERNAL_REDIRECT>`
  /// will pass the redirect back to downstream.
  ///
  /// If not specified, at most one redirect will be followed.
  public var maxInternalRedirects: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxInternalRedirects ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxInternalRedirects = newValue}
  }
  /// Returns true if `maxInternalRedirects` has been explicitly set.
  public var hasMaxInternalRedirects: Bool {return _storage._maxInternalRedirects != nil}
  /// Clears the value of `maxInternalRedirects`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInternalRedirects() {_uniqueStorage()._maxInternalRedirects = nil}

  /// Indicates that the route has a hedge policy. Note that if this is set,
  /// it'll take precedence over the virtual host level hedge policy entirely
  /// (e.g.: policies are not merged, most internal one becomes the enforced policy).
  public var hedgePolicy: Envoy_Config_Route_V3_HedgePolicy {
    get {return _storage._hedgePolicy ?? Envoy_Config_Route_V3_HedgePolicy()}
    set {_uniqueStorage()._hedgePolicy = newValue}
  }
  /// Returns true if `hedgePolicy` has been explicitly set.
  public var hasHedgePolicy: Bool {return _storage._hedgePolicy != nil}
  /// Clears the value of `hedgePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearHedgePolicy() {_uniqueStorage()._hedgePolicy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterSpecifier: Equatable {
    /// Indicates the upstream cluster to which the request should be routed
    /// to.
    case cluster(String)
    /// Envoy will determine the cluster to route to by reading the value of the
    /// HTTP header named by cluster_header from the request headers. If the
    /// header is not found or the referenced cluster does not exist, Envoy will
    /// return a 404 response.
    ///
    /// .. attention::
    ///
    ///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1
    ///   *Host* header. Thus, if attempting to match on *Host*, match on *:authority* instead.
    case clusterHeader(String)
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster. See
    /// :ref:`traffic splitting <config_http_conn_man_route_table_traffic_splitting_split>`
    /// for additional documentation.
    case weightedClusters(Envoy_Config_Route_V3_WeightedCluster)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.OneOf_ClusterSpecifier, rhs: Envoy_Config_Route_V3_RouteAction.OneOf_ClusterSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.cluster(let l), .cluster(let r)): return l == r
      case (.clusterHeader(let l), .clusterHeader(let r)): return l == r
      case (.weightedClusters(let l), .weightedClusters(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_HostRewriteSpecifier: Equatable {
    /// Indicates that during forwarding, the host header will be swapped with
    /// this value.
    case hostRewriteLiteral(String)
    /// Indicates that during forwarding, the host header will be swapped with
    /// the hostname of the upstream host chosen by the cluster manager. This
    /// option is applicable only when the destination cluster for a route is of
    /// type *strict_dns* or *logical_dns*. Setting this to true with other cluster
    /// types has no effect.
    case autoHostRewrite(SwiftProtobuf.Google_Protobuf_BoolValue)
    /// Indicates that during forwarding, the host header will be swapped with the content of given
    /// downstream or :ref:`custom <config_http_conn_man_headers_custom_request_headers>` header.
    /// If header value is empty, host header is left intact.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the potential security implications of using this option. Provided header
    ///   must come from trusted source.
    case hostRewriteHeader(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.OneOf_HostRewriteSpecifier, rhs: Envoy_Config_Route_V3_RouteAction.OneOf_HostRewriteSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.hostRewriteLiteral(let l), .hostRewriteLiteral(let r)): return l == r
      case (.autoHostRewrite(let l), .autoHostRewrite(let r)): return l == r
      case (.hostRewriteHeader(let l), .hostRewriteHeader(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum ClusterNotFoundResponseCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// HTTP status code - 503 Service Unavailable.
    case serviceUnavailable // = 0

    /// HTTP status code - 404 Not Found.
    case notFound // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .serviceUnavailable
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .serviceUnavailable
      case 1: self = .notFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .serviceUnavailable: return 0
      case .notFound: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Configures :ref:`internal redirect <arch_overview_internal_redirects>` behavior.
  /// [#next-major-version: remove this definition - it's defined in the InternalRedirectPolicy message.]
  public enum InternalRedirectAction: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case passThroughInternalRedirect // = 0
    case handleInternalRedirect // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .passThroughInternalRedirect
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .passThroughInternalRedirect
      case 1: self = .handleInternalRedirect
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .passThroughInternalRedirect: return 0
      case .handleInternalRedirect: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The router is capable of shadowing traffic from one cluster to another. The current
  /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
  /// respond before returning the response from the primary cluster. All normal statistics are
  /// collected for the shadow cluster making this feature useful for testing.
  ///
  /// During shadowing, the host/authority header is altered such that *-shadow* is appended. This is
  /// useful for logging. For example, *cluster1* becomes *cluster1-shadow*.
  ///
  /// .. note::
  ///
  ///   Shadowing will not be triggered if the primary cluster does not exist.
  public struct RequestMirrorPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the cluster that requests will be mirrored to. The cluster must
    /// exist in the cluster manager configuration.
    public var cluster: String = String()

    /// If not specified, all requests to the target cluster will be mirrored.
    ///
    /// If specified, this field takes precedence over the `runtime_key` field and requests must also
    /// fall under the percentage of matches indicated by this field.
    ///
    /// For some fraction N/D, a random number in the range [0,D) is selected. If the
    /// number is <= the value of the numerator N, or if the key is not present, the default
    /// value, the request will be mirrored.
    public var runtimeFraction: Envoy_Config_Core_V3_RuntimeFractionalPercent {
      get {return _runtimeFraction ?? Envoy_Config_Core_V3_RuntimeFractionalPercent()}
      set {_runtimeFraction = newValue}
    }
    /// Returns true if `runtimeFraction` has been explicitly set.
    public var hasRuntimeFraction: Bool {return self._runtimeFraction != nil}
    /// Clears the value of `runtimeFraction`. Subsequent reads from it will return its default value.
    public mutating func clearRuntimeFraction() {self._runtimeFraction = nil}

    /// Determines if the trace span should be sampled. Defaults to true.
    public var traceSampled: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _traceSampled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_traceSampled = newValue}
    }
    /// Returns true if `traceSampled` has been explicitly set.
    public var hasTraceSampled: Bool {return self._traceSampled != nil}
    /// Clears the value of `traceSampled`. Subsequent reads from it will return its default value.
    public mutating func clearTraceSampled() {self._traceSampled = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _runtimeFraction: Envoy_Config_Core_V3_RuntimeFractionalPercent? = nil
    fileprivate var _traceSampled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  /// Specifies the route's hashing policy if the upstream cluster uses a hashing :ref:`load balancer
  /// <arch_overview_load_balancing_types>`.
  /// [#next-free-field: 7]
  public struct HashPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var policySpecifier: Envoy_Config_Route_V3_RouteAction.HashPolicy.OneOf_PolicySpecifier? = nil

    /// Header hash policy.
    public var header: Envoy_Config_Route_V3_RouteAction.HashPolicy.Header {
      get {
        if case .header(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V3_RouteAction.HashPolicy.Header()
      }
      set {policySpecifier = .header(newValue)}
    }

    /// Cookie hash policy.
    public var cookie: Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie {
      get {
        if case .cookie(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie()
      }
      set {policySpecifier = .cookie(newValue)}
    }

    /// Connection properties hash policy.
    public var connectionProperties: Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties {
      get {
        if case .connectionProperties(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties()
      }
      set {policySpecifier = .connectionProperties(newValue)}
    }

    /// Query parameter hash policy.
    public var queryParameter: Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter {
      get {
        if case .queryParameter(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter()
      }
      set {policySpecifier = .queryParameter(newValue)}
    }

    /// Filter state hash policy.
    public var filterState: Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState {
      get {
        if case .filterState(let v)? = policySpecifier {return v}
        return Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState()
      }
      set {policySpecifier = .filterState(newValue)}
    }

    /// The flag that short-circuits the hash computing. This field provides a
    /// 'fallback' style of configuration: "if a terminal policy doesn't work,
    /// fallback to rest of the policy list", it saves time when the terminal
    /// policy works.
    ///
    /// If true, and there is already a hash computed, ignore rest of the
    /// list of hash polices.
    /// For example, if the following hash methods are configured:
    ///
    ///  ========= ========
    ///  specifier terminal
    ///  ========= ========
    ///  Header A  true
    ///  Header B  false
    ///  Header C  false
    ///  ========= ========
    ///
    /// The generateHash process ends if policy "header A" generates a hash, as
    /// it's a terminal policy.
    public var terminal: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_PolicySpecifier: Equatable {
      /// Header hash policy.
      case header(Envoy_Config_Route_V3_RouteAction.HashPolicy.Header)
      /// Cookie hash policy.
      case cookie(Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie)
      /// Connection properties hash policy.
      case connectionProperties(Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties)
      /// Query parameter hash policy.
      case queryParameter(Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter)
      /// Filter state hash policy.
      case filterState(Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.OneOf_PolicySpecifier, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.OneOf_PolicySpecifier) -> Bool {
        switch (lhs, rhs) {
        case (.header(let l), .header(let r)): return l == r
        case (.cookie(let l), .cookie(let r)): return l == r
        case (.connectionProperties(let l), .connectionProperties(let r)): return l == r
        case (.queryParameter(let l), .queryParameter(let r)): return l == r
        case (.filterState(let l), .filterState(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    public struct Header {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the request header that will be used to obtain the hash
      /// key. If the request header is not present, no hash will be produced.
      public var headerName: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Envoy supports two types of cookie affinity:
    ///
    /// 1. Passive. Envoy takes a cookie that's present in the cookies header and
    ///    hashes on its value.
    ///
    /// 2. Generated. Envoy generates and sets a cookie with an expiration (TTL)
    ///    on the first request from the client in its response to the client,
    ///    based on the endpoint the request gets sent to. The client then
    ///    presents this on the next and all subsequent requests. The hash of
    ///    this is sufficient to ensure these requests get sent to the same
    ///    endpoint. The cookie is generated by hashing the source and
    ///    destination ports and addresses so that multiple independent HTTP2
    ///    streams on the same connection will independently receive the same
    ///    cookie, even if they arrive at the Envoy simultaneously.
    public struct Cookie {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the cookie that will be used to obtain the hash key. If the
      /// cookie is not present and ttl below is not set, no hash will be
      /// produced.
      public var name: String = String()

      /// If specified, a cookie with the TTL will be generated if the cookie is
      /// not present. If the TTL is present and zero, the generated cookie will
      /// be a session cookie.
      public var ttl: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_ttl = newValue}
      }
      /// Returns true if `ttl` has been explicitly set.
      public var hasTtl: Bool {return self._ttl != nil}
      /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
      public mutating func clearTtl() {self._ttl = nil}

      /// The name of the path for the cookie. If no path is specified here, no path
      /// will be set for the cookie.
      public var path: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
    }

    public struct ConnectionProperties {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Hash on source IP address.
      public var sourceIp: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct QueryParameter {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the URL query parameter that will be used to obtain the hash
      /// key. If the parameter is not present, no hash will be produced. Query
      /// parameter names are case-sensitive.
      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct FilterState {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the Object in the per-request filterState, which is an
      /// Envoy::Http::Hashable object. If there is no data associated with the key,
      /// or the stored object is not Envoy::Http::Hashable, no hash will be produced.
      public var key: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Allows enabling and disabling upgrades on a per-route basis.
  /// This overrides any enabled/disabled upgrade filter chain specified in the
  /// HttpConnectionManager
  /// :ref:`upgrade_configs
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.upgrade_configs>`
  /// but does not affect any custom filter chain specified there.
  public struct UpgradeConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The case-insensitive name of this upgrade, e.g. "websocket".
    /// For each upgrade type present in upgrade_configs, requests with
    /// Upgrade: [upgrade_type] will be proxied upstream.
    public var upgradeType: String = String()

    /// Determines if upgrades are available on this route. Defaults to true.
    public var enabled: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _enabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_enabled = newValue}
    }
    /// Returns true if `enabled` has been explicitly set.
    public var hasEnabled: Bool {return self._enabled != nil}
    /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
    public mutating func clearEnabled() {self._enabled = nil}

    /// Configuration for sending data upstream as a raw data payload. This is used for
    /// CONNECT requests, when forwarding CONNECT payload as raw TCP.
    /// Note that CONNECT support is currently considered alpha in Envoy.
    /// [#comment:TODO(htuch): Replace the above comment with an alpha tag.
    public var connectConfig: Envoy_Config_Route_V3_RouteAction.UpgradeConfig.ConnectConfig {
      get {return _connectConfig ?? Envoy_Config_Route_V3_RouteAction.UpgradeConfig.ConnectConfig()}
      set {_connectConfig = newValue}
    }
    /// Returns true if `connectConfig` has been explicitly set.
    public var hasConnectConfig: Bool {return self._connectConfig != nil}
    /// Clears the value of `connectConfig`. Subsequent reads from it will return its default value.
    public mutating func clearConnectConfig() {self._connectConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Configuration for sending data upstream as a raw data payload. This is used for
    /// CONNECT requests, when forwarding CONNECT payload as raw TCP.
    public struct ConnectConfig {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// If present, the proxy protocol header will be prepended to the CONNECT payload sent upstream.
      public var proxyProtocolConfig: Envoy_Config_Core_V3_ProxyProtocolConfig {
        get {return _proxyProtocolConfig ?? Envoy_Config_Core_V3_ProxyProtocolConfig()}
        set {_proxyProtocolConfig = newValue}
      }
      /// Returns true if `proxyProtocolConfig` has been explicitly set.
      public var hasProxyProtocolConfig: Bool {return self._proxyProtocolConfig != nil}
      /// Clears the value of `proxyProtocolConfig`. Subsequent reads from it will return its default value.
      public mutating func clearProxyProtocolConfig() {self._proxyProtocolConfig = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _proxyProtocolConfig: Envoy_Config_Core_V3_ProxyProtocolConfig? = nil
    }

    public init() {}

    fileprivate var _enabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _connectConfig: Envoy_Config_Route_V3_RouteAction.UpgradeConfig.ConnectConfig? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Route_V3_RouteAction.ClusterNotFoundResponseCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V3_RouteAction.ClusterNotFoundResponseCode] = [
    .serviceUnavailable,
    .notFound,
  ]
}

extension Envoy_Config_Route_V3_RouteAction.InternalRedirectAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V3_RouteAction.InternalRedirectAction] = [
    .passThroughInternalRedirect,
    .handleInternalRedirect,
  ]
}

#endif  // swift(>=4.2)

/// HTTP retry :ref:`architecture overview <arch_overview_http_routing_retry>`.
/// [#next-free-field: 11]
public struct Envoy_Config_Route_V3_RetryPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the conditions under which retry takes place. These are the same
  /// conditions documented for :ref:`config_http_filters_router_x-envoy-retry-on` and
  /// :ref:`config_http_filters_router_x-envoy-retry-grpc-on`.
  public var retryOn: String = String()

  /// Specifies the allowed number of retries. This parameter is optional and
  /// defaults to 1. These are the same conditions documented for
  /// :ref:`config_http_filters_router_x-envoy-max-retries`.
  public var numRetries: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _numRetries ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_numRetries = newValue}
  }
  /// Returns true if `numRetries` has been explicitly set.
  public var hasNumRetries: Bool {return self._numRetries != nil}
  /// Clears the value of `numRetries`. Subsequent reads from it will return its default value.
  public mutating func clearNumRetries() {self._numRetries = nil}

  /// Specifies a non-zero upstream timeout per retry attempt. This parameter is optional. The
  /// same conditions documented for
  /// :ref:`config_http_filters_router_x-envoy-upstream-rq-per-try-timeout-ms` apply.
  ///
  /// .. note::
  ///
  ///   If left unspecified, Envoy will use the global
  ///   :ref:`route timeout <envoy_api_field_config.route.v3.RouteAction.timeout>` for the request.
  ///   Consequently, when using a :ref:`5xx <config_http_filters_router_x-envoy-retry-on>` based
  ///   retry policy, a request that times out will not be retried as the total timeout budget
  ///   would have been exhausted.
  public var perTryTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _perTryTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_perTryTimeout = newValue}
  }
  /// Returns true if `perTryTimeout` has been explicitly set.
  public var hasPerTryTimeout: Bool {return self._perTryTimeout != nil}
  /// Clears the value of `perTryTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearPerTryTimeout() {self._perTryTimeout = nil}

  /// Specifies an implementation of a RetryPriority which is used to determine the
  /// distribution of load across priorities used for retries. Refer to
  /// :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more details.
  public var retryPriority: Envoy_Config_Route_V3_RetryPolicy.RetryPriority {
    get {return _retryPriority ?? Envoy_Config_Route_V3_RetryPolicy.RetryPriority()}
    set {_retryPriority = newValue}
  }
  /// Returns true if `retryPriority` has been explicitly set.
  public var hasRetryPriority: Bool {return self._retryPriority != nil}
  /// Clears the value of `retryPriority`. Subsequent reads from it will return its default value.
  public mutating func clearRetryPriority() {self._retryPriority = nil}

  /// Specifies a collection of RetryHostPredicates that will be consulted when selecting a host
  /// for retries. If any of the predicates reject the host, host selection will be reattempted.
  /// Refer to :ref:`retry plugin configuration <arch_overview_http_retry_plugins>` for more
  /// details.
  public var retryHostPredicate: [Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate] = []

  /// The maximum number of times host selection will be reattempted before giving up, at which
  /// point the host that was last selected will be routed to. If unspecified, this will default to
  /// retrying once.
  public var hostSelectionRetryMaxAttempts: Int64 = 0

  /// HTTP status codes that should trigger a retry in addition to those specified by retry_on.
  public var retriableStatusCodes: [UInt32] = []

  /// Specifies parameters that control retry back off. This parameter is optional, in which case the
  /// default base interval is 25 milliseconds or, if set, the current value of the
  /// `upstream.base_retry_backoff_ms` runtime parameter. The default maximum interval is 10 times
  /// the base interval. The documentation for :ref:`config_http_filters_router_x-envoy-max-retries`
  /// describes Envoy's back-off algorithm.
  public var retryBackOff: Envoy_Config_Route_V3_RetryPolicy.RetryBackOff {
    get {return _retryBackOff ?? Envoy_Config_Route_V3_RetryPolicy.RetryBackOff()}
    set {_retryBackOff = newValue}
  }
  /// Returns true if `retryBackOff` has been explicitly set.
  public var hasRetryBackOff: Bool {return self._retryBackOff != nil}
  /// Clears the value of `retryBackOff`. Subsequent reads from it will return its default value.
  public mutating func clearRetryBackOff() {self._retryBackOff = nil}

  /// HTTP response headers that trigger a retry if present in the response. A retry will be
  /// triggered if any of the header matches match the upstream response headers.
  /// The field is only consulted if 'retriable-headers' retry policy is active.
  public var retriableHeaders: [Envoy_Config_Route_V3_HeaderMatcher] = []

  /// HTTP headers which must be present in the request for retries to be attempted.
  public var retriableRequestHeaders: [Envoy_Config_Route_V3_HeaderMatcher] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct RetryPriority {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var configType: Envoy_Config_Route_V3_RetryPolicy.RetryPriority.OneOf_ConfigType? = nil

    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {
        if case .typedConfig(let v)? = configType {return v}
        return SwiftProtobuf.Google_Protobuf_Any()
      }
      set {configType = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ConfigType: Equatable {
      case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V3_RetryPolicy.RetryPriority.OneOf_ConfigType, rhs: Envoy_Config_Route_V3_RetryPolicy.RetryPriority.OneOf_ConfigType) -> Bool {
        switch (lhs, rhs) {
        case (.typedConfig(let l), .typedConfig(let r)): return l == r
        }
      }
    #endif
    }

    public init() {}
  }

  public struct RetryHostPredicate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var configType: Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate.OneOf_ConfigType? = nil

    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {
        if case .typedConfig(let v)? = configType {return v}
        return SwiftProtobuf.Google_Protobuf_Any()
      }
      set {configType = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ConfigType: Equatable {
      case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate.OneOf_ConfigType, rhs: Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate.OneOf_ConfigType) -> Bool {
        switch (lhs, rhs) {
        case (.typedConfig(let l), .typedConfig(let r)): return l == r
        }
      }
    #endif
    }

    public init() {}
  }

  public struct RetryBackOff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the base interval between retries. This parameter is required and must be greater
    /// than zero. Values less than 1 ms are rounded up to 1 ms.
    /// See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion of Envoy's
    /// back-off algorithm.
    public var baseInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _baseInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_baseInterval = newValue}
    }
    /// Returns true if `baseInterval` has been explicitly set.
    public var hasBaseInterval: Bool {return self._baseInterval != nil}
    /// Clears the value of `baseInterval`. Subsequent reads from it will return its default value.
    public mutating func clearBaseInterval() {self._baseInterval = nil}

    /// Specifies the maximum interval between retries. This parameter is optional, but must be
    /// greater than or equal to the `base_interval` if set. The default is 10 times the
    /// `base_interval`. See :ref:`config_http_filters_router_x-envoy-max-retries` for a discussion
    /// of Envoy's back-off algorithm.
    public var maxInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maxInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maxInterval = newValue}
    }
    /// Returns true if `maxInterval` has been explicitly set.
    public var hasMaxInterval: Bool {return self._maxInterval != nil}
    /// Clears the value of `maxInterval`. Subsequent reads from it will return its default value.
    public mutating func clearMaxInterval() {self._maxInterval = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _baseInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _maxInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _numRetries: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _perTryTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _retryPriority: Envoy_Config_Route_V3_RetryPolicy.RetryPriority? = nil
  fileprivate var _retryBackOff: Envoy_Config_Route_V3_RetryPolicy.RetryBackOff? = nil
}

/// HTTP request hedging :ref:`architecture overview <arch_overview_http_routing_hedging>`.
public struct Envoy_Config_Route_V3_HedgePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the number of initial requests that should be sent upstream.
  /// Must be at least 1.
  /// Defaults to 1.
  /// [#not-implemented-hide:]
  public var initialRequests: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _initialRequests ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_initialRequests = newValue}
  }
  /// Returns true if `initialRequests` has been explicitly set.
  public var hasInitialRequests: Bool {return self._initialRequests != nil}
  /// Clears the value of `initialRequests`. Subsequent reads from it will return its default value.
  public mutating func clearInitialRequests() {self._initialRequests = nil}

  /// Specifies a probability that an additional upstream request should be sent
  /// on top of what is specified by initial_requests.
  /// Defaults to 0.
  /// [#not-implemented-hide:]
  public var additionalRequestChance: Envoy_Type_V3_FractionalPercent {
    get {return _additionalRequestChance ?? Envoy_Type_V3_FractionalPercent()}
    set {_additionalRequestChance = newValue}
  }
  /// Returns true if `additionalRequestChance` has been explicitly set.
  public var hasAdditionalRequestChance: Bool {return self._additionalRequestChance != nil}
  /// Clears the value of `additionalRequestChance`. Subsequent reads from it will return its default value.
  public mutating func clearAdditionalRequestChance() {self._additionalRequestChance = nil}

  /// Indicates that a hedged request should be sent when the per-try timeout
  /// is hit. This will only occur if the retry policy also indicates that a
  /// timed out request should be retried.
  /// Once a timed out request is retried due to per try timeout, the router
  /// filter will ensure that it is not retried again even if the returned
  /// response headers would otherwise be retried according the specified
  /// :ref:`RetryPolicy <envoy_api_msg_config.route.v3.RetryPolicy>`.
  /// Defaults to false.
  public var hedgeOnPerTryTimeout: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _initialRequests: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _additionalRequestChance: Envoy_Type_V3_FractionalPercent? = nil
}

/// [#next-free-field: 9]
public struct Envoy_Config_Route_V3_RedirectAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When the scheme redirection take place, the following rules apply:
  ///  1. If the source URI scheme is `http` and the port is explicitly
  ///     set to `:80`, the port will be removed after the redirection
  ///  2. If the source URI scheme is `https` and the port is explicitly
  ///     set to `:443`, the port will be removed after the redirection
  public var schemeRewriteSpecifier: Envoy_Config_Route_V3_RedirectAction.OneOf_SchemeRewriteSpecifier? = nil

  /// The scheme portion of the URL will be swapped with "https".
  public var httpsRedirect: Bool {
    get {
      if case .httpsRedirect(let v)? = schemeRewriteSpecifier {return v}
      return false
    }
    set {schemeRewriteSpecifier = .httpsRedirect(newValue)}
  }

  /// The scheme portion of the URL will be swapped with this value.
  public var schemeRedirect: String {
    get {
      if case .schemeRedirect(let v)? = schemeRewriteSpecifier {return v}
      return String()
    }
    set {schemeRewriteSpecifier = .schemeRedirect(newValue)}
  }

  /// The host portion of the URL will be swapped with this value.
  public var hostRedirect: String = String()

  /// The port value of the URL will be swapped with this value.
  public var portRedirect: UInt32 = 0

  public var pathRewriteSpecifier: Envoy_Config_Route_V3_RedirectAction.OneOf_PathRewriteSpecifier? = nil

  /// The path portion of the URL will be swapped with this value.
  public var pathRedirect: String {
    get {
      if case .pathRedirect(let v)? = pathRewriteSpecifier {return v}
      return String()
    }
    set {pathRewriteSpecifier = .pathRedirect(newValue)}
  }

  /// Indicates that during redirection, the matched prefix (or path)
  /// should be swapped with this value. This option allows redirect URLs be dynamically created
  /// based on the request.
  ///
  /// .. attention::
  ///
  ///   Pay attention to the use of trailing slashes as mentioned in
  ///   :ref:`RouteAction's prefix_rewrite <envoy_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
  public var prefixRewrite: String {
    get {
      if case .prefixRewrite(let v)? = pathRewriteSpecifier {return v}
      return String()
    }
    set {pathRewriteSpecifier = .prefixRewrite(newValue)}
  }

  /// The HTTP status code to use in the redirect response. The default response
  /// code is MOVED_PERMANENTLY (301).
  public var responseCode: Envoy_Config_Route_V3_RedirectAction.RedirectResponseCode = .movedPermanently

  /// Indicates that during redirection, the query portion of the URL will
  /// be removed. Default value is false.
  public var stripQuery: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// When the scheme redirection take place, the following rules apply:
  ///  1. If the source URI scheme is `http` and the port is explicitly
  ///     set to `:80`, the port will be removed after the redirection
  ///  2. If the source URI scheme is `https` and the port is explicitly
  ///     set to `:443`, the port will be removed after the redirection
  public enum OneOf_SchemeRewriteSpecifier: Equatable {
    /// The scheme portion of the URL will be swapped with "https".
    case httpsRedirect(Bool)
    /// The scheme portion of the URL will be swapped with this value.
    case schemeRedirect(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_RedirectAction.OneOf_SchemeRewriteSpecifier, rhs: Envoy_Config_Route_V3_RedirectAction.OneOf_SchemeRewriteSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.httpsRedirect(let l), .httpsRedirect(let r)): return l == r
      case (.schemeRedirect(let l), .schemeRedirect(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum OneOf_PathRewriteSpecifier: Equatable {
    /// The path portion of the URL will be swapped with this value.
    case pathRedirect(String)
    /// Indicates that during redirection, the matched prefix (or path)
    /// should be swapped with this value. This option allows redirect URLs be dynamically created
    /// based on the request.
    ///
    /// .. attention::
    ///
    ///   Pay attention to the use of trailing slashes as mentioned in
    ///   :ref:`RouteAction's prefix_rewrite <envoy_api_field_config.route.v3.RouteAction.prefix_rewrite>`.
    case prefixRewrite(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_RedirectAction.OneOf_PathRewriteSpecifier, rhs: Envoy_Config_Route_V3_RedirectAction.OneOf_PathRewriteSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.pathRedirect(let l), .pathRedirect(let r)): return l == r
      case (.prefixRewrite(let l), .prefixRewrite(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum RedirectResponseCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Moved Permanently HTTP Status Code - 301.
    case movedPermanently // = 0

    /// Found HTTP Status Code - 302.
    case found // = 1

    /// See Other HTTP Status Code - 303.
    case seeOther // = 2

    /// Temporary Redirect HTTP Status Code - 307.
    case temporaryRedirect // = 3

    /// Permanent Redirect HTTP Status Code - 308.
    case permanentRedirect // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .movedPermanently
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .movedPermanently
      case 1: self = .found
      case 2: self = .seeOther
      case 3: self = .temporaryRedirect
      case 4: self = .permanentRedirect
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .movedPermanently: return 0
      case .found: return 1
      case .seeOther: return 2
      case .temporaryRedirect: return 3
      case .permanentRedirect: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Config_Route_V3_RedirectAction.RedirectResponseCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Route_V3_RedirectAction.RedirectResponseCode] = [
    .movedPermanently,
    .found,
    .seeOther,
    .temporaryRedirect,
    .permanentRedirect,
  ]
}

#endif  // swift(>=4.2)

public struct Envoy_Config_Route_V3_DirectResponseAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the HTTP response status to be returned.
  public var status: UInt32 = 0

  /// Specifies the content of the response body. If this setting is omitted,
  /// no body is included in the generated response.
  ///
  /// .. note::
  ///
  ///   Headers can be specified using *response_headers_to_add* in the enclosing
  ///   :ref:`envoy_api_msg_config.route.v3.Route`, :ref:`envoy_api_msg_config.route.v3.RouteConfiguration` or
  ///   :ref:`envoy_api_msg_config.route.v3.VirtualHost`.
  public var body: Envoy_Config_Core_V3_DataSource {
    get {return _body ?? Envoy_Config_Core_V3_DataSource()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  public var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  public mutating func clearBody() {self._body = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _body: Envoy_Config_Core_V3_DataSource? = nil
}

public struct Envoy_Config_Route_V3_Decorator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation name associated with the request matched to this route. If tracing is
  /// enabled, this information will be used as the span name reported for this request.
  ///
  /// .. note::
  ///
  ///   For ingress (inbound) requests, or egress (outbound) responses, this value may be overridden
  ///   by the :ref:`x-envoy-decorator-operation
  ///   <config_http_filters_router_x-envoy-decorator-operation>` header.
  public var operation: String = String()

  /// Whether the decorated details should be propagated to the other party. The default is true.
  public var propagate: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _propagate ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_propagate = newValue}
  }
  /// Returns true if `propagate` has been explicitly set.
  public var hasPropagate: Bool {return self._propagate != nil}
  /// Clears the value of `propagate`. Subsequent reads from it will return its default value.
  public mutating func clearPropagate() {self._propagate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _propagate: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

public struct Envoy_Config_Route_V3_Tracing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target percentage of requests managed by this HTTP connection manager that will be force
  /// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
  /// header is set. This field is a direct analog for the runtime variable
  /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
  /// <config_http_conn_man_runtime>`.
  /// Default: 100%
  public var clientSampling: Envoy_Type_V3_FractionalPercent {
    get {return _clientSampling ?? Envoy_Type_V3_FractionalPercent()}
    set {_clientSampling = newValue}
  }
  /// Returns true if `clientSampling` has been explicitly set.
  public var hasClientSampling: Bool {return self._clientSampling != nil}
  /// Clears the value of `clientSampling`. Subsequent reads from it will return its default value.
  public mutating func clearClientSampling() {self._clientSampling = nil}

  /// Target percentage of requests managed by this HTTP connection manager that will be randomly
  /// selected for trace generation, if not requested by the client or not forced. This field is
  /// a direct analog for the runtime variable 'tracing.random_sampling' in the
  /// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
  /// Default: 100%
  public var randomSampling: Envoy_Type_V3_FractionalPercent {
    get {return _randomSampling ?? Envoy_Type_V3_FractionalPercent()}
    set {_randomSampling = newValue}
  }
  /// Returns true if `randomSampling` has been explicitly set.
  public var hasRandomSampling: Bool {return self._randomSampling != nil}
  /// Clears the value of `randomSampling`. Subsequent reads from it will return its default value.
  public mutating func clearRandomSampling() {self._randomSampling = nil}

  /// Target percentage of requests managed by this HTTP connection manager that will be traced
  /// after all other sampling checks have been applied (client-directed, force tracing, random
  /// sampling). This field functions as an upper limit on the total configured sampling rate. For
  /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
  /// of client requests with the appropriate headers to be force traced. This field is a direct
  /// analog for the runtime variable 'tracing.global_enabled' in the
  /// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
  /// Default: 100%
  public var overallSampling: Envoy_Type_V3_FractionalPercent {
    get {return _overallSampling ?? Envoy_Type_V3_FractionalPercent()}
    set {_overallSampling = newValue}
  }
  /// Returns true if `overallSampling` has been explicitly set.
  public var hasOverallSampling: Bool {return self._overallSampling != nil}
  /// Clears the value of `overallSampling`. Subsequent reads from it will return its default value.
  public mutating func clearOverallSampling() {self._overallSampling = nil}

  /// A list of custom tags with unique tag name to create tags for the active span.
  /// It will take effect after merging with the :ref:`corresponding configuration
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.Tracing.custom_tags>`
  /// configured in the HTTP connection manager. If two tags with the same name are configured
  /// each in the HTTP connection manager and the route level, the one configured here takes
  /// priority.
  public var customTags: [Envoy_Type_Tracing_V3_CustomTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientSampling: Envoy_Type_V3_FractionalPercent? = nil
  fileprivate var _randomSampling: Envoy_Type_V3_FractionalPercent? = nil
  fileprivate var _overallSampling: Envoy_Type_V3_FractionalPercent? = nil
}

/// A virtual cluster is a way of specifying a regex matching rule against
/// certain important endpoints such that statistics are generated explicitly for
/// the matched requests. The reason this is useful is that when doing
/// prefix/path matching Envoy does not always know what the application
/// considers to be an endpoint. Thus, itâ€™s impossible for Envoy to generically
/// emit per endpoint statistics. However, often systems have highly critical
/// endpoints that they wish to get â€œperfectâ€ statistics on. Virtual cluster
/// statistics are perfect in the sense that they are emitted on the downstream
/// side such that they include network level failures.
///
/// Documentation for :ref:`virtual cluster statistics <config_http_filters_router_vcluster_stats>`.
///
/// .. note::
///
///    Virtual clusters are a useful tool, but we do not recommend setting up a virtual cluster for
///    every application endpoint. This is both not easily maintainable and as well the matching and
///    statistics output are not free.
public struct Envoy_Config_Route_V3_VirtualCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies a list of header matchers to use for matching requests. Each specified header must
  /// match. The pseudo-headers `:path` and `:method` can be used to match the request path and
  /// method, respectively.
  public var headers: [Envoy_Config_Route_V3_HeaderMatcher] = []

  /// Specifies the name of the virtual cluster. The virtual cluster name as well
  /// as the virtual host name are used when emitting statistics. The statistics are emitted by the
  /// router filter and are documented :ref:`here <config_http_filters_router_stats>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Global rate limiting :ref:`architecture overview <arch_overview_global_rate_limit>`.
public struct Envoy_Config_Route_V3_RateLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Refers to the stage set in the filter. The rate limit configuration only
  /// applies to filters with the same stage number. The default stage number is
  /// 0.
  ///
  /// .. note::
  ///
  ///   The filter supports a range of 0 - 10 inclusively for stage numbers.
  public var stage: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _stage ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_stage = newValue}
  }
  /// Returns true if `stage` has been explicitly set.
  public var hasStage: Bool {return self._stage != nil}
  /// Clears the value of `stage`. Subsequent reads from it will return its default value.
  public mutating func clearStage() {self._stage = nil}

  /// The key to be set in runtime to disable this rate limit configuration.
  public var disableKey: String = String()

  /// A list of actions that are to be applied for this rate limit configuration.
  /// Order matters as the actions are processed sequentially and the descriptor
  /// is composed by appending descriptor entries in that sequence. If an action
  /// cannot append a descriptor entry, no descriptor is generated for the
  /// configuration. See :ref:`composing actions
  /// <config_http_filters_rate_limit_composing_actions>` for additional documentation.
  public var actions: [Envoy_Config_Route_V3_RateLimit.Action] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// [#next-free-field: 7]
  public struct Action {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var actionSpecifier: Envoy_Config_Route_V3_RateLimit.Action.OneOf_ActionSpecifier? = nil

    /// Rate limit on source cluster.
    public var sourceCluster: Envoy_Config_Route_V3_RateLimit.Action.SourceCluster {
      get {
        if case .sourceCluster(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V3_RateLimit.Action.SourceCluster()
      }
      set {actionSpecifier = .sourceCluster(newValue)}
    }

    /// Rate limit on destination cluster.
    public var destinationCluster: Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster {
      get {
        if case .destinationCluster(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster()
      }
      set {actionSpecifier = .destinationCluster(newValue)}
    }

    /// Rate limit on request headers.
    public var requestHeaders: Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders {
      get {
        if case .requestHeaders(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders()
      }
      set {actionSpecifier = .requestHeaders(newValue)}
    }

    /// Rate limit on remote address.
    public var remoteAddress: Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress {
      get {
        if case .remoteAddress(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress()
      }
      set {actionSpecifier = .remoteAddress(newValue)}
    }

    /// Rate limit on a generic key.
    public var genericKey: Envoy_Config_Route_V3_RateLimit.Action.GenericKey {
      get {
        if case .genericKey(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V3_RateLimit.Action.GenericKey()
      }
      set {actionSpecifier = .genericKey(newValue)}
    }

    /// Rate limit on the existence of request headers.
    public var headerValueMatch: Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch {
      get {
        if case .headerValueMatch(let v)? = actionSpecifier {return v}
        return Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch()
      }
      set {actionSpecifier = .headerValueMatch(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ActionSpecifier: Equatable {
      /// Rate limit on source cluster.
      case sourceCluster(Envoy_Config_Route_V3_RateLimit.Action.SourceCluster)
      /// Rate limit on destination cluster.
      case destinationCluster(Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster)
      /// Rate limit on request headers.
      case requestHeaders(Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders)
      /// Rate limit on remote address.
      case remoteAddress(Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress)
      /// Rate limit on a generic key.
      case genericKey(Envoy_Config_Route_V3_RateLimit.Action.GenericKey)
      /// Rate limit on the existence of request headers.
      case headerValueMatch(Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.OneOf_ActionSpecifier, rhs: Envoy_Config_Route_V3_RateLimit.Action.OneOf_ActionSpecifier) -> Bool {
        switch (lhs, rhs) {
        case (.sourceCluster(let l), .sourceCluster(let r)): return l == r
        case (.destinationCluster(let l), .destinationCluster(let r)): return l == r
        case (.requestHeaders(let l), .requestHeaders(let r)): return l == r
        case (.remoteAddress(let l), .remoteAddress(let r)): return l == r
        case (.genericKey(let l), .genericKey(let r)): return l == r
        case (.headerValueMatch(let l), .headerValueMatch(let r)): return l == r
        default: return false
        }
      }
    #endif
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("source_cluster", "<local service cluster>")
    ///
    /// <local service cluster> is derived from the :option:`--service-cluster` option.
    public struct SourceCluster {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("destination_cluster", "<routed target cluster>")
    ///
    /// Once a request matches against a route table rule, a routed cluster is determined by one of
    /// the following :ref:`route table configuration <envoy_api_msg_config.route.v3.RouteConfiguration>`
    /// settings:
    ///
    /// * :ref:`cluster <envoy_api_field_config.route.v3.RouteAction.cluster>` indicates the upstream cluster
    ///   to route to.
    /// * :ref:`weighted_clusters <envoy_api_field_config.route.v3.RouteAction.weighted_clusters>`
    ///   chooses a cluster randomly from a set of clusters with attributed weight.
    /// * :ref:`cluster_header <envoy_api_field_config.route.v3.RouteAction.cluster_header>` indicates which
    ///   header in the request contains the target cluster.
    public struct DestinationCluster {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended when a header contains a key that matches the
    /// *header_name*:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("<descriptor_key>", "<header_value_queried_from_header>")
    public struct RequestHeaders {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The header name to be queried from the request headers. The headerâ€™s
      /// value is used to populate the value of the descriptor entry for the
      /// descriptor_key.
      public var headerName: String = String()

      /// The key to use in the descriptor entry.
      public var descriptorKey: String = String()

      /// If set to true, Envoy skips the descriptor while calling rate limiting service
      /// when header is not present in the request. By default it skips calling the
      /// rate limiting service if this header is not present in the request.
      public var skipIfAbsent: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor and is populated using the
    /// trusted address from :ref:`x-forwarded-for <config_http_conn_man_headers_x-forwarded-for>`:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("remote_address", "<trusted address from x-forwarded-for>")
    public struct RemoteAddress {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("generic_key", "<descriptor_value>")
    public struct GenericKey {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The value to use in the descriptor entry.
      public var descriptorValue: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// The following descriptor entry is appended to the descriptor:
    ///
    /// .. code-block:: cpp
    ///
    ///   ("header_match", "<descriptor_value>")
    public struct HeaderValueMatch {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The value to use in the descriptor entry.
      public var descriptorValue: String = String()

      /// If set to true, the action will append a descriptor entry when the
      /// request matches the headers. If set to false, the action will append a
      /// descriptor entry when the request does not match the headers. The
      /// default value is true.
      public var expectMatch: SwiftProtobuf.Google_Protobuf_BoolValue {
        get {return _expectMatch ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
        set {_expectMatch = newValue}
      }
      /// Returns true if `expectMatch` has been explicitly set.
      public var hasExpectMatch: Bool {return self._expectMatch != nil}
      /// Clears the value of `expectMatch`. Subsequent reads from it will return its default value.
      public mutating func clearExpectMatch() {self._expectMatch = nil}

      /// Specifies a set of headers that the rate limit action should match
      /// on. The action will check the requestâ€™s headers against all the
      /// specified headers in the config. A match will happen if all the
      /// headers in the config are present in the request with the same values
      /// (or based on presence if the value field is not in the config).
      public var headers: [Envoy_Config_Route_V3_HeaderMatcher] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _expectMatch: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _stage: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// .. attention::
///
///   Internally, Envoy always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
///   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
///
/// .. attention::
///
///   To route on HTTP method, use the special HTTP/2 *:method* header. This works for both
///   HTTP/1 and HTTP/2 as Envoy normalizes headers. E.g.,
///
///   .. code-block:: json
///
///     {
///       "name": ":method",
///       "exact_match": "POST"
///     }
///
/// .. attention::
///   In the absence of any header match specifier, match will default to :ref:`present_match
///   <envoy_api_field_config.route.v3.HeaderMatcher.present_match>`. i.e, a request that has the :ref:`name
///   <envoy_api_field_config.route.v3.HeaderMatcher.name>` header will match, regardless of the header's
///   value.
///
///  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
/// [#next-free-field: 12]
public struct Envoy_Config_Route_V3_HeaderMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the name of the header in the request.
  public var name: String = String()

  /// Specifies how the header match will be performed to route the request.
  public var headerMatchSpecifier: Envoy_Config_Route_V3_HeaderMatcher.OneOf_HeaderMatchSpecifier? = nil

  /// If specified, header match will be performed based on the value of the header.
  public var exactMatch: String {
    get {
      if case .exactMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .exactMatch(newValue)}
  }

  /// If specified, this regex string is a regular expression rule which implies the entire request
  /// header value must match the regex. The rule will not match if only a subsequence of the
  /// request header value matches the regex.
  public var safeRegexMatch: Envoy_Type_Matcher_V3_RegexMatcher {
    get {
      if case .safeRegexMatch(let v)? = headerMatchSpecifier {return v}
      return Envoy_Type_Matcher_V3_RegexMatcher()
    }
    set {headerMatchSpecifier = .safeRegexMatch(newValue)}
  }

  /// If specified, header match will be performed based on range.
  /// The rule will match if the request header value is within this range.
  /// The entire request header value must represent an integer in base 10 notation: consisting of
  /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
  /// the header value does not represent an integer. Match will fail for empty values, floating
  /// point numbers or if only a subsequence of the header value is an integer.
  ///
  /// Examples:
  ///
  /// * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
  ///   "-1somestring"
  public var rangeMatch: Envoy_Type_V3_Int64Range {
    get {
      if case .rangeMatch(let v)? = headerMatchSpecifier {return v}
      return Envoy_Type_V3_Int64Range()
    }
    set {headerMatchSpecifier = .rangeMatch(newValue)}
  }

  /// If specified, header match will be performed based on whether the header is in the
  /// request.
  public var presentMatch: Bool {
    get {
      if case .presentMatch(let v)? = headerMatchSpecifier {return v}
      return false
    }
    set {headerMatchSpecifier = .presentMatch(newValue)}
  }

  /// If specified, header match will be performed based on the prefix of the header value.
  /// Note: empty prefix is not allowed, please use present_match instead.
  ///
  /// Examples:
  ///
  /// * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
  public var prefixMatch: String {
    get {
      if case .prefixMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .prefixMatch(newValue)}
  }

  /// If specified, header match will be performed based on the suffix of the header value.
  /// Note: empty suffix is not allowed, please use present_match instead.
  ///
  /// Examples:
  ///
  /// * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
  public var suffixMatch: String {
    get {
      if case .suffixMatch(let v)? = headerMatchSpecifier {return v}
      return String()
    }
    set {headerMatchSpecifier = .suffixMatch(newValue)}
  }

  /// If specified, the match result will be inverted before checking. Defaults to false.
  ///
  /// Examples:
  ///
  /// * The regex ``\d{3}`` does not match the value *1234*, so it will match when inverted.
  /// * The range [-10,0) will match the value -1, so it will not match when inverted.
  public var invertMatch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies how the header match will be performed to route the request.
  public enum OneOf_HeaderMatchSpecifier: Equatable {
    /// If specified, header match will be performed based on the value of the header.
    case exactMatch(String)
    /// If specified, this regex string is a regular expression rule which implies the entire request
    /// header value must match the regex. The rule will not match if only a subsequence of the
    /// request header value matches the regex.
    case safeRegexMatch(Envoy_Type_Matcher_V3_RegexMatcher)
    /// If specified, header match will be performed based on range.
    /// The rule will match if the request header value is within this range.
    /// The entire request header value must represent an integer in base 10 notation: consisting of
    /// an optional plus or minus sign followed by a sequence of digits. The rule will not match if
    /// the header value does not represent an integer. Match will fail for empty values, floating
    /// point numbers or if only a subsequence of the header value is an integer.
    ///
    /// Examples:
    ///
    /// * For range [-10,0), route will match for header value -1, but not for 0, "somestring", 10.9,
    ///   "-1somestring"
    case rangeMatch(Envoy_Type_V3_Int64Range)
    /// If specified, header match will be performed based on whether the header is in the
    /// request.
    case presentMatch(Bool)
    /// If specified, header match will be performed based on the prefix of the header value.
    /// Note: empty prefix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The prefix *abcd* matches the value *abcdxyz*, but not for *abcxyz*.
    case prefixMatch(String)
    /// If specified, header match will be performed based on the suffix of the header value.
    /// Note: empty suffix is not allowed, please use present_match instead.
    ///
    /// Examples:
    ///
    /// * The suffix *abcd* matches the value *xyzabcd*, but not for *xyzbcd*.
    case suffixMatch(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_HeaderMatcher.OneOf_HeaderMatchSpecifier, rhs: Envoy_Config_Route_V3_HeaderMatcher.OneOf_HeaderMatchSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.exactMatch(let l), .exactMatch(let r)): return l == r
      case (.safeRegexMatch(let l), .safeRegexMatch(let r)): return l == r
      case (.rangeMatch(let l), .rangeMatch(let r)): return l == r
      case (.presentMatch(let l), .presentMatch(let r)): return l == r
      case (.prefixMatch(let l), .prefixMatch(let r)): return l == r
      case (.suffixMatch(let l), .suffixMatch(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Query parameter matching treats the query string of a request's :path header
/// as an ampersand-separated list of keys and/or key=value elements.
/// [#next-free-field: 7]
public struct Envoy_Config_Route_V3_QueryParameterMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the name of a key that must be present in the requested
  /// *path*'s query string.
  public var name: String = String()

  public var queryParameterMatchSpecifier: Envoy_Config_Route_V3_QueryParameterMatcher.OneOf_QueryParameterMatchSpecifier? = nil

  /// Specifies whether a query parameter value should match against a string.
  public var stringMatch: Envoy_Type_Matcher_V3_StringMatcher {
    get {
      if case .stringMatch(let v)? = queryParameterMatchSpecifier {return v}
      return Envoy_Type_Matcher_V3_StringMatcher()
    }
    set {queryParameterMatchSpecifier = .stringMatch(newValue)}
  }

  /// Specifies whether a query parameter should be present.
  public var presentMatch: Bool {
    get {
      if case .presentMatch(let v)? = queryParameterMatchSpecifier {return v}
      return false
    }
    set {queryParameterMatchSpecifier = .presentMatch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_QueryParameterMatchSpecifier: Equatable {
    /// Specifies whether a query parameter value should match against a string.
    case stringMatch(Envoy_Type_Matcher_V3_StringMatcher)
    /// Specifies whether a query parameter should be present.
    case presentMatch(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Route_V3_QueryParameterMatcher.OneOf_QueryParameterMatchSpecifier, rhs: Envoy_Config_Route_V3_QueryParameterMatcher.OneOf_QueryParameterMatchSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.stringMatch(let l), .stringMatch(let r)): return l == r
      case (.presentMatch(let l), .presentMatch(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// HTTP Internal Redirect :ref:`architecture overview <arch_overview_internal_redirects>`.
public struct Envoy_Config_Route_V3_InternalRedirectPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An internal redirect is not handled, unless the number of previous internal redirects that a
  /// downstream request has encountered is lower than this value.
  /// In the case where a downstream request is bounced among multiple routes by internal redirect,
  /// the first route that hits this threshold, or does not set :ref:`internal_redirect_policy
  /// <envoy_api_field_config.route.v3.RouteAction.internal_redirect_policy>`
  /// will pass the redirect back to downstream.
  ///
  /// If not specified, at most one redirect will be followed.
  public var maxInternalRedirects: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxInternalRedirects ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxInternalRedirects = newValue}
  }
  /// Returns true if `maxInternalRedirects` has been explicitly set.
  public var hasMaxInternalRedirects: Bool {return self._maxInternalRedirects != nil}
  /// Clears the value of `maxInternalRedirects`. Subsequent reads from it will return its default value.
  public mutating func clearMaxInternalRedirects() {self._maxInternalRedirects = nil}

  /// Defines what upstream response codes are allowed to trigger internal redirect. If unspecified,
  /// only 302 will be treated as internal redirect.
  /// Only 301, 302, 303, 307 and 308 are valid values. Any other codes will be ignored.
  public var redirectResponseCodes: [UInt32] = []

  /// Specifies a list of predicates that are queried when an upstream response is deemed
  /// to trigger an internal redirect by all other criteria. Any predicate in the list can reject
  /// the redirect, causing the response to be proxied to downstream.
  public var predicates: [Envoy_Config_Core_V3_TypedExtensionConfig] = []

  /// Allow internal redirect to follow a target URI with a different scheme than the value of
  /// x-forwarded-proto. The default is false.
  public var allowCrossSchemeRedirect: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxInternalRedirects: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.route.v3"

extension Envoy_Config_Route_V3_VirtualHost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VirtualHost"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "domains"),
    3: .same(proto: "routes"),
    4: .standard(proto: "require_tls"),
    5: .standard(proto: "virtual_clusters"),
    6: .standard(proto: "rate_limits"),
    7: .standard(proto: "request_headers_to_add"),
    13: .standard(proto: "request_headers_to_remove"),
    10: .standard(proto: "response_headers_to_add"),
    11: .standard(proto: "response_headers_to_remove"),
    8: .same(proto: "cors"),
    15: .standard(proto: "typed_per_filter_config"),
    14: .standard(proto: "include_request_attempt_count"),
    19: .standard(proto: "include_attempt_count_in_response"),
    16: .standard(proto: "retry_policy"),
    20: .standard(proto: "retry_policy_typed_config"),
    17: .standard(proto: "hedge_policy"),
    18: .standard(proto: "per_request_buffer_limit_bytes"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _domains: [String] = []
    var _routes: [Envoy_Config_Route_V3_Route] = []
    var _requireTls: Envoy_Config_Route_V3_VirtualHost.TlsRequirementType = .none
    var _virtualClusters: [Envoy_Config_Route_V3_VirtualCluster] = []
    var _rateLimits: [Envoy_Config_Route_V3_RateLimit] = []
    var _requestHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []
    var _requestHeadersToRemove: [String] = []
    var _responseHeadersToAdd: [Envoy_Config_Core_V3_HeaderValueOption] = []
    var _responseHeadersToRemove: [String] = []
    var _cors: Envoy_Config_Route_V3_CorsPolicy? = nil
    var _typedPerFilterConfig: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]
    var _includeRequestAttemptCount: Bool = false
    var _includeAttemptCountInResponse: Bool = false
    var _retryPolicy: Envoy_Config_Route_V3_RetryPolicy? = nil
    var _retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _hedgePolicy: Envoy_Config_Route_V3_HedgePolicy? = nil
    var _perRequestBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _domains = source._domains
      _routes = source._routes
      _requireTls = source._requireTls
      _virtualClusters = source._virtualClusters
      _rateLimits = source._rateLimits
      _requestHeadersToAdd = source._requestHeadersToAdd
      _requestHeadersToRemove = source._requestHeadersToRemove
      _responseHeadersToAdd = source._responseHeadersToAdd
      _responseHeadersToRemove = source._responseHeadersToRemove
      _cors = source._cors
      _typedPerFilterConfig = source._typedPerFilterConfig
      _includeRequestAttemptCount = source._includeRequestAttemptCount
      _includeAttemptCountInResponse = source._includeAttemptCountInResponse
      _retryPolicy = source._retryPolicy
      _retryPolicyTypedConfig = source._retryPolicyTypedConfig
      _hedgePolicy = source._hedgePolicy
      _perRequestBufferLimitBytes = source._perRequestBufferLimitBytes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeRepeatedStringField(value: &_storage._domains)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._routes)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._requireTls)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._virtualClusters)
        case 6: try decoder.decodeRepeatedMessageField(value: &_storage._rateLimits)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._requestHeadersToAdd)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._cors)
        case 10: try decoder.decodeRepeatedMessageField(value: &_storage._responseHeadersToAdd)
        case 11: try decoder.decodeRepeatedStringField(value: &_storage._responseHeadersToRemove)
        case 13: try decoder.decodeRepeatedStringField(value: &_storage._requestHeadersToRemove)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._includeRequestAttemptCount)
        case 15: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &_storage._typedPerFilterConfig)
        case 16: try decoder.decodeSingularMessageField(value: &_storage._retryPolicy)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._hedgePolicy)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._perRequestBufferLimitBytes)
        case 19: try decoder.decodeSingularBoolField(value: &_storage._includeAttemptCountInResponse)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._retryPolicyTypedConfig)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._domains.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._domains, fieldNumber: 2)
      }
      if !_storage._routes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._routes, fieldNumber: 3)
      }
      if _storage._requireTls != .none {
        try visitor.visitSingularEnumField(value: _storage._requireTls, fieldNumber: 4)
      }
      if !_storage._virtualClusters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._virtualClusters, fieldNumber: 5)
      }
      if !_storage._rateLimits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rateLimits, fieldNumber: 6)
      }
      if !_storage._requestHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestHeadersToAdd, fieldNumber: 7)
      }
      if let v = _storage._cors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._responseHeadersToAdd.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._responseHeadersToAdd, fieldNumber: 10)
      }
      if !_storage._responseHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._responseHeadersToRemove, fieldNumber: 11)
      }
      if !_storage._requestHeadersToRemove.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._requestHeadersToRemove, fieldNumber: 13)
      }
      if _storage._includeRequestAttemptCount != false {
        try visitor.visitSingularBoolField(value: _storage._includeRequestAttemptCount, fieldNumber: 14)
      }
      if !_storage._typedPerFilterConfig.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: _storage._typedPerFilterConfig, fieldNumber: 15)
      }
      if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._hedgePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._perRequestBufferLimitBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if _storage._includeAttemptCountInResponse != false {
        try visitor.visitSingularBoolField(value: _storage._includeAttemptCountInResponse, fieldNumber: 19)
      }
      if let v = _storage._retryPolicyTypedConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_VirtualHost, rhs: Envoy_Config_Route_V3_VirtualHost) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._domains != rhs_storage._domains {return false}
        if _storage._routes != rhs_storage._routes {return false}
        if _storage._requireTls != rhs_storage._requireTls {return false}
        if _storage._virtualClusters != rhs_storage._virtualClusters {return false}
        if _storage._rateLimits != rhs_storage._rateLimits {return false}
        if _storage._requestHeadersToAdd != rhs_storage._requestHeadersToAdd {return false}
        if _storage._requestHeadersToRemove != rhs_storage._requestHeadersToRemove {return false}
        if _storage._responseHeadersToAdd != rhs_storage._responseHeadersToAdd {return false}
        if _storage._responseHeadersToRemove != rhs_storage._responseHeadersToRemove {return false}
        if _storage._cors != rhs_storage._cors {return false}
        if _storage._typedPerFilterConfig != rhs_storage._typedPerFilterConfig {return false}
        if _storage._includeRequestAttemptCount != rhs_storage._includeRequestAttemptCount {return false}
        if _storage._includeAttemptCountInResponse != rhs_storage._includeAttemptCountInResponse {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._retryPolicyTypedConfig != rhs_storage._retryPolicyTypedConfig {return false}
        if _storage._hedgePolicy != rhs_storage._hedgePolicy {return false}
        if _storage._perRequestBufferLimitBytes != rhs_storage._perRequestBufferLimitBytes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_VirtualHost.TlsRequirementType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "EXTERNAL_ONLY"),
    2: .same(proto: "ALL"),
  ]
}

extension Envoy_Config_Route_V3_FilterAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._action)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_FilterAction, rhs: Envoy_Config_Route_V3_FilterAction) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .same(proto: "name"),
    1: .same(proto: "match"),
    2: .same(proto: "route"),
    3: .same(proto: "redirect"),
    7: .standard(proto: "direct_response"),
    17: .standard(proto: "filter_action"),
    4: .same(proto: "metadata"),
    5: .same(proto: "decorator"),
    13: .standard(proto: "typed_per_filter_config"),
    9: .standard(proto: "request_headers_to_add"),
    12: .standard(proto: "request_headers_to_remove"),
    10: .standard(proto: "response_headers_to_add"),
    11: .standard(proto: "response_headers_to_remove"),
    15: .same(proto: "tracing"),
    16: .standard(proto: "per_request_buffer_limit_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._match)
      case 2:
        var v: Envoy_Config_Route_V3_RouteAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .route(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .route(v)}
      case 3:
        var v: Envoy_Config_Route_V3_RedirectAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .redirect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .redirect(v)}
      case 4: try decoder.decodeSingularMessageField(value: &self._metadata)
      case 5: try decoder.decodeSingularMessageField(value: &self._decorator)
      case 7:
        var v: Envoy_Config_Route_V3_DirectResponseAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .directResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .directResponse(v)}
      case 9: try decoder.decodeRepeatedMessageField(value: &self.requestHeadersToAdd)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.responseHeadersToAdd)
      case 11: try decoder.decodeRepeatedStringField(value: &self.responseHeadersToRemove)
      case 12: try decoder.decodeRepeatedStringField(value: &self.requestHeadersToRemove)
      case 13: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &self.typedPerFilterConfig)
      case 14: try decoder.decodeSingularStringField(value: &self.name)
      case 15: try decoder.decodeSingularMessageField(value: &self._tracing)
      case 16: try decoder.decodeSingularMessageField(value: &self._perRequestBufferLimitBytes)
      case 17:
        var v: Envoy_Config_Route_V3_FilterAction?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .filterAction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .filterAction(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._match {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    switch self.action {
    case .route(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .redirect(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    default: break
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._decorator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if case .directResponse(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.requestHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeadersToAdd, fieldNumber: 9)
    }
    if !self.responseHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeadersToAdd, fieldNumber: 10)
    }
    if !self.responseHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.responseHeadersToRemove, fieldNumber: 11)
    }
    if !self.requestHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestHeadersToRemove, fieldNumber: 12)
    }
    if !self.typedPerFilterConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: self.typedPerFilterConfig, fieldNumber: 13)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 14)
    }
    if let v = self._tracing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }
    if let v = self._perRequestBufferLimitBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }
    if case .filterAction(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_Route, rhs: Envoy_Config_Route_V3_Route) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._match != rhs._match {return false}
    if lhs.action != rhs.action {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs._decorator != rhs._decorator {return false}
    if lhs.typedPerFilterConfig != rhs.typedPerFilterConfig {return false}
    if lhs.requestHeadersToAdd != rhs.requestHeadersToAdd {return false}
    if lhs.requestHeadersToRemove != rhs.requestHeadersToRemove {return false}
    if lhs.responseHeadersToAdd != rhs.responseHeadersToAdd {return false}
    if lhs.responseHeadersToRemove != rhs.responseHeadersToRemove {return false}
    if lhs._tracing != rhs._tracing {return false}
    if lhs._perRequestBufferLimitBytes != rhs._perRequestBufferLimitBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_WeightedCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WeightedCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
    3: .standard(proto: "total_weight"),
    2: .standard(proto: "runtime_key_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.clusters)
      case 2: try decoder.decodeSingularStringField(value: &self.runtimeKeyPrefix)
      case 3: try decoder.decodeSingularMessageField(value: &self._totalWeight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    if !self.runtimeKeyPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKeyPrefix, fieldNumber: 2)
    }
    if let v = self._totalWeight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_WeightedCluster, rhs: Envoy_Config_Route_V3_WeightedCluster) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs._totalWeight != rhs._totalWeight {return false}
    if lhs.runtimeKeyPrefix != rhs.runtimeKeyPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_WeightedCluster.ClusterWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_WeightedCluster.protoMessageName + ".ClusterWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "weight"),
    3: .standard(proto: "metadata_match"),
    4: .standard(proto: "request_headers_to_add"),
    9: .standard(proto: "request_headers_to_remove"),
    5: .standard(proto: "response_headers_to_add"),
    6: .standard(proto: "response_headers_to_remove"),
    10: .standard(proto: "typed_per_filter_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._weight)
      case 3: try decoder.decodeSingularMessageField(value: &self._metadataMatch)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.requestHeadersToAdd)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.responseHeadersToAdd)
      case 6: try decoder.decodeRepeatedStringField(value: &self.responseHeadersToRemove)
      case 9: try decoder.decodeRepeatedStringField(value: &self.requestHeadersToRemove)
      case 10: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &self.typedPerFilterConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._weight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.requestHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeadersToAdd, fieldNumber: 4)
    }
    if !self.responseHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseHeadersToAdd, fieldNumber: 5)
    }
    if !self.responseHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.responseHeadersToRemove, fieldNumber: 6)
    }
    if !self.requestHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestHeadersToRemove, fieldNumber: 9)
    }
    if !self.typedPerFilterConfig.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: self.typedPerFilterConfig, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_WeightedCluster.ClusterWeight, rhs: Envoy_Config_Route_V3_WeightedCluster.ClusterWeight) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs.requestHeadersToAdd != rhs.requestHeadersToAdd {return false}
    if lhs.requestHeadersToRemove != rhs.requestHeadersToRemove {return false}
    if lhs.responseHeadersToAdd != rhs.responseHeadersToAdd {return false}
    if lhs.responseHeadersToRemove != rhs.responseHeadersToRemove {return false}
    if lhs.typedPerFilterConfig != rhs.typedPerFilterConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .same(proto: "path"),
    10: .standard(proto: "safe_regex"),
    12: .standard(proto: "connect_matcher"),
    4: .standard(proto: "case_sensitive"),
    9: .standard(proto: "runtime_fraction"),
    6: .same(proto: "headers"),
    7: .standard(proto: "query_parameters"),
    8: .same(proto: "grpc"),
    11: .standard(proto: "tls_context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.pathSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathSpecifier = .prefix(v)}
      case 2:
        if self.pathSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathSpecifier = .path(v)}
      case 4: try decoder.decodeSingularMessageField(value: &self._caseSensitive)
      case 6: try decoder.decodeRepeatedMessageField(value: &self.headers)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.queryParameters)
      case 8: try decoder.decodeSingularMessageField(value: &self._grpc)
      case 9: try decoder.decodeSingularMessageField(value: &self._runtimeFraction)
      case 10:
        var v: Envoy_Type_Matcher_V3_RegexMatcher?
        if let current = self.pathSpecifier {
          try decoder.handleConflictingOneOf()
          if case .safeRegex(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pathSpecifier = .safeRegex(v)}
      case 11: try decoder.decodeSingularMessageField(value: &self._tlsContext)
      case 12:
        var v: Envoy_Config_Route_V3_RouteMatch.ConnectMatcher?
        if let current = self.pathSpecifier {
          try decoder.handleConflictingOneOf()
          if case .connectMatcher(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pathSpecifier = .connectMatcher(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.pathSpecifier {
    case .prefix(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .path(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    default: break
    }
    if let v = self._caseSensitive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 6)
    }
    if !self.queryParameters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queryParameters, fieldNumber: 7)
    }
    if let v = self._grpc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._runtimeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if case .safeRegex(let v)? = self.pathSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if let v = self._tlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    if case .connectMatcher(let v)? = self.pathSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteMatch, rhs: Envoy_Config_Route_V3_RouteMatch) -> Bool {
    if lhs.pathSpecifier != rhs.pathSpecifier {return false}
    if lhs._caseSensitive != rhs._caseSensitive {return false}
    if lhs._runtimeFraction != rhs._runtimeFraction {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.queryParameters != rhs.queryParameters {return false}
    if lhs._grpc != rhs._grpc {return false}
    if lhs._tlsContext != rhs._tlsContext {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteMatch.GrpcRouteMatchOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteMatch.protoMessageName + ".GrpcRouteMatchOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteMatch.GrpcRouteMatchOptions, rhs: Envoy_Config_Route_V3_RouteMatch.GrpcRouteMatchOptions) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteMatch.TlsContextMatchOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteMatch.protoMessageName + ".TlsContextMatchOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "presented"),
    2: .same(proto: "validated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._presented)
      case 2: try decoder.decodeSingularMessageField(value: &self._validated)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._presented {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._validated {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteMatch.TlsContextMatchOptions, rhs: Envoy_Config_Route_V3_RouteMatch.TlsContextMatchOptions) -> Bool {
    if lhs._presented != rhs._presented {return false}
    if lhs._validated != rhs._validated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteMatch.ConnectMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteMatch.protoMessageName + ".ConnectMatcher"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteMatch.ConnectMatcher, rhs: Envoy_Config_Route_V3_RouteMatch.ConnectMatcher) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_CorsPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CorsPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "allow_origin_string_match"),
    2: .standard(proto: "allow_methods"),
    3: .standard(proto: "allow_headers"),
    4: .standard(proto: "expose_headers"),
    5: .standard(proto: "max_age"),
    6: .standard(proto: "allow_credentials"),
    9: .standard(proto: "filter_enabled"),
    10: .standard(proto: "shadow_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.allowMethods)
      case 3: try decoder.decodeSingularStringField(value: &self.allowHeaders)
      case 4: try decoder.decodeSingularStringField(value: &self.exposeHeaders)
      case 5: try decoder.decodeSingularStringField(value: &self.maxAge)
      case 6: try decoder.decodeSingularMessageField(value: &self._allowCredentials)
      case 9:
        var v: Envoy_Config_Core_V3_RuntimeFractionalPercent?
        if let current = self.enabledSpecifier {
          try decoder.handleConflictingOneOf()
          if case .filterEnabled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.enabledSpecifier = .filterEnabled(v)}
      case 10: try decoder.decodeSingularMessageField(value: &self._shadowEnabled)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.allowOriginStringMatch)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowMethods.isEmpty {
      try visitor.visitSingularStringField(value: self.allowMethods, fieldNumber: 2)
    }
    if !self.allowHeaders.isEmpty {
      try visitor.visitSingularStringField(value: self.allowHeaders, fieldNumber: 3)
    }
    if !self.exposeHeaders.isEmpty {
      try visitor.visitSingularStringField(value: self.exposeHeaders, fieldNumber: 4)
    }
    if !self.maxAge.isEmpty {
      try visitor.visitSingularStringField(value: self.maxAge, fieldNumber: 5)
    }
    if let v = self._allowCredentials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if case .filterEnabled(let v)? = self.enabledSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._shadowEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.allowOriginStringMatch.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowOriginStringMatch, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_CorsPolicy, rhs: Envoy_Config_Route_V3_CorsPolicy) -> Bool {
    if lhs.allowOriginStringMatch != rhs.allowOriginStringMatch {return false}
    if lhs.allowMethods != rhs.allowMethods {return false}
    if lhs.allowHeaders != rhs.allowHeaders {return false}
    if lhs.exposeHeaders != rhs.exposeHeaders {return false}
    if lhs.maxAge != rhs.maxAge {return false}
    if lhs._allowCredentials != rhs._allowCredentials {return false}
    if lhs.enabledSpecifier != rhs.enabledSpecifier {return false}
    if lhs._shadowEnabled != rhs._shadowEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "cluster_header"),
    3: .standard(proto: "weighted_clusters"),
    20: .standard(proto: "cluster_not_found_response_code"),
    4: .standard(proto: "metadata_match"),
    5: .standard(proto: "prefix_rewrite"),
    32: .standard(proto: "regex_rewrite"),
    6: .standard(proto: "host_rewrite_literal"),
    7: .standard(proto: "auto_host_rewrite"),
    29: .standard(proto: "host_rewrite_header"),
    8: .same(proto: "timeout"),
    24: .standard(proto: "idle_timeout"),
    9: .standard(proto: "retry_policy"),
    33: .standard(proto: "retry_policy_typed_config"),
    30: .standard(proto: "request_mirror_policies"),
    11: .same(proto: "priority"),
    13: .standard(proto: "rate_limits"),
    14: .standard(proto: "include_vh_rate_limits"),
    15: .standard(proto: "hash_policy"),
    17: .same(proto: "cors"),
    23: .standard(proto: "max_grpc_timeout"),
    28: .standard(proto: "grpc_timeout_offset"),
    25: .standard(proto: "upgrade_configs"),
    34: .standard(proto: "internal_redirect_policy"),
    26: .standard(proto: "internal_redirect_action"),
    31: .standard(proto: "max_internal_redirects"),
    27: .standard(proto: "hedge_policy"),
  ]

  fileprivate class _StorageClass {
    var _clusterSpecifier: Envoy_Config_Route_V3_RouteAction.OneOf_ClusterSpecifier?
    var _clusterNotFoundResponseCode: Envoy_Config_Route_V3_RouteAction.ClusterNotFoundResponseCode = .serviceUnavailable
    var _metadataMatch: Envoy_Config_Core_V3_Metadata? = nil
    var _prefixRewrite: String = String()
    var _regexRewrite: Envoy_Type_Matcher_V3_RegexMatchAndSubstitute? = nil
    var _hostRewriteSpecifier: Envoy_Config_Route_V3_RouteAction.OneOf_HostRewriteSpecifier?
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Envoy_Config_Route_V3_RetryPolicy? = nil
    var _retryPolicyTypedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _requestMirrorPolicies: [Envoy_Config_Route_V3_RouteAction.RequestMirrorPolicy] = []
    var _priority: Envoy_Config_Core_V3_RoutingPriority = .default
    var _rateLimits: [Envoy_Config_Route_V3_RateLimit] = []
    var _includeVhRateLimits: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _hashPolicy: [Envoy_Config_Route_V3_RouteAction.HashPolicy] = []
    var _cors: Envoy_Config_Route_V3_CorsPolicy? = nil
    var _maxGrpcTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _grpcTimeoutOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _upgradeConfigs: [Envoy_Config_Route_V3_RouteAction.UpgradeConfig] = []
    var _internalRedirectPolicy: Envoy_Config_Route_V3_InternalRedirectPolicy? = nil
    var _internalRedirectAction: Envoy_Config_Route_V3_RouteAction.InternalRedirectAction = .passThroughInternalRedirect
    var _maxInternalRedirects: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _hedgePolicy: Envoy_Config_Route_V3_HedgePolicy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _clusterSpecifier = source._clusterSpecifier
      _clusterNotFoundResponseCode = source._clusterNotFoundResponseCode
      _metadataMatch = source._metadataMatch
      _prefixRewrite = source._prefixRewrite
      _regexRewrite = source._regexRewrite
      _hostRewriteSpecifier = source._hostRewriteSpecifier
      _timeout = source._timeout
      _idleTimeout = source._idleTimeout
      _retryPolicy = source._retryPolicy
      _retryPolicyTypedConfig = source._retryPolicyTypedConfig
      _requestMirrorPolicies = source._requestMirrorPolicies
      _priority = source._priority
      _rateLimits = source._rateLimits
      _includeVhRateLimits = source._includeVhRateLimits
      _hashPolicy = source._hashPolicy
      _cors = source._cors
      _maxGrpcTimeout = source._maxGrpcTimeout
      _grpcTimeoutOffset = source._grpcTimeoutOffset
      _upgradeConfigs = source._upgradeConfigs
      _internalRedirectPolicy = source._internalRedirectPolicy
      _internalRedirectAction = source._internalRedirectAction
      _maxInternalRedirects = source._maxInternalRedirects
      _hedgePolicy = source._hedgePolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1:
          if _storage._clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._clusterSpecifier = .cluster(v)}
        case 2:
          if _storage._clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._clusterSpecifier = .clusterHeader(v)}
        case 3:
          var v: Envoy_Config_Route_V3_WeightedCluster?
          if let current = _storage._clusterSpecifier {
            try decoder.handleConflictingOneOf()
            if case .weightedClusters(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._clusterSpecifier = .weightedClusters(v)}
        case 4: try decoder.decodeSingularMessageField(value: &_storage._metadataMatch)
        case 5: try decoder.decodeSingularStringField(value: &_storage._prefixRewrite)
        case 6:
          if _storage._hostRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .hostRewriteLiteral(v)}
        case 7:
          var v: SwiftProtobuf.Google_Protobuf_BoolValue?
          if let current = _storage._hostRewriteSpecifier {
            try decoder.handleConflictingOneOf()
            if case .autoHostRewrite(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .autoHostRewrite(v)}
        case 8: try decoder.decodeSingularMessageField(value: &_storage._timeout)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._retryPolicy)
        case 11: try decoder.decodeSingularEnumField(value: &_storage._priority)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._rateLimits)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._includeVhRateLimits)
        case 15: try decoder.decodeRepeatedMessageField(value: &_storage._hashPolicy)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._cors)
        case 20: try decoder.decodeSingularEnumField(value: &_storage._clusterNotFoundResponseCode)
        case 23: try decoder.decodeSingularMessageField(value: &_storage._maxGrpcTimeout)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._idleTimeout)
        case 25: try decoder.decodeRepeatedMessageField(value: &_storage._upgradeConfigs)
        case 26: try decoder.decodeSingularEnumField(value: &_storage._internalRedirectAction)
        case 27: try decoder.decodeSingularMessageField(value: &_storage._hedgePolicy)
        case 28: try decoder.decodeSingularMessageField(value: &_storage._grpcTimeoutOffset)
        case 29:
          if _storage._hostRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._hostRewriteSpecifier = .hostRewriteHeader(v)}
        case 30: try decoder.decodeRepeatedMessageField(value: &_storage._requestMirrorPolicies)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._maxInternalRedirects)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._regexRewrite)
        case 33: try decoder.decodeSingularMessageField(value: &_storage._retryPolicyTypedConfig)
        case 34: try decoder.decodeSingularMessageField(value: &_storage._internalRedirectPolicy)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      switch _storage._clusterSpecifier {
      case .cluster(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      case .clusterHeader(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      case .weightedClusters(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
      if let v = _storage._metadataMatch {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._prefixRewrite.isEmpty {
        try visitor.visitSingularStringField(value: _storage._prefixRewrite, fieldNumber: 5)
      }
      switch _storage._hostRewriteSpecifier {
      case .hostRewriteLiteral(let v)?:
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      case .autoHostRewrite(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      default: break
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._priority != .default {
        try visitor.visitSingularEnumField(value: _storage._priority, fieldNumber: 11)
      }
      if !_storage._rateLimits.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._rateLimits, fieldNumber: 13)
      }
      if let v = _storage._includeVhRateLimits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._hashPolicy.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._hashPolicy, fieldNumber: 15)
      }
      if let v = _storage._cors {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if _storage._clusterNotFoundResponseCode != .serviceUnavailable {
        try visitor.visitSingularEnumField(value: _storage._clusterNotFoundResponseCode, fieldNumber: 20)
      }
      if let v = _storage._maxGrpcTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._idleTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if !_storage._upgradeConfigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._upgradeConfigs, fieldNumber: 25)
      }
      if _storage._internalRedirectAction != .passThroughInternalRedirect {
        try visitor.visitSingularEnumField(value: _storage._internalRedirectAction, fieldNumber: 26)
      }
      if let v = _storage._hedgePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._grpcTimeoutOffset {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
      if case .hostRewriteHeader(let v)? = _storage._hostRewriteSpecifier {
        try visitor.visitSingularStringField(value: v, fieldNumber: 29)
      }
      if !_storage._requestMirrorPolicies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._requestMirrorPolicies, fieldNumber: 30)
      }
      if let v = _storage._maxInternalRedirects {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._regexRewrite {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if let v = _storage._retryPolicyTypedConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if let v = _storage._internalRedirectPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction, rhs: Envoy_Config_Route_V3_RouteAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._clusterSpecifier != rhs_storage._clusterSpecifier {return false}
        if _storage._clusterNotFoundResponseCode != rhs_storage._clusterNotFoundResponseCode {return false}
        if _storage._metadataMatch != rhs_storage._metadataMatch {return false}
        if _storage._prefixRewrite != rhs_storage._prefixRewrite {return false}
        if _storage._regexRewrite != rhs_storage._regexRewrite {return false}
        if _storage._hostRewriteSpecifier != rhs_storage._hostRewriteSpecifier {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._idleTimeout != rhs_storage._idleTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._retryPolicyTypedConfig != rhs_storage._retryPolicyTypedConfig {return false}
        if _storage._requestMirrorPolicies != rhs_storage._requestMirrorPolicies {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._rateLimits != rhs_storage._rateLimits {return false}
        if _storage._includeVhRateLimits != rhs_storage._includeVhRateLimits {return false}
        if _storage._hashPolicy != rhs_storage._hashPolicy {return false}
        if _storage._cors != rhs_storage._cors {return false}
        if _storage._maxGrpcTimeout != rhs_storage._maxGrpcTimeout {return false}
        if _storage._grpcTimeoutOffset != rhs_storage._grpcTimeoutOffset {return false}
        if _storage._upgradeConfigs != rhs_storage._upgradeConfigs {return false}
        if _storage._internalRedirectPolicy != rhs_storage._internalRedirectPolicy {return false}
        if _storage._internalRedirectAction != rhs_storage._internalRedirectAction {return false}
        if _storage._maxInternalRedirects != rhs_storage._maxInternalRedirects {return false}
        if _storage._hedgePolicy != rhs_storage._hedgePolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.ClusterNotFoundResponseCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVICE_UNAVAILABLE"),
    1: .same(proto: "NOT_FOUND"),
  ]
}

extension Envoy_Config_Route_V3_RouteAction.InternalRedirectAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PASS_THROUGH_INTERNAL_REDIRECT"),
    1: .same(proto: "HANDLE_INTERNAL_REDIRECT"),
  ]
}

extension Envoy_Config_Route_V3_RouteAction.RequestMirrorPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.protoMessageName + ".RequestMirrorPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    3: .standard(proto: "runtime_fraction"),
    4: .standard(proto: "trace_sampled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cluster)
      case 3: try decoder.decodeSingularMessageField(value: &self._runtimeFraction)
      case 4: try decoder.decodeSingularMessageField(value: &self._traceSampled)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if let v = self._runtimeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._traceSampled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.RequestMirrorPolicy, rhs: Envoy_Config_Route_V3_RouteAction.RequestMirrorPolicy) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs._runtimeFraction != rhs._runtimeFraction {return false}
    if lhs._traceSampled != rhs._traceSampled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.HashPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.protoMessageName + ".HashPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "cookie"),
    3: .standard(proto: "connection_properties"),
    5: .standard(proto: "query_parameter"),
    6: .standard(proto: "filter_state"),
    4: .same(proto: "terminal"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Config_Route_V3_RouteAction.HashPolicy.Header?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .header(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .header(v)}
      case 2:
        var v: Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .cookie(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .cookie(v)}
      case 3:
        var v: Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .connectionProperties(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .connectionProperties(v)}
      case 4: try decoder.decodeSingularBoolField(value: &self.terminal)
      case 5:
        var v: Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .queryParameter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .queryParameter(v)}
      case 6:
        var v: Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState?
        if let current = self.policySpecifier {
          try decoder.handleConflictingOneOf()
          if case .filterState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policySpecifier = .filterState(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.policySpecifier {
    case .header(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .cookie(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .connectionProperties(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case nil: break
    default: break
    }
    if self.terminal != false {
      try visitor.visitSingularBoolField(value: self.terminal, fieldNumber: 4)
    }
    switch self.policySpecifier {
    case .queryParameter(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .filterState(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy) -> Bool {
    if lhs.policySpecifier != rhs.policySpecifier {return false}
    if lhs.terminal != rhs.terminal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.HashPolicy.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.HashPolicy.protoMessageName + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "header_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.headerName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headerName.isEmpty {
      try visitor.visitSingularStringField(value: self.headerName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.Header, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.Header) -> Bool {
    if lhs.headerName != rhs.headerName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.HashPolicy.protoMessageName + ".Cookie"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ttl"),
    3: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._ttl)
      case 3: try decoder.decodeSingularStringField(value: &self.path)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.Cookie) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._ttl != rhs._ttl {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.HashPolicy.protoMessageName + ".ConnectionProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_ip"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.sourceIp)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceIp != false {
      try visitor.visitSingularBoolField(value: self.sourceIp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.ConnectionProperties) -> Bool {
    if lhs.sourceIp != rhs.sourceIp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.HashPolicy.protoMessageName + ".QueryParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.QueryParameter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.HashPolicy.protoMessageName + ".FilterState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState, rhs: Envoy_Config_Route_V3_RouteAction.HashPolicy.FilterState) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.UpgradeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.protoMessageName + ".UpgradeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upgrade_type"),
    2: .same(proto: "enabled"),
    3: .standard(proto: "connect_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.upgradeType)
      case 2: try decoder.decodeSingularMessageField(value: &self._enabled)
      case 3: try decoder.decodeSingularMessageField(value: &self._connectConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.upgradeType.isEmpty {
      try visitor.visitSingularStringField(value: self.upgradeType, fieldNumber: 1)
    }
    if let v = self._enabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._connectConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.UpgradeConfig, rhs: Envoy_Config_Route_V3_RouteAction.UpgradeConfig) -> Bool {
    if lhs.upgradeType != rhs.upgradeType {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs._connectConfig != rhs._connectConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RouteAction.UpgradeConfig.ConnectConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RouteAction.UpgradeConfig.protoMessageName + ".ConnectConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proxy_protocol_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._proxyProtocolConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._proxyProtocolConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RouteAction.UpgradeConfig.ConnectConfig, rhs: Envoy_Config_Route_V3_RouteAction.UpgradeConfig.ConnectConfig) -> Bool {
    if lhs._proxyProtocolConfig != rhs._proxyProtocolConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_on"),
    2: .standard(proto: "num_retries"),
    3: .standard(proto: "per_try_timeout"),
    4: .standard(proto: "retry_priority"),
    5: .standard(proto: "retry_host_predicate"),
    6: .standard(proto: "host_selection_retry_max_attempts"),
    7: .standard(proto: "retriable_status_codes"),
    8: .standard(proto: "retry_back_off"),
    9: .standard(proto: "retriable_headers"),
    10: .standard(proto: "retriable_request_headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.retryOn)
      case 2: try decoder.decodeSingularMessageField(value: &self._numRetries)
      case 3: try decoder.decodeSingularMessageField(value: &self._perTryTimeout)
      case 4: try decoder.decodeSingularMessageField(value: &self._retryPriority)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.retryHostPredicate)
      case 6: try decoder.decodeSingularInt64Field(value: &self.hostSelectionRetryMaxAttempts)
      case 7: try decoder.decodeRepeatedUInt32Field(value: &self.retriableStatusCodes)
      case 8: try decoder.decodeSingularMessageField(value: &self._retryBackOff)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.retriableHeaders)
      case 10: try decoder.decodeRepeatedMessageField(value: &self.retriableRequestHeaders)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.retryOn.isEmpty {
      try visitor.visitSingularStringField(value: self.retryOn, fieldNumber: 1)
    }
    if let v = self._numRetries {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._perTryTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._retryPriority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.retryHostPredicate.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.retryHostPredicate, fieldNumber: 5)
    }
    if self.hostSelectionRetryMaxAttempts != 0 {
      try visitor.visitSingularInt64Field(value: self.hostSelectionRetryMaxAttempts, fieldNumber: 6)
    }
    if !self.retriableStatusCodes.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.retriableStatusCodes, fieldNumber: 7)
    }
    if let v = self._retryBackOff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.retriableHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.retriableHeaders, fieldNumber: 9)
    }
    if !self.retriableRequestHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.retriableRequestHeaders, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RetryPolicy, rhs: Envoy_Config_Route_V3_RetryPolicy) -> Bool {
    if lhs.retryOn != rhs.retryOn {return false}
    if lhs._numRetries != rhs._numRetries {return false}
    if lhs._perTryTimeout != rhs._perTryTimeout {return false}
    if lhs._retryPriority != rhs._retryPriority {return false}
    if lhs.retryHostPredicate != rhs.retryHostPredicate {return false}
    if lhs.hostSelectionRetryMaxAttempts != rhs.hostSelectionRetryMaxAttempts {return false}
    if lhs.retriableStatusCodes != rhs.retriableStatusCodes {return false}
    if lhs._retryBackOff != rhs._retryBackOff {return false}
    if lhs.retriableHeaders != rhs.retriableHeaders {return false}
    if lhs.retriableRequestHeaders != rhs.retriableRequestHeaders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RetryPolicy.RetryPriority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RetryPolicy.protoMessageName + ".RetryPriority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3:
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RetryPolicy.RetryPriority, rhs: Envoy_Config_Route_V3_RetryPolicy.RetryPriority) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RetryPolicy.protoMessageName + ".RetryHostPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 3:
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate, rhs: Envoy_Config_Route_V3_RetryPolicy.RetryHostPredicate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RetryPolicy.RetryBackOff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RetryPolicy.protoMessageName + ".RetryBackOff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_interval"),
    2: .standard(proto: "max_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._baseInterval)
      case 2: try decoder.decodeSingularMessageField(value: &self._maxInterval)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RetryPolicy.RetryBackOff, rhs: Envoy_Config_Route_V3_RetryPolicy.RetryBackOff) -> Bool {
    if lhs._baseInterval != rhs._baseInterval {return false}
    if lhs._maxInterval != rhs._maxInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_HedgePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HedgePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_requests"),
    2: .standard(proto: "additional_request_chance"),
    3: .standard(proto: "hedge_on_per_try_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._initialRequests)
      case 2: try decoder.decodeSingularMessageField(value: &self._additionalRequestChance)
      case 3: try decoder.decodeSingularBoolField(value: &self.hedgeOnPerTryTimeout)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._initialRequests {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._additionalRequestChance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.hedgeOnPerTryTimeout != false {
      try visitor.visitSingularBoolField(value: self.hedgeOnPerTryTimeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_HedgePolicy, rhs: Envoy_Config_Route_V3_HedgePolicy) -> Bool {
    if lhs._initialRequests != rhs._initialRequests {return false}
    if lhs._additionalRequestChance != rhs._additionalRequestChance {return false}
    if lhs.hedgeOnPerTryTimeout != rhs.hedgeOnPerTryTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RedirectAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedirectAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "https_redirect"),
    7: .standard(proto: "scheme_redirect"),
    1: .standard(proto: "host_redirect"),
    8: .standard(proto: "port_redirect"),
    2: .standard(proto: "path_redirect"),
    5: .standard(proto: "prefix_rewrite"),
    3: .standard(proto: "response_code"),
    6: .standard(proto: "strip_query"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hostRedirect)
      case 2:
        if self.pathRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathRewriteSpecifier = .pathRedirect(v)}
      case 3: try decoder.decodeSingularEnumField(value: &self.responseCode)
      case 4:
        if self.schemeRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.schemeRewriteSpecifier = .httpsRedirect(v)}
      case 5:
        if self.pathRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pathRewriteSpecifier = .prefixRewrite(v)}
      case 6: try decoder.decodeSingularBoolField(value: &self.stripQuery)
      case 7:
        if self.schemeRewriteSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.schemeRewriteSpecifier = .schemeRedirect(v)}
      case 8: try decoder.decodeSingularUInt32Field(value: &self.portRedirect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostRedirect.isEmpty {
      try visitor.visitSingularStringField(value: self.hostRedirect, fieldNumber: 1)
    }
    if case .pathRedirect(let v)? = self.pathRewriteSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if self.responseCode != .movedPermanently {
      try visitor.visitSingularEnumField(value: self.responseCode, fieldNumber: 3)
    }
    if case .httpsRedirect(let v)? = self.schemeRewriteSpecifier {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }
    if case .prefixRewrite(let v)? = self.pathRewriteSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    if self.stripQuery != false {
      try visitor.visitSingularBoolField(value: self.stripQuery, fieldNumber: 6)
    }
    if case .schemeRedirect(let v)? = self.schemeRewriteSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if self.portRedirect != 0 {
      try visitor.visitSingularUInt32Field(value: self.portRedirect, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RedirectAction, rhs: Envoy_Config_Route_V3_RedirectAction) -> Bool {
    if lhs.schemeRewriteSpecifier != rhs.schemeRewriteSpecifier {return false}
    if lhs.hostRedirect != rhs.hostRedirect {return false}
    if lhs.portRedirect != rhs.portRedirect {return false}
    if lhs.pathRewriteSpecifier != rhs.pathRewriteSpecifier {return false}
    if lhs.responseCode != rhs.responseCode {return false}
    if lhs.stripQuery != rhs.stripQuery {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RedirectAction.RedirectResponseCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOVED_PERMANENTLY"),
    1: .same(proto: "FOUND"),
    2: .same(proto: "SEE_OTHER"),
    3: .same(proto: "TEMPORARY_REDIRECT"),
    4: .same(proto: "PERMANENT_REDIRECT"),
  ]
}

extension Envoy_Config_Route_V3_DirectResponseAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirectResponseAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt32Field(value: &self.status)
      case 2: try decoder.decodeSingularMessageField(value: &self._body)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != 0 {
      try visitor.visitSingularUInt32Field(value: self.status, fieldNumber: 1)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_DirectResponseAction, rhs: Envoy_Config_Route_V3_DirectResponseAction) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._body != rhs._body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_Decorator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Decorator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "propagate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.operation)
      case 2: try decoder.decodeSingularMessageField(value: &self._propagate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 1)
    }
    if let v = self._propagate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_Decorator, rhs: Envoy_Config_Route_V3_Decorator) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._propagate != rhs._propagate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_Tracing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tracing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_sampling"),
    2: .standard(proto: "random_sampling"),
    3: .standard(proto: "overall_sampling"),
    4: .standard(proto: "custom_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._clientSampling)
      case 2: try decoder.decodeSingularMessageField(value: &self._randomSampling)
      case 3: try decoder.decodeSingularMessageField(value: &self._overallSampling)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.customTags)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._clientSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._randomSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._overallSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.customTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customTags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_Tracing, rhs: Envoy_Config_Route_V3_Tracing) -> Bool {
    if lhs._clientSampling != rhs._clientSampling {return false}
    if lhs._randomSampling != rhs._randomSampling {return false}
    if lhs._overallSampling != rhs._overallSampling {return false}
    if lhs.customTags != rhs.customTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_VirtualCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VirtualCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "headers"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.headers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_VirtualCluster, rhs: Envoy_Config_Route_V3_VirtualCluster) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stage"),
    2: .standard(proto: "disable_key"),
    3: .same(proto: "actions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._stage)
      case 2: try decoder.decodeSingularStringField(value: &self.disableKey)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.actions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._stage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.disableKey.isEmpty {
      try visitor.visitSingularStringField(value: self.disableKey, fieldNumber: 2)
    }
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit, rhs: Envoy_Config_Route_V3_RateLimit) -> Bool {
    if lhs._stage != rhs._stage {return false}
    if lhs.disableKey != rhs.disableKey {return false}
    if lhs.actions != rhs.actions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.protoMessageName + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_cluster"),
    2: .standard(proto: "destination_cluster"),
    3: .standard(proto: "request_headers"),
    4: .standard(proto: "remote_address"),
    5: .standard(proto: "generic_key"),
    6: .standard(proto: "header_value_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Config_Route_V3_RateLimit.Action.SourceCluster?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .sourceCluster(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .sourceCluster(v)}
      case 2:
        var v: Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .destinationCluster(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .destinationCluster(v)}
      case 3:
        var v: Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .requestHeaders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .requestHeaders(v)}
      case 4:
        var v: Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .remoteAddress(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .remoteAddress(v)}
      case 5:
        var v: Envoy_Config_Route_V3_RateLimit.Action.GenericKey?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .genericKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .genericKey(v)}
      case 6:
        var v: Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch?
        if let current = self.actionSpecifier {
          try decoder.handleConflictingOneOf()
          if case .headerValueMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.actionSpecifier = .headerValueMatch(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.actionSpecifier {
    case .sourceCluster(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .destinationCluster(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .requestHeaders(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .remoteAddress(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .genericKey(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .headerValueMatch(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action, rhs: Envoy_Config_Route_V3_RateLimit.Action) -> Bool {
    if lhs.actionSpecifier != rhs.actionSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action.SourceCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.Action.protoMessageName + ".SourceCluster"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.SourceCluster, rhs: Envoy_Config_Route_V3_RateLimit.Action.SourceCluster) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.Action.protoMessageName + ".DestinationCluster"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster, rhs: Envoy_Config_Route_V3_RateLimit.Action.DestinationCluster) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.Action.protoMessageName + ".RequestHeaders"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "header_name"),
    2: .standard(proto: "descriptor_key"),
    3: .standard(proto: "skip_if_absent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.headerName)
      case 2: try decoder.decodeSingularStringField(value: &self.descriptorKey)
      case 3: try decoder.decodeSingularBoolField(value: &self.skipIfAbsent)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headerName.isEmpty {
      try visitor.visitSingularStringField(value: self.headerName, fieldNumber: 1)
    }
    if !self.descriptorKey.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorKey, fieldNumber: 2)
    }
    if self.skipIfAbsent != false {
      try visitor.visitSingularBoolField(value: self.skipIfAbsent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders, rhs: Envoy_Config_Route_V3_RateLimit.Action.RequestHeaders) -> Bool {
    if lhs.headerName != rhs.headerName {return false}
    if lhs.descriptorKey != rhs.descriptorKey {return false}
    if lhs.skipIfAbsent != rhs.skipIfAbsent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.Action.protoMessageName + ".RemoteAddress"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress, rhs: Envoy_Config_Route_V3_RateLimit.Action.RemoteAddress) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action.GenericKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.Action.protoMessageName + ".GenericKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "descriptor_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.descriptorValue)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptorValue.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorValue, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.GenericKey, rhs: Envoy_Config_Route_V3_RateLimit.Action.GenericKey) -> Bool {
    if lhs.descriptorValue != rhs.descriptorValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Route_V3_RateLimit.Action.protoMessageName + ".HeaderValueMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "descriptor_value"),
    2: .standard(proto: "expect_match"),
    3: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.descriptorValue)
      case 2: try decoder.decodeSingularMessageField(value: &self._expectMatch)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.headers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.descriptorValue.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptorValue, fieldNumber: 1)
    }
    if let v = self._expectMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch, rhs: Envoy_Config_Route_V3_RateLimit.Action.HeaderValueMatch) -> Bool {
    if lhs.descriptorValue != rhs.descriptorValue {return false}
    if lhs._expectMatch != rhs._expectMatch {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_HeaderMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeaderMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .standard(proto: "exact_match"),
    11: .standard(proto: "safe_regex_match"),
    6: .standard(proto: "range_match"),
    7: .standard(proto: "present_match"),
    9: .standard(proto: "prefix_match"),
    10: .standard(proto: "suffix_match"),
    8: .standard(proto: "invert_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 4:
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .exactMatch(v)}
      case 6:
        var v: Envoy_Type_V3_Int64Range?
        if let current = self.headerMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .rangeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.headerMatchSpecifier = .rangeMatch(v)}
      case 7:
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.headerMatchSpecifier = .presentMatch(v)}
      case 8: try decoder.decodeSingularBoolField(value: &self.invertMatch)
      case 9:
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .prefixMatch(v)}
      case 10:
        if self.headerMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerMatchSpecifier = .suffixMatch(v)}
      case 11:
        var v: Envoy_Type_Matcher_V3_RegexMatcher?
        if let current = self.headerMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .safeRegexMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.headerMatchSpecifier = .safeRegexMatch(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.headerMatchSpecifier {
    case .exactMatch(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    case .rangeMatch(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    case .presentMatch(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    case nil: break
    default: break
    }
    if self.invertMatch != false {
      try visitor.visitSingularBoolField(value: self.invertMatch, fieldNumber: 8)
    }
    switch self.headerMatchSpecifier {
    case .prefixMatch(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    case .suffixMatch(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    case .safeRegexMatch(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    case nil: break
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_HeaderMatcher, rhs: Envoy_Config_Route_V3_HeaderMatcher) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.headerMatchSpecifier != rhs.headerMatchSpecifier {return false}
    if lhs.invertMatch != rhs.invertMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_QueryParameterMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryParameterMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    5: .standard(proto: "string_match"),
    6: .standard(proto: "present_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 5:
        var v: Envoy_Type_Matcher_V3_StringMatcher?
        if let current = self.queryParameterMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .stringMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.queryParameterMatchSpecifier = .stringMatch(v)}
      case 6:
        if self.queryParameterMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.queryParameterMatchSpecifier = .presentMatch(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    switch self.queryParameterMatchSpecifier {
    case .stringMatch(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case .presentMatch(let v)?:
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_QueryParameterMatcher, rhs: Envoy_Config_Route_V3_QueryParameterMatcher) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.queryParameterMatchSpecifier != rhs.queryParameterMatchSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Route_V3_InternalRedirectPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InternalRedirectPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_internal_redirects"),
    2: .standard(proto: "redirect_response_codes"),
    3: .same(proto: "predicates"),
    4: .standard(proto: "allow_cross_scheme_redirect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._maxInternalRedirects)
      case 2: try decoder.decodeRepeatedUInt32Field(value: &self.redirectResponseCodes)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.predicates)
      case 4: try decoder.decodeSingularBoolField(value: &self.allowCrossSchemeRedirect)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._maxInternalRedirects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.redirectResponseCodes.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.redirectResponseCodes, fieldNumber: 2)
    }
    if !self.predicates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.predicates, fieldNumber: 3)
    }
    if self.allowCrossSchemeRedirect != false {
      try visitor.visitSingularBoolField(value: self.allowCrossSchemeRedirect, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Route_V3_InternalRedirectPolicy, rhs: Envoy_Config_Route_V3_InternalRedirectPolicy) -> Bool {
    if lhs._maxInternalRedirects != rhs._maxInternalRedirects {return false}
    if lhs.redirectResponseCodes != rhs.redirectResponseCodes {return false}
    if lhs.predicates != rhs.predicates {return false}
    if lhs.allowCrossSchemeRedirect != rhs.allowCrossSchemeRedirect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

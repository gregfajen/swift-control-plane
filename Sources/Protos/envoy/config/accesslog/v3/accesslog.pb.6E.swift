// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/accesslog/v3/accesslog.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Config_Accesslog_V3_AccessLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the access log implementation to instantiate. The name must
  /// match a statically registered access log. Current built-in loggers include:
  ///
  /// #. "envoy.access_loggers.file"
  /// #. "envoy.access_loggers.http_grpc"
  /// #. "envoy.access_loggers.tcp_grpc"
  public var name: String = String()

  /// Filter which is used to determine if the access log needs to be written.
  public var filter: Envoy_Config_Accesslog_V3_AccessLogFilter {
    get {return _filter ?? Envoy_Config_Accesslog_V3_AccessLogFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  /// Custom configuration that depends on the access log being instantiated.
  /// Built-in configurations include:
  ///
  /// #. "envoy.access_loggers.file": :ref:`FileAccessLog
  ///    <envoy_api_msg_extensions.access_loggers.file.v3.FileAccessLog>`
  /// #. "envoy.access_loggers.http_grpc": :ref:`HttpGrpcAccessLogConfig
  ///    <envoy_api_msg_extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig>`
  /// #. "envoy.access_loggers.tcp_grpc": :ref:`TcpGrpcAccessLogConfig
  ///    <envoy_api_msg_extensions.access_loggers.grpc.v3.TcpGrpcAccessLogConfig>`
  public var configType: Envoy_Config_Accesslog_V3_AccessLog.OneOf_ConfigType? = nil

  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .typedConfig(let v)? = configType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {configType = .typedConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Custom configuration that depends on the access log being instantiated.
  /// Built-in configurations include:
  ///
  /// #. "envoy.access_loggers.file": :ref:`FileAccessLog
  ///    <envoy_api_msg_extensions.access_loggers.file.v3.FileAccessLog>`
  /// #. "envoy.access_loggers.http_grpc": :ref:`HttpGrpcAccessLogConfig
  ///    <envoy_api_msg_extensions.access_loggers.grpc.v3.HttpGrpcAccessLogConfig>`
  /// #. "envoy.access_loggers.tcp_grpc": :ref:`TcpGrpcAccessLogConfig
  ///    <envoy_api_msg_extensions.access_loggers.grpc.v3.TcpGrpcAccessLogConfig>`
  public enum OneOf_ConfigType: Equatable {
    case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Accesslog_V3_AccessLog.OneOf_ConfigType, rhs: Envoy_Config_Accesslog_V3_AccessLog.OneOf_ConfigType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.typedConfig, .typedConfig): return {
        guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _filter: Envoy_Config_Accesslog_V3_AccessLogFilter? = nil
}

/// [#next-free-field: 13]
public struct Envoy_Config_Accesslog_V3_AccessLogFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filterSpecifier: Envoy_Config_Accesslog_V3_AccessLogFilter.OneOf_FilterSpecifier? = nil

  /// Status code filter.
  public var statusCodeFilter: Envoy_Config_Accesslog_V3_StatusCodeFilter {
    get {
      if case .statusCodeFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_StatusCodeFilter()
    }
    set {filterSpecifier = .statusCodeFilter(newValue)}
  }

  /// Duration filter.
  public var durationFilter: Envoy_Config_Accesslog_V3_DurationFilter {
    get {
      if case .durationFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_DurationFilter()
    }
    set {filterSpecifier = .durationFilter(newValue)}
  }

  /// Not health check filter.
  public var notHealthCheckFilter: Envoy_Config_Accesslog_V3_NotHealthCheckFilter {
    get {
      if case .notHealthCheckFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_NotHealthCheckFilter()
    }
    set {filterSpecifier = .notHealthCheckFilter(newValue)}
  }

  /// Traceable filter.
  public var traceableFilter: Envoy_Config_Accesslog_V3_TraceableFilter {
    get {
      if case .traceableFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_TraceableFilter()
    }
    set {filterSpecifier = .traceableFilter(newValue)}
  }

  /// Runtime filter.
  public var runtimeFilter: Envoy_Config_Accesslog_V3_RuntimeFilter {
    get {
      if case .runtimeFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_RuntimeFilter()
    }
    set {filterSpecifier = .runtimeFilter(newValue)}
  }

  /// And filter.
  public var andFilter: Envoy_Config_Accesslog_V3_AndFilter {
    get {
      if case .andFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_AndFilter()
    }
    set {filterSpecifier = .andFilter(newValue)}
  }

  /// Or filter.
  public var orFilter: Envoy_Config_Accesslog_V3_OrFilter {
    get {
      if case .orFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_OrFilter()
    }
    set {filterSpecifier = .orFilter(newValue)}
  }

  /// Header filter.
  public var headerFilter: Envoy_Config_Accesslog_V3_HeaderFilter {
    get {
      if case .headerFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_HeaderFilter()
    }
    set {filterSpecifier = .headerFilter(newValue)}
  }

  /// Response flag filter.
  public var responseFlagFilter: Envoy_Config_Accesslog_V3_ResponseFlagFilter {
    get {
      if case .responseFlagFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_ResponseFlagFilter()
    }
    set {filterSpecifier = .responseFlagFilter(newValue)}
  }

  /// gRPC status filter.
  public var grpcStatusFilter: Envoy_Config_Accesslog_V3_GrpcStatusFilter {
    get {
      if case .grpcStatusFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_GrpcStatusFilter()
    }
    set {filterSpecifier = .grpcStatusFilter(newValue)}
  }

  /// Extension filter.
  public var extensionFilter: Envoy_Config_Accesslog_V3_ExtensionFilter {
    get {
      if case .extensionFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_ExtensionFilter()
    }
    set {filterSpecifier = .extensionFilter(newValue)}
  }

  /// Metadata Filter
  public var metadataFilter: Envoy_Config_Accesslog_V3_MetadataFilter {
    get {
      if case .metadataFilter(let v)? = filterSpecifier {return v}
      return Envoy_Config_Accesslog_V3_MetadataFilter()
    }
    set {filterSpecifier = .metadataFilter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_FilterSpecifier: Equatable {
    /// Status code filter.
    case statusCodeFilter(Envoy_Config_Accesslog_V3_StatusCodeFilter)
    /// Duration filter.
    case durationFilter(Envoy_Config_Accesslog_V3_DurationFilter)
    /// Not health check filter.
    case notHealthCheckFilter(Envoy_Config_Accesslog_V3_NotHealthCheckFilter)
    /// Traceable filter.
    case traceableFilter(Envoy_Config_Accesslog_V3_TraceableFilter)
    /// Runtime filter.
    case runtimeFilter(Envoy_Config_Accesslog_V3_RuntimeFilter)
    /// And filter.
    case andFilter(Envoy_Config_Accesslog_V3_AndFilter)
    /// Or filter.
    case orFilter(Envoy_Config_Accesslog_V3_OrFilter)
    /// Header filter.
    case headerFilter(Envoy_Config_Accesslog_V3_HeaderFilter)
    /// Response flag filter.
    case responseFlagFilter(Envoy_Config_Accesslog_V3_ResponseFlagFilter)
    /// gRPC status filter.
    case grpcStatusFilter(Envoy_Config_Accesslog_V3_GrpcStatusFilter)
    /// Extension filter.
    case extensionFilter(Envoy_Config_Accesslog_V3_ExtensionFilter)
    /// Metadata Filter
    case metadataFilter(Envoy_Config_Accesslog_V3_MetadataFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Accesslog_V3_AccessLogFilter.OneOf_FilterSpecifier, rhs: Envoy_Config_Accesslog_V3_AccessLogFilter.OneOf_FilterSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.statusCodeFilter, .statusCodeFilter): return {
        guard case .statusCodeFilter(let l) = lhs, case .statusCodeFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.durationFilter, .durationFilter): return {
        guard case .durationFilter(let l) = lhs, case .durationFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notHealthCheckFilter, .notHealthCheckFilter): return {
        guard case .notHealthCheckFilter(let l) = lhs, case .notHealthCheckFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.traceableFilter, .traceableFilter): return {
        guard case .traceableFilter(let l) = lhs, case .traceableFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.runtimeFilter, .runtimeFilter): return {
        guard case .runtimeFilter(let l) = lhs, case .runtimeFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.andFilter, .andFilter): return {
        guard case .andFilter(let l) = lhs, case .andFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.orFilter, .orFilter): return {
        guard case .orFilter(let l) = lhs, case .orFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.headerFilter, .headerFilter): return {
        guard case .headerFilter(let l) = lhs, case .headerFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responseFlagFilter, .responseFlagFilter): return {
        guard case .responseFlagFilter(let l) = lhs, case .responseFlagFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.grpcStatusFilter, .grpcStatusFilter): return {
        guard case .grpcStatusFilter(let l) = lhs, case .grpcStatusFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.extensionFilter, .extensionFilter): return {
        guard case .extensionFilter(let l) = lhs, case .extensionFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metadataFilter, .metadataFilter): return {
        guard case .metadataFilter(let l) = lhs, case .metadataFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Filter on an integer comparison.
public struct Envoy_Config_Accesslog_V3_ComparisonFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Comparison operator.
  public var op: Envoy_Config_Accesslog_V3_ComparisonFilter.Op = .eq

  /// Value to compare against.
  public var value: Envoy_Config_Core_V3_RuntimeUInt32 {
    get {return _value ?? Envoy_Config_Core_V3_RuntimeUInt32()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Op: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// =
    case eq // = 0

    /// >=
    case ge // = 1

    /// <=
    case le // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .eq
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .eq
      case 1: self = .ge
      case 2: self = .le
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .eq: return 0
      case .ge: return 1
      case .le: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _value: Envoy_Config_Core_V3_RuntimeUInt32? = nil
}

#if swift(>=4.2)

extension Envoy_Config_Accesslog_V3_ComparisonFilter.Op: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Accesslog_V3_ComparisonFilter.Op] = [
    .eq,
    .ge,
    .le,
  ]
}

#endif  // swift(>=4.2)

/// Filters on HTTP response/status code.
public struct Envoy_Config_Accesslog_V3_StatusCodeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Comparison.
  public var comparison: Envoy_Config_Accesslog_V3_ComparisonFilter {
    get {return _comparison ?? Envoy_Config_Accesslog_V3_ComparisonFilter()}
    set {_comparison = newValue}
  }
  /// Returns true if `comparison` has been explicitly set.
  public var hasComparison: Bool {return self._comparison != nil}
  /// Clears the value of `comparison`. Subsequent reads from it will return its default value.
  public mutating func clearComparison() {self._comparison = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _comparison: Envoy_Config_Accesslog_V3_ComparisonFilter? = nil
}

/// Filters on total request duration in milliseconds.
public struct Envoy_Config_Accesslog_V3_DurationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Comparison.
  public var comparison: Envoy_Config_Accesslog_V3_ComparisonFilter {
    get {return _comparison ?? Envoy_Config_Accesslog_V3_ComparisonFilter()}
    set {_comparison = newValue}
  }
  /// Returns true if `comparison` has been explicitly set.
  public var hasComparison: Bool {return self._comparison != nil}
  /// Clears the value of `comparison`. Subsequent reads from it will return its default value.
  public mutating func clearComparison() {self._comparison = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _comparison: Envoy_Config_Accesslog_V3_ComparisonFilter? = nil
}

/// Filters for requests that are not health check requests. A health check
/// request is marked by the health check filter.
public struct Envoy_Config_Accesslog_V3_NotHealthCheckFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filters for requests that are traceable. See the tracing overview for more
/// information on how a request becomes traceable.
public struct Envoy_Config_Accesslog_V3_TraceableFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filters for random sampling of requests.
public struct Envoy_Config_Accesslog_V3_RuntimeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Runtime key to get an optional overridden numerator for use in the
  /// *percent_sampled* field. If found in runtime, this value will replace the
  /// default numerator.
  public var runtimeKey: String = String()

  /// The default sampling percentage. If not specified, defaults to 0% with
  /// denominator of 100.
  public var percentSampled: Envoy_Type_V3_FractionalPercent {
    get {return _percentSampled ?? Envoy_Type_V3_FractionalPercent()}
    set {_percentSampled = newValue}
  }
  /// Returns true if `percentSampled` has been explicitly set.
  public var hasPercentSampled: Bool {return self._percentSampled != nil}
  /// Clears the value of `percentSampled`. Subsequent reads from it will return its default value.
  public mutating func clearPercentSampled() {self._percentSampled = nil}

  /// By default, sampling pivots on the header
  /// :ref:`x-request-id<config_http_conn_man_headers_x-request-id>` being
  /// present. If :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`
  /// is present, the filter will consistently sample across multiple hosts based
  /// on the runtime key value and the value extracted from
  /// :ref:`x-request-id<config_http_conn_man_headers_x-request-id>`. If it is
  /// missing, or *use_independent_randomness* is set to true, the filter will
  /// randomly sample based on the runtime key value alone.
  /// *use_independent_randomness* can be used for logging kill switches within
  /// complex nested :ref:`AndFilter
  /// <envoy_api_msg_config.accesslog.v3.AndFilter>` and :ref:`OrFilter
  /// <envoy_api_msg_config.accesslog.v3.OrFilter>` blocks that are easier to
  /// reason about from a probability perspective (i.e., setting to true will
  /// cause the filter to behave like an independent random variable when
  /// composed within logical operator filters).
  public var useIndependentRandomness: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _percentSampled: Envoy_Type_V3_FractionalPercent? = nil
}

/// Performs a logical “and” operation on the result of each filter in filters.
/// Filters are evaluated sequentially and if one of them returns false, the
/// filter returns false immediately.
public struct Envoy_Config_Accesslog_V3_AndFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Envoy_Config_Accesslog_V3_AccessLogFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Performs a logical “or” operation on the result of each individual filter.
/// Filters are evaluated sequentially and if one of them returns true, the
/// filter returns true immediately.
public struct Envoy_Config_Accesslog_V3_OrFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Envoy_Config_Accesslog_V3_AccessLogFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filters requests based on the presence or value of a request header.
public struct Envoy_Config_Accesslog_V3_HeaderFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only requests with a header which matches the specified HeaderMatcher will
  /// pass the filter check.
  public var header: Envoy_Config_Route_V3_HeaderMatcher {
    get {return _header ?? Envoy_Config_Route_V3_HeaderMatcher()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _header: Envoy_Config_Route_V3_HeaderMatcher? = nil
}

/// Filters requests that received responses with an Envoy response flag set.
/// A list of the response flags can be found
/// in the access log formatter
/// :ref:`documentation<config_access_log_format_response_flags>`.
public struct Envoy_Config_Accesslog_V3_ResponseFlagFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only responses with the any of the flags listed in this field will be
  /// logged. This field is optional. If it is not specified, then any response
  /// flag will pass the filter check.
  public var flags: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filters gRPC requests based on their response status. If a gRPC status is not
/// provided, the filter will infer the status from the HTTP status code.
public struct Envoy_Config_Accesslog_V3_GrpcStatusFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Logs only responses that have any one of the gRPC statuses in this field.
  public var statuses: [Envoy_Config_Accesslog_V3_GrpcStatusFilter.Status] = []

  /// If included and set to true, the filter will instead block all responses
  /// with a gRPC status or inferred gRPC status enumerated in statuses, and
  /// allow all other responses.
  public var exclude: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case ok // = 0
    case canceled // = 1
    case unknown // = 2
    case invalidArgument // = 3
    case deadlineExceeded // = 4
    case notFound // = 5
    case alreadyExists // = 6
    case permissionDenied // = 7
    case resourceExhausted // = 8
    case failedPrecondition // = 9
    case aborted // = 10
    case outOfRange // = 11
    case unimplemented // = 12
    case `internal` // = 13
    case unavailable // = 14
    case dataLoss // = 15
    case unauthenticated // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .ok
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .canceled
      case 2: self = .unknown
      case 3: self = .invalidArgument
      case 4: self = .deadlineExceeded
      case 5: self = .notFound
      case 6: self = .alreadyExists
      case 7: self = .permissionDenied
      case 8: self = .resourceExhausted
      case 9: self = .failedPrecondition
      case 10: self = .aborted
      case 11: self = .outOfRange
      case 12: self = .unimplemented
      case 13: self = .internal
      case 14: self = .unavailable
      case 15: self = .dataLoss
      case 16: self = .unauthenticated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .ok: return 0
      case .canceled: return 1
      case .unknown: return 2
      case .invalidArgument: return 3
      case .deadlineExceeded: return 4
      case .notFound: return 5
      case .alreadyExists: return 6
      case .permissionDenied: return 7
      case .resourceExhausted: return 8
      case .failedPrecondition: return 9
      case .aborted: return 10
      case .outOfRange: return 11
      case .unimplemented: return 12
      case .internal: return 13
      case .unavailable: return 14
      case .dataLoss: return 15
      case .unauthenticated: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Config_Accesslog_V3_GrpcStatusFilter.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Accesslog_V3_GrpcStatusFilter.Status] = [
    .ok,
    .canceled,
    .unknown,
    .invalidArgument,
    .deadlineExceeded,
    .notFound,
    .alreadyExists,
    .permissionDenied,
    .resourceExhausted,
    .failedPrecondition,
    .aborted,
    .outOfRange,
    .unimplemented,
    .internal,
    .unavailable,
    .dataLoss,
    .unauthenticated,
  ]
}

#endif  // swift(>=4.2)

/// Filters based on matching dynamic metadata.
/// If the matcher path and key correspond to an existing key in dynamic
/// metadata, the request is logged only if the matcher value is equal to the
/// metadata value. If the matcher path and key *do not* correspond to an
/// existing key in dynamic metadata, the request is logged only if
/// match_if_key_not_found is "true" or unset.
public struct Envoy_Config_Accesslog_V3_MetadataFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Matcher to check metadata for specified value. For example, to match on the
  /// access_log_hint metadata, set the filter to "envoy.common" and the path to
  /// "access_log_hint", and the value to "true".
  public var matcher: Envoy_Type_Matcher_V3_MetadataMatcher {
    get {return _matcher ?? Envoy_Type_Matcher_V3_MetadataMatcher()}
    set {_matcher = newValue}
  }
  /// Returns true if `matcher` has been explicitly set.
  public var hasMatcher: Bool {return self._matcher != nil}
  /// Clears the value of `matcher`. Subsequent reads from it will return its default value.
  public mutating func clearMatcher() {self._matcher = nil}

  /// Default result if the key does not exist in dynamic metadata: if unset or
  /// true, then log; if false, then don't log.
  public var matchIfKeyNotFound: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _matchIfKeyNotFound ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_matchIfKeyNotFound = newValue}
  }
  /// Returns true if `matchIfKeyNotFound` has been explicitly set.
  public var hasMatchIfKeyNotFound: Bool {return self._matchIfKeyNotFound != nil}
  /// Clears the value of `matchIfKeyNotFound`. Subsequent reads from it will return its default value.
  public mutating func clearMatchIfKeyNotFound() {self._matchIfKeyNotFound = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _matcher: Envoy_Type_Matcher_V3_MetadataMatcher? = nil
  fileprivate var _matchIfKeyNotFound: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

/// Extension filter is statically registered at runtime.
public struct Envoy_Config_Accesslog_V3_ExtensionFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the filter implementation to instantiate. The name must
  /// match a statically registered filter.
  public var name: String = String()

  /// Custom configuration that depends on the filter being instantiated.
  public var configType: Envoy_Config_Accesslog_V3_ExtensionFilter.OneOf_ConfigType? = nil

  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .typedConfig(let v)? = configType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {configType = .typedConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Custom configuration that depends on the filter being instantiated.
  public enum OneOf_ConfigType: Equatable {
    case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Accesslog_V3_ExtensionFilter.OneOf_ConfigType, rhs: Envoy_Config_Accesslog_V3_ExtensionFilter.OneOf_ConfigType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.typedConfig, .typedConfig): return {
        guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.accesslog.v3"

extension Envoy_Config_Accesslog_V3_AccessLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "filter"),
    4: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_AccessLog, rhs: Envoy_Config_Accesslog_V3_AccessLog) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_AccessLogFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessLogFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "status_code_filter"),
    2: .standard(proto: "duration_filter"),
    3: .standard(proto: "not_health_check_filter"),
    4: .standard(proto: "traceable_filter"),
    5: .standard(proto: "runtime_filter"),
    6: .standard(proto: "and_filter"),
    7: .standard(proto: "or_filter"),
    8: .standard(proto: "header_filter"),
    9: .standard(proto: "response_flag_filter"),
    10: .standard(proto: "grpc_status_filter"),
    11: .standard(proto: "extension_filter"),
    12: .standard(proto: "metadata_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Config_Accesslog_V3_StatusCodeFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .statusCodeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .statusCodeFilter(v)}
      }()
      case 2: try {
        var v: Envoy_Config_Accesslog_V3_DurationFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .durationFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .durationFilter(v)}
      }()
      case 3: try {
        var v: Envoy_Config_Accesslog_V3_NotHealthCheckFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .notHealthCheckFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .notHealthCheckFilter(v)}
      }()
      case 4: try {
        var v: Envoy_Config_Accesslog_V3_TraceableFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .traceableFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .traceableFilter(v)}
      }()
      case 5: try {
        var v: Envoy_Config_Accesslog_V3_RuntimeFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .runtimeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .runtimeFilter(v)}
      }()
      case 6: try {
        var v: Envoy_Config_Accesslog_V3_AndFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .andFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .andFilter(v)}
      }()
      case 7: try {
        var v: Envoy_Config_Accesslog_V3_OrFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .orFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .orFilter(v)}
      }()
      case 8: try {
        var v: Envoy_Config_Accesslog_V3_HeaderFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .headerFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .headerFilter(v)}
      }()
      case 9: try {
        var v: Envoy_Config_Accesslog_V3_ResponseFlagFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .responseFlagFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .responseFlagFilter(v)}
      }()
      case 10: try {
        var v: Envoy_Config_Accesslog_V3_GrpcStatusFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .grpcStatusFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .grpcStatusFilter(v)}
      }()
      case 11: try {
        var v: Envoy_Config_Accesslog_V3_ExtensionFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .extensionFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .extensionFilter(v)}
      }()
      case 12: try {
        var v: Envoy_Config_Accesslog_V3_MetadataFilter?
        if let current = self.filterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .metadataFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.filterSpecifier = .metadataFilter(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.filterSpecifier {
    case .statusCodeFilter?: try {
      guard case .statusCodeFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .durationFilter?: try {
      guard case .durationFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .notHealthCheckFilter?: try {
      guard case .notHealthCheckFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .traceableFilter?: try {
      guard case .traceableFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .runtimeFilter?: try {
      guard case .runtimeFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .andFilter?: try {
      guard case .andFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .orFilter?: try {
      guard case .orFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .headerFilter?: try {
      guard case .headerFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .responseFlagFilter?: try {
      guard case .responseFlagFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .grpcStatusFilter?: try {
      guard case .grpcStatusFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .extensionFilter?: try {
      guard case .extensionFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .metadataFilter?: try {
      guard case .metadataFilter(let v)? = self.filterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_AccessLogFilter, rhs: Envoy_Config_Accesslog_V3_AccessLogFilter) -> Bool {
    if lhs.filterSpecifier != rhs.filterSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_ComparisonFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComparisonFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "op"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.op) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.op != .eq {
      try visitor.visitSingularEnumField(value: self.op, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_ComparisonFilter, rhs: Envoy_Config_Accesslog_V3_ComparisonFilter) -> Bool {
    if lhs.op != rhs.op {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_ComparisonFilter.Op: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EQ"),
    1: .same(proto: "GE"),
    2: .same(proto: "LE"),
  ]
}

extension Envoy_Config_Accesslog_V3_StatusCodeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusCodeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comparison"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._comparison) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._comparison {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_StatusCodeFilter, rhs: Envoy_Config_Accesslog_V3_StatusCodeFilter) -> Bool {
    if lhs._comparison != rhs._comparison {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_DurationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DurationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comparison"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._comparison) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._comparison {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_DurationFilter, rhs: Envoy_Config_Accesslog_V3_DurationFilter) -> Bool {
    if lhs._comparison != rhs._comparison {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_NotHealthCheckFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotHealthCheckFilter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_NotHealthCheckFilter, rhs: Envoy_Config_Accesslog_V3_NotHealthCheckFilter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_TraceableFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraceableFilter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_TraceableFilter, rhs: Envoy_Config_Accesslog_V3_TraceableFilter) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_RuntimeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "runtime_key"),
    2: .standard(proto: "percent_sampled"),
    3: .standard(proto: "use_independent_randomness"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runtimeKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._percentSampled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.useIndependentRandomness) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runtimeKey.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeKey, fieldNumber: 1)
    }
    if let v = self._percentSampled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.useIndependentRandomness != false {
      try visitor.visitSingularBoolField(value: self.useIndependentRandomness, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_RuntimeFilter, rhs: Envoy_Config_Accesslog_V3_RuntimeFilter) -> Bool {
    if lhs.runtimeKey != rhs.runtimeKey {return false}
    if lhs._percentSampled != rhs._percentSampled {return false}
    if lhs.useIndependentRandomness != rhs.useIndependentRandomness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_AndFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AndFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_AndFilter, rhs: Envoy_Config_Accesslog_V3_AndFilter) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_OrFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OrFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_OrFilter, rhs: Envoy_Config_Accesslog_V3_OrFilter) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_HeaderFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HeaderFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_HeaderFilter, rhs: Envoy_Config_Accesslog_V3_HeaderFilter) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_ResponseFlagFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseFlagFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.flags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.flags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.flags, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_ResponseFlagFilter, rhs: Envoy_Config_Accesslog_V3_ResponseFlagFilter) -> Bool {
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_GrpcStatusFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrpcStatusFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statuses"),
    2: .same(proto: "exclude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.statuses) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.exclude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statuses.isEmpty {
      try visitor.visitPackedEnumField(value: self.statuses, fieldNumber: 1)
    }
    if self.exclude != false {
      try visitor.visitSingularBoolField(value: self.exclude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_GrpcStatusFilter, rhs: Envoy_Config_Accesslog_V3_GrpcStatusFilter) -> Bool {
    if lhs.statuses != rhs.statuses {return false}
    if lhs.exclude != rhs.exclude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_GrpcStatusFilter.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CANCELED"),
    2: .same(proto: "UNKNOWN"),
    3: .same(proto: "INVALID_ARGUMENT"),
    4: .same(proto: "DEADLINE_EXCEEDED"),
    5: .same(proto: "NOT_FOUND"),
    6: .same(proto: "ALREADY_EXISTS"),
    7: .same(proto: "PERMISSION_DENIED"),
    8: .same(proto: "RESOURCE_EXHAUSTED"),
    9: .same(proto: "FAILED_PRECONDITION"),
    10: .same(proto: "ABORTED"),
    11: .same(proto: "OUT_OF_RANGE"),
    12: .same(proto: "UNIMPLEMENTED"),
    13: .same(proto: "INTERNAL"),
    14: .same(proto: "UNAVAILABLE"),
    15: .same(proto: "DATA_LOSS"),
    16: .same(proto: "UNAUTHENTICATED"),
  ]
}

extension Envoy_Config_Accesslog_V3_MetadataFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "matcher"),
    2: .standard(proto: "match_if_key_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._matcher) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._matchIfKeyNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._matcher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._matchIfKeyNotFound {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_MetadataFilter, rhs: Envoy_Config_Accesslog_V3_MetadataFilter) -> Bool {
    if lhs._matcher != rhs._matcher {return false}
    if lhs._matchIfKeyNotFound != rhs._matchIfKeyNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Accesslog_V3_ExtensionFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtensionFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Accesslog_V3_ExtensionFilter, rhs: Envoy_Config_Accesslog_V3_ExtensionFilter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

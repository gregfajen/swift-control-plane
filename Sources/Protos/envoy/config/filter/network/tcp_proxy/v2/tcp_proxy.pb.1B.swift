// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/filter/network/tcp_proxy/v2/tcp_proxy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 13]
public struct Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The prefix to use when emitting :ref:`statistics
  /// <config_network_filters_tcp_proxy_stats>`.
  public var statPrefix: String = String()

  public var clusterSpecifier: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.OneOf_ClusterSpecifier? = nil

  /// The upstream cluster to connect to.
  public var cluster: String {
    get {
      if case .cluster(let v)? = clusterSpecifier {return v}
      return String()
    }
    set {clusterSpecifier = .cluster(newValue)}
  }

  /// Multiple upstream clusters can be specified for a given route. The
  /// request is routed to one of the upstream clusters based on weights
  /// assigned to each cluster.
  public var weightedClusters: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster {
    get {
      if case .weightedClusters(let v)? = clusterSpecifier {return v}
      return Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster()
    }
    set {clusterSpecifier = .weightedClusters(newValue)}
  }

  /// Optional endpoint metadata match criteria. Only endpoints in the upstream
  /// cluster with metadata matching that set in metadata_match will be
  /// considered. The filter name should be specified as *envoy.lb*.
  public var metadataMatch: Envoy_Api_V2_Core_Metadata {
    get {return _metadataMatch ?? Envoy_Api_V2_Core_Metadata()}
    set {_metadataMatch = newValue}
  }
  /// Returns true if `metadataMatch` has been explicitly set.
  public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
  /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataMatch() {self._metadataMatch = nil}

  /// The idle timeout for connections managed by the TCP proxy filter. The idle timeout
  /// is defined as the period in which there are no bytes sent or received on either
  /// the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
  /// to 0s, the timeout will be disabled.
  ///
  /// .. warning::
  ///   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  ///   FIN packets, etc.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return self._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {self._idleTimeout = nil}

  /// [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
  /// filter. The idle timeout is defined as the period in which there is no
  /// active traffic. If not set, there is no idle timeout. When the idle timeout
  /// is reached the connection will be closed. The distinction between
  /// downstream_idle_timeout/upstream_idle_timeout provides a means to set
  /// timeout based on the last byte sent on the downstream/upstream connection.
  public var downstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _downstreamIdleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_downstreamIdleTimeout = newValue}
  }
  /// Returns true if `downstreamIdleTimeout` has been explicitly set.
  public var hasDownstreamIdleTimeout: Bool {return self._downstreamIdleTimeout != nil}
  /// Clears the value of `downstreamIdleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearDownstreamIdleTimeout() {self._downstreamIdleTimeout = nil}

  /// [#not-implemented-hide:]
  public var upstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _upstreamIdleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_upstreamIdleTimeout = newValue}
  }
  /// Returns true if `upstreamIdleTimeout` has been explicitly set.
  public var hasUpstreamIdleTimeout: Bool {return self._upstreamIdleTimeout != nil}
  /// Clears the value of `upstreamIdleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamIdleTimeout() {self._upstreamIdleTimeout = nil}

  /// Configuration for :ref:`access logs <arch_overview_access_logs>`
  /// emitted by the this tcp_proxy.
  public var accessLog: [Envoy_Config_Filter_Accesslog_V2_AccessLog] = []

  /// [#not-implemented-hide:] Deprecated.
  public var deprecatedV1: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1 {
    get {return _deprecatedV1 ?? Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1()}
    set {_deprecatedV1 = newValue}
  }
  /// Returns true if `deprecatedV1` has been explicitly set.
  public var hasDeprecatedV1: Bool {return self._deprecatedV1 != nil}
  /// Clears the value of `deprecatedV1`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecatedV1() {self._deprecatedV1 = nil}

  /// The maximum number of unsuccessful connection attempts that will be made before
  /// giving up. If the parameter is not specified, 1 connection attempt will be made.
  public var maxConnectAttempts: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxConnectAttempts ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxConnectAttempts = newValue}
  }
  /// Returns true if `maxConnectAttempts` has been explicitly set.
  public var hasMaxConnectAttempts: Bool {return self._maxConnectAttempts != nil}
  /// Clears the value of `maxConnectAttempts`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConnectAttempts() {self._maxConnectAttempts = nil}

  /// Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
  /// load balancing algorithms will select a host randomly. Currently the number of hash policies is
  /// limited to 1.
  public var hashPolicy: [Envoy_Type_HashPolicy] = []

  /// [#not-implemented-hide:] feature in progress
  /// If set, this configures tunneling, e.g. configuration options to tunnel multiple TCP
  /// payloads over a shared HTTP/2 tunnel. If this message is absent, the payload
  /// will be proxied upstream as per usual.
  public var tunnelingConfig: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.TunnelingConfig {
    get {return _tunnelingConfig ?? Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.TunnelingConfig()}
    set {_tunnelingConfig = newValue}
  }
  /// Returns true if `tunnelingConfig` has been explicitly set.
  public var hasTunnelingConfig: Bool {return self._tunnelingConfig != nil}
  /// Clears the value of `tunnelingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTunnelingConfig() {self._tunnelingConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterSpecifier: Equatable {
    /// The upstream cluster to connect to.
    case cluster(String)
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster.
    case weightedClusters(Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.OneOf_ClusterSpecifier, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.OneOf_ClusterSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cluster, .cluster): return {
        guard case .cluster(let l) = lhs, case .cluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weightedClusters, .weightedClusters): return {
        guard case .weightedClusters(let l) = lhs, case .weightedClusters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// [#not-implemented-hide:] Deprecated.
  /// TCP Proxy filter configuration using V1 format.
  public struct DeprecatedV1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The route table for the filter. All filter instances must have a route
    /// table, even if it is empty.
    public var routes: [Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1.TCPRoute] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A TCP proxy route consists of a set of optional L4 criteria and the
    /// name of a cluster. If a downstream connection matches all the
    /// specified criteria, the cluster in the route is used for the
    /// corresponding upstream connection. Routes are tried in the order
    /// specified until a match is found. If no match is found, the connection
    /// is closed. A route with no criteria is valid and always produces a
    /// match.
    /// [#next-free-field: 6]
    public struct TCPRoute {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The cluster to connect to when a the downstream network connection
      /// matches the specified criteria.
      public var cluster: String = String()

      /// An optional list of IP address subnets in the form
      /// “ip_address/xx”. The criteria is satisfied if the destination IP
      /// address of the downstream connection is contained in at least one of
      /// the specified subnets. If the parameter is not specified or the list
      /// is empty, the destination IP address is ignored. The destination IP
      /// address of the downstream connection might be different from the
      /// addresses on which the proxy is listening if the connection has been
      /// redirected.
      public var destinationIpList: [Envoy_Api_V2_Core_CidrRange] = []

      /// An optional string containing a comma-separated list of port numbers
      /// or ranges. The criteria is satisfied if the destination port of the
      /// downstream connection is contained in at least one of the specified
      /// ranges. If the parameter is not specified, the destination port is
      /// ignored. The destination port address of the downstream connection
      /// might be different from the port on which the proxy is listening if
      /// the connection has been redirected.
      public var destinationPorts: String = String()

      /// An optional list of IP address subnets in the form
      /// “ip_address/xx”. The criteria is satisfied if the source IP address
      /// of the downstream connection is contained in at least one of the
      /// specified subnets. If the parameter is not specified or the list is
      /// empty, the source IP address is ignored.
      public var sourceIpList: [Envoy_Api_V2_Core_CidrRange] = []

      /// An optional string containing a comma-separated list of port numbers
      /// or ranges. The criteria is satisfied if the source port of the
      /// downstream connection is contained in at least one of the specified
      /// ranges. If the parameter is not specified, the source port is
      /// ignored.
      public var sourcePorts: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Allows for specification of multiple upstream clusters along with weights
  /// that indicate the percentage of traffic to be forwarded to each cluster.
  /// The router selects an upstream cluster based on these weights.
  public struct WeightedCluster {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies one or more upstream clusters associated with the route.
    public var clusters: [Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster.ClusterWeight] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ClusterWeight {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Name of the upstream cluster.
      public var name: String = String()

      /// When a request matches the route, the choice of an upstream cluster is
      /// determined by its weight. The sum of weights across all entries in the
      /// clusters array determines the total weight.
      public var weight: UInt32 = 0

      /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
      /// in the upstream cluster with metadata matching what is set in this field will be considered
      /// for load balancing. Note that this will be merged with what's provided in
      /// :ref:`TcpProxy.metadata_match
      /// <envoy_api_field_config.filter.network.tcp_proxy.v2.TcpProxy.metadata_match>`, with values
      /// here taking precedence. The filter name should be specified as *envoy.lb*.
      public var metadataMatch: Envoy_Api_V2_Core_Metadata {
        get {return _metadataMatch ?? Envoy_Api_V2_Core_Metadata()}
        set {_metadataMatch = newValue}
      }
      /// Returns true if `metadataMatch` has been explicitly set.
      public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
      /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
      public mutating func clearMetadataMatch() {self._metadataMatch = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _metadataMatch: Envoy_Api_V2_Core_Metadata? = nil
    }

    public init() {}
  }

  /// Configuration for tunneling TCP over other transports or application layers.
  /// Currently, only HTTP/2 is supported. When other options exist, HTTP/2 will
  /// remain the default.
  public struct TunnelingConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    public var hostname: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _metadataMatch: Envoy_Api_V2_Core_Metadata? = nil
  fileprivate var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _downstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _upstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _deprecatedV1: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1? = nil
  fileprivate var _maxConnectAttempts: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _tunnelingConfig: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.TunnelingConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.filter.network.tcp_proxy.v2"

extension Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TcpProxy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_prefix"),
    2: .same(proto: "cluster"),
    10: .standard(proto: "weighted_clusters"),
    9: .standard(proto: "metadata_match"),
    8: .standard(proto: "idle_timeout"),
    3: .standard(proto: "downstream_idle_timeout"),
    4: .standard(proto: "upstream_idle_timeout"),
    5: .standard(proto: "access_log"),
    6: .standard(proto: "deprecated_v1"),
    7: .standard(proto: "max_connect_attempts"),
    11: .standard(proto: "hash_policy"),
    12: .standard(proto: "tunneling_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.statPrefix) }()
      case 2: try {
        if self.clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.clusterSpecifier = .cluster(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._downstreamIdleTimeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._upstreamIdleTimeout) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.accessLog) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deprecatedV1) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._maxConnectAttempts) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._idleTimeout) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._metadataMatch) }()
      case 10: try {
        var v: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster?
        if let current = self.clusterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .weightedClusters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.clusterSpecifier = .weightedClusters(v)}
      }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.hashPolicy) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._tunnelingConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.statPrefix, fieldNumber: 1)
    }
    if case .cluster(let v)? = self.clusterSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._downstreamIdleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._upstreamIdleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.accessLog.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLog, fieldNumber: 5)
    }
    if let v = self._deprecatedV1 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._maxConnectAttempts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._idleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if case .weightedClusters(let v)? = self.clusterSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.hashPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashPolicy, fieldNumber: 11)
    }
    if let v = self._tunnelingConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy) -> Bool {
    if lhs.statPrefix != rhs.statPrefix {return false}
    if lhs.clusterSpecifier != rhs.clusterSpecifier {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs._idleTimeout != rhs._idleTimeout {return false}
    if lhs._downstreamIdleTimeout != rhs._downstreamIdleTimeout {return false}
    if lhs._upstreamIdleTimeout != rhs._upstreamIdleTimeout {return false}
    if lhs.accessLog != rhs.accessLog {return false}
    if lhs._deprecatedV1 != rhs._deprecatedV1 {return false}
    if lhs._maxConnectAttempts != rhs._maxConnectAttempts {return false}
    if lhs.hashPolicy != rhs.hashPolicy {return false}
    if lhs._tunnelingConfig != rhs._tunnelingConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.protoMessageName + ".DeprecatedV1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1.TCPRoute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1.protoMessageName + ".TCPRoute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "destination_ip_list"),
    3: .standard(proto: "destination_ports"),
    4: .standard(proto: "source_ip_list"),
    5: .standard(proto: "source_ports"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.destinationIpList) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationPorts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.sourceIpList) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourcePorts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if !self.destinationIpList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.destinationIpList, fieldNumber: 2)
    }
    if !self.destinationPorts.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationPorts, fieldNumber: 3)
    }
    if !self.sourceIpList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sourceIpList, fieldNumber: 4)
    }
    if !self.sourcePorts.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePorts, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1.TCPRoute, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.DeprecatedV1.TCPRoute) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs.destinationIpList != rhs.destinationIpList {return false}
    if lhs.destinationPorts != rhs.destinationPorts {return false}
    if lhs.sourceIpList != rhs.sourceIpList {return false}
    if lhs.sourcePorts != rhs.sourcePorts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.protoMessageName + ".WeightedCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster.ClusterWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster.protoMessageName + ".ClusterWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "weight"),
    3: .standard(proto: "metadata_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadataMatch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.weight != 0 {
      try visitor.visitSingularUInt32Field(value: self.weight, fieldNumber: 2)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster.ClusterWeight, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.WeightedCluster.ClusterWeight) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.TunnelingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.protoMessageName + ".TunnelingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.TunnelingConfig, rhs: Envoy_Config_Filter_Network_TcpProxy_V2_TcpProxy.TunnelingConfig) -> Bool {
    if lhs.hostname != rhs.hostname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

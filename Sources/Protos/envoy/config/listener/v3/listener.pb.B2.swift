// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/listener/v3/listener.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 23]
public struct Envoy_Config_Listener_V3_Listener {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name by which this listener is known. If no name is provided,
  /// Envoy will allocate an internal UUID for the listener. If the listener is to be dynamically
  /// updated or removed via :ref:`LDS <config_listeners_lds>` a unique name must be provided.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The address that the listener should listen on. In general, the address must be unique, though
  /// that is governed by the bind rules of the OS. E.g., multiple listeners can listen on port 0 on
  /// Linux as the actual port will be allocated by the OS.
  public var address: Envoy_Config_Core_V3_Address {
    get {return _storage._address ?? Envoy_Config_Core_V3_Address()}
    set {_uniqueStorage()._address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return _storage._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {_uniqueStorage()._address = nil}

  /// A list of filter chains to consider for this listener. The
  /// :ref:`FilterChain <envoy_api_msg_config.listener.v3.FilterChain>` with the most specific
  /// :ref:`FilterChainMatch <envoy_api_msg_config.listener.v3.FilterChainMatch>` criteria is used on a
  /// connection.
  ///
  /// Example using SNI for filter chain selection can be found in the
  /// :ref:`FAQ entry <faq_how_to_setup_sni>`.
  public var filterChains: [Envoy_Config_Listener_V3_FilterChain] {
    get {return _storage._filterChains}
    set {_uniqueStorage()._filterChains = newValue}
  }

  /// Soft limit on size of the listenerâ€™s new connection read and write buffers.
  /// If unspecified, an implementation defined default is applied (1MiB).
  public var perConnectionBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._perConnectionBufferLimitBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._perConnectionBufferLimitBytes = newValue}
  }
  /// Returns true if `perConnectionBufferLimitBytes` has been explicitly set.
  public var hasPerConnectionBufferLimitBytes: Bool {return _storage._perConnectionBufferLimitBytes != nil}
  /// Clears the value of `perConnectionBufferLimitBytes`. Subsequent reads from it will return its default value.
  public mutating func clearPerConnectionBufferLimitBytes() {_uniqueStorage()._perConnectionBufferLimitBytes = nil}

  /// Listener metadata.
  public var metadata: Envoy_Config_Core_V3_Metadata {
    get {return _storage._metadata ?? Envoy_Config_Core_V3_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// [#not-implemented-hide:]
  public var deprecatedV1: Envoy_Config_Listener_V3_Listener.DeprecatedV1 {
    get {return _storage._deprecatedV1 ?? Envoy_Config_Listener_V3_Listener.DeprecatedV1()}
    set {_uniqueStorage()._deprecatedV1 = newValue}
  }
  /// Returns true if `deprecatedV1` has been explicitly set.
  public var hasDeprecatedV1: Bool {return _storage._deprecatedV1 != nil}
  /// Clears the value of `deprecatedV1`. Subsequent reads from it will return its default value.
  public mutating func clearDeprecatedV1() {_uniqueStorage()._deprecatedV1 = nil}

  /// The type of draining to perform at a listener-wide level.
  public var drainType: Envoy_Config_Listener_V3_Listener.DrainType {
    get {return _storage._drainType}
    set {_uniqueStorage()._drainType = newValue}
  }

  /// Listener filters have the opportunity to manipulate and augment the connection metadata that
  /// is used in connection filter chain matching, for example. These filters are run before any in
  /// :ref:`filter_chains <envoy_api_field_config.listener.v3.Listener.filter_chains>`. Order matters as the
  /// filters are processed sequentially right after a socket has been accepted by the listener, and
  /// before a connection is created.
  /// UDP Listener filters can be specified when the protocol in the listener socket address in
  /// :ref:`protocol <envoy_api_field_config.core.v3.SocketAddress.protocol>` is :ref:`UDP
  /// <envoy_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP>`.
  /// UDP listeners currently support a single filter.
  public var listenerFilters: [Envoy_Config_Listener_V3_ListenerFilter] {
    get {return _storage._listenerFilters}
    set {_uniqueStorage()._listenerFilters = newValue}
  }

  /// The timeout to wait for all listener filters to complete operation. If the timeout is reached,
  /// the accepted socket is closed without a connection being created unless
  /// `continue_on_listener_filters_timeout` is set to true. Specify 0 to disable the
  /// timeout. If not specified, a default timeout of 15s is used.
  public var listenerFiltersTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._listenerFiltersTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._listenerFiltersTimeout = newValue}
  }
  /// Returns true if `listenerFiltersTimeout` has been explicitly set.
  public var hasListenerFiltersTimeout: Bool {return _storage._listenerFiltersTimeout != nil}
  /// Clears the value of `listenerFiltersTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearListenerFiltersTimeout() {_uniqueStorage()._listenerFiltersTimeout = nil}

  /// Whether a connection should be created when listener filters timeout. Default is false.
  ///
  /// .. attention::
  ///
  ///   Some listener filters, such as :ref:`Proxy Protocol filter
  ///   <config_listener_filters_proxy_protocol>`, should not be used with this option. It will cause
  ///   unexpected behavior when a connection is created.
  public var continueOnListenerFiltersTimeout: Bool {
    get {return _storage._continueOnListenerFiltersTimeout}
    set {_uniqueStorage()._continueOnListenerFiltersTimeout = newValue}
  }

  /// Whether the listener should be set as a transparent socket.
  /// When this flag is set to true, connections can be redirected to the listener using an
  /// *iptables* *TPROXY* target, in which case the original source and destination addresses and
  /// ports are preserved on accepted connections. This flag should be used in combination with
  /// :ref:`an original_dst <config_listener_filters_original_dst>` :ref:`listener filter
  /// <envoy_api_field_config.listener.v3.Listener.listener_filters>` to mark the connections' local addresses as
  /// "restored." This can be used to hand off each redirected connection to another listener
  /// associated with the connection's destination address. Direct connections to the socket without
  /// using *TPROXY* cannot be distinguished from connections redirected using *TPROXY* and are
  /// therefore treated as if they were redirected.
  /// When this flag is set to false, the listener's socket is explicitly reset as non-transparent.
  /// Setting this flag requires Envoy to run with the *CAP_NET_ADMIN* capability.
  /// When this flag is not set (default), the socket is not modified, i.e. the transparent option
  /// is neither set nor reset.
  public var transparent: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._transparent ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._transparent = newValue}
  }
  /// Returns true if `transparent` has been explicitly set.
  public var hasTransparent: Bool {return _storage._transparent != nil}
  /// Clears the value of `transparent`. Subsequent reads from it will return its default value.
  public mutating func clearTransparent() {_uniqueStorage()._transparent = nil}

  /// Whether the listener should set the *IP_FREEBIND* socket option. When this
  /// flag is set to true, listeners can be bound to an IP address that is not
  /// configured on the system running Envoy. When this flag is set to false, the
  /// option *IP_FREEBIND* is disabled on the socket. When this flag is not set
  /// (default), the socket is not modified, i.e. the option is neither enabled
  /// nor disabled.
  public var freebind: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._freebind ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._freebind = newValue}
  }
  /// Returns true if `freebind` has been explicitly set.
  public var hasFreebind: Bool {return _storage._freebind != nil}
  /// Clears the value of `freebind`. Subsequent reads from it will return its default value.
  public mutating func clearFreebind() {_uniqueStorage()._freebind = nil}

  /// Additional socket options that may not be present in Envoy source code or
  /// precompiled binaries.
  public var socketOptions: [Envoy_Config_Core_V3_SocketOption] {
    get {return _storage._socketOptions}
    set {_uniqueStorage()._socketOptions = newValue}
  }

  /// Whether the listener should accept TCP Fast Open (TFO) connections.
  /// When this flag is set to a value greater than 0, the option TCP_FASTOPEN is enabled on
  /// the socket, with a queue length of the specified size
  /// (see `details in RFC7413 <https://tools.ietf.org/html/rfc7413#section-5.1>`_).
  /// When this flag is set to 0, the option TCP_FASTOPEN is disabled on the socket.
  /// When this flag is not set (default), the socket is not modified,
  /// i.e. the option is neither enabled nor disabled.
  ///
  /// On Linux, the net.ipv4.tcp_fastopen kernel parameter must include flag 0x2 to enable
  /// TCP_FASTOPEN.
  /// See `ip-sysctl.txt <https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt>`_.
  ///
  /// On macOS, only values of 0, 1, and unset are valid; other values may result in an error.
  /// To set the queue length on macOS, set the net.inet.tcp.fastopen_backlog kernel parameter.
  public var tcpFastOpenQueueLength: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._tcpFastOpenQueueLength ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._tcpFastOpenQueueLength = newValue}
  }
  /// Returns true if `tcpFastOpenQueueLength` has been explicitly set.
  public var hasTcpFastOpenQueueLength: Bool {return _storage._tcpFastOpenQueueLength != nil}
  /// Clears the value of `tcpFastOpenQueueLength`. Subsequent reads from it will return its default value.
  public mutating func clearTcpFastOpenQueueLength() {_uniqueStorage()._tcpFastOpenQueueLength = nil}

  /// Specifies the intended direction of the traffic relative to the local Envoy.
  public var trafficDirection: Envoy_Config_Core_V3_TrafficDirection {
    get {return _storage._trafficDirection}
    set {_uniqueStorage()._trafficDirection = newValue}
  }

  /// If the protocol in the listener socket address in :ref:`protocol
  /// <envoy_api_field_config.core.v3.SocketAddress.protocol>` is :ref:`UDP
  /// <envoy_api_enum_value_config.core.v3.SocketAddress.Protocol.UDP>`, this field specifies the actual udp
  /// listener to create, i.e. :ref:`udp_listener_name
  /// <envoy_api_field_config.listener.v3.UdpListenerConfig.udp_listener_name>` = "raw_udp_listener" for
  /// creating a packet-oriented UDP listener. If not present, treat it as "raw_udp_listener".
  public var udpListenerConfig: Envoy_Config_Listener_V3_UdpListenerConfig {
    get {return _storage._udpListenerConfig ?? Envoy_Config_Listener_V3_UdpListenerConfig()}
    set {_uniqueStorage()._udpListenerConfig = newValue}
  }
  /// Returns true if `udpListenerConfig` has been explicitly set.
  public var hasUdpListenerConfig: Bool {return _storage._udpListenerConfig != nil}
  /// Clears the value of `udpListenerConfig`. Subsequent reads from it will return its default value.
  public mutating func clearUdpListenerConfig() {_uniqueStorage()._udpListenerConfig = nil}

  /// Used to represent an API listener, which is used in non-proxy clients. The type of API
  /// exposed to the non-proxy application depends on the type of API listener.
  /// When this field is set, no other field except for :ref:`name<envoy_api_field_config.listener.v3.Listener.name>`
  /// should be set.
  ///
  /// .. note::
  ///
  ///  Currently only one ApiListener can be installed; and it can only be done via bootstrap config,
  ///  not LDS.
  ///
  /// [#next-major-version: In the v3 API, instead of this messy approach where the socket
  /// listener fields are directly in the top-level Listener message and the API listener types
  /// are in the ApiListener message, the socket listener messages should be in their own message,
  /// and the top-level Listener should essentially be a oneof that selects between the
  /// socket listener and the various types of API listener. That way, a given Listener message
  /// can structurally only contain the fields of the relevant type.]
  public var apiListener: Envoy_Config_Listener_V3_ApiListener {
    get {return _storage._apiListener ?? Envoy_Config_Listener_V3_ApiListener()}
    set {_uniqueStorage()._apiListener = newValue}
  }
  /// Returns true if `apiListener` has been explicitly set.
  public var hasApiListener: Bool {return _storage._apiListener != nil}
  /// Clears the value of `apiListener`. Subsequent reads from it will return its default value.
  public mutating func clearApiListener() {_uniqueStorage()._apiListener = nil}

  /// The listener's connection balancer configuration, currently only applicable to TCP listeners.
  /// If no configuration is specified, Envoy will not attempt to balance active connections between
  /// worker threads.
  public var connectionBalanceConfig: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig {
    get {return _storage._connectionBalanceConfig ?? Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig()}
    set {_uniqueStorage()._connectionBalanceConfig = newValue}
  }
  /// Returns true if `connectionBalanceConfig` has been explicitly set.
  public var hasConnectionBalanceConfig: Bool {return _storage._connectionBalanceConfig != nil}
  /// Clears the value of `connectionBalanceConfig`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionBalanceConfig() {_uniqueStorage()._connectionBalanceConfig = nil}

  /// When this flag is set to true, listeners set the *SO_REUSEPORT* socket option and
  /// create one socket for each worker thread. This makes inbound connections
  /// distribute among worker threads roughly evenly in cases where there are a high number
  /// of connections. When this flag is set to false, all worker threads share one socket.
  ///
  /// Before Linux v4.19-rc1, new TCP connections may be rejected during hot restart
  /// (see `3rd paragraph in 'soreuseport' commit message
  /// <https://github.com/torvalds/linux/commit/c617f398edd4db2b8567a28e89>`_).
  /// This issue was fixed by `tcp: Avoid TCP syncookie rejected by SO_REUSEPORT socket
  /// <https://github.com/torvalds/linux/commit/40a1227ea845a37ab197dd1caffb60b047fa36b1>`_.
  public var reusePort: Bool {
    get {return _storage._reusePort}
    set {_uniqueStorage()._reusePort = newValue}
  }

  /// Configuration for :ref:`access logs <arch_overview_access_logs>`
  /// emitted by this listener.
  public var accessLog: [Envoy_Config_Accesslog_V3_AccessLog] {
    get {return _storage._accessLog}
    set {_uniqueStorage()._accessLog = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum DrainType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Drain in response to calling /healthcheck/fail admin endpoint (along with the health check
    /// filter), listener removal/modification, and hot restart.
    case `default` // = 0

    /// Drain in response to listener removal/modification and hot restart. This setting does not
    /// include /healthcheck/fail. This setting may be desirable if Envoy is hosting both ingress
    /// and egress listeners.
    case modifyOnly // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .default
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .default
      case 1: self = .modifyOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .default: return 0
      case .modifyOnly: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// [#not-implemented-hide:]
  public struct DeprecatedV1 {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether the listener should bind to the port. A listener that doesn't
    /// bind can only receive connections redirected from other listeners that
    /// set use_original_dst parameter to true. Default is true.
    ///
    /// This is deprecated in v2, all Listeners will bind to their port. An
    /// additional filter chain must be created for every original destination
    /// port this listener may redirect to in v2, with the original port
    /// specified in the FilterChainMatch destination_port field.
    ///
    /// [#comment:TODO(PiotrSikora): Remove this once verified that we no longer need it.]
    public var bindToPort: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _bindToPort ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_bindToPort = newValue}
    }
    /// Returns true if `bindToPort` has been explicitly set.
    public var hasBindToPort: Bool {return self._bindToPort != nil}
    /// Clears the value of `bindToPort`. Subsequent reads from it will return its default value.
    public mutating func clearBindToPort() {self._bindToPort = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _bindToPort: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  /// Configuration for listener connection balancing.
  public struct ConnectionBalanceConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var balanceType: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.OneOf_BalanceType? = nil

    /// If specified, the listener will use the exact connection balancer.
    public var exactBalance: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance {
      get {
        if case .exactBalance(let v)? = balanceType {return v}
        return Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance()
      }
      set {balanceType = .exactBalance(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_BalanceType: Equatable {
      /// If specified, the listener will use the exact connection balancer.
      case exactBalance(Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.OneOf_BalanceType, rhs: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.OneOf_BalanceType) -> Bool {
        switch (lhs, rhs) {
        case (.exactBalance(let l), .exactBalance(let r)): return l == r
        }
      }
    #endif
    }

    /// A connection balancer implementation that does exact balancing. This means that a lock is
    /// held during balancing so that connection counts are nearly exactly balanced between worker
    /// threads. This is "nearly" exact in the sense that a connection might close in parallel thus
    /// making the counts incorrect, but this should be rectified on the next accept. This balancer
    /// sacrifices accept throughput for accuracy and should be used when there are a small number of
    /// connections that rarely cycle (e.g., service mesh gRPC egress).
    public struct ExactBalance {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Config_Listener_V3_Listener.DrainType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Config_Listener_V3_Listener.DrainType] = [
    .default,
    .modifyOnly,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.listener.v3"

extension Envoy_Config_Listener_V3_Listener: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Listener"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
    3: .standard(proto: "filter_chains"),
    5: .standard(proto: "per_connection_buffer_limit_bytes"),
    6: .same(proto: "metadata"),
    7: .standard(proto: "deprecated_v1"),
    8: .standard(proto: "drain_type"),
    9: .standard(proto: "listener_filters"),
    15: .standard(proto: "listener_filters_timeout"),
    17: .standard(proto: "continue_on_listener_filters_timeout"),
    10: .same(proto: "transparent"),
    11: .same(proto: "freebind"),
    13: .standard(proto: "socket_options"),
    12: .standard(proto: "tcp_fast_open_queue_length"),
    16: .standard(proto: "traffic_direction"),
    18: .standard(proto: "udp_listener_config"),
    19: .standard(proto: "api_listener"),
    20: .standard(proto: "connection_balance_config"),
    21: .standard(proto: "reuse_port"),
    22: .standard(proto: "access_log"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _address: Envoy_Config_Core_V3_Address? = nil
    var _filterChains: [Envoy_Config_Listener_V3_FilterChain] = []
    var _perConnectionBufferLimitBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _metadata: Envoy_Config_Core_V3_Metadata? = nil
    var _deprecatedV1: Envoy_Config_Listener_V3_Listener.DeprecatedV1? = nil
    var _drainType: Envoy_Config_Listener_V3_Listener.DrainType = .default
    var _listenerFilters: [Envoy_Config_Listener_V3_ListenerFilter] = []
    var _listenerFiltersTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _continueOnListenerFiltersTimeout: Bool = false
    var _transparent: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _freebind: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _socketOptions: [Envoy_Config_Core_V3_SocketOption] = []
    var _tcpFastOpenQueueLength: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _trafficDirection: Envoy_Config_Core_V3_TrafficDirection = .unspecified
    var _udpListenerConfig: Envoy_Config_Listener_V3_UdpListenerConfig? = nil
    var _apiListener: Envoy_Config_Listener_V3_ApiListener? = nil
    var _connectionBalanceConfig: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig? = nil
    var _reusePort: Bool = false
    var _accessLog: [Envoy_Config_Accesslog_V3_AccessLog] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _address = source._address
      _filterChains = source._filterChains
      _perConnectionBufferLimitBytes = source._perConnectionBufferLimitBytes
      _metadata = source._metadata
      _deprecatedV1 = source._deprecatedV1
      _drainType = source._drainType
      _listenerFilters = source._listenerFilters
      _listenerFiltersTimeout = source._listenerFiltersTimeout
      _continueOnListenerFiltersTimeout = source._continueOnListenerFiltersTimeout
      _transparent = source._transparent
      _freebind = source._freebind
      _socketOptions = source._socketOptions
      _tcpFastOpenQueueLength = source._tcpFastOpenQueueLength
      _trafficDirection = source._trafficDirection
      _udpListenerConfig = source._udpListenerConfig
      _apiListener = source._apiListener
      _connectionBalanceConfig = source._connectionBalanceConfig
      _reusePort = source._reusePort
      _accessLog = source._accessLog
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._name)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._address)
        case 3: try decoder.decodeRepeatedMessageField(value: &_storage._filterChains)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._perConnectionBufferLimitBytes)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._metadata)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._deprecatedV1)
        case 8: try decoder.decodeSingularEnumField(value: &_storage._drainType)
        case 9: try decoder.decodeRepeatedMessageField(value: &_storage._listenerFilters)
        case 10: try decoder.decodeSingularMessageField(value: &_storage._transparent)
        case 11: try decoder.decodeSingularMessageField(value: &_storage._freebind)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._tcpFastOpenQueueLength)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._socketOptions)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._listenerFiltersTimeout)
        case 16: try decoder.decodeSingularEnumField(value: &_storage._trafficDirection)
        case 17: try decoder.decodeSingularBoolField(value: &_storage._continueOnListenerFiltersTimeout)
        case 18: try decoder.decodeSingularMessageField(value: &_storage._udpListenerConfig)
        case 19: try decoder.decodeSingularMessageField(value: &_storage._apiListener)
        case 20: try decoder.decodeSingularMessageField(value: &_storage._connectionBalanceConfig)
        case 21: try decoder.decodeSingularBoolField(value: &_storage._reusePort)
        case 22: try decoder.decodeRepeatedMessageField(value: &_storage._accessLog)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._address {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._filterChains.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._filterChains, fieldNumber: 3)
      }
      if let v = _storage._perConnectionBufferLimitBytes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._deprecatedV1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._drainType != .default {
        try visitor.visitSingularEnumField(value: _storage._drainType, fieldNumber: 8)
      }
      if !_storage._listenerFilters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._listenerFilters, fieldNumber: 9)
      }
      if let v = _storage._transparent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._freebind {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._tcpFastOpenQueueLength {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._socketOptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._socketOptions, fieldNumber: 13)
      }
      if let v = _storage._listenerFiltersTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._trafficDirection != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._trafficDirection, fieldNumber: 16)
      }
      if _storage._continueOnListenerFiltersTimeout != false {
        try visitor.visitSingularBoolField(value: _storage._continueOnListenerFiltersTimeout, fieldNumber: 17)
      }
      if let v = _storage._udpListenerConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._apiListener {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._connectionBalanceConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if _storage._reusePort != false {
        try visitor.visitSingularBoolField(value: _storage._reusePort, fieldNumber: 21)
      }
      if !_storage._accessLog.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accessLog, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Listener_V3_Listener, rhs: Envoy_Config_Listener_V3_Listener) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._filterChains != rhs_storage._filterChains {return false}
        if _storage._perConnectionBufferLimitBytes != rhs_storage._perConnectionBufferLimitBytes {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._deprecatedV1 != rhs_storage._deprecatedV1 {return false}
        if _storage._drainType != rhs_storage._drainType {return false}
        if _storage._listenerFilters != rhs_storage._listenerFilters {return false}
        if _storage._listenerFiltersTimeout != rhs_storage._listenerFiltersTimeout {return false}
        if _storage._continueOnListenerFiltersTimeout != rhs_storage._continueOnListenerFiltersTimeout {return false}
        if _storage._transparent != rhs_storage._transparent {return false}
        if _storage._freebind != rhs_storage._freebind {return false}
        if _storage._socketOptions != rhs_storage._socketOptions {return false}
        if _storage._tcpFastOpenQueueLength != rhs_storage._tcpFastOpenQueueLength {return false}
        if _storage._trafficDirection != rhs_storage._trafficDirection {return false}
        if _storage._udpListenerConfig != rhs_storage._udpListenerConfig {return false}
        if _storage._apiListener != rhs_storage._apiListener {return false}
        if _storage._connectionBalanceConfig != rhs_storage._connectionBalanceConfig {return false}
        if _storage._reusePort != rhs_storage._reusePort {return false}
        if _storage._accessLog != rhs_storage._accessLog {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Listener_V3_Listener.DrainType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "MODIFY_ONLY"),
  ]
}

extension Envoy_Config_Listener_V3_Listener.DeprecatedV1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Listener_V3_Listener.protoMessageName + ".DeprecatedV1"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bind_to_port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._bindToPort)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bindToPort {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Listener_V3_Listener.DeprecatedV1, rhs: Envoy_Config_Listener_V3_Listener.DeprecatedV1) -> Bool {
    if lhs._bindToPort != rhs._bindToPort {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Listener_V3_Listener.protoMessageName + ".ConnectionBalanceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exact_balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance?
        if let current = self.balanceType {
          try decoder.handleConflictingOneOf()
          if case .exactBalance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.balanceType = .exactBalance(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .exactBalance(let v)? = self.balanceType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig, rhs: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig) -> Bool {
    if lhs.balanceType != rhs.balanceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.protoMessageName + ".ExactBalance"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance, rhs: Envoy_Config_Listener_V3_Listener.ConnectionBalanceConfig.ExactBalance) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

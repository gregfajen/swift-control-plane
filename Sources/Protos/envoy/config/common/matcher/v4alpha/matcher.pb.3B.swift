// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/config/common/matcher/v4alpha/matcher.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Match configuration. This is a recursive structure which allows complex nested match
/// configurations to be built using various logical operators.
/// [#next-free-field: 11]
public struct Envoy_Config_Common_Matcher_V4alpha_MatchPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rule: OneOf_Rule? {
    get {return _storage._rule}
    set {_uniqueStorage()._rule = newValue}
  }

  /// A set that describes a logical OR. If any member of the set matches, the match configuration
  /// matches.
  public var orMatch: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet {
    get {
      if case .orMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet()
    }
    set {_uniqueStorage()._rule = .orMatch(newValue)}
  }

  /// A set that describes a logical AND. If all members of the set match, the match configuration
  /// matches.
  public var andMatch: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet {
    get {
      if case .andMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet()
    }
    set {_uniqueStorage()._rule = .andMatch(newValue)}
  }

  /// A negation match. The match configuration will match if the negated match condition matches.
  public var notMatch: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate {
    get {
      if case .notMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_MatchPredicate()
    }
    set {_uniqueStorage()._rule = .notMatch(newValue)}
  }

  /// The match configuration will always match.
  public var anyMatch: Bool {
    get {
      if case .anyMatch(let v)? = _storage._rule {return v}
      return false
    }
    set {_uniqueStorage()._rule = .anyMatch(newValue)}
  }

  /// HTTP request headers match configuration.
  public var httpRequestHeadersMatch: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch {
    get {
      if case .httpRequestHeadersMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpRequestHeadersMatch(newValue)}
  }

  /// HTTP request trailers match configuration.
  public var httpRequestTrailersMatch: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch {
    get {
      if case .httpRequestTrailersMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpRequestTrailersMatch(newValue)}
  }

  /// HTTP response headers match configuration.
  public var httpResponseHeadersMatch: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch {
    get {
      if case .httpResponseHeadersMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpResponseHeadersMatch(newValue)}
  }

  /// HTTP response trailers match configuration.
  public var httpResponseTrailersMatch: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch {
    get {
      if case .httpResponseTrailersMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpResponseTrailersMatch(newValue)}
  }

  /// HTTP request generic body match configuration.
  public var httpRequestGenericBodyMatch: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch {
    get {
      if case .httpRequestGenericBodyMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch()
    }
    set {_uniqueStorage()._rule = .httpRequestGenericBodyMatch(newValue)}
  }

  /// HTTP response generic body match configuration.
  public var httpResponseGenericBodyMatch: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch {
    get {
      if case .httpResponseGenericBodyMatch(let v)? = _storage._rule {return v}
      return Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch()
    }
    set {_uniqueStorage()._rule = .httpResponseGenericBodyMatch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rule: Equatable {
    /// A set that describes a logical OR. If any member of the set matches, the match configuration
    /// matches.
    case orMatch(Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet)
    /// A set that describes a logical AND. If all members of the set match, the match configuration
    /// matches.
    case andMatch(Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet)
    /// A negation match. The match configuration will match if the negated match condition matches.
    case notMatch(Envoy_Config_Common_Matcher_V4alpha_MatchPredicate)
    /// The match configuration will always match.
    case anyMatch(Bool)
    /// HTTP request headers match configuration.
    case httpRequestHeadersMatch(Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch)
    /// HTTP request trailers match configuration.
    case httpRequestTrailersMatch(Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch)
    /// HTTP response headers match configuration.
    case httpResponseHeadersMatch(Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch)
    /// HTTP response trailers match configuration.
    case httpResponseTrailersMatch(Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch)
    /// HTTP request generic body match configuration.
    case httpRequestGenericBodyMatch(Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch)
    /// HTTP response generic body match configuration.
    case httpResponseGenericBodyMatch(Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.OneOf_Rule, rhs: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.orMatch, .orMatch): return {
        guard case .orMatch(let l) = lhs, case .orMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.andMatch, .andMatch): return {
        guard case .andMatch(let l) = lhs, case .andMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notMatch, .notMatch): return {
        guard case .notMatch(let l) = lhs, case .notMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.anyMatch, .anyMatch): return {
        guard case .anyMatch(let l) = lhs, case .anyMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpRequestHeadersMatch, .httpRequestHeadersMatch): return {
        guard case .httpRequestHeadersMatch(let l) = lhs, case .httpRequestHeadersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpRequestTrailersMatch, .httpRequestTrailersMatch): return {
        guard case .httpRequestTrailersMatch(let l) = lhs, case .httpRequestTrailersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpResponseHeadersMatch, .httpResponseHeadersMatch): return {
        guard case .httpResponseHeadersMatch(let l) = lhs, case .httpResponseHeadersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpResponseTrailersMatch, .httpResponseTrailersMatch): return {
        guard case .httpResponseTrailersMatch(let l) = lhs, case .httpResponseTrailersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpRequestGenericBodyMatch, .httpRequestGenericBodyMatch): return {
        guard case .httpRequestGenericBodyMatch(let l) = lhs, case .httpRequestGenericBodyMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpResponseGenericBodyMatch, .httpResponseGenericBodyMatch): return {
        guard case .httpResponseGenericBodyMatch(let l) = lhs, case .httpResponseGenericBodyMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A set of match configurations used for logical operations.
  public struct MatchSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of rules that make up the set.
    public var rules: [Envoy_Config_Common_Matcher_V4alpha_MatchPredicate] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// HTTP headers match configuration.
public struct Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HTTP headers to match.
  public var headers: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HTTP generic body match configuration.
/// List of text strings and hex strings to be located in HTTP body.
/// All specified strings must be found in the HTTP body for positive match.
/// The search may be limited to specified number of bytes from the body start.
///
/// .. attention::
///
///   Searching for patterns in HTTP body is potentially cpu intensive. For each specified pattern, http body is scanned byte by byte to find a match.
///   If multiple patterns are specified, the process is repeated for each pattern. If location of a pattern is known, ``bytes_limit`` should be specified
///   to scan only part of the http body.
public struct Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Limits search to specified number of bytes - default zero (no limit - match entire captured buffer).
  public var bytesLimit: UInt32 = 0

  /// List of patterns to match.
  public var patterns: [Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct GenericTextMatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var rule: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch.OneOf_Rule? = nil

    /// Text string to be located in HTTP body.
    public var stringMatch: String {
      get {
        if case .stringMatch(let v)? = rule {return v}
        return String()
      }
      set {rule = .stringMatch(newValue)}
    }

    /// Sequence of bytes to be located in HTTP body.
    public var binaryMatch: Data {
      get {
        if case .binaryMatch(let v)? = rule {return v}
        return Data()
      }
      set {rule = .binaryMatch(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Rule: Equatable {
      /// Text string to be located in HTTP body.
      case stringMatch(String)
      /// Sequence of bytes to be located in HTTP body.
      case binaryMatch(Data)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch.OneOf_Rule, rhs: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch.OneOf_Rule) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.stringMatch, .stringMatch): return {
          guard case .stringMatch(let l) = lhs, case .stringMatch(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.binaryMatch, .binaryMatch): return {
          guard case .binaryMatch(let l) = lhs, case .binaryMatch(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.config.common.matcher.v4alpha"

extension Envoy_Config_Common_Matcher_V4alpha_MatchPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "or_match"),
    2: .standard(proto: "and_match"),
    3: .standard(proto: "not_match"),
    4: .standard(proto: "any_match"),
    5: .standard(proto: "http_request_headers_match"),
    6: .standard(proto: "http_request_trailers_match"),
    7: .standard(proto: "http_response_headers_match"),
    8: .standard(proto: "http_response_trailers_match"),
    9: .standard(proto: "http_request_generic_body_match"),
    10: .standard(proto: "http_response_generic_body_match"),
  ]

  fileprivate class _StorageClass {
    var _rule: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.OneOf_Rule?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .orMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .orMatch(v)}
        }()
        case 2: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .andMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .andMatch(v)}
        }()
        case 3: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .notMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .notMatch(v)}
        }()
        case 4: try {
          if _storage._rule != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._rule = .anyMatch(v)}
        }()
        case 5: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpRequestHeadersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpRequestHeadersMatch(v)}
        }()
        case 6: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpRequestTrailersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpRequestTrailersMatch(v)}
        }()
        case 7: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpResponseHeadersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpResponseHeadersMatch(v)}
        }()
        case 8: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpResponseTrailersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpResponseTrailersMatch(v)}
        }()
        case 9: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpRequestGenericBodyMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpRequestGenericBodyMatch(v)}
        }()
        case 10: try {
          var v: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpResponseGenericBodyMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpResponseGenericBodyMatch(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._rule {
      case .orMatch?: try {
        guard case .orMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .andMatch?: try {
        guard case .andMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .notMatch?: try {
        guard case .notMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .anyMatch?: try {
        guard case .anyMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }()
      case .httpRequestHeadersMatch?: try {
        guard case .httpRequestHeadersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .httpRequestTrailersMatch?: try {
        guard case .httpRequestTrailersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .httpResponseHeadersMatch?: try {
        guard case .httpResponseHeadersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .httpResponseTrailersMatch?: try {
        guard case .httpResponseTrailersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .httpRequestGenericBodyMatch?: try {
        guard case .httpRequestGenericBodyMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .httpResponseGenericBodyMatch?: try {
        guard case .httpResponseGenericBodyMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate, rhs: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.protoMessageName + ".MatchSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet, rhs: Envoy_Config_Common_Matcher_V4alpha_MatchPredicate.MatchSet) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpHeadersMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch, rhs: Envoy_Config_Common_Matcher_V4alpha_HttpHeadersMatch) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpGenericBodyMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bytes_limit"),
    2: .same(proto: "patterns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.bytesLimit) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.patterns) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesLimit != 0 {
      try visitor.visitSingularUInt32Field(value: self.bytesLimit, fieldNumber: 1)
    }
    if !self.patterns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patterns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch, rhs: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch) -> Bool {
    if lhs.bytesLimit != rhs.bytesLimit {return false}
    if lhs.patterns != rhs.patterns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.protoMessageName + ".GenericTextMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_match"),
    2: .standard(proto: "binary_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.rule != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.rule = .stringMatch(v)}
      }()
      case 2: try {
        if self.rule != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.rule = .binaryMatch(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rule {
    case .stringMatch?: try {
      guard case .stringMatch(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .binaryMatch?: try {
      guard case .binaryMatch(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch, rhs: Envoy_Config_Common_Matcher_V4alpha_HttpGenericBodyMatch.GenericTextMatch) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

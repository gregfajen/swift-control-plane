// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/type/metadata/v3/metadata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MetadataKey provides a general interface using `key` and `path` to retrieve value from
/// :ref:`Metadata <envoy_api_msg_config.core.v3.Metadata>`.
///
/// For example, for the following Metadata:
///
/// .. code-block:: yaml
///
///    filter_metadata:
///      envoy.xxx:
///        prop:
///          foo: bar
///          xyz:
///            hello: envoy
///
/// The following MetadataKey will retrieve a string value "bar" from the Metadata.
///
/// .. code-block:: yaml
///
///    key: envoy.xxx
///    path:
///    - key: prop
///    - key: foo
public struct Envoy_Type_Metadata_V3_MetadataKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key name of Metadata to retrieve the Struct from the metadata.
  /// Typically, it represents a builtin subsystem or custom extension.
  public var key: String = String()

  /// The path to retrieve the Value from the Struct. It can be a prefix or a full path,
  /// e.g. ``[prop, xyz]`` for a struct or ``[prop, foo]`` for a string in the example,
  /// which depends on the particular scenario.
  ///
  /// Note: Due to that only the key type segment is supported, the path can not specify a list
  /// unless the list is the last segment.
  public var path: [Envoy_Type_Metadata_V3_MetadataKey.PathSegment] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the segment in a path to retrieve value from Metadata.
  /// Currently it is only supported to specify the key, i.e. field name, as one segment of a path.
  public struct PathSegment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var segment: Envoy_Type_Metadata_V3_MetadataKey.PathSegment.OneOf_Segment? = nil

    /// If specified, use the key to retrieve the value in a Struct.
    public var key: String {
      get {
        if case .key(let v)? = segment {return v}
        return String()
      }
      set {segment = .key(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Segment: Equatable {
      /// If specified, use the key to retrieve the value in a Struct.
      case key(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKey.PathSegment.OneOf_Segment, rhs: Envoy_Type_Metadata_V3_MetadataKey.PathSegment.OneOf_Segment) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.key, .key): return {
          guard case .key(let l) = lhs, case .key(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

/// Describes what kind of metadata.
public struct Envoy_Type_Metadata_V3_MetadataKind {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var kind: Envoy_Type_Metadata_V3_MetadataKind.OneOf_Kind? = nil

  /// Request kind of metadata.
  public var request: Envoy_Type_Metadata_V3_MetadataKind.Request {
    get {
      if case .request(let v)? = kind {return v}
      return Envoy_Type_Metadata_V3_MetadataKind.Request()
    }
    set {kind = .request(newValue)}
  }

  /// Route kind of metadata.
  public var route: Envoy_Type_Metadata_V3_MetadataKind.Route {
    get {
      if case .route(let v)? = kind {return v}
      return Envoy_Type_Metadata_V3_MetadataKind.Route()
    }
    set {kind = .route(newValue)}
  }

  /// Cluster kind of metadata.
  public var cluster: Envoy_Type_Metadata_V3_MetadataKind.Cluster {
    get {
      if case .cluster(let v)? = kind {return v}
      return Envoy_Type_Metadata_V3_MetadataKind.Cluster()
    }
    set {kind = .cluster(newValue)}
  }

  /// Host kind of metadata.
  public var host: Envoy_Type_Metadata_V3_MetadataKind.Host {
    get {
      if case .host(let v)? = kind {return v}
      return Envoy_Type_Metadata_V3_MetadataKind.Host()
    }
    set {kind = .host(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Kind: Equatable {
    /// Request kind of metadata.
    case request(Envoy_Type_Metadata_V3_MetadataKind.Request)
    /// Route kind of metadata.
    case route(Envoy_Type_Metadata_V3_MetadataKind.Route)
    /// Cluster kind of metadata.
    case cluster(Envoy_Type_Metadata_V3_MetadataKind.Cluster)
    /// Host kind of metadata.
    case host(Envoy_Type_Metadata_V3_MetadataKind.Host)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKind.OneOf_Kind, rhs: Envoy_Type_Metadata_V3_MetadataKind.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.request, .request): return {
        guard case .request(let l) = lhs, case .request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.route, .route): return {
        guard case .route(let l) = lhs, case .route(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cluster, .cluster): return {
        guard case .cluster(let l) = lhs, case .cluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.host, .host): return {
        guard case .host(let l) = lhs, case .host(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Represents dynamic metadata associated with the request.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Represents metadata from :ref:`the route<envoy_api_field_config.route.v3.Route.metadata>`.
  public struct Route {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Represents metadata from :ref:`the upstream cluster<envoy_api_field_config.cluster.v3.Cluster.metadata>`.
  public struct Cluster {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Represents metadata from :ref:`the upstream
  /// host<envoy_api_field_config.endpoint.v3.LbEndpoint.metadata>`.
  public struct Host {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.type.metadata.v3"

extension Envoy_Type_Metadata_V3_MetadataKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKey, rhs: Envoy_Type_Metadata_V3_MetadataKey) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Metadata_V3_MetadataKey.PathSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Metadata_V3_MetadataKey.protoMessageName + ".PathSegment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.segment != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.segment = .key(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .key(let v)? = self.segment {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKey.PathSegment, rhs: Envoy_Type_Metadata_V3_MetadataKey.PathSegment) -> Bool {
    if lhs.segment != rhs.segment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Metadata_V3_MetadataKind: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataKind"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "route"),
    3: .same(proto: "cluster"),
    4: .same(proto: "host"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Type_Metadata_V3_MetadataKind.Request?
        if let current = self.kind {
          try decoder.handleConflictingOneOf()
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.kind = .request(v)}
      }()
      case 2: try {
        var v: Envoy_Type_Metadata_V3_MetadataKind.Route?
        if let current = self.kind {
          try decoder.handleConflictingOneOf()
          if case .route(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.kind = .route(v)}
      }()
      case 3: try {
        var v: Envoy_Type_Metadata_V3_MetadataKind.Cluster?
        if let current = self.kind {
          try decoder.handleConflictingOneOf()
          if case .cluster(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.kind = .cluster(v)}
      }()
      case 4: try {
        var v: Envoy_Type_Metadata_V3_MetadataKind.Host?
        if let current = self.kind {
          try decoder.handleConflictingOneOf()
          if case .host(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.kind = .host(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.kind {
    case .request?: try {
      guard case .request(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .route?: try {
      guard case .route(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cluster?: try {
      guard case .cluster(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .host?: try {
      guard case .host(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKind, rhs: Envoy_Type_Metadata_V3_MetadataKind) -> Bool {
    if lhs.kind != rhs.kind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Metadata_V3_MetadataKind.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Metadata_V3_MetadataKind.protoMessageName + ".Request"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKind.Request, rhs: Envoy_Type_Metadata_V3_MetadataKind.Request) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Metadata_V3_MetadataKind.Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Metadata_V3_MetadataKind.protoMessageName + ".Route"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKind.Route, rhs: Envoy_Type_Metadata_V3_MetadataKind.Route) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Metadata_V3_MetadataKind.Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Metadata_V3_MetadataKind.protoMessageName + ".Cluster"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKind.Cluster, rhs: Envoy_Type_Metadata_V3_MetadataKind.Cluster) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Metadata_V3_MetadataKind.Host: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Metadata_V3_MetadataKind.protoMessageName + ".Host"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Metadata_V3_MetadataKind.Host, rhs: Envoy_Type_Metadata_V3_MetadataKind.Host) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

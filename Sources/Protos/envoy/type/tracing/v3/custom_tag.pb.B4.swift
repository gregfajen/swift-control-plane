// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/type/tracing/v3/custom_tag.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes custom tags for the active span.
/// [#next-free-field: 6]
public struct Envoy_Type_Tracing_V3_CustomTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Used to populate the tag name.
  public var tag: String = String()

  /// Used to specify what kind of custom tag.
  public var type: Envoy_Type_Tracing_V3_CustomTag.OneOf_Type? = nil

  /// A literal custom tag.
  public var literal: Envoy_Type_Tracing_V3_CustomTag.Literal {
    get {
      if case .literal(let v)? = type {return v}
      return Envoy_Type_Tracing_V3_CustomTag.Literal()
    }
    set {type = .literal(newValue)}
  }

  /// An environment custom tag.
  public var environment: Envoy_Type_Tracing_V3_CustomTag.Environment {
    get {
      if case .environment(let v)? = type {return v}
      return Envoy_Type_Tracing_V3_CustomTag.Environment()
    }
    set {type = .environment(newValue)}
  }

  /// A request header custom tag.
  public var requestHeader: Envoy_Type_Tracing_V3_CustomTag.Header {
    get {
      if case .requestHeader(let v)? = type {return v}
      return Envoy_Type_Tracing_V3_CustomTag.Header()
    }
    set {type = .requestHeader(newValue)}
  }

  /// A custom tag to obtain tag value from the metadata.
  public var metadata: Envoy_Type_Tracing_V3_CustomTag.Metadata {
    get {
      if case .metadata(let v)? = type {return v}
      return Envoy_Type_Tracing_V3_CustomTag.Metadata()
    }
    set {type = .metadata(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Used to specify what kind of custom tag.
  public enum OneOf_Type: Equatable {
    /// A literal custom tag.
    case literal(Envoy_Type_Tracing_V3_CustomTag.Literal)
    /// An environment custom tag.
    case environment(Envoy_Type_Tracing_V3_CustomTag.Environment)
    /// A request header custom tag.
    case requestHeader(Envoy_Type_Tracing_V3_CustomTag.Header)
    /// A custom tag to obtain tag value from the metadata.
    case metadata(Envoy_Type_Tracing_V3_CustomTag.Metadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Type_Tracing_V3_CustomTag.OneOf_Type, rhs: Envoy_Type_Tracing_V3_CustomTag.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.literal, .literal): return {
        guard case .literal(let l) = lhs, case .literal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.environment, .environment): return {
        guard case .environment(let l) = lhs, case .environment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestHeader, .requestHeader): return {
        guard case .requestHeader(let l) = lhs, case .requestHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metadata, .metadata): return {
        guard case .metadata(let l) = lhs, case .metadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Literal type custom tag with static value for the tag value.
  public struct Literal {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Static literal value to populate the tag value.
    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Environment type custom tag with environment name and default value.
  public struct Environment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Environment variable name to obtain the value to populate the tag value.
    public var name: String = String()

    /// When the environment variable is not found,
    /// the tag value will be populated with this default value if specified,
    /// otherwise no tag will be populated.
    public var defaultValue: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Header type custom tag with header name and default value.
  public struct Header {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Header name to obtain the value to populate the tag value.
    public var name: String = String()

    /// When the header does not exist,
    /// the tag value will be populated with this default value if specified,
    /// otherwise no tag will be populated.
    public var defaultValue: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Metadata type custom tag using
  /// :ref:`MetadataKey <envoy_api_msg_type.metadata.v3.MetadataKey>` to retrieve the protobuf value
  /// from :ref:`Metadata <envoy_api_msg_config.core.v3.Metadata>`, and populate the tag value with
  /// `the canonical JSON <https://developers.google.com/protocol-buffers/docs/proto3#json>`_
  /// representation of it.
  public struct Metadata {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specify what kind of metadata to obtain tag value from.
    public var kind: Envoy_Type_Metadata_V3_MetadataKind {
      get {return _kind ?? Envoy_Type_Metadata_V3_MetadataKind()}
      set {_kind = newValue}
    }
    /// Returns true if `kind` has been explicitly set.
    public var hasKind: Bool {return self._kind != nil}
    /// Clears the value of `kind`. Subsequent reads from it will return its default value.
    public mutating func clearKind() {self._kind = nil}

    /// Metadata key to define the path to retrieve the tag value.
    public var metadataKey: Envoy_Type_Metadata_V3_MetadataKey {
      get {return _metadataKey ?? Envoy_Type_Metadata_V3_MetadataKey()}
      set {_metadataKey = newValue}
    }
    /// Returns true if `metadataKey` has been explicitly set.
    public var hasMetadataKey: Bool {return self._metadataKey != nil}
    /// Clears the value of `metadataKey`. Subsequent reads from it will return its default value.
    public mutating func clearMetadataKey() {self._metadataKey = nil}

    /// When no valid metadata is found,
    /// the tag value would be populated with this default value if specified,
    /// otherwise no tag would be populated.
    public var defaultValue: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _kind: Envoy_Type_Metadata_V3_MetadataKind? = nil
    fileprivate var _metadataKey: Envoy_Type_Metadata_V3_MetadataKey? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.type.tracing.v3"

extension Envoy_Type_Tracing_V3_CustomTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .same(proto: "literal"),
    3: .same(proto: "environment"),
    4: .standard(proto: "request_header"),
    5: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      case 2: try {
        var v: Envoy_Type_Tracing_V3_CustomTag.Literal?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .literal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .literal(v)}
      }()
      case 3: try {
        var v: Envoy_Type_Tracing_V3_CustomTag.Environment?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .environment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .environment(v)}
      }()
      case 4: try {
        var v: Envoy_Type_Tracing_V3_CustomTag.Header?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .requestHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .requestHeader(v)}
      }()
      case 5: try {
        var v: Envoy_Type_Tracing_V3_CustomTag.Metadata?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .metadata(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .literal?: try {
      guard case .literal(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .environment?: try {
      guard case .environment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .requestHeader?: try {
      guard case .requestHeader(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .metadata?: try {
      guard case .metadata(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Tracing_V3_CustomTag, rhs: Envoy_Type_Tracing_V3_CustomTag) -> Bool {
    if lhs.tag != rhs.tag {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Tracing_V3_CustomTag.Literal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Tracing_V3_CustomTag.protoMessageName + ".Literal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Tracing_V3_CustomTag.Literal, rhs: Envoy_Type_Tracing_V3_CustomTag.Literal) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Tracing_V3_CustomTag.Environment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Tracing_V3_CustomTag.protoMessageName + ".Environment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Tracing_V3_CustomTag.Environment, rhs: Envoy_Type_Tracing_V3_CustomTag.Environment) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Tracing_V3_CustomTag.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Tracing_V3_CustomTag.protoMessageName + ".Header"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Tracing_V3_CustomTag.Header, rhs: Envoy_Type_Tracing_V3_CustomTag.Header) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Type_Tracing_V3_CustomTag.Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Type_Tracing_V3_CustomTag.protoMessageName + ".Metadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "kind"),
    2: .standard(proto: "metadata_key"),
    3: .standard(proto: "default_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kind) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadataKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.defaultValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kind {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._metadataKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.defaultValue.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultValue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Type_Tracing_V3_CustomTag.Metadata, rhs: Envoy_Type_Tracing_V3_CustomTag.Metadata) -> Bool {
    if lhs._kind != rhs._kind {return false}
    if lhs._metadataKey != rhs._metadataKey {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

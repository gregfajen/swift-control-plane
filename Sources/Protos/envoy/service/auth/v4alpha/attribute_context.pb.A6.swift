// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/service/auth/v4alpha/attribute_context.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An attribute is a piece of metadata that describes an activity on a network.
/// For example, the size of an HTTP request, or the status code of an HTTP response.
///
/// Each attribute has a type and a name, which is logically defined as a proto message field
/// of the `AttributeContext`. The `AttributeContext` is a collection of individual attributes
/// supported by Envoy authorization system.
/// [#comment: The following items are left out of this proto
/// Request.Auth field for jwt tokens
/// Request.Api for api management
/// Origin peer that originated the request
/// Caching Protocol
/// request_context return values to inject back into the filter chain
/// peer.claims -- from X.509 extensions
/// Configuration
/// - field mask to send
/// - which return values from request_context are copied back
/// - which return values are copied into request_headers]
/// [#next-free-field: 12]
public struct Envoy_Service_Auth_V4alpha_AttributeContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The source of a network activity, such as starting a TCP connection.
  /// In a multi hop network activity, the source represents the sender of the
  /// last hop.
  public var source: Envoy_Service_Auth_V4alpha_AttributeContext.Peer {
    get {return _storage._source ?? Envoy_Service_Auth_V4alpha_AttributeContext.Peer()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {_uniqueStorage()._source = nil}

  /// The destination of a network activity, such as accepting a TCP connection.
  /// In a multi hop network activity, the destination represents the receiver of
  /// the last hop.
  public var destination: Envoy_Service_Auth_V4alpha_AttributeContext.Peer {
    get {return _storage._destination ?? Envoy_Service_Auth_V4alpha_AttributeContext.Peer()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  /// Represents a network request, such as an HTTP request.
  public var request: Envoy_Service_Auth_V4alpha_AttributeContext.Request {
    get {return _storage._request ?? Envoy_Service_Auth_V4alpha_AttributeContext.Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {_uniqueStorage()._request = nil}

  /// This is analogous to http_request.headers, however these contents will not be sent to the
  /// upstream server. Context_extensions provide an extension mechanism for sending additional
  /// information to the auth server without modifying the proto definition. It maps to the
  /// internal opaque context in the filter chain.
  public var contextExtensions: Dictionary<String,String> {
    get {return _storage._contextExtensions}
    set {_uniqueStorage()._contextExtensions = newValue}
  }

  /// Dynamic metadata associated with the request.
  public var metadataContext: Envoy_Config_Core_V4alpha_Metadata {
    get {return _storage._metadataContext ?? Envoy_Config_Core_V4alpha_Metadata()}
    set {_uniqueStorage()._metadataContext = newValue}
  }
  /// Returns true if `metadataContext` has been explicitly set.
  public var hasMetadataContext: Bool {return _storage._metadataContext != nil}
  /// Clears the value of `metadataContext`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataContext() {_uniqueStorage()._metadataContext = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This message defines attributes for a node that handles a network request.
  /// The node can be either a service or an application that sends, forwards,
  /// or receives the request. Service peers should fill in the `service`,
  /// `principal`, and `labels` as appropriate.
  /// [#next-free-field: 6]
  public struct Peer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The address of the peer, this is typically the IP address.
    /// It can also be UDS path, or others.
    public var address: Envoy_Config_Core_V4alpha_Address {
      get {return _address ?? Envoy_Config_Core_V4alpha_Address()}
      set {_address = newValue}
    }
    /// Returns true if `address` has been explicitly set.
    public var hasAddress: Bool {return self._address != nil}
    /// Clears the value of `address`. Subsequent reads from it will return its default value.
    public mutating func clearAddress() {self._address = nil}

    /// The canonical service name of the peer.
    /// It should be set to :ref:`the HTTP x-envoy-downstream-service-cluster
    /// <config_http_conn_man_headers_downstream-service-cluster>`
    /// If a more trusted source of the service name is available through mTLS/secure naming, it
    /// should be used.
    public var service: String = String()

    /// The labels associated with the peer.
    /// These could be pod labels for Kubernetes or tags for VMs.
    /// The source of the labels could be an X.509 certificate or other configuration.
    public var labels: Dictionary<String,String> = [:]

    /// The authenticated identity of this peer.
    /// For example, the identity associated with the workload such as a service account.
    /// If an X.509 certificate is used to assert the identity this field should be sourced from
    /// `URI Subject Alternative Names`, `DNS Subject Alternate Names` or `Subject` in that order.
    /// The primary identity should be the principal. The principal format is issuer specific.
    ///
    /// Example:
    /// *    SPIFFE format is `spiffe://trust-domain/path`
    /// *    Google account format is `https://accounts.google.com/{userid}`
    public var principal: String = String()

    /// The X.509 certificate used to authenticate the identify of this peer.
    /// When present, the certificate contents are encoded in URL and PEM format.
    public var certificate: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _address: Envoy_Config_Core_V4alpha_Address? = nil
  }

  /// Represents a network request, such as an HTTP request.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The timestamp when the proxy receives the first byte of the request.
    public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {self._time = nil}

    /// Represents an HTTP request or an HTTP-like request.
    public var http: Envoy_Service_Auth_V4alpha_AttributeContext.HttpRequest {
      get {return _http ?? Envoy_Service_Auth_V4alpha_AttributeContext.HttpRequest()}
      set {_http = newValue}
    }
    /// Returns true if `http` has been explicitly set.
    public var hasHTTP: Bool {return self._http != nil}
    /// Clears the value of `http`. Subsequent reads from it will return its default value.
    public mutating func clearHTTP() {self._http = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _http: Envoy_Service_Auth_V4alpha_AttributeContext.HttpRequest? = nil
  }

  /// This message defines attributes for an HTTP request.
  /// HTTP/1.x, HTTP/2, gRPC are all considered as HTTP requests.
  /// [#next-free-field: 13]
  public struct HttpRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unique ID for a request, which can be propagated to downstream
    /// systems. The ID should have low probability of collision
    /// within a single day for a specific service.
    /// For HTTP requests, it should be X-Request-ID or equivalent.
    public var id: String = String()

    /// The HTTP request method, such as `GET`, `POST`.
    public var method: String = String()

    /// The HTTP request headers. If multiple headers share the same key, they
    /// must be merged according to the HTTP spec. All header keys must be
    /// lower-cased, because HTTP header keys are case-insensitive.
    public var headers: Dictionary<String,String> = [:]

    /// The request target, as it appears in the first line of the HTTP request. This includes
    /// the URL path and query-string. No decoding is performed.
    public var path: String = String()

    /// The HTTP request `Host` or 'Authority` header value.
    public var host: String = String()

    /// The HTTP URL scheme, such as `http` and `https`.
    public var scheme: String = String()

    /// This field is always empty, and exists for compatibility reasons. The HTTP URL query is
    /// included in `path` field.
    public var query: String = String()

    /// This field is always empty, and exists for compatibility reasons. The URL fragment is
    /// not submitted as part of HTTP requests; it is unknowable.
    public var fragment: String = String()

    /// The HTTP request size in bytes. If unknown, it must be -1.
    public var size: Int64 = 0

    /// The network protocol used with the request, such as "HTTP/1.0", "HTTP/1.1", or "HTTP/2".
    ///
    /// See :repo:`headers.h:ProtocolStrings <source/common/http/headers.h>` for a list of all
    /// possible values.
    public var `protocol`: String = String()

    /// The HTTP request body.
    public var body: String = String()

    /// The HTTP request body in bytes. This is used instead of
    /// :ref:`body <envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` when
    /// :ref:`pack_as_bytes <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.BufferSettings.pack_as_bytes>`
    /// is set to true.
    public var rawBody: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.service.auth.v4alpha"

extension Envoy_Service_Auth_V4alpha_AttributeContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "destination"),
    4: .same(proto: "request"),
    10: .standard(proto: "context_extensions"),
    11: .standard(proto: "metadata_context"),
  ]

  fileprivate class _StorageClass {
    var _source: Envoy_Service_Auth_V4alpha_AttributeContext.Peer? = nil
    var _destination: Envoy_Service_Auth_V4alpha_AttributeContext.Peer? = nil
    var _request: Envoy_Service_Auth_V4alpha_AttributeContext.Request? = nil
    var _contextExtensions: Dictionary<String,String> = [:]
    var _metadataContext: Envoy_Config_Core_V4alpha_Metadata? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _source = source._source
      _destination = source._destination
      _request = source._request
      _contextExtensions = source._contextExtensions
      _metadataContext = source._metadataContext
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._destination) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._contextExtensions) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._metadataContext) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._contextExtensions.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._contextExtensions, fieldNumber: 10)
      }
      if let v = _storage._metadataContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_AttributeContext, rhs: Envoy_Service_Auth_V4alpha_AttributeContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._source != rhs_storage._source {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._contextExtensions != rhs_storage._contextExtensions {return false}
        if _storage._metadataContext != rhs_storage._metadataContext {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Auth_V4alpha_AttributeContext.Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Service_Auth_V4alpha_AttributeContext.protoMessageName + ".Peer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "service"),
    3: .same(proto: "labels"),
    4: .same(proto: "principal"),
    5: .same(proto: "certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.principal) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.certificate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 3)
    }
    if !self.principal.isEmpty {
      try visitor.visitSingularStringField(value: self.principal, fieldNumber: 4)
    }
    if !self.certificate.isEmpty {
      try visitor.visitSingularStringField(value: self.certificate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_AttributeContext.Peer, rhs: Envoy_Service_Auth_V4alpha_AttributeContext.Peer) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.service != rhs.service {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.principal != rhs.principal {return false}
    if lhs.certificate != rhs.certificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Auth_V4alpha_AttributeContext.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Service_Auth_V4alpha_AttributeContext.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "http"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._http) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._http {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_AttributeContext.Request, rhs: Envoy_Service_Auth_V4alpha_AttributeContext.Request) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._http != rhs._http {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Auth_V4alpha_AttributeContext.HttpRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Service_Auth_V4alpha_AttributeContext.protoMessageName + ".HttpRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "method"),
    3: .same(proto: "headers"),
    4: .same(proto: "path"),
    5: .same(proto: "host"),
    6: .same(proto: "scheme"),
    7: .same(proto: "query"),
    8: .same(proto: "fragment"),
    9: .same(proto: "size"),
    10: .same(proto: "protocol"),
    11: .same(proto: "body"),
    12: .standard(proto: "raw_body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.method) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.scheme) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.fragment) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.body) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.rawBody) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.method.isEmpty {
      try visitor.visitSingularStringField(value: self.method, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 5)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 6)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 7)
    }
    if !self.fragment.isEmpty {
      try visitor.visitSingularStringField(value: self.fragment, fieldNumber: 8)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 9)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 10)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 11)
    }
    if !self.rawBody.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawBody, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_AttributeContext.HttpRequest, rhs: Envoy_Service_Auth_V4alpha_AttributeContext.HttpRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.method != rhs.method {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.path != rhs.path {return false}
    if lhs.host != rhs.host {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.query != rhs.query {return false}
    if lhs.fragment != rhs.fragment {return false}
    if lhs.size != rhs.size {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.body != rhs.body {return false}
    if lhs.rawBody != rhs.rawBody {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

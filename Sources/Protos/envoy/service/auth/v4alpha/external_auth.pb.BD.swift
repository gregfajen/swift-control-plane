// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/service/auth/v4alpha/external_auth.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Service_Auth_V4alpha_CheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request attributes.
  public var attributes: Envoy_Service_Auth_V4alpha_AttributeContext {
    get {return _attributes ?? Envoy_Service_Auth_V4alpha_AttributeContext()}
    set {_attributes = newValue}
  }
  /// Returns true if `attributes` has been explicitly set.
  public var hasAttributes: Bool {return self._attributes != nil}
  /// Clears the value of `attributes`. Subsequent reads from it will return its default value.
  public mutating func clearAttributes() {self._attributes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _attributes: Envoy_Service_Auth_V4alpha_AttributeContext? = nil
}

/// HTTP attributes for a denied response.
public struct Envoy_Service_Auth_V4alpha_DeniedHttpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field allows the authorization service to send a HTTP response status
  /// code to the downstream client other than 403 (Forbidden).
  public var status: Envoy_Type_V3_HttpStatus {
    get {return _status ?? Envoy_Type_V3_HttpStatus()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// This field allows the authorization service to send HTTP response headers
  /// to the downstream client. Note that the `append` field in `HeaderValueOption` defaults to
  /// false when used in this message.
  public var headers: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []

  /// This field allows the authorization service to send a response body data
  /// to the downstream client.
  public var body: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Envoy_Type_V3_HttpStatus? = nil
}

/// HTTP attributes for an OK response.
/// [#next-free-field: 6]
public struct Envoy_Service_Auth_V4alpha_OkHttpResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HTTP entity headers in addition to the original request headers. This allows the authorization
  /// service to append, to add or to override headers from the original request before
  /// dispatching it to the upstream. Note that the `append` field in `HeaderValueOption` defaults to
  /// false when used in this message. By setting the `append` field to `true`,
  /// the filter will append the correspondent header value to the matched request header.
  /// By leaving `append` as false, the filter will either add a new header, or override an existing
  /// one if there is a match.
  public var headers: [Envoy_Config_Core_V4alpha_HeaderValueOption] = []

  /// HTTP entity headers to remove from the original request before dispatching
  /// it to the upstream. This allows the authorization service to act on auth
  /// related headers (like `Authorization`), process them, and consume them.
  /// Under this model, the upstream will either receive the request (if it's
  /// authorized) or not receive it (if it's not), but will not see headers
  /// containing authorization credentials.
  ///
  /// Pseudo headers (such as `:authority`, `:method`, `:path` etc), as well as
  /// the header `Host`, may not be removed as that would make the request
  /// malformed. If mentioned in `headers_to_remove` these special headers will
  /// be ignored.
  ///
  /// When using the HTTP service this must instead be set by the HTTP
  /// authorization service as a comma separated list like so:
  /// ``x-envoy-auth-headers-to-remove: one-auth-header, another-auth-header``.
  public var headersToRemove: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Intended for gRPC and Network Authorization servers `only`.
public struct Envoy_Service_Auth_V4alpha_CheckResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Status `OK` allows the request. Any other status indicates the request should be denied.
  public var status: Google_Rpc_Status {
    get {return _status ?? Google_Rpc_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// An message that contains HTTP response attributes. This message is
  /// used when the authorization service needs to send custom responses to the
  /// downstream client or, to modify/add request headers being dispatched to the upstream.
  public var httpResponse: Envoy_Service_Auth_V4alpha_CheckResponse.OneOf_HTTPResponse? = nil

  /// Supplies http attributes for a denied response.
  public var deniedResponse: Envoy_Service_Auth_V4alpha_DeniedHttpResponse {
    get {
      if case .deniedResponse(let v)? = httpResponse {return v}
      return Envoy_Service_Auth_V4alpha_DeniedHttpResponse()
    }
    set {httpResponse = .deniedResponse(newValue)}
  }

  /// Supplies http attributes for an ok response.
  public var okResponse: Envoy_Service_Auth_V4alpha_OkHttpResponse {
    get {
      if case .okResponse(let v)? = httpResponse {return v}
      return Envoy_Service_Auth_V4alpha_OkHttpResponse()
    }
    set {httpResponse = .okResponse(newValue)}
  }

  /// Optional response metadata that will be emitted as dynamic metadata to be consumed by the next
  /// filter. This metadata lives in a namespace specified by the canonical name of extension filter
  /// that requires it:
  ///
  /// - :ref:`envoy.filters.http.ext_authz <config_http_filters_ext_authz_dynamic_metadata>` for HTTP filter.
  /// - :ref:`envoy.filters.network.ext_authz <config_network_filters_ext_authz_dynamic_metadata>` for network filter.
  public var dynamicMetadata: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _dynamicMetadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_dynamicMetadata = newValue}
  }
  /// Returns true if `dynamicMetadata` has been explicitly set.
  public var hasDynamicMetadata: Bool {return self._dynamicMetadata != nil}
  /// Clears the value of `dynamicMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearDynamicMetadata() {self._dynamicMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An message that contains HTTP response attributes. This message is
  /// used when the authorization service needs to send custom responses to the
  /// downstream client or, to modify/add request headers being dispatched to the upstream.
  public enum OneOf_HTTPResponse: Equatable {
    /// Supplies http attributes for a denied response.
    case deniedResponse(Envoy_Service_Auth_V4alpha_DeniedHttpResponse)
    /// Supplies http attributes for an ok response.
    case okResponse(Envoy_Service_Auth_V4alpha_OkHttpResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Service_Auth_V4alpha_CheckResponse.OneOf_HTTPResponse, rhs: Envoy_Service_Auth_V4alpha_CheckResponse.OneOf_HTTPResponse) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.deniedResponse, .deniedResponse): return {
        guard case .deniedResponse(let l) = lhs, case .deniedResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.okResponse, .okResponse): return {
        guard case .okResponse(let l) = lhs, case .okResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _status: Google_Rpc_Status? = nil
  fileprivate var _dynamicMetadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.service.auth.v4alpha"

extension Envoy_Service_Auth_V4alpha_CheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._attributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_CheckRequest, rhs: Envoy_Service_Auth_V4alpha_CheckRequest) -> Bool {
    if lhs._attributes != rhs._attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Auth_V4alpha_DeniedHttpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeniedHttpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "headers"),
    3: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 2)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_DeniedHttpResponse, rhs: Envoy_Service_Auth_V4alpha_DeniedHttpResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Auth_V4alpha_OkHttpResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OkHttpResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "headers"),
    5: .standard(proto: "headers_to_remove"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.headersToRemove) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 2)
    }
    if !self.headersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.headersToRemove, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_OkHttpResponse, rhs: Envoy_Service_Auth_V4alpha_OkHttpResponse) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.headersToRemove != rhs.headersToRemove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Auth_V4alpha_CheckResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "denied_response"),
    3: .standard(proto: "ok_response"),
    4: .standard(proto: "dynamic_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try {
        var v: Envoy_Service_Auth_V4alpha_DeniedHttpResponse?
        if let current = self.httpResponse {
          try decoder.handleConflictingOneOf()
          if case .deniedResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.httpResponse = .deniedResponse(v)}
      }()
      case 3: try {
        var v: Envoy_Service_Auth_V4alpha_OkHttpResponse?
        if let current = self.httpResponse {
          try decoder.handleConflictingOneOf()
          if case .okResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.httpResponse = .okResponse(v)}
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._dynamicMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.httpResponse {
    case .deniedResponse?: try {
      guard case .deniedResponse(let v)? = self.httpResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .okResponse?: try {
      guard case .okResponse(let v)? = self.httpResponse else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if let v = self._dynamicMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Auth_V4alpha_CheckResponse, rhs: Envoy_Service_Auth_V4alpha_CheckResponse) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.httpResponse != rhs.httpResponse {return false}
    if lhs._dynamicMetadata != rhs._dynamicMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

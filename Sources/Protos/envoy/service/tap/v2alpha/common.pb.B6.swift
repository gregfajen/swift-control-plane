// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/service/tap/v2alpha/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tap configuration.
public struct Envoy_Service_Tap_V2alpha_TapConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The match configuration. If the configuration matches the data source being tapped, a tap will
  /// occur, with the result written to the configured output.
  public var matchConfig: Envoy_Service_Tap_V2alpha_MatchPredicate {
    get {return _matchConfig ?? Envoy_Service_Tap_V2alpha_MatchPredicate()}
    set {_matchConfig = newValue}
  }
  /// Returns true if `matchConfig` has been explicitly set.
  public var hasMatchConfig: Bool {return self._matchConfig != nil}
  /// Clears the value of `matchConfig`. Subsequent reads from it will return its default value.
  public mutating func clearMatchConfig() {self._matchConfig = nil}

  /// The tap output configuration. If a match configuration matches a data source being tapped,
  /// a tap will occur and the data will be written to the configured output.
  public var outputConfig: Envoy_Service_Tap_V2alpha_OutputConfig {
    get {return _outputConfig ?? Envoy_Service_Tap_V2alpha_OutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {self._outputConfig = nil}

  /// [#not-implemented-hide:] Specify if Tap matching is enabled. The % of requests\connections for
  /// which the tap matching is enabled. When not enabled, the request\connection will not be
  /// recorded.
  ///
  /// .. note::
  ///
  ///   This field defaults to 100/:ref:`HUNDRED
  ///   <envoy_api_enum_type.FractionalPercent.DenominatorType>`.
  public var tapEnabled: Envoy_Api_V2_Core_RuntimeFractionalPercent {
    get {return _tapEnabled ?? Envoy_Api_V2_Core_RuntimeFractionalPercent()}
    set {_tapEnabled = newValue}
  }
  /// Returns true if `tapEnabled` has been explicitly set.
  public var hasTapEnabled: Bool {return self._tapEnabled != nil}
  /// Clears the value of `tapEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearTapEnabled() {self._tapEnabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _matchConfig: Envoy_Service_Tap_V2alpha_MatchPredicate? = nil
  fileprivate var _outputConfig: Envoy_Service_Tap_V2alpha_OutputConfig? = nil
  fileprivate var _tapEnabled: Envoy_Api_V2_Core_RuntimeFractionalPercent? = nil
}

/// Tap match configuration. This is a recursive structure which allows complex nested match
/// configurations to be built using various logical operators.
/// [#next-free-field: 9]
public struct Envoy_Service_Tap_V2alpha_MatchPredicate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rule: OneOf_Rule? {
    get {return _storage._rule}
    set {_uniqueStorage()._rule = newValue}
  }

  /// A set that describes a logical OR. If any member of the set matches, the match configuration
  /// matches.
  public var orMatch: Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet {
    get {
      if case .orMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet()
    }
    set {_uniqueStorage()._rule = .orMatch(newValue)}
  }

  /// A set that describes a logical AND. If all members of the set match, the match configuration
  /// matches.
  public var andMatch: Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet {
    get {
      if case .andMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet()
    }
    set {_uniqueStorage()._rule = .andMatch(newValue)}
  }

  /// A negation match. The match configuration will match if the negated match condition matches.
  public var notMatch: Envoy_Service_Tap_V2alpha_MatchPredicate {
    get {
      if case .notMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_MatchPredicate()
    }
    set {_uniqueStorage()._rule = .notMatch(newValue)}
  }

  /// The match configuration will always match.
  public var anyMatch: Bool {
    get {
      if case .anyMatch(let v)? = _storage._rule {return v}
      return false
    }
    set {_uniqueStorage()._rule = .anyMatch(newValue)}
  }

  /// HTTP request headers match configuration.
  public var httpRequestHeadersMatch: Envoy_Service_Tap_V2alpha_HttpHeadersMatch {
    get {
      if case .httpRequestHeadersMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpRequestHeadersMatch(newValue)}
  }

  /// HTTP request trailers match configuration.
  public var httpRequestTrailersMatch: Envoy_Service_Tap_V2alpha_HttpHeadersMatch {
    get {
      if case .httpRequestTrailersMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpRequestTrailersMatch(newValue)}
  }

  /// HTTP response headers match configuration.
  public var httpResponseHeadersMatch: Envoy_Service_Tap_V2alpha_HttpHeadersMatch {
    get {
      if case .httpResponseHeadersMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpResponseHeadersMatch(newValue)}
  }

  /// HTTP response trailers match configuration.
  public var httpResponseTrailersMatch: Envoy_Service_Tap_V2alpha_HttpHeadersMatch {
    get {
      if case .httpResponseTrailersMatch(let v)? = _storage._rule {return v}
      return Envoy_Service_Tap_V2alpha_HttpHeadersMatch()
    }
    set {_uniqueStorage()._rule = .httpResponseTrailersMatch(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rule: Equatable {
    /// A set that describes a logical OR. If any member of the set matches, the match configuration
    /// matches.
    case orMatch(Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet)
    /// A set that describes a logical AND. If all members of the set match, the match configuration
    /// matches.
    case andMatch(Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet)
    /// A negation match. The match configuration will match if the negated match condition matches.
    case notMatch(Envoy_Service_Tap_V2alpha_MatchPredicate)
    /// The match configuration will always match.
    case anyMatch(Bool)
    /// HTTP request headers match configuration.
    case httpRequestHeadersMatch(Envoy_Service_Tap_V2alpha_HttpHeadersMatch)
    /// HTTP request trailers match configuration.
    case httpRequestTrailersMatch(Envoy_Service_Tap_V2alpha_HttpHeadersMatch)
    /// HTTP response headers match configuration.
    case httpResponseHeadersMatch(Envoy_Service_Tap_V2alpha_HttpHeadersMatch)
    /// HTTP response trailers match configuration.
    case httpResponseTrailersMatch(Envoy_Service_Tap_V2alpha_HttpHeadersMatch)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Service_Tap_V2alpha_MatchPredicate.OneOf_Rule, rhs: Envoy_Service_Tap_V2alpha_MatchPredicate.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.orMatch, .orMatch): return {
        guard case .orMatch(let l) = lhs, case .orMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.andMatch, .andMatch): return {
        guard case .andMatch(let l) = lhs, case .andMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notMatch, .notMatch): return {
        guard case .notMatch(let l) = lhs, case .notMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.anyMatch, .anyMatch): return {
        guard case .anyMatch(let l) = lhs, case .anyMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpRequestHeadersMatch, .httpRequestHeadersMatch): return {
        guard case .httpRequestHeadersMatch(let l) = lhs, case .httpRequestHeadersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpRequestTrailersMatch, .httpRequestTrailersMatch): return {
        guard case .httpRequestTrailersMatch(let l) = lhs, case .httpRequestTrailersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpResponseHeadersMatch, .httpResponseHeadersMatch): return {
        guard case .httpResponseHeadersMatch(let l) = lhs, case .httpResponseHeadersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpResponseTrailersMatch, .httpResponseTrailersMatch): return {
        guard case .httpResponseTrailersMatch(let l) = lhs, case .httpResponseTrailersMatch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A set of match configurations used for logical operations.
  public struct MatchSet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of rules that make up the set.
    public var rules: [Envoy_Service_Tap_V2alpha_MatchPredicate] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// HTTP headers match configuration.
public struct Envoy_Service_Tap_V2alpha_HttpHeadersMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// HTTP headers to match.
  public var headers: [Envoy_Api_V2_Route_HeaderMatcher] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Tap output configuration.
public struct Envoy_Service_Tap_V2alpha_OutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output sinks for tap data. Currently a single sink is allowed in the list. Once multiple
  /// sink types are supported this constraint will be relaxed.
  public var sinks: [Envoy_Service_Tap_V2alpha_OutputSink] = []

  /// For buffered tapping, the maximum amount of received body that will be buffered prior to
  /// truncation. If truncation occurs, the :ref:`truncated
  /// <envoy_api_field_data.tap.v2alpha.Body.truncated>` field will be set. If not specified, the
  /// default is 1KiB.
  public var maxBufferedRxBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxBufferedRxBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxBufferedRxBytes = newValue}
  }
  /// Returns true if `maxBufferedRxBytes` has been explicitly set.
  public var hasMaxBufferedRxBytes: Bool {return self._maxBufferedRxBytes != nil}
  /// Clears the value of `maxBufferedRxBytes`. Subsequent reads from it will return its default value.
  public mutating func clearMaxBufferedRxBytes() {self._maxBufferedRxBytes = nil}

  /// For buffered tapping, the maximum amount of transmitted body that will be buffered prior to
  /// truncation. If truncation occurs, the :ref:`truncated
  /// <envoy_api_field_data.tap.v2alpha.Body.truncated>` field will be set. If not specified, the
  /// default is 1KiB.
  public var maxBufferedTxBytes: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxBufferedTxBytes ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxBufferedTxBytes = newValue}
  }
  /// Returns true if `maxBufferedTxBytes` has been explicitly set.
  public var hasMaxBufferedTxBytes: Bool {return self._maxBufferedTxBytes != nil}
  /// Clears the value of `maxBufferedTxBytes`. Subsequent reads from it will return its default value.
  public mutating func clearMaxBufferedTxBytes() {self._maxBufferedTxBytes = nil}

  /// Indicates whether taps produce a single buffered message per tap, or multiple streamed
  /// messages per tap in the emitted :ref:`TraceWrapper
  /// <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. Note that streamed tapping does not
  /// mean that no buffering takes place. Buffering may be required if data is processed before a
  /// match can be determined. See the HTTP tap filter :ref:`streaming
  /// <config_http_filters_tap_streaming>` documentation for more information.
  public var streaming: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxBufferedRxBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _maxBufferedTxBytes: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// Tap output sink configuration.
public struct Envoy_Service_Tap_V2alpha_OutputSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sink output format.
  public var format: Envoy_Service_Tap_V2alpha_OutputSink.Format = .jsonBodyAsBytes

  public var outputSinkType: Envoy_Service_Tap_V2alpha_OutputSink.OneOf_OutputSinkType? = nil

  /// Tap output will be streamed out the :http:post:`/tap` admin endpoint.
  ///
  /// .. attention::
  ///
  ///   It is only allowed to specify the streaming admin output sink if the tap is being
  ///   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
  ///   been configured to receive tap configuration from some other source (e.g., static
  ///   file, XDS, etc.) configuring the streaming admin output type will fail.
  public var streamingAdmin: Envoy_Service_Tap_V2alpha_StreamingAdminSink {
    get {
      if case .streamingAdmin(let v)? = outputSinkType {return v}
      return Envoy_Service_Tap_V2alpha_StreamingAdminSink()
    }
    set {outputSinkType = .streamingAdmin(newValue)}
  }

  /// Tap output will be written to a file per tap sink.
  public var filePerTap: Envoy_Service_Tap_V2alpha_FilePerTapSink {
    get {
      if case .filePerTap(let v)? = outputSinkType {return v}
      return Envoy_Service_Tap_V2alpha_FilePerTapSink()
    }
    set {outputSinkType = .filePerTap(newValue)}
  }

  /// [#not-implemented-hide:]
  /// GrpcService to stream data to. The format argument must be PROTO_BINARY.
  public var streamingGrpc: Envoy_Service_Tap_V2alpha_StreamingGrpcSink {
    get {
      if case .streamingGrpc(let v)? = outputSinkType {return v}
      return Envoy_Service_Tap_V2alpha_StreamingGrpcSink()
    }
    set {outputSinkType = .streamingGrpc(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_OutputSinkType: Equatable {
    /// Tap output will be streamed out the :http:post:`/tap` admin endpoint.
    ///
    /// .. attention::
    ///
    ///   It is only allowed to specify the streaming admin output sink if the tap is being
    ///   configured from the :http:post:`/tap` admin endpoint. Thus, if an extension has
    ///   been configured to receive tap configuration from some other source (e.g., static
    ///   file, XDS, etc.) configuring the streaming admin output type will fail.
    case streamingAdmin(Envoy_Service_Tap_V2alpha_StreamingAdminSink)
    /// Tap output will be written to a file per tap sink.
    case filePerTap(Envoy_Service_Tap_V2alpha_FilePerTapSink)
    /// [#not-implemented-hide:]
    /// GrpcService to stream data to. The format argument must be PROTO_BINARY.
    case streamingGrpc(Envoy_Service_Tap_V2alpha_StreamingGrpcSink)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Service_Tap_V2alpha_OutputSink.OneOf_OutputSinkType, rhs: Envoy_Service_Tap_V2alpha_OutputSink.OneOf_OutputSinkType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.streamingAdmin, .streamingAdmin): return {
        guard case .streamingAdmin(let l) = lhs, case .streamingAdmin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filePerTap, .filePerTap): return {
        guard case .filePerTap(let l) = lhs, case .filePerTap(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.streamingGrpc, .streamingGrpc): return {
        guard case .streamingGrpc(let l) = lhs, case .streamingGrpc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Output format. All output is in the form of one or more :ref:`TraceWrapper
  /// <envoy_api_msg_data.tap.v2alpha.TraceWrapper>` messages. This enumeration indicates
  /// how those messages are written. Note that not all sinks support all output formats. See
  /// individual sink documentation for more information.
  public enum Format: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Each message will be written as JSON. Any :ref:`body <envoy_api_msg_data.tap.v2alpha.Body>`
    /// data will be present in the :ref:`as_bytes
    /// <envoy_api_field_data.tap.v2alpha.Body.as_bytes>` field. This means that body data will be
    /// base64 encoded as per the `proto3 JSON mappings
    /// <https://developers.google.com/protocol-buffers/docs/proto3#json>`_.
    case jsonBodyAsBytes // = 0

    /// Each message will be written as JSON. Any :ref:`body <envoy_api_msg_data.tap.v2alpha.Body>`
    /// data will be present in the :ref:`as_string
    /// <envoy_api_field_data.tap.v2alpha.Body.as_string>` field. This means that body data will be
    /// string encoded as per the `proto3 JSON mappings
    /// <https://developers.google.com/protocol-buffers/docs/proto3#json>`_. This format type is
    /// useful when it is known that that body is human readable (e.g., JSON over HTTP) and the
    /// user wishes to view it directly without being forced to base64 decode the body.
    case jsonBodyAsString // = 1

    /// Binary proto format. Note that binary proto is not self-delimiting. If a sink writes
    /// multiple binary messages without any length information the data stream will not be
    /// useful. However, for certain sinks that are self-delimiting (e.g., one message per file)
    /// this output format makes consumption simpler.
    case protoBinary // = 2

    /// Messages are written as a sequence tuples, where each tuple is the message length encoded
    /// as a `protobuf 32-bit varint
    /// <https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream>`_
    /// followed by the binary message. The messages can be read back using the language specific
    /// protobuf coded stream implementation to obtain the message length and the message.
    case protoBinaryLengthDelimited // = 3

    /// Text proto format.
    case protoText // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .jsonBodyAsBytes
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .jsonBodyAsBytes
      case 1: self = .jsonBodyAsString
      case 2: self = .protoBinary
      case 3: self = .protoBinaryLengthDelimited
      case 4: self = .protoText
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .jsonBodyAsBytes: return 0
      case .jsonBodyAsString: return 1
      case .protoBinary: return 2
      case .protoBinaryLengthDelimited: return 3
      case .protoText: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Service_Tap_V2alpha_OutputSink.Format: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Service_Tap_V2alpha_OutputSink.Format] = [
    .jsonBodyAsBytes,
    .jsonBodyAsString,
    .protoBinary,
    .protoBinaryLengthDelimited,
    .protoText,
  ]
}

#endif  // swift(>=4.2)

/// Streaming admin sink configuration.
public struct Envoy_Service_Tap_V2alpha_StreamingAdminSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The file per tap sink outputs a discrete file for every tapped stream.
public struct Envoy_Service_Tap_V2alpha_FilePerTapSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path prefix. The output file will be of the form <path_prefix>_<id>.pb, where <id> is an
  /// identifier distinguishing the recorded trace for stream instances (the Envoy
  /// connection ID, HTTP stream ID, etc.).
  public var pathPrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [#not-implemented-hide:] Streaming gRPC sink configuration sends the taps to an external gRPC
/// server.
public struct Envoy_Service_Tap_V2alpha_StreamingGrpcSink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Opaque identifier, that will be sent back to the streaming grpc server.
  public var tapID: String = String()

  /// The gRPC server that hosts the Tap Sink Service.
  public var grpcService: Envoy_Api_V2_Core_GrpcService {
    get {return _grpcService ?? Envoy_Api_V2_Core_GrpcService()}
    set {_grpcService = newValue}
  }
  /// Returns true if `grpcService` has been explicitly set.
  public var hasGrpcService: Bool {return self._grpcService != nil}
  /// Clears the value of `grpcService`. Subsequent reads from it will return its default value.
  public mutating func clearGrpcService() {self._grpcService = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _grpcService: Envoy_Api_V2_Core_GrpcService? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.service.tap.v2alpha"

extension Envoy_Service_Tap_V2alpha_TapConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TapConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_config"),
    2: .standard(proto: "output_config"),
    3: .standard(proto: "tap_enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._matchConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tapEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._matchConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._tapEnabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_TapConfig, rhs: Envoy_Service_Tap_V2alpha_TapConfig) -> Bool {
    if lhs._matchConfig != rhs._matchConfig {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs._tapEnabled != rhs._tapEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_MatchPredicate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchPredicate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "or_match"),
    2: .standard(proto: "and_match"),
    3: .standard(proto: "not_match"),
    4: .standard(proto: "any_match"),
    5: .standard(proto: "http_request_headers_match"),
    6: .standard(proto: "http_request_trailers_match"),
    7: .standard(proto: "http_response_headers_match"),
    8: .standard(proto: "http_response_trailers_match"),
  ]

  fileprivate class _StorageClass {
    var _rule: Envoy_Service_Tap_V2alpha_MatchPredicate.OneOf_Rule?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rule = source._rule
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .orMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .orMatch(v)}
        }()
        case 2: try {
          var v: Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .andMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .andMatch(v)}
        }()
        case 3: try {
          var v: Envoy_Service_Tap_V2alpha_MatchPredicate?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .notMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .notMatch(v)}
        }()
        case 4: try {
          if _storage._rule != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._rule = .anyMatch(v)}
        }()
        case 5: try {
          var v: Envoy_Service_Tap_V2alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpRequestHeadersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpRequestHeadersMatch(v)}
        }()
        case 6: try {
          var v: Envoy_Service_Tap_V2alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpRequestTrailersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpRequestTrailersMatch(v)}
        }()
        case 7: try {
          var v: Envoy_Service_Tap_V2alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpResponseHeadersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpResponseHeadersMatch(v)}
        }()
        case 8: try {
          var v: Envoy_Service_Tap_V2alpha_HttpHeadersMatch?
          if let current = _storage._rule {
            try decoder.handleConflictingOneOf()
            if case .httpResponseTrailersMatch(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._rule = .httpResponseTrailersMatch(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._rule {
      case .orMatch?: try {
        guard case .orMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .andMatch?: try {
        guard case .andMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .notMatch?: try {
        guard case .notMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .anyMatch?: try {
        guard case .anyMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      }()
      case .httpRequestHeadersMatch?: try {
        guard case .httpRequestHeadersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .httpRequestTrailersMatch?: try {
        guard case .httpRequestTrailersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .httpResponseHeadersMatch?: try {
        guard case .httpResponseHeadersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .httpResponseTrailersMatch?: try {
        guard case .httpResponseTrailersMatch(let v)? = _storage._rule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_MatchPredicate, rhs: Envoy_Service_Tap_V2alpha_MatchPredicate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rule != rhs_storage._rule {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Service_Tap_V2alpha_MatchPredicate.protoMessageName + ".MatchSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet, rhs: Envoy_Service_Tap_V2alpha_MatchPredicate.MatchSet) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_HttpHeadersMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpHeadersMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_HttpHeadersMatch, rhs: Envoy_Service_Tap_V2alpha_HttpHeadersMatch) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sinks"),
    2: .standard(proto: "max_buffered_rx_bytes"),
    3: .standard(proto: "max_buffered_tx_bytes"),
    4: .same(proto: "streaming"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sinks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxBufferedRxBytes) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxBufferedTxBytes) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.streaming) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sinks, fieldNumber: 1)
    }
    if let v = self._maxBufferedRxBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._maxBufferedTxBytes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.streaming != false {
      try visitor.visitSingularBoolField(value: self.streaming, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_OutputConfig, rhs: Envoy_Service_Tap_V2alpha_OutputConfig) -> Bool {
    if lhs.sinks != rhs.sinks {return false}
    if lhs._maxBufferedRxBytes != rhs._maxBufferedRxBytes {return false}
    if lhs._maxBufferedTxBytes != rhs._maxBufferedTxBytes {return false}
    if lhs.streaming != rhs.streaming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_OutputSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .standard(proto: "streaming_admin"),
    3: .standard(proto: "file_per_tap"),
    4: .standard(proto: "streaming_grpc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 2: try {
        var v: Envoy_Service_Tap_V2alpha_StreamingAdminSink?
        if let current = self.outputSinkType {
          try decoder.handleConflictingOneOf()
          if case .streamingAdmin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.outputSinkType = .streamingAdmin(v)}
      }()
      case 3: try {
        var v: Envoy_Service_Tap_V2alpha_FilePerTapSink?
        if let current = self.outputSinkType {
          try decoder.handleConflictingOneOf()
          if case .filePerTap(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.outputSinkType = .filePerTap(v)}
      }()
      case 4: try {
        var v: Envoy_Service_Tap_V2alpha_StreamingGrpcSink?
        if let current = self.outputSinkType {
          try decoder.handleConflictingOneOf()
          if case .streamingGrpc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.outputSinkType = .streamingGrpc(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .jsonBodyAsBytes {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.outputSinkType {
    case .streamingAdmin?: try {
      guard case .streamingAdmin(let v)? = self.outputSinkType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .filePerTap?: try {
      guard case .filePerTap(let v)? = self.outputSinkType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .streamingGrpc?: try {
      guard case .streamingGrpc(let v)? = self.outputSinkType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_OutputSink, rhs: Envoy_Service_Tap_V2alpha_OutputSink) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.outputSinkType != rhs.outputSinkType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_OutputSink.Format: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JSON_BODY_AS_BYTES"),
    1: .same(proto: "JSON_BODY_AS_STRING"),
    2: .same(proto: "PROTO_BINARY"),
    3: .same(proto: "PROTO_BINARY_LENGTH_DELIMITED"),
    4: .same(proto: "PROTO_TEXT"),
  ]
}

extension Envoy_Service_Tap_V2alpha_StreamingAdminSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingAdminSink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_StreamingAdminSink, rhs: Envoy_Service_Tap_V2alpha_StreamingAdminSink) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_FilePerTapSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilePerTapSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pathPrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pathPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.pathPrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_FilePerTapSink, rhs: Envoy_Service_Tap_V2alpha_FilePerTapSink) -> Bool {
    if lhs.pathPrefix != rhs.pathPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Tap_V2alpha_StreamingGrpcSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingGrpcSink"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tap_id"),
    2: .standard(proto: "grpc_service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tapID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._grpcService) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tapID.isEmpty {
      try visitor.visitSingularStringField(value: self.tapID, fieldNumber: 1)
    }
    if let v = self._grpcService {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Tap_V2alpha_StreamingGrpcSink, rhs: Envoy_Service_Tap_V2alpha_StreamingGrpcSink) -> Bool {
    if lhs.tapID != rhs.tapID {return false}
    if lhs._grpcService != rhs._grpcService {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

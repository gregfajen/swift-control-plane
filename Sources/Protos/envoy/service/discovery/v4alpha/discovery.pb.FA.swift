// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/service/discovery/v4alpha/discovery.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A DiscoveryRequest requests a set of versioned resources of the same type for
/// a given Envoy node on some API.
/// [#next-free-field: 7]
public struct Envoy_Service_Discovery_V4alpha_DiscoveryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version_info provided in the request messages will be the version_info
  /// received with the most recent successfully processed response or empty on
  /// the first request. It is expected that no new request is sent after a
  /// response is received until the Envoy instance is ready to ACK/NACK the new
  /// configuration. ACK/NACK takes place by returning the new API config version
  /// as applied or the previous API config version respectively. Each type_url
  /// (see below) has an independent version associated with it.
  public var versionInfo: String {
    get {return _storage._versionInfo}
    set {_uniqueStorage()._versionInfo = newValue}
  }

  /// The node making the request.
  public var node: Envoy_Config_Core_V4alpha_Node {
    get {return _storage._node ?? Envoy_Config_Core_V4alpha_Node()}
    set {_uniqueStorage()._node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return _storage._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {_uniqueStorage()._node = nil}

  /// List of resources to subscribe to, e.g. list of cluster names or a route
  /// configuration name. If this is empty, all resources for the API are
  /// returned. LDS/CDS may have empty resource_names, which will cause all
  /// resources for the Envoy instance to be returned. The LDS and CDS responses
  /// will then imply a number of resources that need to be fetched via EDS/RDS,
  /// which will be explicitly enumerated in resource_names.
  public var resourceNames: [String] {
    get {return _storage._resourceNames}
    set {_uniqueStorage()._resourceNames = newValue}
  }

  /// Type of the resource that is being requested, e.g.
  /// "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This is implicit
  /// in requests made via singleton xDS APIs such as CDS, LDS, etc. but is
  /// required for ADS.
  public var typeURL: String {
    get {return _storage._typeURL}
    set {_uniqueStorage()._typeURL = newValue}
  }

  /// nonce corresponding to DiscoveryResponse being ACK/NACKed. See above
  /// discussion on version_info and the DiscoveryResponse nonce comment. This
  /// may be empty only if 1) this is a non-persistent-stream xDS such as HTTP,
  /// or 2) the client has not yet accepted an update in this xDS stream (unlike
  /// delta, where it is populated only for new explicit ACKs).
  public var responseNonce: String {
    get {return _storage._responseNonce}
    set {_uniqueStorage()._responseNonce = newValue}
  }

  /// This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_service.discovery.v4alpha.DiscoveryResponse>`
  /// failed to update configuration. The *message* field in *error_details* provides the Envoy
  /// internal exception related to the failure. It is only intended for consumption during manual
  /// debugging, the string provided is not guaranteed to be stable across Envoy versions.
  public var errorDetail: Google_Rpc_Status {
    get {return _storage._errorDetail ?? Google_Rpc_Status()}
    set {_uniqueStorage()._errorDetail = newValue}
  }
  /// Returns true if `errorDetail` has been explicitly set.
  public var hasErrorDetail: Bool {return _storage._errorDetail != nil}
  /// Clears the value of `errorDetail`. Subsequent reads from it will return its default value.
  public mutating func clearErrorDetail() {_uniqueStorage()._errorDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// [#next-free-field: 7]
public struct Envoy_Service_Discovery_V4alpha_DiscoveryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the response data.
  public var versionInfo: String = String()

  /// The response resources. These resources are typed and depend on the API being called.
  public var resources: [SwiftProtobuf.Google_Protobuf_Any] = []

  /// [#not-implemented-hide:]
  /// Canary is used to support two Envoy command line flags:
  ///
  /// * --terminate-on-canary-transition-failure. When set, Envoy is able to
  ///   terminate if it detects that configuration is stuck at canary. Consider
  ///   this example sequence of updates:
  ///   - Management server applies a canary config successfully.
  ///   - Management server rolls back to a production config.
  ///   - Envoy rejects the new production config.
  ///   Since there is no sensible way to continue receiving configuration
  ///   updates, Envoy will then terminate and apply production config from a
  ///   clean slate.
  /// * --dry-run-canary. When set, a canary response will never be applied, only
  ///   validated via a dry run.
  public var canary: Bool = false

  /// Type URL for resources. Identifies the xDS API when muxing over ADS.
  /// Must be consistent with the type_url in the 'resources' repeated Any (if non-empty).
  public var typeURL: String = String()

  /// For gRPC based subscriptions, the nonce provides a way to explicitly ack a
  /// specific DiscoveryResponse in a following DiscoveryRequest. Additional
  /// messages may have been sent by Envoy to the management server for the
  /// previous version on the stream prior to this DiscoveryResponse, that were
  /// unprocessed at response send time. The nonce allows the management server
  /// to ignore any further DiscoveryRequests for the previous version until a
  /// DiscoveryRequest bearing the nonce. The nonce is optional and is not
  /// required for non-stream based xDS implementations.
  public var nonce: String = String()

  /// [#not-implemented-hide:]
  /// The control plane instance that sent the response.
  public var controlPlane: Envoy_Config_Core_V4alpha_ControlPlane {
    get {return _controlPlane ?? Envoy_Config_Core_V4alpha_ControlPlane()}
    set {_controlPlane = newValue}
  }
  /// Returns true if `controlPlane` has been explicitly set.
  public var hasControlPlane: Bool {return self._controlPlane != nil}
  /// Clears the value of `controlPlane`. Subsequent reads from it will return its default value.
  public mutating func clearControlPlane() {self._controlPlane = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _controlPlane: Envoy_Config_Core_V4alpha_ControlPlane? = nil
}

/// DeltaDiscoveryRequest and DeltaDiscoveryResponse are used in a new gRPC
/// endpoint for Delta xDS.
///
/// With Delta xDS, the DeltaDiscoveryResponses do not need to include a full
/// snapshot of the tracked resources. Instead, DeltaDiscoveryResponses are a
/// diff to the state of a xDS client.
/// In Delta XDS there are per-resource versions, which allow tracking state at
/// the resource granularity.
/// An xDS Delta session is always in the context of a gRPC bidirectional
/// stream. This allows the xDS server to keep track of the state of xDS clients
/// connected to it.
///
/// In Delta xDS the nonce field is required and used to pair
/// DeltaDiscoveryResponse to a DeltaDiscoveryRequest ACK or NACK.
/// Optionally, a response message level system_version_info is present for
/// debugging purposes only.
///
/// DeltaDiscoveryRequest plays two independent roles. Any DeltaDiscoveryRequest
/// can be either or both of: [1] informing the server of what resources the
/// client has gained/lost interest in (using resource_names_subscribe and
/// resource_names_unsubscribe), or [2] (N)ACKing an earlier resource update from
/// the server (using response_nonce, with presence of error_detail making it a NACK).
/// Additionally, the first message (for a given type_url) of a reconnected gRPC stream
/// has a third role: informing the server of the resources (and their versions)
/// that the client already possesses, using the initial_resource_versions field.
///
/// As with state-of-the-world, when multiple resource types are multiplexed (ADS),
/// all requests/acknowledgments/updates are logically walled off by type_url:
/// a Cluster ACK exists in a completely separate world from a prior Route NACK.
/// In particular, initial_resource_versions being sent at the "start" of every
/// gRPC stream actually entails a message for each type_url, each with its own
/// initial_resource_versions.
/// [#next-free-field: 10]
public struct Envoy_Service_Discovery_V4alpha_DeltaDiscoveryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The node making the request.
  public var node: Envoy_Config_Core_V4alpha_Node {
    get {return _storage._node ?? Envoy_Config_Core_V4alpha_Node()}
    set {_uniqueStorage()._node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return _storage._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {_uniqueStorage()._node = nil}

  /// Type of the resource that is being requested, e.g.
  /// "type.googleapis.com/envoy.api.v2.ClusterLoadAssignment". This does not need to be set if
  /// resources are only referenced via *udpa_resource_subscribe* and
  /// *udpa_resources_unsubscribe*.
  public var typeURL: String {
    get {return _storage._typeURL}
    set {_uniqueStorage()._typeURL = newValue}
  }

  /// DeltaDiscoveryRequests allow the client to add or remove individual
  /// resources to the set of tracked resources in the context of a stream.
  /// All resource names in the resource_names_subscribe list are added to the
  /// set of tracked resources and all resource names in the resource_names_unsubscribe
  /// list are removed from the set of tracked resources.
  ///
  /// *Unlike* state-of-the-world xDS, an empty resource_names_subscribe or
  /// resource_names_unsubscribe list simply means that no resources are to be
  /// added or removed to the resource list.
  /// *Like* state-of-the-world xDS, the server must send updates for all tracked
  /// resources, but can also send updates for resources the client has not subscribed to.
  ///
  /// NOTE: the server must respond with all resources listed in resource_names_subscribe,
  /// even if it believes the client has the most recent version of them. The reason:
  /// the client may have dropped them, but then regained interest before it had a chance
  /// to send the unsubscribe message. See DeltaSubscriptionStateTest.RemoveThenAdd.
  ///
  /// These two fields can be set in any DeltaDiscoveryRequest, including ACKs
  /// and initial_resource_versions.
  ///
  /// A list of Resource names to add to the list of tracked resources.
  public var resourceNamesSubscribe: [String] {
    get {return _storage._resourceNamesSubscribe}
    set {_uniqueStorage()._resourceNamesSubscribe = newValue}
  }

  /// As with *resource_names_subscribe* but used when subscribing to resources indicated
  /// by a *udpa.core.v1.ResourceLocator*. The directives in the resource locator
  /// are ignored and the context parameters are matched with
  /// *context_param_specifier* specific semantics.
  /// [#not-implemented-hide:]
  public var udpaResourcesSubscribe: [Udpa_Core_V1_ResourceLocator] {
    get {return _storage._udpaResourcesSubscribe}
    set {_uniqueStorage()._udpaResourcesSubscribe = newValue}
  }

  /// A list of Resource names to remove from the list of tracked resources.
  public var resourceNamesUnsubscribe: [String] {
    get {return _storage._resourceNamesUnsubscribe}
    set {_uniqueStorage()._resourceNamesUnsubscribe = newValue}
  }

  /// As with *resource_names_unsubscribe* but used when unsubscribing to resources indicated by a
  /// *udpa.core.v1.ResourceLocator*. This must match a previously subscribed
  /// resource locator provided in *udpa_resources_subscribe*.
  /// [#not-implemented-hide:]
  public var udpaResourcesUnsubscribe: [Udpa_Core_V1_ResourceLocator] {
    get {return _storage._udpaResourcesUnsubscribe}
    set {_uniqueStorage()._udpaResourcesUnsubscribe = newValue}
  }

  /// Informs the server of the versions of the resources the xDS client knows of, to enable the
  /// client to continue the same logical xDS session even in the face of gRPC stream reconnection.
  /// It will not be populated: [1] in the very first stream of a session, since the client will
  /// not yet have any resources,  [2] in any message after the first in a stream (for a given
  /// type_url), since the server will already be correctly tracking the client's state.
  /// (In ADS, the first message *of each type_url* of a reconnected stream populates this map.)
  /// The map's keys are names of xDS resources known to the xDS client.
  /// The map's values are opaque resource versions.
  public var initialResourceVersions: Dictionary<String,String> {
    get {return _storage._initialResourceVersions}
    set {_uniqueStorage()._initialResourceVersions = newValue}
  }

  /// When the DeltaDiscoveryRequest is a ACK or NACK message in response
  /// to a previous DeltaDiscoveryResponse, the response_nonce must be the
  /// nonce in the DeltaDiscoveryResponse.
  /// Otherwise (unlike in DiscoveryRequest) response_nonce must be omitted.
  public var responseNonce: String {
    get {return _storage._responseNonce}
    set {_uniqueStorage()._responseNonce = newValue}
  }

  /// This is populated when the previous :ref:`DiscoveryResponse <envoy_api_msg_service.discovery.v4alpha.DiscoveryResponse>`
  /// failed to update configuration. The *message* field in *error_details*
  /// provides the Envoy internal exception related to the failure.
  public var errorDetail: Google_Rpc_Status {
    get {return _storage._errorDetail ?? Google_Rpc_Status()}
    set {_uniqueStorage()._errorDetail = newValue}
  }
  /// Returns true if `errorDetail` has been explicitly set.
  public var hasErrorDetail: Bool {return _storage._errorDetail != nil}
  /// Clears the value of `errorDetail`. Subsequent reads from it will return its default value.
  public mutating func clearErrorDetail() {_uniqueStorage()._errorDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// [#next-free-field: 8]
public struct Envoy_Service_Discovery_V4alpha_DeltaDiscoveryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version of the response data (used for debugging).
  public var systemVersionInfo: String = String()

  /// The response resources. These are typed resources, whose types must match
  /// the type_url field.
  public var resources: [Envoy_Service_Discovery_V4alpha_Resource] = []

  /// Type URL for resources. Identifies the xDS API when muxing over ADS.
  /// Must be consistent with the type_url in the Any within 'resources' if 'resources' is non-empty.
  /// This does not need to be set if *udpa_removed_resources* is used instead of
  /// *removed_resources*.
  public var typeURL: String = String()

  /// Resources names of resources that have be deleted and to be removed from the xDS Client.
  /// Removed resources for missing resources can be ignored.
  public var removedResources: [String] = []

  /// As with *removed_resources* but used when a removed resource was named in
  /// its *Resource*s with a *udpa.core.v1.ResourceName*.
  /// [#not-implemented-hide:]
  public var udpaRemovedResources: [Udpa_Core_V1_ResourceName] = []

  /// The nonce provides a way for DeltaDiscoveryRequests to uniquely
  /// reference a DeltaDiscoveryResponse when (N)ACKing. The nonce is required.
  public var nonce: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [#next-free-field: 7]
public struct Envoy_Service_Discovery_V4alpha_Resource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var nameSpecifier: Envoy_Service_Discovery_V4alpha_Resource.OneOf_NameSpecifier? = nil

  /// The resource's name, to distinguish it from others of the same type of resource.
  public var name: String {
    get {
      if case .name(let v)? = nameSpecifier {return v}
      return String()
    }
    set {nameSpecifier = .name(newValue)}
  }

  /// Used instead of *name* when a resource with a *udpa.core.v1.ResourceName* is delivered.
  public var udpaResourceName: Udpa_Core_V1_ResourceName {
    get {
      if case .udpaResourceName(let v)? = nameSpecifier {return v}
      return Udpa_Core_V1_ResourceName()
    }
    set {nameSpecifier = .udpaResourceName(newValue)}
  }

  /// The aliases are a list of other names that this resource can go by.
  public var aliases: [String] = []

  /// The resource level version. It allows xDS to track the state of individual
  /// resources.
  public var version: String = String()

  /// The resource being tracked.
  public var resource: SwiftProtobuf.Google_Protobuf_Any {
    get {return _resource ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// Time-to-live value for the resource. For each resource, a timer is started. The timer is
  /// reset each time the resource is received with a new TTL. If the resource is received with
  /// no TTL set, the timer is removed for the resource. Upon expiration of the timer, the
  /// configuration for the resource will be removed.
  ///
  /// The TTL can be refreshed or changed by sending a response that doesn't change the resource
  /// version. In this case the resource field does not need to be populated, which allows for
  /// light-weight "heartbeat" updates to keep a resource with a TTL alive.
  ///
  /// The TTL feature is meant to support configurations that should be removed in the event of
  /// a management server failure. For example, the feature may be used for fault injection
  /// testing where the fault injection should be terminated in the event that Envoy loses contact
  /// with the management server.
  public var ttl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  public var hasTtl: Bool {return self._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  public mutating func clearTtl() {self._ttl = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_NameSpecifier: Equatable {
    /// The resource's name, to distinguish it from others of the same type of resource.
    case name(String)
    /// Used instead of *name* when a resource with a *udpa.core.v1.ResourceName* is delivered.
    case udpaResourceName(Udpa_Core_V1_ResourceName)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Service_Discovery_V4alpha_Resource.OneOf_NameSpecifier, rhs: Envoy_Service_Discovery_V4alpha_Resource.OneOf_NameSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.name, .name): return {
        guard case .name(let l) = lhs, case .name(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.udpaResourceName, .udpaResourceName): return {
        guard case .udpaResourceName(let l) = lhs, case .udpaResourceName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _resource: SwiftProtobuf.Google_Protobuf_Any? = nil
  fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.service.discovery.v4alpha"

extension Envoy_Service_Discovery_V4alpha_DiscoveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoveryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_info"),
    2: .same(proto: "node"),
    3: .standard(proto: "resource_names"),
    4: .standard(proto: "type_url"),
    5: .standard(proto: "response_nonce"),
    6: .standard(proto: "error_detail"),
  ]

  fileprivate class _StorageClass {
    var _versionInfo: String = String()
    var _node: Envoy_Config_Core_V4alpha_Node? = nil
    var _resourceNames: [String] = []
    var _typeURL: String = String()
    var _responseNonce: String = String()
    var _errorDetail: Google_Rpc_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _versionInfo = source._versionInfo
      _node = source._node
      _resourceNames = source._resourceNames
      _typeURL = source._typeURL
      _responseNonce = source._responseNonce
      _errorDetail = source._errorDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._versionInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._node) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._resourceNames) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._typeURL) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._responseNonce) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._errorDetail) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._versionInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionInfo, fieldNumber: 1)
      }
      if let v = _storage._node {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._resourceNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._resourceNames, fieldNumber: 3)
      }
      if !_storage._typeURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._typeURL, fieldNumber: 4)
      }
      if !_storage._responseNonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._responseNonce, fieldNumber: 5)
      }
      if let v = _storage._errorDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V4alpha_DiscoveryRequest, rhs: Envoy_Service_Discovery_V4alpha_DiscoveryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._versionInfo != rhs_storage._versionInfo {return false}
        if _storage._node != rhs_storage._node {return false}
        if _storage._resourceNames != rhs_storage._resourceNames {return false}
        if _storage._typeURL != rhs_storage._typeURL {return false}
        if _storage._responseNonce != rhs_storage._responseNonce {return false}
        if _storage._errorDetail != rhs_storage._errorDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V4alpha_DiscoveryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiscoveryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "version_info"),
    2: .same(proto: "resources"),
    3: .same(proto: "canary"),
    4: .standard(proto: "type_url"),
    5: .same(proto: "nonce"),
    6: .standard(proto: "control_plane"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.versionInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canary) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.typeURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nonce) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._controlPlane) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.versionInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.versionInfo, fieldNumber: 1)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 2)
    }
    if self.canary != false {
      try visitor.visitSingularBoolField(value: self.canary, fieldNumber: 3)
    }
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 4)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 5)
    }
    if let v = self._controlPlane {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V4alpha_DiscoveryResponse, rhs: Envoy_Service_Discovery_V4alpha_DiscoveryResponse) -> Bool {
    if lhs.versionInfo != rhs.versionInfo {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.canary != rhs.canary {return false}
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs._controlPlane != rhs._controlPlane {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V4alpha_DeltaDiscoveryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeltaDiscoveryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .standard(proto: "type_url"),
    3: .standard(proto: "resource_names_subscribe"),
    8: .standard(proto: "udpa_resources_subscribe"),
    4: .standard(proto: "resource_names_unsubscribe"),
    9: .standard(proto: "udpa_resources_unsubscribe"),
    5: .standard(proto: "initial_resource_versions"),
    6: .standard(proto: "response_nonce"),
    7: .standard(proto: "error_detail"),
  ]

  fileprivate class _StorageClass {
    var _node: Envoy_Config_Core_V4alpha_Node? = nil
    var _typeURL: String = String()
    var _resourceNamesSubscribe: [String] = []
    var _udpaResourcesSubscribe: [Udpa_Core_V1_ResourceLocator] = []
    var _resourceNamesUnsubscribe: [String] = []
    var _udpaResourcesUnsubscribe: [Udpa_Core_V1_ResourceLocator] = []
    var _initialResourceVersions: Dictionary<String,String> = [:]
    var _responseNonce: String = String()
    var _errorDetail: Google_Rpc_Status? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _node = source._node
      _typeURL = source._typeURL
      _resourceNamesSubscribe = source._resourceNamesSubscribe
      _udpaResourcesSubscribe = source._udpaResourcesSubscribe
      _resourceNamesUnsubscribe = source._resourceNamesUnsubscribe
      _udpaResourcesUnsubscribe = source._udpaResourcesUnsubscribe
      _initialResourceVersions = source._initialResourceVersions
      _responseNonce = source._responseNonce
      _errorDetail = source._errorDetail
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._node) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._typeURL) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._resourceNamesSubscribe) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._resourceNamesUnsubscribe) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._initialResourceVersions) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._responseNonce) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._errorDetail) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._udpaResourcesSubscribe) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._udpaResourcesUnsubscribe) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._node {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._typeURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._typeURL, fieldNumber: 2)
      }
      if !_storage._resourceNamesSubscribe.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._resourceNamesSubscribe, fieldNumber: 3)
      }
      if !_storage._resourceNamesUnsubscribe.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._resourceNamesUnsubscribe, fieldNumber: 4)
      }
      if !_storage._initialResourceVersions.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._initialResourceVersions, fieldNumber: 5)
      }
      if !_storage._responseNonce.isEmpty {
        try visitor.visitSingularStringField(value: _storage._responseNonce, fieldNumber: 6)
      }
      if let v = _storage._errorDetail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._udpaResourcesSubscribe.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._udpaResourcesSubscribe, fieldNumber: 8)
      }
      if !_storage._udpaResourcesUnsubscribe.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._udpaResourcesUnsubscribe, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V4alpha_DeltaDiscoveryRequest, rhs: Envoy_Service_Discovery_V4alpha_DeltaDiscoveryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._node != rhs_storage._node {return false}
        if _storage._typeURL != rhs_storage._typeURL {return false}
        if _storage._resourceNamesSubscribe != rhs_storage._resourceNamesSubscribe {return false}
        if _storage._udpaResourcesSubscribe != rhs_storage._udpaResourcesSubscribe {return false}
        if _storage._resourceNamesUnsubscribe != rhs_storage._resourceNamesUnsubscribe {return false}
        if _storage._udpaResourcesUnsubscribe != rhs_storage._udpaResourcesUnsubscribe {return false}
        if _storage._initialResourceVersions != rhs_storage._initialResourceVersions {return false}
        if _storage._responseNonce != rhs_storage._responseNonce {return false}
        if _storage._errorDetail != rhs_storage._errorDetail {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V4alpha_DeltaDiscoveryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeltaDiscoveryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "system_version_info"),
    2: .same(proto: "resources"),
    4: .standard(proto: "type_url"),
    6: .standard(proto: "removed_resources"),
    7: .standard(proto: "udpa_removed_resources"),
    5: .same(proto: "nonce"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.systemVersionInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.typeURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nonce) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.removedResources) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.udpaRemovedResources) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.systemVersionInfo.isEmpty {
      try visitor.visitSingularStringField(value: self.systemVersionInfo, fieldNumber: 1)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 2)
    }
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 4)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularStringField(value: self.nonce, fieldNumber: 5)
    }
    if !self.removedResources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removedResources, fieldNumber: 6)
    }
    if !self.udpaRemovedResources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.udpaRemovedResources, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V4alpha_DeltaDiscoveryResponse, rhs: Envoy_Service_Discovery_V4alpha_DeltaDiscoveryResponse) -> Bool {
    if lhs.systemVersionInfo != rhs.systemVersionInfo {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.removedResources != rhs.removedResources {return false}
    if lhs.udpaRemovedResources != rhs.udpaRemovedResources {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V4alpha_Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    5: .standard(proto: "udpa_resource_name"),
    4: .same(proto: "aliases"),
    1: .same(proto: "version"),
    2: .same(proto: "resource"),
    6: .same(proto: "ttl"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try {
        if self.nameSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.nameSpecifier = .name(v)}
      }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.aliases) }()
      case 5: try {
        var v: Udpa_Core_V1_ResourceName?
        if let current = self.nameSpecifier {
          try decoder.handleConflictingOneOf()
          if case .udpaResourceName(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.nameSpecifier = .udpaResourceName(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if case .name(let v)? = self.nameSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.aliases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aliases, fieldNumber: 4)
    }
    if case .udpaResourceName(let v)? = self.nameSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V4alpha_Resource, rhs: Envoy_Service_Discovery_V4alpha_Resource) -> Bool {
    if lhs.nameSpecifier != rhs.nameSpecifier {return false}
    if lhs.aliases != rhs.aliases {return false}
    if lhs.version != rhs.version {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._ttl != rhs._ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

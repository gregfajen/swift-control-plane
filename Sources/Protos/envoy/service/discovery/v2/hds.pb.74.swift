// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/service/discovery/v2/hds.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines supported protocols etc, so the management server can assign proper
/// endpoints to healthcheck.
public struct Envoy_Service_Discovery_V2_Capability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var healthCheckProtocols: [Envoy_Service_Discovery_V2_Capability.ProtocolEnum] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Different Envoy instances may have different capabilities (e.g. Redis)
  /// and/or have ports enabled for different protocols.
  public enum ProtocolEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case http // = 0
    case tcp // = 1
    case redis // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .http
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .http
      case 1: self = .tcp
      case 2: self = .redis
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .http: return 0
      case .tcp: return 1
      case .redis: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Service_Discovery_V2_Capability.ProtocolEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Service_Discovery_V2_Capability.ProtocolEnum] = [
    .http,
    .tcp,
    .redis,
  ]
}

#endif  // swift(>=4.2)

public struct Envoy_Service_Discovery_V2_HealthCheckRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var node: Envoy_Api_V2_Core_Node {
    get {return _node ?? Envoy_Api_V2_Core_Node()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  public var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  public mutating func clearNode() {self._node = nil}

  public var capability: Envoy_Service_Discovery_V2_Capability {
    get {return _capability ?? Envoy_Service_Discovery_V2_Capability()}
    set {_capability = newValue}
  }
  /// Returns true if `capability` has been explicitly set.
  public var hasCapability: Bool {return self._capability != nil}
  /// Clears the value of `capability`. Subsequent reads from it will return its default value.
  public mutating func clearCapability() {self._capability = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _node: Envoy_Api_V2_Core_Node? = nil
  fileprivate var _capability: Envoy_Service_Discovery_V2_Capability? = nil
}

public struct Envoy_Service_Discovery_V2_EndpointHealth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var endpoint: Envoy_Api_V2_Endpoint_Endpoint {
    get {return _endpoint ?? Envoy_Api_V2_Endpoint_Endpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  public var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  public mutating func clearEndpoint() {self._endpoint = nil}

  public var healthStatus: Envoy_Api_V2_Core_HealthStatus = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endpoint: Envoy_Api_V2_Endpoint_Endpoint? = nil
}

public struct Envoy_Service_Discovery_V2_EndpointHealthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var endpointsHealth: [Envoy_Service_Discovery_V2_EndpointHealth] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestType: Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse.OneOf_RequestType? = nil

  public var healthCheckRequest: Envoy_Service_Discovery_V2_HealthCheckRequest {
    get {
      if case .healthCheckRequest(let v)? = requestType {return v}
      return Envoy_Service_Discovery_V2_HealthCheckRequest()
    }
    set {requestType = .healthCheckRequest(newValue)}
  }

  public var endpointHealthResponse: Envoy_Service_Discovery_V2_EndpointHealthResponse {
    get {
      if case .endpointHealthResponse(let v)? = requestType {return v}
      return Envoy_Service_Discovery_V2_EndpointHealthResponse()
    }
    set {requestType = .endpointHealthResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RequestType: Equatable {
    case healthCheckRequest(Envoy_Service_Discovery_V2_HealthCheckRequest)
    case endpointHealthResponse(Envoy_Service_Discovery_V2_EndpointHealthResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse.OneOf_RequestType, rhs: Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse.OneOf_RequestType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.healthCheckRequest, .healthCheckRequest): return {
        guard case .healthCheckRequest(let l) = lhs, case .healthCheckRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endpointHealthResponse, .endpointHealthResponse): return {
        guard case .endpointHealthResponse(let l) = lhs, case .endpointHealthResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Envoy_Service_Discovery_V2_LocalityEndpoints {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var locality: Envoy_Api_V2_Core_Locality {
    get {return _locality ?? Envoy_Api_V2_Core_Locality()}
    set {_locality = newValue}
  }
  /// Returns true if `locality` has been explicitly set.
  public var hasLocality: Bool {return self._locality != nil}
  /// Clears the value of `locality`. Subsequent reads from it will return its default value.
  public mutating func clearLocality() {self._locality = nil}

  public var endpoints: [Envoy_Api_V2_Endpoint_Endpoint] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _locality: Envoy_Api_V2_Core_Locality? = nil
}

/// The cluster name and locality is provided to Envoy for the endpoints that it
/// health checks to support statistics reporting, logging and debugging by the
/// Envoy instance (outside of HDS). For maximum usefulness, it should match the
/// same cluster structure as that provided by EDS.
public struct Envoy_Service_Discovery_V2_ClusterHealthCheck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterName: String = String()

  public var healthChecks: [Envoy_Api_V2_Core_HealthCheck] = []

  public var localityEndpoints: [Envoy_Service_Discovery_V2_LocalityEndpoints] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Envoy_Service_Discovery_V2_HealthCheckSpecifier {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterHealthChecks: [Envoy_Service_Discovery_V2_ClusterHealthCheck] = []

  /// The default is 1 second.
  public var interval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _interval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  public var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  public mutating func clearInterval() {self._interval = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interval: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.service.discovery.v2"

extension Envoy_Service_Discovery_V2_Capability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Capability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "health_check_protocols"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.healthCheckProtocols) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.healthCheckProtocols.isEmpty {
      try visitor.visitPackedEnumField(value: self.healthCheckProtocols, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_Capability, rhs: Envoy_Service_Discovery_V2_Capability) -> Bool {
    if lhs.healthCheckProtocols != rhs.healthCheckProtocols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_Capability.ProtocolEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HTTP"),
    1: .same(proto: "TCP"),
    2: .same(proto: "REDIS"),
  ]
}

extension Envoy_Service_Discovery_V2_HealthCheckRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthCheckRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "node"),
    2: .same(proto: "capability"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._node) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._capability) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._capability {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_HealthCheckRequest, rhs: Envoy_Service_Discovery_V2_HealthCheckRequest) -> Bool {
    if lhs._node != rhs._node {return false}
    if lhs._capability != rhs._capability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_EndpointHealth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndpointHealth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "endpoint"),
    2: .standard(proto: "health_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.healthStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.healthStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.healthStatus, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_EndpointHealth, rhs: Envoy_Service_Discovery_V2_EndpointHealth) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.healthStatus != rhs.healthStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_EndpointHealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndpointHealthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "endpoints_health"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.endpointsHealth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointsHealth.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpointsHealth, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_EndpointHealthResponse, rhs: Envoy_Service_Discovery_V2_EndpointHealthResponse) -> Bool {
    if lhs.endpointsHealth != rhs.endpointsHealth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthCheckRequestOrEndpointHealthResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "health_check_request"),
    2: .standard(proto: "endpoint_health_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Service_Discovery_V2_HealthCheckRequest?
        if let current = self.requestType {
          try decoder.handleConflictingOneOf()
          if case .healthCheckRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestType = .healthCheckRequest(v)}
      }()
      case 2: try {
        var v: Envoy_Service_Discovery_V2_EndpointHealthResponse?
        if let current = self.requestType {
          try decoder.handleConflictingOneOf()
          if case .endpointHealthResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestType = .endpointHealthResponse(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requestType {
    case .healthCheckRequest?: try {
      guard case .healthCheckRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .endpointHealthResponse?: try {
      guard case .endpointHealthResponse(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse, rhs: Envoy_Service_Discovery_V2_HealthCheckRequestOrEndpointHealthResponse) -> Bool {
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_LocalityEndpoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalityEndpoints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locality"),
    2: .same(proto: "endpoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locality) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_LocalityEndpoints, rhs: Envoy_Service_Discovery_V2_LocalityEndpoints) -> Bool {
    if lhs._locality != rhs._locality {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_ClusterHealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterHealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .standard(proto: "health_checks"),
    3: .standard(proto: "locality_endpoints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.healthChecks) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.localityEndpoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.healthChecks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.healthChecks, fieldNumber: 2)
    }
    if !self.localityEndpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localityEndpoints, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_ClusterHealthCheck, rhs: Envoy_Service_Discovery_V2_ClusterHealthCheck) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.healthChecks != rhs.healthChecks {return false}
    if lhs.localityEndpoints != rhs.localityEndpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Service_Discovery_V2_HealthCheckSpecifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthCheckSpecifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_health_checks"),
    2: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusterHealthChecks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._interval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterHealthChecks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusterHealthChecks, fieldNumber: 1)
    }
    if let v = self._interval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Service_Discovery_V2_HealthCheckSpecifier, rhs: Envoy_Service_Discovery_V2_HealthCheckSpecifier) -> Bool {
    if lhs.clusterHealthChecks != rhs.clusterHealthChecks {return false}
    if lhs._interval != rhs._interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

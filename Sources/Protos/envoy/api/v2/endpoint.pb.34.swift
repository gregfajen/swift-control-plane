// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/api/v2/endpoint.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Each route from RDS will map to a single cluster or traffic split across
/// clusters using weights expressed in the RDS WeightedCluster.
///
/// With EDS, each cluster is treated independently from a LB perspective, with
/// LB taking place between the Localities within a cluster and at a finer
/// granularity between the hosts within a locality. The percentage of traffic
/// for each endpoint is determined by both its load_balancing_weight, and the
/// load_balancing_weight of its locality. First, a locality will be selected,
/// then an endpoint within that locality will be chose based on its weight.
/// [#next-free-field: 6]
public struct Envoy_Api_V2_ClusterLoadAssignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the cluster. This will be the :ref:`service_name
  /// <envoy_api_field_Cluster.EdsClusterConfig.service_name>` value if specified
  /// in the cluster :ref:`EdsClusterConfig
  /// <envoy_api_msg_Cluster.EdsClusterConfig>`.
  public var clusterName: String = String()

  /// List of endpoints to load balance to.
  public var endpoints: [Envoy_Api_V2_Endpoint_LocalityLbEndpoints] = []

  /// Map of named endpoints that can be referenced in LocalityLbEndpoints.
  /// [#not-implemented-hide:]
  public var namedEndpoints: Dictionary<String,Envoy_Api_V2_Endpoint_Endpoint> = [:]

  /// Load balancing policy settings.
  public var policy: Envoy_Api_V2_ClusterLoadAssignment.Policy {
    get {return _policy ?? Envoy_Api_V2_ClusterLoadAssignment.Policy()}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {self._policy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Load balancing policy settings.
  /// [#next-free-field: 6]
  public struct Policy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Action to trim the overall incoming traffic to protect the upstream
    /// hosts. This action allows protection in case the hosts are unable to
    /// recover from an outage, or unable to autoscale or unable to handle
    /// incoming traffic volume for any reason.
    ///
    /// At the client each category is applied one after the other to generate
    /// the 'actual' drop percentage on all outgoing traffic. For example:
    ///
    /// .. code-block:: json
    ///
    ///  { "drop_overloads": [
    ///      { "category": "throttle", "drop_percentage": 60 }
    ///      { "category": "lb", "drop_percentage": 50 }
    ///  ]}
    ///
    /// The actual drop percentages applied to the traffic at the clients will be
    ///    "throttle"_drop = 60%
    ///    "lb"_drop = 20%  // 50% of the remaining 'actual' load, which is 40%.
    ///    actual_outgoing_load = 20% // remaining after applying all categories.
    /// [#not-implemented-hide:]
    public var dropOverloads: [Envoy_Api_V2_ClusterLoadAssignment.Policy.DropOverload] = []

    /// Priority levels and localities are considered overprovisioned with this
    /// factor (in percentage). This means that we don't consider a priority
    /// level or locality unhealthy until the percentage of healthy hosts
    /// multiplied by the overprovisioning factor drops below 100.
    /// With the default value 140(1.4), Envoy doesn't consider a priority level
    /// or a locality unhealthy until their percentage of healthy hosts drops
    /// below 72%. For example:
    ///
    /// .. code-block:: json
    ///
    ///  { "overprovisioning_factor": 100 }
    ///
    /// Read more at :ref:`priority levels <arch_overview_load_balancing_priority_levels>` and
    /// :ref:`localities <arch_overview_load_balancing_locality_weighted_lb>`.
    public var overprovisioningFactor: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _overprovisioningFactor ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_overprovisioningFactor = newValue}
    }
    /// Returns true if `overprovisioningFactor` has been explicitly set.
    public var hasOverprovisioningFactor: Bool {return self._overprovisioningFactor != nil}
    /// Clears the value of `overprovisioningFactor`. Subsequent reads from it will return its default value.
    public mutating func clearOverprovisioningFactor() {self._overprovisioningFactor = nil}

    /// The max time until which the endpoints from this assignment can be used.
    /// If no new assignments are received before this time expires the endpoints
    /// are considered stale and should be marked unhealthy.
    /// Defaults to 0 which means endpoints never go stale.
    public var endpointStaleAfter: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _endpointStaleAfter ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_endpointStaleAfter = newValue}
    }
    /// Returns true if `endpointStaleAfter` has been explicitly set.
    public var hasEndpointStaleAfter: Bool {return self._endpointStaleAfter != nil}
    /// Clears the value of `endpointStaleAfter`. Subsequent reads from it will return its default value.
    public mutating func clearEndpointStaleAfter() {self._endpointStaleAfter = nil}

    /// The flag to disable overprovisioning. If it is set to true,
    /// :ref:`overprovisioning factor
    /// <arch_overview_load_balancing_overprovisioning_factor>` will be ignored
    /// and Envoy will not perform graceful failover between priority levels or
    /// localities as endpoints become unhealthy. Otherwise Envoy will perform
    /// graceful failover as :ref:`overprovisioning factor
    /// <arch_overview_load_balancing_overprovisioning_factor>` suggests.
    /// [#not-implemented-hide:]
    public var disableOverprovisioning: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// [#not-implemented-hide:]
    public struct DropOverload {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Identifier for the policy specifying the drop.
      public var category: String = String()

      /// Percentage of traffic that should be dropped for the category.
      public var dropPercentage: Envoy_Type_FractionalPercent {
        get {return _dropPercentage ?? Envoy_Type_FractionalPercent()}
        set {_dropPercentage = newValue}
      }
      /// Returns true if `dropPercentage` has been explicitly set.
      public var hasDropPercentage: Bool {return self._dropPercentage != nil}
      /// Clears the value of `dropPercentage`. Subsequent reads from it will return its default value.
      public mutating func clearDropPercentage() {self._dropPercentage = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _dropPercentage: Envoy_Type_FractionalPercent? = nil
    }

    public init() {}

    fileprivate var _overprovisioningFactor: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _endpointStaleAfter: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _policy: Envoy_Api_V2_ClusterLoadAssignment.Policy? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.api.v2"

extension Envoy_Api_V2_ClusterLoadAssignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterLoadAssignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
    2: .same(proto: "endpoints"),
    5: .standard(proto: "named_endpoints"),
    4: .same(proto: "policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._policy) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Api_V2_Endpoint_Endpoint>.self, value: &self.namedEndpoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 2)
    }
    if let v = self._policy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.namedEndpoints.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Api_V2_Endpoint_Endpoint>.self, value: self.namedEndpoints, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_ClusterLoadAssignment, rhs: Envoy_Api_V2_ClusterLoadAssignment) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.namedEndpoints != rhs.namedEndpoints {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_ClusterLoadAssignment.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_ClusterLoadAssignment.protoMessageName + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "drop_overloads"),
    3: .standard(proto: "overprovisioning_factor"),
    4: .standard(proto: "endpoint_stale_after"),
    5: .standard(proto: "disable_overprovisioning"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.dropOverloads) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._overprovisioningFactor) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endpointStaleAfter) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disableOverprovisioning) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dropOverloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dropOverloads, fieldNumber: 2)
    }
    if let v = self._overprovisioningFactor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endpointStaleAfter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.disableOverprovisioning != false {
      try visitor.visitSingularBoolField(value: self.disableOverprovisioning, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_ClusterLoadAssignment.Policy, rhs: Envoy_Api_V2_ClusterLoadAssignment.Policy) -> Bool {
    if lhs.dropOverloads != rhs.dropOverloads {return false}
    if lhs._overprovisioningFactor != rhs._overprovisioningFactor {return false}
    if lhs._endpointStaleAfter != rhs._endpointStaleAfter {return false}
    if lhs.disableOverprovisioning != rhs.disableOverprovisioning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_ClusterLoadAssignment.Policy.DropOverload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_ClusterLoadAssignment.Policy.protoMessageName + ".DropOverload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    2: .standard(proto: "drop_percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dropPercentage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 1)
    }
    if let v = self._dropPercentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_ClusterLoadAssignment.Policy.DropOverload, rhs: Envoy_Api_V2_ClusterLoadAssignment.Policy.DropOverload) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs._dropPercentage != rhs._dropPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

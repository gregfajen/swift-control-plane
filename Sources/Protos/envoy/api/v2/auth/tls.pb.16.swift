// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/api/v2/auth/tls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Api_V2_Auth_UpstreamTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common TLS context settings.
  ///
  /// .. attention::
  ///
  ///   Server certificate verification is not enabled by default. Configure
  ///   :ref:`trusted_ca<envoy_api_field_auth.CertificateValidationContext.trusted_ca>` to enable
  ///   verification.
  public var commonTlsContext: Envoy_Api_V2_Auth_CommonTlsContext {
    get {return _commonTlsContext ?? Envoy_Api_V2_Auth_CommonTlsContext()}
    set {_commonTlsContext = newValue}
  }
  /// Returns true if `commonTlsContext` has been explicitly set.
  public var hasCommonTlsContext: Bool {return self._commonTlsContext != nil}
  /// Clears the value of `commonTlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearCommonTlsContext() {self._commonTlsContext = nil}

  /// SNI string to use when creating TLS backend connections.
  public var sni: String = String()

  /// If true, server-initiated TLS renegotiation will be allowed.
  ///
  /// .. attention::
  ///
  ///   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
  public var allowRenegotiation: Bool = false

  /// Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
  /// for TLSv1.2 and older) to store for the purpose of session resumption.
  ///
  /// Defaults to 1, setting this to 0 disables session resumption.
  public var maxSessionKeys: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxSessionKeys ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxSessionKeys = newValue}
  }
  /// Returns true if `maxSessionKeys` has been explicitly set.
  public var hasMaxSessionKeys: Bool {return self._maxSessionKeys != nil}
  /// Clears the value of `maxSessionKeys`. Subsequent reads from it will return its default value.
  public mutating func clearMaxSessionKeys() {self._maxSessionKeys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commonTlsContext: Envoy_Api_V2_Auth_CommonTlsContext? = nil
  fileprivate var _maxSessionKeys: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#next-free-field: 8]
public struct Envoy_Api_V2_Auth_DownstreamTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common TLS context settings.
  public var commonTlsContext: Envoy_Api_V2_Auth_CommonTlsContext {
    get {return _storage._commonTlsContext ?? Envoy_Api_V2_Auth_CommonTlsContext()}
    set {_uniqueStorage()._commonTlsContext = newValue}
  }
  /// Returns true if `commonTlsContext` has been explicitly set.
  public var hasCommonTlsContext: Bool {return _storage._commonTlsContext != nil}
  /// Clears the value of `commonTlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearCommonTlsContext() {_uniqueStorage()._commonTlsContext = nil}

  /// If specified, Envoy will reject connections without a valid client
  /// certificate.
  public var requireClientCertificate: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._requireClientCertificate ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._requireClientCertificate = newValue}
  }
  /// Returns true if `requireClientCertificate` has been explicitly set.
  public var hasRequireClientCertificate: Bool {return _storage._requireClientCertificate != nil}
  /// Clears the value of `requireClientCertificate`. Subsequent reads from it will return its default value.
  public mutating func clearRequireClientCertificate() {_uniqueStorage()._requireClientCertificate = nil}

  /// If specified, Envoy will reject connections without a valid and matching SNI.
  /// [#not-implemented-hide:]
  public var requireSni: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._requireSni ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._requireSni = newValue}
  }
  /// Returns true if `requireSni` has been explicitly set.
  public var hasRequireSni: Bool {return _storage._requireSni != nil}
  /// Clears the value of `requireSni`. Subsequent reads from it will return its default value.
  public mutating func clearRequireSni() {_uniqueStorage()._requireSni = nil}

  public var sessionTicketKeysType: OneOf_SessionTicketKeysType? {
    get {return _storage._sessionTicketKeysType}
    set {_uniqueStorage()._sessionTicketKeysType = newValue}
  }

  /// TLS session ticket key settings.
  public var sessionTicketKeys: Envoy_Api_V2_Auth_TlsSessionTicketKeys {
    get {
      if case .sessionTicketKeys(let v)? = _storage._sessionTicketKeysType {return v}
      return Envoy_Api_V2_Auth_TlsSessionTicketKeys()
    }
    set {_uniqueStorage()._sessionTicketKeysType = .sessionTicketKeys(newValue)}
  }

  /// Config for fetching TLS session ticket keys via SDS API.
  public var sessionTicketKeysSdsSecretConfig: Envoy_Api_V2_Auth_SdsSecretConfig {
    get {
      if case .sessionTicketKeysSdsSecretConfig(let v)? = _storage._sessionTicketKeysType {return v}
      return Envoy_Api_V2_Auth_SdsSecretConfig()
    }
    set {_uniqueStorage()._sessionTicketKeysType = .sessionTicketKeysSdsSecretConfig(newValue)}
  }

  /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
  /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
  /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
  /// the keys specified through either :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
  /// or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
  /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
  /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
  /// implication that sessions cannot be resumed across hot restarts or on different hosts.
  public var disableStatelessSessionResumption: Bool {
    get {
      if case .disableStatelessSessionResumption(let v)? = _storage._sessionTicketKeysType {return v}
      return false
    }
    set {_uniqueStorage()._sessionTicketKeysType = .disableStatelessSessionResumption(newValue)}
  }

  /// If specified, session_timeout will change maximum lifetime (in seconds) of TLS session
  /// Currently this value is used as a hint to `TLS session ticket lifetime (for TLSv1.2)
  /// <https://tools.ietf.org/html/rfc5077#section-5.6>`
  /// only seconds could be specified (fractional seconds are going to be ignored).
  public var sessionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._sessionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._sessionTimeout = newValue}
  }
  /// Returns true if `sessionTimeout` has been explicitly set.
  public var hasSessionTimeout: Bool {return _storage._sessionTimeout != nil}
  /// Clears the value of `sessionTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearSessionTimeout() {_uniqueStorage()._sessionTimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SessionTicketKeysType: Equatable {
    /// TLS session ticket key settings.
    case sessionTicketKeys(Envoy_Api_V2_Auth_TlsSessionTicketKeys)
    /// Config for fetching TLS session ticket keys via SDS API.
    case sessionTicketKeysSdsSecretConfig(Envoy_Api_V2_Auth_SdsSecretConfig)
    /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    /// the keys specified through either :ref:`session_ticket_keys <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys>`
    /// or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_auth.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
    /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    /// implication that sessions cannot be resumed across hot restarts or on different hosts.
    case disableStatelessSessionResumption(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Api_V2_Auth_DownstreamTlsContext.OneOf_SessionTicketKeysType, rhs: Envoy_Api_V2_Auth_DownstreamTlsContext.OneOf_SessionTicketKeysType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionTicketKeys, .sessionTicketKeys): return {
        guard case .sessionTicketKeys(let l) = lhs, case .sessionTicketKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionTicketKeysSdsSecretConfig, .sessionTicketKeysSdsSecretConfig): return {
        guard case .sessionTicketKeysSdsSecretConfig(let l) = lhs, case .sessionTicketKeysSdsSecretConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.disableStatelessSessionResumption, .disableStatelessSessionResumption): return {
        guard case .disableStatelessSessionResumption(let l) = lhs, case .disableStatelessSessionResumption(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TLS context shared by both client and server TLS contexts.
/// [#next-free-field: 9]
public struct Envoy_Api_V2_Auth_CommonTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLS protocol versions, cipher suites etc.
  public var tlsParams: Envoy_Api_V2_Auth_TlsParameters {
    get {return _storage._tlsParams ?? Envoy_Api_V2_Auth_TlsParameters()}
    set {_uniqueStorage()._tlsParams = newValue}
  }
  /// Returns true if `tlsParams` has been explicitly set.
  public var hasTlsParams: Bool {return _storage._tlsParams != nil}
  /// Clears the value of `tlsParams`. Subsequent reads from it will return its default value.
  public mutating func clearTlsParams() {_uniqueStorage()._tlsParams = nil}

  /// :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
  /// same context to allow both RSA and ECDSA certificates.
  ///
  /// Only a single TLS certificate is supported in client contexts. In server contexts, the first
  /// RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
  /// used for clients that support ECDSA.
  public var tlsCertificates: [Envoy_Api_V2_Auth_TlsCertificate] {
    get {return _storage._tlsCertificates}
    set {_uniqueStorage()._tlsCertificates = newValue}
  }

  /// Configs for fetching TLS certificates via SDS API.
  public var tlsCertificateSdsSecretConfigs: [Envoy_Api_V2_Auth_SdsSecretConfig] {
    get {return _storage._tlsCertificateSdsSecretConfigs}
    set {_uniqueStorage()._tlsCertificateSdsSecretConfigs = newValue}
  }

  public var validationContextType: OneOf_ValidationContextType? {
    get {return _storage._validationContextType}
    set {_uniqueStorage()._validationContextType = newValue}
  }

  /// How to validate peer certificates.
  public var validationContext: Envoy_Api_V2_Auth_CertificateValidationContext {
    get {
      if case .validationContext(let v)? = _storage._validationContextType {return v}
      return Envoy_Api_V2_Auth_CertificateValidationContext()
    }
    set {_uniqueStorage()._validationContextType = .validationContext(newValue)}
  }

  /// Config for fetching validation context via SDS API.
  public var validationContextSdsSecretConfig: Envoy_Api_V2_Auth_SdsSecretConfig {
    get {
      if case .validationContextSdsSecretConfig(let v)? = _storage._validationContextType {return v}
      return Envoy_Api_V2_Auth_SdsSecretConfig()
    }
    set {_uniqueStorage()._validationContextType = .validationContextSdsSecretConfig(newValue)}
  }

  /// Combined certificate validation context holds a default CertificateValidationContext
  /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
  /// and default CertificateValidationContext are merged into a new CertificateValidationContext
  /// for validation. This merge is done by Message::MergeFrom(), so dynamic
  /// CertificateValidationContext overwrites singular fields in default
  /// CertificateValidationContext, and concatenates repeated fields to default
  /// CertificateValidationContext, and logical OR is applied to boolean fields.
  public var combinedValidationContext: Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext {
    get {
      if case .combinedValidationContext(let v)? = _storage._validationContextType {return v}
      return Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext()
    }
    set {_uniqueStorage()._validationContextType = .combinedValidationContext(newValue)}
  }

  /// Supplies the list of ALPN protocols that the listener should expose. In
  /// practice this is likely to be set to one of two values (see the
  /// :ref:`codec_type
  /// <envoy_api_field_config.filter.network.http_connection_manager.v2.HttpConnectionManager.codec_type>`
  /// parameter in the HTTP connection manager for more information):
  ///
  /// * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
  /// * "http/1.1" If the listener is only going to support HTTP/1.1.
  ///
  /// There is no default for this parameter. If empty, Envoy will not expose ALPN.
  public var alpnProtocols: [String] {
    get {return _storage._alpnProtocols}
    set {_uniqueStorage()._alpnProtocols = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ValidationContextType: Equatable {
    /// How to validate peer certificates.
    case validationContext(Envoy_Api_V2_Auth_CertificateValidationContext)
    /// Config for fetching validation context via SDS API.
    case validationContextSdsSecretConfig(Envoy_Api_V2_Auth_SdsSecretConfig)
    /// Combined certificate validation context holds a default CertificateValidationContext
    /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
    /// and default CertificateValidationContext are merged into a new CertificateValidationContext
    /// for validation. This merge is done by Message::MergeFrom(), so dynamic
    /// CertificateValidationContext overwrites singular fields in default
    /// CertificateValidationContext, and concatenates repeated fields to default
    /// CertificateValidationContext, and logical OR is applied to boolean fields.
    case combinedValidationContext(Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Api_V2_Auth_CommonTlsContext.OneOf_ValidationContextType, rhs: Envoy_Api_V2_Auth_CommonTlsContext.OneOf_ValidationContextType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.validationContext, .validationContext): return {
        guard case .validationContext(let l) = lhs, case .validationContext(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validationContextSdsSecretConfig, .validationContextSdsSecretConfig): return {
        guard case .validationContextSdsSecretConfig(let l) = lhs, case .validationContextSdsSecretConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.combinedValidationContext, .combinedValidationContext): return {
        guard case .combinedValidationContext(let l) = lhs, case .combinedValidationContext(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct CombinedCertificateValidationContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How to validate peer certificates.
    public var defaultValidationContext: Envoy_Api_V2_Auth_CertificateValidationContext {
      get {return _storage._defaultValidationContext ?? Envoy_Api_V2_Auth_CertificateValidationContext()}
      set {_uniqueStorage()._defaultValidationContext = newValue}
    }
    /// Returns true if `defaultValidationContext` has been explicitly set.
    public var hasDefaultValidationContext: Bool {return _storage._defaultValidationContext != nil}
    /// Clears the value of `defaultValidationContext`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultValidationContext() {_uniqueStorage()._defaultValidationContext = nil}

    /// Config for fetching validation context via SDS API.
    public var validationContextSdsSecretConfig: Envoy_Api_V2_Auth_SdsSecretConfig {
      get {return _storage._validationContextSdsSecretConfig ?? Envoy_Api_V2_Auth_SdsSecretConfig()}
      set {_uniqueStorage()._validationContextSdsSecretConfig = newValue}
    }
    /// Returns true if `validationContextSdsSecretConfig` has been explicitly set.
    public var hasValidationContextSdsSecretConfig: Bool {return _storage._validationContextSdsSecretConfig != nil}
    /// Clears the value of `validationContextSdsSecretConfig`. Subsequent reads from it will return its default value.
    public mutating func clearValidationContextSdsSecretConfig() {_uniqueStorage()._validationContextSdsSecretConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.api.v2.auth"

extension Envoy_Api_V2_Auth_UpstreamTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_tls_context"),
    2: .same(proto: "sni"),
    3: .standard(proto: "allow_renegotiation"),
    4: .standard(proto: "max_session_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commonTlsContext) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sni) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowRenegotiation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxSessionKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commonTlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.sni.isEmpty {
      try visitor.visitSingularStringField(value: self.sni, fieldNumber: 2)
    }
    if self.allowRenegotiation != false {
      try visitor.visitSingularBoolField(value: self.allowRenegotiation, fieldNumber: 3)
    }
    if let v = self._maxSessionKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Auth_UpstreamTlsContext, rhs: Envoy_Api_V2_Auth_UpstreamTlsContext) -> Bool {
    if lhs._commonTlsContext != rhs._commonTlsContext {return false}
    if lhs.sni != rhs.sni {return false}
    if lhs.allowRenegotiation != rhs.allowRenegotiation {return false}
    if lhs._maxSessionKeys != rhs._maxSessionKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Auth_DownstreamTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownstreamTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_tls_context"),
    2: .standard(proto: "require_client_certificate"),
    3: .standard(proto: "require_sni"),
    4: .standard(proto: "session_ticket_keys"),
    5: .standard(proto: "session_ticket_keys_sds_secret_config"),
    7: .standard(proto: "disable_stateless_session_resumption"),
    6: .standard(proto: "session_timeout"),
  ]

  fileprivate class _StorageClass {
    var _commonTlsContext: Envoy_Api_V2_Auth_CommonTlsContext? = nil
    var _requireClientCertificate: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _requireSni: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _sessionTicketKeysType: Envoy_Api_V2_Auth_DownstreamTlsContext.OneOf_SessionTicketKeysType?
    var _sessionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commonTlsContext = source._commonTlsContext
      _requireClientCertificate = source._requireClientCertificate
      _requireSni = source._requireSni
      _sessionTicketKeysType = source._sessionTicketKeysType
      _sessionTimeout = source._sessionTimeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._commonTlsContext) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._requireClientCertificate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._requireSni) }()
        case 4: try {
          var v: Envoy_Api_V2_Auth_TlsSessionTicketKeys?
          if let current = _storage._sessionTicketKeysType {
            try decoder.handleConflictingOneOf()
            if case .sessionTicketKeys(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sessionTicketKeysType = .sessionTicketKeys(v)}
        }()
        case 5: try {
          var v: Envoy_Api_V2_Auth_SdsSecretConfig?
          if let current = _storage._sessionTicketKeysType {
            try decoder.handleConflictingOneOf()
            if case .sessionTicketKeysSdsSecretConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sessionTicketKeysType = .sessionTicketKeysSdsSecretConfig(v)}
        }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sessionTimeout) }()
        case 7: try {
          if _storage._sessionTicketKeysType != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._sessionTicketKeysType = .disableStatelessSessionResumption(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._commonTlsContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._requireClientCertificate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._requireSni {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._sessionTicketKeysType {
      case .sessionTicketKeys?: try {
        guard case .sessionTicketKeys(let v)? = _storage._sessionTicketKeysType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .sessionTicketKeysSdsSecretConfig?: try {
        guard case .sessionTicketKeysSdsSecretConfig(let v)? = _storage._sessionTicketKeysType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      default: break
      }
      if let v = _storage._sessionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if case .disableStatelessSessionResumption(let v)? = _storage._sessionTicketKeysType {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Auth_DownstreamTlsContext, rhs: Envoy_Api_V2_Auth_DownstreamTlsContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commonTlsContext != rhs_storage._commonTlsContext {return false}
        if _storage._requireClientCertificate != rhs_storage._requireClientCertificate {return false}
        if _storage._requireSni != rhs_storage._requireSni {return false}
        if _storage._sessionTicketKeysType != rhs_storage._sessionTicketKeysType {return false}
        if _storage._sessionTimeout != rhs_storage._sessionTimeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Auth_CommonTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tls_params"),
    2: .standard(proto: "tls_certificates"),
    6: .standard(proto: "tls_certificate_sds_secret_configs"),
    3: .standard(proto: "validation_context"),
    7: .standard(proto: "validation_context_sds_secret_config"),
    8: .standard(proto: "combined_validation_context"),
    4: .standard(proto: "alpn_protocols"),
  ]

  fileprivate class _StorageClass {
    var _tlsParams: Envoy_Api_V2_Auth_TlsParameters? = nil
    var _tlsCertificates: [Envoy_Api_V2_Auth_TlsCertificate] = []
    var _tlsCertificateSdsSecretConfigs: [Envoy_Api_V2_Auth_SdsSecretConfig] = []
    var _validationContextType: Envoy_Api_V2_Auth_CommonTlsContext.OneOf_ValidationContextType?
    var _alpnProtocols: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tlsParams = source._tlsParams
      _tlsCertificates = source._tlsCertificates
      _tlsCertificateSdsSecretConfigs = source._tlsCertificateSdsSecretConfigs
      _validationContextType = source._validationContextType
      _alpnProtocols = source._alpnProtocols
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tlsParams) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._tlsCertificates) }()
        case 3: try {
          var v: Envoy_Api_V2_Auth_CertificateValidationContext?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .validationContext(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .validationContext(v)}
        }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._alpnProtocols) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._tlsCertificateSdsSecretConfigs) }()
        case 7: try {
          var v: Envoy_Api_V2_Auth_SdsSecretConfig?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .validationContextSdsSecretConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .validationContextSdsSecretConfig(v)}
        }()
        case 8: try {
          var v: Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .combinedValidationContext(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .combinedValidationContext(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tlsParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tlsCertificates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tlsCertificates, fieldNumber: 2)
      }
      if case .validationContext(let v)? = _storage._validationContextType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._alpnProtocols.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._alpnProtocols, fieldNumber: 4)
      }
      if !_storage._tlsCertificateSdsSecretConfigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tlsCertificateSdsSecretConfigs, fieldNumber: 6)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._validationContextType {
      case .validationContextSdsSecretConfig?: try {
        guard case .validationContextSdsSecretConfig(let v)? = _storage._validationContextType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .combinedValidationContext?: try {
        guard case .combinedValidationContext(let v)? = _storage._validationContextType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      default: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Auth_CommonTlsContext, rhs: Envoy_Api_V2_Auth_CommonTlsContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tlsParams != rhs_storage._tlsParams {return false}
        if _storage._tlsCertificates != rhs_storage._tlsCertificates {return false}
        if _storage._tlsCertificateSdsSecretConfigs != rhs_storage._tlsCertificateSdsSecretConfigs {return false}
        if _storage._validationContextType != rhs_storage._validationContextType {return false}
        if _storage._alpnProtocols != rhs_storage._alpnProtocols {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Auth_CommonTlsContext.protoMessageName + ".CombinedCertificateValidationContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_validation_context"),
    2: .standard(proto: "validation_context_sds_secret_config"),
  ]

  fileprivate class _StorageClass {
    var _defaultValidationContext: Envoy_Api_V2_Auth_CertificateValidationContext? = nil
    var _validationContextSdsSecretConfig: Envoy_Api_V2_Auth_SdsSecretConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _defaultValidationContext = source._defaultValidationContext
      _validationContextSdsSecretConfig = source._validationContextSdsSecretConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._defaultValidationContext) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._validationContextSdsSecretConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._defaultValidationContext {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._validationContextSdsSecretConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext, rhs: Envoy_Api_V2_Auth_CommonTlsContext.CombinedCertificateValidationContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._defaultValidationContext != rhs_storage._defaultValidationContext {return false}
        if _storage._validationContextSdsSecretConfig != rhs_storage._validationContextSdsSecretConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

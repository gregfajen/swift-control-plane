// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/api/v2/scoped_route.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies a routing scope, which associates a
/// :ref:`Key<envoy_api_msg_ScopedRouteConfiguration.Key>` to a
/// :ref:`envoy_api_msg_RouteConfiguration` (identified by its resource name).
///
/// The HTTP connection manager builds up a table consisting of these Key to
/// RouteConfiguration mappings, and looks up the RouteConfiguration to use per
/// request according to the algorithm specified in the
/// :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`
/// assigned to the HttpConnectionManager.
///
/// For example, with the following configurations (in YAML):
///
/// HttpConnectionManager config:
///
/// .. code::
///
///   ...
///   scoped_routes:
///     name: foo-scoped-routes
///     scope_key_builder:
///       fragments:
///         - header_value_extractor:
///             name: X-Route-Selector
///             element_separator: ,
///             element:
///               separator: =
///               key: vip
///
/// ScopedRouteConfiguration resources (specified statically via
/// :ref:`scoped_route_configurations_list<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scoped_route_configurations_list>`
/// or obtained dynamically via SRDS):
///
/// .. code::
///
///  (1)
///   name: route-scope1
///   route_configuration_name: route-config1
///   key:
///      fragments:
///        - string_key: 172.10.10.20
///
///  (2)
///   name: route-scope2
///   route_configuration_name: route-config2
///   key:
///     fragments:
///       - string_key: 172.20.20.30
///
/// A request from a client such as:
///
/// .. code::
///
///     GET / HTTP/1.1
///     Host: foo.com
///     X-Route-Selector: vip=172.10.10.20
///
/// would result in the routing table defined by the `route-config1`
/// RouteConfiguration being assigned to the HTTP request/stream.
public struct Envoy_Api_V2_ScopedRouteConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name assigned to the routing scope.
  public var name: String = String()

  /// The resource name to use for a :ref:`envoy_api_msg_DiscoveryRequest` to an
  /// RDS server to fetch the :ref:`envoy_api_msg_RouteConfiguration` associated
  /// with this scope.
  public var routeConfigurationName: String = String()

  /// The key to match against.
  public var key: Envoy_Api_V2_ScopedRouteConfiguration.Key {
    get {return _key ?? Envoy_Api_V2_ScopedRouteConfiguration.Key()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies a key which is matched against the output of the
  /// :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`
  /// specified in the HttpConnectionManager. The matching is done per HTTP
  /// request and is dependent on the order of the fragments contained in the
  /// Key.
  public struct Key {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ordered set of fragments to match against. The order must match the
    /// fragments in the corresponding
    /// :ref:`scope_key_builder<envoy_api_field_config.filter.network.http_connection_manager.v2.ScopedRoutes.scope_key_builder>`.
    public var fragments: [Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Fragment {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment.OneOf_Type? = nil

      /// A string to match against.
      public var stringKey: String {
        get {
          if case .stringKey(let v)? = type {return v}
          return String()
        }
        set {type = .stringKey(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Type: Equatable {
        /// A string to match against.
        case stringKey(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment.OneOf_Type, rhs: Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment.OneOf_Type) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.stringKey, .stringKey): return {
            guard case .stringKey(let l) = lhs, case .stringKey(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          }
        }
      #endif
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _key: Envoy_Api_V2_ScopedRouteConfiguration.Key? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.api.v2"

extension Envoy_Api_V2_ScopedRouteConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopedRouteConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "route_configuration_name"),
    3: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.routeConfigurationName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.routeConfigurationName.isEmpty {
      try visitor.visitSingularStringField(value: self.routeConfigurationName, fieldNumber: 2)
    }
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_ScopedRouteConfiguration, rhs: Envoy_Api_V2_ScopedRouteConfiguration) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.routeConfigurationName != rhs.routeConfigurationName {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_ScopedRouteConfiguration.Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_ScopedRouteConfiguration.protoMessageName + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fragments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fragments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fragments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fragments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_ScopedRouteConfiguration.Key, rhs: Envoy_Api_V2_ScopedRouteConfiguration.Key) -> Bool {
    if lhs.fragments != rhs.fragments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_ScopedRouteConfiguration.Key.protoMessageName + ".Fragment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "string_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .stringKey(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .stringKey(let v)? = self.type {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment, rhs: Envoy_Api_V2_ScopedRouteConfiguration.Key.Fragment) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

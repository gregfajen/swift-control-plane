// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/api/v2/core/grpc_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// gRPC service configuration. This is used by :ref:`ApiConfigSource
/// <envoy_api_msg_core.ApiConfigSource>` and filter configurations.
/// [#next-free-field: 6]
public struct Envoy_Api_V2_Core_GrpcService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var targetSpecifier: Envoy_Api_V2_Core_GrpcService.OneOf_TargetSpecifier? = nil

  /// Envoy's in-built gRPC client.
  /// See the :ref:`gRPC services overview <arch_overview_grpc_services>`
  /// documentation for discussion on gRPC client selection.
  public var envoyGrpc: Envoy_Api_V2_Core_GrpcService.EnvoyGrpc {
    get {
      if case .envoyGrpc(let v)? = targetSpecifier {return v}
      return Envoy_Api_V2_Core_GrpcService.EnvoyGrpc()
    }
    set {targetSpecifier = .envoyGrpc(newValue)}
  }

  /// `Google C++ gRPC client <https://github.com/grpc/grpc>`_
  /// See the :ref:`gRPC services overview <arch_overview_grpc_services>`
  /// documentation for discussion on gRPC client selection.
  public var googleGrpc: Envoy_Api_V2_Core_GrpcService.GoogleGrpc {
    get {
      if case .googleGrpc(let v)? = targetSpecifier {return v}
      return Envoy_Api_V2_Core_GrpcService.GoogleGrpc()
    }
    set {targetSpecifier = .googleGrpc(newValue)}
  }

  /// The timeout for the gRPC request. This is the timeout for a specific
  /// request.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// Additional metadata to include in streams initiated to the GrpcService.
  /// This can be used for scenarios in which additional ad hoc authorization
  /// headers (e.g. ``x-foo-bar: baz-key``) are to be injected.
  public var initialMetadata: [Envoy_Api_V2_Core_HeaderValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_TargetSpecifier: Equatable {
    /// Envoy's in-built gRPC client.
    /// See the :ref:`gRPC services overview <arch_overview_grpc_services>`
    /// documentation for discussion on gRPC client selection.
    case envoyGrpc(Envoy_Api_V2_Core_GrpcService.EnvoyGrpc)
    /// `Google C++ gRPC client <https://github.com/grpc/grpc>`_
    /// See the :ref:`gRPC services overview <arch_overview_grpc_services>`
    /// documentation for discussion on gRPC client selection.
    case googleGrpc(Envoy_Api_V2_Core_GrpcService.GoogleGrpc)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.OneOf_TargetSpecifier, rhs: Envoy_Api_V2_Core_GrpcService.OneOf_TargetSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.envoyGrpc, .envoyGrpc): return {
        guard case .envoyGrpc(let l) = lhs, case .envoyGrpc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.googleGrpc, .googleGrpc): return {
        guard case .googleGrpc(let l) = lhs, case .googleGrpc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public struct EnvoyGrpc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the upstream gRPC cluster. SSL credentials will be supplied
    /// in the :ref:`Cluster <envoy_api_msg_Cluster>` :ref:`transport_socket
    /// <envoy_api_field_Cluster.transport_socket>`.
    public var clusterName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// [#next-free-field: 7]
  public struct GoogleGrpc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The target URI when using the `Google C++ gRPC client
    /// <https://github.com/grpc/grpc>`_. SSL credentials will be supplied in
    /// :ref:`channel_credentials <envoy_api_field_core.GrpcService.GoogleGrpc.channel_credentials>`.
    public var targetUri: String = String()

    public var channelCredentials: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials {
      get {return _channelCredentials ?? Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials()}
      set {_channelCredentials = newValue}
    }
    /// Returns true if `channelCredentials` has been explicitly set.
    public var hasChannelCredentials: Bool {return self._channelCredentials != nil}
    /// Clears the value of `channelCredentials`. Subsequent reads from it will return its default value.
    public mutating func clearChannelCredentials() {self._channelCredentials = nil}

    /// A set of call credentials that can be composed with `channel credentials
    /// <https://grpc.io/docs/guides/auth.html#credential-types>`_.
    public var callCredentials: [Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials] = []

    /// The human readable prefix to use when emitting statistics for the gRPC
    /// service.
    ///
    /// .. csv-table::
    ///    :header: Name, Type, Description
    ///    :widths: 1, 1, 2
    ///
    ///    streams_total, Counter, Total number of streams opened
    ///    streams_closed_<gRPC status code>, Counter, Total streams closed with <gRPC status code>
    public var statPrefix: String = String()

    /// The name of the Google gRPC credentials factory to use. This must have been registered with
    /// Envoy. If this is empty, a default credentials factory will be used that sets up channel
    /// credentials based on other configuration parameters.
    public var credentialsFactoryName: String = String()

    /// Additional configuration for site-specific customizations of the Google
    /// gRPC library.
    public var config: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _config ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {return self._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {self._config = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// See https://grpc.io/grpc/cpp/structgrpc_1_1_ssl_credentials_options.html.
    public struct SslCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// PEM encoded server root certificates.
      public var rootCerts: Envoy_Api_V2_Core_DataSource {
        get {return _rootCerts ?? Envoy_Api_V2_Core_DataSource()}
        set {_rootCerts = newValue}
      }
      /// Returns true if `rootCerts` has been explicitly set.
      public var hasRootCerts: Bool {return self._rootCerts != nil}
      /// Clears the value of `rootCerts`. Subsequent reads from it will return its default value.
      public mutating func clearRootCerts() {self._rootCerts = nil}

      /// PEM encoded client private key.
      public var privateKey: Envoy_Api_V2_Core_DataSource {
        get {return _privateKey ?? Envoy_Api_V2_Core_DataSource()}
        set {_privateKey = newValue}
      }
      /// Returns true if `privateKey` has been explicitly set.
      public var hasPrivateKey: Bool {return self._privateKey != nil}
      /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
      public mutating func clearPrivateKey() {self._privateKey = nil}

      /// PEM encoded client certificate chain.
      public var certChain: Envoy_Api_V2_Core_DataSource {
        get {return _certChain ?? Envoy_Api_V2_Core_DataSource()}
        set {_certChain = newValue}
      }
      /// Returns true if `certChain` has been explicitly set.
      public var hasCertChain: Bool {return self._certChain != nil}
      /// Clears the value of `certChain`. Subsequent reads from it will return its default value.
      public mutating func clearCertChain() {self._certChain = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _rootCerts: Envoy_Api_V2_Core_DataSource? = nil
      fileprivate var _privateKey: Envoy_Api_V2_Core_DataSource? = nil
      fileprivate var _certChain: Envoy_Api_V2_Core_DataSource? = nil
    }

    /// Local channel credentials. Only UDS is supported for now.
    /// See https://github.com/grpc/grpc/pull/15909.
    public struct GoogleLocalCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// See https://grpc.io/docs/guides/auth.html#credential-types to understand Channel and Call
    /// credential types.
    public struct ChannelCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var credentialSpecifier: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials.OneOf_CredentialSpecifier? = nil

      public var sslCredentials: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials {
        get {
          if case .sslCredentials(let v)? = credentialSpecifier {return v}
          return Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials()
        }
        set {credentialSpecifier = .sslCredentials(newValue)}
      }

      /// https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
      public var googleDefault: SwiftProtobuf.Google_Protobuf_Empty {
        get {
          if case .googleDefault(let v)? = credentialSpecifier {return v}
          return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set {credentialSpecifier = .googleDefault(newValue)}
      }

      public var localCredentials: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials {
        get {
          if case .localCredentials(let v)? = credentialSpecifier {return v}
          return Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials()
        }
        set {credentialSpecifier = .localCredentials(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_CredentialSpecifier: Equatable {
        case sslCredentials(Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials)
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
        case googleDefault(SwiftProtobuf.Google_Protobuf_Empty)
        case localCredentials(Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials)

      #if !swift(>=4.1)
        public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials.OneOf_CredentialSpecifier, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials.OneOf_CredentialSpecifier) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.sslCredentials, .sslCredentials): return {
            guard case .sslCredentials(let l) = lhs, case .sslCredentials(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.googleDefault, .googleDefault): return {
            guard case .googleDefault(let l) = lhs, case .googleDefault(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.localCredentials, .localCredentials): return {
            guard case .localCredentials(let l) = lhs, case .localCredentials(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// [#next-free-field: 8]
    public struct CallCredentials {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var credentialSpecifier: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.OneOf_CredentialSpecifier? = nil

      /// Access token credentials.
      /// https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d.
      public var accessToken: String {
        get {
          if case .accessToken(let v)? = credentialSpecifier {return v}
          return String()
        }
        set {credentialSpecifier = .accessToken(newValue)}
      }

      /// Google Compute Engine credentials.
      /// https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
      public var googleComputeEngine: SwiftProtobuf.Google_Protobuf_Empty {
        get {
          if case .googleComputeEngine(let v)? = credentialSpecifier {return v}
          return SwiftProtobuf.Google_Protobuf_Empty()
        }
        set {credentialSpecifier = .googleComputeEngine(newValue)}
      }

      /// Google refresh token credentials.
      /// https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c.
      public var googleRefreshToken: String {
        get {
          if case .googleRefreshToken(let v)? = credentialSpecifier {return v}
          return String()
        }
        set {credentialSpecifier = .googleRefreshToken(newValue)}
      }

      /// Service Account JWT Access credentials.
      /// https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa.
      public var serviceAccountJwtAccess: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials {
        get {
          if case .serviceAccountJwtAccess(let v)? = credentialSpecifier {return v}
          return Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials()
        }
        set {credentialSpecifier = .serviceAccountJwtAccess(newValue)}
      }

      /// Google IAM credentials.
      /// https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0.
      public var googleIam: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials {
        get {
          if case .googleIam(let v)? = credentialSpecifier {return v}
          return Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials()
        }
        set {credentialSpecifier = .googleIam(newValue)}
      }

      /// Custom authenticator credentials.
      /// https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07.
      /// https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms.
      public var fromPlugin: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin {
        get {
          if case .fromPlugin(let v)? = credentialSpecifier {return v}
          return Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin()
        }
        set {credentialSpecifier = .fromPlugin(newValue)}
      }

      /// Custom security token service which implements OAuth 2.0 token exchange.
      /// https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16
      /// See https://github.com/grpc/grpc/pull/19587.
      public var stsService: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService {
        get {
          if case .stsService(let v)? = credentialSpecifier {return v}
          return Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService()
        }
        set {credentialSpecifier = .stsService(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_CredentialSpecifier: Equatable {
        /// Access token credentials.
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#ad3a80da696ffdaea943f0f858d7a360d.
        case accessToken(String)
        /// Google Compute Engine credentials.
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#a6beb3ac70ff94bd2ebbd89b8f21d1f61
        case googleComputeEngine(SwiftProtobuf.Google_Protobuf_Empty)
        /// Google refresh token credentials.
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#a96901c997b91bc6513b08491e0dca37c.
        case googleRefreshToken(String)
        /// Service Account JWT Access credentials.
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#a92a9f959d6102461f66ee973d8e9d3aa.
        case serviceAccountJwtAccess(Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials)
        /// Google IAM credentials.
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#a9fc1fc101b41e680d47028166e76f9d0.
        case googleIam(Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials)
        /// Custom authenticator credentials.
        /// https://grpc.io/grpc/cpp/namespacegrpc.html#a823c6a4b19ffc71fb33e90154ee2ad07.
        /// https://grpc.io/docs/guides/auth.html#extending-grpc-to-support-other-authentication-mechanisms.
        case fromPlugin(Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin)
        /// Custom security token service which implements OAuth 2.0 token exchange.
        /// https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16
        /// See https://github.com/grpc/grpc/pull/19587.
        case stsService(Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService)

      #if !swift(>=4.1)
        public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.OneOf_CredentialSpecifier, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.OneOf_CredentialSpecifier) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.accessToken, .accessToken): return {
            guard case .accessToken(let l) = lhs, case .accessToken(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.googleComputeEngine, .googleComputeEngine): return {
            guard case .googleComputeEngine(let l) = lhs, case .googleComputeEngine(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.googleRefreshToken, .googleRefreshToken): return {
            guard case .googleRefreshToken(let l) = lhs, case .googleRefreshToken(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.serviceAccountJwtAccess, .serviceAccountJwtAccess): return {
            guard case .serviceAccountJwtAccess(let l) = lhs, case .serviceAccountJwtAccess(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.googleIam, .googleIam): return {
            guard case .googleIam(let l) = lhs, case .googleIam(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.fromPlugin, .fromPlugin): return {
            guard case .fromPlugin(let l) = lhs, case .fromPlugin(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.stsService, .stsService): return {
            guard case .stsService(let l) = lhs, case .stsService(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public struct ServiceAccountJWTAccessCredentials {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var jsonKey: String = String()

        public var tokenLifetimeSeconds: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct GoogleIAMCredentials {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var authorizationToken: String = String()

        public var authoritySelector: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct MetadataCredentialsFromPlugin {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var name: String = String()

        public var configType: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin.OneOf_ConfigType? = nil

        public var config: SwiftProtobuf.Google_Protobuf_Struct {
          get {
            if case .config(let v)? = configType {return v}
            return SwiftProtobuf.Google_Protobuf_Struct()
          }
          set {configType = .config(newValue)}
        }

        public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
          get {
            if case .typedConfig(let v)? = configType {return v}
            return SwiftProtobuf.Google_Protobuf_Any()
          }
          set {configType = .typedConfig(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ConfigType: Equatable {
          case config(SwiftProtobuf.Google_Protobuf_Struct)
          case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

        #if !swift(>=4.1)
          public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin.OneOf_ConfigType, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin.OneOf_ConfigType) -> Bool {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch (lhs, rhs) {
            case (.config, .config): return {
              guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            case (.typedConfig, .typedConfig): return {
              guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
              return l == r
            }()
            default: return false
            }
          }
        #endif
        }

        public init() {}
      }

      /// Security token service configuration that allows Google gRPC to
      /// fetch security token from an OAuth 2.0 authorization server.
      /// See https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16 and
      /// https://github.com/grpc/grpc/pull/19587.
      /// [#next-free-field: 10]
      public struct StsService {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// URI of the token exchange service that handles token exchange requests.
        /// [#comment:TODO(asraa): Add URI validation when implemented. Tracked by
        /// https://github.com/envoyproxy/protoc-gen-validate/issues/303]
        public var tokenExchangeServiceUri: String = String()

        /// Location of the target service or resource where the client
        /// intends to use the requested security token.
        public var resource: String = String()

        /// Logical name of the target service where the client intends to
        /// use the requested security token.
        public var audience: String = String()

        /// The desired scope of the requested security token in the
        /// context of the service or resource where the token will be used.
        public var scope: String = String()

        /// Type of the requested security token.
        public var requestedTokenType: String = String()

        /// The path of subject token, a security token that represents the
        /// identity of the party on behalf of whom the request is being made.
        public var subjectTokenPath: String = String()

        /// Type of the subject token.
        public var subjectTokenType: String = String()

        /// The path of actor token, a security token that represents the identity
        /// of the acting party. The acting party is authorized to use the
        /// requested security token and act on behalf of the subject.
        public var actorTokenPath: String = String()

        /// Type of the actor token.
        public var actorTokenType: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}

    fileprivate var _channelCredentials: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials? = nil
    fileprivate var _config: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.api.v2.core"

extension Envoy_Api_V2_Core_GrpcService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GrpcService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "envoy_grpc"),
    2: .standard(proto: "google_grpc"),
    3: .same(proto: "timeout"),
    5: .standard(proto: "initial_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Api_V2_Core_GrpcService.EnvoyGrpc?
        if let current = self.targetSpecifier {
          try decoder.handleConflictingOneOf()
          if case .envoyGrpc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.targetSpecifier = .envoyGrpc(v)}
      }()
      case 2: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc?
        if let current = self.targetSpecifier {
          try decoder.handleConflictingOneOf()
          if case .googleGrpc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.targetSpecifier = .googleGrpc(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.initialMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.targetSpecifier {
    case .envoyGrpc?: try {
      guard case .envoyGrpc(let v)? = self.targetSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .googleGrpc?: try {
      guard case .googleGrpc(let v)? = self.targetSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.initialMetadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initialMetadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService, rhs: Envoy_Api_V2_Core_GrpcService) -> Bool {
    if lhs.targetSpecifier != rhs.targetSpecifier {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.initialMetadata != rhs.initialMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.EnvoyGrpc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.protoMessageName + ".EnvoyGrpc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.EnvoyGrpc, rhs: Envoy_Api_V2_Core_GrpcService.EnvoyGrpc) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.protoMessageName + ".GoogleGrpc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_uri"),
    2: .standard(proto: "channel_credentials"),
    3: .standard(proto: "call_credentials"),
    4: .standard(proto: "stat_prefix"),
    5: .standard(proto: "credentials_factory_name"),
    6: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetUri) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._channelCredentials) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.callCredentials) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.statPrefix) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.credentialsFactoryName) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetUri.isEmpty {
      try visitor.visitSingularStringField(value: self.targetUri, fieldNumber: 1)
    }
    if let v = self._channelCredentials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.callCredentials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.callCredentials, fieldNumber: 3)
    }
    if !self.statPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.statPrefix, fieldNumber: 4)
    }
    if !self.credentialsFactoryName.isEmpty {
      try visitor.visitSingularStringField(value: self.credentialsFactoryName, fieldNumber: 5)
    }
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc) -> Bool {
    if lhs.targetUri != rhs.targetUri {return false}
    if lhs._channelCredentials != rhs._channelCredentials {return false}
    if lhs.callCredentials != rhs.callCredentials {return false}
    if lhs.statPrefix != rhs.statPrefix {return false}
    if lhs.credentialsFactoryName != rhs.credentialsFactoryName {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.protoMessageName + ".SslCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "root_certs"),
    2: .standard(proto: "private_key"),
    3: .standard(proto: "cert_chain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rootCerts) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._privateKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._certChain) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rootCerts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._privateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._certChain {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials) -> Bool {
    if lhs._rootCerts != rhs._rootCerts {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs._certChain != rhs._certChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.protoMessageName + ".GoogleLocalCredentials"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.protoMessageName + ".ChannelCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ssl_credentials"),
    2: .standard(proto: "google_default"),
    3: .standard(proto: "local_credentials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.SslCredentials?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .sslCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .sslCredentials(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .googleDefault(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .googleDefault(v)}
      }()
      case 3: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.GoogleLocalCredentials?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .localCredentials(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .localCredentials(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.credentialSpecifier {
    case .sslCredentials?: try {
      guard case .sslCredentials(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .googleDefault?: try {
      guard case .googleDefault(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .localCredentials?: try {
      guard case .localCredentials(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.ChannelCredentials) -> Bool {
    if lhs.credentialSpecifier != rhs.credentialSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.protoMessageName + ".CallCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_token"),
    2: .standard(proto: "google_compute_engine"),
    3: .standard(proto: "google_refresh_token"),
    4: .standard(proto: "service_account_jwt_access"),
    5: .standard(proto: "google_iam"),
    6: .standard(proto: "from_plugin"),
    7: .standard(proto: "sts_service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.credentialSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.credentialSpecifier = .accessToken(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .googleComputeEngine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .googleComputeEngine(v)}
      }()
      case 3: try {
        if self.credentialSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.credentialSpecifier = .googleRefreshToken(v)}
      }()
      case 4: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .serviceAccountJwtAccess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .serviceAccountJwtAccess(v)}
      }()
      case 5: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .googleIam(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .googleIam(v)}
      }()
      case 6: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .fromPlugin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .fromPlugin(v)}
      }()
      case 7: try {
        var v: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService?
        if let current = self.credentialSpecifier {
          try decoder.handleConflictingOneOf()
          if case .stsService(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credentialSpecifier = .stsService(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.credentialSpecifier {
    case .accessToken?: try {
      guard case .accessToken(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .googleComputeEngine?: try {
      guard case .googleComputeEngine(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .googleRefreshToken?: try {
      guard case .googleRefreshToken(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .serviceAccountJwtAccess?: try {
      guard case .serviceAccountJwtAccess(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .googleIam?: try {
      guard case .googleIam(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fromPlugin?: try {
      guard case .fromPlugin(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stsService?: try {
      guard case .stsService(let v)? = self.credentialSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials) -> Bool {
    if lhs.credentialSpecifier != rhs.credentialSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.protoMessageName + ".ServiceAccountJWTAccessCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "json_key"),
    2: .standard(proto: "token_lifetime_seconds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jsonKey) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.tokenLifetimeSeconds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jsonKey.isEmpty {
      try visitor.visitSingularStringField(value: self.jsonKey, fieldNumber: 1)
    }
    if self.tokenLifetimeSeconds != 0 {
      try visitor.visitSingularUInt64Field(value: self.tokenLifetimeSeconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.ServiceAccountJWTAccessCredentials) -> Bool {
    if lhs.jsonKey != rhs.jsonKey {return false}
    if lhs.tokenLifetimeSeconds != rhs.tokenLifetimeSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.protoMessageName + ".GoogleIAMCredentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "authorization_token"),
    2: .standard(proto: "authority_selector"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authoritySelector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 1)
    }
    if !self.authoritySelector.isEmpty {
      try visitor.visitSingularStringField(value: self.authoritySelector, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.GoogleIAMCredentials) -> Bool {
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.authoritySelector != rhs.authoritySelector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.protoMessageName + ".MetadataCredentialsFromPlugin"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .config(v)}
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.configType {
    case .config?: try {
      guard case .config(let v)? = self.configType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .typedConfig?: try {
      guard case .typedConfig(let v)? = self.configType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.MetadataCredentialsFromPlugin) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.protoMessageName + ".StsService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_exchange_service_uri"),
    2: .same(proto: "resource"),
    3: .same(proto: "audience"),
    4: .same(proto: "scope"),
    5: .standard(proto: "requested_token_type"),
    6: .standard(proto: "subject_token_path"),
    7: .standard(proto: "subject_token_type"),
    8: .standard(proto: "actor_token_path"),
    9: .standard(proto: "actor_token_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tokenExchangeServiceUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.audience) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestedTokenType) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.subjectTokenPath) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.subjectTokenType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.actorTokenPath) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.actorTokenType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tokenExchangeServiceUri.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenExchangeServiceUri, fieldNumber: 1)
    }
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 2)
    }
    if !self.audience.isEmpty {
      try visitor.visitSingularStringField(value: self.audience, fieldNumber: 3)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 4)
    }
    if !self.requestedTokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.requestedTokenType, fieldNumber: 5)
    }
    if !self.subjectTokenPath.isEmpty {
      try visitor.visitSingularStringField(value: self.subjectTokenPath, fieldNumber: 6)
    }
    if !self.subjectTokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.subjectTokenType, fieldNumber: 7)
    }
    if !self.actorTokenPath.isEmpty {
      try visitor.visitSingularStringField(value: self.actorTokenPath, fieldNumber: 8)
    }
    if !self.actorTokenType.isEmpty {
      try visitor.visitSingularStringField(value: self.actorTokenType, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService, rhs: Envoy_Api_V2_Core_GrpcService.GoogleGrpc.CallCredentials.StsService) -> Bool {
    if lhs.tokenExchangeServiceUri != rhs.tokenExchangeServiceUri {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.audience != rhs.audience {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.requestedTokenType != rhs.requestedTokenType {return false}
    if lhs.subjectTokenPath != rhs.subjectTokenPath {return false}
    if lhs.subjectTokenType != rhs.subjectTokenType {return false}
    if lhs.actorTokenPath != rhs.actorTokenPath {return false}
    if lhs.actorTokenType != rhs.actorTokenType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

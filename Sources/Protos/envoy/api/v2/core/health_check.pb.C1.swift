// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/api/v2/core/health_check.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Endpoint health status.
public enum Envoy_Api_V2_Core_HealthStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The health status is not known. This is interpreted by Envoy as *HEALTHY*.
  case unknown // = 0

  /// Healthy.
  case healthy // = 1

  /// Unhealthy.
  case unhealthy // = 2

  /// Connection draining in progress. E.g.,
  /// `<https://aws.amazon.com/blogs/aws/elb-connection-draining-remove-instances-from-service-with-care/>`_
  /// or
  /// `<https://cloud.google.com/compute/docs/load-balancing/enabling-connection-draining>`_.
  /// This is interpreted by Envoy as *UNHEALTHY*.
  case draining // = 3

  /// Health check timed out. This is part of HDS and is interpreted by Envoy as
  /// *UNHEALTHY*.
  case timeout // = 4

  /// Degraded.
  case degraded // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .healthy
    case 2: self = .unhealthy
    case 3: self = .draining
    case 4: self = .timeout
    case 5: self = .degraded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .healthy: return 1
    case .unhealthy: return 2
    case .draining: return 3
    case .timeout: return 4
    case .degraded: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Envoy_Api_V2_Core_HealthStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Api_V2_Core_HealthStatus] = [
    .unknown,
    .healthy,
    .unhealthy,
    .draining,
    .timeout,
    .degraded,
  ]
}

#endif  // swift(>=4.2)

/// [#next-free-field: 23]
public struct Envoy_Api_V2_Core_HealthCheck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time to wait for a health check response. If the timeout is reached the
  /// health check attempt will be considered a failure.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// The interval between health checks.
  public var interval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._interval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  public var hasInterval: Bool {return _storage._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  public mutating func clearInterval() {_uniqueStorage()._interval = nil}

  /// An optional jitter amount in milliseconds. If specified, Envoy will start health
  /// checking after for a random time in ms between 0 and initial_jitter. This only
  /// applies to the first health check.
  public var initialJitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._initialJitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._initialJitter = newValue}
  }
  /// Returns true if `initialJitter` has been explicitly set.
  public var hasInitialJitter: Bool {return _storage._initialJitter != nil}
  /// Clears the value of `initialJitter`. Subsequent reads from it will return its default value.
  public mutating func clearInitialJitter() {_uniqueStorage()._initialJitter = nil}

  /// An optional jitter amount in milliseconds. If specified, during every
  /// interval Envoy will add interval_jitter to the wait time.
  public var intervalJitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._intervalJitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._intervalJitter = newValue}
  }
  /// Returns true if `intervalJitter` has been explicitly set.
  public var hasIntervalJitter: Bool {return _storage._intervalJitter != nil}
  /// Clears the value of `intervalJitter`. Subsequent reads from it will return its default value.
  public mutating func clearIntervalJitter() {_uniqueStorage()._intervalJitter = nil}

  /// An optional jitter amount as a percentage of interval_ms. If specified,
  /// during every interval Envoy will add interval_ms *
  /// interval_jitter_percent / 100 to the wait time.
  ///
  /// If interval_jitter_ms and interval_jitter_percent are both set, both of
  /// them will be used to increase the wait time.
  public var intervalJitterPercent: UInt32 {
    get {return _storage._intervalJitterPercent}
    set {_uniqueStorage()._intervalJitterPercent = newValue}
  }

  /// The number of unhealthy health checks required before a host is marked
  /// unhealthy. Note that for *http* health checking if a host responds with 503
  /// this threshold is ignored and the host is considered unhealthy immediately.
  public var unhealthyThreshold: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._unhealthyThreshold ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._unhealthyThreshold = newValue}
  }
  /// Returns true if `unhealthyThreshold` has been explicitly set.
  public var hasUnhealthyThreshold: Bool {return _storage._unhealthyThreshold != nil}
  /// Clears the value of `unhealthyThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearUnhealthyThreshold() {_uniqueStorage()._unhealthyThreshold = nil}

  /// The number of healthy health checks required before a host is marked
  /// healthy. Note that during startup, only a single successful health check is
  /// required to mark a host healthy.
  public var healthyThreshold: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._healthyThreshold ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._healthyThreshold = newValue}
  }
  /// Returns true if `healthyThreshold` has been explicitly set.
  public var hasHealthyThreshold: Bool {return _storage._healthyThreshold != nil}
  /// Clears the value of `healthyThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearHealthyThreshold() {_uniqueStorage()._healthyThreshold = nil}

  /// [#not-implemented-hide:] Non-serving port for health checking.
  public var altPort: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._altPort ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._altPort = newValue}
  }
  /// Returns true if `altPort` has been explicitly set.
  public var hasAltPort: Bool {return _storage._altPort != nil}
  /// Clears the value of `altPort`. Subsequent reads from it will return its default value.
  public mutating func clearAltPort() {_uniqueStorage()._altPort = nil}

  /// Reuse health check connection between health checks. Default is true.
  public var reuseConnection: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._reuseConnection ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._reuseConnection = newValue}
  }
  /// Returns true if `reuseConnection` has been explicitly set.
  public var hasReuseConnection: Bool {return _storage._reuseConnection != nil}
  /// Clears the value of `reuseConnection`. Subsequent reads from it will return its default value.
  public mutating func clearReuseConnection() {_uniqueStorage()._reuseConnection = nil}

  public var healthChecker: OneOf_HealthChecker? {
    get {return _storage._healthChecker}
    set {_uniqueStorage()._healthChecker = newValue}
  }

  /// HTTP health check.
  public var httpHealthCheck: Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck {
    get {
      if case .httpHealthCheck(let v)? = _storage._healthChecker {return v}
      return Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck()
    }
    set {_uniqueStorage()._healthChecker = .httpHealthCheck(newValue)}
  }

  /// TCP health check.
  public var tcpHealthCheck: Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck {
    get {
      if case .tcpHealthCheck(let v)? = _storage._healthChecker {return v}
      return Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck()
    }
    set {_uniqueStorage()._healthChecker = .tcpHealthCheck(newValue)}
  }

  /// gRPC health check.
  public var grpcHealthCheck: Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck {
    get {
      if case .grpcHealthCheck(let v)? = _storage._healthChecker {return v}
      return Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck()
    }
    set {_uniqueStorage()._healthChecker = .grpcHealthCheck(newValue)}
  }

  /// Custom health check.
  public var customHealthCheck: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck {
    get {
      if case .customHealthCheck(let v)? = _storage._healthChecker {return v}
      return Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck()
    }
    set {_uniqueStorage()._healthChecker = .customHealthCheck(newValue)}
  }

  /// The "no traffic interval" is a special health check interval that is used when a cluster has
  /// never had traffic routed to it. This lower interval allows cluster information to be kept up to
  /// date, without sending a potentially large amount of active health checking traffic for no
  /// reason. Once a cluster has been used for traffic routing, Envoy will shift back to using the
  /// standard health check interval that is defined. Note that this interval takes precedence over
  /// any other.
  ///
  /// The default value for "no traffic interval" is 60 seconds.
  public var noTrafficInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._noTrafficInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._noTrafficInterval = newValue}
  }
  /// Returns true if `noTrafficInterval` has been explicitly set.
  public var hasNoTrafficInterval: Bool {return _storage._noTrafficInterval != nil}
  /// Clears the value of `noTrafficInterval`. Subsequent reads from it will return its default value.
  public mutating func clearNoTrafficInterval() {_uniqueStorage()._noTrafficInterval = nil}

  /// The "unhealthy interval" is a health check interval that is used for hosts that are marked as
  /// unhealthy. As soon as the host is marked as healthy, Envoy will shift back to using the
  /// standard health check interval that is defined.
  ///
  /// The default value for "unhealthy interval" is the same as "interval".
  public var unhealthyInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._unhealthyInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._unhealthyInterval = newValue}
  }
  /// Returns true if `unhealthyInterval` has been explicitly set.
  public var hasUnhealthyInterval: Bool {return _storage._unhealthyInterval != nil}
  /// Clears the value of `unhealthyInterval`. Subsequent reads from it will return its default value.
  public mutating func clearUnhealthyInterval() {_uniqueStorage()._unhealthyInterval = nil}

  /// The "unhealthy edge interval" is a special health check interval that is used for the first
  /// health check right after a host is marked as unhealthy. For subsequent health checks
  /// Envoy will shift back to using either "unhealthy interval" if present or the standard health
  /// check interval that is defined.
  ///
  /// The default value for "unhealthy edge interval" is the same as "unhealthy interval".
  public var unhealthyEdgeInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._unhealthyEdgeInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._unhealthyEdgeInterval = newValue}
  }
  /// Returns true if `unhealthyEdgeInterval` has been explicitly set.
  public var hasUnhealthyEdgeInterval: Bool {return _storage._unhealthyEdgeInterval != nil}
  /// Clears the value of `unhealthyEdgeInterval`. Subsequent reads from it will return its default value.
  public mutating func clearUnhealthyEdgeInterval() {_uniqueStorage()._unhealthyEdgeInterval = nil}

  /// The "healthy edge interval" is a special health check interval that is used for the first
  /// health check right after a host is marked as healthy. For subsequent health checks
  /// Envoy will shift back to using the standard health check interval that is defined.
  ///
  /// The default value for "healthy edge interval" is the same as the default interval.
  public var healthyEdgeInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._healthyEdgeInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._healthyEdgeInterval = newValue}
  }
  /// Returns true if `healthyEdgeInterval` has been explicitly set.
  public var hasHealthyEdgeInterval: Bool {return _storage._healthyEdgeInterval != nil}
  /// Clears the value of `healthyEdgeInterval`. Subsequent reads from it will return its default value.
  public mutating func clearHealthyEdgeInterval() {_uniqueStorage()._healthyEdgeInterval = nil}

  /// Specifies the path to the :ref:`health check event log <arch_overview_health_check_logging>`.
  /// If empty, no event log will be written.
  public var eventLogPath: String {
    get {return _storage._eventLogPath}
    set {_uniqueStorage()._eventLogPath = newValue}
  }

  /// [#not-implemented-hide:]
  /// The gRPC service for the health check event service.
  /// If empty, health check events won't be sent to a remote endpoint.
  public var eventService: Envoy_Api_V2_Core_EventServiceConfig {
    get {return _storage._eventService ?? Envoy_Api_V2_Core_EventServiceConfig()}
    set {_uniqueStorage()._eventService = newValue}
  }
  /// Returns true if `eventService` has been explicitly set.
  public var hasEventService: Bool {return _storage._eventService != nil}
  /// Clears the value of `eventService`. Subsequent reads from it will return its default value.
  public mutating func clearEventService() {_uniqueStorage()._eventService = nil}

  /// If set to true, health check failure events will always be logged. If set to false, only the
  /// initial health check failure event will be logged.
  /// The default value is false.
  public var alwaysLogHealthCheckFailures: Bool {
    get {return _storage._alwaysLogHealthCheckFailures}
    set {_uniqueStorage()._alwaysLogHealthCheckFailures = newValue}
  }

  /// This allows overriding the cluster TLS settings, just for health check connections.
  public var tlsOptions: Envoy_Api_V2_Core_HealthCheck.TlsOptions {
    get {return _storage._tlsOptions ?? Envoy_Api_V2_Core_HealthCheck.TlsOptions()}
    set {_uniqueStorage()._tlsOptions = newValue}
  }
  /// Returns true if `tlsOptions` has been explicitly set.
  public var hasTlsOptions: Bool {return _storage._tlsOptions != nil}
  /// Clears the value of `tlsOptions`. Subsequent reads from it will return its default value.
  public mutating func clearTlsOptions() {_uniqueStorage()._tlsOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_HealthChecker: Equatable {
    /// HTTP health check.
    case httpHealthCheck(Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck)
    /// TCP health check.
    case tcpHealthCheck(Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck)
    /// gRPC health check.
    case grpcHealthCheck(Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck)
    /// Custom health check.
    case customHealthCheck(Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.OneOf_HealthChecker, rhs: Envoy_Api_V2_Core_HealthCheck.OneOf_HealthChecker) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.httpHealthCheck, .httpHealthCheck): return {
        guard case .httpHealthCheck(let l) = lhs, case .httpHealthCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tcpHealthCheck, .tcpHealthCheck): return {
        guard case .tcpHealthCheck(let l) = lhs, case .tcpHealthCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.grpcHealthCheck, .grpcHealthCheck): return {
        guard case .grpcHealthCheck(let l) = lhs, case .grpcHealthCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.customHealthCheck, .customHealthCheck): return {
        guard case .customHealthCheck(let l) = lhs, case .customHealthCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Describes the encoding of the payload bytes in the payload.
  public struct Payload {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var payload: Envoy_Api_V2_Core_HealthCheck.Payload.OneOf_Payload? = nil

    /// Hex encoded payload. E.g., "000000FF".
    public var text: String {
      get {
        if case .text(let v)? = payload {return v}
        return String()
      }
      set {payload = .text(newValue)}
    }

    /// [#not-implemented-hide:] Binary payload.
    public var binary: Data {
      get {
        if case .binary(let v)? = payload {return v}
        return Data()
      }
      set {payload = .binary(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Payload: Equatable {
      /// Hex encoded payload. E.g., "000000FF".
      case text(String)
      /// [#not-implemented-hide:] Binary payload.
      case binary(Data)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.Payload.OneOf_Payload, rhs: Envoy_Api_V2_Core_HealthCheck.Payload.OneOf_Payload) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.text, .text): return {
          guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.binary, .binary): return {
          guard case .binary(let l) = lhs, case .binary(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// [#next-free-field: 12]
  public struct HttpHealthCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The value of the host header in the HTTP health check request. If
    /// left empty (default value), the name of the cluster this health check is associated
    /// with will be used. The host header can be customized for a specific endpoint by setting the
    /// :ref:`hostname <envoy_api_field_endpoint.Endpoint.HealthCheckConfig.hostname>` field.
    public var host: String = String()

    /// Specifies the HTTP path that will be requested during health checking. For example
    /// */healthcheck*.
    public var path: String = String()

    /// [#not-implemented-hide:] HTTP specific payload.
    public var send: Envoy_Api_V2_Core_HealthCheck.Payload {
      get {return _send ?? Envoy_Api_V2_Core_HealthCheck.Payload()}
      set {_send = newValue}
    }
    /// Returns true if `send` has been explicitly set.
    public var hasSend: Bool {return self._send != nil}
    /// Clears the value of `send`. Subsequent reads from it will return its default value.
    public mutating func clearSend() {self._send = nil}

    /// [#not-implemented-hide:] HTTP specific response.
    public var receive: Envoy_Api_V2_Core_HealthCheck.Payload {
      get {return _receive ?? Envoy_Api_V2_Core_HealthCheck.Payload()}
      set {_receive = newValue}
    }
    /// Returns true if `receive` has been explicitly set.
    public var hasReceive: Bool {return self._receive != nil}
    /// Clears the value of `receive`. Subsequent reads from it will return its default value.
    public mutating func clearReceive() {self._receive = nil}

    /// An optional service name parameter which is used to validate the identity of
    /// the health checked cluster. See the :ref:`architecture overview
    /// <arch_overview_health_checking_identity>` for more information.
    ///
    /// .. attention::
    ///
    ///   This field has been deprecated in favor of `service_name_matcher` for better flexibility
    ///   over matching with service-cluster name.
    public var serviceName: String = String()

    /// Specifies a list of HTTP headers that should be added to each request that is sent to the
    /// health checked cluster. For more information, including details on header value syntax, see
    /// the documentation on :ref:`custom request headers
    /// <config_http_conn_man_headers_custom_request_headers>`.
    public var requestHeadersToAdd: [Envoy_Api_V2_Core_HeaderValueOption] = []

    /// Specifies a list of HTTP headers that should be removed from each request that is sent to the
    /// health checked cluster.
    public var requestHeadersToRemove: [String] = []

    /// If set, health checks will be made using http/2.
    /// Deprecated, use :ref:`codec_client_type
    /// <envoy_api_field_core.HealthCheck.HttpHealthCheck.codec_client_type>` instead.
    public var useHTTP2: Bool = false

    /// Specifies a list of HTTP response statuses considered healthy. If provided, replaces default
    /// 200-only policy - 200 must be included explicitly as needed. Ranges follow half-open
    /// semantics of :ref:`Int64Range <envoy_api_msg_type.Int64Range>`. The start and end of each
    /// range are required. Only statuses in the range [100, 600) are allowed.
    public var expectedStatuses: [Envoy_Type_Int64Range] = []

    /// Use specified application protocol for health checks.
    public var codecClientType: Envoy_Type_CodecClientType = .http1

    /// An optional service name parameter which is used to validate the identity of
    /// the health checked cluster using a :ref:`StringMatcher
    /// <envoy_api_msg_type.matcher.StringMatcher>`. See the :ref:`architecture overview
    /// <arch_overview_health_checking_identity>` for more information.
    public var serviceNameMatcher: Envoy_Type_Matcher_StringMatcher {
      get {return _serviceNameMatcher ?? Envoy_Type_Matcher_StringMatcher()}
      set {_serviceNameMatcher = newValue}
    }
    /// Returns true if `serviceNameMatcher` has been explicitly set.
    public var hasServiceNameMatcher: Bool {return self._serviceNameMatcher != nil}
    /// Clears the value of `serviceNameMatcher`. Subsequent reads from it will return its default value.
    public mutating func clearServiceNameMatcher() {self._serviceNameMatcher = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _send: Envoy_Api_V2_Core_HealthCheck.Payload? = nil
    fileprivate var _receive: Envoy_Api_V2_Core_HealthCheck.Payload? = nil
    fileprivate var _serviceNameMatcher: Envoy_Type_Matcher_StringMatcher? = nil
  }

  public struct TcpHealthCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Empty payloads imply a connect-only health check.
    public var send: Envoy_Api_V2_Core_HealthCheck.Payload {
      get {return _send ?? Envoy_Api_V2_Core_HealthCheck.Payload()}
      set {_send = newValue}
    }
    /// Returns true if `send` has been explicitly set.
    public var hasSend: Bool {return self._send != nil}
    /// Clears the value of `send`. Subsequent reads from it will return its default value.
    public mutating func clearSend() {self._send = nil}

    /// When checking the response, “fuzzy” matching is performed such that each
    /// binary block must be found, and in the order specified, but not
    /// necessarily contiguous.
    public var receive: [Envoy_Api_V2_Core_HealthCheck.Payload] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _send: Envoy_Api_V2_Core_HealthCheck.Payload? = nil
  }

  public struct RedisHealthCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If set, optionally perform ``EXISTS <key>`` instead of ``PING``. A return value
    /// from Redis of 0 (does not exist) is considered a passing healthcheck. A return value other
    /// than 0 is considered a failure. This allows the user to mark a Redis instance for maintenance
    /// by setting the specified key to any value and waiting for traffic to drain.
    public var key: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// `grpc.health.v1.Health
  /// <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto>`_-based
  /// healthcheck. See `gRPC doc <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_
  /// for details.
  public struct GrpcHealthCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// An optional service name parameter which will be sent to gRPC service in
    /// `grpc.health.v1.HealthCheckRequest
    /// <https://github.com/grpc/grpc/blob/master/src/proto/grpc/health/v1/health.proto#L20>`_.
    /// message. See `gRPC health-checking overview
    /// <https://github.com/grpc/grpc/blob/master/doc/health-checking.md>`_ for more information.
    public var serviceName: String = String()

    /// The value of the :authority header in the gRPC health check request. If
    /// left empty (default value), the name of the cluster this health check is associated
    /// with will be used. The authority header can be customized for a specific endpoint by setting
    /// the :ref:`hostname <envoy_api_field_endpoint.Endpoint.HealthCheckConfig.hostname>` field.
    public var authority: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Custom health check.
  public struct CustomHealthCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The registered name of the custom health checker.
    public var name: String = String()

    /// A custom health checker specific configuration which depends on the custom health checker
    /// being instantiated. See :api:`envoy/config/health_checker` for reference.
    public var configType: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck.OneOf_ConfigType? = nil

    public var config: SwiftProtobuf.Google_Protobuf_Struct {
      get {
        if case .config(let v)? = configType {return v}
        return SwiftProtobuf.Google_Protobuf_Struct()
      }
      set {configType = .config(newValue)}
    }

    public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
      get {
        if case .typedConfig(let v)? = configType {return v}
        return SwiftProtobuf.Google_Protobuf_Any()
      }
      set {configType = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A custom health checker specific configuration which depends on the custom health checker
    /// being instantiated. See :api:`envoy/config/health_checker` for reference.
    public enum OneOf_ConfigType: Equatable {
      case config(SwiftProtobuf.Google_Protobuf_Struct)
      case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck.OneOf_ConfigType, rhs: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck.OneOf_ConfigType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.config, .config): return {
          guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.typedConfig, .typedConfig): return {
          guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Health checks occur over the transport socket specified for the cluster. This implies that if a
  /// cluster is using a TLS-enabled transport socket, the health check will also occur over TLS.
  ///
  /// This allows overriding the cluster TLS settings, just for health check connections.
  public struct TlsOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies the ALPN protocols for health check connections. This is useful if the
    /// corresponding upstream is using ALPN-based :ref:`FilterChainMatch
    /// <envoy_api_msg_listener.FilterChainMatch>` along with different protocols for health checks
    /// versus data connections. If empty, no ALPN protocols will be set on health check connections.
    public var alpnProtocols: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.api.v2.core"

extension Envoy_Api_V2_Core_HealthStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "HEALTHY"),
    2: .same(proto: "UNHEALTHY"),
    3: .same(proto: "DRAINING"),
    4: .same(proto: "TIMEOUT"),
    5: .same(proto: "DEGRADED"),
  ]
}

extension Envoy_Api_V2_Core_HealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
    2: .same(proto: "interval"),
    20: .standard(proto: "initial_jitter"),
    3: .standard(proto: "interval_jitter"),
    18: .standard(proto: "interval_jitter_percent"),
    4: .standard(proto: "unhealthy_threshold"),
    5: .standard(proto: "healthy_threshold"),
    6: .standard(proto: "alt_port"),
    7: .standard(proto: "reuse_connection"),
    8: .standard(proto: "http_health_check"),
    9: .standard(proto: "tcp_health_check"),
    11: .standard(proto: "grpc_health_check"),
    13: .standard(proto: "custom_health_check"),
    12: .standard(proto: "no_traffic_interval"),
    14: .standard(proto: "unhealthy_interval"),
    15: .standard(proto: "unhealthy_edge_interval"),
    16: .standard(proto: "healthy_edge_interval"),
    17: .standard(proto: "event_log_path"),
    22: .standard(proto: "event_service"),
    19: .standard(proto: "always_log_health_check_failures"),
    21: .standard(proto: "tls_options"),
  ]

  fileprivate class _StorageClass {
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _interval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _initialJitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _intervalJitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _intervalJitterPercent: UInt32 = 0
    var _unhealthyThreshold: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _healthyThreshold: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _altPort: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _reuseConnection: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _healthChecker: Envoy_Api_V2_Core_HealthCheck.OneOf_HealthChecker?
    var _noTrafficInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _unhealthyInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _unhealthyEdgeInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _healthyEdgeInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _eventLogPath: String = String()
    var _eventService: Envoy_Api_V2_Core_EventServiceConfig? = nil
    var _alwaysLogHealthCheckFailures: Bool = false
    var _tlsOptions: Envoy_Api_V2_Core_HealthCheck.TlsOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timeout = source._timeout
      _interval = source._interval
      _initialJitter = source._initialJitter
      _intervalJitter = source._intervalJitter
      _intervalJitterPercent = source._intervalJitterPercent
      _unhealthyThreshold = source._unhealthyThreshold
      _healthyThreshold = source._healthyThreshold
      _altPort = source._altPort
      _reuseConnection = source._reuseConnection
      _healthChecker = source._healthChecker
      _noTrafficInterval = source._noTrafficInterval
      _unhealthyInterval = source._unhealthyInterval
      _unhealthyEdgeInterval = source._unhealthyEdgeInterval
      _healthyEdgeInterval = source._healthyEdgeInterval
      _eventLogPath = source._eventLogPath
      _eventService = source._eventService
      _alwaysLogHealthCheckFailures = source._alwaysLogHealthCheckFailures
      _tlsOptions = source._tlsOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._interval) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._intervalJitter) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._unhealthyThreshold) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._healthyThreshold) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._altPort) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._reuseConnection) }()
        case 8: try {
          var v: Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck?
          if let current = _storage._healthChecker {
            try decoder.handleConflictingOneOf()
            if case .httpHealthCheck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._healthChecker = .httpHealthCheck(v)}
        }()
        case 9: try {
          var v: Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck?
          if let current = _storage._healthChecker {
            try decoder.handleConflictingOneOf()
            if case .tcpHealthCheck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._healthChecker = .tcpHealthCheck(v)}
        }()
        case 11: try {
          var v: Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck?
          if let current = _storage._healthChecker {
            try decoder.handleConflictingOneOf()
            if case .grpcHealthCheck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._healthChecker = .grpcHealthCheck(v)}
        }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._noTrafficInterval) }()
        case 13: try {
          var v: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck?
          if let current = _storage._healthChecker {
            try decoder.handleConflictingOneOf()
            if case .customHealthCheck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._healthChecker = .customHealthCheck(v)}
        }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._unhealthyInterval) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._unhealthyEdgeInterval) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._healthyEdgeInterval) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._eventLogPath) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._intervalJitterPercent) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._alwaysLogHealthCheckFailures) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._initialJitter) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._tlsOptions) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._eventService) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._interval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._intervalJitter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._unhealthyThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._healthyThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._altPort {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._reuseConnection {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._healthChecker {
      case .httpHealthCheck?: try {
        guard case .httpHealthCheck(let v)? = _storage._healthChecker else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .tcpHealthCheck?: try {
        guard case .tcpHealthCheck(let v)? = _storage._healthChecker else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .grpcHealthCheck?: try {
        guard case .grpcHealthCheck(let v)? = _storage._healthChecker else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      default: break
      }
      if let v = _storage._noTrafficInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if case .customHealthCheck(let v)? = _storage._healthChecker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._unhealthyInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._unhealthyEdgeInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._healthyEdgeInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._eventLogPath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._eventLogPath, fieldNumber: 17)
      }
      if _storage._intervalJitterPercent != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._intervalJitterPercent, fieldNumber: 18)
      }
      if _storage._alwaysLogHealthCheckFailures != false {
        try visitor.visitSingularBoolField(value: _storage._alwaysLogHealthCheckFailures, fieldNumber: 19)
      }
      if let v = _storage._initialJitter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._tlsOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._eventService {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck, rhs: Envoy_Api_V2_Core_HealthCheck) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._interval != rhs_storage._interval {return false}
        if _storage._initialJitter != rhs_storage._initialJitter {return false}
        if _storage._intervalJitter != rhs_storage._intervalJitter {return false}
        if _storage._intervalJitterPercent != rhs_storage._intervalJitterPercent {return false}
        if _storage._unhealthyThreshold != rhs_storage._unhealthyThreshold {return false}
        if _storage._healthyThreshold != rhs_storage._healthyThreshold {return false}
        if _storage._altPort != rhs_storage._altPort {return false}
        if _storage._reuseConnection != rhs_storage._reuseConnection {return false}
        if _storage._healthChecker != rhs_storage._healthChecker {return false}
        if _storage._noTrafficInterval != rhs_storage._noTrafficInterval {return false}
        if _storage._unhealthyInterval != rhs_storage._unhealthyInterval {return false}
        if _storage._unhealthyEdgeInterval != rhs_storage._unhealthyEdgeInterval {return false}
        if _storage._healthyEdgeInterval != rhs_storage._healthyEdgeInterval {return false}
        if _storage._eventLogPath != rhs_storage._eventLogPath {return false}
        if _storage._eventService != rhs_storage._eventService {return false}
        if _storage._alwaysLogHealthCheckFailures != rhs_storage._alwaysLogHealthCheckFailures {return false}
        if _storage._tlsOptions != rhs_storage._tlsOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".Payload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "binary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.payload != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.payload = .text(v)}
      }()
      case 2: try {
        if self.payload != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.payload = .binary(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .text?: try {
      guard case .text(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .binary?: try {
      guard case .binary(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.Payload, rhs: Envoy_Api_V2_Core_HealthCheck.Payload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".HttpHealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "path"),
    3: .same(proto: "send"),
    4: .same(proto: "receive"),
    5: .standard(proto: "service_name"),
    6: .standard(proto: "request_headers_to_add"),
    8: .standard(proto: "request_headers_to_remove"),
    7: .standard(proto: "use_http2"),
    9: .standard(proto: "expected_statuses"),
    10: .standard(proto: "codec_client_type"),
    11: .standard(proto: "service_name_matcher"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._send) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._receive) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.requestHeadersToAdd) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.useHTTP2) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.requestHeadersToRemove) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.expectedStatuses) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.codecClientType) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._serviceNameMatcher) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if let v = self._send {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._receive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 5)
    }
    if !self.requestHeadersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestHeadersToAdd, fieldNumber: 6)
    }
    if self.useHTTP2 != false {
      try visitor.visitSingularBoolField(value: self.useHTTP2, fieldNumber: 7)
    }
    if !self.requestHeadersToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestHeadersToRemove, fieldNumber: 8)
    }
    if !self.expectedStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.expectedStatuses, fieldNumber: 9)
    }
    if self.codecClientType != .http1 {
      try visitor.visitSingularEnumField(value: self.codecClientType, fieldNumber: 10)
    }
    if let v = self._serviceNameMatcher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck, rhs: Envoy_Api_V2_Core_HealthCheck.HttpHealthCheck) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.path != rhs.path {return false}
    if lhs._send != rhs._send {return false}
    if lhs._receive != rhs._receive {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.requestHeadersToAdd != rhs.requestHeadersToAdd {return false}
    if lhs.requestHeadersToRemove != rhs.requestHeadersToRemove {return false}
    if lhs.useHTTP2 != rhs.useHTTP2 {return false}
    if lhs.expectedStatuses != rhs.expectedStatuses {return false}
    if lhs.codecClientType != rhs.codecClientType {return false}
    if lhs._serviceNameMatcher != rhs._serviceNameMatcher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".TcpHealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "send"),
    2: .same(proto: "receive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._send) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.receive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._send {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.receive.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.receive, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck, rhs: Envoy_Api_V2_Core_HealthCheck.TcpHealthCheck) -> Bool {
    if lhs._send != rhs._send {return false}
    if lhs.receive != rhs.receive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.RedisHealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".RedisHealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.RedisHealthCheck, rhs: Envoy_Api_V2_Core_HealthCheck.RedisHealthCheck) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".GrpcHealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_name"),
    2: .same(proto: "authority"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 1)
    }
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck, rhs: Envoy_Api_V2_Core_HealthCheck.GrpcHealthCheck) -> Bool {
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.authority != rhs.authority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".CustomHealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .config(v)}
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.configType {
    case .config?: try {
      guard case .config(let v)? = self.configType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .typedConfig?: try {
      guard case .typedConfig(let v)? = self.configType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck, rhs: Envoy_Api_V2_Core_HealthCheck.CustomHealthCheck) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Api_V2_Core_HealthCheck.TlsOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Api_V2_Core_HealthCheck.protoMessageName + ".TlsOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alpn_protocols"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.alpnProtocols) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alpnProtocols.isEmpty {
      try visitor.visitRepeatedStringField(value: self.alpnProtocols, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Api_V2_Core_HealthCheck.TlsOptions, rhs: Envoy_Api_V2_Core_HealthCheck.TlsOptions) -> Bool {
    if lhs.alpnProtocols != rhs.alpnProtocols {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

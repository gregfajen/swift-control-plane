// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/transport_sockets/tls/v3/tls.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common TLS context settings.
  ///
  /// .. attention::
  ///
  ///   Server certificate verification is not enabled by default. Configure
  ///   :ref:`trusted_ca<envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>` to enable
  ///   verification.
  public var commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext {
    get {return _commonTlsContext ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext()}
    set {_commonTlsContext = newValue}
  }
  /// Returns true if `commonTlsContext` has been explicitly set.
  public var hasCommonTlsContext: Bool {return self._commonTlsContext != nil}
  /// Clears the value of `commonTlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearCommonTlsContext() {self._commonTlsContext = nil}

  /// SNI string to use when creating TLS backend connections.
  public var sni: String = String()

  /// If true, server-initiated TLS renegotiation will be allowed.
  ///
  /// .. attention::
  ///
  ///   TLS renegotiation is considered insecure and shouldn't be used unless absolutely necessary.
  public var allowRenegotiation: Bool = false

  /// Maximum number of session keys (Pre-Shared Keys for TLSv1.3+, Session IDs and Session Tickets
  /// for TLSv1.2 and older) to store for the purpose of session resumption.
  ///
  /// Defaults to 1, setting this to 0 disables session resumption.
  public var maxSessionKeys: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxSessionKeys ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxSessionKeys = newValue}
  }
  /// Returns true if `maxSessionKeys` has been explicitly set.
  public var hasMaxSessionKeys: Bool {return self._maxSessionKeys != nil}
  /// Clears the value of `maxSessionKeys`. Subsequent reads from it will return its default value.
  public mutating func clearMaxSessionKeys() {self._maxSessionKeys = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext? = nil
  fileprivate var _maxSessionKeys: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#next-free-field: 9]
public struct Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common TLS context settings.
  public var commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext {
    get {return _commonTlsContext ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext()}
    set {_commonTlsContext = newValue}
  }
  /// Returns true if `commonTlsContext` has been explicitly set.
  public var hasCommonTlsContext: Bool {return self._commonTlsContext != nil}
  /// Clears the value of `commonTlsContext`. Subsequent reads from it will return its default value.
  public mutating func clearCommonTlsContext() {self._commonTlsContext = nil}

  /// If specified, Envoy will reject connections without a valid client
  /// certificate.
  public var requireClientCertificate: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _requireClientCertificate ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_requireClientCertificate = newValue}
  }
  /// Returns true if `requireClientCertificate` has been explicitly set.
  public var hasRequireClientCertificate: Bool {return self._requireClientCertificate != nil}
  /// Clears the value of `requireClientCertificate`. Subsequent reads from it will return its default value.
  public mutating func clearRequireClientCertificate() {self._requireClientCertificate = nil}

  /// If specified, Envoy will reject connections without a valid and matching SNI.
  /// [#not-implemented-hide:]
  public var requireSni: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _requireSni ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_requireSni = newValue}
  }
  /// Returns true if `requireSni` has been explicitly set.
  public var hasRequireSni: Bool {return self._requireSni != nil}
  /// Clears the value of `requireSni`. Subsequent reads from it will return its default value.
  public mutating func clearRequireSni() {self._requireSni = nil}

  public var sessionTicketKeysType: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OneOf_SessionTicketKeysType? = nil

  /// TLS session ticket key settings.
  public var sessionTicketKeys: Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys {
    get {
      if case .sessionTicketKeys(let v)? = sessionTicketKeysType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys()
    }
    set {sessionTicketKeysType = .sessionTicketKeys(newValue)}
  }

  /// Config for fetching TLS session ticket keys via SDS API.
  public var sessionTicketKeysSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
    get {
      if case .sessionTicketKeysSdsSecretConfig(let v)? = sessionTicketKeysType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()
    }
    set {sessionTicketKeysType = .sessionTicketKeysSdsSecretConfig(newValue)}
  }

  /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
  /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
  /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
  /// the keys specified through either :ref:`session_ticket_keys <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
  /// or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
  /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
  /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
  /// implication that sessions cannot be resumed across hot restarts or on different hosts.
  public var disableStatelessSessionResumption: Bool {
    get {
      if case .disableStatelessSessionResumption(let v)? = sessionTicketKeysType {return v}
      return false
    }
    set {sessionTicketKeysType = .disableStatelessSessionResumption(newValue)}
  }

  /// If specified, session_timeout will change maximum lifetime (in seconds) of TLS session
  /// Currently this value is used as a hint to `TLS session ticket lifetime (for TLSv1.2)
  /// <https://tools.ietf.org/html/rfc5077#section-5.6>`
  /// only seconds could be specified (fractional seconds are going to be ignored).
  public var sessionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _sessionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_sessionTimeout = newValue}
  }
  /// Returns true if `sessionTimeout` has been explicitly set.
  public var hasSessionTimeout: Bool {return self._sessionTimeout != nil}
  /// Clears the value of `sessionTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearSessionTimeout() {self._sessionTimeout = nil}

  /// Config for whether to use certificates if they do not have
  /// an accompanying OCSP response or if the response expires at runtime.
  /// Defaults to LENIENT_STAPLING
  public var ocspStaplePolicy: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OcspStaplePolicy = .lenientStapling

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SessionTicketKeysType: Equatable {
    /// TLS session ticket key settings.
    case sessionTicketKeys(Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys)
    /// Config for fetching TLS session ticket keys via SDS API.
    case sessionTicketKeysSdsSecretConfig(Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig)
    /// Config for controlling stateless TLS session resumption: setting this to true will cause the TLS
    /// server to not issue TLS session tickets for the purposes of stateless TLS session resumption.
    /// If set to false, the TLS server will issue TLS session tickets and encrypt/decrypt them using
    /// the keys specified through either :ref:`session_ticket_keys <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
    /// or :ref:`session_ticket_keys_sds_secret_config <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys_sds_secret_config>`.
    /// If this config is set to false and no keys are explicitly configured, the TLS server will issue
    /// TLS session tickets and encrypt/decrypt them using an internally-generated and managed key, with the
    /// implication that sessions cannot be resumed across hot restarts or on different hosts.
    case disableStatelessSessionResumption(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OneOf_SessionTicketKeysType, rhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OneOf_SessionTicketKeysType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sessionTicketKeys, .sessionTicketKeys): return {
        guard case .sessionTicketKeys(let l) = lhs, case .sessionTicketKeys(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sessionTicketKeysSdsSecretConfig, .sessionTicketKeysSdsSecretConfig): return {
        guard case .sessionTicketKeysSdsSecretConfig(let l) = lhs, case .sessionTicketKeysSdsSecretConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.disableStatelessSessionResumption, .disableStatelessSessionResumption): return {
        guard case .disableStatelessSessionResumption(let l) = lhs, case .disableStatelessSessionResumption(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum OcspStaplePolicy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// OCSP responses are optional. If an OCSP response is absent
    /// or expired, the associated certificate will be used for
    /// connections without an OCSP staple.
    case lenientStapling // = 0

    /// OCSP responses are optional. If an OCSP response is absent,
    /// the associated certificate will be used without an
    /// OCSP staple. If a response is provided but is expired,
    /// the associated certificate will not be used for
    /// subsequent connections. If no suitable certificate is found,
    /// the connection is rejected.
    case strictStapling // = 1

    /// OCSP responses are required. Configuration will fail if
    /// a certificate is provided without an OCSP response. If a
    /// response expires, the associated certificate will not be
    /// used connections. If no suitable certificate is found, the
    /// connection is rejected.
    case mustStaple // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .lenientStapling
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .lenientStapling
      case 1: self = .strictStapling
      case 2: self = .mustStaple
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .lenientStapling: return 0
      case .strictStapling: return 1
      case .mustStaple: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _commonTlsContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext? = nil
  fileprivate var _requireClientCertificate: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _requireSni: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _sessionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OcspStaplePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OcspStaplePolicy] = [
    .lenientStapling,
    .strictStapling,
    .mustStaple,
  ]
}

#endif  // swift(>=4.2)

/// TLS context shared by both client and server TLS contexts.
/// [#next-free-field: 14]
public struct Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLS protocol versions, cipher suites etc.
  public var tlsParams: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters {
    get {return _storage._tlsParams ?? Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters()}
    set {_uniqueStorage()._tlsParams = newValue}
  }
  /// Returns true if `tlsParams` has been explicitly set.
  public var hasTlsParams: Bool {return _storage._tlsParams != nil}
  /// Clears the value of `tlsParams`. Subsequent reads from it will return its default value.
  public mutating func clearTlsParams() {_uniqueStorage()._tlsParams = nil}

  /// :ref:`Multiple TLS certificates <arch_overview_ssl_cert_select>` can be associated with the
  /// same context to allow both RSA and ECDSA certificates.
  ///
  /// Only a single TLS certificate is supported in client contexts. In server contexts, the first
  /// RSA certificate is used for clients that only support RSA and the first ECDSA certificate is
  /// used for clients that support ECDSA.
  public var tlsCertificates: [Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate] {
    get {return _storage._tlsCertificates}
    set {_uniqueStorage()._tlsCertificates = newValue}
  }

  /// Configs for fetching TLS certificates via SDS API. Note SDS API allows certificates to be
  /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  public var tlsCertificateSdsSecretConfigs: [Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig] {
    get {return _storage._tlsCertificateSdsSecretConfigs}
    set {_uniqueStorage()._tlsCertificateSdsSecretConfigs = newValue}
  }

  /// Certificate provider for fetching TLS certificates.
  /// [#not-implemented-hide:]
  public var tlsCertificateCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider {
    get {return _storage._tlsCertificateCertificateProvider ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider()}
    set {_uniqueStorage()._tlsCertificateCertificateProvider = newValue}
  }
  /// Returns true if `tlsCertificateCertificateProvider` has been explicitly set.
  public var hasTlsCertificateCertificateProvider: Bool {return _storage._tlsCertificateCertificateProvider != nil}
  /// Clears the value of `tlsCertificateCertificateProvider`. Subsequent reads from it will return its default value.
  public mutating func clearTlsCertificateCertificateProvider() {_uniqueStorage()._tlsCertificateCertificateProvider = nil}

  /// Certificate provider instance for fetching TLS certificates.
  /// [#not-implemented-hide:]
  public var tlsCertificateCertificateProviderInstance: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance {
    get {return _storage._tlsCertificateCertificateProviderInstance ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance()}
    set {_uniqueStorage()._tlsCertificateCertificateProviderInstance = newValue}
  }
  /// Returns true if `tlsCertificateCertificateProviderInstance` has been explicitly set.
  public var hasTlsCertificateCertificateProviderInstance: Bool {return _storage._tlsCertificateCertificateProviderInstance != nil}
  /// Clears the value of `tlsCertificateCertificateProviderInstance`. Subsequent reads from it will return its default value.
  public mutating func clearTlsCertificateCertificateProviderInstance() {_uniqueStorage()._tlsCertificateCertificateProviderInstance = nil}

  public var validationContextType: OneOf_ValidationContextType? {
    get {return _storage._validationContextType}
    set {_uniqueStorage()._validationContextType = newValue}
  }

  /// How to validate peer certificates.
  public var validationContext: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext {
    get {
      if case .validationContext(let v)? = _storage._validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext()
    }
    set {_uniqueStorage()._validationContextType = .validationContext(newValue)}
  }

  /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
  /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  public var validationContextSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
    get {
      if case .validationContextSdsSecretConfig(let v)? = _storage._validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()
    }
    set {_uniqueStorage()._validationContextType = .validationContextSdsSecretConfig(newValue)}
  }

  /// Combined certificate validation context holds a default CertificateValidationContext
  /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
  /// and default CertificateValidationContext are merged into a new CertificateValidationContext
  /// for validation. This merge is done by Message::MergeFrom(), so dynamic
  /// CertificateValidationContext overwrites singular fields in default
  /// CertificateValidationContext, and concatenates repeated fields to default
  /// CertificateValidationContext, and logical OR is applied to boolean fields.
  public var combinedValidationContext: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext {
    get {
      if case .combinedValidationContext(let v)? = _storage._validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext()
    }
    set {_uniqueStorage()._validationContextType = .combinedValidationContext(newValue)}
  }

  /// Certificate provider for fetching validation context.
  /// [#not-implemented-hide:]
  public var validationContextCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider {
    get {
      if case .validationContextCertificateProvider(let v)? = _storage._validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider()
    }
    set {_uniqueStorage()._validationContextType = .validationContextCertificateProvider(newValue)}
  }

  /// Certificate provider instance for fetching validation context.
  /// [#not-implemented-hide:]
  public var validationContextCertificateProviderInstance: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance {
    get {
      if case .validationContextCertificateProviderInstance(let v)? = _storage._validationContextType {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance()
    }
    set {_uniqueStorage()._validationContextType = .validationContextCertificateProviderInstance(newValue)}
  }

  /// Supplies the list of ALPN protocols that the listener should expose. In
  /// practice this is likely to be set to one of two values (see the
  /// :ref:`codec_type
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.codec_type>`
  /// parameter in the HTTP connection manager for more information):
  ///
  /// * "h2,http/1.1" If the listener is going to support both HTTP/2 and HTTP/1.1.
  /// * "http/1.1" If the listener is only going to support HTTP/1.1.
  ///
  /// There is no default for this parameter. If empty, Envoy will not expose ALPN.
  public var alpnProtocols: [String] {
    get {return _storage._alpnProtocols}
    set {_uniqueStorage()._alpnProtocols = newValue}
  }

  /// Custom TLS handshaker. If empty, defaults to native TLS handshaking
  /// behavior.
  public var customHandshaker: Envoy_Config_Core_V3_TypedExtensionConfig {
    get {return _storage._customHandshaker ?? Envoy_Config_Core_V3_TypedExtensionConfig()}
    set {_uniqueStorage()._customHandshaker = newValue}
  }
  /// Returns true if `customHandshaker` has been explicitly set.
  public var hasCustomHandshaker: Bool {return _storage._customHandshaker != nil}
  /// Clears the value of `customHandshaker`. Subsequent reads from it will return its default value.
  public mutating func clearCustomHandshaker() {_uniqueStorage()._customHandshaker = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ValidationContextType: Equatable {
    /// How to validate peer certificates.
    case validationContext(Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext)
    /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    case validationContextSdsSecretConfig(Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig)
    /// Combined certificate validation context holds a default CertificateValidationContext
    /// and SDS config. When SDS server returns dynamic CertificateValidationContext, both dynamic
    /// and default CertificateValidationContext are merged into a new CertificateValidationContext
    /// for validation. This merge is done by Message::MergeFrom(), so dynamic
    /// CertificateValidationContext overwrites singular fields in default
    /// CertificateValidationContext, and concatenates repeated fields to default
    /// CertificateValidationContext, and logical OR is applied to boolean fields.
    case combinedValidationContext(Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext)
    /// Certificate provider for fetching validation context.
    /// [#not-implemented-hide:]
    case validationContextCertificateProvider(Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider)
    /// Certificate provider instance for fetching validation context.
    /// [#not-implemented-hide:]
    case validationContextCertificateProviderInstance(Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.OneOf_ValidationContextType, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.OneOf_ValidationContextType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.validationContext, .validationContext): return {
        guard case .validationContext(let l) = lhs, case .validationContext(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validationContextSdsSecretConfig, .validationContextSdsSecretConfig): return {
        guard case .validationContextSdsSecretConfig(let l) = lhs, case .validationContextSdsSecretConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.combinedValidationContext, .combinedValidationContext): return {
        guard case .combinedValidationContext(let l) = lhs, case .combinedValidationContext(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validationContextCertificateProvider, .validationContextCertificateProvider): return {
        guard case .validationContextCertificateProvider(let l) = lhs, case .validationContextCertificateProvider(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.validationContextCertificateProviderInstance, .validationContextCertificateProviderInstance): return {
        guard case .validationContextCertificateProviderInstance(let l) = lhs, case .validationContextCertificateProviderInstance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Config for Certificate provider to get certificates. This provider should allow certificates to be
  /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
  public struct CertificateProvider {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    /// a root-certificate (validation context) or "TLS" to specify a new tls-certificate.
    public var name: String = String()

    /// Provider specific config.
    /// Note: an implementation is expected to dedup multiple instances of the same config
    /// to maintain a single certificate-provider instance. The sharing can happen, for
    /// example, among multiple clusters or between the tls_certificate and validation_context
    /// certificate providers of a cluster.
    /// This config could be supplied inline or (in future) a named xDS resource.
    public var config: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider.OneOf_Config? = nil

    public var typedConfig: Envoy_Config_Core_V3_TypedExtensionConfig {
      get {
        if case .typedConfig(let v)? = config {return v}
        return Envoy_Config_Core_V3_TypedExtensionConfig()
      }
      set {config = .typedConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Provider specific config.
    /// Note: an implementation is expected to dedup multiple instances of the same config
    /// to maintain a single certificate-provider instance. The sharing can happen, for
    /// example, among multiple clusters or between the tls_certificate and validation_context
    /// certificate providers of a cluster.
    /// This config could be supplied inline or (in future) a named xDS resource.
    public enum OneOf_Config: Equatable {
      case typedConfig(Envoy_Config_Core_V3_TypedExtensionConfig)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider.OneOf_Config, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider.OneOf_Config) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.typedConfig, .typedConfig): return {
          guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        }
      }
    #endif
    }

    public init() {}
  }

  /// Similar to CertificateProvider above, but allows the provider instances to be configured on
  /// the client side instead of being sent from the control plane.
  public struct CertificateProviderInstance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Provider instance name. This name must be defined in the client's configuration (e.g., a
    /// bootstrap file) to correspond to a provider instance (i.e., the same data in the typed_config
    /// field that would be sent in the CertificateProvider message if the config was sent by the
    /// control plane). If not present, defaults to "default".
    ///
    /// Instance names should generally be defined not in terms of the underlying provider
    /// implementation (e.g., "file_watcher") but rather in terms of the function of the
    /// certificates (e.g., "foo_deployment_identity").
    public var instanceName: String = String()

    /// Opaque name used to specify certificate instances or types. For example, "ROOTCA" to specify
    /// a root-certificate (validation context) or "example.com" to specify a certificate for a
    /// particular domain. Not all provider instances will actually use this field, so the value
    /// defaults to the empty string.
    public var certificateName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct CombinedCertificateValidationContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How to validate peer certificates.
    public var defaultValidationContext: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext {
      get {return _defaultValidationContext ?? Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext()}
      set {_defaultValidationContext = newValue}
    }
    /// Returns true if `defaultValidationContext` has been explicitly set.
    public var hasDefaultValidationContext: Bool {return self._defaultValidationContext != nil}
    /// Clears the value of `defaultValidationContext`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultValidationContext() {self._defaultValidationContext = nil}

    /// Config for fetching validation context via SDS API. Note SDS API allows certificates to be
    /// fetched/refreshed over the network asynchronously with respect to the TLS handshake.
    /// Only one of validation_context_sds_secret_config, validation_context_certificate_provider,
    /// or validation_context_certificate_provider_instance may be used.
    public var validationContextSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
      get {return _validationContextSdsSecretConfig ?? Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()}
      set {_validationContextSdsSecretConfig = newValue}
    }
    /// Returns true if `validationContextSdsSecretConfig` has been explicitly set.
    public var hasValidationContextSdsSecretConfig: Bool {return self._validationContextSdsSecretConfig != nil}
    /// Clears the value of `validationContextSdsSecretConfig`. Subsequent reads from it will return its default value.
    public mutating func clearValidationContextSdsSecretConfig() {self._validationContextSdsSecretConfig = nil}

    /// Certificate provider for fetching validation context.
    /// Only one of validation_context_sds_secret_config, validation_context_certificate_provider,
    /// or validation_context_certificate_provider_instance may be used.
    /// [#not-implemented-hide:]
    public var validationContextCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider {
      get {return _validationContextCertificateProvider ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider()}
      set {_validationContextCertificateProvider = newValue}
    }
    /// Returns true if `validationContextCertificateProvider` has been explicitly set.
    public var hasValidationContextCertificateProvider: Bool {return self._validationContextCertificateProvider != nil}
    /// Clears the value of `validationContextCertificateProvider`. Subsequent reads from it will return its default value.
    public mutating func clearValidationContextCertificateProvider() {self._validationContextCertificateProvider = nil}

    /// Certificate provider instance for fetching validation context.
    /// Only one of validation_context_sds_secret_config, validation_context_certificate_provider,
    /// or validation_context_certificate_provider_instance may be used.
    /// [#not-implemented-hide:]
    public var validationContextCertificateProviderInstance: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance {
      get {return _validationContextCertificateProviderInstance ?? Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance()}
      set {_validationContextCertificateProviderInstance = newValue}
    }
    /// Returns true if `validationContextCertificateProviderInstance` has been explicitly set.
    public var hasValidationContextCertificateProviderInstance: Bool {return self._validationContextCertificateProviderInstance != nil}
    /// Clears the value of `validationContextCertificateProviderInstance`. Subsequent reads from it will return its default value.
    public mutating func clearValidationContextCertificateProviderInstance() {self._validationContextCertificateProviderInstance = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _defaultValidationContext: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext? = nil
    fileprivate var _validationContextSdsSecretConfig: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig? = nil
    fileprivate var _validationContextCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider? = nil
    fileprivate var _validationContextCertificateProviderInstance: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.transport_sockets.tls.v3"

extension Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpstreamTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_tls_context"),
    2: .same(proto: "sni"),
    3: .standard(proto: "allow_renegotiation"),
    4: .standard(proto: "max_session_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commonTlsContext) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sni) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowRenegotiation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxSessionKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commonTlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.sni.isEmpty {
      try visitor.visitSingularStringField(value: self.sni, fieldNumber: 2)
    }
    if self.allowRenegotiation != false {
      try visitor.visitSingularBoolField(value: self.allowRenegotiation, fieldNumber: 3)
    }
    if let v = self._maxSessionKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_UpstreamTlsContext) -> Bool {
    if lhs._commonTlsContext != rhs._commonTlsContext {return false}
    if lhs.sni != rhs.sni {return false}
    if lhs.allowRenegotiation != rhs.allowRenegotiation {return false}
    if lhs._maxSessionKeys != rhs._maxSessionKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownstreamTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_tls_context"),
    2: .standard(proto: "require_client_certificate"),
    3: .standard(proto: "require_sni"),
    4: .standard(proto: "session_ticket_keys"),
    5: .standard(proto: "session_ticket_keys_sds_secret_config"),
    7: .standard(proto: "disable_stateless_session_resumption"),
    6: .standard(proto: "session_timeout"),
    8: .standard(proto: "ocsp_staple_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commonTlsContext) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requireClientCertificate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requireSni) }()
      case 4: try {
        var v: Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys?
        if let current = self.sessionTicketKeysType {
          try decoder.handleConflictingOneOf()
          if case .sessionTicketKeys(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sessionTicketKeysType = .sessionTicketKeys(v)}
      }()
      case 5: try {
        var v: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig?
        if let current = self.sessionTicketKeysType {
          try decoder.handleConflictingOneOf()
          if case .sessionTicketKeysSdsSecretConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sessionTicketKeysType = .sessionTicketKeysSdsSecretConfig(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sessionTimeout) }()
      case 7: try {
        if self.sessionTicketKeysType != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.sessionTicketKeysType = .disableStatelessSessionResumption(v)}
      }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.ocspStaplePolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commonTlsContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._requireClientCertificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._requireSni {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sessionTicketKeysType {
    case .sessionTicketKeys?: try {
      guard case .sessionTicketKeys(let v)? = self.sessionTicketKeysType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .sessionTicketKeysSdsSecretConfig?: try {
      guard case .sessionTicketKeysSdsSecretConfig(let v)? = self.sessionTicketKeysType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    if let v = self._sessionTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if case .disableStatelessSessionResumption(let v)? = self.sessionTicketKeysType {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    }
    if self.ocspStaplePolicy != .lenientStapling {
      try visitor.visitSingularEnumField(value: self.ocspStaplePolicy, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext) -> Bool {
    if lhs._commonTlsContext != rhs._commonTlsContext {return false}
    if lhs._requireClientCertificate != rhs._requireClientCertificate {return false}
    if lhs._requireSni != rhs._requireSni {return false}
    if lhs.sessionTicketKeysType != rhs.sessionTicketKeysType {return false}
    if lhs._sessionTimeout != rhs._sessionTimeout {return false}
    if lhs.ocspStaplePolicy != rhs.ocspStaplePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_DownstreamTlsContext.OcspStaplePolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LENIENT_STAPLING"),
    1: .same(proto: "STRICT_STAPLING"),
    2: .same(proto: "MUST_STAPLE"),
  ]
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonTlsContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tls_params"),
    2: .standard(proto: "tls_certificates"),
    6: .standard(proto: "tls_certificate_sds_secret_configs"),
    9: .standard(proto: "tls_certificate_certificate_provider"),
    11: .standard(proto: "tls_certificate_certificate_provider_instance"),
    3: .standard(proto: "validation_context"),
    7: .standard(proto: "validation_context_sds_secret_config"),
    8: .standard(proto: "combined_validation_context"),
    10: .standard(proto: "validation_context_certificate_provider"),
    12: .standard(proto: "validation_context_certificate_provider_instance"),
    4: .standard(proto: "alpn_protocols"),
    13: .standard(proto: "custom_handshaker"),
  ]

  fileprivate class _StorageClass {
    var _tlsParams: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters? = nil
    var _tlsCertificates: [Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate] = []
    var _tlsCertificateSdsSecretConfigs: [Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig] = []
    var _tlsCertificateCertificateProvider: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider? = nil
    var _tlsCertificateCertificateProviderInstance: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance? = nil
    var _validationContextType: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.OneOf_ValidationContextType?
    var _alpnProtocols: [String] = []
    var _customHandshaker: Envoy_Config_Core_V3_TypedExtensionConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tlsParams = source._tlsParams
      _tlsCertificates = source._tlsCertificates
      _tlsCertificateSdsSecretConfigs = source._tlsCertificateSdsSecretConfigs
      _tlsCertificateCertificateProvider = source._tlsCertificateCertificateProvider
      _tlsCertificateCertificateProviderInstance = source._tlsCertificateCertificateProviderInstance
      _validationContextType = source._validationContextType
      _alpnProtocols = source._alpnProtocols
      _customHandshaker = source._customHandshaker
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tlsParams) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._tlsCertificates) }()
        case 3: try {
          var v: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .validationContext(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .validationContext(v)}
        }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._alpnProtocols) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._tlsCertificateSdsSecretConfigs) }()
        case 7: try {
          var v: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .validationContextSdsSecretConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .validationContextSdsSecretConfig(v)}
        }()
        case 8: try {
          var v: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .combinedValidationContext(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .combinedValidationContext(v)}
        }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._tlsCertificateCertificateProvider) }()
        case 10: try {
          var v: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .validationContextCertificateProvider(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .validationContextCertificateProvider(v)}
        }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._tlsCertificateCertificateProviderInstance) }()
        case 12: try {
          var v: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance?
          if let current = _storage._validationContextType {
            try decoder.handleConflictingOneOf()
            if case .validationContextCertificateProviderInstance(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._validationContextType = .validationContextCertificateProviderInstance(v)}
        }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._customHandshaker) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tlsParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._tlsCertificates.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tlsCertificates, fieldNumber: 2)
      }
      if case .validationContext(let v)? = _storage._validationContextType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._alpnProtocols.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._alpnProtocols, fieldNumber: 4)
      }
      if !_storage._tlsCertificateSdsSecretConfigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._tlsCertificateSdsSecretConfigs, fieldNumber: 6)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._validationContextType {
      case .validationContextSdsSecretConfig?: try {
        guard case .validationContextSdsSecretConfig(let v)? = _storage._validationContextType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .combinedValidationContext?: try {
        guard case .combinedValidationContext(let v)? = _storage._validationContextType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      default: break
      }
      if let v = _storage._tlsCertificateCertificateProvider {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if case .validationContextCertificateProvider(let v)? = _storage._validationContextType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._tlsCertificateCertificateProviderInstance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if case .validationContextCertificateProviderInstance(let v)? = _storage._validationContextType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._customHandshaker {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tlsParams != rhs_storage._tlsParams {return false}
        if _storage._tlsCertificates != rhs_storage._tlsCertificates {return false}
        if _storage._tlsCertificateSdsSecretConfigs != rhs_storage._tlsCertificateSdsSecretConfigs {return false}
        if _storage._tlsCertificateCertificateProvider != rhs_storage._tlsCertificateCertificateProvider {return false}
        if _storage._tlsCertificateCertificateProviderInstance != rhs_storage._tlsCertificateCertificateProviderInstance {return false}
        if _storage._validationContextType != rhs_storage._validationContextType {return false}
        if _storage._alpnProtocols != rhs_storage._alpnProtocols {return false}
        if _storage._customHandshaker != rhs_storage._customHandshaker {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.protoMessageName + ".CertificateProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Envoy_Config_Core_V3_TypedExtensionConfig?
        if let current = self.config {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.config = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProvider) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.config != rhs.config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.protoMessageName + ".CertificateProviderInstance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_name"),
    2: .standard(proto: "certificate_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.certificateName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceName.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceName, fieldNumber: 1)
    }
    if !self.certificateName.isEmpty {
      try visitor.visitSingularStringField(value: self.certificateName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CertificateProviderInstance) -> Bool {
    if lhs.instanceName != rhs.instanceName {return false}
    if lhs.certificateName != rhs.certificateName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.protoMessageName + ".CombinedCertificateValidationContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_validation_context"),
    2: .standard(proto: "validation_context_sds_secret_config"),
    3: .standard(proto: "validation_context_certificate_provider"),
    4: .standard(proto: "validation_context_certificate_provider_instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._defaultValidationContext) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validationContextSdsSecretConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._validationContextCertificateProvider) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._validationContextCertificateProviderInstance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._defaultValidationContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._validationContextSdsSecretConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._validationContextCertificateProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._validationContextCertificateProviderInstance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CommonTlsContext.CombinedCertificateValidationContext) -> Bool {
    if lhs._defaultValidationContext != rhs._defaultValidationContext {return false}
    if lhs._validationContextSdsSecretConfig != rhs._validationContextSdsSecretConfig {return false}
    if lhs._validationContextCertificateProvider != rhs._validationContextCertificateProvider {return false}
    if lhs._validationContextCertificateProviderInstance != rhs._validationContextCertificateProviderInstance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/transport_sockets/tls/v3/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_0`` for
  /// servers.
  public var tlsMinimumProtocolVersion: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters.TlsProtocol = .tlsAuto

  /// Maximum TLS protocol version. By default, it's ``TLSv1_2`` for clients and ``TLSv1_3`` for
  /// servers.
  public var tlsMaximumProtocolVersion: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters.TlsProtocol = .tlsAuto

  /// If specified, the TLS listener will only support the specified `cipher list
  /// <https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration>`_
  /// when negotiating TLS 1.0-1.2 (this setting has no effect when negotiating TLS 1.3). If not
  /// specified, the default list will be used.
  ///
  /// In non-FIPS builds, the default cipher list is:
  ///
  /// .. code-block:: none
  ///
  ///   [ECDHE-ECDSA-AES128-GCM-SHA256|ECDHE-ECDSA-CHACHA20-POLY1305]
  ///   [ECDHE-RSA-AES128-GCM-SHA256|ECDHE-RSA-CHACHA20-POLY1305]
  ///   ECDHE-ECDSA-AES128-SHA
  ///   ECDHE-RSA-AES128-SHA
  ///   AES128-GCM-SHA256
  ///   AES128-SHA
  ///   ECDHE-ECDSA-AES256-GCM-SHA384
  ///   ECDHE-RSA-AES256-GCM-SHA384
  ///   ECDHE-ECDSA-AES256-SHA
  ///   ECDHE-RSA-AES256-SHA
  ///   AES256-GCM-SHA384
  ///   AES256-SHA
  ///
  /// In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default cipher list is:
  ///
  /// .. code-block:: none
  ///
  ///   ECDHE-ECDSA-AES128-GCM-SHA256
  ///   ECDHE-RSA-AES128-GCM-SHA256
  ///   ECDHE-ECDSA-AES128-SHA
  ///   ECDHE-RSA-AES128-SHA
  ///   AES128-GCM-SHA256
  ///   AES128-SHA
  ///   ECDHE-ECDSA-AES256-GCM-SHA384
  ///   ECDHE-RSA-AES256-GCM-SHA384
  ///   ECDHE-ECDSA-AES256-SHA
  ///   ECDHE-RSA-AES256-SHA
  ///   AES256-GCM-SHA384
  ///   AES256-SHA
  public var cipherSuites: [String] = []

  /// If specified, the TLS connection will only support the specified ECDH
  /// curves. If not specified, the default curves will be used.
  ///
  /// In non-FIPS builds, the default curves are:
  ///
  /// .. code-block:: none
  ///
  ///   X25519
  ///   P-256
  ///
  /// In builds using :ref:`BoringSSL FIPS <arch_overview_ssl_fips>`, the default curve is:
  ///
  /// .. code-block:: none
  ///
  ///   P-256
  public var ecdhCurves: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TlsProtocol: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Envoy will choose the optimal TLS version.
    case tlsAuto // = 0

    /// TLS 1.0
    case tlsv10 // = 1

    /// TLS 1.1
    case tlsv11 // = 2

    /// TLS 1.2
    case tlsv12 // = 3

    /// TLS 1.3
    case tlsv13 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .tlsAuto
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .tlsAuto
      case 1: self = .tlsv10
      case 2: self = .tlsv11
      case 3: self = .tlsv12
      case 4: self = .tlsv13
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .tlsAuto: return 0
      case .tlsv10: return 1
      case .tlsv11: return 2
      case .tlsv12: return 3
      case .tlsv13: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters.TlsProtocol: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters.TlsProtocol] = [
    .tlsAuto,
    .tlsv10,
    .tlsv11,
    .tlsv12,
    .tlsv13,
  ]
}

#endif  // swift(>=4.2)

/// BoringSSL private key method configuration. The private key methods are used for external
/// (potentially asynchronous) signing and decryption operations. Some use cases for private key
/// methods would be TPM support and TLS acceleration.
public struct Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Private key method provider name. The name must match a
  /// supported private key method provider type.
  public var providerName: String = String()

  /// Private key method provider specific configuration.
  public var configType: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider.OneOf_ConfigType? = nil

  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .typedConfig(let v)? = configType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {configType = .typedConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Private key method provider specific configuration.
  public enum OneOf_ConfigType: Equatable {
    case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider.OneOf_ConfigType, rhs: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider.OneOf_ConfigType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.typedConfig, .typedConfig): return {
        guard case .typedConfig(let l) = lhs, case .typedConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// [#next-free-field: 7]
public struct Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The TLS certificate chain.
  public var certificateChain: Envoy_Config_Core_V3_DataSource {
    get {return _certificateChain ?? Envoy_Config_Core_V3_DataSource()}
    set {_certificateChain = newValue}
  }
  /// Returns true if `certificateChain` has been explicitly set.
  public var hasCertificateChain: Bool {return self._certificateChain != nil}
  /// Clears the value of `certificateChain`. Subsequent reads from it will return its default value.
  public mutating func clearCertificateChain() {self._certificateChain = nil}

  /// The TLS private key.
  public var privateKey: Envoy_Config_Core_V3_DataSource {
    get {return _privateKey ?? Envoy_Config_Core_V3_DataSource()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  public var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  public mutating func clearPrivateKey() {self._privateKey = nil}

  /// BoringSSL private key method provider. This is an alternative to :ref:`private_key
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` field. This can't be
  /// marked as ``oneof`` due to API compatibility reasons. Setting both :ref:`private_key
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key>` and
  /// :ref:`private_key_provider
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.TlsCertificate.private_key_provider>` fields will result in an
  /// error.
  public var privateKeyProvider: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider {
    get {return _privateKeyProvider ?? Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider()}
    set {_privateKeyProvider = newValue}
  }
  /// Returns true if `privateKeyProvider` has been explicitly set.
  public var hasPrivateKeyProvider: Bool {return self._privateKeyProvider != nil}
  /// Clears the value of `privateKeyProvider`. Subsequent reads from it will return its default value.
  public mutating func clearPrivateKeyProvider() {self._privateKeyProvider = nil}

  /// The password to decrypt the TLS private key. If this field is not set, it is assumed that the
  /// TLS private key is not password encrypted.
  public var password: Envoy_Config_Core_V3_DataSource {
    get {return _password ?? Envoy_Config_Core_V3_DataSource()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  public var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  public mutating func clearPassword() {self._password = nil}

  /// The OCSP response to be stapled with this certificate during the handshake.
  /// The response must be DER-encoded and may only be  provided via ``filename`` or
  /// ``inline_bytes``. The response may pertain to only one certificate.
  public var ocspStaple: Envoy_Config_Core_V3_DataSource {
    get {return _ocspStaple ?? Envoy_Config_Core_V3_DataSource()}
    set {_ocspStaple = newValue}
  }
  /// Returns true if `ocspStaple` has been explicitly set.
  public var hasOcspStaple: Bool {return self._ocspStaple != nil}
  /// Clears the value of `ocspStaple`. Subsequent reads from it will return its default value.
  public mutating func clearOcspStaple() {self._ocspStaple = nil}

  /// [#not-implemented-hide:]
  public var signedCertificateTimestamp: [Envoy_Config_Core_V3_DataSource] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _certificateChain: Envoy_Config_Core_V3_DataSource? = nil
  fileprivate var _privateKey: Envoy_Config_Core_V3_DataSource? = nil
  fileprivate var _privateKeyProvider: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider? = nil
  fileprivate var _password: Envoy_Config_Core_V3_DataSource? = nil
  fileprivate var _ocspStaple: Envoy_Config_Core_V3_DataSource? = nil
}

public struct Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Keys for encrypting and decrypting TLS session tickets. The
  /// first key in the array contains the key to encrypt all new sessions created by this context.
  /// All keys are candidates for decrypting received tickets. This allows for easy rotation of keys
  /// by, for example, putting the new key first, and the previous key second.
  ///
  /// If :ref:`session_ticket_keys <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.session_ticket_keys>`
  /// is not specified, the TLS library will still support resuming sessions via tickets, but it will
  /// use an internally-generated and managed key, so sessions cannot be resumed across hot restarts
  /// or on different hosts.
  ///
  /// Each key must contain exactly 80 bytes of cryptographically-secure random data. For
  /// example, the output of ``openssl rand 80``.
  ///
  /// .. attention::
  ///
  ///   Using this feature has serious security considerations and risks. Improper handling of keys
  ///   may result in loss of secrecy in connections, even if ciphers supporting perfect forward
  ///   secrecy are used. See https://www.imperialviolet.org/2013/06/27/botchingpfs.html for some
  ///   discussion. To minimize the risk, you must:
  ///
  ///   * Keep the session ticket keys at least as secure as your TLS certificate private keys
  ///   * Rotate session ticket keys at least daily, and preferably hourly
  ///   * Always generate keys using a cryptographically-secure random data source
  public var keys: [Envoy_Config_Core_V3_DataSource] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [#next-free-field: 11]
public struct Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TLS certificate data containing certificate authority certificates to use in verifying
  /// a presented peer certificate (e.g. server certificate for clusters or client certificate
  /// for listeners). If not specified and a peer certificate is presented it will not be
  /// verified. By default, a client certificate is optional, unless one of the additional
  /// options (:ref:`require_client_certificate
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.DownstreamTlsContext.require_client_certificate>`,
  /// :ref:`verify_certificate_spki
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>`,
  /// :ref:`verify_certificate_hash
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`, or
  /// :ref:`match_subject_alt_names
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.match_subject_alt_names>`) is also
  /// specified.
  ///
  /// It can optionally contain certificate revocation lists, in which case Envoy will verify
  /// that the presented peer certificate has not been revoked by one of the included CRLs. Note
  /// that if a CRL is provided for any certificate authority in a trust chain, a CRL must be
  /// provided for all certificate authorities in that chain. Failure to do so will result in
  /// verification failure for both revoked and unrevoked certificates from that chain.
  ///
  /// See :ref:`the TLS overview <arch_overview_ssl_enabling_verification>` for a list of common
  /// system CA locations.
  public var trustedCa: Envoy_Config_Core_V3_DataSource {
    get {return _trustedCa ?? Envoy_Config_Core_V3_DataSource()}
    set {_trustedCa = newValue}
  }
  /// Returns true if `trustedCa` has been explicitly set.
  public var hasTrustedCa: Bool {return self._trustedCa != nil}
  /// Clears the value of `trustedCa`. Subsequent reads from it will return its default value.
  public mutating func clearTrustedCa() {self._trustedCa = nil}

  /// An optional list of base64-encoded SHA-256 hashes. If specified, Envoy will verify that the
  /// SHA-256 of the DER-encoded Subject Public Key Information (SPKI) of the presented certificate
  /// matches one of the specified values.
  ///
  /// A base64-encoded SHA-256 of the Subject Public Key Information (SPKI) of the certificate
  /// can be generated with the following command:
  ///
  /// .. code-block:: bash
  ///
  ///   $ openssl x509 -in path/to/client.crt -noout -pubkey
  ///     | openssl pkey -pubin -outform DER
  ///     | openssl dgst -sha256 -binary
  ///     | openssl enc -base64
  ///   NvqYIYSbgK2vCJpQhObf77vv+bQWtc5ek5RIOwPiC9A=
  ///
  /// This is the format used in HTTP Public Key Pinning.
  ///
  /// When both:
  /// :ref:`verify_certificate_hash
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
  /// :ref:`verify_certificate_spki
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
  /// a hash matching value from either of the lists will result in the certificate being accepted.
  ///
  /// .. attention::
  ///
  ///   This option is preferred over :ref:`verify_certificate_hash
  ///   <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>`,
  ///   because SPKI is tied to a private key, so it doesn't change when the certificate
  ///   is renewed using the same private key.
  public var verifyCertificateSpki: [String] = []

  /// An optional list of hex-encoded SHA-256 hashes. If specified, Envoy will verify that
  /// the SHA-256 of the DER-encoded presented certificate matches one of the specified values.
  ///
  /// A hex-encoded SHA-256 of the certificate can be generated with the following command:
  ///
  /// .. code-block:: bash
  ///
  ///   $ openssl x509 -in path/to/client.crt -outform DER | openssl dgst -sha256 | cut -d" " -f2
  ///   df6ff72fe9116521268f6f2dd4966f51df479883fe7037b39f75916ac3049d1a
  ///
  /// A long hex-encoded and colon-separated SHA-256 (a.k.a. "fingerprint") of the certificate
  /// can be generated with the following command:
  ///
  /// .. code-block:: bash
  ///
  ///   $ openssl x509 -in path/to/client.crt -noout -fingerprint -sha256 | cut -d"=" -f2
  ///   DF:6F:F7:2F:E9:11:65:21:26:8F:6F:2D:D4:96:6F:51:DF:47:98:83:FE:70:37:B3:9F:75:91:6A:C3:04:9D:1A
  ///
  /// Both of those formats are acceptable.
  ///
  /// When both:
  /// :ref:`verify_certificate_hash
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_hash>` and
  /// :ref:`verify_certificate_spki
  /// <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.verify_certificate_spki>` are specified,
  /// a hash matching value from either of the lists will result in the certificate being accepted.
  public var verifyCertificateHash: [String] = []

  /// An optional list of Subject Alternative name matchers. If specified, Envoy will verify that the
  /// Subject Alternative Name of the presented certificate matches one of the specified matchers.
  ///
  /// When a certificate has wildcard DNS SAN entries, to match a specific client, it should be
  /// configured with exact match type in the :ref:`string matcher <envoy_api_msg_type.matcher.v3.StringMatcher>`.
  /// For example if the certificate has "\*.example.com" as DNS SAN entry, to allow only "api.example.com",
  /// it should be configured as shown below.
  ///
  /// .. code-block:: yaml
  ///
  ///  match_subject_alt_names:
  ///    exact: "api.example.com"
  ///
  /// .. attention::
  ///
  ///   Subject Alternative Names are easily spoofable and verifying only them is insecure,
  ///   therefore this option must be used together with :ref:`trusted_ca
  ///   <envoy_api_field_extensions.transport_sockets.tls.v3.CertificateValidationContext.trusted_ca>`.
  public var matchSubjectAltNames: [Envoy_Type_Matcher_V3_StringMatcher] = []

  /// [#not-implemented-hide:] Must present signed certificate time-stamp.
  public var requireSignedCertificateTimestamp: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _requireSignedCertificateTimestamp ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_requireSignedCertificateTimestamp = newValue}
  }
  /// Returns true if `requireSignedCertificateTimestamp` has been explicitly set.
  public var hasRequireSignedCertificateTimestamp: Bool {return self._requireSignedCertificateTimestamp != nil}
  /// Clears the value of `requireSignedCertificateTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearRequireSignedCertificateTimestamp() {self._requireSignedCertificateTimestamp = nil}

  /// An optional `certificate revocation list
  /// <https://en.wikipedia.org/wiki/Certificate_revocation_list>`_
  /// (in PEM format). If specified, Envoy will verify that the presented peer
  /// certificate has not been revoked by this CRL. If this DataSource contains
  /// multiple CRLs, all of them will be used. Note that if a CRL is provided
  /// for any certificate authority in a trust chain, a CRL must be provided
  /// for all certificate authorities in that chain. Failure to do so will
  /// result in verification failure for both revoked and unrevoked certificates
  /// from that chain.
  public var crl: Envoy_Config_Core_V3_DataSource {
    get {return _crl ?? Envoy_Config_Core_V3_DataSource()}
    set {_crl = newValue}
  }
  /// Returns true if `crl` has been explicitly set.
  public var hasCrl: Bool {return self._crl != nil}
  /// Clears the value of `crl`. Subsequent reads from it will return its default value.
  public mutating func clearCrl() {self._crl = nil}

  /// If specified, Envoy will not reject expired certificates.
  public var allowExpiredCertificate: Bool = false

  /// Certificate trust chain verification mode.
  public var trustChainVerification: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext.TrustChainVerification = .verifyTrustChain

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Peer certificate verification mode.
  public enum TrustChainVerification: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Perform default certificate verification (e.g., against CA / verification lists)
    case verifyTrustChain // = 0

    /// Connections where the certificate fails verification will be permitted.
    /// For HTTP connections, the result of certificate verification can be used in route matching. (
    /// see :ref:`validated <envoy_api_field_config.route.v3.RouteMatch.TlsContextMatchOptions.validated>` ).
    case acceptUntrusted // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .verifyTrustChain
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .verifyTrustChain
      case 1: self = .acceptUntrusted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .verifyTrustChain: return 0
      case .acceptUntrusted: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _trustedCa: Envoy_Config_Core_V3_DataSource? = nil
  fileprivate var _requireSignedCertificateTimestamp: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _crl: Envoy_Config_Core_V3_DataSource? = nil
}

#if swift(>=4.2)

extension Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext.TrustChainVerification: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext.TrustChainVerification] = [
    .verifyTrustChain,
    .acceptUntrusted,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.transport_sockets.tls.v3"

extension Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TlsParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tls_minimum_protocol_version"),
    2: .standard(proto: "tls_maximum_protocol_version"),
    3: .standard(proto: "cipher_suites"),
    4: .standard(proto: "ecdh_curves"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tlsMinimumProtocolVersion) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.tlsMaximumProtocolVersion) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.cipherSuites) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ecdhCurves) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tlsMinimumProtocolVersion != .tlsAuto {
      try visitor.visitSingularEnumField(value: self.tlsMinimumProtocolVersion, fieldNumber: 1)
    }
    if self.tlsMaximumProtocolVersion != .tlsAuto {
      try visitor.visitSingularEnumField(value: self.tlsMaximumProtocolVersion, fieldNumber: 2)
    }
    if !self.cipherSuites.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cipherSuites, fieldNumber: 3)
    }
    if !self.ecdhCurves.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ecdhCurves, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters, rhs: Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters) -> Bool {
    if lhs.tlsMinimumProtocolVersion != rhs.tlsMinimumProtocolVersion {return false}
    if lhs.tlsMaximumProtocolVersion != rhs.tlsMaximumProtocolVersion {return false}
    if lhs.cipherSuites != rhs.cipherSuites {return false}
    if lhs.ecdhCurves != rhs.ecdhCurves {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_TlsParameters.TlsProtocol: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TLS_AUTO"),
    1: .same(proto: "TLSv1_0"),
    2: .same(proto: "TLSv1_1"),
    3: .same(proto: "TLSv1_2"),
    4: .same(proto: "TLSv1_3"),
  ]
}

extension Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateKeyProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_name"),
    3: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.providerName) }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providerName.isEmpty {
      try visitor.visitSingularStringField(value: self.providerName, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider, rhs: Envoy_Extensions_TransportSockets_Tls_V3_PrivateKeyProvider) -> Bool {
    if lhs.providerName != rhs.providerName {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TlsCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "certificate_chain"),
    2: .standard(proto: "private_key"),
    6: .standard(proto: "private_key_provider"),
    3: .same(proto: "password"),
    4: .standard(proto: "ocsp_staple"),
    5: .standard(proto: "signed_certificate_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._certificateChain) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._privateKey) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._password) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ocspStaple) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.signedCertificateTimestamp) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._privateKeyProvider) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._certificateChain {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._privateKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._password {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._ocspStaple {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.signedCertificateTimestamp.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signedCertificateTimestamp, fieldNumber: 5)
    }
    if let v = self._privateKeyProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate, rhs: Envoy_Extensions_TransportSockets_Tls_V3_TlsCertificate) -> Bool {
    if lhs._certificateChain != rhs._certificateChain {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs._privateKeyProvider != rhs._privateKeyProvider {return false}
    if lhs._password != rhs._password {return false}
    if lhs._ocspStaple != rhs._ocspStaple {return false}
    if lhs.signedCertificateTimestamp != rhs.signedCertificateTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TlsSessionTicketKeys"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys, rhs: Envoy_Extensions_TransportSockets_Tls_V3_TlsSessionTicketKeys) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateValidationContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trusted_ca"),
    3: .standard(proto: "verify_certificate_spki"),
    2: .standard(proto: "verify_certificate_hash"),
    9: .standard(proto: "match_subject_alt_names"),
    6: .standard(proto: "require_signed_certificate_timestamp"),
    7: .same(proto: "crl"),
    8: .standard(proto: "allow_expired_certificate"),
    10: .standard(proto: "trust_chain_verification"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._trustedCa) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.verifyCertificateHash) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.verifyCertificateSpki) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._requireSignedCertificateTimestamp) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._crl) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.allowExpiredCertificate) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.matchSubjectAltNames) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.trustChainVerification) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._trustedCa {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.verifyCertificateHash.isEmpty {
      try visitor.visitRepeatedStringField(value: self.verifyCertificateHash, fieldNumber: 2)
    }
    if !self.verifyCertificateSpki.isEmpty {
      try visitor.visitRepeatedStringField(value: self.verifyCertificateSpki, fieldNumber: 3)
    }
    if let v = self._requireSignedCertificateTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._crl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.allowExpiredCertificate != false {
      try visitor.visitSingularBoolField(value: self.allowExpiredCertificate, fieldNumber: 8)
    }
    if !self.matchSubjectAltNames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matchSubjectAltNames, fieldNumber: 9)
    }
    if self.trustChainVerification != .verifyTrustChain {
      try visitor.visitSingularEnumField(value: self.trustChainVerification, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext, rhs: Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext) -> Bool {
    if lhs._trustedCa != rhs._trustedCa {return false}
    if lhs.verifyCertificateSpki != rhs.verifyCertificateSpki {return false}
    if lhs.verifyCertificateHash != rhs.verifyCertificateHash {return false}
    if lhs.matchSubjectAltNames != rhs.matchSubjectAltNames {return false}
    if lhs._requireSignedCertificateTimestamp != rhs._requireSignedCertificateTimestamp {return false}
    if lhs._crl != rhs._crl {return false}
    if lhs.allowExpiredCertificate != rhs.allowExpiredCertificate {return false}
    if lhs.trustChainVerification != rhs.trustChainVerification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_TransportSockets_Tls_V3_CertificateValidationContext.TrustChainVerification: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERIFY_TRUST_CHAIN"),
    1: .same(proto: "ACCEPT_UNTRUSTED"),
  ]
}

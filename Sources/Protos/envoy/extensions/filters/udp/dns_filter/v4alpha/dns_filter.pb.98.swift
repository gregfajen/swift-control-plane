// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/udp/dns_filter/v4alpha/dns_filter.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration for the DNS filter.
public struct Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The stat prefix used when emitting DNS filter statistics
  public var statPrefix: String = String()

  /// Server context configuration contains the data that the filter uses to respond
  /// to DNS requests.
  public var serverConfig: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig {
    get {return _serverConfig ?? Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig()}
    set {_serverConfig = newValue}
  }
  /// Returns true if `serverConfig` has been explicitly set.
  public var hasServerConfig: Bool {return self._serverConfig != nil}
  /// Clears the value of `serverConfig`. Subsequent reads from it will return its default value.
  public mutating func clearServerConfig() {self._serverConfig = nil}

  /// Client context configuration controls Envoy's behavior when it must use external
  /// resolvers to answer a query. This object is optional and if omitted instructs
  /// the filter to resolve queries from the data in the server_config
  public var clientConfig: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ClientContextConfig {
    get {return _clientConfig ?? Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ClientContextConfig()}
    set {_clientConfig = newValue}
  }
  /// Returns true if `clientConfig` has been explicitly set.
  public var hasClientConfig: Bool {return self._clientConfig != nil}
  /// Clears the value of `clientConfig`. Subsequent reads from it will return its default value.
  public mutating func clearClientConfig() {self._clientConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This message contains the configuration for the DNS Filter operating
  /// in a server context. This message will contain the virtual hosts and
  /// associated addresses with which Envoy will respond to queries
  public struct ServerContextConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var configSource: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig.OneOf_ConfigSource? = nil

    /// Load the configuration specified from the control plane
    public var inlineDnsTable: Envoy_Data_Dns_V4alpha_DnsTable {
      get {
        if case .inlineDnsTable(let v)? = configSource {return v}
        return Envoy_Data_Dns_V4alpha_DnsTable()
      }
      set {configSource = .inlineDnsTable(newValue)}
    }

    /// Seed the filter configuration from an external path. This source
    /// is a yaml formatted file that contains the DnsTable driving Envoy's
    /// responses to DNS queries
    public var externalDnsTable: Envoy_Config_Core_V4alpha_DataSource {
      get {
        if case .externalDnsTable(let v)? = configSource {return v}
        return Envoy_Config_Core_V4alpha_DataSource()
      }
      set {configSource = .externalDnsTable(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ConfigSource: Equatable {
      /// Load the configuration specified from the control plane
      case inlineDnsTable(Envoy_Data_Dns_V4alpha_DnsTable)
      /// Seed the filter configuration from an external path. This source
      /// is a yaml formatted file that contains the DnsTable driving Envoy's
      /// responses to DNS queries
      case externalDnsTable(Envoy_Config_Core_V4alpha_DataSource)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig.OneOf_ConfigSource, rhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig.OneOf_ConfigSource) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.inlineDnsTable, .inlineDnsTable): return {
          guard case .inlineDnsTable(let l) = lhs, case .inlineDnsTable(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.externalDnsTable, .externalDnsTable): return {
          guard case .externalDnsTable(let l) = lhs, case .externalDnsTable(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// This message contains the configuration for the DNS Filter operating
  /// in a client context. This message will contain the timeouts, retry,
  /// and forwarding configuration for Envoy to make DNS requests to other
  /// resolvers
  public struct ClientContextConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Sets the maximum time we will wait for the upstream query to complete
    /// We allow 5s for the upstream resolution to complete, so the minimum
    /// value here is 1. Note that the total latency for a failed query is the
    /// number of retries multiplied by the resolver_timeout.
    public var resolverTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _resolverTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_resolverTimeout = newValue}
    }
    /// Returns true if `resolverTimeout` has been explicitly set.
    public var hasResolverTimeout: Bool {return self._resolverTimeout != nil}
    /// Clears the value of `resolverTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearResolverTimeout() {self._resolverTimeout = nil}

    /// A list of DNS servers to which we can forward queries. If not
    /// specified, Envoy will use the ambient DNS resolvers in the
    /// system.
    public var upstreamResolvers: [Envoy_Config_Core_V4alpha_Address] = []

    /// Controls how many outstanding external lookup contexts the filter tracks.
    /// The context structure allows the filter to respond to every query even if the external
    /// resolution times out or is otherwise unsuccessful
    public var maxPendingLookups: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _resolverTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _serverConfig: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig? = nil
  fileprivate var _clientConfig: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ClientContextConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.udp.dns_filter.v4alpha"

extension Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DnsFilterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_prefix"),
    2: .standard(proto: "server_config"),
    3: .standard(proto: "client_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.statPrefix) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._serverConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.statPrefix, fieldNumber: 1)
    }
    if let v = self._serverConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._clientConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig, rhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig) -> Bool {
    if lhs.statPrefix != rhs.statPrefix {return false}
    if lhs._serverConfig != rhs._serverConfig {return false}
    if lhs._clientConfig != rhs._clientConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.protoMessageName + ".ServerContextConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "inline_dns_table"),
    2: .standard(proto: "external_dns_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Envoy_Data_Dns_V4alpha_DnsTable?
        if let current = self.configSource {
          try decoder.handleConflictingOneOf()
          if case .inlineDnsTable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configSource = .inlineDnsTable(v)}
      }()
      case 2: try {
        var v: Envoy_Config_Core_V4alpha_DataSource?
        if let current = self.configSource {
          try decoder.handleConflictingOneOf()
          if case .externalDnsTable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configSource = .externalDnsTable(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.configSource {
    case .inlineDnsTable?: try {
      guard case .inlineDnsTable(let v)? = self.configSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .externalDnsTable?: try {
      guard case .externalDnsTable(let v)? = self.configSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig, rhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ServerContextConfig) -> Bool {
    if lhs.configSource != rhs.configSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ClientContextConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.protoMessageName + ".ClientContextConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resolver_timeout"),
    2: .standard(proto: "upstream_resolvers"),
    3: .standard(proto: "max_pending_lookups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resolverTimeout) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.upstreamResolvers) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.maxPendingLookups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._resolverTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.upstreamResolvers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.upstreamResolvers, fieldNumber: 2)
    }
    if self.maxPendingLookups != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxPendingLookups, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ClientContextConfig, rhs: Envoy_Extensions_Filters_Udp_DnsFilter_V4alpha_DnsFilterConfig.ClientContextConfig) -> Bool {
    if lhs._resolverTimeout != rhs._resolverTimeout {return false}
    if lhs.upstreamResolvers != rhs.upstreamResolvers {return false}
    if lhs.maxPendingLookups != rhs.maxPendingLookups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

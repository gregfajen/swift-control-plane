// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/common/fault/v3/fault.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Delay specification is used to inject latency into the
/// HTTP/gRPC/Mongo/Redis operation or delay proxying of TCP connections.
/// [#next-free-field: 6]
public struct Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var faultDelaySecifier: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.OneOf_FaultDelaySecifier? = nil

  /// Add a fixed delay before forwarding the operation upstream. See
  /// https://developers.google.com/protocol-buffers/docs/proto3#json for
  /// the JSON/YAML Duration mapping. For HTTP/Mongo/Redis, the specified
  /// delay will be injected before a new request/operation. For TCP
  /// connections, the proxying of the connection upstream will be delayed
  /// for the specified period. This is required if type is FIXED.
  public var fixedDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .fixedDelay(let v)? = faultDelaySecifier {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {faultDelaySecifier = .fixedDelay(newValue)}
  }

  /// Fault delays are controlled via an HTTP header (if applicable).
  public var headerDelay: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay {
    get {
      if case .headerDelay(let v)? = faultDelaySecifier {return v}
      return Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay()
    }
    set {faultDelaySecifier = .headerDelay(newValue)}
  }

  /// The percentage of operations/connections/requests on which the delay will be injected.
  public var percentage: Envoy_Type_V3_FractionalPercent {
    get {return _percentage ?? Envoy_Type_V3_FractionalPercent()}
    set {_percentage = newValue}
  }
  /// Returns true if `percentage` has been explicitly set.
  public var hasPercentage: Bool {return self._percentage != nil}
  /// Clears the value of `percentage`. Subsequent reads from it will return its default value.
  public mutating func clearPercentage() {self._percentage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_FaultDelaySecifier: Equatable {
    /// Add a fixed delay before forwarding the operation upstream. See
    /// https://developers.google.com/protocol-buffers/docs/proto3#json for
    /// the JSON/YAML Duration mapping. For HTTP/Mongo/Redis, the specified
    /// delay will be injected before a new request/operation. For TCP
    /// connections, the proxying of the connection upstream will be delayed
    /// for the specified period. This is required if type is FIXED.
    case fixedDelay(SwiftProtobuf.Google_Protobuf_Duration)
    /// Fault delays are controlled via an HTTP header (if applicable).
    case headerDelay(Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.OneOf_FaultDelaySecifier, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.OneOf_FaultDelaySecifier) -> Bool {
      switch (lhs, rhs) {
      case (.fixedDelay(let l), .fixedDelay(let r)): return l == r
      case (.headerDelay(let l), .headerDelay(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum FaultDelayType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unused and deprecated.
    case fixed // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .fixed
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .fixed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .fixed: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Fault delays are controlled via an HTTP header (if applicable). See the
  /// :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  /// more information.
  public struct HeaderDelay {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _percentage: Envoy_Type_V3_FractionalPercent? = nil
}

#if swift(>=4.2)

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.FaultDelayType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.FaultDelayType] = [
    .fixed,
  ]
}

#endif  // swift(>=4.2)

/// Describes a rate limit to be applied.
public struct Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var limitType: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.OneOf_LimitType? = nil

  /// A fixed rate limit.
  public var fixedLimit: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit {
    get {
      if case .fixedLimit(let v)? = limitType {return v}
      return Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit()
    }
    set {limitType = .fixedLimit(newValue)}
  }

  /// Rate limits are controlled via an HTTP header (if applicable).
  public var headerLimit: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit {
    get {
      if case .headerLimit(let v)? = limitType {return v}
      return Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit()
    }
    set {limitType = .headerLimit(newValue)}
  }

  /// The percentage of operations/connections/requests on which the rate limit will be injected.
  public var percentage: Envoy_Type_V3_FractionalPercent {
    get {return _percentage ?? Envoy_Type_V3_FractionalPercent()}
    set {_percentage = newValue}
  }
  /// Returns true if `percentage` has been explicitly set.
  public var hasPercentage: Bool {return self._percentage != nil}
  /// Clears the value of `percentage`. Subsequent reads from it will return its default value.
  public mutating func clearPercentage() {self._percentage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_LimitType: Equatable {
    /// A fixed rate limit.
    case fixedLimit(Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit)
    /// Rate limits are controlled via an HTTP header (if applicable).
    case headerLimit(Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.OneOf_LimitType, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.OneOf_LimitType) -> Bool {
      switch (lhs, rhs) {
      case (.fixedLimit(let l), .fixedLimit(let r)): return l == r
      case (.headerLimit(let l), .headerLimit(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Describes a fixed/constant rate limit.
  public struct FixedLimit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The limit supplied in KiB/s.
    public var limitKbps: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Rate limits are controlled via an HTTP header (if applicable). See the
  /// :ref:`HTTP fault filter <config_http_filters_fault_injection_http_header>` documentation for
  /// more information.
  public struct HeaderLimit {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _percentage: Envoy_Type_V3_FractionalPercent? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.common.fault.v3"

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaultDelay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "fixed_delay"),
    5: .standard(proto: "header_delay"),
    4: .same(proto: "percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3:
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.faultDelaySecifier {
          try decoder.handleConflictingOneOf()
          if case .fixedDelay(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.faultDelaySecifier = .fixedDelay(v)}
      case 4: try decoder.decodeSingularMessageField(value: &self._percentage)
      case 5:
        var v: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay?
        if let current = self.faultDelaySecifier {
          try decoder.handleConflictingOneOf()
          if case .headerDelay(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.faultDelaySecifier = .headerDelay(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .fixedDelay(let v)? = self.faultDelaySecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._percentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if case .headerDelay(let v)? = self.faultDelaySecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay) -> Bool {
    if lhs.faultDelaySecifier != rhs.faultDelaySecifier {return false}
    if lhs._percentage != rhs._percentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.FaultDelayType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FIXED"),
  ]
}

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.protoMessageName + ".HeaderDelay"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultDelay.HeaderDelay) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FaultRateLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fixed_limit"),
    3: .standard(proto: "header_limit"),
    2: .same(proto: "percentage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit?
        if let current = self.limitType {
          try decoder.handleConflictingOneOf()
          if case .fixedLimit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.limitType = .fixedLimit(v)}
      case 2: try decoder.decodeSingularMessageField(value: &self._percentage)
      case 3:
        var v: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit?
        if let current = self.limitType {
          try decoder.handleConflictingOneOf()
          if case .headerLimit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.limitType = .headerLimit(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .fixedLimit(let v)? = self.limitType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._percentage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if case .headerLimit(let v)? = self.limitType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit) -> Bool {
    if lhs.limitType != rhs.limitType {return false}
    if lhs._percentage != rhs._percentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.protoMessageName + ".FixedLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "limit_kbps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.limitKbps)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.limitKbps != 0 {
      try visitor.visitSingularUInt64Field(value: self.limitKbps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.FixedLimit) -> Bool {
    if lhs.limitKbps != rhs.limitKbps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.protoMessageName + ".HeaderLimit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit, rhs: Envoy_Extensions_Filters_Common_Fault_V3_FaultRateLimit.HeaderLimit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

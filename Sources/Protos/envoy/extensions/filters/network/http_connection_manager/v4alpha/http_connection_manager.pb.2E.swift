// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/network/http_connection_manager/v4alpha/http_connection_manager.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 40]
public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supplies the type of codec that the connection manager should use.
  public var codecType: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.CodecType {
    get {return _storage._codecType}
    set {_uniqueStorage()._codecType = newValue}
  }

  /// The human readable prefix to use when emitting statistics for the
  /// connection manager. See the :ref:`statistics documentation <config_http_conn_man_stats>` for
  /// more information.
  public var statPrefix: String {
    get {return _storage._statPrefix}
    set {_uniqueStorage()._statPrefix = newValue}
  }

  public var routeSpecifier: OneOf_RouteSpecifier? {
    get {return _storage._routeSpecifier}
    set {_uniqueStorage()._routeSpecifier = newValue}
  }

  /// The connection manager’s route table will be dynamically loaded via the RDS API.
  public var rds: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds {
    get {
      if case .rds(let v)? = _storage._routeSpecifier {return v}
      return Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds()
    }
    set {_uniqueStorage()._routeSpecifier = .rds(newValue)}
  }

  /// The route table for the connection manager is static and is specified in this property.
  public var routeConfig: Envoy_Config_Route_V4alpha_RouteConfiguration {
    get {
      if case .routeConfig(let v)? = _storage._routeSpecifier {return v}
      return Envoy_Config_Route_V4alpha_RouteConfiguration()
    }
    set {_uniqueStorage()._routeSpecifier = .routeConfig(newValue)}
  }

  /// A route table will be dynamically assigned to each request based on request attributes
  /// (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
  /// specified in this message.
  public var scopedRoutes: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes {
    get {
      if case .scopedRoutes(let v)? = _storage._routeSpecifier {return v}
      return Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes()
    }
    set {_uniqueStorage()._routeSpecifier = .scopedRoutes(newValue)}
  }

  /// A list of individual HTTP filters that make up the filter chain for
  /// requests made to the connection manager. :ref:`Order matters <arch_overview_http_filters_ordering>`
  /// as the filters are processed sequentially as request events happen.
  public var httpFilters: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter] {
    get {return _storage._httpFilters}
    set {_uniqueStorage()._httpFilters = newValue}
  }

  /// Whether the connection manager manipulates the :ref:`config_http_conn_man_headers_user-agent`
  /// and :ref:`config_http_conn_man_headers_downstream-service-cluster` headers. See the linked
  /// documentation for more information. Defaults to false.
  public var addUserAgent: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._addUserAgent ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._addUserAgent = newValue}
  }
  /// Returns true if `addUserAgent` has been explicitly set.
  public var hasAddUserAgent: Bool {return _storage._addUserAgent != nil}
  /// Clears the value of `addUserAgent`. Subsequent reads from it will return its default value.
  public mutating func clearAddUserAgent() {_uniqueStorage()._addUserAgent = nil}

  /// Presence of the object defines whether the connection manager
  /// emits :ref:`tracing <arch_overview_tracing>` data to the :ref:`configured tracing provider
  /// <envoy_api_msg_config.trace.v4alpha.Tracing>`.
  public var tracing: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing {
    get {return _storage._tracing ?? Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing()}
    set {_uniqueStorage()._tracing = newValue}
  }
  /// Returns true if `tracing` has been explicitly set.
  public var hasTracing: Bool {return _storage._tracing != nil}
  /// Clears the value of `tracing`. Subsequent reads from it will return its default value.
  public mutating func clearTracing() {_uniqueStorage()._tracing = nil}

  /// Additional settings for HTTP requests handled by the connection manager. These will be
  /// applicable to both HTTP1 and HTTP2 requests.
  public var commonHTTPProtocolOptions: Envoy_Config_Core_V4alpha_HttpProtocolOptions {
    get {return _storage._commonHTTPProtocolOptions ?? Envoy_Config_Core_V4alpha_HttpProtocolOptions()}
    set {_uniqueStorage()._commonHTTPProtocolOptions = newValue}
  }
  /// Returns true if `commonHTTPProtocolOptions` has been explicitly set.
  public var hasCommonHTTPProtocolOptions: Bool {return _storage._commonHTTPProtocolOptions != nil}
  /// Clears the value of `commonHTTPProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearCommonHTTPProtocolOptions() {_uniqueStorage()._commonHTTPProtocolOptions = nil}

  /// Additional HTTP/1 settings that are passed to the HTTP/1 codec.
  public var httpProtocolOptions: Envoy_Config_Core_V4alpha_Http1ProtocolOptions {
    get {return _storage._httpProtocolOptions ?? Envoy_Config_Core_V4alpha_Http1ProtocolOptions()}
    set {_uniqueStorage()._httpProtocolOptions = newValue}
  }
  /// Returns true if `httpProtocolOptions` has been explicitly set.
  public var hasHTTPProtocolOptions: Bool {return _storage._httpProtocolOptions != nil}
  /// Clears the value of `httpProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPProtocolOptions() {_uniqueStorage()._httpProtocolOptions = nil}

  /// Additional HTTP/2 settings that are passed directly to the HTTP/2 codec.
  public var http2ProtocolOptions: Envoy_Config_Core_V4alpha_Http2ProtocolOptions {
    get {return _storage._http2ProtocolOptions ?? Envoy_Config_Core_V4alpha_Http2ProtocolOptions()}
    set {_uniqueStorage()._http2ProtocolOptions = newValue}
  }
  /// Returns true if `http2ProtocolOptions` has been explicitly set.
  public var hasHTTP2ProtocolOptions: Bool {return _storage._http2ProtocolOptions != nil}
  /// Clears the value of `http2ProtocolOptions`. Subsequent reads from it will return its default value.
  public mutating func clearHTTP2ProtocolOptions() {_uniqueStorage()._http2ProtocolOptions = nil}

  /// An optional override that the connection manager will write to the server
  /// header in responses. If not set, the default is *envoy*.
  public var serverName: String {
    get {return _storage._serverName}
    set {_uniqueStorage()._serverName = newValue}
  }

  /// Defines the action to be applied to the Server header on the response path.
  /// By default, Envoy will overwrite the header with the value specified in
  /// server_name.
  public var serverHeaderTransformation: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ServerHeaderTransformation {
    get {return _storage._serverHeaderTransformation}
    set {_uniqueStorage()._serverHeaderTransformation = newValue}
  }

  /// The maximum request headers size for incoming connections.
  /// If unconfigured, the default max request headers allowed is 60 KiB.
  /// Requests that exceed this limit will receive a 431 response.
  /// The max configurable limit is 96 KiB, based on current implementation
  /// constraints.
  public var maxRequestHeadersKb: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _storage._maxRequestHeadersKb ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_uniqueStorage()._maxRequestHeadersKb = newValue}
  }
  /// Returns true if `maxRequestHeadersKb` has been explicitly set.
  public var hasMaxRequestHeadersKb: Bool {return _storage._maxRequestHeadersKb != nil}
  /// Clears the value of `maxRequestHeadersKb`. Subsequent reads from it will return its default value.
  public mutating func clearMaxRequestHeadersKb() {_uniqueStorage()._maxRequestHeadersKb = nil}

  /// The stream idle timeout for connections managed by the connection manager.
  /// If not specified, this defaults to 5 minutes. The default value was selected
  /// so as not to interfere with any smaller configured timeouts that may have
  /// existed in configurations prior to the introduction of this feature, while
  /// introducing robustness to TCP connections that terminate without a FIN.
  ///
  /// This idle timeout applies to new streams and is overridable by the
  /// :ref:`route-level idle_timeout
  /// <envoy_api_field_config.route.v4alpha.RouteAction.idle_timeout>`. Even on a stream in
  /// which the override applies, prior to receipt of the initial request
  /// headers, the :ref:`stream_idle_timeout
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.stream_idle_timeout>`
  /// applies. Each time an encode/decode event for headers or data is processed
  /// for the stream, the timer will be reset. If the timeout fires, the stream
  /// is terminated with a 408 Request Timeout error code if no upstream response
  /// header has been received, otherwise a stream reset occurs.
  ///
  /// Note that it is possible to idle timeout even if the wire traffic for a stream is non-idle, due
  /// to the granularity of events presented to the connection manager. For example, while receiving
  /// very large request headers, it may be the case that there is traffic regularly arriving on the
  /// wire while the connection manage is only able to observe the end-of-headers event, hence the
  /// stream may still idle timeout.
  ///
  /// A value of 0 will completely disable the connection manager stream idle
  /// timeout, although per-route idle timeout overrides will continue to apply.
  public var streamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._streamIdleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._streamIdleTimeout = newValue}
  }
  /// Returns true if `streamIdleTimeout` has been explicitly set.
  public var hasStreamIdleTimeout: Bool {return _storage._streamIdleTimeout != nil}
  /// Clears the value of `streamIdleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearStreamIdleTimeout() {_uniqueStorage()._streamIdleTimeout = nil}

  /// The amount of time that Envoy will wait for the entire request to be received.
  /// The timer is activated when the request is initiated, and is disarmed when the last byte of the
  /// request is sent upstream (i.e. all decoding filters have processed the request), OR when the
  /// response is initiated. If not specified or set to 0, this timeout is disabled.
  public var requestTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._requestTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._requestTimeout = newValue}
  }
  /// Returns true if `requestTimeout` has been explicitly set.
  public var hasRequestTimeout: Bool {return _storage._requestTimeout != nil}
  /// Clears the value of `requestTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearRequestTimeout() {_uniqueStorage()._requestTimeout = nil}

  /// The time that Envoy will wait between sending an HTTP/2 “shutdown
  /// notification” (GOAWAY frame with max stream ID) and a final GOAWAY frame.
  /// This is used so that Envoy provides a grace period for new streams that
  /// race with the final GOAWAY frame. During this grace period, Envoy will
  /// continue to accept new streams. After the grace period, a final GOAWAY
  /// frame is sent and Envoy will start refusing new streams. Draining occurs
  /// both when a connection hits the idle timeout or during general server
  /// draining. The default grace period is 5000 milliseconds (5 seconds) if this
  /// option is not specified.
  public var drainTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._drainTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._drainTimeout = newValue}
  }
  /// Returns true if `drainTimeout` has been explicitly set.
  public var hasDrainTimeout: Bool {return _storage._drainTimeout != nil}
  /// Clears the value of `drainTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearDrainTimeout() {_uniqueStorage()._drainTimeout = nil}

  /// The delayed close timeout is for downstream connections managed by the HTTP connection manager.
  /// It is defined as a grace period after connection close processing has been locally initiated
  /// during which Envoy will wait for the peer to close (i.e., a TCP FIN/RST is received by Envoy
  /// from the downstream connection) prior to Envoy closing the socket associated with that
  /// connection.
  /// NOTE: This timeout is enforced even when the socket associated with the downstream connection
  /// is pending a flush of the write buffer. However, any progress made writing data to the socket
  /// will restart the timer associated with this timeout. This means that the total grace period for
  /// a socket in this state will be
  /// <total_time_waiting_for_write_buffer_flushes>+<delayed_close_timeout>.
  ///
  /// Delaying Envoy's connection close and giving the peer the opportunity to initiate the close
  /// sequence mitigates a race condition that exists when downstream clients do not drain/process
  /// data in a connection's receive buffer after a remote close has been detected via a socket
  /// write(). This race leads to such clients failing to process the response code sent by Envoy,
  /// which could result in erroneous downstream processing.
  ///
  /// If the timeout triggers, Envoy will close the connection's socket.
  ///
  /// The default timeout is 1000 ms if this option is not specified.
  ///
  /// .. NOTE::
  ///    To be useful in avoiding the race condition described above, this timeout must be set
  ///    to *at least* <max round trip time expected between clients and Envoy>+<100ms to account for
  ///    a reasonable "worst" case processing time for a full iteration of Envoy's event loop>.
  ///
  /// .. WARNING::
  ///    A value of 0 will completely disable delayed close processing. When disabled, the downstream
  ///    connection's socket will be closed immediately after the write flush is completed or will
  ///    never close if the write flush does not complete.
  public var delayedCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._delayedCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._delayedCloseTimeout = newValue}
  }
  /// Returns true if `delayedCloseTimeout` has been explicitly set.
  public var hasDelayedCloseTimeout: Bool {return _storage._delayedCloseTimeout != nil}
  /// Clears the value of `delayedCloseTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearDelayedCloseTimeout() {_uniqueStorage()._delayedCloseTimeout = nil}

  /// Configuration for :ref:`HTTP access logs <arch_overview_access_logs>`
  /// emitted by the connection manager.
  public var accessLog: [Envoy_Config_Accesslog_V4alpha_AccessLog] {
    get {return _storage._accessLog}
    set {_uniqueStorage()._accessLog = newValue}
  }

  /// If set to true, the connection manager will use the real remote address
  /// of the client connection when determining internal versus external origin and manipulating
  /// various headers. If set to false or absent, the connection manager will use the
  /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. See the documentation for
  /// :ref:`config_http_conn_man_headers_x-forwarded-for`,
  /// :ref:`config_http_conn_man_headers_x-envoy-internal`, and
  /// :ref:`config_http_conn_man_headers_x-envoy-external-address` for more information.
  public var useRemoteAddress: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._useRemoteAddress ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._useRemoteAddress = newValue}
  }
  /// Returns true if `useRemoteAddress` has been explicitly set.
  public var hasUseRemoteAddress: Bool {return _storage._useRemoteAddress != nil}
  /// Clears the value of `useRemoteAddress`. Subsequent reads from it will return its default value.
  public mutating func clearUseRemoteAddress() {_uniqueStorage()._useRemoteAddress = nil}

  /// The number of additional ingress proxy hops from the right side of the
  /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header to trust when
  /// determining the origin client's IP address. The default is zero if this option
  /// is not specified. See the documentation for
  /// :ref:`config_http_conn_man_headers_x-forwarded-for` for more information.
  public var xffNumTrustedHops: UInt32 {
    get {return _storage._xffNumTrustedHops}
    set {_uniqueStorage()._xffNumTrustedHops = newValue}
  }

  /// Configures what network addresses are considered internal for stats and header sanitation
  /// purposes. If unspecified, only RFC1918 IP addresses will be considered internal.
  /// See the documentation for :ref:`config_http_conn_man_headers_x-envoy-internal` for more
  /// information about internal/external addresses.
  public var internalAddressConfig: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.InternalAddressConfig {
    get {return _storage._internalAddressConfig ?? Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.InternalAddressConfig()}
    set {_uniqueStorage()._internalAddressConfig = newValue}
  }
  /// Returns true if `internalAddressConfig` has been explicitly set.
  public var hasInternalAddressConfig: Bool {return _storage._internalAddressConfig != nil}
  /// Clears the value of `internalAddressConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInternalAddressConfig() {_uniqueStorage()._internalAddressConfig = nil}

  /// If set, Envoy will not append the remote address to the
  /// :ref:`config_http_conn_man_headers_x-forwarded-for` HTTP header. This may be used in
  /// conjunction with HTTP filters that explicitly manipulate XFF after the HTTP connection manager
  /// has mutated the request headers. While :ref:`use_remote_address
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.use_remote_address>`
  /// will also suppress XFF addition, it has consequences for logging and other
  /// Envoy uses of the remote address, so *skip_xff_append* should be used
  /// when only an elision of XFF addition is intended.
  public var skipXffAppend: Bool {
    get {return _storage._skipXffAppend}
    set {_uniqueStorage()._skipXffAppend = newValue}
  }

  /// Via header value to append to request and response headers. If this is
  /// empty, no via header will be appended.
  public var via: String {
    get {return _storage._via}
    set {_uniqueStorage()._via = newValue}
  }

  /// Whether the connection manager will generate the :ref:`x-request-id
  /// <config_http_conn_man_headers_x-request-id>` header if it does not exist. This defaults to
  /// true. Generating a random UUID4 is expensive so in high throughput scenarios where this feature
  /// is not desired it can be disabled.
  public var generateRequestID: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._generateRequestID ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._generateRequestID = newValue}
  }
  /// Returns true if `generateRequestID` has been explicitly set.
  public var hasGenerateRequestID: Bool {return _storage._generateRequestID != nil}
  /// Clears the value of `generateRequestID`. Subsequent reads from it will return its default value.
  public mutating func clearGenerateRequestID() {_uniqueStorage()._generateRequestID = nil}

  /// Whether the connection manager will keep the :ref:`x-request-id
  /// <config_http_conn_man_headers_x-request-id>` header if passed for a request that is edge
  /// (Edge request is the request from external clients to front Envoy) and not reset it, which
  /// is the current Envoy behaviour. This defaults to false.
  public var preserveExternalRequestID: Bool {
    get {return _storage._preserveExternalRequestID}
    set {_uniqueStorage()._preserveExternalRequestID = newValue}
  }

  /// If set, Envoy will always set :ref:`x-request-id <config_http_conn_man_headers_x-request-id>` header in response.
  /// If this is false or not set, the request ID is returned in responses only if tracing is forced using
  /// :ref:`x-envoy-force-trace <config_http_conn_man_headers_x-envoy-force-trace>` header.
  public var alwaysSetRequestIDInResponse: Bool {
    get {return _storage._alwaysSetRequestIDInResponse}
    set {_uniqueStorage()._alwaysSetRequestIDInResponse = newValue}
  }

  /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
  /// header.
  public var forwardClientCertDetails: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ForwardClientCertDetails {
    get {return _storage._forwardClientCertDetails}
    set {_uniqueStorage()._forwardClientCertDetails = newValue}
  }

  /// This field is valid only when :ref:`forward_client_cert_details
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.forward_client_cert_details>`
  /// is APPEND_FORWARD or SANITIZE_SET and the client connection is mTLS. It specifies the fields in
  /// the client certificate to be forwarded. Note that in the
  /// :ref:`config_http_conn_man_headers_x-forwarded-client-cert` header, *Hash* is always set, and
  /// *By* is always set when the client certificate presents the URI type Subject Alternative Name
  /// value.
  public var setCurrentClientCertDetails: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.SetCurrentClientCertDetails {
    get {return _storage._setCurrentClientCertDetails ?? Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.SetCurrentClientCertDetails()}
    set {_uniqueStorage()._setCurrentClientCertDetails = newValue}
  }
  /// Returns true if `setCurrentClientCertDetails` has been explicitly set.
  public var hasSetCurrentClientCertDetails: Bool {return _storage._setCurrentClientCertDetails != nil}
  /// Clears the value of `setCurrentClientCertDetails`. Subsequent reads from it will return its default value.
  public mutating func clearSetCurrentClientCertDetails() {_uniqueStorage()._setCurrentClientCertDetails = nil}

  /// If proxy_100_continue is true, Envoy will proxy incoming "Expect:
  /// 100-continue" headers upstream, and forward "100 Continue" responses
  /// downstream. If this is false or not set, Envoy will instead strip the
  /// "Expect: 100-continue" header, and send a "100 Continue" response itself.
  public var proxy100Continue: Bool {
    get {return _storage._proxy100Continue}
    set {_uniqueStorage()._proxy100Continue = newValue}
  }

  /// If
  /// :ref:`use_remote_address
  /// <envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.HttpConnectionManager.use_remote_address>`
  /// is true and represent_ipv4_remote_address_as_ipv4_mapped_ipv6 is true and the remote address is
  /// an IPv4 address, the address will be mapped to IPv6 before it is appended to *x-forwarded-for*.
  /// This is useful for testing compatibility of upstream services that parse the header value. For
  /// example, 50.0.0.1 is represented as ::FFFF:50.0.0.1. See `IPv4-Mapped IPv6 Addresses
  /// <https://tools.ietf.org/html/rfc4291#section-2.5.5.2>`_ for details. This will also affect the
  /// :ref:`config_http_conn_man_headers_x-envoy-external-address` header. See
  /// :ref:`http_connection_manager.represent_ipv4_remote_address_as_ipv4_mapped_ipv6
  /// <config_http_conn_man_runtime_represent_ipv4_remote_address_as_ipv4_mapped_ipv6>` for runtime
  /// control.
  /// [#not-implemented-hide:]
  public var representIpv4RemoteAddressAsIpv4MappedIpv6: Bool {
    get {return _storage._representIpv4RemoteAddressAsIpv4MappedIpv6}
    set {_uniqueStorage()._representIpv4RemoteAddressAsIpv4MappedIpv6 = newValue}
  }

  public var upgradeConfigs: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.UpgradeConfig] {
    get {return _storage._upgradeConfigs}
    set {_uniqueStorage()._upgradeConfigs = newValue}
  }

  /// Should paths be normalized according to RFC 3986 before any processing of
  /// requests by HTTP filters or routing? This affects the upstream *:path* header
  /// as well. For paths that fail this check, Envoy will respond with 400 to
  /// paths that are malformed. This defaults to false currently but will default
  /// true in the future. When not specified, this value may be overridden by the
  /// runtime variable
  /// :ref:`http_connection_manager.normalize_path<config_http_conn_man_runtime_normalize_path>`.
  /// See `Normalization and Comparison <https://tools.ietf.org/html/rfc3986#section-6>`
  /// for details of normalization.
  /// Note that Envoy does not perform
  /// `case normalization <https://tools.ietf.org/html/rfc3986#section-6.2.2.1>`
  public var normalizePath: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._normalizePath ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._normalizePath = newValue}
  }
  /// Returns true if `normalizePath` has been explicitly set.
  public var hasNormalizePath: Bool {return _storage._normalizePath != nil}
  /// Clears the value of `normalizePath`. Subsequent reads from it will return its default value.
  public mutating func clearNormalizePath() {_uniqueStorage()._normalizePath = nil}

  /// Determines if adjacent slashes in the path are merged into one before any processing of
  /// requests by HTTP filters or routing. This affects the upstream *:path* header as well. Without
  /// setting this option, incoming requests with path `//dir///file` will not match against route
  /// with `prefix` match set to `/dir`. Defaults to `false`. Note that slash merging is not part of
  /// `HTTP spec <https://tools.ietf.org/html/rfc3986>` and is provided for convenience.
  public var mergeSlashes: Bool {
    get {return _storage._mergeSlashes}
    set {_uniqueStorage()._mergeSlashes = newValue}
  }

  /// The configuration of the request ID extension. This includes operations such as
  /// generation, validation, and associated tracing operations.
  ///
  /// If not set, Envoy uses the default UUID-based behavior:
  ///
  /// 1. Request ID is propagated using *x-request-id* header.
  ///
  /// 2. Request ID is a universally unique identifier (UUID).
  ///
  /// 3. Tracing decision (sampled, forced, etc) is set in 14th byte of the UUID.
  public var requestIDExtension: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension {
    get {return _storage._requestIDExtension ?? Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension()}
    set {_uniqueStorage()._requestIDExtension = newValue}
  }
  /// Returns true if `requestIDExtension` has been explicitly set.
  public var hasRequestIDExtension: Bool {return _storage._requestIDExtension != nil}
  /// Clears the value of `requestIDExtension`. Subsequent reads from it will return its default value.
  public mutating func clearRequestIDExtension() {_uniqueStorage()._requestIDExtension = nil}

  /// Determines if the port part should be removed from host/authority header before any processing
  /// of request by HTTP filters or routing. The port would be removed only if it is equal to the :ref:`listener's<envoy_api_field_config.listener.v4alpha.Listener.address>`
  /// local port and request method is not CONNECT. This affects the upstream host header as well.
  /// Without setting this option, incoming requests with host `example:443` will not match against
  /// route with :ref:`domains<envoy_api_field_config.route.v4alpha.VirtualHost.domains>` match set to `example`. Defaults to `false`. Note that port removal is not part
  /// of `HTTP spec <https://tools.ietf.org/html/rfc3986>` and is provided for convenience.
  public var stripMatchingHostPort: Bool {
    get {return _storage._stripMatchingHostPort}
    set {_uniqueStorage()._stripMatchingHostPort = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RouteSpecifier: Equatable {
    /// The connection manager’s route table will be dynamically loaded via the RDS API.
    case rds(Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds)
    /// The route table for the connection manager is static and is specified in this property.
    case routeConfig(Envoy_Config_Route_V4alpha_RouteConfiguration)
    /// A route table will be dynamically assigned to each request based on request attributes
    /// (e.g., the value of a header). The "routing scopes" (i.e., route tables) and "scope keys" are
    /// specified in this message.
    case scopedRoutes(Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.OneOf_RouteSpecifier, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.OneOf_RouteSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.rds(let l), .rds(let r)): return l == r
      case (.routeConfig(let l), .routeConfig(let r)): return l == r
      case (.scopedRoutes(let l), .scopedRoutes(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public enum CodecType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// For every new connection, the connection manager will determine which
    /// codec to use. This mode supports both ALPN for TLS listeners as well as
    /// protocol inference for plaintext listeners. If ALPN data is available, it
    /// is preferred, otherwise protocol inference is used. In almost all cases,
    /// this is the right option to choose for this setting.
    case auto // = 0

    /// The connection manager will assume that the client is speaking HTTP/1.1.
    case http1 // = 1

    /// The connection manager will assume that the client is speaking HTTP/2
    /// (Envoy does not require HTTP/2 to take place over TLS or to use ALPN.
    /// Prior knowledge is allowed).
    case http2 // = 2

    /// [#not-implemented-hide:] QUIC implementation is not production ready yet. Use this enum with
    /// caution to prevent accidental execution of QUIC code. I.e. `!= HTTP2` is no longer sufficient
    /// to distinguish HTTP1 and HTTP2 traffic.
    case http3 // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .auto
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .auto
      case 1: self = .http1
      case 2: self = .http2
      case 3: self = .http3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .auto: return 0
      case .http1: return 1
      case .http2: return 2
      case .http3: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public enum ServerHeaderTransformation: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Overwrite any Server header with the contents of server_name.
    case overwrite // = 0

    /// If no Server header is present, append Server server_name
    /// If a Server header is present, pass it through.
    case appendIfAbsent // = 1

    /// Pass through the value of the server header, and do not append a header
    /// if none is present.
    case passThrough // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .overwrite
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .overwrite
      case 1: self = .appendIfAbsent
      case 2: self = .passThrough
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .overwrite: return 0
      case .appendIfAbsent: return 1
      case .passThrough: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// How to handle the :ref:`config_http_conn_man_headers_x-forwarded-client-cert` (XFCC) HTTP
  /// header.
  public enum ForwardClientCertDetails: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not send the XFCC header to the next hop. This is the default value.
    case sanitize // = 0

    /// When the client connection is mTLS (Mutual TLS), forward the XFCC header
    /// in the request.
    case forwardOnly // = 1

    /// When the client connection is mTLS, append the client certificate
    /// information to the request’s XFCC header and forward it.
    case appendForward // = 2

    /// When the client connection is mTLS, reset the XFCC header with the client
    /// certificate information and send it to the next hop.
    case sanitizeSet // = 3

    /// Always forward the XFCC header in the request, regardless of whether the
    /// client connection is mTLS.
    case alwaysForwardOnly // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .sanitize
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sanitize
      case 1: self = .forwardOnly
      case 2: self = .appendForward
      case 3: self = .sanitizeSet
      case 4: self = .alwaysForwardOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sanitize: return 0
      case .forwardOnly: return 1
      case .appendForward: return 2
      case .sanitizeSet: return 3
      case .alwaysForwardOnly: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// [#next-free-field: 10]
  public struct Tracing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Target percentage of requests managed by this HTTP connection manager that will be force
    /// traced if the :ref:`x-client-trace-id <config_http_conn_man_headers_x-client-trace-id>`
    /// header is set. This field is a direct analog for the runtime variable
    /// 'tracing.client_sampling' in the :ref:`HTTP Connection Manager
    /// <config_http_conn_man_runtime>`.
    /// Default: 100%
    public var clientSampling: Envoy_Type_V3_Percent {
      get {return _clientSampling ?? Envoy_Type_V3_Percent()}
      set {_clientSampling = newValue}
    }
    /// Returns true if `clientSampling` has been explicitly set.
    public var hasClientSampling: Bool {return self._clientSampling != nil}
    /// Clears the value of `clientSampling`. Subsequent reads from it will return its default value.
    public mutating func clearClientSampling() {self._clientSampling = nil}

    /// Target percentage of requests managed by this HTTP connection manager that will be randomly
    /// selected for trace generation, if not requested by the client or not forced. This field is
    /// a direct analog for the runtime variable 'tracing.random_sampling' in the
    /// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
    /// Default: 100%
    public var randomSampling: Envoy_Type_V3_Percent {
      get {return _randomSampling ?? Envoy_Type_V3_Percent()}
      set {_randomSampling = newValue}
    }
    /// Returns true if `randomSampling` has been explicitly set.
    public var hasRandomSampling: Bool {return self._randomSampling != nil}
    /// Clears the value of `randomSampling`. Subsequent reads from it will return its default value.
    public mutating func clearRandomSampling() {self._randomSampling = nil}

    /// Target percentage of requests managed by this HTTP connection manager that will be traced
    /// after all other sampling checks have been applied (client-directed, force tracing, random
    /// sampling). This field functions as an upper limit on the total configured sampling rate. For
    /// instance, setting client_sampling to 100% but overall_sampling to 1% will result in only 1%
    /// of client requests with the appropriate headers to be force traced. This field is a direct
    /// analog for the runtime variable 'tracing.global_enabled' in the
    /// :ref:`HTTP Connection Manager <config_http_conn_man_runtime>`.
    /// Default: 100%
    public var overallSampling: Envoy_Type_V3_Percent {
      get {return _overallSampling ?? Envoy_Type_V3_Percent()}
      set {_overallSampling = newValue}
    }
    /// Returns true if `overallSampling` has been explicitly set.
    public var hasOverallSampling: Bool {return self._overallSampling != nil}
    /// Clears the value of `overallSampling`. Subsequent reads from it will return its default value.
    public mutating func clearOverallSampling() {self._overallSampling = nil}

    /// Whether to annotate spans with additional data. If true, spans will include logs for stream
    /// events.
    public var verbose: Bool = false

    /// Maximum length of the request path to extract and include in the HttpUrl tag. Used to
    /// truncate lengthy request paths to meet the needs of a tracing backend.
    /// Default: 256
    public var maxPathTagLength: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _maxPathTagLength ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_maxPathTagLength = newValue}
    }
    /// Returns true if `maxPathTagLength` has been explicitly set.
    public var hasMaxPathTagLength: Bool {return self._maxPathTagLength != nil}
    /// Clears the value of `maxPathTagLength`. Subsequent reads from it will return its default value.
    public mutating func clearMaxPathTagLength() {self._maxPathTagLength = nil}

    /// A list of custom tags with unique tag name to create tags for the active span.
    public var customTags: [Envoy_Type_Tracing_V3_CustomTag] = []

    /// Configuration for an external tracing provider.
    /// If not specified, no tracing will be performed.
    ///
    /// .. attention::
    ///   Please be aware that *envoy.tracers.opencensus* provider can only be configured once
    ///   in Envoy lifetime.
    ///   Any attempts to reconfigure it or to use different configurations for different HCM filters
    ///   will be rejected.
    ///   Such a constraint is inherent to OpenCensus itself. It cannot be overcome without changes
    ///   on OpenCensus side.
    public var provider: Envoy_Config_Trace_V4alpha_Tracing.Http {
      get {return _provider ?? Envoy_Config_Trace_V4alpha_Tracing.Http()}
      set {_provider = newValue}
    }
    /// Returns true if `provider` has been explicitly set.
    public var hasProvider: Bool {return self._provider != nil}
    /// Clears the value of `provider`. Subsequent reads from it will return its default value.
    public mutating func clearProvider() {self._provider = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OperationName: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The HTTP listener is used for ingress/incoming requests.
      case ingress // = 0

      /// The HTTP listener is used for egress/outgoing requests.
      case egress // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .ingress
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .ingress
        case 1: self = .egress
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .ingress: return 0
        case .egress: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _clientSampling: Envoy_Type_V3_Percent? = nil
    fileprivate var _randomSampling: Envoy_Type_V3_Percent? = nil
    fileprivate var _overallSampling: Envoy_Type_V3_Percent? = nil
    fileprivate var _maxPathTagLength: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _provider: Envoy_Config_Trace_V4alpha_Tracing.Http? = nil
  }

  public struct InternalAddressConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether unix socket addresses should be considered internal.
    public var unixSockets: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// [#next-free-field: 7]
  public struct SetCurrentClientCertDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether to forward the subject of the client cert. Defaults to false.
    public var subject: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _subject ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_subject = newValue}
    }
    /// Returns true if `subject` has been explicitly set.
    public var hasSubject: Bool {return self._subject != nil}
    /// Clears the value of `subject`. Subsequent reads from it will return its default value.
    public mutating func clearSubject() {self._subject = nil}

    /// Whether to forward the entire client cert in URL encoded PEM format. This will appear in the
    /// XFCC header comma separated from other values with the value Cert="PEM".
    /// Defaults to false.
    public var cert: Bool = false

    /// Whether to forward the entire client cert chain (including the leaf cert) in URL encoded PEM
    /// format. This will appear in the XFCC header comma separated from other values with the value
    /// Chain="PEM".
    /// Defaults to false.
    public var chain: Bool = false

    /// Whether to forward the DNS type Subject Alternative Names of the client cert.
    /// Defaults to false.
    public var dns: Bool = false

    /// Whether to forward the URI type Subject Alternative Name of the client cert. Defaults to
    /// false.
    public var uri: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _subject: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  /// The configuration for HTTP upgrades.
  /// For each upgrade type desired, an UpgradeConfig must be added.
  ///
  /// .. warning::
  ///
  ///    The current implementation of upgrade headers does not handle
  ///    multi-valued upgrade headers. Support for multi-valued headers may be
  ///    added in the future if needed.
  ///
  /// .. warning::
  ///    The current implementation of upgrade headers does not work with HTTP/2
  ///    upstreams.
  public struct UpgradeConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The case-insensitive name of this upgrade, e.g. "websocket".
    /// For each upgrade type present in upgrade_configs, requests with
    /// Upgrade: [upgrade_type]
    /// will be proxied upstream.
    public var upgradeType: String = String()

    /// If present, this represents the filter chain which will be created for
    /// this type of upgrade. If no filters are present, the filter chain for
    /// HTTP connections will be used for this upgrade type.
    public var filters: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter] = []

    /// Determines if upgrades are enabled or disabled by default. Defaults to true.
    /// This can be overridden on a per-route basis with :ref:`cluster
    /// <envoy_api_field_config.route.v4alpha.RouteAction.upgrade_configs>` as documented in the
    /// :ref:`upgrade documentation <arch_overview_upgrades>`.
    public var enabled: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _enabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_enabled = newValue}
    }
    /// Returns true if `enabled` has been explicitly set.
    public var hasEnabled: Bool {return self._enabled != nil}
    /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
    public mutating func clearEnabled() {self._enabled = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _enabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.CodecType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.CodecType] = [
    .auto,
    .http1,
    .http2,
    .http3,
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ServerHeaderTransformation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ServerHeaderTransformation] = [
    .overwrite,
    .appendIfAbsent,
    .passThrough,
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ForwardClientCertDetails: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ForwardClientCertDetails] = [
    .sanitize,
    .forwardOnly,
    .appendForward,
    .sanitizeSet,
    .alwaysForwardOnly,
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing.OperationName: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing.OperationName] = [
    .ingress,
    .egress,
  ]
}

#endif  // swift(>=4.2)

public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration source specifier for RDS.
  public var configSource: Envoy_Config_Core_V4alpha_ConfigSource {
    get {return _configSource ?? Envoy_Config_Core_V4alpha_ConfigSource()}
    set {_configSource = newValue}
  }
  /// Returns true if `configSource` has been explicitly set.
  public var hasConfigSource: Bool {return self._configSource != nil}
  /// Clears the value of `configSource`. Subsequent reads from it will return its default value.
  public mutating func clearConfigSource() {self._configSource = nil}

  /// The name of the route configuration. This name will be passed to the RDS
  /// API. This allows an Envoy configuration with multiple HTTP listeners (and
  /// associated HTTP connection manager filters) to use different route
  /// configurations.
  public var routeConfigName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configSource: Envoy_Config_Core_V4alpha_ConfigSource? = nil
}

/// This message is used to work around the limitations with 'oneof' and repeated fields.
public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var scopedRouteConfigurations: [Envoy_Config_Route_V4alpha_ScopedRouteConfiguration] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [#next-free-field: 6]
public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name assigned to the scoped routing configuration.
  public var name: String = String()

  /// The algorithm to use for constructing a scope key for each request.
  public var scopeKeyBuilder: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder {
    get {return _scopeKeyBuilder ?? Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder()}
    set {_scopeKeyBuilder = newValue}
  }
  /// Returns true if `scopeKeyBuilder` has been explicitly set.
  public var hasScopeKeyBuilder: Bool {return self._scopeKeyBuilder != nil}
  /// Clears the value of `scopeKeyBuilder`. Subsequent reads from it will return its default value.
  public mutating func clearScopeKeyBuilder() {self._scopeKeyBuilder = nil}

  /// Configuration source specifier for RDS.
  /// This config source is used to subscribe to RouteConfiguration resources specified in
  /// ScopedRouteConfiguration messages.
  public var rdsConfigSource: Envoy_Config_Core_V4alpha_ConfigSource {
    get {return _rdsConfigSource ?? Envoy_Config_Core_V4alpha_ConfigSource()}
    set {_rdsConfigSource = newValue}
  }
  /// Returns true if `rdsConfigSource` has been explicitly set.
  public var hasRdsConfigSource: Bool {return self._rdsConfigSource != nil}
  /// Clears the value of `rdsConfigSource`. Subsequent reads from it will return its default value.
  public mutating func clearRdsConfigSource() {self._rdsConfigSource = nil}

  public var configSpecifier: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.OneOf_ConfigSpecifier? = nil

  /// The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
  /// matching a key constructed from the request's attributes according to the algorithm specified
  /// by the
  /// :ref:`ScopeKeyBuilder<envoy_api_msg_extensions.filters.network.http_connection_manager.v4alpha.ScopedRoutes.ScopeKeyBuilder>`
  /// in this message.
  public var scopedRouteConfigurationsList: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList {
    get {
      if case .scopedRouteConfigurationsList(let v)? = configSpecifier {return v}
      return Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList()
    }
    set {configSpecifier = .scopedRouteConfigurationsList(newValue)}
  }

  /// The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
  /// API. A scope is assigned to a request by matching a key constructed from the request's
  /// attributes according to the algorithm specified by the
  /// :ref:`ScopeKeyBuilder<envoy_api_msg_extensions.filters.network.http_connection_manager.v4alpha.ScopedRoutes.ScopeKeyBuilder>`
  /// in this message.
  public var scopedRds: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds {
    get {
      if case .scopedRds(let v)? = configSpecifier {return v}
      return Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds()
    }
    set {configSpecifier = .scopedRds(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ConfigSpecifier: Equatable {
    /// The set of routing scopes corresponding to the HCM. A scope is assigned to a request by
    /// matching a key constructed from the request's attributes according to the algorithm specified
    /// by the
    /// :ref:`ScopeKeyBuilder<envoy_api_msg_extensions.filters.network.http_connection_manager.v4alpha.ScopedRoutes.ScopeKeyBuilder>`
    /// in this message.
    case scopedRouteConfigurationsList(Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList)
    /// The set of routing scopes associated with the HCM will be dynamically loaded via the SRDS
    /// API. A scope is assigned to a request by matching a key constructed from the request's
    /// attributes according to the algorithm specified by the
    /// :ref:`ScopeKeyBuilder<envoy_api_msg_extensions.filters.network.http_connection_manager.v4alpha.ScopedRoutes.ScopeKeyBuilder>`
    /// in this message.
    case scopedRds(Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.OneOf_ConfigSpecifier, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.OneOf_ConfigSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.scopedRouteConfigurationsList(let l), .scopedRouteConfigurationsList(let r)): return l == r
      case (.scopedRds(let l), .scopedRds(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Specifies the mechanism for constructing "scope keys" based on HTTP request attributes. These
  /// keys are matched against a set of :ref:`Key<envoy_api_msg_config.route.v4alpha.ScopedRouteConfiguration.Key>`
  /// objects assembled from :ref:`ScopedRouteConfiguration<envoy_api_msg_config.route.v4alpha.ScopedRouteConfiguration>`
  /// messages distributed via SRDS (the Scoped Route Discovery Service) or assigned statically via
  /// :ref:`scoped_route_configurations_list<envoy_api_field_extensions.filters.network.http_connection_manager.v4alpha.ScopedRoutes.scoped_route_configurations_list>`.
  ///
  /// Upon receiving a request's headers, the Router will build a key using the algorithm specified
  /// by this message. This key will be used to look up the routing table (i.e., the
  /// :ref:`RouteConfiguration<envoy_api_msg_config.route.v4alpha.RouteConfiguration>`) to use for the request.
  public struct ScopeKeyBuilder {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The final(built) scope key consists of the ordered union of these fragments, which are compared in order with the
    /// fragments of a :ref:`ScopedRouteConfiguration<envoy_api_msg_config.route.v4alpha.ScopedRouteConfiguration>`.
    /// A missing fragment during comparison will make the key invalid, i.e., the computed key doesn't match any key.
    public var fragments: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Specifies the mechanism for constructing key fragments which are composed into scope keys.
    public struct FragmentBuilder {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var type: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.OneOf_Type? = nil

      /// Specifies how a header field's value should be extracted.
      public var headerValueExtractor: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor {
        get {
          if case .headerValueExtractor(let v)? = type {return v}
          return Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor()
        }
        set {type = .headerValueExtractor(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Type: Equatable {
        /// Specifies how a header field's value should be extracted.
        case headerValueExtractor(Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor)

      #if !swift(>=4.1)
        public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.OneOf_Type, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.OneOf_Type) -> Bool {
          switch (lhs, rhs) {
          case (.headerValueExtractor(let l), .headerValueExtractor(let r)): return l == r
          }
        }
      #endif
      }

      /// Specifies how the value of a header should be extracted.
      /// The following example maps the structure of a header to the fields in this message.
      ///
      /// .. code::
      ///
      ///              <0> <1>   <-- index
      ///    X-Header: a=b;c=d
      ///    |         || |
      ///    |         || \----> <element_separator>
      ///    |         ||
      ///    |         |\----> <element.separator>
      ///    |         |
      ///    |         \----> <element.key>
      ///    |
      ///    \----> <name>
      ///
      ///    Each 'a=b' key-value pair constitutes an 'element' of the header field.
      public struct HeaderValueExtractor {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The name of the header field to extract the value from.
        public var name: String = String()

        /// The element separator (e.g., ';' separates 'a;b;c;d').
        /// Default: empty string. This causes the entirety of the header field to be extracted.
        /// If this field is set to an empty string and 'index' is used in the oneof below, 'index'
        /// must be set to 0.
        public var elementSeparator: String = String()

        public var extractType: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.OneOf_ExtractType? = nil

        /// Specifies the zero based index of the element to extract.
        /// Note Envoy concatenates multiple values of the same header key into a comma separated
        /// string, the splitting always happens after the concatenation.
        public var index: UInt32 {
          get {
            if case .index(let v)? = extractType {return v}
            return 0
          }
          set {extractType = .index(newValue)}
        }

        /// Specifies the key value pair to extract the value from.
        public var element: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement {
          get {
            if case .element(let v)? = extractType {return v}
            return Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement()
          }
          set {extractType = .element(newValue)}
        }

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public enum OneOf_ExtractType: Equatable {
          /// Specifies the zero based index of the element to extract.
          /// Note Envoy concatenates multiple values of the same header key into a comma separated
          /// string, the splitting always happens after the concatenation.
          case index(UInt32)
          /// Specifies the key value pair to extract the value from.
          case element(Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement)

        #if !swift(>=4.1)
          public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.OneOf_ExtractType, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.OneOf_ExtractType) -> Bool {
            switch (lhs, rhs) {
            case (.index(let l), .index(let r)): return l == r
            case (.element(let l), .element(let r)): return l == r
            default: return false
            }
          }
        #endif
        }

        /// Specifies a header field's key value pair to match on.
        public struct KvElement {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          /// The separator between key and value (e.g., '=' separates 'k=v;...').
          /// If an element is an empty string, the element is ignored.
          /// If an element contains no separator, the whole element is parsed as key and the
          /// fragment value is an empty string.
          /// If there are multiple values for a matched key, the first value is returned.
          public var separator: String = String()

          /// The key to match on.
          public var key: String = String()

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _scopeKeyBuilder: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder? = nil
  fileprivate var _rdsConfigSource: Envoy_Config_Core_V4alpha_ConfigSource? = nil
}

public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration source specifier for scoped RDS.
  public var scopedRdsConfigSource: Envoy_Config_Core_V4alpha_ConfigSource {
    get {return _scopedRdsConfigSource ?? Envoy_Config_Core_V4alpha_ConfigSource()}
    set {_scopedRdsConfigSource = newValue}
  }
  /// Returns true if `scopedRdsConfigSource` has been explicitly set.
  public var hasScopedRdsConfigSource: Bool {return self._scopedRdsConfigSource != nil}
  /// Clears the value of `scopedRdsConfigSource`. Subsequent reads from it will return its default value.
  public mutating func clearScopedRdsConfigSource() {self._scopedRdsConfigSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scopedRdsConfigSource: Envoy_Config_Core_V4alpha_ConfigSource? = nil
}

public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the filter to instantiate. The name must match a
  /// :ref:`supported filter <config_http_filters>`.
  public var name: String = String()

  /// Filter specific configuration which depends on the filter being instantiated. See the supported
  /// filters for further documentation.
  public var configType: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter.OneOf_ConfigType? = nil

  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {
      if case .typedConfig(let v)? = configType {return v}
      return SwiftProtobuf.Google_Protobuf_Any()
    }
    set {configType = .typedConfig(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Filter specific configuration which depends on the filter being instantiated. See the supported
  /// filters for further documentation.
  public enum OneOf_ConfigType: Equatable {
    case typedConfig(SwiftProtobuf.Google_Protobuf_Any)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter.OneOf_ConfigType, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter.OneOf_ConfigType) -> Bool {
      switch (lhs, rhs) {
      case (.typedConfig(let l), .typedConfig(let r)): return l == r
      }
    }
  #endif
  }

  public init() {}
}

public struct Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request ID extension specific configuration.
  public var typedConfig: SwiftProtobuf.Google_Protobuf_Any {
    get {return _typedConfig ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_typedConfig = newValue}
  }
  /// Returns true if `typedConfig` has been explicitly set.
  public var hasTypedConfig: Bool {return self._typedConfig != nil}
  /// Clears the value of `typedConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTypedConfig() {self._typedConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _typedConfig: SwiftProtobuf.Google_Protobuf_Any? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.network.http_connection_manager.v4alpha"

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpConnectionManager"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "codec_type"),
    2: .standard(proto: "stat_prefix"),
    3: .same(proto: "rds"),
    4: .standard(proto: "route_config"),
    31: .standard(proto: "scoped_routes"),
    5: .standard(proto: "http_filters"),
    6: .standard(proto: "add_user_agent"),
    7: .same(proto: "tracing"),
    35: .standard(proto: "common_http_protocol_options"),
    8: .standard(proto: "http_protocol_options"),
    9: .standard(proto: "http2_protocol_options"),
    10: .standard(proto: "server_name"),
    34: .standard(proto: "server_header_transformation"),
    29: .standard(proto: "max_request_headers_kb"),
    24: .standard(proto: "stream_idle_timeout"),
    28: .standard(proto: "request_timeout"),
    12: .standard(proto: "drain_timeout"),
    26: .standard(proto: "delayed_close_timeout"),
    13: .standard(proto: "access_log"),
    14: .standard(proto: "use_remote_address"),
    19: .standard(proto: "xff_num_trusted_hops"),
    25: .standard(proto: "internal_address_config"),
    21: .standard(proto: "skip_xff_append"),
    22: .same(proto: "via"),
    15: .standard(proto: "generate_request_id"),
    32: .standard(proto: "preserve_external_request_id"),
    37: .standard(proto: "always_set_request_id_in_response"),
    16: .standard(proto: "forward_client_cert_details"),
    17: .standard(proto: "set_current_client_cert_details"),
    18: .standard(proto: "proxy_100_continue"),
    20: .standard(proto: "represent_ipv4_remote_address_as_ipv4_mapped_ipv6"),
    23: .standard(proto: "upgrade_configs"),
    30: .standard(proto: "normalize_path"),
    33: .standard(proto: "merge_slashes"),
    36: .standard(proto: "request_id_extension"),
    39: .standard(proto: "strip_matching_host_port"),
  ]

  fileprivate class _StorageClass {
    var _codecType: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.CodecType = .auto
    var _statPrefix: String = String()
    var _routeSpecifier: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.OneOf_RouteSpecifier?
    var _httpFilters: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter] = []
    var _addUserAgent: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _tracing: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing? = nil
    var _commonHTTPProtocolOptions: Envoy_Config_Core_V4alpha_HttpProtocolOptions? = nil
    var _httpProtocolOptions: Envoy_Config_Core_V4alpha_Http1ProtocolOptions? = nil
    var _http2ProtocolOptions: Envoy_Config_Core_V4alpha_Http2ProtocolOptions? = nil
    var _serverName: String = String()
    var _serverHeaderTransformation: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ServerHeaderTransformation = .overwrite
    var _maxRequestHeadersKb: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    var _streamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _requestTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _drainTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _delayedCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _accessLog: [Envoy_Config_Accesslog_V4alpha_AccessLog] = []
    var _useRemoteAddress: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _xffNumTrustedHops: UInt32 = 0
    var _internalAddressConfig: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.InternalAddressConfig? = nil
    var _skipXffAppend: Bool = false
    var _via: String = String()
    var _generateRequestID: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _preserveExternalRequestID: Bool = false
    var _alwaysSetRequestIDInResponse: Bool = false
    var _forwardClientCertDetails: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ForwardClientCertDetails = .sanitize
    var _setCurrentClientCertDetails: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.SetCurrentClientCertDetails? = nil
    var _proxy100Continue: Bool = false
    var _representIpv4RemoteAddressAsIpv4MappedIpv6: Bool = false
    var _upgradeConfigs: [Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.UpgradeConfig] = []
    var _normalizePath: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _mergeSlashes: Bool = false
    var _requestIDExtension: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension? = nil
    var _stripMatchingHostPort: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _codecType = source._codecType
      _statPrefix = source._statPrefix
      _routeSpecifier = source._routeSpecifier
      _httpFilters = source._httpFilters
      _addUserAgent = source._addUserAgent
      _tracing = source._tracing
      _commonHTTPProtocolOptions = source._commonHTTPProtocolOptions
      _httpProtocolOptions = source._httpProtocolOptions
      _http2ProtocolOptions = source._http2ProtocolOptions
      _serverName = source._serverName
      _serverHeaderTransformation = source._serverHeaderTransformation
      _maxRequestHeadersKb = source._maxRequestHeadersKb
      _streamIdleTimeout = source._streamIdleTimeout
      _requestTimeout = source._requestTimeout
      _drainTimeout = source._drainTimeout
      _delayedCloseTimeout = source._delayedCloseTimeout
      _accessLog = source._accessLog
      _useRemoteAddress = source._useRemoteAddress
      _xffNumTrustedHops = source._xffNumTrustedHops
      _internalAddressConfig = source._internalAddressConfig
      _skipXffAppend = source._skipXffAppend
      _via = source._via
      _generateRequestID = source._generateRequestID
      _preserveExternalRequestID = source._preserveExternalRequestID
      _alwaysSetRequestIDInResponse = source._alwaysSetRequestIDInResponse
      _forwardClientCertDetails = source._forwardClientCertDetails
      _setCurrentClientCertDetails = source._setCurrentClientCertDetails
      _proxy100Continue = source._proxy100Continue
      _representIpv4RemoteAddressAsIpv4MappedIpv6 = source._representIpv4RemoteAddressAsIpv4MappedIpv6
      _upgradeConfigs = source._upgradeConfigs
      _normalizePath = source._normalizePath
      _mergeSlashes = source._mergeSlashes
      _requestIDExtension = source._requestIDExtension
      _stripMatchingHostPort = source._stripMatchingHostPort
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularEnumField(value: &_storage._codecType)
        case 2: try decoder.decodeSingularStringField(value: &_storage._statPrefix)
        case 3:
          var v: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds?
          if let current = _storage._routeSpecifier {
            try decoder.handleConflictingOneOf()
            if case .rds(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._routeSpecifier = .rds(v)}
        case 4:
          var v: Envoy_Config_Route_V4alpha_RouteConfiguration?
          if let current = _storage._routeSpecifier {
            try decoder.handleConflictingOneOf()
            if case .routeConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._routeSpecifier = .routeConfig(v)}
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._httpFilters)
        case 6: try decoder.decodeSingularMessageField(value: &_storage._addUserAgent)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._tracing)
        case 8: try decoder.decodeSingularMessageField(value: &_storage._httpProtocolOptions)
        case 9: try decoder.decodeSingularMessageField(value: &_storage._http2ProtocolOptions)
        case 10: try decoder.decodeSingularStringField(value: &_storage._serverName)
        case 12: try decoder.decodeSingularMessageField(value: &_storage._drainTimeout)
        case 13: try decoder.decodeRepeatedMessageField(value: &_storage._accessLog)
        case 14: try decoder.decodeSingularMessageField(value: &_storage._useRemoteAddress)
        case 15: try decoder.decodeSingularMessageField(value: &_storage._generateRequestID)
        case 16: try decoder.decodeSingularEnumField(value: &_storage._forwardClientCertDetails)
        case 17: try decoder.decodeSingularMessageField(value: &_storage._setCurrentClientCertDetails)
        case 18: try decoder.decodeSingularBoolField(value: &_storage._proxy100Continue)
        case 19: try decoder.decodeSingularUInt32Field(value: &_storage._xffNumTrustedHops)
        case 20: try decoder.decodeSingularBoolField(value: &_storage._representIpv4RemoteAddressAsIpv4MappedIpv6)
        case 21: try decoder.decodeSingularBoolField(value: &_storage._skipXffAppend)
        case 22: try decoder.decodeSingularStringField(value: &_storage._via)
        case 23: try decoder.decodeRepeatedMessageField(value: &_storage._upgradeConfigs)
        case 24: try decoder.decodeSingularMessageField(value: &_storage._streamIdleTimeout)
        case 25: try decoder.decodeSingularMessageField(value: &_storage._internalAddressConfig)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._delayedCloseTimeout)
        case 28: try decoder.decodeSingularMessageField(value: &_storage._requestTimeout)
        case 29: try decoder.decodeSingularMessageField(value: &_storage._maxRequestHeadersKb)
        case 30: try decoder.decodeSingularMessageField(value: &_storage._normalizePath)
        case 31:
          var v: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes?
          if let current = _storage._routeSpecifier {
            try decoder.handleConflictingOneOf()
            if case .scopedRoutes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._routeSpecifier = .scopedRoutes(v)}
        case 32: try decoder.decodeSingularBoolField(value: &_storage._preserveExternalRequestID)
        case 33: try decoder.decodeSingularBoolField(value: &_storage._mergeSlashes)
        case 34: try decoder.decodeSingularEnumField(value: &_storage._serverHeaderTransformation)
        case 35: try decoder.decodeSingularMessageField(value: &_storage._commonHTTPProtocolOptions)
        case 36: try decoder.decodeSingularMessageField(value: &_storage._requestIDExtension)
        case 37: try decoder.decodeSingularBoolField(value: &_storage._alwaysSetRequestIDInResponse)
        case 39: try decoder.decodeSingularBoolField(value: &_storage._stripMatchingHostPort)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._codecType != .auto {
        try visitor.visitSingularEnumField(value: _storage._codecType, fieldNumber: 1)
      }
      if !_storage._statPrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statPrefix, fieldNumber: 2)
      }
      switch _storage._routeSpecifier {
      case .rds(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case .routeConfig(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      case nil: break
      default: break
      }
      if !_storage._httpFilters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._httpFilters, fieldNumber: 5)
      }
      if let v = _storage._addUserAgent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._tracing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._httpProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._http2ProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._serverName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverName, fieldNumber: 10)
      }
      if let v = _storage._drainTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._accessLog.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._accessLog, fieldNumber: 13)
      }
      if let v = _storage._useRemoteAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._generateRequestID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if _storage._forwardClientCertDetails != .sanitize {
        try visitor.visitSingularEnumField(value: _storage._forwardClientCertDetails, fieldNumber: 16)
      }
      if let v = _storage._setCurrentClientCertDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if _storage._proxy100Continue != false {
        try visitor.visitSingularBoolField(value: _storage._proxy100Continue, fieldNumber: 18)
      }
      if _storage._xffNumTrustedHops != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._xffNumTrustedHops, fieldNumber: 19)
      }
      if _storage._representIpv4RemoteAddressAsIpv4MappedIpv6 != false {
        try visitor.visitSingularBoolField(value: _storage._representIpv4RemoteAddressAsIpv4MappedIpv6, fieldNumber: 20)
      }
      if _storage._skipXffAppend != false {
        try visitor.visitSingularBoolField(value: _storage._skipXffAppend, fieldNumber: 21)
      }
      if !_storage._via.isEmpty {
        try visitor.visitSingularStringField(value: _storage._via, fieldNumber: 22)
      }
      if !_storage._upgradeConfigs.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._upgradeConfigs, fieldNumber: 23)
      }
      if let v = _storage._streamIdleTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._internalAddressConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if let v = _storage._delayedCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._requestTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }
      if let v = _storage._maxRequestHeadersKb {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }
      if let v = _storage._normalizePath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if case .scopedRoutes(let v)? = _storage._routeSpecifier {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if _storage._preserveExternalRequestID != false {
        try visitor.visitSingularBoolField(value: _storage._preserveExternalRequestID, fieldNumber: 32)
      }
      if _storage._mergeSlashes != false {
        try visitor.visitSingularBoolField(value: _storage._mergeSlashes, fieldNumber: 33)
      }
      if _storage._serverHeaderTransformation != .overwrite {
        try visitor.visitSingularEnumField(value: _storage._serverHeaderTransformation, fieldNumber: 34)
      }
      if let v = _storage._commonHTTPProtocolOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }
      if let v = _storage._requestIDExtension {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }
      if _storage._alwaysSetRequestIDInResponse != false {
        try visitor.visitSingularBoolField(value: _storage._alwaysSetRequestIDInResponse, fieldNumber: 37)
      }
      if _storage._stripMatchingHostPort != false {
        try visitor.visitSingularBoolField(value: _storage._stripMatchingHostPort, fieldNumber: 39)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._codecType != rhs_storage._codecType {return false}
        if _storage._statPrefix != rhs_storage._statPrefix {return false}
        if _storage._routeSpecifier != rhs_storage._routeSpecifier {return false}
        if _storage._httpFilters != rhs_storage._httpFilters {return false}
        if _storage._addUserAgent != rhs_storage._addUserAgent {return false}
        if _storage._tracing != rhs_storage._tracing {return false}
        if _storage._commonHTTPProtocolOptions != rhs_storage._commonHTTPProtocolOptions {return false}
        if _storage._httpProtocolOptions != rhs_storage._httpProtocolOptions {return false}
        if _storage._http2ProtocolOptions != rhs_storage._http2ProtocolOptions {return false}
        if _storage._serverName != rhs_storage._serverName {return false}
        if _storage._serverHeaderTransformation != rhs_storage._serverHeaderTransformation {return false}
        if _storage._maxRequestHeadersKb != rhs_storage._maxRequestHeadersKb {return false}
        if _storage._streamIdleTimeout != rhs_storage._streamIdleTimeout {return false}
        if _storage._requestTimeout != rhs_storage._requestTimeout {return false}
        if _storage._drainTimeout != rhs_storage._drainTimeout {return false}
        if _storage._delayedCloseTimeout != rhs_storage._delayedCloseTimeout {return false}
        if _storage._accessLog != rhs_storage._accessLog {return false}
        if _storage._useRemoteAddress != rhs_storage._useRemoteAddress {return false}
        if _storage._xffNumTrustedHops != rhs_storage._xffNumTrustedHops {return false}
        if _storage._internalAddressConfig != rhs_storage._internalAddressConfig {return false}
        if _storage._skipXffAppend != rhs_storage._skipXffAppend {return false}
        if _storage._via != rhs_storage._via {return false}
        if _storage._generateRequestID != rhs_storage._generateRequestID {return false}
        if _storage._preserveExternalRequestID != rhs_storage._preserveExternalRequestID {return false}
        if _storage._alwaysSetRequestIDInResponse != rhs_storage._alwaysSetRequestIDInResponse {return false}
        if _storage._forwardClientCertDetails != rhs_storage._forwardClientCertDetails {return false}
        if _storage._setCurrentClientCertDetails != rhs_storage._setCurrentClientCertDetails {return false}
        if _storage._proxy100Continue != rhs_storage._proxy100Continue {return false}
        if _storage._representIpv4RemoteAddressAsIpv4MappedIpv6 != rhs_storage._representIpv4RemoteAddressAsIpv4MappedIpv6 {return false}
        if _storage._upgradeConfigs != rhs_storage._upgradeConfigs {return false}
        if _storage._normalizePath != rhs_storage._normalizePath {return false}
        if _storage._mergeSlashes != rhs_storage._mergeSlashes {return false}
        if _storage._requestIDExtension != rhs_storage._requestIDExtension {return false}
        if _storage._stripMatchingHostPort != rhs_storage._stripMatchingHostPort {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.CodecType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTO"),
    1: .same(proto: "HTTP1"),
    2: .same(proto: "HTTP2"),
    3: .same(proto: "HTTP3"),
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ServerHeaderTransformation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OVERWRITE"),
    1: .same(proto: "APPEND_IF_ABSENT"),
    2: .same(proto: "PASS_THROUGH"),
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.ForwardClientCertDetails: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SANITIZE"),
    1: .same(proto: "FORWARD_ONLY"),
    2: .same(proto: "APPEND_FORWARD"),
    3: .same(proto: "SANITIZE_SET"),
    4: .same(proto: "ALWAYS_FORWARD_ONLY"),
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.protoMessageName + ".Tracing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "client_sampling"),
    4: .standard(proto: "random_sampling"),
    5: .standard(proto: "overall_sampling"),
    6: .same(proto: "verbose"),
    7: .standard(proto: "max_path_tag_length"),
    8: .standard(proto: "custom_tags"),
    9: .same(proto: "provider"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 3: try decoder.decodeSingularMessageField(value: &self._clientSampling)
      case 4: try decoder.decodeSingularMessageField(value: &self._randomSampling)
      case 5: try decoder.decodeSingularMessageField(value: &self._overallSampling)
      case 6: try decoder.decodeSingularBoolField(value: &self.verbose)
      case 7: try decoder.decodeSingularMessageField(value: &self._maxPathTagLength)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.customTags)
      case 9: try decoder.decodeSingularMessageField(value: &self._provider)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._clientSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._randomSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._overallSampling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 6)
    }
    if let v = self._maxPathTagLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.customTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customTags, fieldNumber: 8)
    }
    if let v = self._provider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing) -> Bool {
    if lhs._clientSampling != rhs._clientSampling {return false}
    if lhs._randomSampling != rhs._randomSampling {return false}
    if lhs._overallSampling != rhs._overallSampling {return false}
    if lhs.verbose != rhs.verbose {return false}
    if lhs._maxPathTagLength != rhs._maxPathTagLength {return false}
    if lhs.customTags != rhs.customTags {return false}
    if lhs._provider != rhs._provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.Tracing.OperationName: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INGRESS"),
    1: .same(proto: "EGRESS"),
  ]
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.InternalAddressConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.protoMessageName + ".InternalAddressConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unix_sockets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.unixSockets)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unixSockets != false {
      try visitor.visitSingularBoolField(value: self.unixSockets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.InternalAddressConfig, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.InternalAddressConfig) -> Bool {
    if lhs.unixSockets != rhs.unixSockets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.SetCurrentClientCertDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.protoMessageName + ".SetCurrentClientCertDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    3: .same(proto: "cert"),
    6: .same(proto: "chain"),
    4: .same(proto: "dns"),
    5: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._subject)
      case 3: try decoder.decodeSingularBoolField(value: &self.cert)
      case 4: try decoder.decodeSingularBoolField(value: &self.dns)
      case 5: try decoder.decodeSingularBoolField(value: &self.uri)
      case 6: try decoder.decodeSingularBoolField(value: &self.chain)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.cert != false {
      try visitor.visitSingularBoolField(value: self.cert, fieldNumber: 3)
    }
    if self.dns != false {
      try visitor.visitSingularBoolField(value: self.dns, fieldNumber: 4)
    }
    if self.uri != false {
      try visitor.visitSingularBoolField(value: self.uri, fieldNumber: 5)
    }
    if self.chain != false {
      try visitor.visitSingularBoolField(value: self.chain, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.SetCurrentClientCertDetails, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.SetCurrentClientCertDetails) -> Bool {
    if lhs._subject != rhs._subject {return false}
    if lhs.cert != rhs.cert {return false}
    if lhs.chain != rhs.chain {return false}
    if lhs.dns != rhs.dns {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.UpgradeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.protoMessageName + ".UpgradeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upgrade_type"),
    2: .same(proto: "filters"),
    3: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.upgradeType)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.filters)
      case 3: try decoder.decodeSingularMessageField(value: &self._enabled)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.upgradeType.isEmpty {
      try visitor.visitSingularStringField(value: self.upgradeType, fieldNumber: 1)
    }
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 2)
    }
    if let v = self._enabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.UpgradeConfig, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpConnectionManager.UpgradeConfig) -> Bool {
    if lhs.upgradeType != rhs.upgradeType {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Rds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "config_source"),
    2: .standard(proto: "route_config_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._configSource)
      case 2: try decoder.decodeSingularStringField(value: &self.routeConfigName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._configSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.routeConfigName.isEmpty {
      try visitor.visitSingularStringField(value: self.routeConfigName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_Rds) -> Bool {
    if lhs._configSource != rhs._configSource {return false}
    if lhs.routeConfigName != rhs.routeConfigName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopedRouteConfigurationsList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scoped_route_configurations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.scopedRouteConfigurations)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scopedRouteConfigurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.scopedRouteConfigurations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList) -> Bool {
    if lhs.scopedRouteConfigurations != rhs.scopedRouteConfigurations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopedRoutes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "scope_key_builder"),
    3: .standard(proto: "rds_config_source"),
    4: .standard(proto: "scoped_route_configurations_list"),
    5: .standard(proto: "scoped_rds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._scopeKeyBuilder)
      case 3: try decoder.decodeSingularMessageField(value: &self._rdsConfigSource)
      case 4:
        var v: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRouteConfigurationsList?
        if let current = self.configSpecifier {
          try decoder.handleConflictingOneOf()
          if case .scopedRouteConfigurationsList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configSpecifier = .scopedRouteConfigurationsList(v)}
      case 5:
        var v: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds?
        if let current = self.configSpecifier {
          try decoder.handleConflictingOneOf()
          if case .scopedRds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configSpecifier = .scopedRds(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._scopeKeyBuilder {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._rdsConfigSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    switch self.configSpecifier {
    case .scopedRouteConfigurationsList(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case .scopedRds(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._scopeKeyBuilder != rhs._scopeKeyBuilder {return false}
    if lhs._rdsConfigSource != rhs._rdsConfigSource {return false}
    if lhs.configSpecifier != rhs.configSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.protoMessageName + ".ScopeKeyBuilder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fragments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.fragments)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fragments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fragments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder) -> Bool {
    if lhs.fragments != rhs.fragments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.protoMessageName + ".FragmentBuilder"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "header_value_extractor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .headerValueExtractor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .headerValueExtractor(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .headerValueExtractor(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.protoMessageName + ".HeaderValueExtractor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "element_separator"),
    3: .same(proto: "index"),
    4: .same(proto: "element"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.elementSeparator)
      case 3:
        if self.extractType != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.extractType = .index(v)}
      case 4:
        var v: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement?
        if let current = self.extractType {
          try decoder.handleConflictingOneOf()
          if case .element(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.extractType = .element(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.elementSeparator.isEmpty {
      try visitor.visitSingularStringField(value: self.elementSeparator, fieldNumber: 2)
    }
    switch self.extractType {
    case .index(let v)?:
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    case .element(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.elementSeparator != rhs.elementSeparator {return false}
    if lhs.extractType != rhs.extractType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.protoMessageName + ".KvElement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "separator"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.separator)
      case 2: try decoder.decodeSingularStringField(value: &self.key)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.separator.isEmpty {
      try visitor.visitSingularStringField(value: self.separator, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRoutes.ScopeKeyBuilder.FragmentBuilder.HeaderValueExtractor.KvElement) -> Bool {
    if lhs.separator != rhs.separator {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScopedRds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scoped_rds_config_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._scopedRdsConfigSource)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scopedRdsConfigSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_ScopedRds) -> Bool {
    if lhs._scopedRdsConfigSource != rhs._scopedRdsConfigSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    4: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 4:
        var v: SwiftProtobuf.Google_Protobuf_Any?
        if let current = self.configType {
          try decoder.handleConflictingOneOf()
          if case .typedConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configType = .typedConfig(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .typedConfig(let v)? = self.configType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_HttpFilter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestIDExtension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "typed_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._typedConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._typedConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension, rhs: Envoy_Extensions_Filters_Network_HttpConnectionManager_V4alpha_RequestIDExtension) -> Bool {
    if lhs._typedConfig != rhs._typedConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/network/redis_proxy/v3/redis_proxy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 7]
public struct Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The prefix to use when emitting :ref:`statistics <config_network_filters_redis_proxy_stats>`.
  public var statPrefix: String = String()

  /// Network settings for the connection pool to the upstream clusters.
  public var settings: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings {
    get {return _settings ?? Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {self._settings = nil}

  /// Indicates that latency stat should be computed in microseconds. By default it is computed in
  /// milliseconds. This does not apply to upstream command stats currently.
  public var latencyInMicros: Bool = false

  /// List of **unique** prefixes used to separate keys from different workloads to different
  /// clusters. Envoy will always favor the longest match first in case of overlap. A catch-all
  /// cluster can be used to forward commands when there is no match. Time complexity of the
  /// lookups are in O(min(longest key prefix, key length)).
  ///
  /// Example:
  ///
  /// .. code-block:: yaml
  ///
  ///    prefix_routes:
  ///      routes:
  ///        - prefix: "ab"
  ///          cluster: "cluster_a"
  ///        - prefix: "abc"
  ///          cluster: "cluster_b"
  ///
  /// When using the above routes, the following prefixes would be sent to:
  ///
  /// * ``get abc:users`` would retrieve the key 'abc:users' from cluster_b.
  /// * ``get ab:users`` would retrieve the key 'ab:users' from cluster_a.
  /// * ``get z:users`` would return a NoUpstreamHost error. A :ref:`catch-all
  ///   route<envoy_api_field_extensions.filters.network.redis_proxy.v3.RedisProxy.PrefixRoutes.catch_all_route>`
  ///   would have retrieved the key from that cluster instead.
  ///
  /// See the :ref:`configuration section
  /// <arch_overview_redis_configuration>` of the architecture overview for recommendations on
  /// configuring the backing clusters.
  public var prefixRoutes: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes {
    get {return _prefixRoutes ?? Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes()}
    set {_prefixRoutes = newValue}
  }
  /// Returns true if `prefixRoutes` has been explicitly set.
  public var hasPrefixRoutes: Bool {return self._prefixRoutes != nil}
  /// Clears the value of `prefixRoutes`. Subsequent reads from it will return its default value.
  public mutating func clearPrefixRoutes() {self._prefixRoutes = nil}

  /// Authenticate Redis client connections locally by forcing downstream clients to issue a `Redis
  /// AUTH command <https://redis.io/commands/auth>`_ with this password before enabling any other
  /// command. If an AUTH command's password matches this password, an "OK" response will be returned
  /// to the client. If the AUTH command password does not match this password, then an "ERR invalid
  /// password" error will be returned. If any other command is received before AUTH when this
  /// password is set, then a "NOAUTH Authentication required." error response will be sent to the
  /// client. If an AUTH command is received when the password is not set, then an "ERR Client sent
  /// AUTH, but no password is set" error will be returned.
  public var downstreamAuthPassword: Envoy_Config_Core_V3_DataSource {
    get {return _downstreamAuthPassword ?? Envoy_Config_Core_V3_DataSource()}
    set {_downstreamAuthPassword = newValue}
  }
  /// Returns true if `downstreamAuthPassword` has been explicitly set.
  public var hasDownstreamAuthPassword: Bool {return self._downstreamAuthPassword != nil}
  /// Clears the value of `downstreamAuthPassword`. Subsequent reads from it will return its default value.
  public mutating func clearDownstreamAuthPassword() {self._downstreamAuthPassword = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Redis connection pool settings.
  /// [#next-free-field: 9]
  public struct ConnPoolSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Per-operation timeout in milliseconds. The timer starts when the first
    /// command of a pipeline is written to the backend connection. Each response received from Redis
    /// resets the timer since it signifies that the next command is being processed by the backend.
    /// The only exception to this behavior is when a connection to a backend is not yet established.
    /// In that case, the connect timeout on the cluster will govern the timeout until the connection
    /// is ready.
    public var opTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _opTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_opTimeout = newValue}
    }
    /// Returns true if `opTimeout` has been explicitly set.
    public var hasOpTimeout: Bool {return self._opTimeout != nil}
    /// Clears the value of `opTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearOpTimeout() {self._opTimeout = nil}

    /// Use hash tagging on every redis key to guarantee that keys with the same hash tag will be
    /// forwarded to the same upstream. The hash key used for determining the upstream in a
    /// consistent hash ring configuration will be computed from the hash tagged key instead of the
    /// whole key. The algorithm used to compute the hash tag is identical to the `redis-cluster
    /// implementation <https://redis.io/topics/cluster-spec#keys-hash-tags>`_.
    ///
    /// Examples:
    ///
    /// * '{user1000}.following' and '{user1000}.followers' **will** be sent to the same upstream
    /// * '{user1000}.following' and '{user1001}.following' **might** be sent to the same upstream
    public var enableHashtagging: Bool = false

    /// Accept `moved and ask redirection
    /// <https://redis.io/topics/cluster-spec#redirection-and-resharding>`_ errors from upstream
    /// redis servers, and retry commands to the specified target server. The target server does not
    /// need to be known to the cluster manager. If the command cannot be redirected, then the
    /// original error is passed downstream unchanged. By default, this support is not enabled.
    public var enableRedirection: Bool = false

    /// Maximum size of encoded request buffer before flush is triggered and encoded requests
    /// are sent upstream. If this is unset, the buffer flushes whenever it receives data
    /// and performs no batching.
    /// This feature makes it possible for multiple clients to send requests to Envoy and have
    /// them batched- for example if one is running several worker processes, each with its own
    /// Redis connection. There is no benefit to using this with a single downstream process.
    /// Recommended size (if enabled) is 1024 bytes.
    public var maxBufferSizeBeforeFlush: UInt32 = 0

    /// The encoded request buffer is flushed N milliseconds after the first request has been
    /// encoded, unless the buffer size has already exceeded `max_buffer_size_before_flush`.
    /// If `max_buffer_size_before_flush` is not set, this flush timer is not used. Otherwise,
    /// the timer should be set according to the number of clients, overall request rate and
    /// desired maximum latency for a single command. For example, if there are many requests
    /// being batched together at a high rate, the buffer will likely be filled before the timer
    /// fires. Alternatively, if the request rate is lower the buffer will not be filled as often
    /// before the timer fires.
    /// If `max_buffer_size_before_flush` is set, but `buffer_flush_timeout` is not, the latter
    /// defaults to 3ms.
    public var bufferFlushTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _bufferFlushTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_bufferFlushTimeout = newValue}
    }
    /// Returns true if `bufferFlushTimeout` has been explicitly set.
    public var hasBufferFlushTimeout: Bool {return self._bufferFlushTimeout != nil}
    /// Clears the value of `bufferFlushTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearBufferFlushTimeout() {self._bufferFlushTimeout = nil}

    /// `max_upstream_unknown_connections` controls how many upstream connections to unknown hosts
    /// can be created at any given time by any given worker thread (see `enable_redirection` for
    /// more details). If the host is unknown and a connection cannot be created due to enforcing
    /// this limit, then redirection will fail and the original redirection error will be passed
    /// downstream unchanged. This limit defaults to 100.
    public var maxUpstreamUnknownConnections: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _maxUpstreamUnknownConnections ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_maxUpstreamUnknownConnections = newValue}
    }
    /// Returns true if `maxUpstreamUnknownConnections` has been explicitly set.
    public var hasMaxUpstreamUnknownConnections: Bool {return self._maxUpstreamUnknownConnections != nil}
    /// Clears the value of `maxUpstreamUnknownConnections`. Subsequent reads from it will return its default value.
    public mutating func clearMaxUpstreamUnknownConnections() {self._maxUpstreamUnknownConnections = nil}

    /// Enable per-command statistics per upstream cluster, in addition to the filter level aggregate
    /// count. These commands are measured in microseconds.
    public var enableCommandStats: Bool = false

    /// Read policy. The default is to read from the master.
    public var readPolicy: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings.ReadPolicy = .master

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// ReadPolicy controls how Envoy routes read commands to Redis nodes. This is currently
    /// supported for Redis Cluster. All ReadPolicy settings except MASTER may return stale data
    /// because replication is asynchronous and requires some delay. You need to ensure that your
    /// application can tolerate stale data.
    public enum ReadPolicy: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Default mode. Read from the current master node.
      case master // = 0

      /// Read from the master, but if it is unavailable, read from replica nodes.
      case preferMaster // = 1

      /// Read from replica nodes. If multiple replica nodes are present within a shard, a random
      /// node is selected. Healthy nodes have precedent over unhealthy nodes.
      case replica // = 2

      /// Read from the replica nodes (similar to REPLICA), but if all replicas are unavailable (not
      /// present or unhealthy), read from the master.
      case preferReplica // = 3

      /// Read from any node of the cluster. A random node is selected among the master and replicas,
      /// healthy nodes have precedent over unhealthy nodes.
      case any // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .master
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .master
        case 1: self = .preferMaster
        case 2: self = .replica
        case 3: self = .preferReplica
        case 4: self = .any
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .master: return 0
        case .preferMaster: return 1
        case .replica: return 2
        case .preferReplica: return 3
        case .any: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _opTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _bufferFlushTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _maxUpstreamUnknownConnections: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  }

  public struct PrefixRoutes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of prefix routes.
    public var routes: [Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route] = []

    /// Indicates that prefix matching should be case insensitive.
    public var caseInsensitive: Bool = false

    /// Optional catch-all route to forward commands that doesn't match any of the routes. The
    /// catch-all route becomes required when no routes are specified.
    public var catchAllRoute: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route {
      get {return _catchAllRoute ?? Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route()}
      set {_catchAllRoute = newValue}
    }
    /// Returns true if `catchAllRoute` has been explicitly set.
    public var hasCatchAllRoute: Bool {return self._catchAllRoute != nil}
    /// Clears the value of `catchAllRoute`. Subsequent reads from it will return its default value.
    public mutating func clearCatchAllRoute() {self._catchAllRoute = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Route {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// String prefix that must match the beginning of the keys. Envoy will always favor the
      /// longest match.
      public var prefix: String = String()

      /// Indicates if the prefix needs to be removed from the key when forwarded.
      public var removePrefix: Bool = false

      /// Upstream cluster to forward the command to.
      public var cluster: String = String()

      /// Indicates that the route has a request mirroring policy.
      public var requestMirrorPolicy: [Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The router is capable of shadowing traffic from one cluster to another. The current
      /// implementation is "fire and forget," meaning Envoy will not wait for the shadow cluster to
      /// respond before returning the response from the primary cluster. All normal statistics are
      /// collected for the shadow cluster making this feature useful for testing.
      public struct RequestMirrorPolicy {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Specifies the cluster that requests will be mirrored to. The cluster must
        /// exist in the cluster manager configuration.
        public var cluster: String = String()

        /// If not specified or the runtime key is not present, all requests to the target cluster
        /// will be mirrored.
        ///
        /// If specified, Envoy will lookup the runtime key to get the percentage of requests to the
        /// mirror.
        public var runtimeFraction: Envoy_Config_Core_V3_RuntimeFractionalPercent {
          get {return _runtimeFraction ?? Envoy_Config_Core_V3_RuntimeFractionalPercent()}
          set {_runtimeFraction = newValue}
        }
        /// Returns true if `runtimeFraction` has been explicitly set.
        public var hasRuntimeFraction: Bool {return self._runtimeFraction != nil}
        /// Clears the value of `runtimeFraction`. Subsequent reads from it will return its default value.
        public mutating func clearRuntimeFraction() {self._runtimeFraction = nil}

        /// Set this to TRUE to only mirror write commands, this is effectively replicating the
        /// writes in a "fire and forget" manner.
        public var excludeReadCommands: Bool = false

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _runtimeFraction: Envoy_Config_Core_V3_RuntimeFractionalPercent? = nil
      }

      public init() {}
    }

    public init() {}

    fileprivate var _catchAllRoute: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route? = nil
  }

  public init() {}

  fileprivate var _settings: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings? = nil
  fileprivate var _prefixRoutes: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes? = nil
  fileprivate var _downstreamAuthPassword: Envoy_Config_Core_V3_DataSource? = nil
}

#if swift(>=4.2)

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings.ReadPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings.ReadPolicy] = [
    .master,
    .preferMaster,
    .replica,
    .preferReplica,
    .any,
  ]
}

#endif  // swift(>=4.2)

/// RedisProtocolOptions specifies Redis upstream protocol options. This object is used in
/// :ref:`typed_extension_protocol_options<envoy_api_field_config.cluster.v3.Cluster.typed_extension_protocol_options>`,
/// keyed by the name `envoy.filters.network.redis_proxy`.
public struct Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProtocolOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Upstream server password as defined by the `requirepass` directive
  /// <https://redis.io/topics/config>`_ in the server's configuration file.
  public var authPassword: Envoy_Config_Core_V3_DataSource {
    get {return _authPassword ?? Envoy_Config_Core_V3_DataSource()}
    set {_authPassword = newValue}
  }
  /// Returns true if `authPassword` has been explicitly set.
  public var hasAuthPassword: Bool {return self._authPassword != nil}
  /// Clears the value of `authPassword`. Subsequent reads from it will return its default value.
  public mutating func clearAuthPassword() {self._authPassword = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authPassword: Envoy_Config_Core_V3_DataSource? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.network.redis_proxy.v3"

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedisProxy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_prefix"),
    3: .same(proto: "settings"),
    4: .standard(proto: "latency_in_micros"),
    5: .standard(proto: "prefix_routes"),
    6: .standard(proto: "downstream_auth_password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.statPrefix)
      case 3: try decoder.decodeSingularMessageField(value: &self._settings)
      case 4: try decoder.decodeSingularBoolField(value: &self.latencyInMicros)
      case 5: try decoder.decodeSingularMessageField(value: &self._prefixRoutes)
      case 6: try decoder.decodeSingularMessageField(value: &self._downstreamAuthPassword)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.statPrefix, fieldNumber: 1)
    }
    if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.latencyInMicros != false {
      try visitor.visitSingularBoolField(value: self.latencyInMicros, fieldNumber: 4)
    }
    if let v = self._prefixRoutes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._downstreamAuthPassword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy, rhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy) -> Bool {
    if lhs.statPrefix != rhs.statPrefix {return false}
    if lhs._settings != rhs._settings {return false}
    if lhs.latencyInMicros != rhs.latencyInMicros {return false}
    if lhs._prefixRoutes != rhs._prefixRoutes {return false}
    if lhs._downstreamAuthPassword != rhs._downstreamAuthPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.protoMessageName + ".ConnPoolSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "op_timeout"),
    2: .standard(proto: "enable_hashtagging"),
    3: .standard(proto: "enable_redirection"),
    4: .standard(proto: "max_buffer_size_before_flush"),
    5: .standard(proto: "buffer_flush_timeout"),
    6: .standard(proto: "max_upstream_unknown_connections"),
    8: .standard(proto: "enable_command_stats"),
    7: .standard(proto: "read_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._opTimeout)
      case 2: try decoder.decodeSingularBoolField(value: &self.enableHashtagging)
      case 3: try decoder.decodeSingularBoolField(value: &self.enableRedirection)
      case 4: try decoder.decodeSingularUInt32Field(value: &self.maxBufferSizeBeforeFlush)
      case 5: try decoder.decodeSingularMessageField(value: &self._bufferFlushTimeout)
      case 6: try decoder.decodeSingularMessageField(value: &self._maxUpstreamUnknownConnections)
      case 7: try decoder.decodeSingularEnumField(value: &self.readPolicy)
      case 8: try decoder.decodeSingularBoolField(value: &self.enableCommandStats)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._opTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.enableHashtagging != false {
      try visitor.visitSingularBoolField(value: self.enableHashtagging, fieldNumber: 2)
    }
    if self.enableRedirection != false {
      try visitor.visitSingularBoolField(value: self.enableRedirection, fieldNumber: 3)
    }
    if self.maxBufferSizeBeforeFlush != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBufferSizeBeforeFlush, fieldNumber: 4)
    }
    if let v = self._bufferFlushTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._maxUpstreamUnknownConnections {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.readPolicy != .master {
      try visitor.visitSingularEnumField(value: self.readPolicy, fieldNumber: 7)
    }
    if self.enableCommandStats != false {
      try visitor.visitSingularBoolField(value: self.enableCommandStats, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings, rhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings) -> Bool {
    if lhs._opTimeout != rhs._opTimeout {return false}
    if lhs.enableHashtagging != rhs.enableHashtagging {return false}
    if lhs.enableRedirection != rhs.enableRedirection {return false}
    if lhs.maxBufferSizeBeforeFlush != rhs.maxBufferSizeBeforeFlush {return false}
    if lhs._bufferFlushTimeout != rhs._bufferFlushTimeout {return false}
    if lhs._maxUpstreamUnknownConnections != rhs._maxUpstreamUnknownConnections {return false}
    if lhs.enableCommandStats != rhs.enableCommandStats {return false}
    if lhs.readPolicy != rhs.readPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.ConnPoolSettings.ReadPolicy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MASTER"),
    1: .same(proto: "PREFER_MASTER"),
    2: .same(proto: "REPLICA"),
    3: .same(proto: "PREFER_REPLICA"),
    4: .same(proto: "ANY"),
  ]
}

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.protoMessageName + ".PrefixRoutes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "routes"),
    2: .standard(proto: "case_insensitive"),
    4: .standard(proto: "catch_all_route"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.routes)
      case 2: try decoder.decodeSingularBoolField(value: &self.caseInsensitive)
      case 4: try decoder.decodeSingularMessageField(value: &self._catchAllRoute)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 1)
    }
    if self.caseInsensitive != false {
      try visitor.visitSingularBoolField(value: self.caseInsensitive, fieldNumber: 2)
    }
    if let v = self._catchAllRoute {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes, rhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes) -> Bool {
    if lhs.routes != rhs.routes {return false}
    if lhs.caseInsensitive != rhs.caseInsensitive {return false}
    if lhs._catchAllRoute != rhs._catchAllRoute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.protoMessageName + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prefix"),
    2: .standard(proto: "remove_prefix"),
    3: .same(proto: "cluster"),
    4: .standard(proto: "request_mirror_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.prefix)
      case 2: try decoder.decodeSingularBoolField(value: &self.removePrefix)
      case 3: try decoder.decodeSingularStringField(value: &self.cluster)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.requestMirrorPolicy)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prefix.isEmpty {
      try visitor.visitSingularStringField(value: self.prefix, fieldNumber: 1)
    }
    if self.removePrefix != false {
      try visitor.visitSingularBoolField(value: self.removePrefix, fieldNumber: 2)
    }
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 3)
    }
    if !self.requestMirrorPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestMirrorPolicy, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route, rhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route) -> Bool {
    if lhs.prefix != rhs.prefix {return false}
    if lhs.removePrefix != rhs.removePrefix {return false}
    if lhs.cluster != rhs.cluster {return false}
    if lhs.requestMirrorPolicy != rhs.requestMirrorPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route.protoMessageName + ".RequestMirrorPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "runtime_fraction"),
    3: .standard(proto: "exclude_read_commands"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.cluster)
      case 2: try decoder.decodeSingularMessageField(value: &self._runtimeFraction)
      case 3: try decoder.decodeSingularBoolField(value: &self.excludeReadCommands)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if let v = self._runtimeFraction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.excludeReadCommands != false {
      try visitor.visitSingularBoolField(value: self.excludeReadCommands, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy, rhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProxy.PrefixRoutes.Route.RequestMirrorPolicy) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs._runtimeFraction != rhs._runtimeFraction {return false}
    if lhs.excludeReadCommands != rhs.excludeReadCommands {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProtocolOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RedisProtocolOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._authPassword)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._authPassword {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProtocolOptions, rhs: Envoy_Extensions_Filters_Network_RedisProxy_V3_RedisProtocolOptions) -> Bool {
    if lhs._authPassword != rhs._authPassword {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

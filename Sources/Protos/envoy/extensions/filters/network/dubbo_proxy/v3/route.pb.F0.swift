// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/network/dubbo_proxy/v3/route.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 6]
public struct Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the route configuration. Reserved for future use in asynchronous route discovery.
  public var name: String = String()

  /// The interface name of the service.
  public var interface: String = String()

  /// Which group does the interface belong to.
  public var group: String = String()

  /// The version number of the interface.
  public var version: String = String()

  /// The list of routes that will be matched, in order, against incoming requests. The first route
  /// that matches will be used.
  public var routes: [Envoy_Extensions_Filters_Network_DubboProxy_V3_Route] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Envoy_Extensions_Filters_Network_DubboProxy_V3_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Route matching parameters.
  public var match: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch {
    get {return _match ?? Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch()}
    set {_match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return self._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {self._match = nil}

  /// Route request to some upstream cluster.
  public var route: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction {
    get {return _route ?? Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  public var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  public mutating func clearRoute() {self._route = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _match: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch? = nil
  fileprivate var _route: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction? = nil
}

public struct Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Method level routing matching.
  public var method: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch {
    get {return _method ?? Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch()}
    set {_method = newValue}
  }
  /// Returns true if `method` has been explicitly set.
  public var hasMethod: Bool {return self._method != nil}
  /// Clears the value of `method`. Subsequent reads from it will return its default value.
  public mutating func clearMethod() {self._method = nil}

  /// Specifies a set of headers that the route should match on. The router will check the requestâ€™s
  /// headers against all the specified headers in the route config. A match will happen if all the
  /// headers in the route are present in the request with the same values (or based on presence if
  /// the value field is not in the config).
  public var headers: [Envoy_Config_Route_V3_HeaderMatcher] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _method: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch? = nil
}

public struct Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterSpecifier: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction.OneOf_ClusterSpecifier? = nil

  /// Indicates the upstream cluster to which the request should be routed.
  public var cluster: String {
    get {
      if case .cluster(let v)? = clusterSpecifier {return v}
      return String()
    }
    set {clusterSpecifier = .cluster(newValue)}
  }

  /// Multiple upstream clusters can be specified for a given route. The
  /// request is routed to one of the upstream clusters based on weights
  /// assigned to each cluster.
  /// Currently ClusterWeight only supports the name and weight fields.
  public var weightedClusters: Envoy_Config_Route_V3_WeightedCluster {
    get {
      if case .weightedClusters(let v)? = clusterSpecifier {return v}
      return Envoy_Config_Route_V3_WeightedCluster()
    }
    set {clusterSpecifier = .weightedClusters(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterSpecifier: Equatable {
    /// Indicates the upstream cluster to which the request should be routed.
    case cluster(String)
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster.
    /// Currently ClusterWeight only supports the name and weight fields.
    case weightedClusters(Envoy_Config_Route_V3_WeightedCluster)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction.OneOf_ClusterSpecifier, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction.OneOf_ClusterSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cluster, .cluster): return {
        guard case .cluster(let l) = lhs, case .cluster(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.weightedClusters, .weightedClusters): return {
        guard case .weightedClusters(let l) = lhs, case .weightedClusters(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

public struct Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the method.
  public var name: Envoy_Type_Matcher_V3_StringMatcher {
    get {return _name ?? Envoy_Type_Matcher_V3_StringMatcher()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  public var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  public mutating func clearName() {self._name = nil}

  /// Method parameter definition.
  /// The key is the parameter index, starting from 0.
  /// The value is the parameter matching type.
  public var paramsMatch: Dictionary<UInt32,Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The parameter matching type.
  public struct ParameterMatchSpecifier {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var parameterMatchSpecifier: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier.OneOf_ParameterMatchSpecifier? = nil

    /// If specified, header match will be performed based on the value of the header.
    public var exactMatch: String {
      get {
        if case .exactMatch(let v)? = parameterMatchSpecifier {return v}
        return String()
      }
      set {parameterMatchSpecifier = .exactMatch(newValue)}
    }

    /// If specified, header match will be performed based on range.
    /// The rule will match if the request header value is within this range.
    /// The entire request header value must represent an integer in base 10 notation: consisting
    /// of an optional plus or minus sign followed by a sequence of digits. The rule will not match
    /// if the header value does not represent an integer. Match will fail for empty values,
    /// floating point numbers or if only a subsequence of the header value is an integer.
    ///
    /// Examples:
    ///
    /// * For range [-10,0), route will match for header value -1, but not for 0,
    ///   "somestring", 10.9, "-1somestring"
    public var rangeMatch: Envoy_Type_V3_Int64Range {
      get {
        if case .rangeMatch(let v)? = parameterMatchSpecifier {return v}
        return Envoy_Type_V3_Int64Range()
      }
      set {parameterMatchSpecifier = .rangeMatch(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ParameterMatchSpecifier: Equatable {
      /// If specified, header match will be performed based on the value of the header.
      case exactMatch(String)
      /// If specified, header match will be performed based on range.
      /// The rule will match if the request header value is within this range.
      /// The entire request header value must represent an integer in base 10 notation: consisting
      /// of an optional plus or minus sign followed by a sequence of digits. The rule will not match
      /// if the header value does not represent an integer. Match will fail for empty values,
      /// floating point numbers or if only a subsequence of the header value is an integer.
      ///
      /// Examples:
      ///
      /// * For range [-10,0), route will match for header value -1, but not for 0,
      ///   "somestring", 10.9, "-1somestring"
      case rangeMatch(Envoy_Type_V3_Int64Range)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier.OneOf_ParameterMatchSpecifier, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier.OneOf_ParameterMatchSpecifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.exactMatch, .exactMatch): return {
          guard case .exactMatch(let l) = lhs, case .exactMatch(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.rangeMatch, .rangeMatch): return {
          guard case .rangeMatch(let l) = lhs, case .rangeMatch(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _name: Envoy_Type_Matcher_V3_StringMatcher? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.network.dubbo_proxy.v3"

extension Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "interface"),
    3: .same(proto: "group"),
    4: .same(proto: "version"),
    5: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.interface) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.group) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.routes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.interface.isEmpty {
      try visitor.visitSingularStringField(value: self.interface, fieldNumber: 2)
    }
    if !self.group.isEmpty {
      try visitor.visitSingularStringField(value: self.group, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteConfiguration, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteConfiguration) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.interface != rhs.interface {return false}
    if lhs.group != rhs.group {return false}
    if lhs.version != rhs.version {return false}
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_DubboProxy_V3_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "route"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._match) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._route) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._match {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_Route, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_Route) -> Bool {
    if lhs._match != rhs._match {return false}
    if lhs._route != rhs._route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._method) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._method {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteMatch) -> Bool {
    if lhs._method != rhs._method {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "weighted_clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.clusterSpecifier = .cluster(v)}
      }()
      case 2: try {
        var v: Envoy_Config_Route_V3_WeightedCluster?
        if let current = self.clusterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .weightedClusters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.clusterSpecifier = .weightedClusters(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.clusterSpecifier {
    case .cluster?: try {
      guard case .cluster(let v)? = self.clusterSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .weightedClusters?: try {
      guard case .weightedClusters(let v)? = self.clusterSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_RouteAction) -> Bool {
    if lhs.clusterSpecifier != rhs.clusterSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MethodMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "params_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier>.self, value: &self.paramsMatch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._name {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.paramsMatch.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufUInt32,Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier>.self, value: self.paramsMatch, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs.paramsMatch != rhs.paramsMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.protoMessageName + ".ParameterMatchSpecifier"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "exact_match"),
    4: .standard(proto: "range_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try {
        if self.parameterMatchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.parameterMatchSpecifier = .exactMatch(v)}
      }()
      case 4: try {
        var v: Envoy_Type_V3_Int64Range?
        if let current = self.parameterMatchSpecifier {
          try decoder.handleConflictingOneOf()
          if case .rangeMatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.parameterMatchSpecifier = .rangeMatch(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.parameterMatchSpecifier {
    case .exactMatch?: try {
      guard case .exactMatch(let v)? = self.parameterMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .rangeMatch?: try {
      guard case .rangeMatch(let v)? = self.parameterMatchSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier, rhs: Envoy_Extensions_Filters_Network_DubboProxy_V3_MethodMatch.ParameterMatchSpecifier) -> Bool {
    if lhs.parameterMatchSpecifier != rhs.parameterMatchSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

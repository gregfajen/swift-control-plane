// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/network/tcp_proxy/v3/tcp_proxy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 13]
public struct Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The prefix to use when emitting :ref:`statistics
  /// <config_network_filters_tcp_proxy_stats>`.
  public var statPrefix: String = String()

  public var clusterSpecifier: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.OneOf_ClusterSpecifier? = nil

  /// The upstream cluster to connect to.
  public var cluster: String {
    get {
      if case .cluster(let v)? = clusterSpecifier {return v}
      return String()
    }
    set {clusterSpecifier = .cluster(newValue)}
  }

  /// Multiple upstream clusters can be specified for a given route. The
  /// request is routed to one of the upstream clusters based on weights
  /// assigned to each cluster.
  public var weightedClusters: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster {
    get {
      if case .weightedClusters(let v)? = clusterSpecifier {return v}
      return Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster()
    }
    set {clusterSpecifier = .weightedClusters(newValue)}
  }

  /// Optional endpoint metadata match criteria. Only endpoints in the upstream
  /// cluster with metadata matching that set in metadata_match will be
  /// considered. The filter name should be specified as *envoy.lb*.
  public var metadataMatch: Envoy_Config_Core_V3_Metadata {
    get {return _metadataMatch ?? Envoy_Config_Core_V3_Metadata()}
    set {_metadataMatch = newValue}
  }
  /// Returns true if `metadataMatch` has been explicitly set.
  public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
  /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataMatch() {self._metadataMatch = nil}

  /// The idle timeout for connections managed by the TCP proxy filter. The idle timeout
  /// is defined as the period in which there are no bytes sent or received on either
  /// the upstream or downstream connection. If not set, the default idle timeout is 1 hour. If set
  /// to 0s, the timeout will be disabled.
  ///
  /// .. warning::
  ///   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
  ///   FIN packets, etc.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return self._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {self._idleTimeout = nil}

  /// [#not-implemented-hide:] The idle timeout for connections managed by the TCP proxy
  /// filter. The idle timeout is defined as the period in which there is no
  /// active traffic. If not set, there is no idle timeout. When the idle timeout
  /// is reached the connection will be closed. The distinction between
  /// downstream_idle_timeout/upstream_idle_timeout provides a means to set
  /// timeout based on the last byte sent on the downstream/upstream connection.
  public var downstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _downstreamIdleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_downstreamIdleTimeout = newValue}
  }
  /// Returns true if `downstreamIdleTimeout` has been explicitly set.
  public var hasDownstreamIdleTimeout: Bool {return self._downstreamIdleTimeout != nil}
  /// Clears the value of `downstreamIdleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearDownstreamIdleTimeout() {self._downstreamIdleTimeout = nil}

  /// [#not-implemented-hide:]
  public var upstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _upstreamIdleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_upstreamIdleTimeout = newValue}
  }
  /// Returns true if `upstreamIdleTimeout` has been explicitly set.
  public var hasUpstreamIdleTimeout: Bool {return self._upstreamIdleTimeout != nil}
  /// Clears the value of `upstreamIdleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamIdleTimeout() {self._upstreamIdleTimeout = nil}

  /// Configuration for :ref:`access logs <arch_overview_access_logs>`
  /// emitted by the this tcp_proxy.
  public var accessLog: [Envoy_Config_Accesslog_V3_AccessLog] = []

  /// The maximum number of unsuccessful connection attempts that will be made before
  /// giving up. If the parameter is not specified, 1 connection attempt will be made.
  public var maxConnectAttempts: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxConnectAttempts ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxConnectAttempts = newValue}
  }
  /// Returns true if `maxConnectAttempts` has been explicitly set.
  public var hasMaxConnectAttempts: Bool {return self._maxConnectAttempts != nil}
  /// Clears the value of `maxConnectAttempts`. Subsequent reads from it will return its default value.
  public mutating func clearMaxConnectAttempts() {self._maxConnectAttempts = nil}

  /// Optional configuration for TCP proxy hash policy. If hash_policy is not set, the hash-based
  /// load balancing algorithms will select a host randomly. Currently the number of hash policies is
  /// limited to 1.
  public var hashPolicy: [Envoy_Type_V3_HashPolicy] = []

  /// [#not-implemented-hide:] feature in progress
  /// If set, this configures tunneling, e.g. configuration options to tunnel multiple TCP
  /// payloads over a shared HTTP/2 tunnel. If this message is absent, the payload
  /// will be proxied upstream as per usual.
  public var tunnelingConfig: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.TunnelingConfig {
    get {return _tunnelingConfig ?? Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.TunnelingConfig()}
    set {_tunnelingConfig = newValue}
  }
  /// Returns true if `tunnelingConfig` has been explicitly set.
  public var hasTunnelingConfig: Bool {return self._tunnelingConfig != nil}
  /// Clears the value of `tunnelingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearTunnelingConfig() {self._tunnelingConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterSpecifier: Equatable {
    /// The upstream cluster to connect to.
    case cluster(String)
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster.
    case weightedClusters(Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.OneOf_ClusterSpecifier, rhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.OneOf_ClusterSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.cluster(let l), .cluster(let r)): return l == r
      case (.weightedClusters(let l), .weightedClusters(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Allows for specification of multiple upstream clusters along with weights
  /// that indicate the percentage of traffic to be forwarded to each cluster.
  /// The router selects an upstream cluster based on these weights.
  public struct WeightedCluster {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies one or more upstream clusters associated with the route.
    public var clusters: [Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster.ClusterWeight] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ClusterWeight {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Name of the upstream cluster.
      public var name: String = String()

      /// When a request matches the route, the choice of an upstream cluster is
      /// determined by its weight. The sum of weights across all entries in the
      /// clusters array determines the total weight.
      public var weight: UInt32 = 0

      /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints
      /// in the upstream cluster with metadata matching what is set in this field will be considered
      /// for load balancing. Note that this will be merged with what's provided in
      /// :ref:`TcpProxy.metadata_match
      /// <envoy_api_field_extensions.filters.network.tcp_proxy.v3.TcpProxy.metadata_match>`, with values
      /// here taking precedence. The filter name should be specified as *envoy.lb*.
      public var metadataMatch: Envoy_Config_Core_V3_Metadata {
        get {return _metadataMatch ?? Envoy_Config_Core_V3_Metadata()}
        set {_metadataMatch = newValue}
      }
      /// Returns true if `metadataMatch` has been explicitly set.
      public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
      /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
      public mutating func clearMetadataMatch() {self._metadataMatch = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _metadataMatch: Envoy_Config_Core_V3_Metadata? = nil
    }

    public init() {}
  }

  /// Configuration for tunneling TCP over other transports or application layers.
  /// Currently, only HTTP/2 is supported. When other options exist, HTTP/2 will
  /// remain the default.
  public struct TunnelingConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The hostname to send in the synthesized CONNECT headers to the upstream proxy.
    public var hostname: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _metadataMatch: Envoy_Config_Core_V3_Metadata? = nil
  fileprivate var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _downstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _upstreamIdleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxConnectAttempts: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _tunnelingConfig: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.TunnelingConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.network.tcp_proxy.v3"

extension Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TcpProxy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stat_prefix"),
    2: .same(proto: "cluster"),
    10: .standard(proto: "weighted_clusters"),
    9: .standard(proto: "metadata_match"),
    8: .standard(proto: "idle_timeout"),
    3: .standard(proto: "downstream_idle_timeout"),
    4: .standard(proto: "upstream_idle_timeout"),
    5: .standard(proto: "access_log"),
    7: .standard(proto: "max_connect_attempts"),
    11: .standard(proto: "hash_policy"),
    12: .standard(proto: "tunneling_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.statPrefix)
      case 2:
        if self.clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.clusterSpecifier = .cluster(v)}
      case 3: try decoder.decodeSingularMessageField(value: &self._downstreamIdleTimeout)
      case 4: try decoder.decodeSingularMessageField(value: &self._upstreamIdleTimeout)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.accessLog)
      case 7: try decoder.decodeSingularMessageField(value: &self._maxConnectAttempts)
      case 8: try decoder.decodeSingularMessageField(value: &self._idleTimeout)
      case 9: try decoder.decodeSingularMessageField(value: &self._metadataMatch)
      case 10:
        var v: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster?
        if let current = self.clusterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .weightedClusters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.clusterSpecifier = .weightedClusters(v)}
      case 11: try decoder.decodeRepeatedMessageField(value: &self.hashPolicy)
      case 12: try decoder.decodeSingularMessageField(value: &self._tunnelingConfig)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.statPrefix, fieldNumber: 1)
    }
    if case .cluster(let v)? = self.clusterSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._downstreamIdleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._upstreamIdleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.accessLog.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessLog, fieldNumber: 5)
    }
    if let v = self._maxConnectAttempts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._idleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if case .weightedClusters(let v)? = self.clusterSpecifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.hashPolicy.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hashPolicy, fieldNumber: 11)
    }
    if let v = self._tunnelingConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy, rhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy) -> Bool {
    if lhs.statPrefix != rhs.statPrefix {return false}
    if lhs.clusterSpecifier != rhs.clusterSpecifier {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs._idleTimeout != rhs._idleTimeout {return false}
    if lhs._downstreamIdleTimeout != rhs._downstreamIdleTimeout {return false}
    if lhs._upstreamIdleTimeout != rhs._upstreamIdleTimeout {return false}
    if lhs.accessLog != rhs.accessLog {return false}
    if lhs._maxConnectAttempts != rhs._maxConnectAttempts {return false}
    if lhs.hashPolicy != rhs.hashPolicy {return false}
    if lhs._tunnelingConfig != rhs._tunnelingConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.protoMessageName + ".WeightedCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.clusters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster, rhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster.ClusterWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster.protoMessageName + ".ClusterWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "weight"),
    3: .standard(proto: "metadata_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularUInt32Field(value: &self.weight)
      case 3: try decoder.decodeSingularMessageField(value: &self._metadataMatch)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.weight != 0 {
      try visitor.visitSingularUInt32Field(value: self.weight, fieldNumber: 2)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster.ClusterWeight, rhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.WeightedCluster.ClusterWeight) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.TunnelingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.protoMessageName + ".TunnelingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.hostname)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.TunnelingConfig, rhs: Envoy_Extensions_Filters_Network_TcpProxy_V3_TcpProxy.TunnelingConfig) -> Bool {
    if lhs.hostname != rhs.hostname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

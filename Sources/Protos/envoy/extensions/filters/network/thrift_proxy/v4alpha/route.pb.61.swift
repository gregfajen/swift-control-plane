// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/network/thrift_proxy/v4alpha/route.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the route configuration. Reserved for future use in asynchronous route discovery.
  public var name: String = String()

  /// The list of routes that will be matched, in order, against incoming requests. The first route
  /// that matches will be used.
  public var routes: [Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_Route] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_Route {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Route matching parameters.
  public var match: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch {
    get {return _match ?? Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch()}
    set {_match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return self._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {self._match = nil}

  /// Route request to some upstream cluster.
  public var route: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction {
    get {return _route ?? Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  public var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  public mutating func clearRoute() {self._route = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _match: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch? = nil
  fileprivate var _route: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction? = nil
}

public struct Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var matchSpecifier: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch.OneOf_MatchSpecifier? = nil

  /// If specified, the route must exactly match the request method name. As a special case, an
  /// empty string matches any request method name.
  public var methodName: String {
    get {
      if case .methodName(let v)? = matchSpecifier {return v}
      return String()
    }
    set {matchSpecifier = .methodName(newValue)}
  }

  /// If specified, the route must have the service name as the request method name prefix. As a
  /// special case, an empty string matches any service name. Only relevant when service
  /// multiplexing.
  public var serviceName: String {
    get {
      if case .serviceName(let v)? = matchSpecifier {return v}
      return String()
    }
    set {matchSpecifier = .serviceName(newValue)}
  }

  /// Inverts whatever matching is done in the :ref:`method_name
  /// <envoy_api_field_extensions.filters.network.thrift_proxy.v4alpha.RouteMatch.method_name>` or
  /// :ref:`service_name
  /// <envoy_api_field_extensions.filters.network.thrift_proxy.v4alpha.RouteMatch.service_name>` fields.
  /// Cannot be combined with wildcard matching as that would result in routes never being matched.
  ///
  /// .. note::
  ///
  ///   This does not invert matching done as part of the :ref:`headers field
  ///   <envoy_api_field_extensions.filters.network.thrift_proxy.v4alpha.RouteMatch.headers>` field. To
  ///   invert header matching, see :ref:`invert_match
  ///   <envoy_api_field_config.route.v4alpha.HeaderMatcher.invert_match>`.
  public var invert: Bool = false

  /// Specifies a set of headers that the route should match on. The router will check the requestâ€™s
  /// headers against all the specified headers in the route config. A match will happen if all the
  /// headers in the route are present in the request with the same values (or based on presence if
  /// the value field is not in the config). Note that this only applies for Thrift transports and/or
  /// protocols that support headers.
  public var headers: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MatchSpecifier: Equatable {
    /// If specified, the route must exactly match the request method name. As a special case, an
    /// empty string matches any request method name.
    case methodName(String)
    /// If specified, the route must have the service name as the request method name prefix. As a
    /// special case, an empty string matches any service name. Only relevant when service
    /// multiplexing.
    case serviceName(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch.OneOf_MatchSpecifier, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch.OneOf_MatchSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.methodName(let l), .methodName(let r)): return l == r
      case (.serviceName(let l), .serviceName(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// [#next-free-field: 7]
public struct Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var clusterSpecifier: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction.OneOf_ClusterSpecifier? = nil

  /// Indicates a single upstream cluster to which the request should be routed
  /// to.
  public var cluster: String {
    get {
      if case .cluster(let v)? = clusterSpecifier {return v}
      return String()
    }
    set {clusterSpecifier = .cluster(newValue)}
  }

  /// Multiple upstream clusters can be specified for a given route. The
  /// request is routed to one of the upstream clusters based on weights
  /// assigned to each cluster.
  public var weightedClusters: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster {
    get {
      if case .weightedClusters(let v)? = clusterSpecifier {return v}
      return Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster()
    }
    set {clusterSpecifier = .weightedClusters(newValue)}
  }

  /// Envoy will determine the cluster to route to by reading the value of the
  /// Thrift header named by cluster_header from the request headers. If the
  /// header is not found or the referenced cluster does not exist Envoy will
  /// respond with an unknown method exception or an internal error exception,
  /// respectively.
  public var clusterHeader: String {
    get {
      if case .clusterHeader(let v)? = clusterSpecifier {return v}
      return String()
    }
    set {clusterSpecifier = .clusterHeader(newValue)}
  }

  /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
  /// the upstream cluster with metadata matching what is set in this field will be considered.
  /// Note that this will be merged with what's provided in :ref:`WeightedCluster.metadata_match
  /// <envoy_api_field_extensions.filters.network.thrift_proxy.v4alpha.WeightedCluster.ClusterWeight.metadata_match>`,
  /// with values there taking precedence. Keys and values should be provided under the "envoy.lb"
  /// metadata key.
  public var metadataMatch: Envoy_Config_Core_V4alpha_Metadata {
    get {return _metadataMatch ?? Envoy_Config_Core_V4alpha_Metadata()}
    set {_metadataMatch = newValue}
  }
  /// Returns true if `metadataMatch` has been explicitly set.
  public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
  /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataMatch() {self._metadataMatch = nil}

  /// Specifies a set of rate limit configurations that could be applied to the route.
  /// N.B. Thrift service or method name matching can be achieved by specifying a RequestHeaders
  /// action with the header name ":method-name".
  public var rateLimits: [Envoy_Config_Route_V4alpha_RateLimit] = []

  /// Strip the service prefix from the method name, if there's a prefix. For
  /// example, the method call Service:method would end up being just method.
  public var stripServiceName: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ClusterSpecifier: Equatable {
    /// Indicates a single upstream cluster to which the request should be routed
    /// to.
    case cluster(String)
    /// Multiple upstream clusters can be specified for a given route. The
    /// request is routed to one of the upstream clusters based on weights
    /// assigned to each cluster.
    case weightedClusters(Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster)
    /// Envoy will determine the cluster to route to by reading the value of the
    /// Thrift header named by cluster_header from the request headers. If the
    /// header is not found or the referenced cluster does not exist Envoy will
    /// respond with an unknown method exception or an internal error exception,
    /// respectively.
    case clusterHeader(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction.OneOf_ClusterSpecifier, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction.OneOf_ClusterSpecifier) -> Bool {
      switch (lhs, rhs) {
      case (.cluster(let l), .cluster(let r)): return l == r
      case (.weightedClusters(let l), .weightedClusters(let r)): return l == r
      case (.clusterHeader(let l), .clusterHeader(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _metadataMatch: Envoy_Config_Core_V4alpha_Metadata? = nil
}

/// Allows for specification of multiple upstream clusters along with weights that indicate the
/// percentage of traffic to be forwarded to each cluster. The router selects an upstream cluster
/// based on these weights.
public struct Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies one or more upstream clusters associated with the route.
  public var clusters: [Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster.ClusterWeight] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ClusterWeight {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the upstream cluster.
    public var name: String = String()

    /// When a request matches the route, the choice of an upstream cluster is determined by its
    /// weight. The sum of weights across all entries in the clusters array determines the total
    /// weight.
    public var weight: SwiftProtobuf.Google_Protobuf_UInt32Value {
      get {return _weight ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
      set {_weight = newValue}
    }
    /// Returns true if `weight` has been explicitly set.
    public var hasWeight: Bool {return self._weight != nil}
    /// Clears the value of `weight`. Subsequent reads from it will return its default value.
    public mutating func clearWeight() {self._weight = nil}

    /// Optional endpoint metadata match criteria used by the subset load balancer. Only endpoints in
    /// the upstream cluster with metadata matching what is set in this field, combined with what's
    /// provided in :ref:`RouteAction's metadata_match
    /// <envoy_api_field_extensions.filters.network.thrift_proxy.v4alpha.RouteAction.metadata_match>`,
    /// will be considered. Values here will take precedence. Keys and values should be provided
    /// under the "envoy.lb" metadata key.
    public var metadataMatch: Envoy_Config_Core_V4alpha_Metadata {
      get {return _metadataMatch ?? Envoy_Config_Core_V4alpha_Metadata()}
      set {_metadataMatch = newValue}
    }
    /// Returns true if `metadataMatch` has been explicitly set.
    public var hasMetadataMatch: Bool {return self._metadataMatch != nil}
    /// Clears the value of `metadataMatch`. Subsequent reads from it will return its default value.
    public mutating func clearMetadataMatch() {self._metadataMatch = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _weight: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
    fileprivate var _metadataMatch: Envoy_Config_Core_V4alpha_Metadata? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.network.thrift_proxy.v4alpha"

extension Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "routes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.routes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.routes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.routes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteConfiguration, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteConfiguration) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.routes != rhs.routes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_Route: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Route"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "route"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._match)
      case 2: try decoder.decodeSingularMessageField(value: &self._route)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._match {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_Route, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_Route) -> Bool {
    if lhs._match != rhs._match {return false}
    if lhs._route != rhs._route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteMatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "method_name"),
    2: .standard(proto: "service_name"),
    3: .same(proto: "invert"),
    4: .same(proto: "headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.matchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.matchSpecifier = .methodName(v)}
      case 2:
        if self.matchSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.matchSpecifier = .serviceName(v)}
      case 3: try decoder.decodeSingularBoolField(value: &self.invert)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.headers)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.matchSpecifier {
    case .methodName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .serviceName(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case nil: break
    }
    if self.invert != false {
      try visitor.visitSingularBoolField(value: self.invert, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteMatch) -> Bool {
    if lhs.matchSpecifier != rhs.matchSpecifier {return false}
    if lhs.invert != rhs.invert {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RouteAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "weighted_clusters"),
    6: .standard(proto: "cluster_header"),
    3: .standard(proto: "metadata_match"),
    4: .standard(proto: "rate_limits"),
    5: .standard(proto: "strip_service_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.clusterSpecifier = .cluster(v)}
      case 2:
        var v: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster?
        if let current = self.clusterSpecifier {
          try decoder.handleConflictingOneOf()
          if case .weightedClusters(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.clusterSpecifier = .weightedClusters(v)}
      case 3: try decoder.decodeSingularMessageField(value: &self._metadataMatch)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.rateLimits)
      case 5: try decoder.decodeSingularBoolField(value: &self.stripServiceName)
      case 6:
        if self.clusterSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.clusterSpecifier = .clusterHeader(v)}
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.clusterSpecifier {
    case .cluster(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    case .weightedClusters(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    default: break
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.rateLimits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rateLimits, fieldNumber: 4)
    }
    if self.stripServiceName != false {
      try visitor.visitSingularBoolField(value: self.stripServiceName, fieldNumber: 5)
    }
    if case .clusterHeader(let v)? = self.clusterSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_RouteAction) -> Bool {
    if lhs.clusterSpecifier != rhs.clusterSpecifier {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs.rateLimits != rhs.rateLimits {return false}
    if lhs.stripServiceName != rhs.stripServiceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WeightedCluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.clusters)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster.ClusterWeight: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster.protoMessageName + ".ClusterWeight"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "weight"),
    3: .standard(proto: "metadata_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularMessageField(value: &self._weight)
      case 3: try decoder.decodeSingularMessageField(value: &self._metadataMatch)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._weight {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._metadataMatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster.ClusterWeight, rhs: Envoy_Extensions_Filters_Network_ThriftProxy_V4alpha_WeightedCluster.ClusterWeight) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs._metadataMatch != rhs._metadataMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

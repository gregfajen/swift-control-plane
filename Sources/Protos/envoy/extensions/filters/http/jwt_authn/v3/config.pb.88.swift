// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/http/jwt_authn/v3/config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Please see following for JWT authentication flow:
///
/// * `JSON Web Token (JWT) <https://tools.ietf.org/html/rfc7519>`_
/// * `The OAuth 2.0 Authorization Framework <https://tools.ietf.org/html/rfc6749>`_
/// * `OpenID Connect <http://openid.net/connect>`_
///
/// A JwtProvider message specifies how a JSON Web Token (JWT) can be verified. It specifies:
///
/// * issuer: the principal that issues the JWT. It has to match the one from the token.
/// * allowed audiences: the ones in the token have to be listed here.
/// * how to fetch public key JWKS to verify the token signature.
/// * how to extract JWT token in the request.
/// * how to pass successfully verified token payload.
///
/// Example:
///
/// .. code-block:: yaml
///
///     issuer: https://example.com
///     audiences:
///     - bookstore_android.apps.googleusercontent.com
///     - bookstore_web.apps.googleusercontent.com
///     remote_jwks:
///       http_uri:
///         uri: https://example.com/.well-known/jwks.json
///         cluster: example_jwks_cluster
///       cache_duration:
///         seconds: 300
///
/// [#next-free-field: 10]
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify the `principal <https://tools.ietf.org/html/rfc7519#section-4.1.1>`_ that issued
  /// the JWT, usually a URL or an email address.
  ///
  /// Example: https://securetoken.google.com
  /// Example: 1234567-compute@developer.gserviceaccount.com
  public var issuer: String = String()

  /// The list of JWT `audiences <https://tools.ietf.org/html/rfc7519#section-4.1.3>`_ are
  /// allowed to access. A JWT containing any of these audiences will be accepted. If not specified,
  /// will not check audiences in the token.
  ///
  /// Example:
  ///
  /// .. code-block:: yaml
  ///
  ///     audiences:
  ///     - bookstore_android.apps.googleusercontent.com
  ///     - bookstore_web.apps.googleusercontent.com
  public var audiences: [String] = []

  /// `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
  /// validate signature of a JWT. This field specifies where to fetch JWKS.
  public var jwksSourceSpecifier: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider.OneOf_JwksSourceSpecifier? = nil

  /// JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
  /// URI and how the fetched JWKS should be cached.
  ///
  /// Example:
  ///
  /// .. code-block:: yaml
  ///
  ///    remote_jwks:
  ///      http_uri:
  ///        uri: https://www.googleapis.com/oauth2/v1/certs
  ///        cluster: jwt.www.googleapis.com|443
  ///      cache_duration:
  ///        seconds: 300
  public var remoteJwks: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks {
    get {
      if case .remoteJwks(let v)? = jwksSourceSpecifier {return v}
      return Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks()
    }
    set {jwksSourceSpecifier = .remoteJwks(newValue)}
  }

  /// JWKS is in local data source. It could be either in a local file or embedded in the
  /// inline_string.
  ///
  /// Example: local file
  ///
  /// .. code-block:: yaml
  ///
  ///    local_jwks:
  ///      filename: /etc/envoy/jwks/jwks1.txt
  ///
  /// Example: inline_string
  ///
  /// .. code-block:: yaml
  ///
  ///    local_jwks:
  ///      inline_string: ACADADADADA
  public var localJwks: Envoy_Config_Core_V3_DataSource {
    get {
      if case .localJwks(let v)? = jwksSourceSpecifier {return v}
      return Envoy_Config_Core_V3_DataSource()
    }
    set {jwksSourceSpecifier = .localJwks(newValue)}
  }

  /// If false, the JWT is removed in the request after a success verification. If true, the JWT is
  /// not removed in the request. Default value is false.
  public var forward: Bool = false

  /// Two fields below define where to extract the JWT from an HTTP request.
  ///
  /// If no explicit location is specified, the following default locations are tried in order:
  ///
  /// 1. The Authorization header using the `Bearer schema
  /// <https://tools.ietf.org/html/rfc6750#section-2.1>`_. Example::
  ///
  ///    Authorization: Bearer <token>.
  ///
  /// 2. `access_token <https://tools.ietf.org/html/rfc6750#section-2.3>`_ query parameter.
  ///
  /// Multiple JWTs can be verified for a request. Each JWT has to be extracted from the locations
  /// its provider specified or from the default locations.
  ///
  /// Specify the HTTP headers to extract JWT token. For examples, following config:
  ///
  /// .. code-block:: yaml
  ///
  ///   from_headers:
  ///   - name: x-goog-iap-jwt-assertion
  ///
  /// can be used to extract token from header::
  ///
  ///   ``x-goog-iap-jwt-assertion: <JWT>``.
  public var fromHeaders: [Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtHeader] = []

  /// JWT is sent in a query parameter. `jwt_params` represents the query parameter names.
  ///
  /// For example, if config is:
  ///
  /// .. code-block:: yaml
  ///
  ///   from_params:
  ///   - jwt_token
  ///
  /// The JWT format in query parameter is::
  ///
  ///    /path?jwt_token=<JWT>
  public var fromParams: [String] = []

  /// This field specifies the header name to forward a successfully verified JWT payload to the
  /// backend. The forwarded data is::
  ///
  ///    base64url_encoded(jwt_payload_in_JSON)
  ///
  /// If it is not specified, the payload will not be forwarded.
  public var forwardPayloadHeader: String = String()

  /// If non empty, successfully verified JWT payloads will be written to StreamInfo DynamicMetadata
  /// in the format as: *namespace* is the jwt_authn filter name as **envoy.filters.http.jwt_authn**
  /// The value is the *protobuf::Struct*. The value of this field will be the key for its *fields*
  /// and the value is the *protobuf::Struct* converted from JWT JSON payload.
  ///
  /// For example, if payload_in_metadata is *my_payload*:
  ///
  /// .. code-block:: yaml
  ///
  ///   envoy.filters.http.jwt_authn:
  ///     my_payload:
  ///       iss: https://example.com
  ///       sub: test@example.com
  ///       aud: https://example.com
  ///       exp: 1501281058
  public var payloadInMetadata: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// `JSON Web Key Set (JWKS) <https://tools.ietf.org/html/rfc7517#appendix-A>`_ is needed to
  /// validate signature of a JWT. This field specifies where to fetch JWKS.
  public enum OneOf_JwksSourceSpecifier: Equatable {
    /// JWKS can be fetched from remote server via HTTP/HTTPS. This field specifies the remote HTTP
    /// URI and how the fetched JWKS should be cached.
    ///
    /// Example:
    ///
    /// .. code-block:: yaml
    ///
    ///    remote_jwks:
    ///      http_uri:
    ///        uri: https://www.googleapis.com/oauth2/v1/certs
    ///        cluster: jwt.www.googleapis.com|443
    ///      cache_duration:
    ///        seconds: 300
    case remoteJwks(Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks)
    /// JWKS is in local data source. It could be either in a local file or embedded in the
    /// inline_string.
    ///
    /// Example: local file
    ///
    /// .. code-block:: yaml
    ///
    ///    local_jwks:
    ///      filename: /etc/envoy/jwks/jwks1.txt
    ///
    /// Example: inline_string
    ///
    /// .. code-block:: yaml
    ///
    ///    local_jwks:
    ///      inline_string: ACADADADADA
    case localJwks(Envoy_Config_Core_V3_DataSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider.OneOf_JwksSourceSpecifier, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider.OneOf_JwksSourceSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.remoteJwks, .remoteJwks): return {
        guard case .remoteJwks(let l) = lhs, case .remoteJwks(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.localJwks, .localJwks): return {
        guard case .localJwks(let l) = lhs, case .localJwks(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// This message specifies how to fetch JWKS from remote and how to cache it.
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP URI to fetch the JWKS. For example:
  ///
  /// .. code-block:: yaml
  ///
  ///    http_uri:
  ///      uri: https://www.googleapis.com/oauth2/v1/certs
  ///      cluster: jwt.www.googleapis.com|443
  public var httpUri: Envoy_Config_Core_V3_HttpUri {
    get {return _httpUri ?? Envoy_Config_Core_V3_HttpUri()}
    set {_httpUri = newValue}
  }
  /// Returns true if `httpUri` has been explicitly set.
  public var hasHTTPUri: Bool {return self._httpUri != nil}
  /// Clears the value of `httpUri`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPUri() {self._httpUri = nil}

  /// Duration after which the cached JWKS should be expired. If not specified, default cache
  /// duration is 5 minutes.
  public var cacheDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _cacheDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_cacheDuration = newValue}
  }
  /// Returns true if `cacheDuration` has been explicitly set.
  public var hasCacheDuration: Bool {return self._cacheDuration != nil}
  /// Clears the value of `cacheDuration`. Subsequent reads from it will return its default value.
  public mutating func clearCacheDuration() {self._cacheDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _httpUri: Envoy_Config_Core_V3_HttpUri? = nil
  fileprivate var _cacheDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// This message specifies a header location to extract JWT token.
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP header name.
  public var name: String = String()

  /// The value prefix. The value format is "value_prefix<token>"
  /// For example, for "Authorization: Bearer <token>", value_prefix="Bearer " with a space at the
  /// end.
  public var valuePrefix: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specify a required provider with audiences.
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify a required provider name.
  public var providerName: String = String()

  /// This field overrides the one specified in the JwtProvider.
  public var audiences: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This message specifies a Jwt requirement. An empty message means JWT verification is not
/// required. Here are some config examples:
///
/// .. code-block:: yaml
///
///  # Example 1: not required with an empty message
///
///  # Example 2: require A
///  provider_name: provider-A
///
///  # Example 3: require A or B
///  requires_any:
///    requirements:
///      - provider_name: provider-A
///      - provider_name: provider-B
///
///  # Example 4: require A and B
///  requires_all:
///    requirements:
///      - provider_name: provider-A
///      - provider_name: provider-B
///
///  # Example 5: require A and (B or C)
///  requires_all:
///    requirements:
///      - provider_name: provider-A
///      - requires_any:
///        requirements:
///          - provider_name: provider-B
///          - provider_name: provider-C
///
///  # Example 6: require A or (B and C)
///  requires_any:
///    requirements:
///      - provider_name: provider-A
///      - requires_all:
///        requirements:
///          - provider_name: provider-B
///          - provider_name: provider-C
///
///  # Example 7: A is optional (if token from A is provided, it must be valid, but also allows
///  missing token.)
///  requires_any:
///    requirements:
///    - provider_name: provider-A
///    - allow_missing: {}
///
///  # Example 8: A is optional and B is required.
///  requires_all:
///    requirements:
///    - requires_any:
///        requirements:
///        - provider_name: provider-A
///        - allow_missing: {}
///    - provider_name: provider-B
///
/// [#next-free-field: 7]
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requiresType: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement.OneOf_RequiresType? = nil

  /// Specify a required provider name.
  public var providerName: String {
    get {
      if case .providerName(let v)? = requiresType {return v}
      return String()
    }
    set {requiresType = .providerName(newValue)}
  }

  /// Specify a required provider with audiences.
  public var providerAndAudiences: Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences {
    get {
      if case .providerAndAudiences(let v)? = requiresType {return v}
      return Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences()
    }
    set {requiresType = .providerAndAudiences(newValue)}
  }

  /// Specify list of JwtRequirement. Their results are OR-ed.
  /// If any one of them passes, the result is passed.
  public var requiresAny: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList {
    get {
      if case .requiresAny(let v)? = requiresType {return v}
      return Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList()
    }
    set {requiresType = .requiresAny(newValue)}
  }

  /// Specify list of JwtRequirement. Their results are AND-ed.
  /// All of them must pass, if one of them fails or missing, it fails.
  public var requiresAll: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList {
    get {
      if case .requiresAll(let v)? = requiresType {return v}
      return Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList()
    }
    set {requiresType = .requiresAll(newValue)}
  }

  /// The requirement is always satisfied even if JWT is missing or the JWT
  /// verification fails. A typical usage is: this filter is used to only verify
  /// JWTs and pass the verified JWT payloads to another filter, the other filter
  /// will make decision. In this mode, all JWT tokens will be verified.
  public var allowMissingOrFailed: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .allowMissingOrFailed(let v)? = requiresType {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {requiresType = .allowMissingOrFailed(newValue)}
  }

  /// The requirement is satisfied if JWT is missing, but failed if JWT is
  /// presented but invalid. Similar to allow_missing_or_failed, this is used
  /// to only verify JWTs and pass the verified payload to another filter. The
  /// different is this mode will reject requests with invalid tokens.
  public var allowMissing: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .allowMissing(let v)? = requiresType {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {requiresType = .allowMissing(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RequiresType: Equatable {
    /// Specify a required provider name.
    case providerName(String)
    /// Specify a required provider with audiences.
    case providerAndAudiences(Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences)
    /// Specify list of JwtRequirement. Their results are OR-ed.
    /// If any one of them passes, the result is passed.
    case requiresAny(Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList)
    /// Specify list of JwtRequirement. Their results are AND-ed.
    /// All of them must pass, if one of them fails or missing, it fails.
    case requiresAll(Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList)
    /// The requirement is always satisfied even if JWT is missing or the JWT
    /// verification fails. A typical usage is: this filter is used to only verify
    /// JWTs and pass the verified JWT payloads to another filter, the other filter
    /// will make decision. In this mode, all JWT tokens will be verified.
    case allowMissingOrFailed(SwiftProtobuf.Google_Protobuf_Empty)
    /// The requirement is satisfied if JWT is missing, but failed if JWT is
    /// presented but invalid. Similar to allow_missing_or_failed, this is used
    /// to only verify JWTs and pass the verified payload to another filter. The
    /// different is this mode will reject requests with invalid tokens.
    case allowMissing(SwiftProtobuf.Google_Protobuf_Empty)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement.OneOf_RequiresType, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement.OneOf_RequiresType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.providerName, .providerName): return {
        guard case .providerName(let l) = lhs, case .providerName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.providerAndAudiences, .providerAndAudiences): return {
        guard case .providerAndAudiences(let l) = lhs, case .providerAndAudiences(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requiresAny, .requiresAny): return {
        guard case .requiresAny(let l) = lhs, case .requiresAny(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requiresAll, .requiresAll): return {
        guard case .requiresAll(let l) = lhs, case .requiresAll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.allowMissingOrFailed, .allowMissingOrFailed): return {
        guard case .allowMissingOrFailed(let l) = lhs, case .allowMissingOrFailed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.allowMissing, .allowMissing): return {
        guard case .allowMissing(let l) = lhs, case .allowMissing(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// This message specifies a list of RequiredProvider.
/// Their results are OR-ed; if any one of them passes, the result is passed
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify a list of JwtRequirement.
  public var requirements: [Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This message specifies a list of RequiredProvider.
/// Their results are AND-ed; all of them must pass, if one of them fails or missing, it fails.
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specify a list of JwtRequirement.
  public var requirements: [Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This message specifies a Jwt requirement for a specific Route condition.
/// Example 1:
///
/// .. code-block:: yaml
///
///    - match:
///        prefix: /healthz
///
/// In above example, "requires" field is empty for /healthz prefix match,
/// it means that requests matching the path prefix don't require JWT authentication.
///
/// Example 2:
///
/// .. code-block:: yaml
///
///    - match:
///        prefix: /
///      requires: { provider_name: provider-A }
///
/// In above example, all requests matched the path prefix require jwt authentication
/// from "provider-A".
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The route matching parameter. Only when the match is satisfied, the "requires" field will
  /// apply.
  ///
  /// For example: following match will match all requests.
  ///
  /// .. code-block:: yaml
  ///
  ///    match:
  ///      prefix: /
  public var match: Envoy_Config_Route_V3_RouteMatch {
    get {return _match ?? Envoy_Config_Route_V3_RouteMatch()}
    set {_match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return self._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {self._match = nil}

  /// Specify a Jwt requirement.
  /// If not specified, Jwt verification is disabled.
  public var requirementType: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule.OneOf_RequirementType? = nil

  /// Specify a Jwt requirement. Please see detail comment in message JwtRequirement.
  public var requires: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement {
    get {
      if case .requires(let v)? = requirementType {return v}
      return Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement()
    }
    set {requirementType = .requires(newValue)}
  }

  /// Use requirement_name to specify a Jwt requirement.
  /// This requirement_name MUST be specified at the
  /// :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
  /// in `JwtAuthentication`.
  public var requirementName: String {
    get {
      if case .requirementName(let v)? = requirementType {return v}
      return String()
    }
    set {requirementType = .requirementName(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify a Jwt requirement.
  /// If not specified, Jwt verification is disabled.
  public enum OneOf_RequirementType: Equatable {
    /// Specify a Jwt requirement. Please see detail comment in message JwtRequirement.
    case requires(Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement)
    /// Use requirement_name to specify a Jwt requirement.
    /// This requirement_name MUST be specified at the
    /// :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
    /// in `JwtAuthentication`.
    case requirementName(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule.OneOf_RequirementType, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule.OneOf_RequirementType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.requires, .requires): return {
        guard case .requires(let l) = lhs, case .requires(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requirementName, .requirementName): return {
        guard case .requirementName(let l) = lhs, case .requirementName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _match: Envoy_Config_Route_V3_RouteMatch? = nil
}

/// This message specifies Jwt requirements based on stream_info.filterState.
/// This FilterState should use `Router::StringAccessor` object to set a string value.
/// Other HTTP filters can use it to specify Jwt requirements dynamically.
///
/// Example:
///
/// .. code-block:: yaml
///
///    name: jwt_selector
///    requires:
///      issuer_1:
///        provider_name: issuer1
///      issuer_2:
///        provider_name: issuer2
///
/// If a filter set "jwt_selector" with "issuer_1" to FilterState for a request,
/// jwt_authn filter will use JwtRequirement{"provider_name": "issuer1"} to verify.
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The filter state name to retrieve the `Router::StringAccessor` object.
  public var name: String = String()

  /// A map of string keys to requirements. The string key is the string value
  /// in the FilterState with the name specified in the *name* field above.
  public var requires: Dictionary<String,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This is the Envoy HTTP filter config for JWT authentication.
///
/// For example:
///
/// .. code-block:: yaml
///
///   providers:
///      provider1:
///        issuer: issuer1
///        audiences:
///        - audience1
///        - audience2
///        remote_jwks:
///          http_uri:
///            uri: https://example.com/.well-known/jwks.json
///            cluster: example_jwks_cluster
///      provider2:
///        issuer: issuer2
///        local_jwks:
///          inline_string: jwks_string
///
///   rules:
///      # Not jwt verification is required for /health path
///      - match:
///          prefix: /health
///
///      # Jwt verification for provider1 is required for path prefixed with "prefix"
///      - match:
///          prefix: /prefix
///        requires:
///          provider_name: provider1
///
///      # Jwt verification for either provider1 or provider2 is required for all other requests.
///      - match:
///          prefix: /
///        requires:
///          requires_any:
///            requirements:
///              - provider_name: provider1
///              - provider_name: provider2
///
/// [#next-free-field: 6]
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtAuthentication {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of provider names to JwtProviders.
  ///
  /// .. code-block:: yaml
  ///
  ///   providers:
  ///     provider1:
  ///        issuer: issuer1
  ///        audiences:
  ///        - audience1
  ///        - audience2
  ///        remote_jwks:
  ///          http_uri:
  ///            uri: https://example.com/.well-known/jwks.json
  ///            cluster: example_jwks_cluster
  ///      provider2:
  ///        issuer: provider2
  ///        local_jwks:
  ///          inline_string: jwks_string
  public var providers: Dictionary<String,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider> = [:]

  /// Specifies requirements based on the route matches. The first matched requirement will be
  /// applied. If there are overlapped match conditions, please put the most specific match first.
  ///
  /// Examples
  ///
  /// .. code-block:: yaml
  ///
  ///   rules:
  ///     - match:
  ///         prefix: /healthz
  ///     - match:
  ///         prefix: /baz
  ///       requires:
  ///         provider_name: provider1
  ///     - match:
  ///         prefix: /foo
  ///       requires:
  ///         requires_any:
  ///           requirements:
  ///             - provider_name: provider1
  ///             - provider_name: provider2
  ///     - match:
  ///         prefix: /bar
  ///       requires:
  ///         requires_all:
  ///           requirements:
  ///             - provider_name: provider1
  ///             - provider_name: provider2
  public var rules: [Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule] = []

  /// This message specifies Jwt requirements based on stream_info.filterState.
  /// Other HTTP filters can use it to specify Jwt requirements dynamically.
  /// The *rules* field above is checked first, if it could not find any matches,
  /// check this one.
  public var filterStateRules: Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule {
    get {return _filterStateRules ?? Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule()}
    set {_filterStateRules = newValue}
  }
  /// Returns true if `filterStateRules` has been explicitly set.
  public var hasFilterStateRules: Bool {return self._filterStateRules != nil}
  /// Clears the value of `filterStateRules`. Subsequent reads from it will return its default value.
  public mutating func clearFilterStateRules() {self._filterStateRules = nil}

  /// When set to true, bypass the `CORS preflight request
  /// <http://www.w3.org/TR/cors/#cross-origin-request-with-preflight>`_ regardless of JWT
  /// requirements specified in the rules.
  public var bypassCorsPreflight: Bool = false

  /// A map of unique requirement_names to JwtRequirements.
  /// :ref:`requirement_name <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.PerRouteConfig.requirement_name>`
  /// in `PerRouteConfig` uses this map to specify a JwtRequirement.
  public var requirementMap: Dictionary<String,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _filterStateRules: Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule? = nil
}

/// Specify per-route config.
public struct Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requirementSpecifier: Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig.OneOf_RequirementSpecifier? = nil

  /// Disable Jwt Authentication for this route.
  public var disabled: Bool {
    get {
      if case .disabled(let v)? = requirementSpecifier {return v}
      return false
    }
    set {requirementSpecifier = .disabled(newValue)}
  }

  /// Use requirement_name to specify a JwtRequirement.
  /// This requirement_name MUST be specified at the
  /// :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
  /// in `JwtAuthentication`. If no, the requests using this route will be rejected with 403.
  public var requirementName: String {
    get {
      if case .requirementName(let v)? = requirementSpecifier {return v}
      return String()
    }
    set {requirementSpecifier = .requirementName(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_RequirementSpecifier: Equatable {
    /// Disable Jwt Authentication for this route.
    case disabled(Bool)
    /// Use requirement_name to specify a JwtRequirement.
    /// This requirement_name MUST be specified at the
    /// :ref:`requirement_map <envoy_v3_api_field_extensions.filters.http.jwt_authn.v3.JwtAuthentication.requirement_map>`
    /// in `JwtAuthentication`. If no, the requests using this route will be rejected with 403.
    case requirementName(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig.OneOf_RequirementSpecifier, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig.OneOf_RequirementSpecifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.disabled, .disabled): return {
        guard case .disabled(let l) = lhs, case .disabled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requirementName, .requirementName): return {
        guard case .requirementName(let l) = lhs, case .requirementName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.http.jwt_authn.v3"

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JwtProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "audiences"),
    3: .standard(proto: "remote_jwks"),
    4: .standard(proto: "local_jwks"),
    5: .same(proto: "forward"),
    6: .standard(proto: "from_headers"),
    7: .standard(proto: "from_params"),
    8: .standard(proto: "forward_payload_header"),
    9: .standard(proto: "payload_in_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.audiences) }()
      case 3: try {
        var v: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks?
        if let current = self.jwksSourceSpecifier {
          try decoder.handleConflictingOneOf()
          if case .remoteJwks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.jwksSourceSpecifier = .remoteJwks(v)}
      }()
      case 4: try {
        var v: Envoy_Config_Core_V3_DataSource?
        if let current = self.jwksSourceSpecifier {
          try decoder.handleConflictingOneOf()
          if case .localJwks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.jwksSourceSpecifier = .localJwks(v)}
      }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.forward) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.fromHeaders) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.fromParams) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.forwardPayloadHeader) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.payloadInMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 1)
    }
    if !self.audiences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.audiences, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.jwksSourceSpecifier {
    case .remoteJwks?: try {
      guard case .remoteJwks(let v)? = self.jwksSourceSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .localJwks?: try {
      guard case .localJwks(let v)? = self.jwksSourceSpecifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.forward != false {
      try visitor.visitSingularBoolField(value: self.forward, fieldNumber: 5)
    }
    if !self.fromHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fromHeaders, fieldNumber: 6)
    }
    if !self.fromParams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fromParams, fieldNumber: 7)
    }
    if !self.forwardPayloadHeader.isEmpty {
      try visitor.visitSingularStringField(value: self.forwardPayloadHeader, fieldNumber: 8)
    }
    if !self.payloadInMetadata.isEmpty {
      try visitor.visitSingularStringField(value: self.payloadInMetadata, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider) -> Bool {
    if lhs.issuer != rhs.issuer {return false}
    if lhs.audiences != rhs.audiences {return false}
    if lhs.jwksSourceSpecifier != rhs.jwksSourceSpecifier {return false}
    if lhs.forward != rhs.forward {return false}
    if lhs.fromHeaders != rhs.fromHeaders {return false}
    if lhs.fromParams != rhs.fromParams {return false}
    if lhs.forwardPayloadHeader != rhs.forwardPayloadHeader {return false}
    if lhs.payloadInMetadata != rhs.payloadInMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteJwks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http_uri"),
    2: .standard(proto: "cache_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._httpUri) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cacheDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._httpUri {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._cacheDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RemoteJwks) -> Bool {
    if lhs._httpUri != rhs._httpUri {return false}
    if lhs._cacheDuration != rhs._cacheDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JwtHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "value_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.valuePrefix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.valuePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.valuePrefix, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtHeader, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtHeader) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.valuePrefix != rhs.valuePrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProviderWithAudiences"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_name"),
    2: .same(proto: "audiences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.providerName) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.audiences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providerName.isEmpty {
      try visitor.visitSingularStringField(value: self.providerName, fieldNumber: 1)
    }
    if !self.audiences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.audiences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences) -> Bool {
    if lhs.providerName != rhs.providerName {return false}
    if lhs.audiences != rhs.audiences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JwtRequirement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "provider_name"),
    2: .standard(proto: "provider_and_audiences"),
    3: .standard(proto: "requires_any"),
    4: .standard(proto: "requires_all"),
    5: .standard(proto: "allow_missing_or_failed"),
    6: .standard(proto: "allow_missing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.requiresType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.requiresType = .providerName(v)}
      }()
      case 2: try {
        var v: Envoy_Extensions_Filters_Http_JwtAuthn_V3_ProviderWithAudiences?
        if let current = self.requiresType {
          try decoder.handleConflictingOneOf()
          if case .providerAndAudiences(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requiresType = .providerAndAudiences(v)}
      }()
      case 3: try {
        var v: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList?
        if let current = self.requiresType {
          try decoder.handleConflictingOneOf()
          if case .requiresAny(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requiresType = .requiresAny(v)}
      }()
      case 4: try {
        var v: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList?
        if let current = self.requiresType {
          try decoder.handleConflictingOneOf()
          if case .requiresAll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requiresType = .requiresAll(v)}
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.requiresType {
          try decoder.handleConflictingOneOf()
          if case .allowMissingOrFailed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requiresType = .allowMissingOrFailed(v)}
      }()
      case 6: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        if let current = self.requiresType {
          try decoder.handleConflictingOneOf()
          if case .allowMissing(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requiresType = .allowMissing(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requiresType {
    case .providerName?: try {
      guard case .providerName(let v)? = self.requiresType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .providerAndAudiences?: try {
      guard case .providerAndAudiences(let v)? = self.requiresType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .requiresAny?: try {
      guard case .requiresAny(let v)? = self.requiresType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .requiresAll?: try {
      guard case .requiresAll(let v)? = self.requiresType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .allowMissingOrFailed?: try {
      guard case .allowMissingOrFailed(let v)? = self.requiresType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .allowMissing?: try {
      guard case .allowMissing(let v)? = self.requiresType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement) -> Bool {
    if lhs.requiresType != rhs.requiresType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JwtRequirementOrList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requirements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requirements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requirements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requirements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementOrList) -> Bool {
    if lhs.requirements != rhs.requirements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JwtRequirementAndList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "requirements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requirements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requirements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requirements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirementAndList) -> Bool {
    if lhs.requirements != rhs.requirements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequirementRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "match"),
    2: .same(proto: "requires"),
    3: .standard(proto: "requirement_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._match) }()
      case 2: try {
        var v: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement?
        if let current = self.requirementType {
          try decoder.handleConflictingOneOf()
          if case .requires(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requirementType = .requires(v)}
      }()
      case 3: try {
        if self.requirementType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.requirementType = .requirementName(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._match {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requirementType {
    case .requires?: try {
      guard case .requires(let v)? = self.requirementType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .requirementName?: try {
      guard case .requirementName(let v)? = self.requirementType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_RequirementRule) -> Bool {
    if lhs._match != rhs._match {return false}
    if lhs.requirementType != rhs.requirementType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FilterStateRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "requires"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement>.self, value: &self.requires) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.requires.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement>.self, value: self.requires, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_FilterStateRule) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.requires != rhs.requires {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JwtAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "providers"),
    2: .same(proto: "rules"),
    3: .standard(proto: "filter_state_rules"),
    4: .standard(proto: "bypass_cors_preflight"),
    5: .standard(proto: "requirement_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider>.self, value: &self.providers) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._filterStateRules) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.bypassCorsPreflight) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement>.self, value: &self.requirementMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.providers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtProvider>.self, value: self.providers, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 2)
    }
    if let v = self._filterStateRules {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.bypassCorsPreflight != false {
      try visitor.visitSingularBoolField(value: self.bypassCorsPreflight, fieldNumber: 4)
    }
    if !self.requirementMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtRequirement>.self, value: self.requirementMap, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtAuthentication, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_JwtAuthentication) -> Bool {
    if lhs.providers != rhs.providers {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs._filterStateRules != rhs._filterStateRules {return false}
    if lhs.bypassCorsPreflight != rhs.bypassCorsPreflight {return false}
    if lhs.requirementMap != rhs.requirementMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PerRouteConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
    2: .standard(proto: "requirement_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.requirementSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.requirementSpecifier = .disabled(v)}
      }()
      case 2: try {
        if self.requirementSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.requirementSpecifier = .requirementName(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requirementSpecifier {
    case .disabled?: try {
      guard case .disabled(let v)? = self.requirementSpecifier else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .requirementName?: try {
      guard case .requirementName(let v)? = self.requirementSpecifier else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig, rhs: Envoy_Extensions_Filters_Http_JwtAuthn_V3_PerRouteConfig) -> Bool {
    if lhs.requirementSpecifier != rhs.requirementSpecifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/http/header_to_metadata/v4alpha/header_to_metadata.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of rules to apply to requests.
  public var requestRules: [Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule] = []

  /// The list of rules to apply to responses.
  public var responseRules: [Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ValueType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case string // = 0
    case number // = 1

    /// The value is a serialized `protobuf.Value
    /// <https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/struct.proto#L62>`_.
    case protobufValue // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .string
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .string
      case 1: self = .number
      case 2: self = .protobufValue
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .string: return 0
      case .number: return 1
      case .protobufValue: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// ValueEncode defines the encoding algorithm.
  public enum ValueEncode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The value is not encoded.
    case none // = 0

    /// The value is encoded in `Base64 <https://tools.ietf.org/html/rfc4648#section-4>`_.
    /// Note: this is mostly used for STRING and PROTOBUF_VALUE to escape the
    /// non-ASCII characters in the header.
    case base64 // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .base64
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .base64: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// [#next-free-field: 7]
  public struct KeyValuePair {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace — if this is empty, the filter's namespace will be used.
    public var metadataNamespace: String = String()

    /// The key to use within the namespace.
    public var key: String = String()

    public var valueType: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair.OneOf_ValueType? = nil

    /// The value to pair with the given key.
    ///
    /// When used for a
    /// :ref:`on_header_present <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_present>`
    /// case, if value is non-empty it'll be used instead of the header value. If both are empty, no metadata is added.
    ///
    /// When used for a :ref:`on_header_missing <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_missing>`
    /// case, a non-empty value must be provided otherwise no metadata is added.
    public var value: String {
      get {
        if case .value(let v)? = valueType {return v}
        return String()
      }
      set {valueType = .value(newValue)}
    }

    /// If present, the header's value will be matched and substituted with this. If there is no match or substitution, the header value
    /// is used as-is.
    ///
    /// This is only used for :ref:`on_header_present <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_present>`.
    ///
    /// Note: if the `value` field is non-empty this field should be empty.
    public var regexValueRewrite: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute {
      get {
        if case .regexValueRewrite(let v)? = valueType {return v}
        return Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute()
      }
      set {valueType = .regexValueRewrite(newValue)}
    }

    /// The value's type — defaults to string.
    public var type: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueType = .string

    /// How is the value encoded, default is NONE (not encoded).
    /// The value will be decoded accordingly before storing to metadata.
    public var encode: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueEncode = .none

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_ValueType: Equatable {
      /// The value to pair with the given key.
      ///
      /// When used for a
      /// :ref:`on_header_present <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_present>`
      /// case, if value is non-empty it'll be used instead of the header value. If both are empty, no metadata is added.
      ///
      /// When used for a :ref:`on_header_missing <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_missing>`
      /// case, a non-empty value must be provided otherwise no metadata is added.
      case value(String)
      /// If present, the header's value will be matched and substituted with this. If there is no match or substitution, the header value
      /// is used as-is.
      ///
      /// This is only used for :ref:`on_header_present <envoy_v3_api_field_extensions.filters.http.header_to_metadata.v3.Config.Rule.on_header_present>`.
      ///
      /// Note: if the `value` field is non-empty this field should be empty.
      case regexValueRewrite(Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair.OneOf_ValueType, rhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair.OneOf_ValueType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.value, .value): return {
          guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.regexValueRewrite, .regexValueRewrite): return {
          guard case .regexValueRewrite(let l) = lhs, case .regexValueRewrite(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A Rule defines what metadata to apply when a header is present or missing.
  /// [#next-free-field: 6]
  public struct Rule {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var headerCookieSpecifier: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule.OneOf_HeaderCookieSpecifier? = nil

    /// Specifies that a match will be performed on the value of a header or a cookie.
    ///
    /// The header to be extracted.
    public var header: String {
      get {
        if case .header(let v)? = headerCookieSpecifier {return v}
        return String()
      }
      set {headerCookieSpecifier = .header(newValue)}
    }

    /// The cookie to be extracted.
    public var cookie: String {
      get {
        if case .cookie(let v)? = headerCookieSpecifier {return v}
        return String()
      }
      set {headerCookieSpecifier = .cookie(newValue)}
    }

    /// If the header or cookie is present, apply this metadata KeyValuePair.
    ///
    /// If the value in the KeyValuePair is non-empty, it'll be used instead
    /// of the header or cookie value.
    public var onPresent: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair {
      get {return _onPresent ?? Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair()}
      set {_onPresent = newValue}
    }
    /// Returns true if `onPresent` has been explicitly set.
    public var hasOnPresent: Bool {return self._onPresent != nil}
    /// Clears the value of `onPresent`. Subsequent reads from it will return its default value.
    public mutating func clearOnPresent() {self._onPresent = nil}

    /// If the header or cookie is not present, apply this metadata KeyValuePair.
    ///
    /// The value in the KeyValuePair must be set, since it'll be used in lieu
    /// of the missing header or cookie value.
    public var onMissing: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair {
      get {return _onMissing ?? Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair()}
      set {_onMissing = newValue}
    }
    /// Returns true if `onMissing` has been explicitly set.
    public var hasOnMissing: Bool {return self._onMissing != nil}
    /// Clears the value of `onMissing`. Subsequent reads from it will return its default value.
    public mutating func clearOnMissing() {self._onMissing = nil}

    /// Whether or not to remove the header after a rule is applied.
    ///
    /// This prevents headers from leaking.
    /// This field is not supported in case of a cookie.
    public var remove: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_HeaderCookieSpecifier: Equatable {
      /// Specifies that a match will be performed on the value of a header or a cookie.
      ///
      /// The header to be extracted.
      case header(String)
      /// The cookie to be extracted.
      case cookie(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule.OneOf_HeaderCookieSpecifier, rhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule.OneOf_HeaderCookieSpecifier) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.header, .header): return {
          guard case .header(let l) = lhs, case .header(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.cookie, .cookie): return {
          guard case .cookie(let l) = lhs, case .cookie(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _onPresent: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair? = nil
    fileprivate var _onMissing: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueType] = [
    .string,
    .number,
    .protobufValue,
  ]
}

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueEncode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueEncode] = [
    .none,
    .base64,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.http.header_to_metadata.v4alpha"

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_rules"),
    2: .standard(proto: "response_rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.requestRules) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.responseRules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.requestRules, fieldNumber: 1)
    }
    if !self.responseRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responseRules, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config, rhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config) -> Bool {
    if lhs.requestRules != rhs.requestRules {return false}
    if lhs.responseRules != rhs.responseRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRING"),
    1: .same(proto: "NUMBER"),
    2: .same(proto: "PROTOBUF_VALUE"),
  ]
}

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.ValueEncode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "BASE64"),
  ]
}

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.protoMessageName + ".KeyValuePair"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metadata_namespace"),
    2: .same(proto: "key"),
    3: .same(proto: "value"),
    6: .standard(proto: "regex_value_rewrite"),
    4: .same(proto: "type"),
    5: .same(proto: "encode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metadataNamespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 3: try {
        if self.valueType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.valueType = .value(v)}
      }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.encode) }()
      case 6: try {
        var v: Envoy_Type_Matcher_V4alpha_RegexMatchAndSubstitute?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .regexValueRewrite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .regexValueRewrite(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadataNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataNamespace, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    if case .value(let v)? = self.valueType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if self.type != .string {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if self.encode != .none {
      try visitor.visitSingularEnumField(value: self.encode, fieldNumber: 5)
    }
    if case .regexValueRewrite(let v)? = self.valueType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair, rhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.KeyValuePair) -> Bool {
    if lhs.metadataNamespace != rhs.metadataNamespace {return false}
    if lhs.key != rhs.key {return false}
    if lhs.valueType != rhs.valueType {return false}
    if lhs.type != rhs.type {return false}
    if lhs.encode != rhs.encode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.protoMessageName + ".Rule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    5: .same(proto: "cookie"),
    2: .standard(proto: "on_present"),
    3: .standard(proto: "on_missing"),
    4: .same(proto: "remove"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.headerCookieSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerCookieSpecifier = .header(v)}
      }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._onPresent) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._onMissing) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.remove) }()
      case 5: try {
        if self.headerCookieSpecifier != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.headerCookieSpecifier = .cookie(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .header(let v)? = self.headerCookieSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._onPresent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._onMissing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.remove != false {
      try visitor.visitSingularBoolField(value: self.remove, fieldNumber: 4)
    }
    if case .cookie(let v)? = self.headerCookieSpecifier {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule, rhs: Envoy_Extensions_Filters_Http_HeaderToMetadata_V4alpha_Config.Rule) -> Bool {
    if lhs.headerCookieSpecifier != rhs.headerCookieSpecifier {return false}
    if lhs._onPresent != rhs._onPresent {return false}
    if lhs._onMissing != rhs._onMissing {return false}
    if lhs.remove != rhs.remove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

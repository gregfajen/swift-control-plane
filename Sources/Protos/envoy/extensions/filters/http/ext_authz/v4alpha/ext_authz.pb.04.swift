// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/http/ext_authz/v4alpha/ext_authz.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [#next-free-field: 15]
public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// External authorization service configuration.
  public var services: OneOf_Services? {
    get {return _storage._services}
    set {_uniqueStorage()._services = newValue}
  }

  /// gRPC service configuration (default timeout: 200ms).
  public var grpcService: Envoy_Config_Core_V4alpha_GrpcService {
    get {
      if case .grpcService(let v)? = _storage._services {return v}
      return Envoy_Config_Core_V4alpha_GrpcService()
    }
    set {_uniqueStorage()._services = .grpcService(newValue)}
  }

  /// HTTP service configuration (default timeout: 200ms).
  public var httpService: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService {
    get {
      if case .httpService(let v)? = _storage._services {return v}
      return Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService()
    }
    set {_uniqueStorage()._services = .httpService(newValue)}
  }

  /// API version for ext_authz transport protocol. This describes the ext_authz gRPC endpoint and
  /// version of messages used on the wire.
  public var transportApiVersion: Envoy_Config_Core_V4alpha_ApiVersion {
    get {return _storage._transportApiVersion}
    set {_uniqueStorage()._transportApiVersion = newValue}
  }

  ///  Changes filter's behaviour on errors:
  ///
  ///  1. When set to true, the filter will *accept* client request even if the communication with
  ///  the authorization service has failed, or if the authorization service has returned a HTTP 5xx
  ///  error.
  ///
  ///  2. When set to false, ext-authz will *reject* client requests and return a *Forbidden*
  ///  response if the communication with the authorization service has failed, or if the
  ///  authorization service has returned a HTTP 5xx error.
  ///
  /// Note that errors can be *always* tracked in the :ref:`stats
  /// <config_http_filters_ext_authz_stats>`.
  public var failureModeAllow: Bool {
    get {return _storage._failureModeAllow}
    set {_uniqueStorage()._failureModeAllow = newValue}
  }

  /// Enables filter to buffer the client request body and send it within the authorization request.
  /// A ``x-envoy-auth-partial-body: false|true`` metadata header will be added to the authorization
  /// request message indicating if the body data is partial.
  public var withRequestBody: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings {
    get {return _storage._withRequestBody ?? Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings()}
    set {_uniqueStorage()._withRequestBody = newValue}
  }
  /// Returns true if `withRequestBody` has been explicitly set.
  public var hasWithRequestBody: Bool {return _storage._withRequestBody != nil}
  /// Clears the value of `withRequestBody`. Subsequent reads from it will return its default value.
  public mutating func clearWithRequestBody() {_uniqueStorage()._withRequestBody = nil}

  /// Clears route cache in order to allow the external authorization service to correctly affect
  /// routing decisions. Filter clears all cached routes when:
  ///
  /// 1. The field is set to *true*.
  ///
  /// 2. The status returned from the authorization service is a HTTP 200 or gRPC 0.
  ///
  /// 3. At least one *authorization response header* is added to the client request, or is used for
  /// altering another client request header.
  public var clearRouteCache_p: Bool {
    get {return _storage._clearRouteCache_p}
    set {_uniqueStorage()._clearRouteCache_p = newValue}
  }

  /// Sets the HTTP status that is returned to the client when there is a network error between the
  /// filter and the authorization server. The default status is HTTP 403 Forbidden.
  public var statusOnError: Envoy_Type_V3_HttpStatus {
    get {return _storage._statusOnError ?? Envoy_Type_V3_HttpStatus()}
    set {_uniqueStorage()._statusOnError = newValue}
  }
  /// Returns true if `statusOnError` has been explicitly set.
  public var hasStatusOnError: Bool {return _storage._statusOnError != nil}
  /// Clears the value of `statusOnError`. Subsequent reads from it will return its default value.
  public mutating func clearStatusOnError() {_uniqueStorage()._statusOnError = nil}

  /// Specifies a list of metadata namespaces whose values, if present, will be passed to the
  /// ext_authz service as an opaque *protobuf::Struct*.
  ///
  /// For example, if the *jwt_authn* filter is used and :ref:`payload_in_metadata
  /// <envoy_api_field_extensions.filters.http.jwt_authn.v4alpha.JwtProvider.payload_in_metadata>` is set,
  /// then the following will pass the jwt payload to the authorization server.
  ///
  /// .. code-block:: yaml
  ///
  ///    metadata_context_namespaces:
  ///    - envoy.filters.http.jwt_authn
  public var metadataContextNamespaces: [String] {
    get {return _storage._metadataContextNamespaces}
    set {_uniqueStorage()._metadataContextNamespaces = newValue}
  }

  /// Specifies if the filter is enabled.
  ///
  /// If :ref:`runtime_key <envoy_api_field_config.core.v4alpha.RuntimeFractionalPercent.runtime_key>` is specified,
  /// Envoy will lookup the runtime key to get the percentage of requests to filter.
  ///
  /// If this field is not specified, the filter will be enabled for all requests.
  public var filterEnabled: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent {
    get {return _storage._filterEnabled ?? Envoy_Config_Core_V4alpha_RuntimeFractionalPercent()}
    set {_uniqueStorage()._filterEnabled = newValue}
  }
  /// Returns true if `filterEnabled` has been explicitly set.
  public var hasFilterEnabled: Bool {return _storage._filterEnabled != nil}
  /// Clears the value of `filterEnabled`. Subsequent reads from it will return its default value.
  public mutating func clearFilterEnabled() {_uniqueStorage()._filterEnabled = nil}

  /// Specifies if the filter is enabled with metadata matcher.
  /// If this field is not specified, the filter will be enabled for all requests.
  public var filterEnabledMetadata: Envoy_Type_Matcher_V4alpha_MetadataMatcher {
    get {return _storage._filterEnabledMetadata ?? Envoy_Type_Matcher_V4alpha_MetadataMatcher()}
    set {_uniqueStorage()._filterEnabledMetadata = newValue}
  }
  /// Returns true if `filterEnabledMetadata` has been explicitly set.
  public var hasFilterEnabledMetadata: Bool {return _storage._filterEnabledMetadata != nil}
  /// Clears the value of `filterEnabledMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearFilterEnabledMetadata() {_uniqueStorage()._filterEnabledMetadata = nil}

  /// Specifies whether to deny the requests, when the filter is disabled.
  /// If :ref:`runtime_key <envoy_api_field_config.core.v4alpha.RuntimeFeatureFlag.runtime_key>` is specified,
  /// Envoy will lookup the runtime key to determine whether to deny request for
  /// filter protected path at filter disabling. If filter is disabled in
  /// typed_per_filter_config for the path, requests will not be denied.
  ///
  /// If this field is not specified, all requests will be allowed when disabled.
  public var denyAtDisable: Envoy_Config_Core_V4alpha_RuntimeFeatureFlag {
    get {return _storage._denyAtDisable ?? Envoy_Config_Core_V4alpha_RuntimeFeatureFlag()}
    set {_uniqueStorage()._denyAtDisable = newValue}
  }
  /// Returns true if `denyAtDisable` has been explicitly set.
  public var hasDenyAtDisable: Bool {return _storage._denyAtDisable != nil}
  /// Clears the value of `denyAtDisable`. Subsequent reads from it will return its default value.
  public mutating func clearDenyAtDisable() {_uniqueStorage()._denyAtDisable = nil}

  /// Specifies if the peer certificate is sent to the external service.
  ///
  /// When this field is true, Envoy will include the peer X.509 certificate, if available, in the
  /// :ref:`certificate<envoy_api_field_service.auth.v4alpha.AttributeContext.Peer.certificate>`.
  public var includePeerCertificate: Bool {
    get {return _storage._includePeerCertificate}
    set {_uniqueStorage()._includePeerCertificate = newValue}
  }

  /// Optional additional prefix to use when emitting statistics. This allows to distinguish
  /// emitted statistics between configured *ext_authz* filters in an HTTP filter chain. For example:
  ///
  /// .. code-block:: yaml
  ///
  ///   http_filters:
  ///     - name: envoy.filters.http.ext_authz
  ///       typed_config:
  ///         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
  ///         stat_prefix: waf # This emits ext_authz.waf.ok, ext_authz.waf.denied, etc.
  ///     - name: envoy.filters.http.ext_authz
  ///       typed_config:
  ///         "@type": type.googleapis.com/envoy.extensions.filters.http.ext_authz.v3.ExtAuthz
  ///         stat_prefix: blocker # This emits ext_authz.blocker.ok, ext_authz.blocker.denied, etc.
  public var statPrefix: String {
    get {return _storage._statPrefix}
    set {_uniqueStorage()._statPrefix = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// External authorization service configuration.
  public enum OneOf_Services: Equatable {
    /// gRPC service configuration (default timeout: 200ms).
    case grpcService(Envoy_Config_Core_V4alpha_GrpcService)
    /// HTTP service configuration (default timeout: 200ms).
    case httpService(Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz.OneOf_Services, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz.OneOf_Services) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.grpcService, .grpcService): return {
        guard case .grpcService(let l) = lhs, case .grpcService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpService, .httpService): return {
        guard case .httpService(let l) = lhs, case .httpService(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Configuration for buffering the request data.
public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sets the maximum size of a message body that the filter will hold in memory. Envoy will return
  /// *HTTP 413* and will *not* initiate the authorization process when buffer reaches the number
  /// set in this field. Note that this setting will have precedence over :ref:`failure_mode_allow
  /// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.ExtAuthz.failure_mode_allow>`.
  public var maxRequestBytes: UInt32 = 0

  /// When this field is true, Envoy will buffer the message until *max_request_bytes* is reached.
  /// The authorization request will be dispatched and no 413 HTTP error will be returned by the
  /// filter.
  public var allowPartialMessage: Bool = false

  /// If true, the body sent to the external authorization service is set with raw bytes, it sets
  /// the :ref:`raw_body<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.raw_body>`
  /// field of HTTP request attribute context. Otherwise, :ref:`
  /// body<envoy_v3_api_field_service.auth.v3.AttributeContext.HttpRequest.body>` will be filled
  /// with UTF-8 string request body.
  public var packAsBytes: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// HttpService is used for raw HTTP communication between the filter and the authorization service.
/// When configured, the filter will parse the client request and use these attributes to call the
/// authorization server. Depending on the response, the filter may reject or accept the client
/// request. Note that in any of these events, metadata can be added, removed or overridden by the
/// filter:
///
/// *On authorization request*, a list of allowed request headers may be supplied. See
/// :ref:`allowed_headers
/// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.AuthorizationRequest.allowed_headers>`
/// for details. Additional headers metadata may be added to the authorization request. See
/// :ref:`headers_to_add
/// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.AuthorizationRequest.headers_to_add>` for
/// details.
///
/// On authorization response status HTTP 200 OK, the filter will allow traffic to the upstream and
/// additional headers metadata may be added to the original client request. See
/// :ref:`allowed_upstream_headers
/// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.AuthorizationResponse.allowed_upstream_headers>`
/// for details.
///
/// On other authorization response statuses, the filter will not allow traffic. Additional headers
/// metadata as well as body may be added to the client's response. See :ref:`allowed_client_headers
/// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.AuthorizationResponse.allowed_client_headers>`
/// for details.
/// [#next-free-field: 9]
public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sets the HTTP server URI which the authorization requests must be sent to.
  public var serverUri: Envoy_Config_Core_V4alpha_HttpUri {
    get {return _serverUri ?? Envoy_Config_Core_V4alpha_HttpUri()}
    set {_serverUri = newValue}
  }
  /// Returns true if `serverUri` has been explicitly set.
  public var hasServerUri: Bool {return self._serverUri != nil}
  /// Clears the value of `serverUri`. Subsequent reads from it will return its default value.
  public mutating func clearServerUri() {self._serverUri = nil}

  /// Sets a prefix to the value of authorization request header *Path*.
  public var pathPrefix: String = String()

  /// Settings used for controlling authorization request metadata.
  public var authorizationRequest: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest {
    get {return _authorizationRequest ?? Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest()}
    set {_authorizationRequest = newValue}
  }
  /// Returns true if `authorizationRequest` has been explicitly set.
  public var hasAuthorizationRequest: Bool {return self._authorizationRequest != nil}
  /// Clears the value of `authorizationRequest`. Subsequent reads from it will return its default value.
  public mutating func clearAuthorizationRequest() {self._authorizationRequest = nil}

  /// Settings used for controlling authorization response metadata.
  public var authorizationResponse: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse {
    get {return _authorizationResponse ?? Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse()}
    set {_authorizationResponse = newValue}
  }
  /// Returns true if `authorizationResponse` has been explicitly set.
  public var hasAuthorizationResponse: Bool {return self._authorizationResponse != nil}
  /// Clears the value of `authorizationResponse`. Subsequent reads from it will return its default value.
  public mutating func clearAuthorizationResponse() {self._authorizationResponse = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serverUri: Envoy_Config_Core_V4alpha_HttpUri? = nil
  fileprivate var _authorizationRequest: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest? = nil
  fileprivate var _authorizationResponse: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse? = nil
}

public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Authorization request will include the client request headers that have a correspondent match
  /// in the :ref:`list <envoy_api_msg_type.matcher.v4alpha.ListStringMatcher>`. Note that in addition to the
  /// user's supplied matchers:
  ///
  /// 1. *Host*, *Method*, *Path* and *Content-Length* are automatically included to the list.
  ///
  /// 2. *Content-Length* will be set to 0 and the request to the authorization service will not have
  /// a message body. However, the authorization request can include the buffered client request body
  /// (controlled by :ref:`with_request_body
  /// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.ExtAuthz.with_request_body>` setting),
  /// consequently the value of *Content-Length* of the authorization request reflects the size of
  /// its payload size.
  public var allowedHeaders: Envoy_Type_Matcher_V4alpha_ListStringMatcher {
    get {return _allowedHeaders ?? Envoy_Type_Matcher_V4alpha_ListStringMatcher()}
    set {_allowedHeaders = newValue}
  }
  /// Returns true if `allowedHeaders` has been explicitly set.
  public var hasAllowedHeaders: Bool {return self._allowedHeaders != nil}
  /// Clears the value of `allowedHeaders`. Subsequent reads from it will return its default value.
  public mutating func clearAllowedHeaders() {self._allowedHeaders = nil}

  /// Sets a list of headers that will be included to the request to authorization service. Note that
  /// client request of the same key will be overridden.
  public var headersToAdd: [Envoy_Config_Core_V4alpha_HeaderValue] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _allowedHeaders: Envoy_Type_Matcher_V4alpha_ListStringMatcher? = nil
}

public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// When this :ref:`list <envoy_api_msg_type.matcher.v4alpha.ListStringMatcher>` is set, authorization
  /// response headers that have a correspondent match will be added to the original client request.
  /// Note that coexistent headers will be overridden.
  public var allowedUpstreamHeaders: Envoy_Type_Matcher_V4alpha_ListStringMatcher {
    get {return _allowedUpstreamHeaders ?? Envoy_Type_Matcher_V4alpha_ListStringMatcher()}
    set {_allowedUpstreamHeaders = newValue}
  }
  /// Returns true if `allowedUpstreamHeaders` has been explicitly set.
  public var hasAllowedUpstreamHeaders: Bool {return self._allowedUpstreamHeaders != nil}
  /// Clears the value of `allowedUpstreamHeaders`. Subsequent reads from it will return its default value.
  public mutating func clearAllowedUpstreamHeaders() {self._allowedUpstreamHeaders = nil}

  /// When this :ref:`list <envoy_api_msg_type.matcher.v4alpha.ListStringMatcher>` is set, authorization
  /// response headers that have a correspondent match will be added to the client's response. Note
  /// that coexistent headers will be appended.
  public var allowedUpstreamHeadersToAppend: Envoy_Type_Matcher_V4alpha_ListStringMatcher {
    get {return _allowedUpstreamHeadersToAppend ?? Envoy_Type_Matcher_V4alpha_ListStringMatcher()}
    set {_allowedUpstreamHeadersToAppend = newValue}
  }
  /// Returns true if `allowedUpstreamHeadersToAppend` has been explicitly set.
  public var hasAllowedUpstreamHeadersToAppend: Bool {return self._allowedUpstreamHeadersToAppend != nil}
  /// Clears the value of `allowedUpstreamHeadersToAppend`. Subsequent reads from it will return its default value.
  public mutating func clearAllowedUpstreamHeadersToAppend() {self._allowedUpstreamHeadersToAppend = nil}

  /// When this :ref:`list <envoy_api_msg_type.matcher.v4alpha.ListStringMatcher>`. is set, authorization
  /// response headers that have a correspondent match will be added to the client's response. Note
  /// that when this list is *not* set, all the authorization response headers, except *Authority
  /// (Host)* will be in the response to the client. When a header is included in this list, *Path*,
  /// *Status*, *Content-Length*, *WWWAuthenticate* and *Location* are automatically added.
  public var allowedClientHeaders: Envoy_Type_Matcher_V4alpha_ListStringMatcher {
    get {return _allowedClientHeaders ?? Envoy_Type_Matcher_V4alpha_ListStringMatcher()}
    set {_allowedClientHeaders = newValue}
  }
  /// Returns true if `allowedClientHeaders` has been explicitly set.
  public var hasAllowedClientHeaders: Bool {return self._allowedClientHeaders != nil}
  /// Clears the value of `allowedClientHeaders`. Subsequent reads from it will return its default value.
  public mutating func clearAllowedClientHeaders() {self._allowedClientHeaders = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _allowedUpstreamHeaders: Envoy_Type_Matcher_V4alpha_ListStringMatcher? = nil
  fileprivate var _allowedUpstreamHeadersToAppend: Envoy_Type_Matcher_V4alpha_ListStringMatcher? = nil
  fileprivate var _allowedClientHeaders: Envoy_Type_Matcher_V4alpha_ListStringMatcher? = nil
}

/// Extra settings on a per virtualhost/route/weighted-cluster level.
public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var override: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute.OneOf_Override? = nil

  /// Disable the ext auth filter for this particular vhost or route.
  /// If disabled is specified in multiple per-filter-configs, the most specific one will be used.
  public var disabled: Bool {
    get {
      if case .disabled(let v)? = override {return v}
      return false
    }
    set {override = .disabled(newValue)}
  }

  /// Check request settings for this route.
  public var checkSettings: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings {
    get {
      if case .checkSettings(let v)? = override {return v}
      return Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings()
    }
    set {override = .checkSettings(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Override: Equatable {
    /// Disable the ext auth filter for this particular vhost or route.
    /// If disabled is specified in multiple per-filter-configs, the most specific one will be used.
    case disabled(Bool)
    /// Check request settings for this route.
    case checkSettings(Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute.OneOf_Override, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute.OneOf_Override) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.disabled, .disabled): return {
        guard case .disabled(let l) = lhs, case .disabled(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.checkSettings, .checkSettings): return {
        guard case .checkSettings(let l) = lhs, case .checkSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Extra settings for the check request.
public struct Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Context extensions to set on the CheckRequest's
  /// :ref:`AttributeContext.context_extensions<envoy_api_field_service.auth.v4alpha.AttributeContext.context_extensions>`
  ///
  /// You can use this to provide extra context for the external authorization server on specific
  /// virtual hosts/routes. For example, adding a context extension on the virtual host level can
  /// give the ext-authz server information on what virtual host is used without needing to parse the
  /// host header. If CheckSettings is specified in multiple per-filter-configs, they will be merged
  /// in order, and the result will be used.
  ///
  /// Merge semantics for this field are such that keys from more specific configs override.
  ///
  /// .. note::
  ///
  ///   These settings are only applied to a filter configured with a
  ///   :ref:`grpc_service<envoy_api_field_extensions.filters.http.ext_authz.v4alpha.ExtAuthz.grpc_service>`.
  public var contextExtensions: Dictionary<String,String> = [:]

  /// When set to true, disable the configured :ref:`with_request_body
  /// <envoy_api_field_extensions.filters.http.ext_authz.v4alpha.ExtAuthz.with_request_body>` for a route.
  public var disableRequestBodyBuffering: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.http.ext_authz.v4alpha"

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtAuthz"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "grpc_service"),
    3: .standard(proto: "http_service"),
    12: .standard(proto: "transport_api_version"),
    2: .standard(proto: "failure_mode_allow"),
    5: .standard(proto: "with_request_body"),
    6: .standard(proto: "clear_route_cache"),
    7: .standard(proto: "status_on_error"),
    8: .standard(proto: "metadata_context_namespaces"),
    9: .standard(proto: "filter_enabled"),
    14: .standard(proto: "filter_enabled_metadata"),
    11: .standard(proto: "deny_at_disable"),
    10: .standard(proto: "include_peer_certificate"),
    13: .standard(proto: "stat_prefix"),
  ]

  fileprivate class _StorageClass {
    var _services: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz.OneOf_Services?
    var _transportApiVersion: Envoy_Config_Core_V4alpha_ApiVersion = .auto
    var _failureModeAllow: Bool = false
    var _withRequestBody: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings? = nil
    var _clearRouteCache_p: Bool = false
    var _statusOnError: Envoy_Type_V3_HttpStatus? = nil
    var _metadataContextNamespaces: [String] = []
    var _filterEnabled: Envoy_Config_Core_V4alpha_RuntimeFractionalPercent? = nil
    var _filterEnabledMetadata: Envoy_Type_Matcher_V4alpha_MetadataMatcher? = nil
    var _denyAtDisable: Envoy_Config_Core_V4alpha_RuntimeFeatureFlag? = nil
    var _includePeerCertificate: Bool = false
    var _statPrefix: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _services = source._services
      _transportApiVersion = source._transportApiVersion
      _failureModeAllow = source._failureModeAllow
      _withRequestBody = source._withRequestBody
      _clearRouteCache_p = source._clearRouteCache_p
      _statusOnError = source._statusOnError
      _metadataContextNamespaces = source._metadataContextNamespaces
      _filterEnabled = source._filterEnabled
      _filterEnabledMetadata = source._filterEnabledMetadata
      _denyAtDisable = source._denyAtDisable
      _includePeerCertificate = source._includePeerCertificate
      _statPrefix = source._statPrefix
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Envoy_Config_Core_V4alpha_GrpcService?
          if let current = _storage._services {
            try decoder.handleConflictingOneOf()
            if case .grpcService(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._services = .grpcService(v)}
        }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._failureModeAllow) }()
        case 3: try {
          var v: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService?
          if let current = _storage._services {
            try decoder.handleConflictingOneOf()
            if case .httpService(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._services = .httpService(v)}
        }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._withRequestBody) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._clearRouteCache_p) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._statusOnError) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._metadataContextNamespaces) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._filterEnabled) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._includePeerCertificate) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._denyAtDisable) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._transportApiVersion) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._statPrefix) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._filterEnabledMetadata) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .grpcService(let v)? = _storage._services {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._failureModeAllow != false {
        try visitor.visitSingularBoolField(value: _storage._failureModeAllow, fieldNumber: 2)
      }
      if case .httpService(let v)? = _storage._services {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._withRequestBody {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._clearRouteCache_p != false {
        try visitor.visitSingularBoolField(value: _storage._clearRouteCache_p, fieldNumber: 6)
      }
      if let v = _storage._statusOnError {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._metadataContextNamespaces.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._metadataContextNamespaces, fieldNumber: 8)
      }
      if let v = _storage._filterEnabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._includePeerCertificate != false {
        try visitor.visitSingularBoolField(value: _storage._includePeerCertificate, fieldNumber: 10)
      }
      if let v = _storage._denyAtDisable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._transportApiVersion != .auto {
        try visitor.visitSingularEnumField(value: _storage._transportApiVersion, fieldNumber: 12)
      }
      if !_storage._statPrefix.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statPrefix, fieldNumber: 13)
      }
      if let v = _storage._filterEnabledMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthz) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._services != rhs_storage._services {return false}
        if _storage._transportApiVersion != rhs_storage._transportApiVersion {return false}
        if _storage._failureModeAllow != rhs_storage._failureModeAllow {return false}
        if _storage._withRequestBody != rhs_storage._withRequestBody {return false}
        if _storage._clearRouteCache_p != rhs_storage._clearRouteCache_p {return false}
        if _storage._statusOnError != rhs_storage._statusOnError {return false}
        if _storage._metadataContextNamespaces != rhs_storage._metadataContextNamespaces {return false}
        if _storage._filterEnabled != rhs_storage._filterEnabled {return false}
        if _storage._filterEnabledMetadata != rhs_storage._filterEnabledMetadata {return false}
        if _storage._denyAtDisable != rhs_storage._denyAtDisable {return false}
        if _storage._includePeerCertificate != rhs_storage._includePeerCertificate {return false}
        if _storage._statPrefix != rhs_storage._statPrefix {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BufferSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_request_bytes"),
    2: .standard(proto: "allow_partial_message"),
    3: .standard(proto: "pack_as_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxRequestBytes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowPartialMessage) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.packAsBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxRequestBytes != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxRequestBytes, fieldNumber: 1)
    }
    if self.allowPartialMessage != false {
      try visitor.visitSingularBoolField(value: self.allowPartialMessage, fieldNumber: 2)
    }
    if self.packAsBytes != false {
      try visitor.visitSingularBoolField(value: self.packAsBytes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_BufferSettings) -> Bool {
    if lhs.maxRequestBytes != rhs.maxRequestBytes {return false}
    if lhs.allowPartialMessage != rhs.allowPartialMessage {return false}
    if lhs.packAsBytes != rhs.packAsBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_uri"),
    2: .standard(proto: "path_prefix"),
    7: .standard(proto: "authorization_request"),
    8: .standard(proto: "authorization_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serverUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pathPrefix) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._authorizationRequest) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._authorizationResponse) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._serverUri {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.pathPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.pathPrefix, fieldNumber: 2)
    }
    if let v = self._authorizationRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._authorizationResponse {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_HttpService) -> Bool {
    if lhs._serverUri != rhs._serverUri {return false}
    if lhs.pathPrefix != rhs.pathPrefix {return false}
    if lhs._authorizationRequest != rhs._authorizationRequest {return false}
    if lhs._authorizationResponse != rhs._authorizationResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthorizationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_headers"),
    2: .standard(proto: "headers_to_add"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._allowedHeaders) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.headersToAdd) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._allowedHeaders {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.headersToAdd.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headersToAdd, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationRequest) -> Bool {
    if lhs._allowedHeaders != rhs._allowedHeaders {return false}
    if lhs.headersToAdd != rhs.headersToAdd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthorizationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_upstream_headers"),
    3: .standard(proto: "allowed_upstream_headers_to_append"),
    2: .standard(proto: "allowed_client_headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._allowedUpstreamHeaders) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._allowedClientHeaders) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._allowedUpstreamHeadersToAppend) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._allowedUpstreamHeaders {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._allowedClientHeaders {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._allowedUpstreamHeadersToAppend {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_AuthorizationResponse) -> Bool {
    if lhs._allowedUpstreamHeaders != rhs._allowedUpstreamHeaders {return false}
    if lhs._allowedUpstreamHeadersToAppend != rhs._allowedUpstreamHeadersToAppend {return false}
    if lhs._allowedClientHeaders != rhs._allowedClientHeaders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExtAuthzPerRoute"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
    2: .standard(proto: "check_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.override != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.override = .disabled(v)}
      }()
      case 2: try {
        var v: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings?
        if let current = self.override {
          try decoder.handleConflictingOneOf()
          if case .checkSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.override = .checkSettings(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .disabled?: try {
      guard case .disabled(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .checkSettings?: try {
      guard case .checkSettings(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_ExtAuthzPerRoute) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "context_extensions"),
    2: .standard(proto: "disable_request_body_buffering"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.contextExtensions) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.disableRequestBodyBuffering) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contextExtensions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.contextExtensions, fieldNumber: 1)
    }
    if self.disableRequestBodyBuffering != false {
      try visitor.visitSingularBoolField(value: self.disableRequestBodyBuffering, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings, rhs: Envoy_Extensions_Filters_Http_ExtAuthz_V4alpha_CheckSettings) -> Bool {
    if lhs.contextExtensions != rhs.contextExtensions {return false}
    if lhs.disableRequestBodyBuffering != rhs.disableRequestBodyBuffering {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

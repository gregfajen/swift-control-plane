// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/http/oauth2/v3alpha/oauth.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The client_id to be used in the authorize calls. This value will be URL encoded when sent to the OAuth server.
  public var clientID: String = String()

  /// The secret used to retrieve the access token. This value will be URL encoded when sent to the OAuth server.
  public var tokenSecret: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
    get {return _tokenSecret ?? Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()}
    set {_tokenSecret = newValue}
  }
  /// Returns true if `tokenSecret` has been explicitly set.
  public var hasTokenSecret: Bool {return self._tokenSecret != nil}
  /// Clears the value of `tokenSecret`. Subsequent reads from it will return its default value.
  public mutating func clearTokenSecret() {self._tokenSecret = nil}

  /// Configures how the secret token should be created.
  public var tokenFormation: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials.OneOf_TokenFormation? = nil

  /// If present, the secret token will be a HMAC using the provided secret.
  public var hmacSecret: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig {
    get {
      if case .hmacSecret(let v)? = tokenFormation {return v}
      return Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig()
    }
    set {tokenFormation = .hmacSecret(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configures how the secret token should be created.
  public enum OneOf_TokenFormation: Equatable {
    /// If present, the secret token will be a HMAC using the provided secret.
    case hmacSecret(Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials.OneOf_TokenFormation, rhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials.OneOf_TokenFormation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hmacSecret, .hmacSecret): return {
        guard case .hmacSecret(let l) = lhs, case .hmacSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _tokenSecret: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig? = nil
}

/// OAuth config
///
/// [#next-free-field: 9]
public struct Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint on the authorization server to retrieve the access token from.
  public var tokenEndpoint: Envoy_Config_Core_V3_HttpUri {
    get {return _storage._tokenEndpoint ?? Envoy_Config_Core_V3_HttpUri()}
    set {_uniqueStorage()._tokenEndpoint = newValue}
  }
  /// Returns true if `tokenEndpoint` has been explicitly set.
  public var hasTokenEndpoint: Bool {return _storage._tokenEndpoint != nil}
  /// Clears the value of `tokenEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearTokenEndpoint() {_uniqueStorage()._tokenEndpoint = nil}

  /// The endpoint redirect to for authorization in response to unauthorized requests.
  public var authorizationEndpoint: String {
    get {return _storage._authorizationEndpoint}
    set {_uniqueStorage()._authorizationEndpoint = newValue}
  }

  /// Credentials used for OAuth.
  public var credentials: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials {
    get {return _storage._credentials ?? Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials()}
    set {_uniqueStorage()._credentials = newValue}
  }
  /// Returns true if `credentials` has been explicitly set.
  public var hasCredentials: Bool {return _storage._credentials != nil}
  /// Clears the value of `credentials`. Subsequent reads from it will return its default value.
  public mutating func clearCredentials() {_uniqueStorage()._credentials = nil}

  /// The redirect URI passed to the authorization endpoint. Supports header formatting
  /// tokens. For more information, including details on header value syntax, see the
  /// documentation on :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
  ///
  /// This URI should not contain any query parameters.
  public var redirectUri: String {
    get {return _storage._redirectUri}
    set {_uniqueStorage()._redirectUri = newValue}
  }

  /// Matching criteria used to determine whether a path appears to be the result of a redirect from the authorization server.
  public var redirectPathMatcher: Envoy_Type_Matcher_V3_PathMatcher {
    get {return _storage._redirectPathMatcher ?? Envoy_Type_Matcher_V3_PathMatcher()}
    set {_uniqueStorage()._redirectPathMatcher = newValue}
  }
  /// Returns true if `redirectPathMatcher` has been explicitly set.
  public var hasRedirectPathMatcher: Bool {return _storage._redirectPathMatcher != nil}
  /// Clears the value of `redirectPathMatcher`. Subsequent reads from it will return its default value.
  public mutating func clearRedirectPathMatcher() {_uniqueStorage()._redirectPathMatcher = nil}

  /// The path to sign a user out, clearing their credential cookies.
  public var signoutPath: Envoy_Type_Matcher_V3_PathMatcher {
    get {return _storage._signoutPath ?? Envoy_Type_Matcher_V3_PathMatcher()}
    set {_uniqueStorage()._signoutPath = newValue}
  }
  /// Returns true if `signoutPath` has been explicitly set.
  public var hasSignoutPath: Bool {return _storage._signoutPath != nil}
  /// Clears the value of `signoutPath`. Subsequent reads from it will return its default value.
  public mutating func clearSignoutPath() {_uniqueStorage()._signoutPath = nil}

  /// Forward the OAuth token as a Bearer to upstream web service.
  public var forwardBearerToken: Bool {
    get {return _storage._forwardBearerToken}
    set {_uniqueStorage()._forwardBearerToken = newValue}
  }

  /// Any request that matches any of the provided matchers will be passed through without OAuth validation.
  public var passThroughMatcher: [Envoy_Config_Route_V3_HeaderMatcher] {
    get {return _storage._passThroughMatcher}
    set {_uniqueStorage()._passThroughMatcher = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Filter config.
public struct Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Leave this empty to disable OAuth2 for a specific route, using per filter config.
  public var config: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config {
    get {return _config ?? Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.http.oauth2.v3alpha"

extension Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuth2Credentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "token_secret"),
    3: .standard(proto: "hmac_secret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tokenSecret) }()
      case 3: try {
        var v: Envoy_Extensions_TransportSockets_Tls_V3_SdsSecretConfig?
        if let current = self.tokenFormation {
          try decoder.handleConflictingOneOf()
          if case .hmacSecret(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.tokenFormation = .hmacSecret(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if let v = self._tokenSecret {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if case .hmacSecret(let v)? = self.tokenFormation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials, rhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs._tokenSecret != rhs._tokenSecret {return false}
    if lhs.tokenFormation != rhs.tokenFormation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuth2Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_endpoint"),
    2: .standard(proto: "authorization_endpoint"),
    3: .same(proto: "credentials"),
    4: .standard(proto: "redirect_uri"),
    5: .standard(proto: "redirect_path_matcher"),
    6: .standard(proto: "signout_path"),
    7: .standard(proto: "forward_bearer_token"),
    8: .standard(proto: "pass_through_matcher"),
  ]

  fileprivate class _StorageClass {
    var _tokenEndpoint: Envoy_Config_Core_V3_HttpUri? = nil
    var _authorizationEndpoint: String = String()
    var _credentials: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Credentials? = nil
    var _redirectUri: String = String()
    var _redirectPathMatcher: Envoy_Type_Matcher_V3_PathMatcher? = nil
    var _signoutPath: Envoy_Type_Matcher_V3_PathMatcher? = nil
    var _forwardBearerToken: Bool = false
    var _passThroughMatcher: [Envoy_Config_Route_V3_HeaderMatcher] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _tokenEndpoint = source._tokenEndpoint
      _authorizationEndpoint = source._authorizationEndpoint
      _credentials = source._credentials
      _redirectUri = source._redirectUri
      _redirectPathMatcher = source._redirectPathMatcher
      _signoutPath = source._signoutPath
      _forwardBearerToken = source._forwardBearerToken
      _passThroughMatcher = source._passThroughMatcher
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._tokenEndpoint) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._authorizationEndpoint) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._credentials) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._redirectUri) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._redirectPathMatcher) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._signoutPath) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._forwardBearerToken) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._passThroughMatcher) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._tokenEndpoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._authorizationEndpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationEndpoint, fieldNumber: 2)
      }
      if let v = _storage._credentials {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._redirectUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._redirectUri, fieldNumber: 4)
      }
      if let v = _storage._redirectPathMatcher {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._signoutPath {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._forwardBearerToken != false {
        try visitor.visitSingularBoolField(value: _storage._forwardBearerToken, fieldNumber: 7)
      }
      if !_storage._passThroughMatcher.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._passThroughMatcher, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config, rhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2Config) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._tokenEndpoint != rhs_storage._tokenEndpoint {return false}
        if _storage._authorizationEndpoint != rhs_storage._authorizationEndpoint {return false}
        if _storage._credentials != rhs_storage._credentials {return false}
        if _storage._redirectUri != rhs_storage._redirectUri {return false}
        if _storage._redirectPathMatcher != rhs_storage._redirectPathMatcher {return false}
        if _storage._signoutPath != rhs_storage._signoutPath {return false}
        if _storage._forwardBearerToken != rhs_storage._forwardBearerToken {return false}
        if _storage._passThroughMatcher != rhs_storage._passThroughMatcher {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuth2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2, rhs: Envoy_Extensions_Filters_Http_Oauth2_V3alpha_OAuth2) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

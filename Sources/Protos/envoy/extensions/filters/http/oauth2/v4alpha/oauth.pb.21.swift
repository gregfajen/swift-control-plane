// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/filters/http/oauth2/v4alpha/oauth.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The client_id to be used in the authorize calls. This value will be URL encoded when sent to the OAuth server.
  public var clientID: String = String()

  /// The secret used to retrieve the access token. This value will be URL encoded when sent to the OAuth server.
  public var tokenSecret: Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig {
    get {return _tokenSecret ?? Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig()}
    set {_tokenSecret = newValue}
  }
  /// Returns true if `tokenSecret` has been explicitly set.
  public var hasTokenSecret: Bool {return self._tokenSecret != nil}
  /// Clears the value of `tokenSecret`. Subsequent reads from it will return its default value.
  public mutating func clearTokenSecret() {self._tokenSecret = nil}

  /// Configures how the secret token should be created.
  public var tokenFormation: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials.OneOf_TokenFormation? = nil

  /// If present, the secret token will be a HMAC using the provided secret.
  public var hmacSecret: Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig {
    get {
      if case .hmacSecret(let v)? = tokenFormation {return v}
      return Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig()
    }
    set {tokenFormation = .hmacSecret(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configures how the secret token should be created.
  public enum OneOf_TokenFormation: Equatable {
    /// If present, the secret token will be a HMAC using the provided secret.
    case hmacSecret(Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials.OneOf_TokenFormation, rhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials.OneOf_TokenFormation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hmacSecret, .hmacSecret): return {
        guard case .hmacSecret(let l) = lhs, case .hmacSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _tokenSecret: Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig? = nil
}

/// OAuth config
///
/// [#next-free-field: 9]
public struct Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint on the authorization server to retrieve the access token from.
  public var tokenEndpoint: Envoy_Config_Core_V4alpha_HttpUri {
    get {return _tokenEndpoint ?? Envoy_Config_Core_V4alpha_HttpUri()}
    set {_tokenEndpoint = newValue}
  }
  /// Returns true if `tokenEndpoint` has been explicitly set.
  public var hasTokenEndpoint: Bool {return self._tokenEndpoint != nil}
  /// Clears the value of `tokenEndpoint`. Subsequent reads from it will return its default value.
  public mutating func clearTokenEndpoint() {self._tokenEndpoint = nil}

  /// The endpoint redirect to for authorization in response to unauthorized requests.
  public var authorizationEndpoint: String = String()

  /// Credentials used for OAuth.
  public var credentials: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials {
    get {return _credentials ?? Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials()}
    set {_credentials = newValue}
  }
  /// Returns true if `credentials` has been explicitly set.
  public var hasCredentials: Bool {return self._credentials != nil}
  /// Clears the value of `credentials`. Subsequent reads from it will return its default value.
  public mutating func clearCredentials() {self._credentials = nil}

  /// The redirect URI passed to the authorization endpoint. Supports header formatting
  /// tokens. For more information, including details on header value syntax, see the
  /// documentation on :ref:`custom request headers <config_http_conn_man_headers_custom_request_headers>`.
  ///
  /// This URI should not contain any query parameters.
  public var redirectUri: String = String()

  /// Matching criteria used to determine whether a path appears to be the result of a redirect from the authorization server.
  public var redirectPathMatcher: Envoy_Type_Matcher_V4alpha_PathMatcher {
    get {return _redirectPathMatcher ?? Envoy_Type_Matcher_V4alpha_PathMatcher()}
    set {_redirectPathMatcher = newValue}
  }
  /// Returns true if `redirectPathMatcher` has been explicitly set.
  public var hasRedirectPathMatcher: Bool {return self._redirectPathMatcher != nil}
  /// Clears the value of `redirectPathMatcher`. Subsequent reads from it will return its default value.
  public mutating func clearRedirectPathMatcher() {self._redirectPathMatcher = nil}

  /// The path to sign a user out, clearing their credential cookies.
  public var signoutPath: Envoy_Type_Matcher_V4alpha_PathMatcher {
    get {return _signoutPath ?? Envoy_Type_Matcher_V4alpha_PathMatcher()}
    set {_signoutPath = newValue}
  }
  /// Returns true if `signoutPath` has been explicitly set.
  public var hasSignoutPath: Bool {return self._signoutPath != nil}
  /// Clears the value of `signoutPath`. Subsequent reads from it will return its default value.
  public mutating func clearSignoutPath() {self._signoutPath = nil}

  /// Forward the OAuth token as a Bearer to upstream web service.
  public var forwardBearerToken: Bool = false

  /// Any request that matches any of the provided matchers will be passed through without OAuth validation.
  public var passThroughMatcher: [Envoy_Config_Route_V4alpha_HeaderMatcher] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenEndpoint: Envoy_Config_Core_V4alpha_HttpUri? = nil
  fileprivate var _credentials: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials? = nil
  fileprivate var _redirectPathMatcher: Envoy_Type_Matcher_V4alpha_PathMatcher? = nil
  fileprivate var _signoutPath: Envoy_Type_Matcher_V4alpha_PathMatcher? = nil
}

/// Filter config.
public struct Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Leave this empty to disable OAuth2 for a specific route, using per filter config.
  public var config: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config {
    get {return _config ?? Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.filters.http.oauth2.v4alpha"

extension Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuth2Credentials"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "token_secret"),
    3: .standard(proto: "hmac_secret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tokenSecret) }()
      case 3: try {
        var v: Envoy_Extensions_TransportSockets_Tls_V4alpha_SdsSecretConfig?
        if let current = self.tokenFormation {
          try decoder.handleConflictingOneOf()
          if case .hmacSecret(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.tokenFormation = .hmacSecret(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if let v = self._tokenSecret {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if case .hmacSecret(let v)? = self.tokenFormation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials, rhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Credentials) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs._tokenSecret != rhs._tokenSecret {return false}
    if lhs.tokenFormation != rhs.tokenFormation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuth2Config"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "token_endpoint"),
    2: .standard(proto: "authorization_endpoint"),
    3: .same(proto: "credentials"),
    4: .standard(proto: "redirect_uri"),
    5: .standard(proto: "redirect_path_matcher"),
    6: .standard(proto: "signout_path"),
    7: .standard(proto: "forward_bearer_token"),
    8: .standard(proto: "pass_through_matcher"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tokenEndpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorizationEndpoint) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._credentials) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.redirectUri) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._redirectPathMatcher) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._signoutPath) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.forwardBearerToken) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.passThroughMatcher) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tokenEndpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.authorizationEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationEndpoint, fieldNumber: 2)
    }
    if let v = self._credentials {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.redirectUri.isEmpty {
      try visitor.visitSingularStringField(value: self.redirectUri, fieldNumber: 4)
    }
    if let v = self._redirectPathMatcher {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._signoutPath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.forwardBearerToken != false {
      try visitor.visitSingularBoolField(value: self.forwardBearerToken, fieldNumber: 7)
    }
    if !self.passThroughMatcher.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.passThroughMatcher, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config, rhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2Config) -> Bool {
    if lhs._tokenEndpoint != rhs._tokenEndpoint {return false}
    if lhs.authorizationEndpoint != rhs.authorizationEndpoint {return false}
    if lhs._credentials != rhs._credentials {return false}
    if lhs.redirectUri != rhs.redirectUri {return false}
    if lhs._redirectPathMatcher != rhs._redirectPathMatcher {return false}
    if lhs._signoutPath != rhs._signoutPath {return false}
    if lhs.forwardBearerToken != rhs.forwardBearerToken {return false}
    if lhs.passThroughMatcher != rhs.passThroughMatcher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuth2"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2, rhs: Envoy_Extensions_Filters_Http_Oauth2_V4alpha_OAuth2) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/wasm/v3/wasm.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration for a Wasm VM.
/// [#next-free-field: 7]
public struct Envoy_Extensions_Wasm_V3_VmConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An ID which will be used along with a hash of the wasm code (or the name of the registered Null
  /// VM plugin) to determine which VM will be used for the plugin. All plugins which use the same
  /// *vm_id* and code will use the same VM. May be left blank. Sharing a VM between plugins can
  /// reduce memory utilization and make sharing of data easier which may have security implications.
  /// See ref: "TODO: add ref" for details.
  public var vmID: String = String()

  /// The Wasm runtime type (either "v8" or "null" for code compiled into Envoy).
  public var runtime: String = String()

  /// The Wasm code that Envoy will execute.
  public var code: Envoy_Config_Core_V3_AsyncDataSource {
    get {return _code ?? Envoy_Config_Core_V3_AsyncDataSource()}
    set {_code = newValue}
  }
  /// Returns true if `code` has been explicitly set.
  public var hasCode: Bool {return self._code != nil}
  /// Clears the value of `code`. Subsequent reads from it will return its default value.
  public mutating func clearCode() {self._code = nil}

  /// The Wasm configuration used in initialization of a new VM
  /// (proxy_on_start). `google.protobuf.Struct` is serialized as JSON before
  /// passing it to the plugin. `google.protobuf.BytesValue` and
  /// `google.protobuf.StringValue` are passed directly without the wrapper.
  public var configuration: SwiftProtobuf.Google_Protobuf_Any {
    get {return _configuration ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {self._configuration = nil}

  /// Allow the wasm file to include pre-compiled code on VMs which support it.
  /// Warning: this should only be enable for trusted sources as the precompiled code is not
  /// verified.
  public var allowPrecompiled: Bool = false

  /// If true and the code needs to be remotely fetched and it is not in the cache then NACK the configuration
  /// update and do a background fetch to fill the cache, otherwise fetch the code asynchronously and enter
  /// warming state.
  public var nackOnCodeCacheMiss: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _code: Envoy_Config_Core_V3_AsyncDataSource? = nil
  fileprivate var _configuration: SwiftProtobuf.Google_Protobuf_Any? = nil
}

/// Base Configuration for Wasm Plugins e.g. filters and services.
/// [#next-free-field: 6]
public struct Envoy_Extensions_Wasm_V3_PluginConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique name for a filters/services in a VM for use in identifying the filter/service if
  /// multiple filters/services are handled by the same *vm_id* and *root_id* and for
  /// logging/debugging.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A unique ID for a set of filters/services in a VM which will share a RootContext and Contexts
  /// if applicable (e.g. an Wasm HttpFilter and an Wasm AccessLog). If left blank, all
  /// filters/services with a blank root_id with the same *vm_id* will share Context(s).
  public var rootID: String {
    get {return _storage._rootID}
    set {_uniqueStorage()._rootID = newValue}
  }

  /// Configuration for finding or starting VM.
  public var vm: OneOf_Vm? {
    get {return _storage._vm}
    set {_uniqueStorage()._vm = newValue}
  }

  /// TODO: add referential VM configurations.
  public var vmConfig: Envoy_Extensions_Wasm_V3_VmConfig {
    get {
      if case .vmConfig(let v)? = _storage._vm {return v}
      return Envoy_Extensions_Wasm_V3_VmConfig()
    }
    set {_uniqueStorage()._vm = .vmConfig(newValue)}
  }

  /// Filter/service configuration used to configure or reconfigure a plugin
  /// (proxy_on_configuration).
  /// `google.protobuf.Struct` is serialized as JSON before
  /// passing it to the plugin. `google.protobuf.BytesValue` and
  /// `google.protobuf.StringValue` are passed directly without the wrapper.
  public var configuration: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._configuration ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return _storage._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {_uniqueStorage()._configuration = nil}

  /// If there is a fatal error on the VM (e.g. exception, abort(), on_start or on_configure return false),
  /// then all plugins associated with the VM will either fail closed (by default), e.g. by returning an HTTP 503 error,
  /// or fail open (if 'fail_open' is set to true) by bypassing the filter. Note: when on_start or on_configure return false
  /// during xDS updates the xDS configuration will be rejected and when on_start or on_configuration return false on initial
  /// startup the proxy will not start.
  public var failOpen: Bool {
    get {return _storage._failOpen}
    set {_uniqueStorage()._failOpen = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configuration for finding or starting VM.
  public enum OneOf_Vm: Equatable {
    /// TODO: add referential VM configurations.
    case vmConfig(Envoy_Extensions_Wasm_V3_VmConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Extensions_Wasm_V3_PluginConfig.OneOf_Vm, rhs: Envoy_Extensions_Wasm_V3_PluginConfig.OneOf_Vm) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vmConfig, .vmConfig): return {
        guard case .vmConfig(let l) = lhs, case .vmConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// WasmService is configured as a built-in *envoy.wasm_service* :ref:`WasmService
/// <config_wasm_service>` This opaque configuration will be used to create a Wasm Service.
public struct Envoy_Extensions_Wasm_V3_WasmService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// General plugin configuration.
  public var config: Envoy_Extensions_Wasm_V3_PluginConfig {
    get {return _config ?? Envoy_Extensions_Wasm_V3_PluginConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// If true, create a single VM rather than creating one VM per worker. Such a singleton can
  /// not be used with filters.
  public var singleton: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Envoy_Extensions_Wasm_V3_PluginConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.wasm.v3"

extension Envoy_Extensions_Wasm_V3_VmConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VmConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vm_id"),
    2: .same(proto: "runtime"),
    3: .same(proto: "code"),
    4: .same(proto: "configuration"),
    5: .standard(proto: "allow_precompiled"),
    6: .standard(proto: "nack_on_code_cache_miss"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.vmID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runtime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._code) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowPrecompiled) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.nackOnCodeCacheMiss) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vmID.isEmpty {
      try visitor.visitSingularStringField(value: self.vmID, fieldNumber: 1)
    }
    if !self.runtime.isEmpty {
      try visitor.visitSingularStringField(value: self.runtime, fieldNumber: 2)
    }
    if let v = self._code {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.allowPrecompiled != false {
      try visitor.visitSingularBoolField(value: self.allowPrecompiled, fieldNumber: 5)
    }
    if self.nackOnCodeCacheMiss != false {
      try visitor.visitSingularBoolField(value: self.nackOnCodeCacheMiss, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Wasm_V3_VmConfig, rhs: Envoy_Extensions_Wasm_V3_VmConfig) -> Bool {
    if lhs.vmID != rhs.vmID {return false}
    if lhs.runtime != rhs.runtime {return false}
    if lhs._code != rhs._code {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.allowPrecompiled != rhs.allowPrecompiled {return false}
    if lhs.nackOnCodeCacheMiss != rhs.nackOnCodeCacheMiss {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Wasm_V3_PluginConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PluginConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "root_id"),
    3: .standard(proto: "vm_config"),
    4: .same(proto: "configuration"),
    5: .standard(proto: "fail_open"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _rootID: String = String()
    var _vm: Envoy_Extensions_Wasm_V3_PluginConfig.OneOf_Vm?
    var _configuration: SwiftProtobuf.Google_Protobuf_Any? = nil
    var _failOpen: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _rootID = source._rootID
      _vm = source._vm
      _configuration = source._configuration
      _failOpen = source._failOpen
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._rootID) }()
        case 3: try {
          var v: Envoy_Extensions_Wasm_V3_VmConfig?
          if let current = _storage._vm {
            try decoder.handleConflictingOneOf()
            if case .vmConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._vm = .vmConfig(v)}
        }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._configuration) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._failOpen) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._rootID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rootID, fieldNumber: 2)
      }
      if case .vmConfig(let v)? = _storage._vm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._configuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._failOpen != false {
        try visitor.visitSingularBoolField(value: _storage._failOpen, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Wasm_V3_PluginConfig, rhs: Envoy_Extensions_Wasm_V3_PluginConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._rootID != rhs_storage._rootID {return false}
        if _storage._vm != rhs_storage._vm {return false}
        if _storage._configuration != rhs_storage._configuration {return false}
        if _storage._failOpen != rhs_storage._failOpen {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Wasm_V3_WasmService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WasmService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "singleton"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.singleton) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.singleton != false {
      try visitor.visitSingularBoolField(value: self.singleton, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Wasm_V3_WasmService, rhs: Envoy_Extensions_Wasm_V3_WasmService) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.singleton != rhs.singleton {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

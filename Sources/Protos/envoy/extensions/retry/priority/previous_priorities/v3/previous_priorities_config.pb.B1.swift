// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/retry/priority/previous_priorities/v3/previous_priorities_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A retry host selector that attempts to spread retries between priorities, even if certain
/// priorities would not normally be attempted due to higher priorities being available.
///
/// As priorities get excluded, load will be distributed amongst the remaining healthy priorities
/// based on the relative health of the priorities, matching how load is distributed during regular
/// host selection. For example, given priority healths of {100, 50, 50}, the original load will be
/// {100, 0, 0} (since P0 has capacity to handle 100% of the traffic). If P0 is excluded, the load
/// changes to {0, 50, 50}, because P1 is only able to handle 50% of the traffic, causing the
/// remaining to spill over to P2.
///
/// Each priority attempted will be excluded until there are no healthy priorities left, at which
/// point the list of attempted priorities will be reset, essentially starting from the beginning.
/// For example, given three priorities P0, P1, P2 with healthy % of 100, 0 and 50 respectively, the
/// following sequence of priorities would be selected (assuming update_frequency = 1):
/// Attempt 1: P0 (P0 is 100% healthy)
/// Attempt 2: P2 (P0 already attempted, P2 only healthy priority)
/// Attempt 3: P0 (no healthy priorities, reset)
/// Attempt 4: P2
///
/// In the case of all upstream hosts being unhealthy, no adjustments will be made to the original
/// priority load, so behavior should be identical to not using this plugin.
///
/// Using this PriorityFilter requires rebuilding the priority load, which runs in O(# of
/// priorities), which might incur significant overhead for clusters with many priorities.
/// [#extension: envoy.retry_priorities.previous_priorities]
public struct Envoy_Extensions_Retry_Priority_PreviousPriorities_V3_PreviousPrioritiesConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How often the priority load should be updated based on previously attempted priorities. Useful
  /// to allow each priorities to receive more than one request before being excluded or to reduce
  /// the number of times that the priority load has to be recomputed.
  ///
  /// For example, by setting this to 2, then the first two attempts (initial attempt and first
  /// retry) will use the unmodified priority load. The third and fourth attempt will use priority
  /// load which excludes the priorities routed to with the first two attempts, and the fifth and
  /// sixth attempt will use the priority load excluding the priorities used for the first four
  /// attempts.
  ///
  /// Must be greater than 0.
  public var updateFrequency: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.retry.priority.previous_priorities.v3"

extension Envoy_Extensions_Retry_Priority_PreviousPriorities_V3_PreviousPrioritiesConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreviousPrioritiesConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_frequency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.updateFrequency) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.updateFrequency != 0 {
      try visitor.visitSingularInt32Field(value: self.updateFrequency, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Retry_Priority_PreviousPriorities_V3_PreviousPrioritiesConfig, rhs: Envoy_Extensions_Retry_Priority_PreviousPriorities_V3_PreviousPrioritiesConfig) -> Bool {
    if lhs.updateFrequency != rhs.updateFrequency {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

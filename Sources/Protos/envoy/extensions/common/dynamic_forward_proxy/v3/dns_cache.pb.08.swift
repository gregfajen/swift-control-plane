// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/extensions/common/dynamic_forward_proxy/v3/dns_cache.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration of circuit breakers for resolver.
public struct Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of pending requests that Envoy will allow to the
  /// resolver. If not specified, the default is 1024.
  public var maxPendingRequests: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxPendingRequests ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxPendingRequests = newValue}
  }
  /// Returns true if `maxPendingRequests` has been explicitly set.
  public var hasMaxPendingRequests: Bool {return self._maxPendingRequests != nil}
  /// Clears the value of `maxPendingRequests`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPendingRequests() {self._maxPendingRequests = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxPendingRequests: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// Configuration for the dynamic forward proxy DNS cache. See the :ref:`architecture overview
/// <arch_overview_http_dynamic_forward_proxy>` for more information.
/// [#next-free-field: 9]
public struct Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the cache. Multiple named caches allow independent dynamic forward proxy
  /// configurations to operate within a single Envoy process using different configurations. All
  /// configurations with the same name *must* otherwise have the same settings when referenced
  /// from different configuration components. Configuration will fail to load if this is not
  /// the case.
  public var name: String = String()

  /// The DNS lookup family to use during resolution.
  ///
  /// [#comment:TODO(mattklein123): Figure out how to support IPv4/IPv6 "happy eyeballs" mode. The
  /// way this might work is a new lookup family which returns both IPv4 and IPv6 addresses, and
  /// then configures a host to have a primary and fall back address. With this, we could very
  /// likely build a "happy eyeballs" connection pool which would race the primary / fall back
  /// address and return the one that wins. This same method could potentially also be used for
  /// QUIC to TCP fall back.]
  public var dnsLookupFamily: Envoy_Config_Cluster_V3_Cluster.DnsLookupFamily = .auto

  /// The DNS refresh rate for currently cached DNS hosts. If not specified defaults to 60s.
  ///
  /// .. note:
  ///
  ///  The returned DNS TTL is not currently used to alter the refresh rate. This feature will be
  ///  added in a future change.
  ///
  /// .. note:
  ///
  /// The refresh rate is rounded to the closest millisecond, and must be at least 1ms.
  public var dnsRefreshRate: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _dnsRefreshRate ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_dnsRefreshRate = newValue}
  }
  /// Returns true if `dnsRefreshRate` has been explicitly set.
  public var hasDnsRefreshRate: Bool {return self._dnsRefreshRate != nil}
  /// Clears the value of `dnsRefreshRate`. Subsequent reads from it will return its default value.
  public mutating func clearDnsRefreshRate() {self._dnsRefreshRate = nil}

  /// The TTL for hosts that are unused. Hosts that have not been used in the configured time
  /// interval will be purged. If not specified defaults to 5m.
  ///
  /// .. note:
  ///
  ///   The TTL is only checked at the time of DNS refresh, as specified by *dns_refresh_rate*. This
  ///   means that if the configured TTL is shorter than the refresh rate the host may not be removed
  ///   immediately.
  ///
  ///  .. note:
  ///
  ///   The TTL has no relation to DNS TTL and is only used to control Envoy's resource usage.
  public var hostTtl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _hostTtl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_hostTtl = newValue}
  }
  /// Returns true if `hostTtl` has been explicitly set.
  public var hasHostTtl: Bool {return self._hostTtl != nil}
  /// Clears the value of `hostTtl`. Subsequent reads from it will return its default value.
  public mutating func clearHostTtl() {self._hostTtl = nil}

  /// The maximum number of hosts that the cache will hold. If not specified defaults to 1024.
  ///
  /// .. note:
  ///
  ///   The implementation is approximate and enforced independently on each worker thread, thus
  ///   it is possible for the maximum hosts in the cache to go slightly above the configured
  ///   value depending on timing. This is similar to how other circuit breakers work.
  public var maxHosts: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxHosts ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxHosts = newValue}
  }
  /// Returns true if `maxHosts` has been explicitly set.
  public var hasMaxHosts: Bool {return self._maxHosts != nil}
  /// Clears the value of `maxHosts`. Subsequent reads from it will return its default value.
  public mutating func clearMaxHosts() {self._maxHosts = nil}

  /// If the DNS failure refresh rate is specified,
  /// this is used as the cache's DNS refresh rate when DNS requests are failing. If this setting is
  /// not specified, the failure refresh rate defaults to the dns_refresh_rate.
  public var dnsFailureRefreshRate: Envoy_Config_Cluster_V3_Cluster.RefreshRate {
    get {return _dnsFailureRefreshRate ?? Envoy_Config_Cluster_V3_Cluster.RefreshRate()}
    set {_dnsFailureRefreshRate = newValue}
  }
  /// Returns true if `dnsFailureRefreshRate` has been explicitly set.
  public var hasDnsFailureRefreshRate: Bool {return self._dnsFailureRefreshRate != nil}
  /// Clears the value of `dnsFailureRefreshRate`. Subsequent reads from it will return its default value.
  public mutating func clearDnsFailureRefreshRate() {self._dnsFailureRefreshRate = nil}

  /// The config of circuit breakers for resolver. It provides a configurable threshold.
  /// If `envoy.reloadable_features.enable_dns_cache_circuit_breakers` is enabled,
  /// envoy will use dns cache circuit breakers with default settings even if this value is not set.
  public var dnsCacheCircuitBreaker: Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers {
    get {return _dnsCacheCircuitBreaker ?? Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers()}
    set {_dnsCacheCircuitBreaker = newValue}
  }
  /// Returns true if `dnsCacheCircuitBreaker` has been explicitly set.
  public var hasDnsCacheCircuitBreaker: Bool {return self._dnsCacheCircuitBreaker != nil}
  /// Clears the value of `dnsCacheCircuitBreaker`. Subsequent reads from it will return its default value.
  public mutating func clearDnsCacheCircuitBreaker() {self._dnsCacheCircuitBreaker = nil}

  /// [#next-major-version: Reconcile DNS options in a single message.]
  /// Always use TCP queries instead of UDP queries for DNS lookups.
  /// Setting this value causes failure if the
  /// ``envoy.restart_features.use_apple_api_for_dns_lookups`` runtime value is true during
  /// server startup. Apple' API only uses UDP for DNS resolution.
  public var useTcpForDnsLookups: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dnsRefreshRate: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _hostTtl: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxHosts: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _dnsFailureRefreshRate: Envoy_Config_Cluster_V3_Cluster.RefreshRate? = nil
  fileprivate var _dnsCacheCircuitBreaker: Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.extensions.common.dynamic_forward_proxy.v3"

extension Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DnsCacheCircuitBreakers"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_pending_requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._maxPendingRequests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._maxPendingRequests {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers, rhs: Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheCircuitBreakers) -> Bool {
    if lhs._maxPendingRequests != rhs._maxPendingRequests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DnsCacheConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "dns_lookup_family"),
    3: .standard(proto: "dns_refresh_rate"),
    4: .standard(proto: "host_ttl"),
    5: .standard(proto: "max_hosts"),
    6: .standard(proto: "dns_failure_refresh_rate"),
    7: .standard(proto: "dns_cache_circuit_breaker"),
    8: .standard(proto: "use_tcp_for_dns_lookups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dnsLookupFamily) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._dnsRefreshRate) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._hostTtl) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxHosts) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dnsFailureRefreshRate) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._dnsCacheCircuitBreaker) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.useTcpForDnsLookups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.dnsLookupFamily != .auto {
      try visitor.visitSingularEnumField(value: self.dnsLookupFamily, fieldNumber: 2)
    }
    if let v = self._dnsRefreshRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._hostTtl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._maxHosts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._dnsFailureRefreshRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._dnsCacheCircuitBreaker {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if self.useTcpForDnsLookups != false {
      try visitor.visitSingularBoolField(value: self.useTcpForDnsLookups, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheConfig, rhs: Envoy_Extensions_Common_DynamicForwardProxy_V3_DnsCacheConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.dnsLookupFamily != rhs.dnsLookupFamily {return false}
    if lhs._dnsRefreshRate != rhs._dnsRefreshRate {return false}
    if lhs._hostTtl != rhs._hostTtl {return false}
    if lhs._maxHosts != rhs._maxHosts {return false}
    if lhs._dnsFailureRefreshRate != rhs._dnsFailureRefreshRate {return false}
    if lhs._dnsCacheCircuitBreaker != rhs._dnsCacheCircuitBreaker {return false}
    if lhs.useTcpForDnsLookups != rhs.useTcpForDnsLookups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

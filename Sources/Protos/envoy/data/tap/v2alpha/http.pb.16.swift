// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/data/tap/v2alpha/http.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A fully buffered HTTP trace message.
public struct Envoy_Data_Tap_V2alpha_HttpBufferedTrace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Request message.
  public var request: Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message {
    get {return _request ?? Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {self._request = nil}

  /// Response message.
  public var response: Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message {
    get {return _response ?? Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {self._response = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// HTTP message wrapper.
  public struct Message {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Message headers.
    public var headers: [Envoy_Api_V2_Core_HeaderValue] = []

    /// Message body.
    public var body: Envoy_Data_Tap_V2alpha_Body {
      get {return _body ?? Envoy_Data_Tap_V2alpha_Body()}
      set {_body = newValue}
    }
    /// Returns true if `body` has been explicitly set.
    public var hasBody: Bool {return self._body != nil}
    /// Clears the value of `body`. Subsequent reads from it will return its default value.
    public mutating func clearBody() {self._body = nil}

    /// Message trailers.
    public var trailers: [Envoy_Api_V2_Core_HeaderValue] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _body: Envoy_Data_Tap_V2alpha_Body? = nil
  }

  public init() {}

  fileprivate var _request: Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message? = nil
  fileprivate var _response: Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message? = nil
}

/// A streamed HTTP trace segment. Multiple segments make up a full trace.
/// [#next-free-field: 8]
public struct Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Trace ID unique to the originating Envoy only. Trace IDs can repeat and should not be used
  /// for long term stable uniqueness.
  public var traceID: UInt64 = 0

  public var messagePiece: Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment.OneOf_MessagePiece? = nil

  /// Request headers.
  public var requestHeaders: Envoy_Api_V2_Core_HeaderMap {
    get {
      if case .requestHeaders(let v)? = messagePiece {return v}
      return Envoy_Api_V2_Core_HeaderMap()
    }
    set {messagePiece = .requestHeaders(newValue)}
  }

  /// Request body chunk.
  public var requestBodyChunk: Envoy_Data_Tap_V2alpha_Body {
    get {
      if case .requestBodyChunk(let v)? = messagePiece {return v}
      return Envoy_Data_Tap_V2alpha_Body()
    }
    set {messagePiece = .requestBodyChunk(newValue)}
  }

  /// Request trailers.
  public var requestTrailers: Envoy_Api_V2_Core_HeaderMap {
    get {
      if case .requestTrailers(let v)? = messagePiece {return v}
      return Envoy_Api_V2_Core_HeaderMap()
    }
    set {messagePiece = .requestTrailers(newValue)}
  }

  /// Response headers.
  public var responseHeaders: Envoy_Api_V2_Core_HeaderMap {
    get {
      if case .responseHeaders(let v)? = messagePiece {return v}
      return Envoy_Api_V2_Core_HeaderMap()
    }
    set {messagePiece = .responseHeaders(newValue)}
  }

  /// Response body chunk.
  public var responseBodyChunk: Envoy_Data_Tap_V2alpha_Body {
    get {
      if case .responseBodyChunk(let v)? = messagePiece {return v}
      return Envoy_Data_Tap_V2alpha_Body()
    }
    set {messagePiece = .responseBodyChunk(newValue)}
  }

  /// Response trailers.
  public var responseTrailers: Envoy_Api_V2_Core_HeaderMap {
    get {
      if case .responseTrailers(let v)? = messagePiece {return v}
      return Envoy_Api_V2_Core_HeaderMap()
    }
    set {messagePiece = .responseTrailers(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MessagePiece: Equatable {
    /// Request headers.
    case requestHeaders(Envoy_Api_V2_Core_HeaderMap)
    /// Request body chunk.
    case requestBodyChunk(Envoy_Data_Tap_V2alpha_Body)
    /// Request trailers.
    case requestTrailers(Envoy_Api_V2_Core_HeaderMap)
    /// Response headers.
    case responseHeaders(Envoy_Api_V2_Core_HeaderMap)
    /// Response body chunk.
    case responseBodyChunk(Envoy_Data_Tap_V2alpha_Body)
    /// Response trailers.
    case responseTrailers(Envoy_Api_V2_Core_HeaderMap)

  #if !swift(>=4.1)
    public static func ==(lhs: Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment.OneOf_MessagePiece, rhs: Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment.OneOf_MessagePiece) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.requestHeaders, .requestHeaders): return {
        guard case .requestHeaders(let l) = lhs, case .requestHeaders(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestBodyChunk, .requestBodyChunk): return {
        guard case .requestBodyChunk(let l) = lhs, case .requestBodyChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestTrailers, .requestTrailers): return {
        guard case .requestTrailers(let l) = lhs, case .requestTrailers(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responseHeaders, .responseHeaders): return {
        guard case .responseHeaders(let l) = lhs, case .responseHeaders(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responseBodyChunk, .responseBodyChunk): return {
        guard case .responseBodyChunk(let l) = lhs, case .responseBodyChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.responseTrailers, .responseTrailers): return {
        guard case .responseTrailers(let l) = lhs, case .responseTrailers(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.data.tap.v2alpha"

extension Envoy_Data_Tap_V2alpha_HttpBufferedTrace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpBufferedTrace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Tap_V2alpha_HttpBufferedTrace, rhs: Envoy_Data_Tap_V2alpha_HttpBufferedTrace) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Data_Tap_V2alpha_HttpBufferedTrace.protoMessageName + ".Message"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "headers"),
    2: .same(proto: "body"),
    3: .same(proto: "trailers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.headers) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.trailers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.headers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.headers, fieldNumber: 1)
    }
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.trailers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trailers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message, rhs: Envoy_Data_Tap_V2alpha_HttpBufferedTrace.Message) -> Bool {
    if lhs.headers != rhs.headers {return false}
    if lhs._body != rhs._body {return false}
    if lhs.trailers != rhs.trailers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpStreamedTraceSegment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trace_id"),
    2: .standard(proto: "request_headers"),
    3: .standard(proto: "request_body_chunk"),
    4: .standard(proto: "request_trailers"),
    5: .standard(proto: "response_headers"),
    6: .standard(proto: "response_body_chunk"),
    7: .standard(proto: "response_trailers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.traceID) }()
      case 2: try {
        var v: Envoy_Api_V2_Core_HeaderMap?
        if let current = self.messagePiece {
          try decoder.handleConflictingOneOf()
          if case .requestHeaders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.messagePiece = .requestHeaders(v)}
      }()
      case 3: try {
        var v: Envoy_Data_Tap_V2alpha_Body?
        if let current = self.messagePiece {
          try decoder.handleConflictingOneOf()
          if case .requestBodyChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.messagePiece = .requestBodyChunk(v)}
      }()
      case 4: try {
        var v: Envoy_Api_V2_Core_HeaderMap?
        if let current = self.messagePiece {
          try decoder.handleConflictingOneOf()
          if case .requestTrailers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.messagePiece = .requestTrailers(v)}
      }()
      case 5: try {
        var v: Envoy_Api_V2_Core_HeaderMap?
        if let current = self.messagePiece {
          try decoder.handleConflictingOneOf()
          if case .responseHeaders(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.messagePiece = .responseHeaders(v)}
      }()
      case 6: try {
        var v: Envoy_Data_Tap_V2alpha_Body?
        if let current = self.messagePiece {
          try decoder.handleConflictingOneOf()
          if case .responseBodyChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.messagePiece = .responseBodyChunk(v)}
      }()
      case 7: try {
        var v: Envoy_Api_V2_Core_HeaderMap?
        if let current = self.messagePiece {
          try decoder.handleConflictingOneOf()
          if case .responseTrailers(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.messagePiece = .responseTrailers(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.traceID != 0 {
      try visitor.visitSingularUInt64Field(value: self.traceID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.messagePiece {
    case .requestHeaders?: try {
      guard case .requestHeaders(let v)? = self.messagePiece else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .requestBodyChunk?: try {
      guard case .requestBodyChunk(let v)? = self.messagePiece else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .requestTrailers?: try {
      guard case .requestTrailers(let v)? = self.messagePiece else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .responseHeaders?: try {
      guard case .responseHeaders(let v)? = self.messagePiece else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .responseBodyChunk?: try {
      guard case .responseBodyChunk(let v)? = self.messagePiece else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .responseTrailers?: try {
      guard case .responseTrailers(let v)? = self.messagePiece else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment, rhs: Envoy_Data_Tap_V2alpha_HttpStreamedTraceSegment) -> Bool {
    if lhs.traceID != rhs.traceID {return false}
    if lhs.messagePiece != rhs.messagePiece {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

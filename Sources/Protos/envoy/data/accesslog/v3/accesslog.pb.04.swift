// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/data/accesslog/v3/accesslog.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Envoy_Data_Accesslog_V3_TCPAccessLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common properties shared by all Envoy access logs.
  public var commonProperties: Envoy_Data_Accesslog_V3_AccessLogCommon {
    get {return _commonProperties ?? Envoy_Data_Accesslog_V3_AccessLogCommon()}
    set {_commonProperties = newValue}
  }
  /// Returns true if `commonProperties` has been explicitly set.
  public var hasCommonProperties: Bool {return self._commonProperties != nil}
  /// Clears the value of `commonProperties`. Subsequent reads from it will return its default value.
  public mutating func clearCommonProperties() {self._commonProperties = nil}

  /// Properties of the TCP connection.
  public var connectionProperties: Envoy_Data_Accesslog_V3_ConnectionProperties {
    get {return _connectionProperties ?? Envoy_Data_Accesslog_V3_ConnectionProperties()}
    set {_connectionProperties = newValue}
  }
  /// Returns true if `connectionProperties` has been explicitly set.
  public var hasConnectionProperties: Bool {return self._connectionProperties != nil}
  /// Clears the value of `connectionProperties`. Subsequent reads from it will return its default value.
  public mutating func clearConnectionProperties() {self._connectionProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commonProperties: Envoy_Data_Accesslog_V3_AccessLogCommon? = nil
  fileprivate var _connectionProperties: Envoy_Data_Accesslog_V3_ConnectionProperties? = nil
}

public struct Envoy_Data_Accesslog_V3_HTTPAccessLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common properties shared by all Envoy access logs.
  public var commonProperties: Envoy_Data_Accesslog_V3_AccessLogCommon {
    get {return _storage._commonProperties ?? Envoy_Data_Accesslog_V3_AccessLogCommon()}
    set {_uniqueStorage()._commonProperties = newValue}
  }
  /// Returns true if `commonProperties` has been explicitly set.
  public var hasCommonProperties: Bool {return _storage._commonProperties != nil}
  /// Clears the value of `commonProperties`. Subsequent reads from it will return its default value.
  public mutating func clearCommonProperties() {_uniqueStorage()._commonProperties = nil}

  public var protocolVersion: Envoy_Data_Accesslog_V3_HTTPAccessLogEntry.HTTPVersion {
    get {return _storage._protocolVersion}
    set {_uniqueStorage()._protocolVersion = newValue}
  }

  /// Description of the incoming HTTP request.
  public var request: Envoy_Data_Accesslog_V3_HTTPRequestProperties {
    get {return _storage._request ?? Envoy_Data_Accesslog_V3_HTTPRequestProperties()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {_uniqueStorage()._request = nil}

  /// Description of the outgoing HTTP response.
  public var response: Envoy_Data_Accesslog_V3_HTTPResponseProperties {
    get {return _storage._response ?? Envoy_Data_Accesslog_V3_HTTPResponseProperties()}
    set {_uniqueStorage()._response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return _storage._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {_uniqueStorage()._response = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// HTTP version
  public enum HTTPVersion: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case protocolUnspecified // = 0
    case http10 // = 1
    case http11 // = 2
    case http2 // = 3
    case http3 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .protocolUnspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .protocolUnspecified
      case 1: self = .http10
      case 2: self = .http11
      case 3: self = .http2
      case 4: self = .http3
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .protocolUnspecified: return 0
      case .http10: return 1
      case .http11: return 2
      case .http2: return 3
      case .http3: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Data_Accesslog_V3_HTTPAccessLogEntry.HTTPVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Data_Accesslog_V3_HTTPAccessLogEntry.HTTPVersion] = [
    .protocolUnspecified,
    .http10,
    .http11,
    .http2,
    .http3,
  ]
}

#endif  // swift(>=4.2)

/// Defines fields for a connection
public struct Envoy_Data_Accesslog_V3_ConnectionProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of bytes received from downstream.
  public var receivedBytes: UInt64 = 0

  /// Number of bytes sent to downstream.
  public var sentBytes: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Defines fields that are shared by all Envoy access logs.
/// [#next-free-field: 22]
public struct Envoy_Data_Accesslog_V3_AccessLogCommon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [#not-implemented-hide:]
  /// This field indicates the rate at which this log entry was sampled.
  /// Valid range is (0.0, 1.0].
  public var sampleRate: Double {
    get {return _storage._sampleRate}
    set {_uniqueStorage()._sampleRate = newValue}
  }

  /// This field is the remote/origin address on which the request from the user was received.
  /// Note: This may not be the physical peer. E.g, if the remote address is inferred from for
  /// example the x-forwarder-for header, proxy protocol, etc.
  public var downstreamRemoteAddress: Envoy_Config_Core_V3_Address {
    get {return _storage._downstreamRemoteAddress ?? Envoy_Config_Core_V3_Address()}
    set {_uniqueStorage()._downstreamRemoteAddress = newValue}
  }
  /// Returns true if `downstreamRemoteAddress` has been explicitly set.
  public var hasDownstreamRemoteAddress: Bool {return _storage._downstreamRemoteAddress != nil}
  /// Clears the value of `downstreamRemoteAddress`. Subsequent reads from it will return its default value.
  public mutating func clearDownstreamRemoteAddress() {_uniqueStorage()._downstreamRemoteAddress = nil}

  /// This field is the local/destination address on which the request from the user was received.
  public var downstreamLocalAddress: Envoy_Config_Core_V3_Address {
    get {return _storage._downstreamLocalAddress ?? Envoy_Config_Core_V3_Address()}
    set {_uniqueStorage()._downstreamLocalAddress = newValue}
  }
  /// Returns true if `downstreamLocalAddress` has been explicitly set.
  public var hasDownstreamLocalAddress: Bool {return _storage._downstreamLocalAddress != nil}
  /// Clears the value of `downstreamLocalAddress`. Subsequent reads from it will return its default value.
  public mutating func clearDownstreamLocalAddress() {_uniqueStorage()._downstreamLocalAddress = nil}

  /// If the connection is secure,S this field will contain TLS properties.
  public var tlsProperties: Envoy_Data_Accesslog_V3_TLSProperties {
    get {return _storage._tlsProperties ?? Envoy_Data_Accesslog_V3_TLSProperties()}
    set {_uniqueStorage()._tlsProperties = newValue}
  }
  /// Returns true if `tlsProperties` has been explicitly set.
  public var hasTlsProperties: Bool {return _storage._tlsProperties != nil}
  /// Clears the value of `tlsProperties`. Subsequent reads from it will return its default value.
  public mutating func clearTlsProperties() {_uniqueStorage()._tlsProperties = nil}

  /// The time that Envoy started servicing this request. This is effectively the time that the first
  /// downstream byte is received.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Interval between the first downstream byte received and the last
  /// downstream byte received (i.e. time it takes to receive a request).
  public var timeToLastRxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToLastRxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToLastRxByte = newValue}
  }
  /// Returns true if `timeToLastRxByte` has been explicitly set.
  public var hasTimeToLastRxByte: Bool {return _storage._timeToLastRxByte != nil}
  /// Clears the value of `timeToLastRxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToLastRxByte() {_uniqueStorage()._timeToLastRxByte = nil}

  /// Interval between the first downstream byte received and the first upstream byte sent. There may
  /// by considerable delta between *time_to_last_rx_byte* and this value due to filters.
  /// Additionally, the same caveats apply as documented in *time_to_last_downstream_tx_byte* about
  /// not accounting for kernel socket buffer time, etc.
  public var timeToFirstUpstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToFirstUpstreamTxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToFirstUpstreamTxByte = newValue}
  }
  /// Returns true if `timeToFirstUpstreamTxByte` has been explicitly set.
  public var hasTimeToFirstUpstreamTxByte: Bool {return _storage._timeToFirstUpstreamTxByte != nil}
  /// Clears the value of `timeToFirstUpstreamTxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToFirstUpstreamTxByte() {_uniqueStorage()._timeToFirstUpstreamTxByte = nil}

  /// Interval between the first downstream byte received and the last upstream byte sent. There may
  /// by considerable delta between *time_to_last_rx_byte* and this value due to filters.
  /// Additionally, the same caveats apply as documented in *time_to_last_downstream_tx_byte* about
  /// not accounting for kernel socket buffer time, etc.
  public var timeToLastUpstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToLastUpstreamTxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToLastUpstreamTxByte = newValue}
  }
  /// Returns true if `timeToLastUpstreamTxByte` has been explicitly set.
  public var hasTimeToLastUpstreamTxByte: Bool {return _storage._timeToLastUpstreamTxByte != nil}
  /// Clears the value of `timeToLastUpstreamTxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToLastUpstreamTxByte() {_uniqueStorage()._timeToLastUpstreamTxByte = nil}

  /// Interval between the first downstream byte received and the first upstream
  /// byte received (i.e. time it takes to start receiving a response).
  public var timeToFirstUpstreamRxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToFirstUpstreamRxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToFirstUpstreamRxByte = newValue}
  }
  /// Returns true if `timeToFirstUpstreamRxByte` has been explicitly set.
  public var hasTimeToFirstUpstreamRxByte: Bool {return _storage._timeToFirstUpstreamRxByte != nil}
  /// Clears the value of `timeToFirstUpstreamRxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToFirstUpstreamRxByte() {_uniqueStorage()._timeToFirstUpstreamRxByte = nil}

  /// Interval between the first downstream byte received and the last upstream
  /// byte received (i.e. time it takes to receive a complete response).
  public var timeToLastUpstreamRxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToLastUpstreamRxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToLastUpstreamRxByte = newValue}
  }
  /// Returns true if `timeToLastUpstreamRxByte` has been explicitly set.
  public var hasTimeToLastUpstreamRxByte: Bool {return _storage._timeToLastUpstreamRxByte != nil}
  /// Clears the value of `timeToLastUpstreamRxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToLastUpstreamRxByte() {_uniqueStorage()._timeToLastUpstreamRxByte = nil}

  /// Interval between the first downstream byte received and the first downstream byte sent.
  /// There may be a considerable delta between the *time_to_first_upstream_rx_byte* and this field
  /// due to filters. Additionally, the same caveats apply as documented in
  /// *time_to_last_downstream_tx_byte* about not accounting for kernel socket buffer time, etc.
  public var timeToFirstDownstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToFirstDownstreamTxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToFirstDownstreamTxByte = newValue}
  }
  /// Returns true if `timeToFirstDownstreamTxByte` has been explicitly set.
  public var hasTimeToFirstDownstreamTxByte: Bool {return _storage._timeToFirstDownstreamTxByte != nil}
  /// Clears the value of `timeToFirstDownstreamTxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToFirstDownstreamTxByte() {_uniqueStorage()._timeToFirstDownstreamTxByte = nil}

  /// Interval between the first downstream byte received and the last downstream byte sent.
  /// Depending on protocol, buffering, windowing, filters, etc. there may be a considerable delta
  /// between *time_to_last_upstream_rx_byte* and this field. Note also that this is an approximate
  /// time. In the current implementation it does not include kernel socket buffer time. In the
  /// current implementation it also does not include send window buffering inside the HTTP/2 codec.
  /// In the future it is likely that work will be done to make this duration more accurate.
  public var timeToLastDownstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeToLastDownstreamTxByte ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeToLastDownstreamTxByte = newValue}
  }
  /// Returns true if `timeToLastDownstreamTxByte` has been explicitly set.
  public var hasTimeToLastDownstreamTxByte: Bool {return _storage._timeToLastDownstreamTxByte != nil}
  /// Clears the value of `timeToLastDownstreamTxByte`. Subsequent reads from it will return its default value.
  public mutating func clearTimeToLastDownstreamTxByte() {_uniqueStorage()._timeToLastDownstreamTxByte = nil}

  /// The upstream remote/destination address that handles this exchange. This does not include
  /// retries.
  public var upstreamRemoteAddress: Envoy_Config_Core_V3_Address {
    get {return _storage._upstreamRemoteAddress ?? Envoy_Config_Core_V3_Address()}
    set {_uniqueStorage()._upstreamRemoteAddress = newValue}
  }
  /// Returns true if `upstreamRemoteAddress` has been explicitly set.
  public var hasUpstreamRemoteAddress: Bool {return _storage._upstreamRemoteAddress != nil}
  /// Clears the value of `upstreamRemoteAddress`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamRemoteAddress() {_uniqueStorage()._upstreamRemoteAddress = nil}

  /// The upstream local/origin address that handles this exchange. This does not include retries.
  public var upstreamLocalAddress: Envoy_Config_Core_V3_Address {
    get {return _storage._upstreamLocalAddress ?? Envoy_Config_Core_V3_Address()}
    set {_uniqueStorage()._upstreamLocalAddress = newValue}
  }
  /// Returns true if `upstreamLocalAddress` has been explicitly set.
  public var hasUpstreamLocalAddress: Bool {return _storage._upstreamLocalAddress != nil}
  /// Clears the value of `upstreamLocalAddress`. Subsequent reads from it will return its default value.
  public mutating func clearUpstreamLocalAddress() {_uniqueStorage()._upstreamLocalAddress = nil}

  /// The upstream cluster that *upstream_remote_address* belongs to.
  public var upstreamCluster: String {
    get {return _storage._upstreamCluster}
    set {_uniqueStorage()._upstreamCluster = newValue}
  }

  /// Flags indicating occurrences during request/response processing.
  public var responseFlags: Envoy_Data_Accesslog_V3_ResponseFlags {
    get {return _storage._responseFlags ?? Envoy_Data_Accesslog_V3_ResponseFlags()}
    set {_uniqueStorage()._responseFlags = newValue}
  }
  /// Returns true if `responseFlags` has been explicitly set.
  public var hasResponseFlags: Bool {return _storage._responseFlags != nil}
  /// Clears the value of `responseFlags`. Subsequent reads from it will return its default value.
  public mutating func clearResponseFlags() {_uniqueStorage()._responseFlags = nil}

  /// All metadata encountered during request processing, including endpoint
  /// selection.
  ///
  /// This can be used to associate IDs attached to the various configurations
  /// used to process this request with the access log entry. For example, a
  /// route created from a higher level forwarding rule with some ID can place
  /// that ID in this field and cross reference later. It can also be used to
  /// determine if a canary endpoint was used or not.
  public var metadata: Envoy_Config_Core_V3_Metadata {
    get {return _storage._metadata ?? Envoy_Config_Core_V3_Metadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// If upstream connection failed due to transport socket (e.g. TLS handshake), provides the
  /// failure reason from the transport socket. The format of this field depends on the configured
  /// upstream transport socket. Common TLS failures are in
  /// :ref:`TLS trouble shooting <arch_overview_ssl_trouble_shooting>`.
  public var upstreamTransportFailureReason: String {
    get {return _storage._upstreamTransportFailureReason}
    set {_uniqueStorage()._upstreamTransportFailureReason = newValue}
  }

  /// The name of the route
  public var routeName: String {
    get {return _storage._routeName}
    set {_uniqueStorage()._routeName = newValue}
  }

  /// This field is the downstream direct remote address on which the request from the user was
  /// received. Note: This is always the physical peer, even if the remote address is inferred from
  /// for example the x-forwarder-for header, proxy protocol, etc.
  public var downstreamDirectRemoteAddress: Envoy_Config_Core_V3_Address {
    get {return _storage._downstreamDirectRemoteAddress ?? Envoy_Config_Core_V3_Address()}
    set {_uniqueStorage()._downstreamDirectRemoteAddress = newValue}
  }
  /// Returns true if `downstreamDirectRemoteAddress` has been explicitly set.
  public var hasDownstreamDirectRemoteAddress: Bool {return _storage._downstreamDirectRemoteAddress != nil}
  /// Clears the value of `downstreamDirectRemoteAddress`. Subsequent reads from it will return its default value.
  public mutating func clearDownstreamDirectRemoteAddress() {_uniqueStorage()._downstreamDirectRemoteAddress = nil}

  /// Map of filter state in stream info that have been configured to be logged. If the filter
  /// state serialized to any message other than `google.protobuf.Any` it will be packed into
  /// `google.protobuf.Any`.
  public var filterStateObjects: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> {
    get {return _storage._filterStateObjects}
    set {_uniqueStorage()._filterStateObjects = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Flags indicating occurrences during request/response processing.
/// [#next-free-field: 24]
public struct Envoy_Data_Accesslog_V3_ResponseFlags {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates local server healthcheck failed.
  public var failedLocalHealthcheck: Bool {
    get {return _storage._failedLocalHealthcheck}
    set {_uniqueStorage()._failedLocalHealthcheck = newValue}
  }

  /// Indicates there was no healthy upstream.
  public var noHealthyUpstream: Bool {
    get {return _storage._noHealthyUpstream}
    set {_uniqueStorage()._noHealthyUpstream = newValue}
  }

  /// Indicates an there was an upstream request timeout.
  public var upstreamRequestTimeout: Bool {
    get {return _storage._upstreamRequestTimeout}
    set {_uniqueStorage()._upstreamRequestTimeout = newValue}
  }

  /// Indicates local codec level reset was sent on the stream.
  public var localReset: Bool {
    get {return _storage._localReset}
    set {_uniqueStorage()._localReset = newValue}
  }

  /// Indicates remote codec level reset was received on the stream.
  public var upstreamRemoteReset: Bool {
    get {return _storage._upstreamRemoteReset}
    set {_uniqueStorage()._upstreamRemoteReset = newValue}
  }

  /// Indicates there was a local reset by a connection pool due to an initial connection failure.
  public var upstreamConnectionFailure: Bool {
    get {return _storage._upstreamConnectionFailure}
    set {_uniqueStorage()._upstreamConnectionFailure = newValue}
  }

  /// Indicates the stream was reset due to an upstream connection termination.
  public var upstreamConnectionTermination: Bool {
    get {return _storage._upstreamConnectionTermination}
    set {_uniqueStorage()._upstreamConnectionTermination = newValue}
  }

  /// Indicates the stream was reset because of a resource overflow.
  public var upstreamOverflow: Bool {
    get {return _storage._upstreamOverflow}
    set {_uniqueStorage()._upstreamOverflow = newValue}
  }

  /// Indicates no route was found for the request.
  public var noRouteFound: Bool {
    get {return _storage._noRouteFound}
    set {_uniqueStorage()._noRouteFound = newValue}
  }

  /// Indicates that the request was delayed before proxying.
  public var delayInjected: Bool {
    get {return _storage._delayInjected}
    set {_uniqueStorage()._delayInjected = newValue}
  }

  /// Indicates that the request was aborted with an injected error code.
  public var faultInjected: Bool {
    get {return _storage._faultInjected}
    set {_uniqueStorage()._faultInjected = newValue}
  }

  /// Indicates that the request was rate-limited locally.
  public var rateLimited: Bool {
    get {return _storage._rateLimited}
    set {_uniqueStorage()._rateLimited = newValue}
  }

  /// Indicates if the request was deemed unauthorized and the reason for it.
  public var unauthorizedDetails: Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized {
    get {return _storage._unauthorizedDetails ?? Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized()}
    set {_uniqueStorage()._unauthorizedDetails = newValue}
  }
  /// Returns true if `unauthorizedDetails` has been explicitly set.
  public var hasUnauthorizedDetails: Bool {return _storage._unauthorizedDetails != nil}
  /// Clears the value of `unauthorizedDetails`. Subsequent reads from it will return its default value.
  public mutating func clearUnauthorizedDetails() {_uniqueStorage()._unauthorizedDetails = nil}

  /// Indicates that the request was rejected because there was an error in rate limit service.
  public var rateLimitServiceError: Bool {
    get {return _storage._rateLimitServiceError}
    set {_uniqueStorage()._rateLimitServiceError = newValue}
  }

  /// Indicates the stream was reset due to a downstream connection termination.
  public var downstreamConnectionTermination: Bool {
    get {return _storage._downstreamConnectionTermination}
    set {_uniqueStorage()._downstreamConnectionTermination = newValue}
  }

  /// Indicates that the upstream retry limit was exceeded, resulting in a downstream error.
  public var upstreamRetryLimitExceeded: Bool {
    get {return _storage._upstreamRetryLimitExceeded}
    set {_uniqueStorage()._upstreamRetryLimitExceeded = newValue}
  }

  /// Indicates that the stream idle timeout was hit, resulting in a downstream 408.
  public var streamIdleTimeout: Bool {
    get {return _storage._streamIdleTimeout}
    set {_uniqueStorage()._streamIdleTimeout = newValue}
  }

  /// Indicates that the request was rejected because an envoy request header failed strict
  /// validation.
  public var invalidEnvoyRequestHeaders: Bool {
    get {return _storage._invalidEnvoyRequestHeaders}
    set {_uniqueStorage()._invalidEnvoyRequestHeaders = newValue}
  }

  /// Indicates there was an HTTP protocol error on the downstream request.
  public var downstreamProtocolError: Bool {
    get {return _storage._downstreamProtocolError}
    set {_uniqueStorage()._downstreamProtocolError = newValue}
  }

  /// Indicates there was a max stream duration reached on the upstream request.
  public var upstreamMaxStreamDurationReached: Bool {
    get {return _storage._upstreamMaxStreamDurationReached}
    set {_uniqueStorage()._upstreamMaxStreamDurationReached = newValue}
  }

  /// Indicates the response was served from a cache filter.
  public var responseFromCacheFilter: Bool {
    get {return _storage._responseFromCacheFilter}
    set {_uniqueStorage()._responseFromCacheFilter = newValue}
  }

  /// Indicates that a filter configuration is not available.
  public var noFilterConfigFound: Bool {
    get {return _storage._noFilterConfigFound}
    set {_uniqueStorage()._noFilterConfigFound = newValue}
  }

  /// Indicates that request or connection exceeded the downstream connection duration.
  public var durationTimeout: Bool {
    get {return _storage._durationTimeout}
    set {_uniqueStorage()._durationTimeout = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Unauthorized {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var reason: Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized.Reason = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Reasons why the request was unauthorized
    public enum Reason: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unspecified // = 0

      /// The request was denied by the external authorization service.
      case externalService // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .externalService
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .externalService: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized.Reason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized.Reason] = [
    .unspecified,
    .externalService,
  ]
}

#endif  // swift(>=4.2)

/// Properties of a negotiated TLS connection.
/// [#next-free-field: 7]
public struct Envoy_Data_Accesslog_V3_TLSProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of TLS that was negotiated.
  public var tlsVersion: Envoy_Data_Accesslog_V3_TLSProperties.TLSVersion = .versionUnspecified

  /// TLS cipher suite negotiated during handshake. The value is a
  /// four-digit hex code defined by the IANA TLS Cipher Suite Registry
  /// (e.g. ``009C`` for ``TLS_RSA_WITH_AES_128_GCM_SHA256``).
  ///
  /// Here it is expressed as an integer.
  public var tlsCipherSuite: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _tlsCipherSuite ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_tlsCipherSuite = newValue}
  }
  /// Returns true if `tlsCipherSuite` has been explicitly set.
  public var hasTlsCipherSuite: Bool {return self._tlsCipherSuite != nil}
  /// Clears the value of `tlsCipherSuite`. Subsequent reads from it will return its default value.
  public mutating func clearTlsCipherSuite() {self._tlsCipherSuite = nil}

  /// SNI hostname from handshake.
  public var tlsSniHostname: String = String()

  /// Properties of the local certificate used to negotiate TLS.
  public var localCertificateProperties: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties {
    get {return _localCertificateProperties ?? Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties()}
    set {_localCertificateProperties = newValue}
  }
  /// Returns true if `localCertificateProperties` has been explicitly set.
  public var hasLocalCertificateProperties: Bool {return self._localCertificateProperties != nil}
  /// Clears the value of `localCertificateProperties`. Subsequent reads from it will return its default value.
  public mutating func clearLocalCertificateProperties() {self._localCertificateProperties = nil}

  /// Properties of the peer certificate used to negotiate TLS.
  public var peerCertificateProperties: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties {
    get {return _peerCertificateProperties ?? Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties()}
    set {_peerCertificateProperties = newValue}
  }
  /// Returns true if `peerCertificateProperties` has been explicitly set.
  public var hasPeerCertificateProperties: Bool {return self._peerCertificateProperties != nil}
  /// Clears the value of `peerCertificateProperties`. Subsequent reads from it will return its default value.
  public mutating func clearPeerCertificateProperties() {self._peerCertificateProperties = nil}

  /// The TLS session ID.
  public var tlsSessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TLSVersion: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case versionUnspecified // = 0
    case tlsv1 // = 1
    case tlsv11 // = 2
    case tlsv12 // = 3
    case tlsv13 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .versionUnspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .versionUnspecified
      case 1: self = .tlsv1
      case 2: self = .tlsv11
      case 3: self = .tlsv12
      case 4: self = .tlsv13
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .versionUnspecified: return 0
      case .tlsv1: return 1
      case .tlsv11: return 2
      case .tlsv12: return 3
      case .tlsv13: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct CertificateProperties {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// SANs present in the certificate.
    public var subjectAltName: [Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName] = []

    /// The subject field of the certificate.
    public var subject: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct SubjectAltName {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var san: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName.OneOf_San? = nil

      public var uri: String {
        get {
          if case .uri(let v)? = san {return v}
          return String()
        }
        set {san = .uri(newValue)}
      }

      /// [#not-implemented-hide:]
      public var dns: String {
        get {
          if case .dns(let v)? = san {return v}
          return String()
        }
        set {san = .dns(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_San: Equatable {
        case uri(String)
        /// [#not-implemented-hide:]
        case dns(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName.OneOf_San, rhs: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName.OneOf_San) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.uri, .uri): return {
            guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.dns, .dns): return {
            guard case .dns(let l) = lhs, case .dns(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _tlsCipherSuite: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
  fileprivate var _localCertificateProperties: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties? = nil
  fileprivate var _peerCertificateProperties: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties? = nil
}

#if swift(>=4.2)

extension Envoy_Data_Accesslog_V3_TLSProperties.TLSVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Envoy_Data_Accesslog_V3_TLSProperties.TLSVersion] = [
    .versionUnspecified,
    .tlsv1,
    .tlsv11,
    .tlsv12,
    .tlsv13,
  ]
}

#endif  // swift(>=4.2)

/// [#next-free-field: 14]
public struct Envoy_Data_Accesslog_V3_HTTPRequestProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request method (RFC 7231/2616).
  public var requestMethod: Envoy_Config_Core_V3_RequestMethod = .methodUnspecified

  /// The scheme portion of the incoming request URI.
  public var scheme: String = String()

  /// HTTP/2 ``:authority`` or HTTP/1.1 ``Host`` header value.
  public var authority: String = String()

  /// The port of the incoming request URI
  /// (unused currently, as port is composed onto authority).
  public var port: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _port ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_port = newValue}
  }
  /// Returns true if `port` has been explicitly set.
  public var hasPort: Bool {return self._port != nil}
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  public mutating func clearPort() {self._port = nil}

  /// The path portion from the incoming request URI.
  public var path: String = String()

  /// Value of the ``User-Agent`` request header.
  public var userAgent: String = String()

  /// Value of the ``Referer`` request header.
  public var referer: String = String()

  /// Value of the ``X-Forwarded-For`` request header.
  public var forwardedFor: String = String()

  /// Value of the ``X-Request-Id`` request header
  ///
  /// This header is used by Envoy to uniquely identify a request.
  /// It will be generated for all external requests and internal requests that
  /// do not already have a request ID.
  public var requestID: String = String()

  /// Value of the ``X-Envoy-Original-Path`` request header.
  public var originalPath: String = String()

  /// Size of the HTTP request headers in bytes.
  ///
  /// This value is captured from the OSI layer 7 perspective, i.e. it does not
  /// include overhead from framing or encoding at other networking layers.
  public var requestHeadersBytes: UInt64 = 0

  /// Size of the HTTP request body in bytes.
  ///
  /// This value is captured from the OSI layer 7 perspective, i.e. it does not
  /// include overhead from framing or encoding at other networking layers.
  public var requestBodyBytes: UInt64 = 0

  /// Map of additional headers that have been configured to be logged.
  public var requestHeaders: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _port: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// [#next-free-field: 7]
public struct Envoy_Data_Accesslog_V3_HTTPResponseProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP response code returned by Envoy.
  public var responseCode: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _responseCode ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_responseCode = newValue}
  }
  /// Returns true if `responseCode` has been explicitly set.
  public var hasResponseCode: Bool {return self._responseCode != nil}
  /// Clears the value of `responseCode`. Subsequent reads from it will return its default value.
  public mutating func clearResponseCode() {self._responseCode = nil}

  /// Size of the HTTP response headers in bytes.
  ///
  /// This value is captured from the OSI layer 7 perspective, i.e. it does not
  /// include overhead from framing or encoding at other networking layers.
  public var responseHeadersBytes: UInt64 = 0

  /// Size of the HTTP response body in bytes.
  ///
  /// This value is captured from the OSI layer 7 perspective, i.e. it does not
  /// include overhead from framing or encoding at other networking layers.
  public var responseBodyBytes: UInt64 = 0

  /// Map of additional headers configured to be logged.
  public var responseHeaders: Dictionary<String,String> = [:]

  /// Map of trailers configured to be logged.
  public var responseTrailers: Dictionary<String,String> = [:]

  /// The HTTP response code details.
  public var responseCodeDetails: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _responseCode: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.data.accesslog.v3"

extension Envoy_Data_Accesslog_V3_TCPAccessLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TCPAccessLogEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_properties"),
    2: .standard(proto: "connection_properties"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commonProperties) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connectionProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commonProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._connectionProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_TCPAccessLogEntry, rhs: Envoy_Data_Accesslog_V3_TCPAccessLogEntry) -> Bool {
    if lhs._commonProperties != rhs._commonProperties {return false}
    if lhs._connectionProperties != rhs._connectionProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_HTTPAccessLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HTTPAccessLogEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "common_properties"),
    2: .standard(proto: "protocol_version"),
    3: .same(proto: "request"),
    4: .same(proto: "response"),
  ]

  fileprivate class _StorageClass {
    var _commonProperties: Envoy_Data_Accesslog_V3_AccessLogCommon? = nil
    var _protocolVersion: Envoy_Data_Accesslog_V3_HTTPAccessLogEntry.HTTPVersion = .protocolUnspecified
    var _request: Envoy_Data_Accesslog_V3_HTTPRequestProperties? = nil
    var _response: Envoy_Data_Accesslog_V3_HTTPResponseProperties? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commonProperties = source._commonProperties
      _protocolVersion = source._protocolVersion
      _request = source._request
      _response = source._response
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._commonProperties) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._protocolVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._response) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._commonProperties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._protocolVersion != .protocolUnspecified {
        try visitor.visitSingularEnumField(value: _storage._protocolVersion, fieldNumber: 2)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_HTTPAccessLogEntry, rhs: Envoy_Data_Accesslog_V3_HTTPAccessLogEntry) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commonProperties != rhs_storage._commonProperties {return false}
        if _storage._protocolVersion != rhs_storage._protocolVersion {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_HTTPAccessLogEntry.HTTPVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROTOCOL_UNSPECIFIED"),
    1: .same(proto: "HTTP10"),
    2: .same(proto: "HTTP11"),
    3: .same(proto: "HTTP2"),
    4: .same(proto: "HTTP3"),
  ]
}

extension Envoy_Data_Accesslog_V3_ConnectionProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "received_bytes"),
    2: .standard(proto: "sent_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.receivedBytes) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.sentBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.receivedBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.receivedBytes, fieldNumber: 1)
    }
    if self.sentBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.sentBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_ConnectionProperties, rhs: Envoy_Data_Accesslog_V3_ConnectionProperties) -> Bool {
    if lhs.receivedBytes != rhs.receivedBytes {return false}
    if lhs.sentBytes != rhs.sentBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_AccessLogCommon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessLogCommon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sample_rate"),
    2: .standard(proto: "downstream_remote_address"),
    3: .standard(proto: "downstream_local_address"),
    4: .standard(proto: "tls_properties"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "time_to_last_rx_byte"),
    7: .standard(proto: "time_to_first_upstream_tx_byte"),
    8: .standard(proto: "time_to_last_upstream_tx_byte"),
    9: .standard(proto: "time_to_first_upstream_rx_byte"),
    10: .standard(proto: "time_to_last_upstream_rx_byte"),
    11: .standard(proto: "time_to_first_downstream_tx_byte"),
    12: .standard(proto: "time_to_last_downstream_tx_byte"),
    13: .standard(proto: "upstream_remote_address"),
    14: .standard(proto: "upstream_local_address"),
    15: .standard(proto: "upstream_cluster"),
    16: .standard(proto: "response_flags"),
    17: .same(proto: "metadata"),
    18: .standard(proto: "upstream_transport_failure_reason"),
    19: .standard(proto: "route_name"),
    20: .standard(proto: "downstream_direct_remote_address"),
    21: .standard(proto: "filter_state_objects"),
  ]

  fileprivate class _StorageClass {
    var _sampleRate: Double = 0
    var _downstreamRemoteAddress: Envoy_Config_Core_V3_Address? = nil
    var _downstreamLocalAddress: Envoy_Config_Core_V3_Address? = nil
    var _tlsProperties: Envoy_Data_Accesslog_V3_TLSProperties? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _timeToLastRxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeToFirstUpstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeToLastUpstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeToFirstUpstreamRxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeToLastUpstreamRxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeToFirstDownstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeToLastDownstreamTxByte: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _upstreamRemoteAddress: Envoy_Config_Core_V3_Address? = nil
    var _upstreamLocalAddress: Envoy_Config_Core_V3_Address? = nil
    var _upstreamCluster: String = String()
    var _responseFlags: Envoy_Data_Accesslog_V3_ResponseFlags? = nil
    var _metadata: Envoy_Config_Core_V3_Metadata? = nil
    var _upstreamTransportFailureReason: String = String()
    var _routeName: String = String()
    var _downstreamDirectRemoteAddress: Envoy_Config_Core_V3_Address? = nil
    var _filterStateObjects: Dictionary<String,SwiftProtobuf.Google_Protobuf_Any> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _sampleRate = source._sampleRate
      _downstreamRemoteAddress = source._downstreamRemoteAddress
      _downstreamLocalAddress = source._downstreamLocalAddress
      _tlsProperties = source._tlsProperties
      _startTime = source._startTime
      _timeToLastRxByte = source._timeToLastRxByte
      _timeToFirstUpstreamTxByte = source._timeToFirstUpstreamTxByte
      _timeToLastUpstreamTxByte = source._timeToLastUpstreamTxByte
      _timeToFirstUpstreamRxByte = source._timeToFirstUpstreamRxByte
      _timeToLastUpstreamRxByte = source._timeToLastUpstreamRxByte
      _timeToFirstDownstreamTxByte = source._timeToFirstDownstreamTxByte
      _timeToLastDownstreamTxByte = source._timeToLastDownstreamTxByte
      _upstreamRemoteAddress = source._upstreamRemoteAddress
      _upstreamLocalAddress = source._upstreamLocalAddress
      _upstreamCluster = source._upstreamCluster
      _responseFlags = source._responseFlags
      _metadata = source._metadata
      _upstreamTransportFailureReason = source._upstreamTransportFailureReason
      _routeName = source._routeName
      _downstreamDirectRemoteAddress = source._downstreamDirectRemoteAddress
      _filterStateObjects = source._filterStateObjects
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularDoubleField(value: &_storage._sampleRate) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._downstreamRemoteAddress) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._downstreamLocalAddress) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._tlsProperties) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._timeToLastRxByte) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._timeToFirstUpstreamTxByte) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._timeToLastUpstreamTxByte) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._timeToFirstUpstreamRxByte) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._timeToLastUpstreamRxByte) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._timeToFirstDownstreamTxByte) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._timeToLastDownstreamTxByte) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._upstreamRemoteAddress) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._upstreamLocalAddress) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._upstreamCluster) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._responseFlags) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._upstreamTransportFailureReason) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._routeName) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._downstreamDirectRemoteAddress) }()
        case 21: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: &_storage._filterStateObjects) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._sampleRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._sampleRate, fieldNumber: 1)
      }
      if let v = _storage._downstreamRemoteAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._downstreamLocalAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._tlsProperties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._timeToLastRxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._timeToFirstUpstreamTxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._timeToLastUpstreamTxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._timeToFirstUpstreamRxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._timeToLastUpstreamRxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._timeToFirstDownstreamTxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._timeToLastDownstreamTxByte {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._upstreamRemoteAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._upstreamLocalAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if !_storage._upstreamCluster.isEmpty {
        try visitor.visitSingularStringField(value: _storage._upstreamCluster, fieldNumber: 15)
      }
      if let v = _storage._responseFlags {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._upstreamTransportFailureReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._upstreamTransportFailureReason, fieldNumber: 18)
      }
      if !_storage._routeName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._routeName, fieldNumber: 19)
      }
      if let v = _storage._downstreamDirectRemoteAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._filterStateObjects.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Any>.self, value: _storage._filterStateObjects, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_AccessLogCommon, rhs: Envoy_Data_Accesslog_V3_AccessLogCommon) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sampleRate != rhs_storage._sampleRate {return false}
        if _storage._downstreamRemoteAddress != rhs_storage._downstreamRemoteAddress {return false}
        if _storage._downstreamLocalAddress != rhs_storage._downstreamLocalAddress {return false}
        if _storage._tlsProperties != rhs_storage._tlsProperties {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._timeToLastRxByte != rhs_storage._timeToLastRxByte {return false}
        if _storage._timeToFirstUpstreamTxByte != rhs_storage._timeToFirstUpstreamTxByte {return false}
        if _storage._timeToLastUpstreamTxByte != rhs_storage._timeToLastUpstreamTxByte {return false}
        if _storage._timeToFirstUpstreamRxByte != rhs_storage._timeToFirstUpstreamRxByte {return false}
        if _storage._timeToLastUpstreamRxByte != rhs_storage._timeToLastUpstreamRxByte {return false}
        if _storage._timeToFirstDownstreamTxByte != rhs_storage._timeToFirstDownstreamTxByte {return false}
        if _storage._timeToLastDownstreamTxByte != rhs_storage._timeToLastDownstreamTxByte {return false}
        if _storage._upstreamRemoteAddress != rhs_storage._upstreamRemoteAddress {return false}
        if _storage._upstreamLocalAddress != rhs_storage._upstreamLocalAddress {return false}
        if _storage._upstreamCluster != rhs_storage._upstreamCluster {return false}
        if _storage._responseFlags != rhs_storage._responseFlags {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._upstreamTransportFailureReason != rhs_storage._upstreamTransportFailureReason {return false}
        if _storage._routeName != rhs_storage._routeName {return false}
        if _storage._downstreamDirectRemoteAddress != rhs_storage._downstreamDirectRemoteAddress {return false}
        if _storage._filterStateObjects != rhs_storage._filterStateObjects {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_ResponseFlags: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseFlags"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "failed_local_healthcheck"),
    2: .standard(proto: "no_healthy_upstream"),
    3: .standard(proto: "upstream_request_timeout"),
    4: .standard(proto: "local_reset"),
    5: .standard(proto: "upstream_remote_reset"),
    6: .standard(proto: "upstream_connection_failure"),
    7: .standard(proto: "upstream_connection_termination"),
    8: .standard(proto: "upstream_overflow"),
    9: .standard(proto: "no_route_found"),
    10: .standard(proto: "delay_injected"),
    11: .standard(proto: "fault_injected"),
    12: .standard(proto: "rate_limited"),
    13: .standard(proto: "unauthorized_details"),
    14: .standard(proto: "rate_limit_service_error"),
    15: .standard(proto: "downstream_connection_termination"),
    16: .standard(proto: "upstream_retry_limit_exceeded"),
    17: .standard(proto: "stream_idle_timeout"),
    18: .standard(proto: "invalid_envoy_request_headers"),
    19: .standard(proto: "downstream_protocol_error"),
    20: .standard(proto: "upstream_max_stream_duration_reached"),
    21: .standard(proto: "response_from_cache_filter"),
    22: .standard(proto: "no_filter_config_found"),
    23: .standard(proto: "duration_timeout"),
  ]

  fileprivate class _StorageClass {
    var _failedLocalHealthcheck: Bool = false
    var _noHealthyUpstream: Bool = false
    var _upstreamRequestTimeout: Bool = false
    var _localReset: Bool = false
    var _upstreamRemoteReset: Bool = false
    var _upstreamConnectionFailure: Bool = false
    var _upstreamConnectionTermination: Bool = false
    var _upstreamOverflow: Bool = false
    var _noRouteFound: Bool = false
    var _delayInjected: Bool = false
    var _faultInjected: Bool = false
    var _rateLimited: Bool = false
    var _unauthorizedDetails: Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized? = nil
    var _rateLimitServiceError: Bool = false
    var _downstreamConnectionTermination: Bool = false
    var _upstreamRetryLimitExceeded: Bool = false
    var _streamIdleTimeout: Bool = false
    var _invalidEnvoyRequestHeaders: Bool = false
    var _downstreamProtocolError: Bool = false
    var _upstreamMaxStreamDurationReached: Bool = false
    var _responseFromCacheFilter: Bool = false
    var _noFilterConfigFound: Bool = false
    var _durationTimeout: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _failedLocalHealthcheck = source._failedLocalHealthcheck
      _noHealthyUpstream = source._noHealthyUpstream
      _upstreamRequestTimeout = source._upstreamRequestTimeout
      _localReset = source._localReset
      _upstreamRemoteReset = source._upstreamRemoteReset
      _upstreamConnectionFailure = source._upstreamConnectionFailure
      _upstreamConnectionTermination = source._upstreamConnectionTermination
      _upstreamOverflow = source._upstreamOverflow
      _noRouteFound = source._noRouteFound
      _delayInjected = source._delayInjected
      _faultInjected = source._faultInjected
      _rateLimited = source._rateLimited
      _unauthorizedDetails = source._unauthorizedDetails
      _rateLimitServiceError = source._rateLimitServiceError
      _downstreamConnectionTermination = source._downstreamConnectionTermination
      _upstreamRetryLimitExceeded = source._upstreamRetryLimitExceeded
      _streamIdleTimeout = source._streamIdleTimeout
      _invalidEnvoyRequestHeaders = source._invalidEnvoyRequestHeaders
      _downstreamProtocolError = source._downstreamProtocolError
      _upstreamMaxStreamDurationReached = source._upstreamMaxStreamDurationReached
      _responseFromCacheFilter = source._responseFromCacheFilter
      _noFilterConfigFound = source._noFilterConfigFound
      _durationTimeout = source._durationTimeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._failedLocalHealthcheck) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._noHealthyUpstream) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamRequestTimeout) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._localReset) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamRemoteReset) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamConnectionFailure) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamConnectionTermination) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamOverflow) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._noRouteFound) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._delayInjected) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._faultInjected) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._rateLimited) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._unauthorizedDetails) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._rateLimitServiceError) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._downstreamConnectionTermination) }()
        case 16: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamRetryLimitExceeded) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._streamIdleTimeout) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._invalidEnvoyRequestHeaders) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._downstreamProtocolError) }()
        case 20: try { try decoder.decodeSingularBoolField(value: &_storage._upstreamMaxStreamDurationReached) }()
        case 21: try { try decoder.decodeSingularBoolField(value: &_storage._responseFromCacheFilter) }()
        case 22: try { try decoder.decodeSingularBoolField(value: &_storage._noFilterConfigFound) }()
        case 23: try { try decoder.decodeSingularBoolField(value: &_storage._durationTimeout) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._failedLocalHealthcheck != false {
        try visitor.visitSingularBoolField(value: _storage._failedLocalHealthcheck, fieldNumber: 1)
      }
      if _storage._noHealthyUpstream != false {
        try visitor.visitSingularBoolField(value: _storage._noHealthyUpstream, fieldNumber: 2)
      }
      if _storage._upstreamRequestTimeout != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamRequestTimeout, fieldNumber: 3)
      }
      if _storage._localReset != false {
        try visitor.visitSingularBoolField(value: _storage._localReset, fieldNumber: 4)
      }
      if _storage._upstreamRemoteReset != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamRemoteReset, fieldNumber: 5)
      }
      if _storage._upstreamConnectionFailure != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamConnectionFailure, fieldNumber: 6)
      }
      if _storage._upstreamConnectionTermination != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamConnectionTermination, fieldNumber: 7)
      }
      if _storage._upstreamOverflow != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamOverflow, fieldNumber: 8)
      }
      if _storage._noRouteFound != false {
        try visitor.visitSingularBoolField(value: _storage._noRouteFound, fieldNumber: 9)
      }
      if _storage._delayInjected != false {
        try visitor.visitSingularBoolField(value: _storage._delayInjected, fieldNumber: 10)
      }
      if _storage._faultInjected != false {
        try visitor.visitSingularBoolField(value: _storage._faultInjected, fieldNumber: 11)
      }
      if _storage._rateLimited != false {
        try visitor.visitSingularBoolField(value: _storage._rateLimited, fieldNumber: 12)
      }
      if let v = _storage._unauthorizedDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if _storage._rateLimitServiceError != false {
        try visitor.visitSingularBoolField(value: _storage._rateLimitServiceError, fieldNumber: 14)
      }
      if _storage._downstreamConnectionTermination != false {
        try visitor.visitSingularBoolField(value: _storage._downstreamConnectionTermination, fieldNumber: 15)
      }
      if _storage._upstreamRetryLimitExceeded != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamRetryLimitExceeded, fieldNumber: 16)
      }
      if _storage._streamIdleTimeout != false {
        try visitor.visitSingularBoolField(value: _storage._streamIdleTimeout, fieldNumber: 17)
      }
      if _storage._invalidEnvoyRequestHeaders != false {
        try visitor.visitSingularBoolField(value: _storage._invalidEnvoyRequestHeaders, fieldNumber: 18)
      }
      if _storage._downstreamProtocolError != false {
        try visitor.visitSingularBoolField(value: _storage._downstreamProtocolError, fieldNumber: 19)
      }
      if _storage._upstreamMaxStreamDurationReached != false {
        try visitor.visitSingularBoolField(value: _storage._upstreamMaxStreamDurationReached, fieldNumber: 20)
      }
      if _storage._responseFromCacheFilter != false {
        try visitor.visitSingularBoolField(value: _storage._responseFromCacheFilter, fieldNumber: 21)
      }
      if _storage._noFilterConfigFound != false {
        try visitor.visitSingularBoolField(value: _storage._noFilterConfigFound, fieldNumber: 22)
      }
      if _storage._durationTimeout != false {
        try visitor.visitSingularBoolField(value: _storage._durationTimeout, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_ResponseFlags, rhs: Envoy_Data_Accesslog_V3_ResponseFlags) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._failedLocalHealthcheck != rhs_storage._failedLocalHealthcheck {return false}
        if _storage._noHealthyUpstream != rhs_storage._noHealthyUpstream {return false}
        if _storage._upstreamRequestTimeout != rhs_storage._upstreamRequestTimeout {return false}
        if _storage._localReset != rhs_storage._localReset {return false}
        if _storage._upstreamRemoteReset != rhs_storage._upstreamRemoteReset {return false}
        if _storage._upstreamConnectionFailure != rhs_storage._upstreamConnectionFailure {return false}
        if _storage._upstreamConnectionTermination != rhs_storage._upstreamConnectionTermination {return false}
        if _storage._upstreamOverflow != rhs_storage._upstreamOverflow {return false}
        if _storage._noRouteFound != rhs_storage._noRouteFound {return false}
        if _storage._delayInjected != rhs_storage._delayInjected {return false}
        if _storage._faultInjected != rhs_storage._faultInjected {return false}
        if _storage._rateLimited != rhs_storage._rateLimited {return false}
        if _storage._unauthorizedDetails != rhs_storage._unauthorizedDetails {return false}
        if _storage._rateLimitServiceError != rhs_storage._rateLimitServiceError {return false}
        if _storage._downstreamConnectionTermination != rhs_storage._downstreamConnectionTermination {return false}
        if _storage._upstreamRetryLimitExceeded != rhs_storage._upstreamRetryLimitExceeded {return false}
        if _storage._streamIdleTimeout != rhs_storage._streamIdleTimeout {return false}
        if _storage._invalidEnvoyRequestHeaders != rhs_storage._invalidEnvoyRequestHeaders {return false}
        if _storage._downstreamProtocolError != rhs_storage._downstreamProtocolError {return false}
        if _storage._upstreamMaxStreamDurationReached != rhs_storage._upstreamMaxStreamDurationReached {return false}
        if _storage._responseFromCacheFilter != rhs_storage._responseFromCacheFilter {return false}
        if _storage._noFilterConfigFound != rhs_storage._noFilterConfigFound {return false}
        if _storage._durationTimeout != rhs_storage._durationTimeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Data_Accesslog_V3_ResponseFlags.protoMessageName + ".Unauthorized"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .unspecified {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized, rhs: Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_ResponseFlags.Unauthorized.Reason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REASON_UNSPECIFIED"),
    1: .same(proto: "EXTERNAL_SERVICE"),
  ]
}

extension Envoy_Data_Accesslog_V3_TLSProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TLSProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tls_version"),
    2: .standard(proto: "tls_cipher_suite"),
    3: .standard(proto: "tls_sni_hostname"),
    4: .standard(proto: "local_certificate_properties"),
    5: .standard(proto: "peer_certificate_properties"),
    6: .standard(proto: "tls_session_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.tlsVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tlsCipherSuite) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tlsSniHostname) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._localCertificateProperties) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._peerCertificateProperties) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.tlsSessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tlsVersion != .versionUnspecified {
      try visitor.visitSingularEnumField(value: self.tlsVersion, fieldNumber: 1)
    }
    if let v = self._tlsCipherSuite {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.tlsSniHostname.isEmpty {
      try visitor.visitSingularStringField(value: self.tlsSniHostname, fieldNumber: 3)
    }
    if let v = self._localCertificateProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._peerCertificateProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.tlsSessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.tlsSessionID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_TLSProperties, rhs: Envoy_Data_Accesslog_V3_TLSProperties) -> Bool {
    if lhs.tlsVersion != rhs.tlsVersion {return false}
    if lhs._tlsCipherSuite != rhs._tlsCipherSuite {return false}
    if lhs.tlsSniHostname != rhs.tlsSniHostname {return false}
    if lhs._localCertificateProperties != rhs._localCertificateProperties {return false}
    if lhs._peerCertificateProperties != rhs._peerCertificateProperties {return false}
    if lhs.tlsSessionID != rhs.tlsSessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_TLSProperties.TLSVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERSION_UNSPECIFIED"),
    1: .same(proto: "TLSv1"),
    2: .same(proto: "TLSv1_1"),
    3: .same(proto: "TLSv1_2"),
    4: .same(proto: "TLSv1_3"),
  ]
}

extension Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Data_Accesslog_V3_TLSProperties.protoMessageName + ".CertificateProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subject_alt_name"),
    2: .same(proto: "subject"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subjectAltName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subjectAltName.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subjectAltName, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties, rhs: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties) -> Bool {
    if lhs.subjectAltName != rhs.subjectAltName {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.protoMessageName + ".SubjectAltName"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "dns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.san != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.san = .uri(v)}
      }()
      case 2: try {
        if self.san != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.san = .dns(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.san {
    case .uri?: try {
      guard case .uri(let v)? = self.san else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .dns?: try {
      guard case .dns(let v)? = self.san else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName, rhs: Envoy_Data_Accesslog_V3_TLSProperties.CertificateProperties.SubjectAltName) -> Bool {
    if lhs.san != rhs.san {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_HTTPRequestProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HTTPRequestProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_method"),
    2: .same(proto: "scheme"),
    3: .same(proto: "authority"),
    4: .same(proto: "port"),
    5: .same(proto: "path"),
    6: .standard(proto: "user_agent"),
    7: .same(proto: "referer"),
    8: .standard(proto: "forwarded_for"),
    9: .standard(proto: "request_id"),
    10: .standard(proto: "original_path"),
    11: .standard(proto: "request_headers_bytes"),
    12: .standard(proto: "request_body_bytes"),
    13: .standard(proto: "request_headers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.requestMethod) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheme) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authority) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._port) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.referer) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.forwardedFor) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.originalPath) }()
      case 11: try { try decoder.decodeSingularUInt64Field(value: &self.requestHeadersBytes) }()
      case 12: try { try decoder.decodeSingularUInt64Field(value: &self.requestBodyBytes) }()
      case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.requestHeaders) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestMethod != .methodUnspecified {
      try visitor.visitSingularEnumField(value: self.requestMethod, fieldNumber: 1)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 2)
    }
    if !self.authority.isEmpty {
      try visitor.visitSingularStringField(value: self.authority, fieldNumber: 3)
    }
    if let v = self._port {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 5)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 6)
    }
    if !self.referer.isEmpty {
      try visitor.visitSingularStringField(value: self.referer, fieldNumber: 7)
    }
    if !self.forwardedFor.isEmpty {
      try visitor.visitSingularStringField(value: self.forwardedFor, fieldNumber: 8)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 9)
    }
    if !self.originalPath.isEmpty {
      try visitor.visitSingularStringField(value: self.originalPath, fieldNumber: 10)
    }
    if self.requestHeadersBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestHeadersBytes, fieldNumber: 11)
    }
    if self.requestBodyBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestBodyBytes, fieldNumber: 12)
    }
    if !self.requestHeaders.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.requestHeaders, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_HTTPRequestProperties, rhs: Envoy_Data_Accesslog_V3_HTTPRequestProperties) -> Bool {
    if lhs.requestMethod != rhs.requestMethod {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.authority != rhs.authority {return false}
    if lhs._port != rhs._port {return false}
    if lhs.path != rhs.path {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.referer != rhs.referer {return false}
    if lhs.forwardedFor != rhs.forwardedFor {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.originalPath != rhs.originalPath {return false}
    if lhs.requestHeadersBytes != rhs.requestHeadersBytes {return false}
    if lhs.requestBodyBytes != rhs.requestBodyBytes {return false}
    if lhs.requestHeaders != rhs.requestHeaders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Data_Accesslog_V3_HTTPResponseProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HTTPResponseProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_code"),
    2: .standard(proto: "response_headers_bytes"),
    3: .standard(proto: "response_body_bytes"),
    4: .standard(proto: "response_headers"),
    5: .standard(proto: "response_trailers"),
    6: .standard(proto: "response_code_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._responseCode) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.responseHeadersBytes) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.responseBodyBytes) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.responseHeaders) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.responseTrailers) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.responseCodeDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._responseCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.responseHeadersBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.responseHeadersBytes, fieldNumber: 2)
    }
    if self.responseBodyBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.responseBodyBytes, fieldNumber: 3)
    }
    if !self.responseHeaders.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.responseHeaders, fieldNumber: 4)
    }
    if !self.responseTrailers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.responseTrailers, fieldNumber: 5)
    }
    if !self.responseCodeDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.responseCodeDetails, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Data_Accesslog_V3_HTTPResponseProperties, rhs: Envoy_Data_Accesslog_V3_HTTPResponseProperties) -> Bool {
    if lhs._responseCode != rhs._responseCode {return false}
    if lhs.responseHeadersBytes != rhs.responseHeadersBytes {return false}
    if lhs.responseBodyBytes != rhs.responseBodyBytes {return false}
    if lhs.responseHeaders != rhs.responseHeaders {return false}
    if lhs.responseTrailers != rhs.responseTrailers {return false}
    if lhs.responseCodeDetails != rhs.responseCodeDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

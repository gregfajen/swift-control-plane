// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: envoy/admin/v3/clusters.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Admin endpoint uses this wrapper for `/clusters` to display cluster status information.
/// See :ref:`/clusters <operations_admin_interface_clusters>` for more information.
public struct Envoy_Admin_V3_Clusters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mapping from cluster name to each cluster's status.
  public var clusterStatuses: [Envoy_Admin_V3_ClusterStatus] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Details an individual cluster's current status.
/// [#next-free-field: 6]
public struct Envoy_Admin_V3_ClusterStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the cluster.
  public var name: String = String()

  /// Denotes whether this cluster was added via API or configured statically.
  public var addedViaApi: Bool = false

  /// The success rate threshold used in the last interval.
  /// If
  /// :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  /// is *false*, all errors: externally and locally generated were used to calculate the threshold.
  /// If
  /// :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  /// is *true*, only externally generated errors were used to calculate the threshold.
  /// The threshold is used to eject hosts based on their success rate. See
  /// :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for details.
  ///
  /// Note: this field may be omitted in any of the three following cases:
  ///
  /// 1. There were not enough hosts with enough request volume to proceed with success rate based
  ///    outlier ejection.
  /// 2. The threshold is computed to be < 0 because a negative value implies that there was no
  ///    threshold for that interval.
  /// 3. Outlier detection is not enabled for this cluster.
  public var successRateEjectionThreshold: Envoy_Type_V3_Percent {
    get {return _successRateEjectionThreshold ?? Envoy_Type_V3_Percent()}
    set {_successRateEjectionThreshold = newValue}
  }
  /// Returns true if `successRateEjectionThreshold` has been explicitly set.
  public var hasSuccessRateEjectionThreshold: Bool {return self._successRateEjectionThreshold != nil}
  /// Clears the value of `successRateEjectionThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearSuccessRateEjectionThreshold() {self._successRateEjectionThreshold = nil}

  /// Mapping from host address to the host's current status.
  public var hostStatuses: [Envoy_Admin_V3_HostStatus] = []

  /// The success rate threshold used in the last interval when only locally originated failures were
  /// taken into account and externally originated errors were treated as success.
  /// This field should be interpreted only when
  /// :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  /// is *true*. The threshold is used to eject hosts based on their success rate.
  /// See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  /// details.
  ///
  /// Note: this field may be omitted in any of the three following cases:
  ///
  /// 1. There were not enough hosts with enough request volume to proceed with success rate based
  ///    outlier ejection.
  /// 2. The threshold is computed to be < 0 because a negative value implies that there was no
  ///    threshold for that interval.
  /// 3. Outlier detection is not enabled for this cluster.
  public var localOriginSuccessRateEjectionThreshold: Envoy_Type_V3_Percent {
    get {return _localOriginSuccessRateEjectionThreshold ?? Envoy_Type_V3_Percent()}
    set {_localOriginSuccessRateEjectionThreshold = newValue}
  }
  /// Returns true if `localOriginSuccessRateEjectionThreshold` has been explicitly set.
  public var hasLocalOriginSuccessRateEjectionThreshold: Bool {return self._localOriginSuccessRateEjectionThreshold != nil}
  /// Clears the value of `localOriginSuccessRateEjectionThreshold`. Subsequent reads from it will return its default value.
  public mutating func clearLocalOriginSuccessRateEjectionThreshold() {self._localOriginSuccessRateEjectionThreshold = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _successRateEjectionThreshold: Envoy_Type_V3_Percent? = nil
  fileprivate var _localOriginSuccessRateEjectionThreshold: Envoy_Type_V3_Percent? = nil
}

/// Current state of a particular host.
/// [#next-free-field: 10]
public struct Envoy_Admin_V3_HostStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address of this host.
  public var address: Envoy_Config_Core_V3_Address {
    get {return _address ?? Envoy_Config_Core_V3_Address()}
    set {_address = newValue}
  }
  /// Returns true if `address` has been explicitly set.
  public var hasAddress: Bool {return self._address != nil}
  /// Clears the value of `address`. Subsequent reads from it will return its default value.
  public mutating func clearAddress() {self._address = nil}

  /// List of stats specific to this host.
  public var stats: [Envoy_Admin_V3_SimpleMetric] = []

  /// The host's current health status.
  public var healthStatus: Envoy_Admin_V3_HostHealthStatus {
    get {return _healthStatus ?? Envoy_Admin_V3_HostHealthStatus()}
    set {_healthStatus = newValue}
  }
  /// Returns true if `healthStatus` has been explicitly set.
  public var hasHealthStatus: Bool {return self._healthStatus != nil}
  /// Clears the value of `healthStatus`. Subsequent reads from it will return its default value.
  public mutating func clearHealthStatus() {self._healthStatus = nil}

  /// Request success rate for this host over the last calculated interval.
  /// If
  /// :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  /// is *false*, all errors: externally and locally generated were used in success rate
  /// calculation. If
  /// :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  /// is *true*, only externally generated errors were used in success rate calculation.
  /// See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  /// details.
  ///
  /// Note: the message will not be present if host did not have enough request volume to calculate
  /// success rate or the cluster did not have enough hosts to run through success rate outlier
  /// ejection.
  public var successRate: Envoy_Type_V3_Percent {
    get {return _successRate ?? Envoy_Type_V3_Percent()}
    set {_successRate = newValue}
  }
  /// Returns true if `successRate` has been explicitly set.
  public var hasSuccessRate: Bool {return self._successRate != nil}
  /// Clears the value of `successRate`. Subsequent reads from it will return its default value.
  public mutating func clearSuccessRate() {self._successRate = nil}

  /// The host's weight. If not configured, the value defaults to 1.
  public var weight: UInt32 = 0

  /// The hostname of the host, if applicable.
  public var hostname: String = String()

  /// The host's priority. If not configured, the value defaults to 0 (highest priority).
  public var priority: UInt32 = 0

  /// Request success rate for this host over the last calculated
  /// interval when only locally originated errors are taken into account and externally originated
  /// errors were treated as success.
  /// This field should be interpreted only when
  /// :ref:`outlier_detection.split_external_local_origin_errors<envoy_api_field_config.cluster.v3.OutlierDetection.split_external_local_origin_errors>`
  /// is *true*.
  /// See :ref:`Cluster outlier detection <arch_overview_outlier_detection>` documentation for
  /// details.
  ///
  /// Note: the message will not be present if host did not have enough request volume to calculate
  /// success rate or the cluster did not have enough hosts to run through success rate outlier
  /// ejection.
  public var localOriginSuccessRate: Envoy_Type_V3_Percent {
    get {return _localOriginSuccessRate ?? Envoy_Type_V3_Percent()}
    set {_localOriginSuccessRate = newValue}
  }
  /// Returns true if `localOriginSuccessRate` has been explicitly set.
  public var hasLocalOriginSuccessRate: Bool {return self._localOriginSuccessRate != nil}
  /// Clears the value of `localOriginSuccessRate`. Subsequent reads from it will return its default value.
  public mutating func clearLocalOriginSuccessRate() {self._localOriginSuccessRate = nil}

  /// locality of the host.
  public var locality: Envoy_Config_Core_V3_Locality {
    get {return _locality ?? Envoy_Config_Core_V3_Locality()}
    set {_locality = newValue}
  }
  /// Returns true if `locality` has been explicitly set.
  public var hasLocality: Bool {return self._locality != nil}
  /// Clears the value of `locality`. Subsequent reads from it will return its default value.
  public mutating func clearLocality() {self._locality = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _address: Envoy_Config_Core_V3_Address? = nil
  fileprivate var _healthStatus: Envoy_Admin_V3_HostHealthStatus? = nil
  fileprivate var _successRate: Envoy_Type_V3_Percent? = nil
  fileprivate var _localOriginSuccessRate: Envoy_Type_V3_Percent? = nil
  fileprivate var _locality: Envoy_Config_Core_V3_Locality? = nil
}

/// Health status for a host.
/// [#next-free-field: 7]
public struct Envoy_Admin_V3_HostHealthStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The host is currently failing active health checks.
  public var failedActiveHealthCheck: Bool = false

  /// The host is currently considered an outlier and has been ejected.
  public var failedOutlierCheck: Bool = false

  /// The host is currently being marked as degraded through active health checking.
  public var failedActiveDegradedCheck: Bool = false

  /// The host has been removed from service discovery, but is being stabilized due to active
  /// health checking.
  public var pendingDynamicRemoval: Bool = false

  /// The host has not yet been health checked.
  public var pendingActiveHc: Bool = false

  /// Health status as reported by EDS. Note: only HEALTHY and UNHEALTHY are currently supported
  /// here.
  /// [#comment:TODO(mrice32): pipe through remaining EDS health status possibilities.]
  public var edsHealthStatus: Envoy_Config_Core_V3_HealthStatus = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "envoy.admin.v3"

extension Envoy_Admin_V3_Clusters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Clusters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_statuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.clusterStatuses)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusterStatuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Admin_V3_Clusters, rhs: Envoy_Admin_V3_Clusters) -> Bool {
    if lhs.clusterStatuses != rhs.clusterStatuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Admin_V3_ClusterStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "added_via_api"),
    3: .standard(proto: "success_rate_ejection_threshold"),
    4: .standard(proto: "host_statuses"),
    5: .standard(proto: "local_origin_success_rate_ejection_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularBoolField(value: &self.addedViaApi)
      case 3: try decoder.decodeSingularMessageField(value: &self._successRateEjectionThreshold)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.hostStatuses)
      case 5: try decoder.decodeSingularMessageField(value: &self._localOriginSuccessRateEjectionThreshold)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.addedViaApi != false {
      try visitor.visitSingularBoolField(value: self.addedViaApi, fieldNumber: 2)
    }
    if let v = self._successRateEjectionThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.hostStatuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hostStatuses, fieldNumber: 4)
    }
    if let v = self._localOriginSuccessRateEjectionThreshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Admin_V3_ClusterStatus, rhs: Envoy_Admin_V3_ClusterStatus) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.addedViaApi != rhs.addedViaApi {return false}
    if lhs._successRateEjectionThreshold != rhs._successRateEjectionThreshold {return false}
    if lhs.hostStatuses != rhs.hostStatuses {return false}
    if lhs._localOriginSuccessRateEjectionThreshold != rhs._localOriginSuccessRateEjectionThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Admin_V3_HostStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HostStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "stats"),
    3: .standard(proto: "health_status"),
    4: .standard(proto: "success_rate"),
    5: .same(proto: "weight"),
    6: .same(proto: "hostname"),
    7: .same(proto: "priority"),
    8: .standard(proto: "local_origin_success_rate"),
    9: .same(proto: "locality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.stats)
      case 3: try decoder.decodeSingularMessageField(value: &self._healthStatus)
      case 4: try decoder.decodeSingularMessageField(value: &self._successRate)
      case 5: try decoder.decodeSingularUInt32Field(value: &self.weight)
      case 6: try decoder.decodeSingularStringField(value: &self.hostname)
      case 7: try decoder.decodeSingularUInt32Field(value: &self.priority)
      case 8: try decoder.decodeSingularMessageField(value: &self._localOriginSuccessRate)
      case 9: try decoder.decodeSingularMessageField(value: &self._locality)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._address {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.stats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stats, fieldNumber: 2)
    }
    if let v = self._healthStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._successRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.weight != 0 {
      try visitor.visitSingularUInt32Field(value: self.weight, fieldNumber: 5)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 6)
    }
    if self.priority != 0 {
      try visitor.visitSingularUInt32Field(value: self.priority, fieldNumber: 7)
    }
    if let v = self._localOriginSuccessRate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._locality {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Admin_V3_HostStatus, rhs: Envoy_Admin_V3_HostStatus) -> Bool {
    if lhs._address != rhs._address {return false}
    if lhs.stats != rhs.stats {return false}
    if lhs._healthStatus != rhs._healthStatus {return false}
    if lhs._successRate != rhs._successRate {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.priority != rhs.priority {return false}
    if lhs._localOriginSuccessRate != rhs._localOriginSuccessRate {return false}
    if lhs._locality != rhs._locality {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Envoy_Admin_V3_HostHealthStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HostHealthStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "failed_active_health_check"),
    2: .standard(proto: "failed_outlier_check"),
    4: .standard(proto: "failed_active_degraded_check"),
    5: .standard(proto: "pending_dynamic_removal"),
    6: .standard(proto: "pending_active_hc"),
    3: .standard(proto: "eds_health_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.failedActiveHealthCheck)
      case 2: try decoder.decodeSingularBoolField(value: &self.failedOutlierCheck)
      case 3: try decoder.decodeSingularEnumField(value: &self.edsHealthStatus)
      case 4: try decoder.decodeSingularBoolField(value: &self.failedActiveDegradedCheck)
      case 5: try decoder.decodeSingularBoolField(value: &self.pendingDynamicRemoval)
      case 6: try decoder.decodeSingularBoolField(value: &self.pendingActiveHc)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.failedActiveHealthCheck != false {
      try visitor.visitSingularBoolField(value: self.failedActiveHealthCheck, fieldNumber: 1)
    }
    if self.failedOutlierCheck != false {
      try visitor.visitSingularBoolField(value: self.failedOutlierCheck, fieldNumber: 2)
    }
    if self.edsHealthStatus != .unknown {
      try visitor.visitSingularEnumField(value: self.edsHealthStatus, fieldNumber: 3)
    }
    if self.failedActiveDegradedCheck != false {
      try visitor.visitSingularBoolField(value: self.failedActiveDegradedCheck, fieldNumber: 4)
    }
    if self.pendingDynamicRemoval != false {
      try visitor.visitSingularBoolField(value: self.pendingDynamicRemoval, fieldNumber: 5)
    }
    if self.pendingActiveHc != false {
      try visitor.visitSingularBoolField(value: self.pendingActiveHc, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Envoy_Admin_V3_HostHealthStatus, rhs: Envoy_Admin_V3_HostHealthStatus) -> Bool {
    if lhs.failedActiveHealthCheck != rhs.failedActiveHealthCheck {return false}
    if lhs.failedOutlierCheck != rhs.failedOutlierCheck {return false}
    if lhs.failedActiveDegradedCheck != rhs.failedActiveDegradedCheck {return false}
    if lhs.pendingDynamicRemoval != rhs.pendingDynamicRemoval {return false}
    if lhs.pendingActiveHc != rhs.pendingActiveHc {return false}
    if lhs.edsHealthStatus != rhs.edsHealthStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/assuredworkloads/v1beta1/assuredworkloads_v1beta1.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request for creating a workload.
public struct Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the new Workload's parent.
  /// Must be of the form `organizations/{org_id}/locations/{location_id}`.
  public var parent: String = String()

  /// Required. Assured Workload to create
  public var workload: Google_Cloud_Assuredworkloads_V1beta1_Workload {
    get {return _workload ?? Google_Cloud_Assuredworkloads_V1beta1_Workload()}
    set {_workload = newValue}
  }
  /// Returns true if `workload` has been explicitly set.
  public var hasWorkload: Bool {return self._workload != nil}
  /// Clears the value of `workload`. Subsequent reads from it will return its default value.
  public mutating func clearWorkload() {self._workload = nil}

  /// Optional. A identifier associated with the workload and underlying projects which
  /// allows for the break down of billing costs for a workload. The value
  /// provided for the identifier will add a label to the workload and contained
  /// projects with the identifier as the value.
  public var externalID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workload: Google_Cloud_Assuredworkloads_V1beta1_Workload? = nil
}

/// Request for Updating a workload.
public struct Google_Cloud_Assuredworkloads_V1beta1_UpdateWorkloadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The workload to update.
  /// The workloadâ€™s `name` field is used to identify the workload to be updated.
  /// Format:
  /// organizations/{org_id}/locations/{location_id}/workloads/{workload_id}
  public var workload: Google_Cloud_Assuredworkloads_V1beta1_Workload {
    get {return _workload ?? Google_Cloud_Assuredworkloads_V1beta1_Workload()}
    set {_workload = newValue}
  }
  /// Returns true if `workload` has been explicitly set.
  public var hasWorkload: Bool {return self._workload != nil}
  /// Clears the value of `workload`. Subsequent reads from it will return its default value.
  public mutating func clearWorkload() {self._workload = nil}

  /// Required. The list of fields to be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workload: Google_Cloud_Assuredworkloads_V1beta1_Workload? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for deleting a Workload.
public struct Google_Cloud_Assuredworkloads_V1beta1_DeleteWorkloadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The `name` field is used to identify the workload.
  /// Format:
  /// organizations/{org_id}/locations/{location_id}/workloads/{workload_id}
  public var name: String = String()

  /// Optional. The etag of the workload.
  /// If this is provided, it must match the server's etag.
  public var etag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for fetching a workload.
public struct Google_Cloud_Assuredworkloads_V1beta1_GetWorkloadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Workload to fetch. This is the workloads's
  /// relative path in the API, formatted as
  /// "organizations/{organization_id}/locations/{location_id}/workloads/{workload_id}".
  /// For example,
  /// "organizations/123/locations/us-east1/workloads/assured-workload-1".
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for fetching workloads in an organization.
public struct Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent Resource to list workloads from.
  /// Must be of the form `organizations/{org_id}/locations/{location}`.
  public var parent: String = String()

  /// Page size.
  public var pageSize: Int32 = 0

  /// Page token returned from previous request. Page token contains context from
  /// previous request. Page token needs to be passed in the second and following
  /// requests.
  public var pageToken: String = String()

  /// A custom filter for filtering by properties of a workload. At this time,
  /// only filtering by labels is supported.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response of ListWorkloads endpoint.
public struct Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of Workloads under a given parent.
  public var workloads: [Google_Cloud_Assuredworkloads_V1beta1_Workload] = []

  /// The next page token. Return empty if reached the last page.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An Workload object for managing highly regulated workloads of cloud
/// customers.
public struct Google_Cloud_Assuredworkloads_V1beta1_Workload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The resource name of the workload.
  /// Format:
  /// organizations/{organization}/locations/{location}/workloads/{workload}
  ///
  /// Read-only.
  public var name: String = String()

  /// Required. The user-assigned display name of the Workload.
  /// When present it must be between 4 to 30 characters.
  /// Allowed characters are: lowercase and uppercase letters, numbers,
  /// hyphen, single-quote, double-quote, space, and exclamation point.
  ///
  /// Example: My Workload
  public var displayName: String = String()

  /// Output only. The resources associated with this workload.
  /// These resources will be created when creating the workload.
  /// If any of the projects already exist, the workload creation will fail.
  /// Always read only.
  public var resources: [Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo] = []

  /// Required. Immutable. Compliance Regime associated with this workload.
  public var complianceRegime: Google_Cloud_Assuredworkloads_V1beta1_Workload.ComplianceRegime = .unspecified

  /// Output only. Immutable. The Workload creation timestamp.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Required. Input only. The billing account used for the resources which are
  /// direct children of workload. This billing account is initially associated
  /// with the resources created as part of Workload creation.
  /// After the initial creation of these resources, the customer can change
  /// the assigned billing account.
  /// The resource name has the form
  /// `billingAccounts/{billing_account_id}`. For example,
  /// `billingAccounts/012345-567890-ABCDEF`.
  public var billingAccount: String = String()

  /// Settings specific to the selected [compliance_regime]
  public var complianceRegimeSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.OneOf_ComplianceRegimeSettings? = nil

  /// Required. Input only. Immutable. Settings specific to resources needed for IL4.
  public var il4Settings: Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings {
    get {
      if case .il4Settings(let v)? = complianceRegimeSettings {return v}
      return Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings()
    }
    set {complianceRegimeSettings = .il4Settings(newValue)}
  }

  /// Required. Input only. Immutable. Settings specific to resources needed for CJIS.
  public var cjisSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings {
    get {
      if case .cjisSettings(let v)? = complianceRegimeSettings {return v}
      return Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings()
    }
    set {complianceRegimeSettings = .cjisSettings(newValue)}
  }

  /// Required. Input only. Immutable. Settings specific to resources needed for FedRAMP High.
  public var fedrampHighSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings {
    get {
      if case .fedrampHighSettings(let v)? = complianceRegimeSettings {return v}
      return Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings()
    }
    set {complianceRegimeSettings = .fedrampHighSettings(newValue)}
  }

  /// Required. Input only. Immutable. Settings specific to resources needed for FedRAMP Moderate.
  public var fedrampModerateSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings {
    get {
      if case .fedrampModerateSettings(let v)? = complianceRegimeSettings {return v}
      return Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings()
    }
    set {complianceRegimeSettings = .fedrampModerateSettings(newValue)}
  }

  /// Optional. ETag of the workload, it is calculated on the basis
  /// of the Workload contents. It will be used in Update & Delete operations.
  public var etag: String = String()

  /// Optional. Labels applied to the workload.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Settings specific to the selected [compliance_regime]
  public enum OneOf_ComplianceRegimeSettings: Equatable {
    /// Required. Input only. Immutable. Settings specific to resources needed for IL4.
    case il4Settings(Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings)
    /// Required. Input only. Immutable. Settings specific to resources needed for CJIS.
    case cjisSettings(Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings)
    /// Required. Input only. Immutable. Settings specific to resources needed for FedRAMP High.
    case fedrampHighSettings(Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings)
    /// Required. Input only. Immutable. Settings specific to resources needed for FedRAMP Moderate.
    case fedrampModerateSettings(Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.OneOf_ComplianceRegimeSettings, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.OneOf_ComplianceRegimeSettings) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.il4Settings, .il4Settings): return {
        guard case .il4Settings(let l) = lhs, case .il4Settings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cjisSettings, .cjisSettings): return {
        guard case .cjisSettings(let l) = lhs, case .cjisSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fedrampHighSettings, .fedrampHighSettings): return {
        guard case .fedrampHighSettings(let l) = lhs, case .fedrampHighSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fedrampModerateSettings, .fedrampModerateSettings): return {
        guard case .fedrampModerateSettings(let l) = lhs, case .fedrampModerateSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Supported Compliance Regimes.
  public enum ComplianceRegime: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown compliance regime.
    case unspecified // = 0

    /// Information protection as per DoD IL4 requirements.
    case il4 // = 1

    /// Criminal Justice Information Services (CJIS) Security policies.
    case cjis // = 2

    /// FedRAMP High data protection controls
    case fedrampHigh // = 3

    /// FedRAMP Moderate data protection controls
    case fedrampModerate // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .il4
      case 2: self = .cjis
      case 3: self = .fedrampHigh
      case 4: self = .fedrampModerate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .il4: return 1
      case .cjis: return 2
      case .fedrampHigh: return 3
      case .fedrampModerate: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Represent the resources that are children of this Workload.
  public struct ResourceInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Resource identifier.
    /// For a project this represents project_number.
    public var resourceID: Int64 = 0

    /// Indicates the type of resource.
    public var resourceType: Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo.ResourceType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of resource.
    public enum ResourceType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unknown resource type.
      case unspecified // = 0

      /// Consumer project.
      case consumerProject // = 1

      /// Consumer project containing encryption keys.
      case encryptionKeysProject // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .consumerProject
        case 2: self = .encryptionKeysProject
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .consumerProject: return 1
        case .encryptionKeysProject: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// Settings specific to the Key Management Service.
  public struct KMSSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Input only. Immutable. The time at which the Key Management Service will automatically create a
    /// new version of the crypto key and mark it as the primary.
    public var nextRotationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _nextRotationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_nextRotationTime = newValue}
    }
    /// Returns true if `nextRotationTime` has been explicitly set.
    public var hasNextRotationTime: Bool {return self._nextRotationTime != nil}
    /// Clears the value of `nextRotationTime`. Subsequent reads from it will return its default value.
    public mutating func clearNextRotationTime() {self._nextRotationTime = nil}

    /// Required. Input only. Immutable. [next_rotation_time] will be advanced by this period when the Key
    /// Management Service automatically rotates a key. Must be at least 24 hours
    /// and at most 876,000 hours.
    public var rotationPeriod: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _rotationPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_rotationPeriod = newValue}
    }
    /// Returns true if `rotationPeriod` has been explicitly set.
    public var hasRotationPeriod: Bool {return self._rotationPeriod != nil}
    /// Clears the value of `rotationPeriod`. Subsequent reads from it will return its default value.
    public mutating func clearRotationPeriod() {self._rotationPeriod = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _nextRotationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _rotationPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  /// Settings specific to resources needed for IL4.
  public struct IL4Settings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Input only. Immutable. Settings used to create a CMEK crypto key.
    public var kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings {
      get {return _kmsSettings ?? Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings()}
      set {_kmsSettings = newValue}
    }
    /// Returns true if `kmsSettings` has been explicitly set.
    public var hasKmsSettings: Bool {return self._kmsSettings != nil}
    /// Clears the value of `kmsSettings`. Subsequent reads from it will return its default value.
    public mutating func clearKmsSettings() {self._kmsSettings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings? = nil
  }

  /// Settings specific to resources needed for CJIS.
  public struct CJISSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Input only. Immutable. Settings used to create a CMEK crypto key.
    public var kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings {
      get {return _kmsSettings ?? Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings()}
      set {_kmsSettings = newValue}
    }
    /// Returns true if `kmsSettings` has been explicitly set.
    public var hasKmsSettings: Bool {return self._kmsSettings != nil}
    /// Clears the value of `kmsSettings`. Subsequent reads from it will return its default value.
    public mutating func clearKmsSettings() {self._kmsSettings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings? = nil
  }

  /// Settings specific to resources needed for FedRAMP High.
  public struct FedrampHighSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Input only. Immutable. Settings used to create a CMEK crypto key.
    public var kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings {
      get {return _kmsSettings ?? Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings()}
      set {_kmsSettings = newValue}
    }
    /// Returns true if `kmsSettings` has been explicitly set.
    public var hasKmsSettings: Bool {return self._kmsSettings != nil}
    /// Clears the value of `kmsSettings`. Subsequent reads from it will return its default value.
    public mutating func clearKmsSettings() {self._kmsSettings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings? = nil
  }

  /// Settings specific to resources needed for FedRAMP Moderate.
  public struct FedrampModerateSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Input only. Immutable. Settings used to create a CMEK crypto key.
    public var kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings {
      get {return _kmsSettings ?? Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings()}
      set {_kmsSettings = newValue}
    }
    /// Returns true if `kmsSettings` has been explicitly set.
    public var hasKmsSettings: Bool {return self._kmsSettings != nil}
    /// Clears the value of `kmsSettings`. Subsequent reads from it will return its default value.
    public mutating func clearKmsSettings() {self._kmsSettings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _kmsSettings: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings? = nil
  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.ComplianceRegime: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Assuredworkloads_V1beta1_Workload.ComplianceRegime] = [
    .unspecified,
    .il4,
    .cjis,
    .fedrampHigh,
    .fedrampModerate,
  ]
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo.ResourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo.ResourceType] = [
    .unspecified,
    .consumerProject,
    .encryptionKeysProject,
  ]
}

#endif  // swift(>=4.2)

/// Operation metadata to give request details of CreateWorkload.
public struct Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Time when the operation was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Optional. The display name of the workload.
  public var displayName: String = String()

  /// Optional. The parent of the workload.
  public var parent: String = String()

  /// Optional. Compliance controls that should be applied to the resources managed by
  /// the workload.
  public var complianceRegime: Google_Cloud_Assuredworkloads_V1beta1_Workload.ComplianceRegime = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.assuredworkloads.v1beta1"

extension Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkloadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "workload"),
    3: .standard(proto: "external_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workload) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.externalID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._workload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.externalID.isEmpty {
      try visitor.visitSingularStringField(value: self.externalID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadRequest, rhs: Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._workload != rhs._workload {return false}
    if lhs.externalID != rhs.externalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_UpdateWorkloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkloadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workload"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workload) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._workload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_UpdateWorkloadRequest, rhs: Google_Cloud_Assuredworkloads_V1beta1_UpdateWorkloadRequest) -> Bool {
    if lhs._workload != rhs._workload {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_DeleteWorkloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkloadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "etag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_DeleteWorkloadRequest, rhs: Google_Cloud_Assuredworkloads_V1beta1_DeleteWorkloadRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_GetWorkloadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkloadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_GetWorkloadRequest, rhs: Google_Cloud_Assuredworkloads_V1beta1_GetWorkloadRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkloadsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsRequest, rhs: Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkloadsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "workloads"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workloads) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workloads, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsResponse, rhs: Google_Cloud_Assuredworkloads_V1beta1_ListWorkloadsResponse) -> Bool {
    if lhs.workloads != rhs.workloads {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Workload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "resources"),
    4: .standard(proto: "compliance_regime"),
    5: .standard(proto: "create_time"),
    6: .standard(proto: "billing_account"),
    7: .standard(proto: "il4_settings"),
    8: .standard(proto: "cjis_settings"),
    11: .standard(proto: "fedramp_high_settings"),
    12: .standard(proto: "fedramp_moderate_settings"),
    9: .same(proto: "etag"),
    10: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.complianceRegime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.billingAccount) }()
      case 7: try {
        var v: Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings?
        if let current = self.complianceRegimeSettings {
          try decoder.handleConflictingOneOf()
          if case .il4Settings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.complianceRegimeSettings = .il4Settings(v)}
      }()
      case 8: try {
        var v: Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings?
        if let current = self.complianceRegimeSettings {
          try decoder.handleConflictingOneOf()
          if case .cjisSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.complianceRegimeSettings = .cjisSettings(v)}
      }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 11: try {
        var v: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings?
        if let current = self.complianceRegimeSettings {
          try decoder.handleConflictingOneOf()
          if case .fedrampHighSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.complianceRegimeSettings = .fedrampHighSettings(v)}
      }()
      case 12: try {
        var v: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings?
        if let current = self.complianceRegimeSettings {
          try decoder.handleConflictingOneOf()
          if case .fedrampModerateSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.complianceRegimeSettings = .fedrampModerateSettings(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 3)
    }
    if self.complianceRegime != .unspecified {
      try visitor.visitSingularEnumField(value: self.complianceRegime, fieldNumber: 4)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.billingAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.billingAccount, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.complianceRegimeSettings {
    case .il4Settings?: try {
      guard case .il4Settings(let v)? = self.complianceRegimeSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .cjisSettings?: try {
      guard case .cjisSettings(let v)? = self.complianceRegimeSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    default: break
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 9)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 10)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.complianceRegimeSettings {
    case .fedrampHighSettings?: try {
      guard case .fedrampHighSettings(let v)? = self.complianceRegimeSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .fedrampModerateSettings?: try {
      guard case .fedrampModerateSettings(let v)? = self.complianceRegimeSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.complianceRegime != rhs.complianceRegime {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.billingAccount != rhs.billingAccount {return false}
    if lhs.complianceRegimeSettings != rhs.complianceRegimeSettings {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.ComplianceRegime: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPLIANCE_REGIME_UNSPECIFIED"),
    1: .same(proto: "IL4"),
    2: .same(proto: "CJIS"),
    3: .same(proto: "FEDRAMP_HIGH"),
    4: .same(proto: "FEDRAMP_MODERATE"),
  ]
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Assuredworkloads_V1beta1_Workload.protoMessageName + ".ResourceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_id"),
    2: .standard(proto: "resource_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.resourceID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.resourceID != 0 {
      try visitor.visitSingularInt64Field(value: self.resourceID, fieldNumber: 1)
    }
    if self.resourceType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resourceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo) -> Bool {
    if lhs.resourceID != rhs.resourceID {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.ResourceInfo.ResourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESOURCE_TYPE_UNSPECIFIED"),
    1: .same(proto: "CONSUMER_PROJECT"),
    2: .same(proto: "ENCRYPTION_KEYS_PROJECT"),
  ]
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Assuredworkloads_V1beta1_Workload.protoMessageName + ".KMSSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_rotation_time"),
    2: .standard(proto: "rotation_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._nextRotationTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rotationPeriod) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nextRotationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._rotationPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.KMSSettings) -> Bool {
    if lhs._nextRotationTime != rhs._nextRotationTime {return false}
    if lhs._rotationPeriod != rhs._rotationPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Assuredworkloads_V1beta1_Workload.protoMessageName + ".IL4Settings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kms_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kmsSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kmsSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.IL4Settings) -> Bool {
    if lhs._kmsSettings != rhs._kmsSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Assuredworkloads_V1beta1_Workload.protoMessageName + ".CJISSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kms_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kmsSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kmsSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.CJISSettings) -> Bool {
    if lhs._kmsSettings != rhs._kmsSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Assuredworkloads_V1beta1_Workload.protoMessageName + ".FedrampHighSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kms_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kmsSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kmsSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampHighSettings) -> Bool {
    if lhs._kmsSettings != rhs._kmsSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Assuredworkloads_V1beta1_Workload.protoMessageName + ".FedrampModerateSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kms_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._kmsSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._kmsSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings, rhs: Google_Cloud_Assuredworkloads_V1beta1_Workload.FedrampModerateSettings) -> Bool {
    if lhs._kmsSettings != rhs._kmsSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkloadOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_time"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "parent"),
    4: .standard(proto: "compliance_regime"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.complianceRegime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 3)
    }
    if self.complianceRegime != .unspecified {
      try visitor.visitSingularEnumField(value: self.complianceRegime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadOperationMetadata, rhs: Google_Cloud_Assuredworkloads_V1beta1_CreateWorkloadOperationMetadata) -> Bool {
    if lhs._createTime != rhs._createTime {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.complianceRegime != rhs.complianceRegime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/memcache/v1beta2/cloud_memcache.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Memcached versions supported by our service.
public enum Google_Cloud_Memcache_V1beta2_MemcacheVersion: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Memcached 1.5 version.
  case memcache15 // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .memcache15
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .memcache15: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Memcache_V1beta2_MemcacheVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Memcache_V1beta2_MemcacheVersion] = [
    .unspecified,
    .memcache15,
  ]
}

#endif  // swift(>=4.2)

public struct Google_Cloud_Memcache_V1beta2_Instance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Unique name of the resource in this scope including project and
  /// location using the form:
  ///     `projects/{project_id}/locations/{location_id}/instances/{instance_id}`
  ///
  /// Note: Memcached instances are managed and addressed at regional level so
  /// location_id here refers to a GCP region; however, users may choose which
  /// zones Memcached nodes within an instances should be provisioned in.
  /// Refer to [zones] field for more details.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional. User provided name for the instance only used for display
  /// purposes. Cannot be more than 80 characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Optional. Resource labels to represent user-provided metadata.
  /// Refer to cloud documentation on labels for more details.
  /// https://cloud.google.com/compute/docs/labeling-resources
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Optional. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/vpc/docs/vpc) to which the
  /// instance is connected. If left unspecified, the `default` network
  /// will be used.
  public var authorizedNetwork: String {
    get {return _storage._authorizedNetwork}
    set {_uniqueStorage()._authorizedNetwork = newValue}
  }

  /// Optional. Zones where Memcached nodes should be provisioned in.
  /// Memcached nodes will be equally distributed across these zones. If not
  /// provided, the service will by default create nodes in all zones in the
  /// region for the instance.
  public var zones: [String] {
    get {return _storage._zones}
    set {_uniqueStorage()._zones = newValue}
  }

  /// Required. Number of nodes in the Memcached instance.
  public var nodeCount: Int32 {
    get {return _storage._nodeCount}
    set {_uniqueStorage()._nodeCount = newValue}
  }

  /// Required. Configuration for Memcached nodes.
  public var nodeConfig: Google_Cloud_Memcache_V1beta2_Instance.NodeConfig {
    get {return _storage._nodeConfig ?? Google_Cloud_Memcache_V1beta2_Instance.NodeConfig()}
    set {_uniqueStorage()._nodeConfig = newValue}
  }
  /// Returns true if `nodeConfig` has been explicitly set.
  public var hasNodeConfig: Bool {return _storage._nodeConfig != nil}
  /// Clears the value of `nodeConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNodeConfig() {_uniqueStorage()._nodeConfig = nil}

  /// Optional. The major version of Memcached software.
  /// If not provided, latest supported version will be used. Currently the
  /// latest supported major version is MEMCACHE_1_5.
  /// The minor version will be automatically determined by our system based on
  /// the latest supported minor version.
  public var memcacheVersion: Google_Cloud_Memcache_V1beta2_MemcacheVersion {
    get {return _storage._memcacheVersion}
    set {_uniqueStorage()._memcacheVersion = newValue}
  }

  /// Optional: User defined parameters to apply to the memcached process
  /// on each node.
  public var parameters: Google_Cloud_Memcache_V1beta2_MemcacheParameters {
    get {return _storage._parameters ?? Google_Cloud_Memcache_V1beta2_MemcacheParameters()}
    set {_uniqueStorage()._parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return _storage._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {_uniqueStorage()._parameters = nil}

  /// Output only. List of Memcached nodes.
  /// Refer to [Node] message for more details.
  public var memcacheNodes: [Google_Cloud_Memcache_V1beta2_Instance.Node] {
    get {return _storage._memcacheNodes}
    set {_uniqueStorage()._memcacheNodes = newValue}
  }

  /// Output only. The time the instance was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time the instance was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. The state of this Memcached instance.
  public var state: Google_Cloud_Memcache_V1beta2_Instance.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. The full version of memcached server running on this instance.
  /// System automatically determines the full memcached version for an instance
  /// based on the input MemcacheVersion.
  /// The full version format will be "memcached-1.5.16".
  public var memcacheFullVersion: String {
    get {return _storage._memcacheFullVersion}
    set {_uniqueStorage()._memcacheFullVersion = newValue}
  }

  /// List of messages that describe current statuses of memcached instance.
  public var instanceMessages: [Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage] {
    get {return _storage._instanceMessages}
    set {_uniqueStorage()._instanceMessages = newValue}
  }

  /// Output only. Endpoint for Discovery API
  public var discoveryEndpoint: String {
    get {return _storage._discoveryEndpoint}
    set {_uniqueStorage()._discoveryEndpoint = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Different states of a Memcached instance.
  /// LINT.IfChange
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// State not set.
    case unspecified // = 0

    /// Memcached instance is being created.
    case creating // = 1

    /// Memcached instance has been created and ready to be used.
    case ready // = 2

    /// Memcached instance is being deleted.
    case deleting // = 4

    /// Memcached instance is going through maintenance, e.g. data plane rollout.
    case performingMaintenance // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .ready
      case 4: self = .deleting
      case 5: self = .performingMaintenance
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .ready: return 2
      case .deleting: return 4
      case .performingMaintenance: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Configuration for a Memcached Node.
  public struct NodeConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Number of cpus per Memcached node.
    public var cpuCount: Int32 = 0

    /// Required. Memory size in MiB for each Memcached node.
    public var memorySizeMb: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct Node {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. Identifier of the Memcached node. The node id does not
    /// include project or location like the Memcached instance name.
    public var nodeID: String = String()

    /// Output only. Location (GCP Zone) for the Memcached node.
    public var zone: String = String()

    /// Output only. Current state of the Memcached node.
    public var state: Google_Cloud_Memcache_V1beta2_Instance.Node.State = .unspecified

    /// Output only. Hostname or IP address of the Memcached node used by the
    /// clients to connect to the Memcached server on this node.
    public var host: String = String()

    /// Output only. The port number of the Memcached server on this node.
    public var port: Int32 = 0

    /// User defined parameters currently applied to the node.
    public var parameters: Google_Cloud_Memcache_V1beta2_MemcacheParameters {
      get {return _parameters ?? Google_Cloud_Memcache_V1beta2_MemcacheParameters()}
      set {_parameters = newValue}
    }
    /// Returns true if `parameters` has been explicitly set.
    public var hasParameters: Bool {return self._parameters != nil}
    /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
    public mutating func clearParameters() {self._parameters = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Different states of a Memcached node.
    /// LINT.IfChange
    public enum State: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Node state is not set.
      case unspecified // = 0

      /// Node is being created.
      case creating // = 1

      /// Node has been created and ready to be used.
      case ready // = 2

      /// Node is being deleted.
      case deleting // = 3

      /// Node is being updated.
      case updating // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .creating
        case 2: self = .ready
        case 3: self = .deleting
        case 4: self = .updating
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .creating: return 1
        case .ready: return 2
        case .deleting: return 3
        case .updating: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _parameters: Google_Cloud_Memcache_V1beta2_MemcacheParameters? = nil
  }

  public struct InstanceMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A code that correspond to one type of user-facing message.
    public var code: Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage.Code = .unspecified

    /// Message on memcached instance which will be exposed to users.
    public var message: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Code: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Message Code not set.
      case unspecified // = 0

      /// Memcached nodes are distributed unevenly.
      case zoneDistributionUnbalanced // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .zoneDistributionUnbalanced
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .zoneDistributionUnbalanced: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Memcache_V1beta2_Instance.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Memcache_V1beta2_Instance.State] = [
    .unspecified,
    .creating,
    .ready,
    .deleting,
    .performingMaintenance,
  ]
}

extension Google_Cloud_Memcache_V1beta2_Instance.Node.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Memcache_V1beta2_Instance.Node.State] = [
    .unspecified,
    .creating,
    .ready,
    .deleting,
    .updating,
  ]
}

extension Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage.Code] = [
    .unspecified,
    .zoneDistributionUnbalanced,
  ]
}

#endif  // swift(>=4.2)

/// Request for [ListInstances][google.cloud.memcache.v1beta2.CloudMemcache.ListInstances].
public struct Google_Cloud_Memcache_V1beta2_ListInstancesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the instance location using the form:
  ///     `projects/{project_id}/locations/{location_id}`
  /// where `location_id` refers to a GCP region
  public var parent: String = String()

  /// The maximum number of items to return.
  ///
  /// If not specified, a default value of 1000 will be used by the service.
  /// Regardless of the page_size value, the response may include a partial list
  /// and a caller should only rely on response's
  /// [next_page_token][CloudMemcache.ListInstancesResponse.next_page_token]
  /// to determine if there are more instances left to be queried.
  public var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous List request,
  /// if any.
  public var pageToken: String = String()

  /// List filter. For example, exclude all Memcached instances with name as
  /// my-instance by specifying "name != my-instance".
  public var filter: String = String()

  /// Sort results. Supported values are "name", "name desc" or "" (unsorted).
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for [ListInstances][google.cloud.memcache.v1beta2.CloudMemcache.ListInstances].
public struct Google_Cloud_Memcache_V1beta2_ListInstancesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of Memcached instances in the project in the specified location,
  /// or across all locations.
  ///
  /// If the `location_id` in the parent field of the request is "-", all regions
  /// available to the project are queried, and the results aggregated.
  public var resources: [Google_Cloud_Memcache_V1beta2_Instance] = []

  /// Token to retrieve the next page of results, or empty if there are no more
  /// results in the list.
  public var nextPageToken: String = String()

  /// Locations that could not be reached.
  public var unreachable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for [GetInstance][google.cloud.memcache.v1beta2.CloudMemcache.GetInstance].
public struct Google_Cloud_Memcache_V1beta2_GetInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Memcached instance resource name in the format:
  ///     `projects/{project_id}/locations/{location_id}/instances/{instance_id}`
  /// where `location_id` refers to a GCP region
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for [CreateInstance][google.cloud.memcache.v1beta2.CloudMemcache.CreateInstance].
public struct Google_Cloud_Memcache_V1beta2_CreateInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the instance location using the form:
  ///     `projects/{project_id}/locations/{location_id}`
  /// where `location_id` refers to a GCP region
  public var parent: String = String()

  /// Required. The logical name of the Memcached instance in the user
  /// project with the following restrictions:
  ///
  /// * Must contain only lowercase letters, numbers, and hyphens.
  /// * Must start with a letter.
  /// * Must be between 1-40 characters.
  /// * Must end with a number or a letter.
  /// * Must be unique within the user project / location
  public var instanceID: String = String()

  /// Required. A Memcached [Instance] resource
  public var resource: Google_Cloud_Memcache_V1beta2_Instance {
    get {return _resource ?? Google_Cloud_Memcache_V1beta2_Instance()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resource: Google_Cloud_Memcache_V1beta2_Instance? = nil
}

/// Request for [UpdateInstance][google.cloud.memcache.v1beta2.CloudMemcache.UpdateInstance].
public struct Google_Cloud_Memcache_V1beta2_UpdateInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Mask of fields to update.
  ///  *   `displayName`
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// Required. A Memcached [Instance] resource.
  /// Only fields specified in update_mask are updated.
  public var resource: Google_Cloud_Memcache_V1beta2_Instance {
    get {return _resource ?? Google_Cloud_Memcache_V1beta2_Instance()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _resource: Google_Cloud_Memcache_V1beta2_Instance? = nil
}

/// Request for [DeleteInstance][google.cloud.memcache.v1beta2.CloudMemcache.DeleteInstance].
public struct Google_Cloud_Memcache_V1beta2_DeleteInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Memcached instance resource name in the format:
  ///     `projects/{project_id}/locations/{location_id}/instances/{instance_id}`
  /// where `location_id` refers to a GCP region
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for [ApplyParameters][google.cloud.memcache.v1beta2.CloudMemcache.ApplyParameters].
public struct Google_Cloud_Memcache_V1beta2_ApplyParametersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the Memcached instance for which parameter group updates
  /// should be applied.
  public var name: String = String()

  /// Nodes to which we should apply the instance-level parameter group.
  public var nodeIds: [String] = []

  /// Whether to apply instance-level parameter group to all nodes. If set to
  /// true, will explicitly restrict users from specifying any nodes, and apply
  /// parameter group updates to all nodes within the instance.
  public var applyAll: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for [UpdateParameters][google.cloud.memcache.v1beta2.CloudMemcache.UpdateParameters].
public struct Google_Cloud_Memcache_V1beta2_UpdateParametersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the Memcached instance for which the parameters should be
  /// updated.
  public var name: String = String()

  /// Required. Mask of fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// The parameters to apply to the instance.
  public var parameters: Google_Cloud_Memcache_V1beta2_MemcacheParameters {
    get {return _parameters ?? Google_Cloud_Memcache_V1beta2_MemcacheParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _parameters: Google_Cloud_Memcache_V1beta2_MemcacheParameters? = nil
}

public struct Google_Cloud_Memcache_V1beta2_MemcacheParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The unique ID associated with this set of parameters. Users
  /// can use this id to determine if the parameters associated with the instance
  /// differ from the parameters associated with the nodes and any action needs
  /// to be taken to apply parameters on nodes.
  public var id: String = String()

  /// User defined set of parameters to use in the memcached process.
  public var params: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the metadata of a long-running operation.
public struct Google_Cloud_Memcache_V1beta2_OperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time when the operation was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Time when the operation finished running.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Server-defined resource path for the target of the operation.
  public var target: String = String()

  /// Name of the verb executed by the operation.
  public var verb: String = String()

  /// Human-readable status of the operation, if any.
  public var statusDetail: String = String()

  /// Identifies whether the user has requested cancellation
  /// of the operation. Operations that have successfully been cancelled
  /// have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
  /// corresponding to `Code.CANCELLED`.
  public var cancelRequested: Bool = false

  /// API version used to start the operation.
  public var apiVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata for the given [google.cloud.location.Location][google.cloud.location.Location].
public struct Google_Cloud_Memcache_V1beta2_LocationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The set of available zones in the location. The map is keyed
  /// by the lowercase ID of each zone, as defined by GCE. These keys can be
  /// specified in the `zones` field when creating a Memcached instance.
  public var availableZones: Dictionary<String,Google_Cloud_Memcache_V1beta2_ZoneMetadata> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Memcache_V1beta2_ZoneMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.memcache.v1beta2"

extension Google_Cloud_Memcache_V1beta2_MemcacheVersion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMCACHE_VERSION_UNSPECIFIED"),
    1: .same(proto: "MEMCACHE_1_5"),
  ]
}

extension Google_Cloud_Memcache_V1beta2_Instance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "labels"),
    4: .standard(proto: "authorized_network"),
    5: .same(proto: "zones"),
    6: .standard(proto: "node_count"),
    7: .standard(proto: "node_config"),
    9: .standard(proto: "memcache_version"),
    11: .same(proto: "parameters"),
    12: .standard(proto: "memcache_nodes"),
    13: .standard(proto: "create_time"),
    14: .standard(proto: "update_time"),
    15: .same(proto: "state"),
    18: .standard(proto: "memcache_full_version"),
    19: .standard(proto: "instance_messages"),
    20: .standard(proto: "discovery_endpoint"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _labels: Dictionary<String,String> = [:]
    var _authorizedNetwork: String = String()
    var _zones: [String] = []
    var _nodeCount: Int32 = 0
    var _nodeConfig: Google_Cloud_Memcache_V1beta2_Instance.NodeConfig? = nil
    var _memcacheVersion: Google_Cloud_Memcache_V1beta2_MemcacheVersion = .unspecified
    var _parameters: Google_Cloud_Memcache_V1beta2_MemcacheParameters? = nil
    var _memcacheNodes: [Google_Cloud_Memcache_V1beta2_Instance.Node] = []
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Google_Cloud_Memcache_V1beta2_Instance.State = .unspecified
    var _memcacheFullVersion: String = String()
    var _instanceMessages: [Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage] = []
    var _discoveryEndpoint: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _labels = source._labels
      _authorizedNetwork = source._authorizedNetwork
      _zones = source._zones
      _nodeCount = source._nodeCount
      _nodeConfig = source._nodeConfig
      _memcacheVersion = source._memcacheVersion
      _parameters = source._parameters
      _memcacheNodes = source._memcacheNodes
      _createTime = source._createTime
      _updateTime = source._updateTime
      _state = source._state
      _memcacheFullVersion = source._memcacheFullVersion
      _instanceMessages = source._instanceMessages
      _discoveryEndpoint = source._discoveryEndpoint
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._authorizedNetwork) }()
        case 5: try { try decoder.decodeRepeatedStringField(value: &_storage._zones) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._nodeCount) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._nodeConfig) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._memcacheVersion) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._parameters) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._memcacheNodes) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._memcacheFullVersion) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._instanceMessages) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._discoveryEndpoint) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 3)
      }
      if !_storage._authorizedNetwork.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizedNetwork, fieldNumber: 4)
      }
      if !_storage._zones.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._zones, fieldNumber: 5)
      }
      if _storage._nodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nodeCount, fieldNumber: 6)
      }
      if let v = _storage._nodeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._memcacheVersion != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._memcacheVersion, fieldNumber: 9)
      }
      if let v = _storage._parameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._memcacheNodes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._memcacheNodes, fieldNumber: 12)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 15)
      }
      if !_storage._memcacheFullVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._memcacheFullVersion, fieldNumber: 18)
      }
      if !_storage._instanceMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._instanceMessages, fieldNumber: 19)
      }
      if !_storage._discoveryEndpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._discoveryEndpoint, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_Instance, rhs: Google_Cloud_Memcache_V1beta2_Instance) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._authorizedNetwork != rhs_storage._authorizedNetwork {return false}
        if _storage._zones != rhs_storage._zones {return false}
        if _storage._nodeCount != rhs_storage._nodeCount {return false}
        if _storage._nodeConfig != rhs_storage._nodeConfig {return false}
        if _storage._memcacheVersion != rhs_storage._memcacheVersion {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._memcacheNodes != rhs_storage._memcacheNodes {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._memcacheFullVersion != rhs_storage._memcacheFullVersion {return false}
        if _storage._instanceMessages != rhs_storage._instanceMessages {return false}
        if _storage._discoveryEndpoint != rhs_storage._discoveryEndpoint {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_Instance.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
    4: .same(proto: "DELETING"),
    5: .same(proto: "PERFORMING_MAINTENANCE"),
  ]
}

extension Google_Cloud_Memcache_V1beta2_Instance.NodeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Memcache_V1beta2_Instance.protoMessageName + ".NodeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpu_count"),
    2: .standard(proto: "memory_size_mb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.cpuCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.memorySizeMb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpuCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cpuCount, fieldNumber: 1)
    }
    if self.memorySizeMb != 0 {
      try visitor.visitSingularInt32Field(value: self.memorySizeMb, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_Instance.NodeConfig, rhs: Google_Cloud_Memcache_V1beta2_Instance.NodeConfig) -> Bool {
    if lhs.cpuCount != rhs.cpuCount {return false}
    if lhs.memorySizeMb != rhs.memorySizeMb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_Instance.Node: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Memcache_V1beta2_Instance.protoMessageName + ".Node"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_id"),
    2: .same(proto: "zone"),
    3: .same(proto: "state"),
    4: .same(proto: "host"),
    5: .same(proto: "port"),
    6: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nodeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 4)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 5)
    }
    if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_Instance.Node, rhs: Google_Cloud_Memcache_V1beta2_Instance.Node) -> Bool {
    if lhs.nodeID != rhs.nodeID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.state != rhs.state {return false}
    if lhs.host != rhs.host {return false}
    if lhs.port != rhs.port {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_Instance.Node.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
    3: .same(proto: "DELETING"),
    4: .same(proto: "UPDATING"),
  ]
}

extension Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Memcache_V1beta2_Instance.protoMessageName + ".InstanceMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unspecified {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage, rhs: Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_Instance.InstanceMessage.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CODE_UNSPECIFIED"),
    1: .same(proto: "ZONE_DISTRIBUTION_UNBALANCED"),
  ]
}

extension Google_Cloud_Memcache_V1beta2_ListInstancesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstancesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_ListInstancesRequest, rhs: Google_Cloud_Memcache_V1beta2_ListInstancesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_ListInstancesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstancesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
    2: .standard(proto: "next_page_token"),
    3: .same(proto: "unreachable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_ListInstancesResponse, rhs: Google_Cloud_Memcache_V1beta2_ListInstancesResponse) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_GetInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_GetInstanceRequest, rhs: Google_Cloud_Memcache_V1beta2_GetInstanceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_CreateInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "instance_id"),
    3: .same(proto: "resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 2)
    }
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_CreateInstanceRequest, rhs: Google_Cloud_Memcache_V1beta2_CreateInstanceRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_UpdateInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_mask"),
    2: .same(proto: "resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_UpdateInstanceRequest, rhs: Google_Cloud_Memcache_V1beta2_UpdateInstanceRequest) -> Bool {
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_DeleteInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_DeleteInstanceRequest, rhs: Google_Cloud_Memcache_V1beta2_DeleteInstanceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_ApplyParametersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplyParametersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "node_ids"),
    3: .standard(proto: "apply_all"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.nodeIds) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.applyAll) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.nodeIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nodeIds, fieldNumber: 2)
    }
    if self.applyAll != false {
      try visitor.visitSingularBoolField(value: self.applyAll, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_ApplyParametersRequest, rhs: Google_Cloud_Memcache_V1beta2_ApplyParametersRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.nodeIds != rhs.nodeIds {return false}
    if lhs.applyAll != rhs.applyAll {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_UpdateParametersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateParametersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "update_mask"),
    3: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_UpdateParametersRequest, rhs: Google_Cloud_Memcache_V1beta2_UpdateParametersRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_MemcacheParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MemcacheParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    3: .same(proto: "params"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.params) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.params, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_MemcacheParameters, rhs: Google_Cloud_Memcache_V1beta2_MemcacheParameters) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_OperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "target"),
    4: .same(proto: "verb"),
    5: .standard(proto: "status_detail"),
    6: .standard(proto: "cancel_requested"),
    7: .standard(proto: "api_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.verb) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusDetail) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    if !self.verb.isEmpty {
      try visitor.visitSingularStringField(value: self.verb, fieldNumber: 4)
    }
    if !self.statusDetail.isEmpty {
      try visitor.visitSingularStringField(value: self.statusDetail, fieldNumber: 5)
    }
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 6)
    }
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_OperationMetadata, rhs: Google_Cloud_Memcache_V1beta2_OperationMetadata) -> Bool {
    if lhs._createTime != rhs._createTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.target != rhs.target {return false}
    if lhs.verb != rhs.verb {return false}
    if lhs.statusDetail != rhs.statusDetail {return false}
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_LocationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "available_zones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Memcache_V1beta2_ZoneMetadata>.self, value: &self.availableZones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.availableZones.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Memcache_V1beta2_ZoneMetadata>.self, value: self.availableZones, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_LocationMetadata, rhs: Google_Cloud_Memcache_V1beta2_LocationMetadata) -> Bool {
    if lhs.availableZones != rhs.availableZones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Memcache_V1beta2_ZoneMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ZoneMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Memcache_V1beta2_ZoneMetadata, rhs: Google_Cloud_Memcache_V1beta2_ZoneMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/metastore/v1alpha/metastore.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A managed metastore service that serves metadata queries.
public struct Google_Cloud_Metastore_V1alpha_Service {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The relative resource name of the metastore service, of the form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}".
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. The time when the metastore service was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time when the metastore service was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// User-defined labels for the metastore service.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Configuration properties specific to the underlying metastore service
  /// technology (the software that serves metastore queries).
  public var metastoreConfig: OneOf_MetastoreConfig? {
    get {return _storage._metastoreConfig}
    set {_uniqueStorage()._metastoreConfig = newValue}
  }

  /// Configuration information specific to running Hive metastore
  /// software as the metastore service.
  public var hiveMetastoreConfig: Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig {
    get {
      if case .hiveMetastoreConfig(let v)? = _storage._metastoreConfig {return v}
      return Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig()
    }
    set {_uniqueStorage()._metastoreConfig = .hiveMetastoreConfig(newValue)}
  }

  /// Immutable. The relative resource name of the VPC network on which the instance can be
  /// accessed. The network must belong to the same project as the metastore
  /// instance. It is specified in the following form:
  ///
  /// "projects/{project_id}/global/networks/{network_id}".
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// Output only. The URI of the endpoint used to access the metastore service.
  public var endpointUri: String {
    get {return _storage._endpointUri}
    set {_uniqueStorage()._endpointUri = newValue}
  }

  /// The TCP port at which the metastore service is reached. Default: 9083.
  public var port: Int32 {
    get {return _storage._port}
    set {_uniqueStorage()._port = newValue}
  }

  /// Output only. The current state of the metastore service.
  public var state: Google_Cloud_Metastore_V1alpha_Service.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. Additional information about the current state of the metastore service, if
  /// available.
  public var stateMessage: String {
    get {return _storage._stateMessage}
    set {_uniqueStorage()._stateMessage = newValue}
  }

  /// Output only. A Cloud Storage URI (starting with `gs://`) that specifies where artifacts
  /// related to the metastore service are stored.
  public var artifactGcsUri: String {
    get {return _storage._artifactGcsUri}
    set {_uniqueStorage()._artifactGcsUri = newValue}
  }

  /// The tier of the service.
  public var tier: Google_Cloud_Metastore_V1alpha_Service.Tier {
    get {return _storage._tier}
    set {_uniqueStorage()._tier = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configuration properties specific to the underlying metastore service
  /// technology (the software that serves metastore queries).
  public enum OneOf_MetastoreConfig: Equatable {
    /// Configuration information specific to running Hive metastore
    /// software as the metastore service.
    case hiveMetastoreConfig(Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Metastore_V1alpha_Service.OneOf_MetastoreConfig, rhs: Google_Cloud_Metastore_V1alpha_Service.OneOf_MetastoreConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.hiveMetastoreConfig, .hiveMetastoreConfig): return {
        guard case .hiveMetastoreConfig(let l) = lhs, case .hiveMetastoreConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The current state of the metastore service.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the metastore service is unknown.
    case unspecified // = 0

    /// The metastore service is in the process of being created.
    case creating // = 1

    /// The metastore service is running and ready to serve queries.
    case active // = 2

    /// The metastore service is entering suspension. Its query-serving
    /// availability may cease unexpectedly.
    case suspending // = 3

    /// The metastore service is suspended and unable to serve queries.
    case suspended // = 4

    /// The metastore service is being updated. It remains usable but cannot
    /// accept additional update requests or be deleted at this time.
    case updating // = 5

    /// The metastore service is undergoing deletion. It cannot be used.
    case deleting // = 6

    /// The metastore service has encountered an error and cannot be used. The
    /// metastore service should be deleted.
    case error // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .active
      case 3: self = .suspending
      case 4: self = .suspended
      case 5: self = .updating
      case 6: self = .deleting
      case 7: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .active: return 2
      case .suspending: return 3
      case .suspended: return 4
      case .updating: return 5
      case .deleting: return 6
      case .error: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Available service tiers.
  public enum Tier: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The tier is not set.
    case unspecified // = 0

    /// The enterprise tier combines a powerful metastore serving layer with a
    /// highly scalable data storage layer.
    case enterprise // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 3: self = .enterprise
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enterprise: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Metastore_V1alpha_Service.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Metastore_V1alpha_Service.State] = [
    .unspecified,
    .creating,
    .active,
    .suspending,
    .suspended,
    .updating,
    .deleting,
    .error,
  ]
}

extension Google_Cloud_Metastore_V1alpha_Service.Tier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Metastore_V1alpha_Service.Tier] = [
    .unspecified,
    .enterprise,
  ]
}

#endif  // swift(>=4.2)

/// Specifies configuration information specific to running Hive metastore
/// software as the metastore service.
public struct Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The Hive metastore schema version.
  public var version: String = String()

  /// A mapping of Hive metastore configuration key-value pairs to apply to the
  /// Hive metastore (configured in `hive-site.xml`). The mappings
  /// override system defaults (some keys cannot be overridden).
  public var configOverrides: Dictionary<String,String> = [:]

  /// Information used to configure the Hive metastore service as a service
  /// principal in a Kerberos realm.
  public var kerberosConfig: Google_Cloud_Metastore_V1alpha_KerberosConfig {
    get {return _kerberosConfig ?? Google_Cloud_Metastore_V1alpha_KerberosConfig()}
    set {_kerberosConfig = newValue}
  }
  /// Returns true if `kerberosConfig` has been explicitly set.
  public var hasKerberosConfig: Bool {return self._kerberosConfig != nil}
  /// Clears the value of `kerberosConfig`. Subsequent reads from it will return its default value.
  public mutating func clearKerberosConfig() {self._kerberosConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _kerberosConfig: Google_Cloud_Metastore_V1alpha_KerberosConfig? = nil
}

/// Configuration information for a Kerberos principal.
public struct Google_Cloud_Metastore_V1alpha_KerberosConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A Kerberos keytab file that can be used to authenticate a service principal
  /// with a Kerberos Key Distribution Center (KDC).
  public var keytab: Google_Cloud_Metastore_V1alpha_Secret {
    get {return _keytab ?? Google_Cloud_Metastore_V1alpha_Secret()}
    set {_keytab = newValue}
  }
  /// Returns true if `keytab` has been explicitly set.
  public var hasKeytab: Bool {return self._keytab != nil}
  /// Clears the value of `keytab`. Subsequent reads from it will return its default value.
  public mutating func clearKeytab() {self._keytab = nil}

  /// A Kerberos principal that exists in the both the keytab the KDC
  /// to authenticate as. A typical principal is of the form
  /// "primary/instance@REALM", but there is no exact format.
  public var principal: String = String()

  /// A Cloud Storage URI that specifies the path to a
  /// krb5.conf file. It is of the form gs://{bucket_name}/path/to/krb5.conf,
  /// although the file does not need to be named krb5.conf explicitly.
  public var krb5ConfigGcsUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keytab: Google_Cloud_Metastore_V1alpha_Secret? = nil
}

/// A securely stored value.
public struct Google_Cloud_Metastore_V1alpha_Secret {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Google_Cloud_Metastore_V1alpha_Secret.OneOf_Value? = nil

  /// The relative resource name of a Secret Manager secret version, in the
  /// following form:
  ///
  /// "projects/{project_id}/secrets/{secret_id}/versions/{version_id}".
  public var cloudSecret: String {
    get {
      if case .cloudSecret(let v)? = value {return v}
      return String()
    }
    set {value = .cloudSecret(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Value: Equatable {
    /// The relative resource name of a Secret Manager secret version, in the
    /// following form:
    ///
    /// "projects/{project_id}/secrets/{secret_id}/versions/{version_id}".
    case cloudSecret(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Metastore_V1alpha_Secret.OneOf_Value, rhs: Google_Cloud_Metastore_V1alpha_Secret.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cloudSecret, .cloudSecret): return {
        guard case .cloudSecret(let l) = lhs, case .cloudSecret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A metastore resource that imports metadata.
public struct Google_Cloud_Metastore_V1alpha_MetadataImport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The relative resource name of the metadata import, of the form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}/metadataImports/{metadata_import_id}".
  public var name: String = String()

  /// The description of the metadata import.
  public var description_p: String = String()

  /// Output only. The time when the metadata import was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time when the metadata import was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Output only. The current state of the metadata import.
  public var state: Google_Cloud_Metastore_V1alpha_MetadataImport.State = .unspecified

  /// The metadata to be imported.
  public var metadata: Google_Cloud_Metastore_V1alpha_MetadataImport.OneOf_Metadata? = nil

  /// Immutable. A database dump from a pre-existing metastore's database.
  public var databaseDump: Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump {
    get {
      if case .databaseDump(let v)? = metadata {return v}
      return Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump()
    }
    set {metadata = .databaseDump(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The metadata to be imported.
  public enum OneOf_Metadata: Equatable {
    /// Immutable. A database dump from a pre-existing metastore's database.
    case databaseDump(Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Metastore_V1alpha_MetadataImport.OneOf_Metadata, rhs: Google_Cloud_Metastore_V1alpha_MetadataImport.OneOf_Metadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.databaseDump, .databaseDump): return {
        guard case .databaseDump(let l) = lhs, case .databaseDump(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The current state of the metadata import.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the metadata import is unknown.
    case unspecified // = 0

    /// The metadata import is running.
    case running // = 1

    /// The metadata import completed successfully.
    case succeeded // = 2

    /// The metadata import is being updated.
    case updating // = 3

    /// The metadata import failed, and attempted metadata changes were rolled
    /// back.
    case failed // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .succeeded
      case 3: self = .updating
      case 4: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .succeeded: return 2
      case .updating: return 3
      case .failed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A specification of the location of and metadata about a database dump from
  /// a relational database management system.
  public struct DatabaseDump {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The type of the database.
    public var databaseType: Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump.DatabaseType = .unspecified

    /// A Cloud Storage object URI that specifies the source from which to
    /// import metadata. It must begin with `gs://`.
    public var gcsUri: String = String()

    /// The name of the source database.
    public var sourceDatabase: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of the database.
    public enum DatabaseType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The type of the source database is unknown.
      case unspecified // = 0

      /// The type of the source database is MySQL.
      case mysql // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .mysql
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .mysql: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Metastore_V1alpha_MetadataImport.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Metastore_V1alpha_MetadataImport.State] = [
    .unspecified,
    .running,
    .succeeded,
    .updating,
    .failed,
  ]
}

extension Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump.DatabaseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump.DatabaseType] = [
    .unspecified,
    .mysql,
  ]
}

#endif  // swift(>=4.2)

/// Request message for [DataprocMetastore.ListServices][google.cloud.metastore.v1alpha.DataprocMetastore.ListServices].
public struct Google_Cloud_Metastore_V1alpha_ListServicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the location of metastore services to
  /// list, in the following form:
  ///
  /// "projects/{project_id}/locations/{location_id}".
  public var parent: String = String()

  /// Optional. The maximum number of services to return. The response may contain less
  /// than the maximum number. If unspecified, no more than 500 services are
  /// returned. The maximum value is 1000; values above 1000 are changed to 1000.
  public var pageSize: Int32 = 0

  /// Optional. A page token, received from a previous [DataprocMetastore.ListServices][google.cloud.metastore.v1alpha.DataprocMetastore.ListServices]
  /// call. Provide this token to retrieve the subsequent page.
  ///
  /// To retrieve the first page, supply an empty page token.
  ///
  /// When paginating, other parameters provided to
  /// [DataprocMetastore.ListServices][google.cloud.metastore.v1alpha.DataprocMetastore.ListServices] must match the call that provided the
  /// page token.
  public var pageToken: String = String()

  /// Optional. The filter to apply to list results.
  public var filter: String = String()

  /// Optional. Specify the ordering of results as described in
  /// [Sorting Order](/apis/design/design_patterns#sorting_order). If not
  /// specified, the results will be sorted in the default order.
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [DataprocMetastore.ListServices][google.cloud.metastore.v1alpha.DataprocMetastore.ListServices].
public struct Google_Cloud_Metastore_V1alpha_ListServicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The services in the specified location.
  public var services: [Google_Cloud_Metastore_V1alpha_Service] = []

  /// A token that can be sent as `page_token` to retrieve the next page. If this
  /// field is omitted, there are no subsequent pages.
  public var nextPageToken: String = String()

  /// Locations that could not be reached.
  public var unreachable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [DataprocMetastore.GetService][google.cloud.metastore.v1alpha.DataprocMetastore.GetService].
public struct Google_Cloud_Metastore_V1alpha_GetServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the metastore service to retrieve, in the
  /// following form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}".
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [DataprocMetastore.CreateService][google.cloud.metastore.v1alpha.DataprocMetastore.CreateService].
public struct Google_Cloud_Metastore_V1alpha_CreateServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the location in which to create a metastore
  /// service, in the following form:
  ///
  /// "projects/{project_id}/locations/{location_id}".
  public var parent: String = String()

  /// Required. The ID of the metastore service, which is used as the final
  /// component of the metastore service's name.
  ///
  /// This value must be between 1 and 64 characters long, begin with a
  /// letter, end with a letter or number, and consist of alpha-numeric
  /// ASCII characters or hyphens.
  public var serviceID: String = String()

  /// Required. The Metastore service to create. The `name` field is
  /// ignored. The ID of the created metastore service must be provided in
  /// the request's `service_id` field.
  public var service: Google_Cloud_Metastore_V1alpha_Service {
    get {return _service ?? Google_Cloud_Metastore_V1alpha_Service()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {self._service = nil}

  /// Optional. A request ID. Specify a unique request ID to allow the server to ignore the
  /// request if it has completed. The server will ignore subsequent requests
  /// that provide a duplicate request ID for at least 60 minutes after the first
  /// request.
  ///
  /// For example, if an initial request times out, followed by another request
  /// with the same request ID, the server ignores the second request to prevent
  /// the creation of duplicate commitments.
  ///
  /// The request ID must be a valid
  /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)
  /// A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _service: Google_Cloud_Metastore_V1alpha_Service? = nil
}

/// Request message for [DataprocMetastore.UpdateService][google.cloud.metastore.v1alpha.DataprocMetastore.UpdateService].
public struct Google_Cloud_Metastore_V1alpha_UpdateServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A field mask used to specify the fields to be overwritten in the
  /// metastore service resource by the update.
  /// Fields specified in the `update_mask` are relative to the resource (not
  /// to the full request). A field is overwritten if it is in the mask.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// Required. The metastore service to update. The server only merges fields
  /// in the service if they are specified in `update_mask`.
  ///
  /// The metastore service's `name` field is used to identify the metastore
  /// service to be updated.
  public var service: Google_Cloud_Metastore_V1alpha_Service {
    get {return _service ?? Google_Cloud_Metastore_V1alpha_Service()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  public var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  public mutating func clearService() {self._service = nil}

  /// Optional. A request ID. Specify a unique request ID to allow the server to ignore the
  /// request if it has completed. The server will ignore subsequent requests
  /// that provide a duplicate request ID for at least 60 minutes after the first
  /// request.
  ///
  /// For example, if an initial request times out, followed by another request
  /// with the same request ID, the server ignores the second request to prevent
  /// the creation of duplicate commitments.
  ///
  /// The request ID must be a valid
  /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)
  /// A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _service: Google_Cloud_Metastore_V1alpha_Service? = nil
}

/// Request message for [DataprocMetastore.DeleteService][google.cloud.metastore.v1alpha.DataprocMetastore.DeleteService].
public struct Google_Cloud_Metastore_V1alpha_DeleteServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the metastore service to delete, in the
  /// following form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}".
  public var name: String = String()

  /// Optional. A request ID. Specify a unique request ID to allow the server to ignore the
  /// request if it has completed. The server will ignore subsequent requests
  /// that provide a duplicate request ID for at least 60 minutes after the first
  /// request.
  ///
  /// For example, if an initial request times out, followed by another request
  /// with the same request ID, the server ignores the second request to prevent
  /// the creation of duplicate commitments.
  ///
  /// The request ID must be a valid
  /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)
  /// A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [DataprocMetastore.ListMetadataImports][google.cloud.metastore.v1alpha.DataprocMetastore.ListMetadataImports].
public struct Google_Cloud_Metastore_V1alpha_ListMetadataImportsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the service whose metadata imports to
  /// list, in the following form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}/metadataImports".
  public var parent: String = String()

  /// Optional. The maximum number of imports to return. The response may contain less
  /// than the maximum number. If unspecified, no more than 500 imports are
  /// returned. The maximum value is 1000; values above 1000 are changed to 1000.
  public var pageSize: Int32 = 0

  /// Optional. A page token, received from a previous [DataprocMetastore.ListServices][google.cloud.metastore.v1alpha.DataprocMetastore.ListServices]
  /// call. Provide this token to retrieve the subsequent page.
  ///
  /// To retrieve the first page, supply an empty page token.
  ///
  /// When paginating, other parameters provided to
  /// [DataprocMetastore.ListServices][google.cloud.metastore.v1alpha.DataprocMetastore.ListServices] must match the call that provided the
  /// page token.
  public var pageToken: String = String()

  /// Optional. The filter to apply to list results.
  public var filter: String = String()

  /// Optional. Specify the ordering of results as described in
  /// [Sorting Order](/apis/design/design_patterns#sorting_order). If not
  /// specified, the results will be sorted in the default order.
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [DataprocMetastore.ListMetadataImports][google.cloud.metastore.v1alpha.DataprocMetastore.ListMetadataImports].
public struct Google_Cloud_Metastore_V1alpha_ListMetadataImportsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The imports in the specified service.
  public var metadataImports: [Google_Cloud_Metastore_V1alpha_MetadataImport] = []

  /// A token that can be sent as `page_token` to retrieve the next page. If this
  /// field is omitted, there are no subsequent pages.
  public var nextPageToken: String = String()

  /// Locations that could not be reached.
  public var unreachable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [DataprocMetastore.GetMetadataImport][google.cloud.metastore.v1alpha.DataprocMetastore.GetMetadataImport].
public struct Google_Cloud_Metastore_V1alpha_GetMetadataImportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the metadata import to retrieve, in the
  /// following form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}/metadataImports/{import_id}".
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [DataprocMetastore.CreateMetadataImport][google.cloud.metastore.v1alpha.DataprocMetastore.CreateMetadataImport].
public struct Google_Cloud_Metastore_V1alpha_CreateMetadataImportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative resource name of the service in which to create a metastore
  /// import, in the following form:
  ///
  /// "projects/{project_id}/locations/{location_id}/services/{service_id}"
  public var parent: String = String()

  /// Required. The ID of the metadata import, which is used as the final component of the
  /// metadata import's name.
  ///
  /// This value must be between 1 and 64 characters long, begin with a letter,
  /// end with a letter or number, and consist of alpha-numeric ASCII characters
  /// or hyphens.
  public var metadataImportID: String = String()

  /// Required. The metadata import to create. The `name` field is ignored. The ID of the
  /// created metadata import must be provided in the request's
  /// `metadata_import_id` field.
  public var metadataImport: Google_Cloud_Metastore_V1alpha_MetadataImport {
    get {return _metadataImport ?? Google_Cloud_Metastore_V1alpha_MetadataImport()}
    set {_metadataImport = newValue}
  }
  /// Returns true if `metadataImport` has been explicitly set.
  public var hasMetadataImport: Bool {return self._metadataImport != nil}
  /// Clears the value of `metadataImport`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataImport() {self._metadataImport = nil}

  /// Optional. A request ID. Specify a unique request ID to allow the server to ignore the
  /// request if it has completed. The server will ignore subsequent requests
  /// that provide a duplicate request ID for at least 60 minutes after the first
  /// request.
  ///
  /// For example, if an initial request times out, followed by another request
  /// with the same request ID, the server ignores the second request to prevent
  /// the creation of duplicate commitments.
  ///
  /// The request ID must be a valid
  /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)
  /// A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metadataImport: Google_Cloud_Metastore_V1alpha_MetadataImport? = nil
}

/// Request message for [DataprocMetastore.UpdateMetadataImport][google.cloud.metastore.v1alpha.DataprocMetastore.UpdateMetadataImport].
public struct Google_Cloud_Metastore_V1alpha_UpdateMetadataImportRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A field mask used to specify the fields to be overwritten in the
  /// metadata import resource by the update.
  /// Fields specified in the `update_mask` are relative to the resource (not
  /// to the full request). A field is overwritten if it is in the mask.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// Required. The metadata import to update. The server only merges fields
  /// in the import if they are specified in `update_mask`.
  ///
  /// The metadata import's `name` field is used to identify the metastore
  /// import to be updated.
  public var metadataImport: Google_Cloud_Metastore_V1alpha_MetadataImport {
    get {return _metadataImport ?? Google_Cloud_Metastore_V1alpha_MetadataImport()}
    set {_metadataImport = newValue}
  }
  /// Returns true if `metadataImport` has been explicitly set.
  public var hasMetadataImport: Bool {return self._metadataImport != nil}
  /// Clears the value of `metadataImport`. Subsequent reads from it will return its default value.
  public mutating func clearMetadataImport() {self._metadataImport = nil}

  /// Optional. A request ID. Specify a unique request ID to allow the server to ignore the
  /// request if it has completed. The server will ignore subsequent requests
  /// that provide a duplicate request ID for at least 60 minutes after the first
  /// request.
  ///
  /// For example, if an initial request times out, followed by another request
  /// with the same request ID, the server ignores the second request to prevent
  /// the creation of duplicate commitments.
  ///
  /// The request ID must be a valid
  /// [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier#Format)
  /// A zero UUID (00000000-0000-0000-0000-000000000000) is not supported.
  public var requestID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _metadataImport: Google_Cloud_Metastore_V1alpha_MetadataImport? = nil
}

/// Represents the metadata of a long-running operation.
public struct Google_Cloud_Metastore_V1alpha_OperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The time the operation was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time the operation finished running.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Output only. Server-defined resource path for the target of the operation.
  public var target: String = String()

  /// Output only. Name of the verb executed by the operation.
  public var verb: String = String()

  /// Output only. Human-readable status of the operation, if any.
  public var statusMessage: String = String()

  /// Output only. Identifies whether the caller has requested cancellation
  /// of the operation. Operations that have successfully been cancelled
  /// have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
  /// corresponding to `Code.CANCELLED`.
  public var requestedCancellation: Bool = false

  /// Output only. API version used to start the operation.
  public var apiVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata about the service in a location.
public struct Google_Cloud_Metastore_V1alpha_LocationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The versions of Hive Metastore that can be used when creating a new
  /// metastore service in this location. The server guarantees that exactly one
  /// `HiveMetastoreVersion` in the list will set `is_default`.
  public var supportedHiveMetastoreVersions: [Google_Cloud_Metastore_V1alpha_LocationMetadata.HiveMetastoreVersion] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A specification of a supported version of the Hive Metastore software.
  public struct HiveMetastoreVersion {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The semantic version of the Hive Metastore software.
    public var version: String = String()

    /// Whether `version` will be chosen by the server if a metastore service is
    /// created with a `HiveMetastoreConfig` that omits the `version`.
    public var isDefault: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.metastore.v1alpha"

extension Google_Cloud_Metastore_V1alpha_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Service"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "update_time"),
    4: .same(proto: "labels"),
    5: .standard(proto: "hive_metastore_config"),
    7: .same(proto: "network"),
    8: .standard(proto: "endpoint_uri"),
    9: .same(proto: "port"),
    10: .same(proto: "state"),
    11: .standard(proto: "state_message"),
    12: .standard(proto: "artifact_gcs_uri"),
    13: .same(proto: "tier"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _labels: Dictionary<String,String> = [:]
    var _metastoreConfig: Google_Cloud_Metastore_V1alpha_Service.OneOf_MetastoreConfig?
    var _network: String = String()
    var _endpointUri: String = String()
    var _port: Int32 = 0
    var _state: Google_Cloud_Metastore_V1alpha_Service.State = .unspecified
    var _stateMessage: String = String()
    var _artifactGcsUri: String = String()
    var _tier: Google_Cloud_Metastore_V1alpha_Service.Tier = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _createTime = source._createTime
      _updateTime = source._updateTime
      _labels = source._labels
      _metastoreConfig = source._metastoreConfig
      _network = source._network
      _endpointUri = source._endpointUri
      _port = source._port
      _state = source._state
      _stateMessage = source._stateMessage
      _artifactGcsUri = source._artifactGcsUri
      _tier = source._tier
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 5: try {
          var v: Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig?
          if let current = _storage._metastoreConfig {
            try decoder.handleConflictingOneOf()
            if case .hiveMetastoreConfig(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._metastoreConfig = .hiveMetastoreConfig(v)}
        }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._endpointUri) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._port) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._stateMessage) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._artifactGcsUri) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._tier) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 4)
      }
      if case .hiveMetastoreConfig(let v)? = _storage._metastoreConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 7)
      }
      if !_storage._endpointUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endpointUri, fieldNumber: 8)
      }
      if _storage._port != 0 {
        try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 9)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 10)
      }
      if !_storage._stateMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateMessage, fieldNumber: 11)
      }
      if !_storage._artifactGcsUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._artifactGcsUri, fieldNumber: 12)
      }
      if _storage._tier != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tier, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_Service, rhs: Google_Cloud_Metastore_V1alpha_Service) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._metastoreConfig != rhs_storage._metastoreConfig {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._endpointUri != rhs_storage._endpointUri {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._stateMessage != rhs_storage._stateMessage {return false}
        if _storage._artifactGcsUri != rhs_storage._artifactGcsUri {return false}
        if _storage._tier != rhs_storage._tier {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_Service.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "SUSPENDING"),
    4: .same(proto: "SUSPENDED"),
    5: .same(proto: "UPDATING"),
    6: .same(proto: "DELETING"),
    7: .same(proto: "ERROR"),
  ]
}

extension Google_Cloud_Metastore_V1alpha_Service.Tier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIER_UNSPECIFIED"),
    3: .same(proto: "ENTERPRISE"),
  ]
}

extension Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HiveMetastoreConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "config_overrides"),
    3: .standard(proto: "kerberos_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.configOverrides) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._kerberosConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.configOverrides.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.configOverrides, fieldNumber: 2)
    }
    if let v = self._kerberosConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig, rhs: Google_Cloud_Metastore_V1alpha_HiveMetastoreConfig) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.configOverrides != rhs.configOverrides {return false}
    if lhs._kerberosConfig != rhs._kerberosConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_KerberosConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KerberosConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keytab"),
    2: .same(proto: "principal"),
    3: .standard(proto: "krb5_config_gcs_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._keytab) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.principal) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.krb5ConfigGcsUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._keytab {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.principal.isEmpty {
      try visitor.visitSingularStringField(value: self.principal, fieldNumber: 2)
    }
    if !self.krb5ConfigGcsUri.isEmpty {
      try visitor.visitSingularStringField(value: self.krb5ConfigGcsUri, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_KerberosConfig, rhs: Google_Cloud_Metastore_V1alpha_KerberosConfig) -> Bool {
    if lhs._keytab != rhs._keytab {return false}
    if lhs.principal != rhs.principal {return false}
    if lhs.krb5ConfigGcsUri != rhs.krb5ConfigGcsUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_Secret: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Secret"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "cloud_secret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .cloudSecret(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .cloudSecret(let v)? = self.value {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_Secret, rhs: Google_Cloud_Metastore_V1alpha_Secret) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_MetadataImport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MetadataImport"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "update_time"),
    5: .same(proto: "state"),
    6: .standard(proto: "database_dump"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 6: try {
        var v: Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump?
        if let current = self.metadata {
          try decoder.handleConflictingOneOf()
          if case .databaseDump(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.metadata = .databaseDump(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 5)
    }
    if case .databaseDump(let v)? = self.metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_MetadataImport, rhs: Google_Cloud_Metastore_V1alpha_MetadataImport) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_MetadataImport.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "SUCCEEDED"),
    3: .same(proto: "UPDATING"),
    4: .same(proto: "FAILED"),
  ]
}

extension Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Metastore_V1alpha_MetadataImport.protoMessageName + ".DatabaseDump"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "database_type"),
    2: .standard(proto: "gcs_uri"),
    3: .standard(proto: "source_database"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.databaseType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gcsUri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceDatabase) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.databaseType != .unspecified {
      try visitor.visitSingularEnumField(value: self.databaseType, fieldNumber: 1)
    }
    if !self.gcsUri.isEmpty {
      try visitor.visitSingularStringField(value: self.gcsUri, fieldNumber: 2)
    }
    if !self.sourceDatabase.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceDatabase, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump, rhs: Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump) -> Bool {
    if lhs.databaseType != rhs.databaseType {return false}
    if lhs.gcsUri != rhs.gcsUri {return false}
    if lhs.sourceDatabase != rhs.sourceDatabase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_MetadataImport.DatabaseDump.DatabaseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATABASE_TYPE_UNSPECIFIED"),
    1: .same(proto: "MYSQL"),
  ]
}

extension Google_Cloud_Metastore_V1alpha_ListServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListServicesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_ListServicesRequest, rhs: Google_Cloud_Metastore_V1alpha_ListServicesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_ListServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListServicesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services"),
    2: .standard(proto: "next_page_token"),
    3: .same(proto: "unreachable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_ListServicesResponse, rhs: Google_Cloud_Metastore_V1alpha_ListServicesResponse) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_GetServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_GetServiceRequest, rhs: Google_Cloud_Metastore_V1alpha_GetServiceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_CreateServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "service_id"),
    3: .same(proto: "service"),
    4: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.serviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceID, fieldNumber: 2)
    }
    if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_CreateServiceRequest, rhs: Google_Cloud_Metastore_V1alpha_CreateServiceRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.serviceID != rhs.serviceID {return false}
    if lhs._service != rhs._service {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_UpdateServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_mask"),
    2: .same(proto: "service"),
    3: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_UpdateServiceRequest, rhs: Google_Cloud_Metastore_V1alpha_UpdateServiceRequest) -> Bool {
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._service != rhs._service {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_DeleteServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_DeleteServiceRequest, rhs: Google_Cloud_Metastore_V1alpha_DeleteServiceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_ListMetadataImportsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMetadataImportsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_ListMetadataImportsRequest, rhs: Google_Cloud_Metastore_V1alpha_ListMetadataImportsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_ListMetadataImportsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMetadataImportsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metadata_imports"),
    2: .standard(proto: "next_page_token"),
    3: .same(proto: "unreachable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.metadataImports) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadataImports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadataImports, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_ListMetadataImportsResponse, rhs: Google_Cloud_Metastore_V1alpha_ListMetadataImportsResponse) -> Bool {
    if lhs.metadataImports != rhs.metadataImports {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_GetMetadataImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetMetadataImportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_GetMetadataImportRequest, rhs: Google_Cloud_Metastore_V1alpha_GetMetadataImportRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_CreateMetadataImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateMetadataImportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "metadata_import_id"),
    3: .standard(proto: "metadata_import"),
    4: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.metadataImportID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadataImport) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.metadataImportID.isEmpty {
      try visitor.visitSingularStringField(value: self.metadataImportID, fieldNumber: 2)
    }
    if let v = self._metadataImport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_CreateMetadataImportRequest, rhs: Google_Cloud_Metastore_V1alpha_CreateMetadataImportRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.metadataImportID != rhs.metadataImportID {return false}
    if lhs._metadataImport != rhs._metadataImport {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_UpdateMetadataImportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateMetadataImportRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_mask"),
    2: .standard(proto: "metadata_import"),
    3: .standard(proto: "request_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadataImport) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._metadataImport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_UpdateMetadataImportRequest, rhs: Google_Cloud_Metastore_V1alpha_UpdateMetadataImportRequest) -> Bool {
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._metadataImport != rhs._metadataImport {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_OperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "target"),
    4: .same(proto: "verb"),
    5: .standard(proto: "status_message"),
    6: .standard(proto: "requested_cancellation"),
    7: .standard(proto: "api_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.verb) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusMessage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.requestedCancellation) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    if !self.verb.isEmpty {
      try visitor.visitSingularStringField(value: self.verb, fieldNumber: 4)
    }
    if !self.statusMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMessage, fieldNumber: 5)
    }
    if self.requestedCancellation != false {
      try visitor.visitSingularBoolField(value: self.requestedCancellation, fieldNumber: 6)
    }
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_OperationMetadata, rhs: Google_Cloud_Metastore_V1alpha_OperationMetadata) -> Bool {
    if lhs._createTime != rhs._createTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.target != rhs.target {return false}
    if lhs.verb != rhs.verb {return false}
    if lhs.statusMessage != rhs.statusMessage {return false}
    if lhs.requestedCancellation != rhs.requestedCancellation {return false}
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_LocationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supported_hive_metastore_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.supportedHiveMetastoreVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.supportedHiveMetastoreVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.supportedHiveMetastoreVersions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_LocationMetadata, rhs: Google_Cloud_Metastore_V1alpha_LocationMetadata) -> Bool {
    if lhs.supportedHiveMetastoreVersions != rhs.supportedHiveMetastoreVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Metastore_V1alpha_LocationMetadata.HiveMetastoreVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Metastore_V1alpha_LocationMetadata.protoMessageName + ".HiveMetastoreVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "is_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isDefault) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.isDefault != false {
      try visitor.visitSingularBoolField(value: self.isDefault, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Metastore_V1alpha_LocationMetadata.HiveMetastoreVersion, rhs: Google_Cloud_Metastore_V1alpha_LocationMetadata.HiveMetastoreVersion) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.isDefault != rhs.isDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

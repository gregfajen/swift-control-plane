// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/policytroubleshooter/v1/explanations.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Whether a member has a permission for a resource.
public enum Google_Cloud_Policytroubleshooter_V1_AccessState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Reserved for future use.
  case unspecified // = 0

  /// The member has the permission.
  case granted // = 1

  /// The member does not have the permission.
  case notGranted // = 2

  /// The member has the permission only if a condition expression evaluates to
  /// `true`.
  case unknownConditional // = 3

  /// The sender of the request does not have access to all of the policies that
  /// Policy Troubleshooter needs to evaluate.
  case unknownInfoDenied // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .granted
    case 2: self = .notGranted
    case 3: self = .unknownConditional
    case 4: self = .unknownInfoDenied
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .granted: return 1
    case .notGranted: return 2
    case .unknownConditional: return 3
    case .unknownInfoDenied: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Policytroubleshooter_V1_AccessState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Policytroubleshooter_V1_AccessState] = [
    .unspecified,
    .granted,
    .notGranted,
    .unknownConditional,
    .unknownInfoDenied,
  ]
}

#endif  // swift(>=4.2)

/// The extent to which a single data point contributes to an overall
/// determination.
public enum Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Reserved for future use.
  case unspecified // = 0

  /// The data point has a limited effect on the result. Changing the data point
  /// is unlikely to affect the overall determination.
  case normal // = 1

  /// The data point has a strong effect on the result. Changing the data point
  /// is likely to affect the overall determination.
  case high // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .normal
    case 2: self = .high
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .normal: return 1
    case .high: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance] = [
    .unspecified,
    .normal,
    .high,
  ]
}

#endif  // swift(>=4.2)

/// Information about the member, resource, and permission to check.
public struct Google_Cloud_Policytroubleshooter_V1_AccessTuple {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The member, or principal, whose access you want to check, in the form of
  /// the email address that represents that member. For example,
  /// `alice@example.com` or
  /// `my-service-account@my-project.iam.gserviceaccount.com`.
  ///
  /// The member must be a Google Account or a service account. Other types of
  /// members are not supported.
  public var principal: String = String()

  /// Required. The full resource name that identifies the resource. For example,
  /// `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
  ///
  /// For examples of full resource names for Google Cloud services, see
  /// https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
  public var fullResourceName: String = String()

  /// Required. The IAM permission to check for the specified member and resource.
  ///
  /// For a complete list of IAM permissions, see
  /// https://cloud.google.com/iam/help/permissions/reference.
  ///
  /// For a complete list of predefined IAM roles and the permissions in each
  /// role, see https://cloud.google.com/iam/help/roles/reference.
  public var permission: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Details about how a specific IAM [Policy][google.iam.v1.Policy] contributed
/// to the access check.
public struct Google_Cloud_Policytroubleshooter_V1_ExplainedPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether _this policy_ provides the specified permission to the
  /// specified member for the specified resource.
  ///
  /// This field does _not_ indicate whether the member actually has the
  /// permission for the resource. There might be another policy that overrides
  /// this policy. To determine whether the member actually has the permission,
  /// use the `access` field in the
  /// [TroubleshootIamPolicyResponse][IamChecker.TroubleshootIamPolicyResponse].
  public var access: Google_Cloud_Policytroubleshooter_V1_AccessState = .unspecified

  /// The full resource name that identifies the resource. For example,
  /// `//compute.googleapis.com/projects/my-project/zones/us-central1-a/instances/my-instance`.
  ///
  /// If the sender of the request does not have access to the policy, this field
  /// is omitted.
  ///
  /// For examples of full resource names for Google Cloud services, see
  /// https://cloud.google.com/iam/help/troubleshooter/full-resource-names.
  public var fullResourceName: String = String()

  /// The IAM policy attached to the resource.
  ///
  /// If the sender of the request does not have access to the policy, this field
  /// is empty.
  public var policy: Google_Iam_V1_Policy {
    get {return _policy ?? Google_Iam_V1_Policy()}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {self._policy = nil}

  /// Details about how each binding in the policy affects the member's ability,
  /// or inability, to use the permission for the resource.
  ///
  /// If the sender of the request does not have access to the policy, this field
  /// is omitted.
  public var bindingExplanations: [Google_Cloud_Policytroubleshooter_V1_BindingExplanation] = []

  /// The relevance of this policy to the overall determination in the
  /// [TroubleshootIamPolicyResponse][IamChecker.TroubleshootIamPolicyResponse].
  ///
  /// If the sender of the request does not have access to the policy, this field
  /// is omitted.
  public var relevance: Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _policy: Google_Iam_V1_Policy? = nil
}

/// Details about how a binding in a policy affects a member's ability to use a
/// permission.
public struct Google_Cloud_Policytroubleshooter_V1_BindingExplanation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Indicates whether _this binding_ provides the specified permission to the
  /// specified member for the specified resource.
  ///
  /// This field does _not_ indicate whether the member actually has the
  /// permission for the resource. There might be another binding that overrides
  /// this binding. To determine whether the member actually has the permission,
  /// use the `access` field in the
  /// [TroubleshootIamPolicyResponse][IamChecker.TroubleshootIamPolicyResponse].
  public var access: Google_Cloud_Policytroubleshooter_V1_AccessState = .unspecified

  /// The role that this binding grants. For example,
  /// `roles/compute.serviceAgent`.
  ///
  /// For a complete list of predefined IAM roles, as well as the permissions in
  /// each role, see https://cloud.google.com/iam/help/roles/reference.
  public var role: String = String()

  /// Indicates whether the role granted by this binding contains the specified
  /// permission.
  public var rolePermission: Google_Cloud_Policytroubleshooter_V1_BindingExplanation.RolePermission = .unspecified

  /// The relevance of the permission's existence, or nonexistence, in the role
  /// to the overall determination for the entire policy.
  public var rolePermissionRelevance: Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance = .unspecified

  /// Indicates whether each member in the binding includes the member specified
  /// in the request, either directly or indirectly. Each key identifies a member
  /// in the binding, and each value indicates whether the member in the binding
  /// includes the member in the request.
  ///
  /// For example, suppose that a binding includes the following members:
  ///
  /// * `user:alice@example.com`
  /// * `group:product-eng@example.com`
  ///
  /// You want to troubleshoot access for `user:bob@example.com`. This user is a
  /// member of the group `group:product-eng@example.com`.
  ///
  /// For the first member in the binding, the key is `user:alice@example.com`,
  /// and the `membership` field in the value is set to
  /// `MEMBERSHIP_NOT_INCLUDED`.
  ///
  /// For the second member in the binding, the key is
  /// `group:product-eng@example.com`, and the `membership` field in the value is
  /// set to `MEMBERSHIP_INCLUDED`.
  public var memberships: Dictionary<String,Google_Cloud_Policytroubleshooter_V1_BindingExplanation.AnnotatedMembership> = [:]

  /// The relevance of this binding to the overall determination for the entire
  /// policy.
  public var relevance: Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance = .unspecified

  /// A condition expression that prevents access unless the expression evaluates
  /// to `true`.
  ///
  /// To learn about IAM Conditions, see
  /// http://cloud.google.com/iam/help/conditions/overview.
  public var condition: Google_Type_Expr {
    get {return _condition ?? Google_Type_Expr()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Whether a role includes a specific permission.
  public enum RolePermission: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Reserved for future use.
    case unspecified // = 0

    /// The permission is included in the role.
    case included // = 1

    /// The permission is not included in the role.
    case notIncluded // = 2

    /// The sender of the request is not allowed to access the binding.
    case unknownInfoDenied // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .included
      case 2: self = .notIncluded
      case 3: self = .unknownInfoDenied
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .included: return 1
      case .notIncluded: return 2
      case .unknownInfoDenied: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Whether the binding includes the member.
  public enum Membership: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Reserved for future use.
    case unspecified // = 0

    /// The binding includes the member. The member can be included directly
    /// or indirectly. For example:
    ///
    /// * A member is included directly if that member is listed in the binding.
    /// * A member is included indirectly if that member is in a Google group or
    ///   G Suite domain that is listed in the binding.
    case included // = 1

    /// The binding does not include the member.
    case notIncluded // = 2

    /// The sender of the request is not allowed to access the binding.
    case unknownInfoDenied // = 3

    /// The member is an unsupported type. Only Google Accounts and service
    /// accounts are supported.
    case unknownUnsupported // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .included
      case 2: self = .notIncluded
      case 3: self = .unknownInfoDenied
      case 4: self = .unknownUnsupported
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .included: return 1
      case .notIncluded: return 2
      case .unknownInfoDenied: return 3
      case .unknownUnsupported: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Details about whether the binding includes the member.
  public struct AnnotatedMembership {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates whether the binding includes the member.
    public var membership: Google_Cloud_Policytroubleshooter_V1_BindingExplanation.Membership = .unspecified

    /// The relevance of the member's status to the overall determination for the
    /// binding.
    public var relevance: Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _condition: Google_Type_Expr? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Policytroubleshooter_V1_BindingExplanation.RolePermission: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Policytroubleshooter_V1_BindingExplanation.RolePermission] = [
    .unspecified,
    .included,
    .notIncluded,
    .unknownInfoDenied,
  ]
}

extension Google_Cloud_Policytroubleshooter_V1_BindingExplanation.Membership: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Policytroubleshooter_V1_BindingExplanation.Membership] = [
    .unspecified,
    .included,
    .notIncluded,
    .unknownInfoDenied,
    .unknownUnsupported,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.policytroubleshooter.v1"

extension Google_Cloud_Policytroubleshooter_V1_AccessState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCESS_STATE_UNSPECIFIED"),
    1: .same(proto: "GRANTED"),
    2: .same(proto: "NOT_GRANTED"),
    3: .same(proto: "UNKNOWN_CONDITIONAL"),
    4: .same(proto: "UNKNOWN_INFO_DENIED"),
  ]
}

extension Google_Cloud_Policytroubleshooter_V1_HeuristicRelevance: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEURISTIC_RELEVANCE_UNSPECIFIED"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "HIGH"),
  ]
}

extension Google_Cloud_Policytroubleshooter_V1_AccessTuple: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessTuple"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "principal"),
    2: .standard(proto: "full_resource_name"),
    3: .same(proto: "permission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.principal) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.permission) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.principal.isEmpty {
      try visitor.visitSingularStringField(value: self.principal, fieldNumber: 1)
    }
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 2)
    }
    if !self.permission.isEmpty {
      try visitor.visitSingularStringField(value: self.permission, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Policytroubleshooter_V1_AccessTuple, rhs: Google_Cloud_Policytroubleshooter_V1_AccessTuple) -> Bool {
    if lhs.principal != rhs.principal {return false}
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Policytroubleshooter_V1_ExplainedPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplainedPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "access"),
    2: .standard(proto: "full_resource_name"),
    3: .same(proto: "policy"),
    4: .standard(proto: "binding_explanations"),
    5: .same(proto: "relevance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.access) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._policy) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.bindingExplanations) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.relevance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.access != .unspecified {
      try visitor.visitSingularEnumField(value: self.access, fieldNumber: 1)
    }
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 2)
    }
    if let v = self._policy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.bindingExplanations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bindingExplanations, fieldNumber: 4)
    }
    if self.relevance != .unspecified {
      try visitor.visitSingularEnumField(value: self.relevance, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Policytroubleshooter_V1_ExplainedPolicy, rhs: Google_Cloud_Policytroubleshooter_V1_ExplainedPolicy) -> Bool {
    if lhs.access != rhs.access {return false}
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs.bindingExplanations != rhs.bindingExplanations {return false}
    if lhs.relevance != rhs.relevance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Policytroubleshooter_V1_BindingExplanation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindingExplanation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "access"),
    2: .same(proto: "role"),
    3: .standard(proto: "role_permission"),
    4: .standard(proto: "role_permission_relevance"),
    5: .same(proto: "memberships"),
    6: .same(proto: "relevance"),
    7: .same(proto: "condition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.access) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.role) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rolePermission) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.rolePermissionRelevance) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Policytroubleshooter_V1_BindingExplanation.AnnotatedMembership>.self, value: &self.memberships) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.relevance) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.access != .unspecified {
      try visitor.visitSingularEnumField(value: self.access, fieldNumber: 1)
    }
    if !self.role.isEmpty {
      try visitor.visitSingularStringField(value: self.role, fieldNumber: 2)
    }
    if self.rolePermission != .unspecified {
      try visitor.visitSingularEnumField(value: self.rolePermission, fieldNumber: 3)
    }
    if self.rolePermissionRelevance != .unspecified {
      try visitor.visitSingularEnumField(value: self.rolePermissionRelevance, fieldNumber: 4)
    }
    if !self.memberships.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Policytroubleshooter_V1_BindingExplanation.AnnotatedMembership>.self, value: self.memberships, fieldNumber: 5)
    }
    if self.relevance != .unspecified {
      try visitor.visitSingularEnumField(value: self.relevance, fieldNumber: 6)
    }
    if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Policytroubleshooter_V1_BindingExplanation, rhs: Google_Cloud_Policytroubleshooter_V1_BindingExplanation) -> Bool {
    if lhs.access != rhs.access {return false}
    if lhs.role != rhs.role {return false}
    if lhs.rolePermission != rhs.rolePermission {return false}
    if lhs.rolePermissionRelevance != rhs.rolePermissionRelevance {return false}
    if lhs.memberships != rhs.memberships {return false}
    if lhs.relevance != rhs.relevance {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Policytroubleshooter_V1_BindingExplanation.RolePermission: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROLE_PERMISSION_UNSPECIFIED"),
    1: .same(proto: "ROLE_PERMISSION_INCLUDED"),
    2: .same(proto: "ROLE_PERMISSION_NOT_INCLUDED"),
    3: .same(proto: "ROLE_PERMISSION_UNKNOWN_INFO_DENIED"),
  ]
}

extension Google_Cloud_Policytroubleshooter_V1_BindingExplanation.Membership: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBERSHIP_UNSPECIFIED"),
    1: .same(proto: "MEMBERSHIP_INCLUDED"),
    2: .same(proto: "MEMBERSHIP_NOT_INCLUDED"),
    3: .same(proto: "MEMBERSHIP_UNKNOWN_INFO_DENIED"),
    4: .same(proto: "MEMBERSHIP_UNKNOWN_UNSUPPORTED"),
  ]
}

extension Google_Cloud_Policytroubleshooter_V1_BindingExplanation.AnnotatedMembership: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Policytroubleshooter_V1_BindingExplanation.protoMessageName + ".AnnotatedMembership"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "membership"),
    2: .same(proto: "relevance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.membership) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.relevance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.membership != .unspecified {
      try visitor.visitSingularEnumField(value: self.membership, fieldNumber: 1)
    }
    if self.relevance != .unspecified {
      try visitor.visitSingularEnumField(value: self.relevance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Policytroubleshooter_V1_BindingExplanation.AnnotatedMembership, rhs: Google_Cloud_Policytroubleshooter_V1_BindingExplanation.AnnotatedMembership) -> Bool {
    if lhs.membership != rhs.membership {return false}
    if lhs.relevance != rhs.relevance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

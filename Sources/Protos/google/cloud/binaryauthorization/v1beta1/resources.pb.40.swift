// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/binaryauthorization/v1beta1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A [policy][google.cloud.binaryauthorization.v1beta1.Policy] for container image binary authorization.
public struct Google_Cloud_Binaryauthorization_V1beta1_Policy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name, in the format `projects/*/policy`. There is
  /// at most one policy per project.
  public var name: String = String()

  /// Optional. A descriptive comment.
  public var description_p: String = String()

  /// Optional. Controls the evaluation of a Google-maintained global admission
  /// policy for common system-level images. Images not covered by the global
  /// policy will be subject to the project admission policy. This setting
  /// has no effect when specified inside a global admission policy.
  public var globalPolicyEvaluationMode: Google_Cloud_Binaryauthorization_V1beta1_Policy.GlobalPolicyEvaluationMode = .unspecified

  /// Optional. Admission policy whitelisting. A matching admission request will
  /// always be permitted. This feature is typically used to exclude Google or
  /// third-party infrastructure images from Binary Authorization policies.
  public var admissionWhitelistPatterns: [Google_Cloud_Binaryauthorization_V1beta1_AdmissionWhitelistPattern] = []

  /// Optional. Per-cluster admission rules. Cluster spec format:
  /// `location.clusterId`. There can be at most one admission rule per cluster
  /// spec.
  /// A `location` is either a compute zone (e.g. us-central1-a) or a region
  /// (e.g. us-central1).
  /// For `clusterId` syntax restrictions see
  /// https://cloud.google.com/container-engine/reference/rest/v1/projects.zones.clusters.
  public var clusterAdmissionRules: Dictionary<String,Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule> = [:]

  /// Required. Default admission rule for a cluster without a per-cluster, per-
  /// kubernetes-service-account, or per-istio-service-identity admission rule.
  public var defaultAdmissionRule: Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule {
    get {return _defaultAdmissionRule ?? Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule()}
    set {_defaultAdmissionRule = newValue}
  }
  /// Returns true if `defaultAdmissionRule` has been explicitly set.
  public var hasDefaultAdmissionRule: Bool {return self._defaultAdmissionRule != nil}
  /// Clears the value of `defaultAdmissionRule`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultAdmissionRule() {self._defaultAdmissionRule = nil}

  /// Output only. Time when the policy was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum GlobalPolicyEvaluationMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified: DISABLE is assumed.
    case unspecified // = 0

    /// Enables global policy evaluation.
    case enable // = 1

    /// Disables global policy evaluation.
    case disable // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enable
      case 2: self = .disable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enable: return 1
      case .disable: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _defaultAdmissionRule: Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Binaryauthorization_V1beta1_Policy.GlobalPolicyEvaluationMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Binaryauthorization_V1beta1_Policy.GlobalPolicyEvaluationMode] = [
    .unspecified,
    .enable,
    .disable,
  ]
}

#endif  // swift(>=4.2)

/// An [admission whitelist pattern][google.cloud.binaryauthorization.v1beta1.AdmissionWhitelistPattern] exempts images
/// from checks by [admission rules][google.cloud.binaryauthorization.v1beta1.AdmissionRule].
public struct Google_Cloud_Binaryauthorization_V1beta1_AdmissionWhitelistPattern {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An image name pattern to whitelist, in the form `registry/path/to/image`.
  /// This supports a trailing `*` as a wildcard, but this is allowed only in
  /// text after the `registry/` part.
  public var namePattern: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An [admission rule][google.cloud.binaryauthorization.v1beta1.AdmissionRule] specifies either that all container images
/// used in a pod creation request must be attested to by one or more
/// [attestors][google.cloud.binaryauthorization.v1beta1.Attestor], that all pod creations will be allowed, or that all
/// pod creations will be denied.
///
/// Images matching an [admission whitelist pattern][google.cloud.binaryauthorization.v1beta1.AdmissionWhitelistPattern]
/// are exempted from admission rules and will never block a pod creation.
public struct Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. How this admission rule will be evaluated.
  public var evaluationMode: Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EvaluationMode = .unspecified

  /// Optional. The resource names of the attestors that must attest to
  /// a container image, in the format `projects/*/attestors/*`. Each
  /// attestor must exist before a policy can reference it.  To add an attestor
  /// to a policy the principal issuing the policy change request must be able
  /// to read the attestor resource.
  ///
  /// Note: this field must be non-empty when the evaluation_mode field specifies
  /// REQUIRE_ATTESTATION, otherwise it must be empty.
  public var requireAttestationsBy: [String] = []

  /// Required. The action when a pod creation is denied by the admission rule.
  public var enforcementMode: Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EnforcementMode = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum EvaluationMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not use.
    case unspecified // = 0

    /// This rule allows all all pod creations.
    case alwaysAllow // = 1

    /// This rule allows a pod creation if all the attestors listed in
    /// 'require_attestations_by' have valid attestations for all of the
    /// images in the pod spec.
    case requireAttestation // = 2

    /// This rule denies all pod creations.
    case alwaysDeny // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .alwaysAllow
      case 2: self = .requireAttestation
      case 3: self = .alwaysDeny
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .alwaysAllow: return 1
      case .requireAttestation: return 2
      case .alwaysDeny: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Defines the possible actions when a pod creation is denied by an admission
  /// rule.
  public enum EnforcementMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not use.
    case unspecified // = 0

    /// Enforce the admission rule by blocking the pod creation.
    case enforcedBlockAndAuditLog // = 1

    /// Dryrun mode: Audit logging only.  This will allow the pod creation as if
    /// the admission request had specified break-glass.
    case dryrunAuditLogOnly // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enforcedBlockAndAuditLog
      case 2: self = .dryrunAuditLogOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enforcedBlockAndAuditLog: return 1
      case .dryrunAuditLogOnly: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EvaluationMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EvaluationMode] = [
    .unspecified,
    .alwaysAllow,
    .requireAttestation,
    .alwaysDeny,
  ]
}

extension Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EnforcementMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EnforcementMode] = [
    .unspecified,
    .enforcedBlockAndAuditLog,
    .dryrunAuditLogOnly,
  ]
}

#endif  // swift(>=4.2)

/// An [attestor][google.cloud.binaryauthorization.v1beta1.Attestor] that attests to container image
/// artifacts. An existing attestor cannot be modified except where
/// indicated.
public struct Google_Cloud_Binaryauthorization_V1beta1_Attestor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name, in the format:
  /// `projects/*/attestors/*`. This field may not be updated.
  public var name: String = String()

  /// Optional. A descriptive comment.  This field may be updated.
  /// The field may be displayed in chooser dialogs.
  public var description_p: String = String()

  /// Required. Identifies an [attestor][google.cloud.binaryauthorization.v1beta1.Attestor] that attests to a
  /// container image artifact. This determines how an attestation will
  /// be stored, and how it will be used during policy
  /// enforcement. Updates may not change the attestor type, but individual
  /// attestor fields may be updated
  public var attestorType: Google_Cloud_Binaryauthorization_V1beta1_Attestor.OneOf_AttestorType? = nil

  /// A Drydock ATTESTATION_AUTHORITY Note, created by the user.
  public var userOwnedDrydockNote: Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote {
    get {
      if case .userOwnedDrydockNote(let v)? = attestorType {return v}
      return Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote()
    }
    set {attestorType = .userOwnedDrydockNote(newValue)}
  }

  /// Output only. Time when the attestor was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Identifies an [attestor][google.cloud.binaryauthorization.v1beta1.Attestor] that attests to a
  /// container image artifact. This determines how an attestation will
  /// be stored, and how it will be used during policy
  /// enforcement. Updates may not change the attestor type, but individual
  /// attestor fields may be updated
  public enum OneOf_AttestorType: Equatable {
    /// A Drydock ATTESTATION_AUTHORITY Note, created by the user.
    case userOwnedDrydockNote(Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_Attestor.OneOf_AttestorType, rhs: Google_Cloud_Binaryauthorization_V1beta1_Attestor.OneOf_AttestorType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userOwnedDrydockNote, .userOwnedDrydockNote): return {
        guard case .userOwnedDrydockNote(let l) = lhs, case .userOwnedDrydockNote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// An [user owned drydock note][google.cloud.binaryauthorization.v1beta1.UserOwnedDrydockNote] references a Drydock
/// ATTESTATION_AUTHORITY Note created by the user.
public struct Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Drydock resource name of a ATTESTATION_AUTHORITY Note,
  /// created by the user, in the format: `projects/*/notes/*` (or the legacy
  /// `providers/*/notes/*`). This field may not be updated.
  ///
  /// An attestation by this attestor is stored as a Drydock
  /// ATTESTATION_AUTHORITY Occurrence that names a container image and that
  /// links to this Note. Drydock is an external dependency.
  public var noteReference: String = String()

  /// Optional. Public keys that verify attestations signed by this
  /// attestor.  This field may be updated.
  ///
  /// If this field is non-empty, one of the specified public keys must
  /// verify that an attestation was signed by this attestor for the
  /// image specified in the admission request.
  ///
  /// If this field is empty, this attestor always returns that no
  /// valid attestations exist.
  public var publicKeys: [Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey] = []

  /// Output only. This field will contain the service account email address
  /// that this Attestor will use as the principal when querying Container
  /// Analysis. Attestor administrators must grant this service account the
  /// IAM role needed to read attestations from the [note_reference][Note] in
  /// Container Analysis (`containeranalysis.notes.occurrences.viewer`).
  ///
  /// This email address is fixed for the lifetime of the Attestor, but callers
  /// should not make any other assumptions about the service account email;
  /// future versions may use an email based on a different naming pattern.
  public var delegationServiceAccountEmail: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A public key in the PkixPublicKey format (see
/// https://tools.ietf.org/html/rfc5280#section-4.1.2.7 for details).
/// Public keys of this type are typically textually encoded using the PEM
/// format.
public struct Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A PEM-encoded public key, as described in
  /// https://tools.ietf.org/html/rfc7468#section-13
  public var publicKeyPem: String = String()

  /// The signature algorithm used to verify a message against a signature using
  /// this key.
  /// These signature algorithm must match the structure and any object
  /// identifiers encoded in `public_key_pem` (i.e. this algorithm must match
  /// that of the public key).
  public var signatureAlgorithm: Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey.SignatureAlgorithm = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents a signature algorithm and other information necessary to verify
  /// signatures with a given public key.
  /// This is based primarily on the public key types supported by Tink's
  /// PemKeyType, which is in turn based on KMS's supported signing algorithms.
  /// See https://cloud.google.com/kms/docs/algorithms. In the future, BinAuthz
  /// might support additional public key types independently of Tink and/or KMS.
  public enum SignatureAlgorithm: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// RSASSA-PSS 2048 bit key with a SHA256 digest.
    case rsaPss2048Sha256 // = 1

    /// RSASSA-PSS 3072 bit key with a SHA256 digest.
    case rsaPss3072Sha256 // = 2

    /// RSASSA-PSS 4096 bit key with a SHA256 digest.
    case rsaPss4096Sha256 // = 3

    /// RSASSA-PSS 4096 bit key with a SHA512 digest.
    case rsaPss4096Sha512 // = 4

    /// RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.
    case rsaSignPkcs12048Sha256 // = 5

    /// RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.
    case rsaSignPkcs13072Sha256 // = 6

    /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.
    case rsaSignPkcs14096Sha256 // = 7

    /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.
    case rsaSignPkcs14096Sha512 // = 8

    /// ECDSA on the NIST P-256 curve with a SHA256 digest.
    case ecdsaP256Sha256 // = 9

    /// ECDSA on the NIST P-384 curve with a SHA384 digest.
    case ecdsaP384Sha384 // = 10

    /// ECDSA on the NIST P-521 curve with a SHA512 digest.
    case ecdsaP521Sha512 // = 11
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .rsaPss2048Sha256
      case 2: self = .rsaPss3072Sha256
      case 3: self = .rsaPss4096Sha256
      case 4: self = .rsaPss4096Sha512
      case 5: self = .rsaSignPkcs12048Sha256
      case 6: self = .rsaSignPkcs13072Sha256
      case 7: self = .rsaSignPkcs14096Sha256
      case 8: self = .rsaSignPkcs14096Sha512
      case 9: self = .ecdsaP256Sha256
      case 10: self = .ecdsaP384Sha384
      case 11: self = .ecdsaP521Sha512
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .rsaPss2048Sha256: return 1
      case .rsaPss3072Sha256: return 2
      case .rsaPss4096Sha256: return 3
      case .rsaPss4096Sha512: return 4
      case .rsaSignPkcs12048Sha256: return 5
      case .rsaSignPkcs13072Sha256: return 6
      case .rsaSignPkcs14096Sha256: return 7
      case .rsaSignPkcs14096Sha512: return 8
      case .ecdsaP256Sha256: return 9
      case .ecdsaP384Sha384: return 10
      case .ecdsaP521Sha512: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey.SignatureAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey.SignatureAlgorithm] = [
    .unspecified,
    .rsaPss2048Sha256,
    .rsaPss3072Sha256,
    .rsaPss4096Sha256,
    .rsaPss4096Sha512,
    .rsaSignPkcs12048Sha256,
    .rsaSignPkcs13072Sha256,
    .rsaSignPkcs14096Sha256,
    .rsaSignPkcs14096Sha512,
    .ecdsaP256Sha256,
    .ecdsaP384Sha384,
    .ecdsaP521Sha512,
  ]
}

#endif  // swift(>=4.2)

/// An [attestor public key][google.cloud.binaryauthorization.v1beta1.AttestorPublicKey] that will be used to verify
/// attestations signed by this attestor.
public struct Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A descriptive comment. This field may be updated.
  public var comment: String = String()

  /// The ID of this public key.
  /// Signatures verified by BinAuthz must include the ID of the public key that
  /// can be used to verify them, and that ID must match the contents of this
  /// field exactly.
  /// Additional restrictions on this field can be imposed based on which public
  /// key type is encapsulated. See the documentation on `public_key` cases below
  /// for details.
  public var id: String = String()

  /// Required. A public key reference or serialized instance. This field may be
  /// updated.
  public var publicKey: Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey.OneOf_PublicKey? = nil

  /// ASCII-armored representation of a PGP public key, as the entire output by
  /// the command `gpg --export --armor foo@example.com` (either LF or CRLF
  /// line endings).
  /// When using this field, `id` should be left blank.  The BinAuthz API
  /// handlers will calculate the ID and fill it in automatically.  BinAuthz
  /// computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as
  /// upper-case hex.  If `id` is provided by the caller, it will be
  /// overwritten by the API-calculated ID.
  public var asciiArmoredPgpPublicKey: String {
    get {
      if case .asciiArmoredPgpPublicKey(let v)? = publicKey {return v}
      return String()
    }
    set {publicKey = .asciiArmoredPgpPublicKey(newValue)}
  }

  /// A raw PKIX SubjectPublicKeyInfo format public key.
  ///
  /// NOTE: `id` may be explicitly provided by the caller when using this
  /// type of public key, but it MUST be a valid RFC3986 URI. If `id` is left
  /// blank, a default one will be computed based on the digest of the DER
  /// encoding of the public key.
  public var pkixPublicKey: Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey {
    get {
      if case .pkixPublicKey(let v)? = publicKey {return v}
      return Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey()
    }
    set {publicKey = .pkixPublicKey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. A public key reference or serialized instance. This field may be
  /// updated.
  public enum OneOf_PublicKey: Equatable {
    /// ASCII-armored representation of a PGP public key, as the entire output by
    /// the command `gpg --export --armor foo@example.com` (either LF or CRLF
    /// line endings).
    /// When using this field, `id` should be left blank.  The BinAuthz API
    /// handlers will calculate the ID and fill it in automatically.  BinAuthz
    /// computes this ID as the OpenPGP RFC4880 V4 fingerprint, represented as
    /// upper-case hex.  If `id` is provided by the caller, it will be
    /// overwritten by the API-calculated ID.
    case asciiArmoredPgpPublicKey(String)
    /// A raw PKIX SubjectPublicKeyInfo format public key.
    ///
    /// NOTE: `id` may be explicitly provided by the caller when using this
    /// type of public key, but it MUST be a valid RFC3986 URI. If `id` is left
    /// blank, a default one will be computed based on the digest of the DER
    /// encoding of the public key.
    case pkixPublicKey(Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey.OneOf_PublicKey, rhs: Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey.OneOf_PublicKey) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.asciiArmoredPgpPublicKey, .asciiArmoredPgpPublicKey): return {
        guard case .asciiArmoredPgpPublicKey(let l) = lhs, case .asciiArmoredPgpPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pkixPublicKey, .pkixPublicKey): return {
        guard case .pkixPublicKey(let l) = lhs, case .pkixPublicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.binaryauthorization.v1beta1"

extension Google_Cloud_Binaryauthorization_V1beta1_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    6: .same(proto: "description"),
    7: .standard(proto: "global_policy_evaluation_mode"),
    2: .standard(proto: "admission_whitelist_patterns"),
    3: .standard(proto: "cluster_admission_rules"),
    4: .standard(proto: "default_admission_rule"),
    5: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.admissionWhitelistPatterns) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule>.self, value: &self.clusterAdmissionRules) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._defaultAdmissionRule) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.globalPolicyEvaluationMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.admissionWhitelistPatterns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.admissionWhitelistPatterns, fieldNumber: 2)
    }
    if !self.clusterAdmissionRules.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule>.self, value: self.clusterAdmissionRules, fieldNumber: 3)
    }
    if let v = self._defaultAdmissionRule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if self.globalPolicyEvaluationMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.globalPolicyEvaluationMode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_Policy, rhs: Google_Cloud_Binaryauthorization_V1beta1_Policy) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.globalPolicyEvaluationMode != rhs.globalPolicyEvaluationMode {return false}
    if lhs.admissionWhitelistPatterns != rhs.admissionWhitelistPatterns {return false}
    if lhs.clusterAdmissionRules != rhs.clusterAdmissionRules {return false}
    if lhs._defaultAdmissionRule != rhs._defaultAdmissionRule {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Binaryauthorization_V1beta1_Policy.GlobalPolicyEvaluationMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GLOBAL_POLICY_EVALUATION_MODE_UNSPECIFIED"),
    1: .same(proto: "ENABLE"),
    2: .same(proto: "DISABLE"),
  ]
}

extension Google_Cloud_Binaryauthorization_V1beta1_AdmissionWhitelistPattern: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdmissionWhitelistPattern"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "name_pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namePattern) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namePattern.isEmpty {
      try visitor.visitSingularStringField(value: self.namePattern, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_AdmissionWhitelistPattern, rhs: Google_Cloud_Binaryauthorization_V1beta1_AdmissionWhitelistPattern) -> Bool {
    if lhs.namePattern != rhs.namePattern {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdmissionRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "evaluation_mode"),
    2: .standard(proto: "require_attestations_by"),
    3: .standard(proto: "enforcement_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.evaluationMode) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.requireAttestationsBy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.enforcementMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.evaluationMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.evaluationMode, fieldNumber: 1)
    }
    if !self.requireAttestationsBy.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requireAttestationsBy, fieldNumber: 2)
    }
    if self.enforcementMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.enforcementMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule, rhs: Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule) -> Bool {
    if lhs.evaluationMode != rhs.evaluationMode {return false}
    if lhs.requireAttestationsBy != rhs.requireAttestationsBy {return false}
    if lhs.enforcementMode != rhs.enforcementMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EvaluationMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EVALUATION_MODE_UNSPECIFIED"),
    1: .same(proto: "ALWAYS_ALLOW"),
    2: .same(proto: "REQUIRE_ATTESTATION"),
    3: .same(proto: "ALWAYS_DENY"),
  ]
}

extension Google_Cloud_Binaryauthorization_V1beta1_AdmissionRule.EnforcementMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENFORCEMENT_MODE_UNSPECIFIED"),
    1: .same(proto: "ENFORCED_BLOCK_AND_AUDIT_LOG"),
    2: .same(proto: "DRYRUN_AUDIT_LOG_ONLY"),
  ]
}

extension Google_Cloud_Binaryauthorization_V1beta1_Attestor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attestor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    6: .same(proto: "description"),
    3: .standard(proto: "user_owned_drydock_note"),
    4: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote?
        if let current = self.attestorType {
          try decoder.handleConflictingOneOf()
          if case .userOwnedDrydockNote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.attestorType = .userOwnedDrydockNote(v)}
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .userOwnedDrydockNote(let v)? = self.attestorType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_Attestor, rhs: Google_Cloud_Binaryauthorization_V1beta1_Attestor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.attestorType != rhs.attestorType {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserOwnedDrydockNote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "note_reference"),
    2: .standard(proto: "public_keys"),
    3: .standard(proto: "delegation_service_account_email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.noteReference) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.publicKeys) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.delegationServiceAccountEmail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.noteReference.isEmpty {
      try visitor.visitSingularStringField(value: self.noteReference, fieldNumber: 1)
    }
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicKeys, fieldNumber: 2)
    }
    if !self.delegationServiceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.delegationServiceAccountEmail, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote, rhs: Google_Cloud_Binaryauthorization_V1beta1_UserOwnedDrydockNote) -> Bool {
    if lhs.noteReference != rhs.noteReference {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.delegationServiceAccountEmail != rhs.delegationServiceAccountEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PkixPublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key_pem"),
    2: .standard(proto: "signature_algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicKeyPem) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.signatureAlgorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicKeyPem.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyPem, fieldNumber: 1)
    }
    if self.signatureAlgorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.signatureAlgorithm, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey, rhs: Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey) -> Bool {
    if lhs.publicKeyPem != rhs.publicKeyPem {return false}
    if lhs.signatureAlgorithm != rhs.signatureAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey.SignatureAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGNATURE_ALGORITHM_UNSPECIFIED"),
    1: .same(proto: "RSA_PSS_2048_SHA256"),
    2: .same(proto: "RSA_PSS_3072_SHA256"),
    3: .same(proto: "RSA_PSS_4096_SHA256"),
    4: .same(proto: "RSA_PSS_4096_SHA512"),
    5: .same(proto: "RSA_SIGN_PKCS1_2048_SHA256"),
    6: .same(proto: "RSA_SIGN_PKCS1_3072_SHA256"),
    7: .same(proto: "RSA_SIGN_PKCS1_4096_SHA256"),
    8: .same(proto: "RSA_SIGN_PKCS1_4096_SHA512"),
    9: .same(proto: "ECDSA_P256_SHA256"),
    10: .same(proto: "ECDSA_P384_SHA384"),
    11: .same(proto: "ECDSA_P521_SHA512"),
  ]
}

extension Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttestorPublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "comment"),
    2: .same(proto: "id"),
    3: .standard(proto: "ascii_armored_pgp_public_key"),
    5: .standard(proto: "pkix_public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try {
        if self.publicKey != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.publicKey = .asciiArmoredPgpPublicKey(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Binaryauthorization_V1beta1_PkixPublicKey?
        if let current = self.publicKey {
          try decoder.handleConflictingOneOf()
          if case .pkixPublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.publicKey = .pkixPublicKey(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.publicKey {
    case .asciiArmoredPgpPublicKey?: try {
      guard case .asciiArmoredPgpPublicKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .pkixPublicKey?: try {
      guard case .pkixPublicKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey, rhs: Google_Cloud_Binaryauthorization_V1beta1_AttestorPublicKey) -> Bool {
    if lhs.comment != rhs.comment {return false}
    if lhs.id != rhs.id {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

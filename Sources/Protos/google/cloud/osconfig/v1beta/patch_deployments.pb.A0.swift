// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/osconfig/v1beta/patch_deployments.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Patch deployments are configurations that individual patch jobs use to
/// complete a patch. These configurations include instance filter, package
/// repository settings, and a schedule. For more information about creating and
/// managing patch deployments, see [Scheduling patch
/// jobs](/compute/docs/os-patch-management/schedule-patch-jobs).
public struct Google_Cloud_Osconfig_V1beta_PatchDeployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique name for the patch deployment resource in a project. The patch
  /// deployment name is in the form:
  /// `projects/{project_id}/patchDeployments/{patch_deployment_id}`.
  /// This field is ignored when you create a new patch deployment.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optional. Description of the patch deployment. Length of the description is limited
  /// to 1024 characters.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Required. VM instances to patch.
  public var instanceFilter: Google_Cloud_Osconfig_V1beta_PatchInstanceFilter {
    get {return _storage._instanceFilter ?? Google_Cloud_Osconfig_V1beta_PatchInstanceFilter()}
    set {_uniqueStorage()._instanceFilter = newValue}
  }
  /// Returns true if `instanceFilter` has been explicitly set.
  public var hasInstanceFilter: Bool {return _storage._instanceFilter != nil}
  /// Clears the value of `instanceFilter`. Subsequent reads from it will return its default value.
  public mutating func clearInstanceFilter() {_uniqueStorage()._instanceFilter = nil}

  /// Optional. Patch configuration that is applied.
  public var patchConfig: Google_Cloud_Osconfig_V1beta_PatchConfig {
    get {return _storage._patchConfig ?? Google_Cloud_Osconfig_V1beta_PatchConfig()}
    set {_uniqueStorage()._patchConfig = newValue}
  }
  /// Returns true if `patchConfig` has been explicitly set.
  public var hasPatchConfig: Bool {return _storage._patchConfig != nil}
  /// Clears the value of `patchConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPatchConfig() {_uniqueStorage()._patchConfig = nil}

  /// Optional. Duration of the patch. After the duration ends, the patch times out.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  /// Schedule for the patch.
  public var schedule: OneOf_Schedule? {
    get {return _storage._schedule}
    set {_uniqueStorage()._schedule = newValue}
  }

  /// Required. Schedule a one-time execution.
  public var oneTimeSchedule: Google_Cloud_Osconfig_V1beta_OneTimeSchedule {
    get {
      if case .oneTimeSchedule(let v)? = _storage._schedule {return v}
      return Google_Cloud_Osconfig_V1beta_OneTimeSchedule()
    }
    set {_uniqueStorage()._schedule = .oneTimeSchedule(newValue)}
  }

  /// Required. Schedule recurring executions.
  public var recurringSchedule: Google_Cloud_Osconfig_V1beta_RecurringSchedule {
    get {
      if case .recurringSchedule(let v)? = _storage._schedule {return v}
      return Google_Cloud_Osconfig_V1beta_RecurringSchedule()
    }
    set {_uniqueStorage()._schedule = .recurringSchedule(newValue)}
  }

  /// Output only. Time the patch deployment was created. Timestamp is in
  /// <a href="https://www.ietf.org/rfc/rfc3339.txt" target="_blank">RFC3339</a>
  /// text format.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Time the patch deployment was last updated. Timestamp is in
  /// <a href="https://www.ietf.org/rfc/rfc3339.txt" target="_blank">RFC3339</a>
  /// text format.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. The last time a patch job was started by this deployment.
  /// Timestamp is in
  /// <a href="https://www.ietf.org/rfc/rfc3339.txt" target="_blank">RFC3339</a>
  /// text format.
  public var lastExecuteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastExecuteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastExecuteTime = newValue}
  }
  /// Returns true if `lastExecuteTime` has been explicitly set.
  public var hasLastExecuteTime: Bool {return _storage._lastExecuteTime != nil}
  /// Clears the value of `lastExecuteTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastExecuteTime() {_uniqueStorage()._lastExecuteTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Schedule for the patch.
  public enum OneOf_Schedule: Equatable {
    /// Required. Schedule a one-time execution.
    case oneTimeSchedule(Google_Cloud_Osconfig_V1beta_OneTimeSchedule)
    /// Required. Schedule recurring executions.
    case recurringSchedule(Google_Cloud_Osconfig_V1beta_RecurringSchedule)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_V1beta_PatchDeployment.OneOf_Schedule, rhs: Google_Cloud_Osconfig_V1beta_PatchDeployment.OneOf_Schedule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.oneTimeSchedule, .oneTimeSchedule): return {
        guard case .oneTimeSchedule(let l) = lhs, case .oneTimeSchedule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recurringSchedule, .recurringSchedule): return {
        guard case .recurringSchedule(let l) = lhs, case .recurringSchedule(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Sets the time for a one time patch deployment. Timestamp is in
/// <a href="https://www.ietf.org/rfc/rfc3339.txt" target="_blank">RFC3339</a>
/// text format.
public struct Google_Cloud_Osconfig_V1beta_OneTimeSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The desired patch job execution time.
  public var executeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _executeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_executeTime = newValue}
  }
  /// Returns true if `executeTime` has been explicitly set.
  public var hasExecuteTime: Bool {return self._executeTime != nil}
  /// Clears the value of `executeTime`. Subsequent reads from it will return its default value.
  public mutating func clearExecuteTime() {self._executeTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _executeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Sets the time for recurring patch deployments.
public struct Google_Cloud_Osconfig_V1beta_RecurringSchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Defines the time zone that `time_of_day` is relative to.
  /// The rules for daylight saving time are determined by the chosen time zone.
  public var timeZone: Google_Type_TimeZone {
    get {return _storage._timeZone ?? Google_Type_TimeZone()}
    set {_uniqueStorage()._timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  public var hasTimeZone: Bool {return _storage._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  public mutating func clearTimeZone() {_uniqueStorage()._timeZone = nil}

  /// Optional. The time that the recurring schedule becomes effective.
  /// Defaults to `create_time` of the patch deployment.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Optional. The end time at which a recurring patch deployment schedule is no longer
  /// active.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Required. Time of the day to run a recurring deployment.
  public var timeOfDay: Google_Type_TimeOfDay {
    get {return _storage._timeOfDay ?? Google_Type_TimeOfDay()}
    set {_uniqueStorage()._timeOfDay = newValue}
  }
  /// Returns true if `timeOfDay` has been explicitly set.
  public var hasTimeOfDay: Bool {return _storage._timeOfDay != nil}
  /// Clears the value of `timeOfDay`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOfDay() {_uniqueStorage()._timeOfDay = nil}

  /// Required. The frequency unit of this recurring schedule.
  public var frequency: Google_Cloud_Osconfig_V1beta_RecurringSchedule.Frequency {
    get {return _storage._frequency}
    set {_uniqueStorage()._frequency = newValue}
  }

  /// Configurations for this recurring schedule.
  /// Configurations must match frequency.
  public var scheduleConfig: OneOf_ScheduleConfig? {
    get {return _storage._scheduleConfig}
    set {_uniqueStorage()._scheduleConfig = newValue}
  }

  /// Required. Schedule with weekly executions.
  public var weekly: Google_Cloud_Osconfig_V1beta_WeeklySchedule {
    get {
      if case .weekly(let v)? = _storage._scheduleConfig {return v}
      return Google_Cloud_Osconfig_V1beta_WeeklySchedule()
    }
    set {_uniqueStorage()._scheduleConfig = .weekly(newValue)}
  }

  /// Required. Schedule with monthly executions.
  public var monthly: Google_Cloud_Osconfig_V1beta_MonthlySchedule {
    get {
      if case .monthly(let v)? = _storage._scheduleConfig {return v}
      return Google_Cloud_Osconfig_V1beta_MonthlySchedule()
    }
    set {_uniqueStorage()._scheduleConfig = .monthly(newValue)}
  }

  /// Output only. The time the last patch job ran successfully.
  public var lastExecuteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastExecuteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastExecuteTime = newValue}
  }
  /// Returns true if `lastExecuteTime` has been explicitly set.
  public var hasLastExecuteTime: Bool {return _storage._lastExecuteTime != nil}
  /// Clears the value of `lastExecuteTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastExecuteTime() {_uniqueStorage()._lastExecuteTime = nil}

  /// Output only. The time the next patch job is scheduled to run.
  public var nextExecuteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._nextExecuteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._nextExecuteTime = newValue}
  }
  /// Returns true if `nextExecuteTime` has been explicitly set.
  public var hasNextExecuteTime: Bool {return _storage._nextExecuteTime != nil}
  /// Clears the value of `nextExecuteTime`. Subsequent reads from it will return its default value.
  public mutating func clearNextExecuteTime() {_uniqueStorage()._nextExecuteTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Configurations for this recurring schedule.
  /// Configurations must match frequency.
  public enum OneOf_ScheduleConfig: Equatable {
    /// Required. Schedule with weekly executions.
    case weekly(Google_Cloud_Osconfig_V1beta_WeeklySchedule)
    /// Required. Schedule with monthly executions.
    case monthly(Google_Cloud_Osconfig_V1beta_MonthlySchedule)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_V1beta_RecurringSchedule.OneOf_ScheduleConfig, rhs: Google_Cloud_Osconfig_V1beta_RecurringSchedule.OneOf_ScheduleConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.weekly, .weekly): return {
        guard case .weekly(let l) = lhs, case .weekly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.monthly, .monthly): return {
        guard case .monthly(let l) = lhs, case .monthly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Specifies the frequency of the recurring patch deployments.
  public enum Frequency: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid. A frequency must be specified.
    case unspecified // = 0

    /// Indicates that the frequency should be expressed in terms of
    /// weeks.
    case weekly // = 1

    /// Indicates that the frequency should be expressed in terms of
    /// months.
    case monthly // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .weekly
      case 2: self = .monthly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .weekly: return 1
      case .monthly: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1beta_RecurringSchedule.Frequency: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1beta_RecurringSchedule.Frequency] = [
    .unspecified,
    .weekly,
    .monthly,
  ]
}

#endif  // swift(>=4.2)

/// Represents a weekly schedule.
public struct Google_Cloud_Osconfig_V1beta_WeeklySchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Day of the week.
  public var dayOfWeek: Google_Type_DayOfWeek = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a monthly schedule. An example of a valid monthly schedule is
/// "on the third Tuesday of the month" or "on the 15th of the month".
public struct Google_Cloud_Osconfig_V1beta_MonthlySchedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One day in a month.
  public var dayOfMonth: Google_Cloud_Osconfig_V1beta_MonthlySchedule.OneOf_DayOfMonth? = nil

  /// Required. Week day in a month.
  public var weekDayOfMonth: Google_Cloud_Osconfig_V1beta_WeekDayOfMonth {
    get {
      if case .weekDayOfMonth(let v)? = dayOfMonth {return v}
      return Google_Cloud_Osconfig_V1beta_WeekDayOfMonth()
    }
    set {dayOfMonth = .weekDayOfMonth(newValue)}
  }

  /// Required. One day of the month. 1-31 indicates the 1st to the 31st day. -1
  /// indicates the last day of the month.
  /// Months without the target day will be skipped. For example, a schedule to
  /// run "every month on the 31st" will not run in February, April, June, etc.
  public var monthDay: Int32 {
    get {
      if case .monthDay(let v)? = dayOfMonth {return v}
      return 0
    }
    set {dayOfMonth = .monthDay(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One day in a month.
  public enum OneOf_DayOfMonth: Equatable {
    /// Required. Week day in a month.
    case weekDayOfMonth(Google_Cloud_Osconfig_V1beta_WeekDayOfMonth)
    /// Required. One day of the month. 1-31 indicates the 1st to the 31st day. -1
    /// indicates the last day of the month.
    /// Months without the target day will be skipped. For example, a schedule to
    /// run "every month on the 31st" will not run in February, April, June, etc.
    case monthDay(Int32)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_V1beta_MonthlySchedule.OneOf_DayOfMonth, rhs: Google_Cloud_Osconfig_V1beta_MonthlySchedule.OneOf_DayOfMonth) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.weekDayOfMonth, .weekDayOfMonth): return {
        guard case .weekDayOfMonth(let l) = lhs, case .weekDayOfMonth(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.monthDay, .monthDay): return {
        guard case .monthDay(let l) = lhs, case .monthDay(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Represents one week day in a month. An example is "the 4th Sunday".
public struct Google_Cloud_Osconfig_V1beta_WeekDayOfMonth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Week number in a month. 1-4 indicates the 1st to 4th week of the month. -1
  /// indicates the last week of the month.
  public var weekOrdinal: Int32 = 0

  /// Required. A day of the week.
  public var dayOfWeek: Google_Type_DayOfWeek = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for creating a patch deployment.
public struct Google_Cloud_Osconfig_V1beta_CreatePatchDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project to apply this patch deployment to in the form `projects/*`.
  public var parent: String = String()

  /// Required. A name for the patch deployment in the project. When creating a name
  /// the following rules apply:
  /// * Must contain only lowercase letters, numbers, and hyphens.
  /// * Must start with a letter.
  /// * Must be between 1-63 characters.
  /// * Must end with a number or a letter.
  /// * Must be unique within the project.
  public var patchDeploymentID: String = String()

  /// Required. The patch deployment to create.
  public var patchDeployment: Google_Cloud_Osconfig_V1beta_PatchDeployment {
    get {return _patchDeployment ?? Google_Cloud_Osconfig_V1beta_PatchDeployment()}
    set {_patchDeployment = newValue}
  }
  /// Returns true if `patchDeployment` has been explicitly set.
  public var hasPatchDeployment: Bool {return self._patchDeployment != nil}
  /// Clears the value of `patchDeployment`. Subsequent reads from it will return its default value.
  public mutating func clearPatchDeployment() {self._patchDeployment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _patchDeployment: Google_Cloud_Osconfig_V1beta_PatchDeployment? = nil
}

/// A request message for retrieving a patch deployment.
public struct Google_Cloud_Osconfig_V1beta_GetPatchDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the patch deployment in the form
  /// `projects/*/patchDeployments/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for listing patch deployments.
public struct Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the parent in the form `projects/*`.
  public var parent: String = String()

  /// Optional. The maximum number of patch deployments to return. Default is 100.
  public var pageSize: Int32 = 0

  /// Optional. A pagination token returned from a previous call to ListPatchDeployments
  /// that indicates where this listing should continue from.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for listing patch deployments.
public struct Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of patch deployments.
  public var patchDeployments: [Google_Cloud_Osconfig_V1beta_PatchDeployment] = []

  /// A pagination token that can be used to get the next page of patch
  /// deployments.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for deleting a patch deployment.
public struct Google_Cloud_Osconfig_V1beta_DeletePatchDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the patch deployment in the form
  /// `projects/*/patchDeployments/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.osconfig.v1beta"

extension Google_Cloud_Osconfig_V1beta_PatchDeployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchDeployment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "instance_filter"),
    4: .standard(proto: "patch_config"),
    5: .same(proto: "duration"),
    6: .standard(proto: "one_time_schedule"),
    7: .standard(proto: "recurring_schedule"),
    8: .standard(proto: "create_time"),
    9: .standard(proto: "update_time"),
    10: .standard(proto: "last_execute_time"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _instanceFilter: Google_Cloud_Osconfig_V1beta_PatchInstanceFilter? = nil
    var _patchConfig: Google_Cloud_Osconfig_V1beta_PatchConfig? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _schedule: Google_Cloud_Osconfig_V1beta_PatchDeployment.OneOf_Schedule?
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastExecuteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _instanceFilter = source._instanceFilter
      _patchConfig = source._patchConfig
      _duration = source._duration
      _schedule = source._schedule
      _createTime = source._createTime
      _updateTime = source._updateTime
      _lastExecuteTime = source._lastExecuteTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._instanceFilter) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._patchConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._duration) }()
        case 6: try {
          var v: Google_Cloud_Osconfig_V1beta_OneTimeSchedule?
          if let current = _storage._schedule {
            try decoder.handleConflictingOneOf()
            if case .oneTimeSchedule(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._schedule = .oneTimeSchedule(v)}
        }()
        case 7: try {
          var v: Google_Cloud_Osconfig_V1beta_RecurringSchedule?
          if let current = _storage._schedule {
            try decoder.handleConflictingOneOf()
            if case .recurringSchedule(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._schedule = .recurringSchedule(v)}
        }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastExecuteTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if let v = _storage._instanceFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._patchConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._schedule {
      case .oneTimeSchedule?: try {
        guard case .oneTimeSchedule(let v)? = _storage._schedule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .recurringSchedule?: try {
        guard case .recurringSchedule(let v)? = _storage._schedule else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._lastExecuteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_PatchDeployment, rhs: Google_Cloud_Osconfig_V1beta_PatchDeployment) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._instanceFilter != rhs_storage._instanceFilter {return false}
        if _storage._patchConfig != rhs_storage._patchConfig {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._lastExecuteTime != rhs_storage._lastExecuteTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_OneTimeSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OneTimeSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "execute_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._executeTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._executeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_OneTimeSchedule, rhs: Google_Cloud_Osconfig_V1beta_OneTimeSchedule) -> Bool {
    if lhs._executeTime != rhs._executeTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_RecurringSchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecurringSchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_zone"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "end_time"),
    4: .standard(proto: "time_of_day"),
    5: .same(proto: "frequency"),
    6: .same(proto: "weekly"),
    7: .same(proto: "monthly"),
    9: .standard(proto: "last_execute_time"),
    10: .standard(proto: "next_execute_time"),
  ]

  fileprivate class _StorageClass {
    var _timeZone: Google_Type_TimeZone? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _timeOfDay: Google_Type_TimeOfDay? = nil
    var _frequency: Google_Cloud_Osconfig_V1beta_RecurringSchedule.Frequency = .unspecified
    var _scheduleConfig: Google_Cloud_Osconfig_V1beta_RecurringSchedule.OneOf_ScheduleConfig?
    var _lastExecuteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nextExecuteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _timeZone = source._timeZone
      _startTime = source._startTime
      _endTime = source._endTime
      _timeOfDay = source._timeOfDay
      _frequency = source._frequency
      _scheduleConfig = source._scheduleConfig
      _lastExecuteTime = source._lastExecuteTime
      _nextExecuteTime = source._nextExecuteTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._timeZone) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._timeOfDay) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._frequency) }()
        case 6: try {
          var v: Google_Cloud_Osconfig_V1beta_WeeklySchedule?
          if let current = _storage._scheduleConfig {
            try decoder.handleConflictingOneOf()
            if case .weekly(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scheduleConfig = .weekly(v)}
        }()
        case 7: try {
          var v: Google_Cloud_Osconfig_V1beta_MonthlySchedule?
          if let current = _storage._scheduleConfig {
            try decoder.handleConflictingOneOf()
            if case .monthly(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scheduleConfig = .monthly(v)}
        }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lastExecuteTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._nextExecuteTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._timeZone {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timeOfDay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._frequency != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._frequency, fieldNumber: 5)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._scheduleConfig {
      case .weekly?: try {
        guard case .weekly(let v)? = _storage._scheduleConfig else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .monthly?: try {
        guard case .monthly(let v)? = _storage._scheduleConfig else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case nil: break
      }
      if let v = _storage._lastExecuteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._nextExecuteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_RecurringSchedule, rhs: Google_Cloud_Osconfig_V1beta_RecurringSchedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._timeZone != rhs_storage._timeZone {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._timeOfDay != rhs_storage._timeOfDay {return false}
        if _storage._frequency != rhs_storage._frequency {return false}
        if _storage._scheduleConfig != rhs_storage._scheduleConfig {return false}
        if _storage._lastExecuteTime != rhs_storage._lastExecuteTime {return false}
        if _storage._nextExecuteTime != rhs_storage._nextExecuteTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_RecurringSchedule.Frequency: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FREQUENCY_UNSPECIFIED"),
    1: .same(proto: "WEEKLY"),
    2: .same(proto: "MONTHLY"),
  ]
}

extension Google_Cloud_Osconfig_V1beta_WeeklySchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WeeklySchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "day_of_week"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dayOfWeek) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dayOfWeek != .unspecified {
      try visitor.visitSingularEnumField(value: self.dayOfWeek, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_WeeklySchedule, rhs: Google_Cloud_Osconfig_V1beta_WeeklySchedule) -> Bool {
    if lhs.dayOfWeek != rhs.dayOfWeek {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_MonthlySchedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MonthlySchedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "week_day_of_month"),
    2: .standard(proto: "month_day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Osconfig_V1beta_WeekDayOfMonth?
        if let current = self.dayOfMonth {
          try decoder.handleConflictingOneOf()
          if case .weekDayOfMonth(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dayOfMonth = .weekDayOfMonth(v)}
      }()
      case 2: try {
        if self.dayOfMonth != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.dayOfMonth = .monthDay(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.dayOfMonth {
    case .weekDayOfMonth?: try {
      guard case .weekDayOfMonth(let v)? = self.dayOfMonth else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .monthDay?: try {
      guard case .monthDay(let v)? = self.dayOfMonth else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_MonthlySchedule, rhs: Google_Cloud_Osconfig_V1beta_MonthlySchedule) -> Bool {
    if lhs.dayOfMonth != rhs.dayOfMonth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_WeekDayOfMonth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WeekDayOfMonth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "week_ordinal"),
    2: .standard(proto: "day_of_week"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.weekOrdinal) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.dayOfWeek) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.weekOrdinal != 0 {
      try visitor.visitSingularInt32Field(value: self.weekOrdinal, fieldNumber: 1)
    }
    if self.dayOfWeek != .unspecified {
      try visitor.visitSingularEnumField(value: self.dayOfWeek, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_WeekDayOfMonth, rhs: Google_Cloud_Osconfig_V1beta_WeekDayOfMonth) -> Bool {
    if lhs.weekOrdinal != rhs.weekOrdinal {return false}
    if lhs.dayOfWeek != rhs.dayOfWeek {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_CreatePatchDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreatePatchDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "patch_deployment_id"),
    3: .standard(proto: "patch_deployment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.patchDeploymentID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._patchDeployment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.patchDeploymentID.isEmpty {
      try visitor.visitSingularStringField(value: self.patchDeploymentID, fieldNumber: 2)
    }
    if let v = self._patchDeployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_CreatePatchDeploymentRequest, rhs: Google_Cloud_Osconfig_V1beta_CreatePatchDeploymentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.patchDeploymentID != rhs.patchDeploymentID {return false}
    if lhs._patchDeployment != rhs._patchDeployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_GetPatchDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPatchDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_GetPatchDeploymentRequest, rhs: Google_Cloud_Osconfig_V1beta_GetPatchDeploymentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPatchDeploymentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsRequest, rhs: Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPatchDeploymentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "patch_deployments"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.patchDeployments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchDeployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patchDeployments, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsResponse, rhs: Google_Cloud_Osconfig_V1beta_ListPatchDeploymentsResponse) -> Bool {
    if lhs.patchDeployments != rhs.patchDeployments {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_DeletePatchDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeletePatchDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_DeletePatchDeploymentRequest, rhs: Google_Cloud_Osconfig_V1beta_DeletePatchDeploymentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

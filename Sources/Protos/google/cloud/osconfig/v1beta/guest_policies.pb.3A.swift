// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/osconfig/v1beta/guest_policies.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The desired state that the OS Config agent maintains on the VM instance.
public enum Google_Cloud_Osconfig_V1beta_DesiredState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The default is to ensure the package is installed.
  case unspecified // = 0

  /// The agent ensures that the package is installed.
  case installed // = 1

  /// The agent ensures that the package is installed and
  /// periodically checks for and install any updates.
  case updated // = 2

  /// The agent ensures that the package is not installed and uninstall it
  /// if detected.
  case removed // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .installed
    case 2: self = .updated
    case 3: self = .removed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .installed: return 1
    case .updated: return 2
    case .removed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1beta_DesiredState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1beta_DesiredState] = [
    .unspecified,
    .installed,
    .updated,
    .removed,
  ]
}

#endif  // swift(>=4.2)

/// An OS Config resource representing a guest configuration policy. These
/// policies represent the desired state for VM instance guest environments
/// including packages to install or remove, package repository configurations,
/// and software to install.
public struct Google_Cloud_Osconfig_V1beta_GuestPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Unique name of the resource in this project using one of the following
  /// forms:
  /// `projects/{project_number}/guestPolicies/{guest_policy_id}`.
  public var name: String = String()

  /// Description of the guest policy. Length of the description is limited
  /// to 1024 characters.
  public var description_p: String = String()

  /// Output only. Time this guest policy was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Last time this guest policy was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Required. Specifies the VM instances that are assigned to this policy. This allows
  /// you to target sets or groups of VM instances by different parameters such
  /// as labels, names, OS, or zones.
  ///
  /// If left empty, all VM instances underneath this policy are targeted.
  ///
  /// At the same level in the resource hierarchy (that is within a project), the
  /// service prevents the creation of multiple policies that conflict with
  /// each other. For more information, see how the service [handles assignment
  /// conflicts](/compute/docs/os-config-management/create-guest-policy#handle-conflicts).
  public var assignment: Google_Cloud_Osconfig_V1beta_Assignment {
    get {return _assignment ?? Google_Cloud_Osconfig_V1beta_Assignment()}
    set {_assignment = newValue}
  }
  /// Returns true if `assignment` has been explicitly set.
  public var hasAssignment: Bool {return self._assignment != nil}
  /// Clears the value of `assignment`. Subsequent reads from it will return its default value.
  public mutating func clearAssignment() {self._assignment = nil}

  /// The software packages to be managed by this policy.
  public var packages: [Google_Cloud_Osconfig_V1beta_Package] = []

  /// A list of package repositories to configure on the VM instance. This is
  /// done before any other configs are applied so they can use these repos.
  /// Package repositories are only configured if the corresponding package
  /// manager(s) are available.
  public var packageRepositories: [Google_Cloud_Osconfig_V1beta_PackageRepository] = []

  /// A list of Recipes to install on the VM instance.
  public var recipes: [Google_Cloud_Osconfig_V1beta_SoftwareRecipe] = []

  /// The etag for this guest policy.
  /// If this is provided on update, it must match the server's etag.
  public var etag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _assignment: Google_Cloud_Osconfig_V1beta_Assignment? = nil
}

/// An assignment represents the group or groups of VM instances that the policy
/// applies to.
///
/// If an assignment is empty, it applies to all VM instances. Otherwise, the
/// targeted VM instances must meet all the criteria specified. So if both
/// labels and zones are specified, the policy applies to VM instances with those
/// labels and in those zones.
public struct Google_Cloud_Osconfig_V1beta_Assignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Targets instances matching at least one of these label sets. This allows
  /// an assignment to target disparate groups, for example "env=prod or
  /// env=staging".
  public var groupLabels: [Google_Cloud_Osconfig_V1beta_Assignment.GroupLabel] = []

  /// Targets instances in any of these zones. Leave empty to target instances
  /// in any zone.
  ///
  /// Zonal targeting is uncommon and is supported to facilitate the management
  /// of changes by zone.
  public var zones: [String] = []

  /// Targets any of the instances specified. Instances are specified by their
  /// URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`.
  ///
  /// Instance targeting is uncommon and is supported to facilitate the
  /// management of changes by the instance or to target specific VM instances
  /// for development and testing.
  ///
  /// Only supported for project-level policies and must reference instances
  /// within this project.
  public var instances: [String] = []

  /// Targets VM instances whose name starts with one of these prefixes.
  ///
  /// Like labels, this is another way to group VM instances when targeting
  /// configs, for example prefix="prod-".
  ///
  /// Only supported for project-level policies.
  public var instanceNamePrefixes: [String] = []

  /// Targets VM instances matching at least one of the following OS types.
  ///
  /// VM instances must match all supplied criteria for a given OsType to be
  /// included.
  public var osTypes: [Google_Cloud_Osconfig_V1beta_Assignment.OsType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents a group of VM intances that can be identified as having all
  /// these labels, for example "env=prod and app=web".
  public struct GroupLabel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Google Compute Engine instance labels that must be present for an
    /// instance to be included in this assignment group.
    public var labels: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Defines the criteria for selecting VM Instances by OS type.
  public struct OsType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Targets VM instances with OS Inventory enabled and having the following
    /// OS short name, for example "debian" or "windows".
    public var osShortName: String = String()

    /// Targets VM instances with OS Inventory enabled and having the following
    /// following OS version.
    public var osVersion: String = String()

    /// Targets VM instances with OS Inventory enabled and having the following
    /// OS architecture.
    public var osArchitecture: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Package is a reference to the software package to be installed or removed.
/// The agent on the VM instance uses the system package manager to apply the
/// config.
///
///
/// These are the commands that the agent uses to install or remove
/// packages.
///
/// Apt
/// install: `apt-get update && apt-get -y install package1 package2 package3`
/// remove: `apt-get -y remove package1 package2 package3`
///
/// Yum
/// install: `yum -y install package1 package2 package3`
/// remove: `yum -y remove package1 package2 package3`
///
/// Zypper
/// install: `zypper install package1 package2 package3`
/// remove: `zypper rm package1 package2`
///
/// Googet
/// install: `googet -noconfirm install package1 package2 package3`
/// remove: `googet -noconfirm remove package1 package2 package3`
public struct Google_Cloud_Osconfig_V1beta_Package {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the package. A package is uniquely identified for conflict
  /// validation by checking the package name and the manager(s) that the
  /// package targets.
  public var name: String = String()

  /// The desired_state the agent should maintain for this package. The
  /// default is to ensure the package is installed.
  public var desiredState: Google_Cloud_Osconfig_V1beta_DesiredState = .unspecified

  /// Type of package manager that can be used to install this package.
  /// If a system does not have the package manager, the package is not
  /// installed or removed no error message is returned. By default,
  /// or if you specify `ANY`,
  /// the agent attempts to install and remove this package using the default
  /// package manager. This is useful when creating a policy that applies to
  /// different types of systems.
  ///
  /// The default behavior is ANY.
  public var manager: Google_Cloud_Osconfig_V1beta_Package.Manager = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Types of package managers that may be used to manage this package.
  public enum Manager: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The default behavior is ANY.
    case unspecified // = 0

    /// Apply this package config using the default system package manager.
    case any // = 1

    /// Apply this package config only if Apt is available on the system.
    case apt // = 2

    /// Apply this package config only if Yum is available on the system.
    case yum // = 3

    /// Apply this package config only if Zypper is available on the system.
    case zypper // = 4

    /// Apply this package config only if GooGet is available on the system.
    case goo // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .any
      case 2: self = .apt
      case 3: self = .yum
      case 4: self = .zypper
      case 5: self = .goo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .any: return 1
      case .apt: return 2
      case .yum: return 3
      case .zypper: return 4
      case .goo: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1beta_Package.Manager: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1beta_Package.Manager] = [
    .unspecified,
    .any,
    .apt,
    .yum,
    .zypper,
    .goo,
  ]
}

#endif  // swift(>=4.2)

/// Represents a single Apt package repository. This repository is added to
/// a repo file that is stored at
/// `/etc/apt/sources.list.d/google_osconfig.list`.
public struct Google_Cloud_Osconfig_V1beta_AptRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of archive files in this repository. The default behavior is DEB.
  public var archiveType: Google_Cloud_Osconfig_V1beta_AptRepository.ArchiveType = .unspecified

  /// Required. URI for this repository.
  public var uri: String = String()

  /// Required. Distribution of this repository.
  public var distribution: String = String()

  /// Required. List of components for this repository. Must contain at least one item.
  public var components: [String] = []

  /// URI of the key file for this repository. The agent maintains
  /// a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing
  /// all the keys in any applied guest policy.
  public var gpgKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of archive.
  public enum ArchiveType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// DEB indicates that the archive contains binary files.
    case deb // = 1

    /// DEB_SRC indicates that the archive contains source files.
    case debSrc // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .deb
      case 2: self = .debSrc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .deb: return 1
      case .debSrc: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1beta_AptRepository.ArchiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1beta_AptRepository.ArchiveType] = [
    .unspecified,
    .deb,
    .debSrc,
  ]
}

#endif  // swift(>=4.2)

/// Represents a single Yum package repository. This repository is added to a
/// repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
public struct Google_Cloud_Osconfig_V1beta_YumRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A one word, unique name for this repository. This is
  /// the `repo id` in the Yum config file and also the `display_name` if
  /// `display_name` is omitted. This id is also used as the unique identifier
  /// when checking for guest policy conflicts.
  public var id: String = String()

  /// The display name of the repository.
  public var displayName: String = String()

  /// Required. The location of the repository directory.
  public var baseURL: String = String()

  /// URIs of GPG keys.
  public var gpgKeys: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a single Zypper package repository. This repository is added to a
/// repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
public struct Google_Cloud_Osconfig_V1beta_ZypperRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A one word, unique name for this repository. This is
  /// the `repo id` in the zypper config file and also the `display_name` if
  /// `display_name` is omitted. This id is also used as the unique identifier
  /// when checking for guest policy conflicts.
  public var id: String = String()

  /// The display name of the repository.
  public var displayName: String = String()

  /// Required. The location of the repository directory.
  public var baseURL: String = String()

  /// URIs of GPG keys.
  public var gpgKeys: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a Goo package repository. These is added to a repo file
/// that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
public struct Google_Cloud_Osconfig_V1beta_GooRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the repository.
  public var name: String = String()

  /// Required. The url of the repository.
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A package repository.
public struct Google_Cloud_Osconfig_V1beta_PackageRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A specific type of repository.
  public var repository: Google_Cloud_Osconfig_V1beta_PackageRepository.OneOf_Repository? = nil

  /// An Apt Repository.
  public var apt: Google_Cloud_Osconfig_V1beta_AptRepository {
    get {
      if case .apt(let v)? = repository {return v}
      return Google_Cloud_Osconfig_V1beta_AptRepository()
    }
    set {repository = .apt(newValue)}
  }

  /// A Yum Repository.
  public var yum: Google_Cloud_Osconfig_V1beta_YumRepository {
    get {
      if case .yum(let v)? = repository {return v}
      return Google_Cloud_Osconfig_V1beta_YumRepository()
    }
    set {repository = .yum(newValue)}
  }

  /// A Zypper Repository.
  public var zypper: Google_Cloud_Osconfig_V1beta_ZypperRepository {
    get {
      if case .zypper(let v)? = repository {return v}
      return Google_Cloud_Osconfig_V1beta_ZypperRepository()
    }
    set {repository = .zypper(newValue)}
  }

  /// A Goo Repository.
  public var goo: Google_Cloud_Osconfig_V1beta_GooRepository {
    get {
      if case .goo(let v)? = repository {return v}
      return Google_Cloud_Osconfig_V1beta_GooRepository()
    }
    set {repository = .goo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A specific type of repository.
  public enum OneOf_Repository: Equatable {
    /// An Apt Repository.
    case apt(Google_Cloud_Osconfig_V1beta_AptRepository)
    /// A Yum Repository.
    case yum(Google_Cloud_Osconfig_V1beta_YumRepository)
    /// A Zypper Repository.
    case zypper(Google_Cloud_Osconfig_V1beta_ZypperRepository)
    /// A Goo Repository.
    case goo(Google_Cloud_Osconfig_V1beta_GooRepository)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_V1beta_PackageRepository.OneOf_Repository, rhs: Google_Cloud_Osconfig_V1beta_PackageRepository.OneOf_Repository) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.apt, .apt): return {
        guard case .apt(let l) = lhs, case .apt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yum, .yum): return {
        guard case .yum(let l) = lhs, case .yum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zypper, .zypper): return {
        guard case .zypper(let l) = lhs, case .zypper(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.goo, .goo): return {
        guard case .goo(let l) = lhs, case .goo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A software recipe is a set of instructions for installing and configuring a
/// piece of software. It consists of a set of artifacts that are
/// downloaded, and a set of steps that install, configure, and/or update the
/// software.
///
/// Recipes support installing and updating software from artifacts in the
/// following formats:
/// Zip archive, Tar archive, Windows MSI, Debian package, and RPM package.
///
/// Additionally, recipes support executing a script (either defined in a file or
/// directly in this api) in bash, sh, cmd, and powershell.
///
/// Updating a software recipe
///
/// If a recipe is assigned to an instance and there is a recipe with the same
/// name but a lower version already installed and the assigned state
/// of the recipe is `INSTALLED_KEEP_UPDATED`, then the recipe is updated to
/// the new version.
///
/// Script Working Directories
///
/// Each script or execution step is run in its own temporary directory which
/// is deleted after completing the step.
public struct Google_Cloud_Osconfig_V1beta_SoftwareRecipe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Unique identifier for the recipe. Only one recipe with a given name is
  /// installed on an instance.
  ///
  /// Names are also used to identify resources which helps to determine whether
  /// guest policies have conflicts. This means that requests to create multiple
  /// recipes with the same name and version are rejected since they
  /// could potentially have conflicting assignments.
  public var name: String = String()

  /// The version of this software recipe. Version can be up to 4 period
  /// separated numbers (e.g. 12.34.56.78).
  public var version: String = String()

  /// Resources available to be used in the steps in the recipe.
  public var artifacts: [Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact] = []

  /// Actions to be taken for installing this recipe. On failure it stops
  /// executing steps and does not attempt another installation. Any steps taken
  /// (including partially completed steps) are not rolled back.
  public var installSteps: [Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step] = []

  /// Actions to be taken for updating this recipe. On failure it stops
  /// executing steps and  does not attempt another update for this recipe. Any
  /// steps taken (including partially completed steps) are not rolled back.
  public var updateSteps: [Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step] = []

  /// Default is INSTALLED. The desired state the agent should maintain for this
  /// recipe.
  ///
  /// INSTALLED: The software recipe is installed on the instance but
  ///            won't be updated to new versions.
  /// INSTALLED_KEEP_UPDATED: The software recipe is installed on the
  ///                         instance. The recipe is updated to a higher
  ///                         version, if a higher version of the recipe is
  ///                         assigned to this instance.
  /// REMOVE: Remove is unsupported for software recipes and attempts to
  ///         create or update a recipe to the REMOVE state is rejected.
  public var desiredState: Google_Cloud_Osconfig_V1beta_DesiredState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies a resource to be used in the recipe.
  public struct Artifact {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Id of the artifact, which the installation and update steps of this
    /// recipe can reference. Artifacts in a recipe cannot have the same id.
    public var id: String = String()

    /// A specific type of artifact.
    public var artifact: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.OneOf_Artifact? = nil

    /// A generic remote artifact.
    public var remote: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote {
      get {
        if case .remote(let v)? = artifact {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote()
      }
      set {artifact = .remote(newValue)}
    }

    /// A Google Cloud Storage artifact.
    public var gcs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs {
      get {
        if case .gcs(let v)? = artifact {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs()
      }
      set {artifact = .gcs(newValue)}
    }

    /// Defaults to false. When false, recipes are subject to validations
    /// based on the artifact type:
    ///
    /// Remote: A checksum must be specified, and only protocols with
    /// transport-layer security are permitted.
    /// GCS:    An object generation number must be specified.
    public var allowInsecure: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A specific type of artifact.
    public enum OneOf_Artifact: Equatable {
      /// A generic remote artifact.
      case remote(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote)
      /// A Google Cloud Storage artifact.
      case gcs(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.OneOf_Artifact, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.OneOf_Artifact) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.remote, .remote): return {
          guard case .remote(let l) = lhs, case .remote(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.gcs, .gcs): return {
          guard case .gcs(let l) = lhs, case .gcs(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Specifies an artifact available via some URI.
    public struct Remote {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// URI from which to fetch the object. It should contain both the protocol
      /// and path following the format {protocol}://{location}.
      public var uri: String = String()

      /// Must be provided if `allow_insecure` is `false`.
      /// SHA256 checksum in hex format, to compare to the checksum of the
      /// artifact. If the checksum is not empty and it doesn't match the
      /// artifact then the recipe installation fails before running any of the
      /// steps.
      public var checksum: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Specifies an artifact available as a Google Cloud Storage object.
    public struct Gcs {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Bucket of the Google Cloud Storage object.
      /// Given an example URL:
      /// `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
      /// this value would be `my-bucket`.
      public var bucket: String = String()

      /// Name of the Google Cloud Storage object.
      /// As specified [here]
      /// (https://cloud.google.com/storage/docs/naming#objectnames)
      /// Given an example URL:
      /// `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
      /// this value would be `foo/bar`.
      public var object: String = String()

      /// Must be provided if allow_insecure is false.
      /// Generation number of the Google Cloud Storage object.
      /// `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
      /// this value would be `1234567`.
      public var generation: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// An action that can be taken as part of installing or updating a recipe.
  public struct Step {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A specific type of step.
    public var step: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.OneOf_Step? = nil

    /// Copies a file onto the instance.
    public var fileCopy: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile {
      get {
        if case .fileCopy(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile()
      }
      set {step = .fileCopy(newValue)}
    }

    /// Extracts an archive into the specified directory.
    public var archiveExtraction: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive {
      get {
        if case .archiveExtraction(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive()
      }
      set {step = .archiveExtraction(newValue)}
    }

    /// Installs an MSI file.
    public var msiInstallation: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi {
      get {
        if case .msiInstallation(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi()
      }
      set {step = .msiInstallation(newValue)}
    }

    /// Installs a deb file via dpkg.
    public var dpkgInstallation: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg {
      get {
        if case .dpkgInstallation(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg()
      }
      set {step = .dpkgInstallation(newValue)}
    }

    /// Installs an rpm file via the rpm utility.
    public var rpmInstallation: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm {
      get {
        if case .rpmInstallation(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm()
      }
      set {step = .rpmInstallation(newValue)}
    }

    /// Executes an artifact or local file.
    public var fileExec: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile {
      get {
        if case .fileExec(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile()
      }
      set {step = .fileExec(newValue)}
    }

    /// Runs commands in a shell.
    public var scriptRun: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript {
      get {
        if case .scriptRun(let v)? = step {return v}
        return Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript()
      }
      set {step = .scriptRun(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A specific type of step.
    public enum OneOf_Step: Equatable {
      /// Copies a file onto the instance.
      case fileCopy(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile)
      /// Extracts an archive into the specified directory.
      case archiveExtraction(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive)
      /// Installs an MSI file.
      case msiInstallation(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi)
      /// Installs a deb file via dpkg.
      case dpkgInstallation(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg)
      /// Installs an rpm file via the rpm utility.
      case rpmInstallation(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm)
      /// Executes an artifact or local file.
      case fileExec(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile)
      /// Runs commands in a shell.
      case scriptRun(Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.OneOf_Step, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.OneOf_Step) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fileCopy, .fileCopy): return {
          guard case .fileCopy(let l) = lhs, case .fileCopy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.archiveExtraction, .archiveExtraction): return {
          guard case .archiveExtraction(let l) = lhs, case .archiveExtraction(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.msiInstallation, .msiInstallation): return {
          guard case .msiInstallation(let l) = lhs, case .msiInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.dpkgInstallation, .dpkgInstallation): return {
          guard case .dpkgInstallation(let l) = lhs, case .dpkgInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.rpmInstallation, .rpmInstallation): return {
          guard case .rpmInstallation(let l) = lhs, case .rpmInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.fileExec, .fileExec): return {
          guard case .fileExec(let l) = lhs, case .fileExec(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scriptRun, .scriptRun): return {
          guard case .scriptRun(let l) = lhs, case .scriptRun(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Copies the artifact to the specified path on the instance.
    public struct CopyFile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      /// Required. The absolute path on the instance to put the file.
      public var destination: String = String()

      /// Whether to allow this step to overwrite existing files. If this is
      /// false and the file already exists the file is not overwritten
      /// and the step is considered a success. Defaults to false.
      public var overwrite: Bool = false

      /// Consists of three octal digits which represent, in
      /// order, the permissions of the owner, group, and other users for the
      /// file (similarly to the numeric mode used in the linux chmod utility).
      /// Each digit represents a three bit number with the 4 bit
      /// corresponding to the read permissions, the 2 bit corresponds to the
      /// write bit, and the one bit corresponds to the execute permission.
      /// Default behavior is 755.
      ///
      /// Below are some examples of permissions and their associated values:
      /// read, write, and execute: 7
      /// read and execute: 5
      /// read and write: 6
      /// read only: 4
      public var permissions: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Extracts an archive of the type specified in the specified directory.
    public struct ExtractArchive {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      /// Directory to extract archive to.
      /// Defaults to `/` on Linux or `C:\` on Windows.
      public var destination: String = String()

      /// Required. The type of the archive to extract.
      public var type: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Specifying the type of archive.
      public enum ArchiveType: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Indicates that the archive type isn't specified.
        case unspecified // = 0

        /// Indicates that the archive is a tar archive with no encryption.
        case tar // = 1

        /// Indicates that the archive is a tar archive with gzip encryption.
        case tarGzip // = 2

        /// Indicates that the archive is a tar archive with bzip encryption.
        case tarBzip // = 3

        /// Indicates that the archive is a tar archive with lzma encryption.
        case tarLzma // = 4

        /// Indicates that the archive is a tar archive with xz encryption.
        case tarXz // = 5

        /// Indicates that the archive is a zip archive.
        case zip // = 11
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .tar
          case 2: self = .tarGzip
          case 3: self = .tarBzip
          case 4: self = .tarLzma
          case 5: self = .tarXz
          case 11: self = .zip
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .tar: return 1
          case .tarGzip: return 2
          case .tarBzip: return 3
          case .tarLzma: return 4
          case .tarXz: return 5
          case .zip: return 11
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    /// Installs an MSI file.
    public struct InstallMsi {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      /// The flags to use when installing the MSI
      /// defaults to ["/i"] (i.e. the install flag).
      public var flags: [String] = []

      /// Return codes that indicate that the software installed or updated
      /// successfully. Behaviour defaults to [0]
      public var allowedExitCodes: [Int32] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Installs a deb via dpkg.
    public struct InstallDpkg {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Installs an rpm file via the rpm utility.
    public struct InstallRpm {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Executes an artifact or local file.
    public struct ExecFile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Location of the file to execute.
      public var locationType: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile.OneOf_LocationType? = nil

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String {
        get {
          if case .artifactID(let v)? = locationType {return v}
          return String()
        }
        set {locationType = .artifactID(newValue)}
      }

      /// The absolute path of the file on the local filesystem.
      public var localPath: String {
        get {
          if case .localPath(let v)? = locationType {return v}
          return String()
        }
        set {locationType = .localPath(newValue)}
      }

      /// Arguments to be passed to the provided executable.
      public var args: [String] = []

      /// Defaults to [0]. A list of possible return values that the program
      /// can return to indicate a success.
      public var allowedExitCodes: [Int32] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Location of the file to execute.
      public enum OneOf_LocationType: Equatable {
        /// The id of the relevant artifact in the recipe.
        case artifactID(String)
        /// The absolute path of the file on the local filesystem.
        case localPath(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile.OneOf_LocationType, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile.OneOf_LocationType) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.artifactID, .artifactID): return {
            guard case .artifactID(let l) = lhs, case .artifactID(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.localPath, .localPath): return {
            guard case .localPath(let l) = lhs, case .localPath(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// Runs a script through an interpreter.
    public struct RunScript {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The shell script to be executed.
      public var script: String = String()

      /// Return codes that indicate that the software installed or updated
      /// successfully. Behaviour defaults to [0]
      public var allowedExitCodes: [Int32] = []

      /// The script interpreter to use to run the script. If no interpreter is
      /// specified the script is executed directly, which likely
      /// only succeed for scripts with
      /// [shebang lines](https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
      public var interpreter: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript.Interpreter = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The interpreter used to execute a script.
      public enum Interpreter: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Default value for ScriptType.
        case unspecified // = 0

        /// Indicates that the script is run with `/bin/sh` on Linux and `cmd`
        /// on windows.
        case shell // = 1

        /// Indicates that the script is run with powershell.
        case powershell // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .shell
          case 3: self = .powershell
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .shell: return 1
          case .powershell: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType] = [
    .unspecified,
    .tar,
    .tarGzip,
    .tarBzip,
    .tarLzma,
    .tarXz,
    .zip,
  ]
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript.Interpreter: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript.Interpreter] = [
    .unspecified,
    .shell,
    .powershell,
  ]
}

#endif  // swift(>=4.2)

/// A request message for creating a guest policy.
public struct Google_Cloud_Osconfig_V1beta_CreateGuestPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the parent using one of the following forms:
  /// `projects/{project_number}`.
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Required. The logical name of the guest policy in the project
  /// with the following restrictions:
  ///
  /// * Must contain only lowercase letters, numbers, and hyphens.
  /// * Must start with a letter.
  /// * Must be between 1-63 characters.
  /// * Must end with a number or a letter.
  /// * Must be unique within the project.
  public var guestPolicyID: String {
    get {return _storage._guestPolicyID}
    set {_uniqueStorage()._guestPolicyID = newValue}
  }

  /// Required. The GuestPolicy to create.
  public var guestPolicy: Google_Cloud_Osconfig_V1beta_GuestPolicy {
    get {return _storage._guestPolicy ?? Google_Cloud_Osconfig_V1beta_GuestPolicy()}
    set {_uniqueStorage()._guestPolicy = newValue}
  }
  /// Returns true if `guestPolicy` has been explicitly set.
  public var hasGuestPolicy: Bool {return _storage._guestPolicy != nil}
  /// Clears the value of `guestPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearGuestPolicy() {_uniqueStorage()._guestPolicy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A request message for retrieving a guest policy.
public struct Google_Cloud_Osconfig_V1beta_GetGuestPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the guest policy using one of the following forms:
  /// `projects/{project_number}/guestPolicies/{guest_policy_id}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for listing guest policies.
public struct Google_Cloud_Osconfig_V1beta_ListGuestPoliciesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the parent using one of the following forms:
  /// `projects/{project_number}`.
  public var parent: String = String()

  /// The maximum number of guest policies to return.
  public var pageSize: Int32 = 0

  /// A pagination token returned from a previous call to `ListGuestPolicies`
  /// that indicates where this listing should continue from.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for listing guest policies.
public struct Google_Cloud_Osconfig_V1beta_ListGuestPoliciesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of GuestPolicies.
  public var guestPolicies: [Google_Cloud_Osconfig_V1beta_GuestPolicy] = []

  /// A pagination token that can be used to get the next page
  /// of guest policies.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for updating a guest policy.
public struct Google_Cloud_Osconfig_V1beta_UpdateGuestPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated GuestPolicy.
  public var guestPolicy: Google_Cloud_Osconfig_V1beta_GuestPolicy {
    get {return _guestPolicy ?? Google_Cloud_Osconfig_V1beta_GuestPolicy()}
    set {_guestPolicy = newValue}
  }
  /// Returns true if `guestPolicy` has been explicitly set.
  public var hasGuestPolicy: Bool {return self._guestPolicy != nil}
  /// Clears the value of `guestPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearGuestPolicy() {self._guestPolicy = nil}

  /// Field mask that controls which fields of the guest policy should be
  /// updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _guestPolicy: Google_Cloud_Osconfig_V1beta_GuestPolicy? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// A request message for deleting a guest policy.
public struct Google_Cloud_Osconfig_V1beta_DeleteGuestPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the guest policy  using one of the following forms:
  /// `projects/{project_number}/guestPolicies/{guest_policy_id}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for getting the effective guest policy assigned to the
/// instance.
public struct Google_Cloud_Osconfig_V1beta_LookupEffectiveGuestPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The VM instance whose policies are being looked up.
  public var instance: String = String()

  /// Short name of the OS running on the instance. The OS Config agent only
  /// provides this field for targeting if OS Inventory is enabled for that
  /// instance.
  public var osShortName: String = String()

  /// Version of the OS running on the instance. The OS Config agent only
  /// provides this field for targeting if OS Inventory is enabled for that
  /// VM instance.
  public var osVersion: String = String()

  /// Architecture of OS running on the instance. The OS Config agent only
  /// provides this field for targeting if OS Inventory is enabled for that
  /// instance.
  public var osArchitecture: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The effective guest policy that applies to a VM instance.
public struct Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of package configurations assigned to the VM instance.
  public var packages: [Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackage] = []

  /// List of package repository configurations assigned to the VM instance.
  public var packageRepositories: [Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackageRepository] = []

  /// List of recipes assigned to the VM instance.
  public var softwareRecipes: [Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A guest policy package including its source.
  public struct SourcedPackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the guest policy providing this config.
    public var source: String = String()

    /// A software package to configure on the VM instance.
    public var package: Google_Cloud_Osconfig_V1beta_Package {
      get {return _package ?? Google_Cloud_Osconfig_V1beta_Package()}
      set {_package = newValue}
    }
    /// Returns true if `package` has been explicitly set.
    public var hasPackage: Bool {return self._package != nil}
    /// Clears the value of `package`. Subsequent reads from it will return its default value.
    public mutating func clearPackage() {self._package = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _package: Google_Cloud_Osconfig_V1beta_Package? = nil
  }

  /// A guest policy package repository including its source.
  public struct SourcedPackageRepository {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the guest policy providing this config.
    public var source: String = String()

    /// A software package repository to configure on the VM instance.
    public var packageRepository: Google_Cloud_Osconfig_V1beta_PackageRepository {
      get {return _packageRepository ?? Google_Cloud_Osconfig_V1beta_PackageRepository()}
      set {_packageRepository = newValue}
    }
    /// Returns true if `packageRepository` has been explicitly set.
    public var hasPackageRepository: Bool {return self._packageRepository != nil}
    /// Clears the value of `packageRepository`. Subsequent reads from it will return its default value.
    public mutating func clearPackageRepository() {self._packageRepository = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _packageRepository: Google_Cloud_Osconfig_V1beta_PackageRepository? = nil
  }

  /// A guest policy recipe including its source.
  public struct SourcedSoftwareRecipe {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the guest policy providing this config.
    public var source: String = String()

    /// A software recipe to configure on the VM instance.
    public var softwareRecipe: Google_Cloud_Osconfig_V1beta_SoftwareRecipe {
      get {return _softwareRecipe ?? Google_Cloud_Osconfig_V1beta_SoftwareRecipe()}
      set {_softwareRecipe = newValue}
    }
    /// Returns true if `softwareRecipe` has been explicitly set.
    public var hasSoftwareRecipe: Bool {return self._softwareRecipe != nil}
    /// Clears the value of `softwareRecipe`. Subsequent reads from it will return its default value.
    public mutating func clearSoftwareRecipe() {self._softwareRecipe = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _softwareRecipe: Google_Cloud_Osconfig_V1beta_SoftwareRecipe? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.osconfig.v1beta"

extension Google_Cloud_Osconfig_V1beta_DesiredState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESIRED_STATE_UNSPECIFIED"),
    1: .same(proto: "INSTALLED"),
    2: .same(proto: "UPDATED"),
    3: .same(proto: "REMOVED"),
  ]
}

extension Google_Cloud_Osconfig_V1beta_GuestPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GuestPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "update_time"),
    6: .same(proto: "assignment"),
    7: .same(proto: "packages"),
    8: .standard(proto: "package_repositories"),
    9: .same(proto: "recipes"),
    10: .same(proto: "etag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._assignment) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.packages) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.packageRepositories) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.recipes) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._assignment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.packages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packages, fieldNumber: 7)
    }
    if !self.packageRepositories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packageRepositories, fieldNumber: 8)
    }
    if !self.recipes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recipes, fieldNumber: 9)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_GuestPolicy, rhs: Google_Cloud_Osconfig_V1beta_GuestPolicy) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs._assignment != rhs._assignment {return false}
    if lhs.packages != rhs.packages {return false}
    if lhs.packageRepositories != rhs.packageRepositories {return false}
    if lhs.recipes != rhs.recipes {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_Assignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Assignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_labels"),
    2: .same(proto: "zones"),
    3: .same(proto: "instances"),
    4: .standard(proto: "instance_name_prefixes"),
    5: .standard(proto: "os_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupLabels) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.zones) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.instances) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.instanceNamePrefixes) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.osTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupLabels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupLabels, fieldNumber: 1)
    }
    if !self.zones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.zones, fieldNumber: 2)
    }
    if !self.instances.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instances, fieldNumber: 3)
    }
    if !self.instanceNamePrefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instanceNamePrefixes, fieldNumber: 4)
    }
    if !self.osTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.osTypes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_Assignment, rhs: Google_Cloud_Osconfig_V1beta_Assignment) -> Bool {
    if lhs.groupLabels != rhs.groupLabels {return false}
    if lhs.zones != rhs.zones {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.instanceNamePrefixes != rhs.instanceNamePrefixes {return false}
    if lhs.osTypes != rhs.osTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_Assignment.GroupLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_Assignment.protoMessageName + ".GroupLabel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_Assignment.GroupLabel, rhs: Google_Cloud_Osconfig_V1beta_Assignment.GroupLabel) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_Assignment.OsType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_Assignment.protoMessageName + ".OsType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "os_short_name"),
    2: .standard(proto: "os_version"),
    3: .standard(proto: "os_architecture"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.osShortName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.osArchitecture) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.osShortName.isEmpty {
      try visitor.visitSingularStringField(value: self.osShortName, fieldNumber: 1)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 2)
    }
    if !self.osArchitecture.isEmpty {
      try visitor.visitSingularStringField(value: self.osArchitecture, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_Assignment.OsType, rhs: Google_Cloud_Osconfig_V1beta_Assignment.OsType) -> Bool {
    if lhs.osShortName != rhs.osShortName {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.osArchitecture != rhs.osArchitecture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_Package: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Package"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "desired_state"),
    3: .same(proto: "manager"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.desiredState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.manager) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.desiredState != .unspecified {
      try visitor.visitSingularEnumField(value: self.desiredState, fieldNumber: 2)
    }
    if self.manager != .unspecified {
      try visitor.visitSingularEnumField(value: self.manager, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_Package, rhs: Google_Cloud_Osconfig_V1beta_Package) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.desiredState != rhs.desiredState {return false}
    if lhs.manager != rhs.manager {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_Package.Manager: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANAGER_UNSPECIFIED"),
    1: .same(proto: "ANY"),
    2: .same(proto: "APT"),
    3: .same(proto: "YUM"),
    4: .same(proto: "ZYPPER"),
    5: .same(proto: "GOO"),
  ]
}

extension Google_Cloud_Osconfig_V1beta_AptRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AptRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "archive_type"),
    2: .same(proto: "uri"),
    3: .same(proto: "distribution"),
    4: .same(proto: "components"),
    5: .standard(proto: "gpg_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.archiveType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.distribution) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.components) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.gpgKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.archiveType != .unspecified {
      try visitor.visitSingularEnumField(value: self.archiveType, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.distribution.isEmpty {
      try visitor.visitSingularStringField(value: self.distribution, fieldNumber: 3)
    }
    if !self.components.isEmpty {
      try visitor.visitRepeatedStringField(value: self.components, fieldNumber: 4)
    }
    if !self.gpgKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gpgKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_AptRepository, rhs: Google_Cloud_Osconfig_V1beta_AptRepository) -> Bool {
    if lhs.archiveType != rhs.archiveType {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.distribution != rhs.distribution {return false}
    if lhs.components != rhs.components {return false}
    if lhs.gpgKey != rhs.gpgKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_AptRepository.ArchiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARCHIVE_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEB"),
    2: .same(proto: "DEB_SRC"),
  ]
}

extension Google_Cloud_Osconfig_V1beta_YumRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".YumRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "base_url"),
    4: .standard(proto: "gpg_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseURL) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.gpgKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.baseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURL, fieldNumber: 3)
    }
    if !self.gpgKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gpgKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_YumRepository, rhs: Google_Cloud_Osconfig_V1beta_YumRepository) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.baseURL != rhs.baseURL {return false}
    if lhs.gpgKeys != rhs.gpgKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_ZypperRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ZypperRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "base_url"),
    4: .standard(proto: "gpg_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseURL) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.gpgKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.baseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURL, fieldNumber: 3)
    }
    if !self.gpgKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gpgKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_ZypperRepository, rhs: Google_Cloud_Osconfig_V1beta_ZypperRepository) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.baseURL != rhs.baseURL {return false}
    if lhs.gpgKeys != rhs.gpgKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_GooRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GooRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_GooRepository, rhs: Google_Cloud_Osconfig_V1beta_GooRepository) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_PackageRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apt"),
    2: .same(proto: "yum"),
    3: .same(proto: "zypper"),
    4: .same(proto: "goo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Osconfig_V1beta_AptRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .apt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .apt(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_V1beta_YumRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .yum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .yum(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_V1beta_ZypperRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .zypper(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .zypper(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Osconfig_V1beta_GooRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .goo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .goo(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.repository {
    case .apt?: try {
      guard case .apt(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .yum?: try {
      guard case .yum(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .zypper?: try {
      guard case .zypper(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .goo?: try {
      guard case .goo(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_PackageRepository, rhs: Google_Cloud_Osconfig_V1beta_PackageRepository) -> Bool {
    if lhs.repository != rhs.repository {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoftwareRecipe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
    3: .same(proto: "artifacts"),
    4: .standard(proto: "install_steps"),
    5: .standard(proto: "update_steps"),
    6: .standard(proto: "desired_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.artifacts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.installSteps) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.updateSteps) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.desiredState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.artifacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifacts, fieldNumber: 3)
    }
    if !self.installSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.installSteps, fieldNumber: 4)
    }
    if !self.updateSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateSteps, fieldNumber: 5)
    }
    if self.desiredState != .unspecified {
      try visitor.visitSingularEnumField(value: self.desiredState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.artifacts != rhs.artifacts {return false}
    if lhs.installSteps != rhs.installSteps {return false}
    if lhs.updateSteps != rhs.updateSteps {return false}
    if lhs.desiredState != rhs.desiredState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.protoMessageName + ".Artifact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "remote"),
    3: .same(proto: "gcs"),
    4: .standard(proto: "allow_insecure"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote?
        if let current = self.artifact {
          try decoder.handleConflictingOneOf()
          if case .remote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.artifact = .remote(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs?
        if let current = self.artifact {
          try decoder.handleConflictingOneOf()
          if case .gcs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.artifact = .gcs(v)}
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowInsecure) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.artifact {
    case .remote?: try {
      guard case .remote(let v)? = self.artifact else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .gcs?: try {
      guard case .gcs(let v)? = self.artifact else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.allowInsecure != false {
      try visitor.visitSingularBoolField(value: self.allowInsecure, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.artifact != rhs.artifact {return false}
    if lhs.allowInsecure != rhs.allowInsecure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.protoMessageName + ".Remote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Remote) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.protoMessageName + ".Gcs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "object"),
    3: .same(proto: "generation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.generation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 2)
    }
    if self.generation != 0 {
      try visitor.visitSingularInt64Field(value: self.generation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Artifact.Gcs) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.object != rhs.object {return false}
    if lhs.generation != rhs.generation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.protoMessageName + ".Step"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_copy"),
    2: .standard(proto: "archive_extraction"),
    3: .standard(proto: "msi_installation"),
    4: .standard(proto: "dpkg_installation"),
    5: .standard(proto: "rpm_installation"),
    6: .standard(proto: "file_exec"),
    7: .standard(proto: "script_run"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .fileCopy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .fileCopy(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .archiveExtraction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .archiveExtraction(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .msiInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .msiInstallation(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .dpkgInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .dpkgInstallation(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .rpmInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .rpmInstallation(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .fileExec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .fileExec(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .scriptRun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .scriptRun(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.step {
    case .fileCopy?: try {
      guard case .fileCopy(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .archiveExtraction?: try {
      guard case .archiveExtraction(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .msiInstallation?: try {
      guard case .msiInstallation(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dpkgInstallation?: try {
      guard case .dpkgInstallation(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rpmInstallation?: try {
      guard case .rpmInstallation(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fileExec?: try {
      guard case .fileExec(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .scriptRun?: try {
      guard case .scriptRun(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".CopyFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .same(proto: "destination"),
    3: .same(proto: "overwrite"),
    4: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.overwrite) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 2)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 3)
    }
    if !self.permissions.isEmpty {
      try visitor.visitSingularStringField(value: self.permissions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.CopyFile) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".ExtractArchive"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .same(proto: "destination"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARCHIVE_TYPE_UNSPECIFIED"),
    1: .same(proto: "TAR"),
    2: .same(proto: "TAR_GZIP"),
    3: .same(proto: "TAR_BZIP"),
    4: .same(proto: "TAR_LZMA"),
    5: .same(proto: "TAR_XZ"),
    11: .same(proto: "ZIP"),
  ]
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".InstallMsi"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .same(proto: "flags"),
    3: .standard(proto: "allowed_exit_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.flags) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedExitCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.flags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.flags, fieldNumber: 2)
    }
    if !self.allowedExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedExitCodes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallMsi) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.allowedExitCodes != rhs.allowedExitCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".InstallDpkg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallDpkg) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".InstallRpm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.InstallRpm) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".ExecFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .standard(proto: "local_path"),
    3: .same(proto: "args"),
    4: .standard(proto: "allowed_exit_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.locationType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationType = .artifactID(v)}
      }()
      case 2: try {
        if self.locationType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationType = .localPath(v)}
      }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedExitCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.locationType {
    case .artifactID?: try {
      guard case .artifactID(let v)? = self.locationType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .localPath?: try {
      guard case .localPath(let v)? = self.locationType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 3)
    }
    if !self.allowedExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedExitCodes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.ExecFile) -> Bool {
    if lhs.locationType != rhs.locationType {return false}
    if lhs.args != rhs.args {return false}
    if lhs.allowedExitCodes != rhs.allowedExitCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.protoMessageName + ".RunScript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "script"),
    2: .standard(proto: "allowed_exit_codes"),
    3: .same(proto: "interpreter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.script) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedExitCodes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.interpreter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.script.isEmpty {
      try visitor.visitSingularStringField(value: self.script, fieldNumber: 1)
    }
    if !self.allowedExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedExitCodes, fieldNumber: 2)
    }
    if self.interpreter != .unspecified {
      try visitor.visitSingularEnumField(value: self.interpreter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript, rhs: Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript) -> Bool {
    if lhs.script != rhs.script {return false}
    if lhs.allowedExitCodes != rhs.allowedExitCodes {return false}
    if lhs.interpreter != rhs.interpreter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_SoftwareRecipe.Step.RunScript.Interpreter: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERPRETER_UNSPECIFIED"),
    1: .same(proto: "SHELL"),
    3: .same(proto: "POWERSHELL"),
  ]
}

extension Google_Cloud_Osconfig_V1beta_CreateGuestPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGuestPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "guest_policy_id"),
    3: .standard(proto: "guest_policy"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _guestPolicyID: String = String()
    var _guestPolicy: Google_Cloud_Osconfig_V1beta_GuestPolicy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _guestPolicyID = source._guestPolicyID
      _guestPolicy = source._guestPolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._guestPolicyID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._guestPolicy) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      if !_storage._guestPolicyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._guestPolicyID, fieldNumber: 2)
      }
      if let v = _storage._guestPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_CreateGuestPolicyRequest, rhs: Google_Cloud_Osconfig_V1beta_CreateGuestPolicyRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._guestPolicyID != rhs_storage._guestPolicyID {return false}
        if _storage._guestPolicy != rhs_storage._guestPolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_GetGuestPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGuestPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_GetGuestPolicyRequest, rhs: Google_Cloud_Osconfig_V1beta_GetGuestPolicyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_ListGuestPoliciesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGuestPoliciesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_ListGuestPoliciesRequest, rhs: Google_Cloud_Osconfig_V1beta_ListGuestPoliciesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_ListGuestPoliciesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGuestPoliciesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guest_policies"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.guestPolicies) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.guestPolicies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.guestPolicies, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_ListGuestPoliciesResponse, rhs: Google_Cloud_Osconfig_V1beta_ListGuestPoliciesResponse) -> Bool {
    if lhs.guestPolicies != rhs.guestPolicies {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_UpdateGuestPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGuestPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "guest_policy"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._guestPolicy) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._guestPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_UpdateGuestPolicyRequest, rhs: Google_Cloud_Osconfig_V1beta_UpdateGuestPolicyRequest) -> Bool {
    if lhs._guestPolicy != rhs._guestPolicy {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_DeleteGuestPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGuestPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_DeleteGuestPolicyRequest, rhs: Google_Cloud_Osconfig_V1beta_DeleteGuestPolicyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_LookupEffectiveGuestPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookupEffectiveGuestPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "os_short_name"),
    3: .standard(proto: "os_version"),
    4: .standard(proto: "os_architecture"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instance) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osShortName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osArchitecture) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instance.isEmpty {
      try visitor.visitSingularStringField(value: self.instance, fieldNumber: 1)
    }
    if !self.osShortName.isEmpty {
      try visitor.visitSingularStringField(value: self.osShortName, fieldNumber: 2)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 3)
    }
    if !self.osArchitecture.isEmpty {
      try visitor.visitSingularStringField(value: self.osArchitecture, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_LookupEffectiveGuestPolicyRequest, rhs: Google_Cloud_Osconfig_V1beta_LookupEffectiveGuestPolicyRequest) -> Bool {
    if lhs.instance != rhs.instance {return false}
    if lhs.osShortName != rhs.osShortName {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.osArchitecture != rhs.osArchitecture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EffectiveGuestPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packages"),
    2: .standard(proto: "package_repositories"),
    3: .standard(proto: "software_recipes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.packages) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.packageRepositories) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.softwareRecipes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packages, fieldNumber: 1)
    }
    if !self.packageRepositories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packageRepositories, fieldNumber: 2)
    }
    if !self.softwareRecipes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.softwareRecipes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy, rhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy) -> Bool {
    if lhs.packages != rhs.packages {return false}
    if lhs.packageRepositories != rhs.packageRepositories {return false}
    if lhs.softwareRecipes != rhs.softwareRecipes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.protoMessageName + ".SourcedPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "package"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackage, rhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackage) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._package != rhs._package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackageRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.protoMessageName + ".SourcedPackageRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "package_repository"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._packageRepository) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if let v = self._packageRepository {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackageRepository, rhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedPackageRepository) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._packageRepository != rhs._packageRepository {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.protoMessageName + ".SourcedSoftwareRecipe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "software_recipe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._softwareRecipe) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if let v = self._softwareRecipe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe, rhs: Google_Cloud_Osconfig_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._softwareRecipe != rhs._softwareRecipe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

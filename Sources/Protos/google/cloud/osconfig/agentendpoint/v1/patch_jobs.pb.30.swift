// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/osconfig/agentendpoint/v1/patch_jobs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Patch configuration specifications. Contains details on how to
/// apply patches to a VM instance.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Post-patch reboot settings.
  public var rebootConfig: Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig.RebootConfig {
    get {return _storage._rebootConfig}
    set {_uniqueStorage()._rebootConfig = newValue}
  }

  /// Retry strategy can be defined to have the agent retry patching
  /// during the window if patching fails. If omitted, the agent will use its
  /// default retry strategy.
  public var retryStrategy: Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy {
    get {return _storage._retryStrategy ?? Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy()}
    set {_uniqueStorage()._retryStrategy = newValue}
  }
  /// Returns true if `retryStrategy` has been explicitly set.
  public var hasRetryStrategy: Bool {return _storage._retryStrategy != nil}
  /// Clears the value of `retryStrategy`. Subsequent reads from it will return its default value.
  public mutating func clearRetryStrategy() {_uniqueStorage()._retryStrategy = nil}

  /// Apt update settings. Use this override the default apt patch rules.
  public var apt: Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings {
    get {return _storage._apt ?? Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings()}
    set {_uniqueStorage()._apt = newValue}
  }
  /// Returns true if `apt` has been explicitly set.
  public var hasApt: Bool {return _storage._apt != nil}
  /// Clears the value of `apt`. Subsequent reads from it will return its default value.
  public mutating func clearApt() {_uniqueStorage()._apt = nil}

  /// Yum update settings. Use this override the default yum patch rules.
  public var yum: Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings {
    get {return _storage._yum ?? Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings()}
    set {_uniqueStorage()._yum = newValue}
  }
  /// Returns true if `yum` has been explicitly set.
  public var hasYum: Bool {return _storage._yum != nil}
  /// Clears the value of `yum`. Subsequent reads from it will return its default value.
  public mutating func clearYum() {_uniqueStorage()._yum = nil}

  /// Goo update settings. Use this override the default goo patch rules.
  public var goo: Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings {
    get {return _storage._goo ?? Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings()}
    set {_uniqueStorage()._goo = newValue}
  }
  /// Returns true if `goo` has been explicitly set.
  public var hasGoo: Bool {return _storage._goo != nil}
  /// Clears the value of `goo`. Subsequent reads from it will return its default value.
  public mutating func clearGoo() {_uniqueStorage()._goo = nil}

  /// Zypper update settings. Use this override the default zypper patch rules.
  public var zypper: Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings {
    get {return _storage._zypper ?? Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings()}
    set {_uniqueStorage()._zypper = newValue}
  }
  /// Returns true if `zypper` has been explicitly set.
  public var hasZypper: Bool {return _storage._zypper != nil}
  /// Clears the value of `zypper`. Subsequent reads from it will return its default value.
  public mutating func clearZypper() {_uniqueStorage()._zypper = nil}

  /// Windows update settings. Use this override the default windows patch rules.
  public var windowsUpdate: Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings {
    get {return _storage._windowsUpdate ?? Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings()}
    set {_uniqueStorage()._windowsUpdate = newValue}
  }
  /// Returns true if `windowsUpdate` has been explicitly set.
  public var hasWindowsUpdate: Bool {return _storage._windowsUpdate != nil}
  /// Clears the value of `windowsUpdate`. Subsequent reads from it will return its default value.
  public mutating func clearWindowsUpdate() {_uniqueStorage()._windowsUpdate = nil}

  /// The ExecStep to run before the patch update.
  public var preStep: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep {
    get {return _storage._preStep ?? Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep()}
    set {_uniqueStorage()._preStep = newValue}
  }
  /// Returns true if `preStep` has been explicitly set.
  public var hasPreStep: Bool {return _storage._preStep != nil}
  /// Clears the value of `preStep`. Subsequent reads from it will return its default value.
  public mutating func clearPreStep() {_uniqueStorage()._preStep = nil}

  /// The ExecStep to run after the patch update.
  public var postStep: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep {
    get {return _storage._postStep ?? Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep()}
    set {_uniqueStorage()._postStep = newValue}
  }
  /// Returns true if `postStep` has been explicitly set.
  public var hasPostStep: Bool {return _storage._postStep != nil}
  /// Clears the value of `postStep`. Subsequent reads from it will return its default value.
  public mutating func clearPostStep() {_uniqueStorage()._postStep = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Post-patch reboot settings.
  public enum RebootConfig: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The default behavior is DEFAULT.
    case unspecified // = 0

    /// The agent decides if a reboot is necessary by checking
    /// signals such as registry keys on Windows or `/var/run/reboot-required` on
    /// APT based systems. On RPM based systems, a set of core system package
    /// install times are compared with system boot time.
    case `default` // = 1

    /// Always reboot the machine after the update completes.
    case always // = 2

    /// Never reboot the machine after the update completes.
    case never // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .default
      case 2: self = .always
      case 3: self = .never
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .default: return 1
      case .always: return 2
      case .never: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig.RebootConfig: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig.RebootConfig] = [
    .unspecified,
    .default,
    .always,
    .never,
  ]
}

#endif  // swift(>=4.2)

/// Apt patching will be performed by executing `apt-get update && apt-get
/// upgrade`. Additional options can be set to control how this is executed.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// By changing the type to DIST, the patching will be performed
  /// using `apt-get dist-upgrade` instead.
  public var type: Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings.TypeEnum = .unspecified

  /// List of packages to exclude from update.
  public var excludes: [String] = []

  /// An exclusive list of packages to be updated. These are the only packages
  /// that will be updated. If these packages are not installed, they will be
  /// ignored. This field cannot be specified with any other patch configuration
  /// fields.
  public var exclusivePackages: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Apt patch type.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// By default, upgrade will be performed.
    case unspecified // = 0

    /// Runs `apt-get dist-upgrade`.
    case dist // = 1

    /// Runs `apt-get upgrade`.
    case upgrade // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .dist
      case 2: self = .upgrade
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .dist: return 1
      case .upgrade: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings.TypeEnum] = [
    .unspecified,
    .dist,
    .upgrade,
  ]
}

#endif  // swift(>=4.2)

/// Yum patching will be performed by executing `yum update`. Additional options
/// can be set to control how this is executed.
///
/// Note that not all settings are supported on all platforms.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Adds the `--security` flag to `yum update`. Not supported on
  /// all platforms.
  public var security: Bool = false

  /// Will cause patch to run `yum update-minimal` instead.
  public var minimal: Bool = false

  /// List of packages to exclude from update. These packages will be excluded by
  /// using the yum `--exclude` flag.
  public var excludes: [String] = []

  /// An exclusive list of packages to be updated. These are the only packages
  /// that will be updated. If these packages are not installed, they will be
  /// ignored. This field must not be specified with any other patch
  /// configuration fields.
  public var exclusivePackages: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Googet patching is performed by running `googet update`.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Zypper patching is performed by running `zypper patch`.
/// See also https://en.opensuse.org/SDB:Zypper_manual.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Adds the `--with-optional` flag to `zypper patch`.
  public var withOptional: Bool = false

  /// Adds the `--with-update` flag, to `zypper patch`.
  public var withUpdate: Bool = false

  /// Install only patches with these categories.
  /// Common categories include security, recommended, and feature.
  public var categories: [String] = []

  /// Install only patches with these severities.
  /// Common severities include critical, important, moderate, and low.
  public var severities: [String] = []

  /// List of patches to exclude from update.
  public var excludes: [String] = []

  /// An exclusive list of patches to be updated. These are the only patches
  /// that will be installed using 'zypper patch patch:<patch_name>' command.
  /// This field must not be used with any other patch configuration fields.
  public var exclusivePatches: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Windows patching is performed using the Windows Update Agent.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only apply updates of these windows update classifications. If empty, all
  /// updates will be applied.
  public var classifications: [Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings.Classification] = []

  /// List of KBs to exclude from update.
  public var excludes: [String] = []

  /// An exclusive list of kbs to be updated. These are the only patches
  /// that will be updated. This field must not be used with other
  /// patch configurations.
  public var exclusivePatches: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Microsoft Windows update classifications as defined in
  /// [1]
  /// https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro
  public enum Classification: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid. If classifications are included, they must be specified.
    case unspecified // = 0

    /// "A widely released fix for a specific problem that addresses a critical,
    /// non-security-related bug." [1]
    case critical // = 1

    /// "A widely released fix for a product-specific, security-related
    /// vulnerability. Security vulnerabilities are rated by their severity. The
    /// severity rating is indicated in the Microsoft security bulletin as
    /// critical, important, moderate, or low." [1]
    case security // = 2

    /// "A widely released and frequent software update that contains additions
    /// to a product’s definition database. Definition databases are often used
    /// to detect objects that have specific attributes, such as malicious code,
    /// phishing websites, or junk mail." [1]
    case definition // = 3

    /// "Software that controls the input and output of a device." [1]
    case driver // = 4

    /// "New product functionality that is first distributed outside the context
    /// of a product release and that is typically included in the next full
    /// product release." [1]
    case featurePack // = 5

    /// "A tested, cumulative set of all hotfixes, security updates, critical
    /// updates, and updates. Additionally, service packs may contain additional
    /// fixes for problems that are found internally since the release of the
    /// product. Service packs my also contain a limited number of
    /// customer-requested design changes or features." [1]
    case servicePack // = 6

    /// "A utility or feature that helps complete a task or set of tasks." [1]
    case tool // = 7

    /// "A tested, cumulative set of hotfixes, security updates, critical
    /// updates, and updates that are packaged together for easy deployment. A
    /// rollup generally targets a specific area, such as security, or a
    /// component of a product, such as Internet Information Services (IIS)." [1]
    case updateRollup // = 8

    /// "A widely released fix for a specific problem. An update addresses a
    /// noncritical, non-security-related bug." [1]
    case update // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .critical
      case 2: self = .security
      case 3: self = .definition
      case 4: self = .driver
      case 5: self = .featurePack
      case 6: self = .servicePack
      case 7: self = .tool
      case 8: self = .updateRollup
      case 9: self = .update
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .critical: return 1
      case .security: return 2
      case .definition: return 3
      case .driver: return 4
      case .featurePack: return 5
      case .servicePack: return 6
      case .tool: return 7
      case .updateRollup: return 8
      case .update: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings.Classification: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings.Classification] = [
    .unspecified,
    .critical,
    .security,
    .definition,
    .driver,
    .featurePack,
    .servicePack,
    .tool,
    .updateRollup,
    .update,
  ]
}

#endif  // swift(>=4.2)

/// The strategy for retrying failed patches during the patch window.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, the agent will continue to try and patch until the window has
  /// ended.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A step that runs an executable for a PatchJob.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
  public var linuxExecStepConfig: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig {
    get {return _linuxExecStepConfig ?? Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig()}
    set {_linuxExecStepConfig = newValue}
  }
  /// Returns true if `linuxExecStepConfig` has been explicitly set.
  public var hasLinuxExecStepConfig: Bool {return self._linuxExecStepConfig != nil}
  /// Clears the value of `linuxExecStepConfig`. Subsequent reads from it will return its default value.
  public mutating func clearLinuxExecStepConfig() {self._linuxExecStepConfig = nil}

  /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
  public var windowsExecStepConfig: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig {
    get {return _windowsExecStepConfig ?? Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig()}
    set {_windowsExecStepConfig = newValue}
  }
  /// Returns true if `windowsExecStepConfig` has been explicitly set.
  public var hasWindowsExecStepConfig: Bool {return self._windowsExecStepConfig != nil}
  /// Clears the value of `windowsExecStepConfig`. Subsequent reads from it will return its default value.
  public mutating func clearWindowsExecStepConfig() {self._windowsExecStepConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linuxExecStepConfig: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig? = nil
  fileprivate var _windowsExecStepConfig: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig? = nil
}

/// Common configurations for an ExecStep.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location of the executable.
  public var executable: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.OneOf_Executable? = nil

  /// An absolute path to the executable on the VM.
  public var localPath: String {
    get {
      if case .localPath(let v)? = executable {return v}
      return String()
    }
    set {executable = .localPath(newValue)}
  }

  /// A GCS object containing the executable.
  public var gcsObject: Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject {
    get {
      if case .gcsObject(let v)? = executable {return v}
      return Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject()
    }
    set {executable = .gcsObject(newValue)}
  }

  /// Defaults to [0]. A list of possible return values that the
  /// execution can return to indicate a success.
  public var allowedSuccessCodes: [Int32] = []

  /// The script interpreter to use to run the script. If no interpreter is
  /// specified the script will be executed directly, which will likely
  /// only succeed for scripts with shebang lines.
  /// [Wikipedia shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)).
  public var interpreter: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.Interpreter = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Location of the executable.
  public enum OneOf_Executable: Equatable {
    /// An absolute path to the executable on the VM.
    case localPath(String)
    /// A GCS object containing the executable.
    case gcsObject(Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.OneOf_Executable, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.OneOf_Executable) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.localPath, .localPath): return {
        guard case .localPath(let l) = lhs, case .localPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsObject, .gcsObject): return {
        guard case .gcsObject(let l) = lhs, case .gcsObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The interpreter used to execute the a file.
  public enum Interpreter: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
    /// interpreter will be parsed from the shebang line of the script if
    /// unspecified.
    case unspecified // = 0

    /// Indicates that the script will be run with /bin/sh on Linux and cmd
    /// on windows.
    case shell // = 1

    /// Indicates that the file will be run with PowerShell.
    case powershell // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .shell
      case 2: self = .powershell
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .shell: return 1
      case .powershell: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.Interpreter: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.Interpreter] = [
    .unspecified,
    .shell,
    .powershell,
  ]
}

#endif  // swift(>=4.2)

/// GCS object representation.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Bucket of the GCS object.
  public var bucket: String = String()

  /// Name of the GCS object.
  public var object: String = String()

  /// Generation number of the GCS object. This is used to ensure that the
  /// ExecStep specified by this PatchJob does not change.
  public var generationNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.osconfig.agentendpoint.v1"

extension Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reboot_config"),
    2: .standard(proto: "retry_strategy"),
    3: .same(proto: "apt"),
    4: .same(proto: "yum"),
    5: .same(proto: "goo"),
    6: .same(proto: "zypper"),
    7: .standard(proto: "windows_update"),
    8: .standard(proto: "pre_step"),
    9: .standard(proto: "post_step"),
  ]

  fileprivate class _StorageClass {
    var _rebootConfig: Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig.RebootConfig = .unspecified
    var _retryStrategy: Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy? = nil
    var _apt: Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings? = nil
    var _yum: Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings? = nil
    var _goo: Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings? = nil
    var _zypper: Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings? = nil
    var _windowsUpdate: Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings? = nil
    var _preStep: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep? = nil
    var _postStep: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rebootConfig = source._rebootConfig
      _retryStrategy = source._retryStrategy
      _apt = source._apt
      _yum = source._yum
      _goo = source._goo
      _zypper = source._zypper
      _windowsUpdate = source._windowsUpdate
      _preStep = source._preStep
      _postStep = source._postStep
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._rebootConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._retryStrategy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._apt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._yum) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._goo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._zypper) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._windowsUpdate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._preStep) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._postStep) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._rebootConfig != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._rebootConfig, fieldNumber: 1)
      }
      if let v = _storage._retryStrategy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._apt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._yum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._goo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._zypper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._windowsUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._preStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._postStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rebootConfig != rhs_storage._rebootConfig {return false}
        if _storage._retryStrategy != rhs_storage._retryStrategy {return false}
        if _storage._apt != rhs_storage._apt {return false}
        if _storage._yum != rhs_storage._yum {return false}
        if _storage._goo != rhs_storage._goo {return false}
        if _storage._zypper != rhs_storage._zypper {return false}
        if _storage._windowsUpdate != rhs_storage._windowsUpdate {return false}
        if _storage._preStep != rhs_storage._preStep {return false}
        if _storage._postStep != rhs_storage._postStep {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_PatchConfig.RebootConfig: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REBOOT_CONFIG_UNSPECIFIED"),
    1: .same(proto: "DEFAULT"),
    2: .same(proto: "ALWAYS"),
    3: .same(proto: "NEVER"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AptSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "excludes"),
    3: .standard(proto: "exclusive_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 2)
    }
    if !self.exclusivePackages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePackages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePackages != rhs.exclusivePackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_AptSettings.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "DIST"),
    2: .same(proto: "UPGRADE"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".YumSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "security"),
    2: .same(proto: "minimal"),
    3: .same(proto: "excludes"),
    4: .standard(proto: "exclusive_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.security) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.minimal) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.security != false {
      try visitor.visitSingularBoolField(value: self.security, fieldNumber: 1)
    }
    if self.minimal != false {
      try visitor.visitSingularBoolField(value: self.minimal, fieldNumber: 2)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 3)
    }
    if !self.exclusivePackages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePackages, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_YumSettings) -> Bool {
    if lhs.security != rhs.security {return false}
    if lhs.minimal != rhs.minimal {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePackages != rhs.exclusivePackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GooSettings"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_GooSettings) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ZypperSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "with_optional"),
    2: .standard(proto: "with_update"),
    3: .same(proto: "categories"),
    4: .same(proto: "severities"),
    5: .same(proto: "excludes"),
    6: .standard(proto: "exclusive_patches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.withOptional) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.withUpdate) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.severities) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.withOptional != false {
      try visitor.visitSingularBoolField(value: self.withOptional, fieldNumber: 1)
    }
    if self.withUpdate != false {
      try visitor.visitSingularBoolField(value: self.withUpdate, fieldNumber: 2)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 3)
    }
    if !self.severities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.severities, fieldNumber: 4)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 5)
    }
    if !self.exclusivePatches.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePatches, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_ZypperSettings) -> Bool {
    if lhs.withOptional != rhs.withOptional {return false}
    if lhs.withUpdate != rhs.withUpdate {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.severities != rhs.severities {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePatches != rhs.exclusivePatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WindowsUpdateSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "classifications"),
    2: .same(proto: "excludes"),
    3: .standard(proto: "exclusive_patches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.classifications) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classifications.isEmpty {
      try visitor.visitPackedEnumField(value: self.classifications, fieldNumber: 1)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 2)
    }
    if !self.exclusivePatches.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePatches, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings) -> Bool {
    if lhs.classifications != rhs.classifications {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePatches != rhs.exclusivePatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_WindowsUpdateSettings.Classification: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLASSIFICATION_UNSPECIFIED"),
    1: .same(proto: "CRITICAL"),
    2: .same(proto: "SECURITY"),
    3: .same(proto: "DEFINITION"),
    4: .same(proto: "DRIVER"),
    5: .same(proto: "FEATURE_PACK"),
    6: .same(proto: "SERVICE_PACK"),
    7: .same(proto: "TOOL"),
    8: .same(proto: "UPDATE_ROLLUP"),
    9: .same(proto: "UPDATE"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryStrategy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_RetryStrategy) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linux_exec_step_config"),
    2: .standard(proto: "windows_exec_step_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._linuxExecStepConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._windowsExecStepConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._linuxExecStepConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._windowsExecStepConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStep) -> Bool {
    if lhs._linuxExecStepConfig != rhs._linuxExecStepConfig {return false}
    if lhs._windowsExecStepConfig != rhs._windowsExecStepConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecStepConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_path"),
    2: .standard(proto: "gcs_object"),
    3: .standard(proto: "allowed_success_codes"),
    4: .same(proto: "interpreter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.executable != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.executable = .localPath(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject?
        if let current = self.executable {
          try decoder.handleConflictingOneOf()
          if case .gcsObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.executable = .gcsObject(v)}
      }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedSuccessCodes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interpreter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.executable {
    case .localPath?: try {
      guard case .localPath(let v)? = self.executable else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .gcsObject?: try {
      guard case .gcsObject(let v)? = self.executable else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.allowedSuccessCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedSuccessCodes, fieldNumber: 3)
    }
    if self.interpreter != .unspecified {
      try visitor.visitSingularEnumField(value: self.interpreter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig) -> Bool {
    if lhs.executable != rhs.executable {return false}
    if lhs.allowedSuccessCodes != rhs.allowedSuccessCodes {return false}
    if lhs.interpreter != rhs.interpreter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_ExecStepConfig.Interpreter: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERPRETER_UNSPECIFIED"),
    1: .same(proto: "SHELL"),
    2: .same(proto: "POWERSHELL"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "object"),
    3: .standard(proto: "generation_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.generationNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 2)
    }
    if self.generationNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.generationNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_GcsObject) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.object != rhs.object {return false}
    if lhs.generationNumber != rhs.generationNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

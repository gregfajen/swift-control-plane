// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/osconfig/agentendpoint/v1/inventory.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The inventory details of a VM.
public struct Google_Cloud_Osconfig_Agentendpoint_V1_Inventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Base level operating system information for the VM.
  public var osInfo: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.OsInfo {
    get {return _osInfo ?? Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.OsInfo()}
    set {_osInfo = newValue}
  }
  /// Returns true if `osInfo` has been explicitly set.
  public var hasOsInfo: Bool {return self._osInfo != nil}
  /// Clears the value of `osInfo`. Subsequent reads from it will return its default value.
  public mutating func clearOsInfo() {self._osInfo = nil}

  /// A list of installed packages currently on the VM.
  public var installedPackages: [Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage] = []

  /// A list of software updates available for the VM as reported by the update
  /// managers.
  public var availablePackages: [Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operating system information for the VM.
  public struct OsInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The VM hostname.
    public var hostname: String = String()

    /// The operating system long name.
    /// For example 'Debian GNU/Linux 9' or 'Microsoft Window Server 2019
    /// Datacenter'.
    public var longName: String = String()

    /// The operating system short name.
    /// For example, 'windows' or 'debian'.
    public var shortName: String = String()

    /// The version of the operating system.
    public var version: String = String()

    /// The system architecture of the operating system.
    public var architecture: String = String()

    /// The kernel version of the operating system.
    public var kernelVersion: String = String()

    /// The kernel release of the operating system.
    public var kernelRelease: String = String()

    /// The current version of the OS Config agent running on the VM.
    public var osconfigAgentVersion: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Software package information of the operating system.
  public struct SoftwarePackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Information about the different types of software packages.
    public var details: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage.OneOf_Details? = nil

    /// Yum package info.
    /// For details about the yum package manager, see
    /// https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum.
    public var yumPackage: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage {
      get {
        if case .yumPackage(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage()
      }
      set {details = .yumPackage(newValue)}
    }

    /// Details of an APT package.
    /// For details about the apt package manager, see
    /// https://wiki.debian.org/Apt.
    public var aptPackage: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage {
      get {
        if case .aptPackage(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage()
      }
      set {details = .aptPackage(newValue)}
    }

    /// Details of a Zypper package.
    /// For details about the Zypper package manager, see
    /// https://en.opensuse.org/SDB:Zypper_manual.
    public var zypperPackage: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage {
      get {
        if case .zypperPackage(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage()
      }
      set {details = .zypperPackage(newValue)}
    }

    /// Details of a Googet package.
    ///  For details about the googet package manager, see
    ///  https://github.com/google/googet.
    public var googetPackage: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage {
      get {
        if case .googetPackage(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage()
      }
      set {details = .googetPackage(newValue)}
    }

    /// Details of a Zypper patch.
    /// For details about the Zypper package manager, see
    /// https://en.opensuse.org/SDB:Zypper_manual.
    public var zypperPatch: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch {
      get {
        if case .zypperPatch(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch()
      }
      set {details = .zypperPatch(newValue)}
    }

    /// Details of a Windows Update package.
    /// See https://docs.microsoft.com/en-us/windows/win32/api/_wua/ for
    /// information about Windows Update.
    public var wuaPackage: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage {
      get {
        if case .wuaPackage(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage()
      }
      set {details = .wuaPackage(newValue)}
    }

    /// Details of a Windows Quick Fix engineering package.
    /// See
    /// https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
    /// for info in Windows Quick Fix Engineering.
    public var qfePackage: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage {
      get {
        if case .qfePackage(let v)? = details {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage()
      }
      set {details = .qfePackage(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Information about the different types of software packages.
    public enum OneOf_Details: Equatable {
      /// Yum package info.
      /// For details about the yum package manager, see
      /// https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/deployment_guide/ch-yum.
      case yumPackage(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage)
      /// Details of an APT package.
      /// For details about the apt package manager, see
      /// https://wiki.debian.org/Apt.
      case aptPackage(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage)
      /// Details of a Zypper package.
      /// For details about the Zypper package manager, see
      /// https://en.opensuse.org/SDB:Zypper_manual.
      case zypperPackage(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage)
      /// Details of a Googet package.
      ///  For details about the googet package manager, see
      ///  https://github.com/google/googet.
      case googetPackage(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage)
      /// Details of a Zypper patch.
      /// For details about the Zypper package manager, see
      /// https://en.opensuse.org/SDB:Zypper_manual.
      case zypperPatch(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch)
      /// Details of a Windows Update package.
      /// See https://docs.microsoft.com/en-us/windows/win32/api/_wua/ for
      /// information about Windows Update.
      case wuaPackage(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage)
      /// Details of a Windows Quick Fix engineering package.
      /// See
      /// https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
      /// for info in Windows Quick Fix Engineering.
      case qfePackage(Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage.OneOf_Details, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage.OneOf_Details) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.yumPackage, .yumPackage): return {
          guard case .yumPackage(let l) = lhs, case .yumPackage(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.aptPackage, .aptPackage): return {
          guard case .aptPackage(let l) = lhs, case .aptPackage(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.zypperPackage, .zypperPackage): return {
          guard case .zypperPackage(let l) = lhs, case .zypperPackage(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.googetPackage, .googetPackage): return {
          guard case .googetPackage(let l) = lhs, case .googetPackage(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.zypperPatch, .zypperPatch): return {
          guard case .zypperPatch(let l) = lhs, case .zypperPatch(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.wuaPackage, .wuaPackage): return {
          guard case .wuaPackage(let l) = lhs, case .wuaPackage(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.qfePackage, .qfePackage): return {
          guard case .qfePackage(let l) = lhs, case .qfePackage(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Information related to the a standard versioned package.  This includes
  /// package info for APT, Yum, Zypper, and Googet package managers.
  public struct VersionedPackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the package.
    public var packageName: String = String()

    /// The system architecture this package is intended for.
    public var architecture: String = String()

    /// The version of the package.
    public var version: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Details related to a Windows Update package.
  /// Field data and names are taken from Windows Update API IUpdate Interface:
  /// https://docs.microsoft.com/en-us/windows/win32/api/_wua/
  /// Descriptive fields like title, and description are localized based on
  /// the locale of the VM being updated.
  public struct WindowsUpdatePackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The localized title of the update package.
    public var title: String = String()

    /// The localized description of the update package.
    public var description_p: String = String()

    /// The categories that are associated with this update package.
    public var categories: [Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage.WindowsUpdateCategory] = []

    /// A collection of Microsoft Knowledge Base article IDs that are associated
    /// with the update package.
    public var kbArticleIds: [String] = []

    /// A hyperlink to the language-specific support information for the update.
    public var supportURL: String = String()

    /// A collection of URLs that provide more information about the update
    /// package.
    public var moreInfoUrls: [String] = []

    /// Gets the identifier of an update package.  Stays the same across
    /// revisions.
    public var updateID: String = String()

    /// The revision number of this update package.
    public var revisionNumber: Int32 = 0

    /// The last published date of the update, in (UTC) date and time.
    public var lastDeploymentChangeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _lastDeploymentChangeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastDeploymentChangeTime = newValue}
    }
    /// Returns true if `lastDeploymentChangeTime` has been explicitly set.
    public var hasLastDeploymentChangeTime: Bool {return self._lastDeploymentChangeTime != nil}
    /// Clears the value of `lastDeploymentChangeTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastDeploymentChangeTime() {self._lastDeploymentChangeTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Categories specified by the Windows Update.
    public struct WindowsUpdateCategory {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The identifier of the windows update category.
      public var id: String = String()

      /// The name of the windows update category.
      public var name: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _lastDeploymentChangeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// Details related to a Zypper Patch.
  public struct ZypperPatch {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the patch.
    public var patchName: String = String()

    /// The category of the patch.
    public var category: String = String()

    /// The severity specified for this patch
    public var severity: String = String()

    /// Any summary information provided about this patch.
    public var summary: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Information related to a Quick Fix Engineering package.
  /// Fields are taken from Windows QuickFixEngineering Interface and match
  /// the source names:
  /// https://docs.microsoft.com/en-us/windows/win32/cimwin32prov/win32-quickfixengineering
  public struct WindowsQuickFixEngineeringPackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A short textual description of the QFE update.
    public var caption: String = String()

    /// A textual description of the QFE update.
    public var description_p: String = String()

    /// Unique identifier associated with a particular QFE update.
    public var hotFixID: String = String()

    /// Date that the QFE update was installed.  Mapped from installed_on field.
    public var installTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _installTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_installTime = newValue}
    }
    /// Returns true if `installTime` has been explicitly set.
    public var hasInstallTime: Bool {return self._installTime != nil}
    /// Clears the value of `installTime`. Subsequent reads from it will return its default value.
    public mutating func clearInstallTime() {self._installTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _installTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _osInfo: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.OsInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.osconfig.agentendpoint.v1"

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Inventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "os_info"),
    2: .standard(proto: "installed_packages"),
    3: .standard(proto: "available_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._osInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.installedPackages) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.availablePackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._osInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.installedPackages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.installedPackages, fieldNumber: 2)
    }
    if !self.availablePackages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availablePackages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory) -> Bool {
    if lhs._osInfo != rhs._osInfo {return false}
    if lhs.installedPackages != rhs.installedPackages {return false}
    if lhs.availablePackages != rhs.availablePackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.OsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.protoMessageName + ".OsInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hostname"),
    2: .standard(proto: "long_name"),
    3: .standard(proto: "short_name"),
    4: .same(proto: "version"),
    5: .same(proto: "architecture"),
    6: .standard(proto: "kernel_version"),
    7: .standard(proto: "kernel_release"),
    8: .standard(proto: "osconfig_agent_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.longName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.shortName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.kernelVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.kernelRelease) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.osconfigAgentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 1)
    }
    if !self.longName.isEmpty {
      try visitor.visitSingularStringField(value: self.longName, fieldNumber: 2)
    }
    if !self.shortName.isEmpty {
      try visitor.visitSingularStringField(value: self.shortName, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 5)
    }
    if !self.kernelVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.kernelVersion, fieldNumber: 6)
    }
    if !self.kernelRelease.isEmpty {
      try visitor.visitSingularStringField(value: self.kernelRelease, fieldNumber: 7)
    }
    if !self.osconfigAgentVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osconfigAgentVersion, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.OsInfo, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.OsInfo) -> Bool {
    if lhs.hostname != rhs.hostname {return false}
    if lhs.longName != rhs.longName {return false}
    if lhs.shortName != rhs.shortName {return false}
    if lhs.version != rhs.version {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.kernelVersion != rhs.kernelVersion {return false}
    if lhs.kernelRelease != rhs.kernelRelease {return false}
    if lhs.osconfigAgentVersion != rhs.osconfigAgentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.protoMessageName + ".SoftwarePackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "yum_package"),
    2: .standard(proto: "apt_package"),
    3: .standard(proto: "zypper_package"),
    4: .standard(proto: "googet_package"),
    5: .standard(proto: "zypper_patch"),
    6: .standard(proto: "wua_package"),
    7: .standard(proto: "qfe_package"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .yumPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .yumPackage(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .aptPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .aptPackage(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .zypperPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .zypperPackage(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .googetPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .googetPackage(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .zypperPatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .zypperPatch(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .wuaPackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .wuaPackage(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage?
        if let current = self.details {
          try decoder.handleConflictingOneOf()
          if case .qfePackage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.details = .qfePackage(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.details {
    case .yumPackage?: try {
      guard case .yumPackage(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .aptPackage?: try {
      guard case .aptPackage(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .zypperPackage?: try {
      guard case .zypperPackage(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .googetPackage?: try {
      guard case .googetPackage(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .zypperPatch?: try {
      guard case .zypperPatch(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .wuaPackage?: try {
      guard case .wuaPackage(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .qfePackage?: try {
      guard case .qfePackage(let v)? = self.details else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.SoftwarePackage) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.protoMessageName + ".VersionedPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "package_name"),
    2: .same(proto: "architecture"),
    3: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.packageName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.architecture) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packageName.isEmpty {
      try visitor.visitSingularStringField(value: self.packageName, fieldNumber: 1)
    }
    if !self.architecture.isEmpty {
      try visitor.visitSingularStringField(value: self.architecture, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.VersionedPackage) -> Bool {
    if lhs.packageName != rhs.packageName {return false}
    if lhs.architecture != rhs.architecture {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.protoMessageName + ".WindowsUpdatePackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .same(proto: "categories"),
    4: .standard(proto: "kb_article_ids"),
    5: .standard(proto: "support_url"),
    6: .standard(proto: "more_info_urls"),
    7: .standard(proto: "update_id"),
    8: .standard(proto: "revision_number"),
    9: .standard(proto: "last_deployment_change_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.categories) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.kbArticleIds) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.supportURL) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.moreInfoUrls) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.updateID) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.revisionNumber) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._lastDeploymentChangeTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.categories, fieldNumber: 3)
    }
    if !self.kbArticleIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.kbArticleIds, fieldNumber: 4)
    }
    if !self.supportURL.isEmpty {
      try visitor.visitSingularStringField(value: self.supportURL, fieldNumber: 5)
    }
    if !self.moreInfoUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.moreInfoUrls, fieldNumber: 6)
    }
    if !self.updateID.isEmpty {
      try visitor.visitSingularStringField(value: self.updateID, fieldNumber: 7)
    }
    if self.revisionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.revisionNumber, fieldNumber: 8)
    }
    if let v = self._lastDeploymentChangeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.kbArticleIds != rhs.kbArticleIds {return false}
    if lhs.supportURL != rhs.supportURL {return false}
    if lhs.moreInfoUrls != rhs.moreInfoUrls {return false}
    if lhs.updateID != rhs.updateID {return false}
    if lhs.revisionNumber != rhs.revisionNumber {return false}
    if lhs._lastDeploymentChangeTime != rhs._lastDeploymentChangeTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage.WindowsUpdateCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage.protoMessageName + ".WindowsUpdateCategory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage.WindowsUpdateCategory, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsUpdatePackage.WindowsUpdateCategory) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.protoMessageName + ".ZypperPatch"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "patch_name"),
    2: .same(proto: "category"),
    3: .same(proto: "severity"),
    4: .same(proto: "summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.patchName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.category) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.severity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.summary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchName.isEmpty {
      try visitor.visitSingularStringField(value: self.patchName, fieldNumber: 1)
    }
    if !self.category.isEmpty {
      try visitor.visitSingularStringField(value: self.category, fieldNumber: 2)
    }
    if !self.severity.isEmpty {
      try visitor.visitSingularStringField(value: self.severity, fieldNumber: 3)
    }
    if !self.summary.isEmpty {
      try visitor.visitSingularStringField(value: self.summary, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.ZypperPatch) -> Bool {
    if lhs.patchName != rhs.patchName {return false}
    if lhs.category != rhs.category {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.summary != rhs.summary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.protoMessageName + ".WindowsQuickFixEngineeringPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "caption"),
    2: .same(proto: "description"),
    3: .standard(proto: "hot_fix_id"),
    4: .standard(proto: "install_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.caption) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hotFixID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._installTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.caption.isEmpty {
      try visitor.visitSingularStringField(value: self.caption, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.hotFixID.isEmpty {
      try visitor.visitSingularStringField(value: self.hotFixID, fieldNumber: 3)
    }
    if let v = self._installTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage, rhs: Google_Cloud_Osconfig_Agentendpoint_V1_Inventory.WindowsQuickFixEngineeringPackage) -> Bool {
    if lhs.caption != rhs.caption {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.hotFixID != rhs.hotFixID {return false}
    if lhs._installTime != rhs._installTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

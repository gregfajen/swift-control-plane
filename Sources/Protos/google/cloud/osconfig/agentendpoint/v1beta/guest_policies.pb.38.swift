// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/osconfig/agentendpoint/v1beta/guest_policies.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The desired state that the OS Config agent will maintain on the VM.
public enum Google_Cloud_Osconfig_Agentendpoint_V1beta_DesiredState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The default is to ensure the package is installed.
  case unspecified // = 0

  /// The agent ensures that the package is installed.
  case installed // = 1

  /// The agent ensures that the package is installed and
  /// periodically checks for and install any updates.
  case updated // = 2

  /// The agent ensures that the package is not installed and uninstall it
  /// if detected.
  case removed // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .installed
    case 2: self = .updated
    case 3: self = .removed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .installed: return 1
    case .updated: return 2
    case .removed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_DesiredState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1beta_DesiredState] = [
    .unspecified,
    .installed,
    .updated,
    .removed,
  ]
}

#endif  // swift(>=4.2)

/// Package is a reference to the software package to be installed or removed.
/// The agent on the VM instance uses the system package manager to apply the
/// config.
///
///
/// These are the commands that the agent uses to install or remove
/// packages.
///
/// Apt
/// install: `apt-get update && apt-get -y install package1 package2 package3`
/// remove: `apt-get -y remove package1 package2 package3`
///
/// Yum
/// install: `yum -y install package1 package2 package3`
/// remove: `yum -y remove package1 package2 package3`
///
/// Zypper
/// install: `zypper install package1 package2 package3`
/// remove: `zypper rm package1 package2`
///
/// Googet
/// install: `googet -noconfirm install package1 package2 package3`
/// remove: `googet -noconfirm remove package1 package2 package3`
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_Package {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the package. A package is uniquely identified for conflict
  /// validation by checking the package name and the manager(s) that the
  /// package targets.
  public var name: String = String()

  /// The desired_state the agent should maintain for this package. The
  /// default is to ensure the package is installed.
  public var desiredState: Google_Cloud_Osconfig_Agentendpoint_V1beta_DesiredState = .unspecified

  /// Type of package manager that can be used to install this package.
  /// If a system does not have the package manager, the package is not
  /// installed or removed no error message is returned. By default,
  /// or if you specify `ANY`,
  /// the agent attempts to install and remove this package using the default
  /// package manager. This is useful when creating a policy that applies to
  /// different types of systems.
  ///
  /// The default behavior is ANY.
  public var manager: Google_Cloud_Osconfig_Agentendpoint_V1beta_Package.Manager = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Types of package managers that may be used to manage this package.
  public enum Manager: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The default behavior is ANY.
    case unspecified // = 0

    /// Apply this package config using the default system package manager.
    case any // = 1

    /// Apply this package config only if Apt is available on the system.
    case apt // = 2

    /// Apply this package config only if Yum is available on the system.
    case yum // = 3

    /// Apply this package config only if Zypper is available on the system.
    case zypper // = 4

    /// Apply this package config only if GooGet is available on the system.
    case goo // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .any
      case 2: self = .apt
      case 3: self = .yum
      case 4: self = .zypper
      case 5: self = .goo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .any: return 1
      case .apt: return 2
      case .yum: return 3
      case .zypper: return 4
      case .goo: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_Package.Manager: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1beta_Package.Manager] = [
    .unspecified,
    .any,
    .apt,
    .yum,
    .zypper,
    .goo,
  ]
}

#endif  // swift(>=4.2)

/// Represents a single Apt package repository. This repository is added to
/// a repo file that is stored at
/// `/etc/apt/sources.list.d/google_osconfig.list`.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of archive files in this repository. The default behavior is DEB.
  public var archiveType: Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository.ArchiveType = .unspecified

  /// URI for this repository.
  public var uri: String = String()

  /// Distribution of this repository.
  public var distribution: String = String()

  /// List of components for this repository. Must contain at least one item.
  public var components: [String] = []

  /// URI of the key file for this repository. The agent maintains
  /// a keyring at `/etc/apt/trusted.gpg.d/osconfig_agent_managed.gpg` containing
  /// all the keys in any applied guest policy.
  public var gpgKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of archive.
  public enum ArchiveType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// DEB indicates that the archive contains binary files.
    case deb // = 1

    /// DEB_SRC indicates that the archive contains source files.
    case debSrc // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .deb
      case 2: self = .debSrc
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .deb: return 1
      case .debSrc: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository.ArchiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository.ArchiveType] = [
    .unspecified,
    .deb,
    .debSrc,
  ]
}

#endif  // swift(>=4.2)

/// Represents a single Yum package repository. This repository is added to a
/// repo file that is stored at `/etc/yum.repos.d/google_osconfig.repo`.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A one word, unique name for this repository. This is
  /// the `repo id` in the Yum config file and also the `display_name` if
  /// `display_name` is omitted. This id is also used as the unique identifier
  /// when checking for guest policy conflicts.
  public var id: String = String()

  /// The display name of the repository.
  public var displayName: String = String()

  /// The location of the repository directory.
  public var baseURL: String = String()

  /// URIs of GPG keys.
  public var gpgKeys: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a single Zypper package repository. This repository is added to a
/// repo file that is stored at `/etc/zypp/repos.d/google_osconfig.repo`.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A one word, unique name for this repository. This is
  /// the `repo id` in the zypper config file and also the `display_name` if
  /// `display_name` is omitted. This id is also used as the unique identifier
  /// when checking for guest policy conflicts.
  public var id: String = String()

  /// The display name of the repository.
  public var displayName: String = String()

  /// The location of the repository directory.
  public var baseURL: String = String()

  /// URIs of GPG keys.
  public var gpgKeys: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a Goo package repository. These is added to a repo file
/// that is stored at C:/ProgramData/GooGet/repos/google_osconfig.repo.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the repository.
  public var name: String = String()

  /// The url of the repository.
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A package repository.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A specific type of repository.
  public var repository: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository.OneOf_Repository? = nil

  /// An Apt Repository.
  public var apt: Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository {
    get {
      if case .apt(let v)? = repository {return v}
      return Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository()
    }
    set {repository = .apt(newValue)}
  }

  /// A Yum Repository.
  public var yum: Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository {
    get {
      if case .yum(let v)? = repository {return v}
      return Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository()
    }
    set {repository = .yum(newValue)}
  }

  /// A Zypper Repository.
  public var zypper: Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository {
    get {
      if case .zypper(let v)? = repository {return v}
      return Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository()
    }
    set {repository = .zypper(newValue)}
  }

  /// A Goo Repository.
  public var goo: Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository {
    get {
      if case .goo(let v)? = repository {return v}
      return Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository()
    }
    set {repository = .goo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A specific type of repository.
  public enum OneOf_Repository: Equatable {
    /// An Apt Repository.
    case apt(Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository)
    /// A Yum Repository.
    case yum(Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository)
    /// A Zypper Repository.
    case zypper(Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository)
    /// A Goo Repository.
    case goo(Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository.OneOf_Repository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository.OneOf_Repository) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.apt, .apt): return {
        guard case .apt(let l) = lhs, case .apt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.yum, .yum): return {
        guard case .yum(let l) = lhs, case .yum(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.zypper, .zypper): return {
        guard case .zypper(let l) = lhs, case .zypper(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.goo, .goo): return {
        guard case .goo(let l) = lhs, case .goo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A software recipe is a set of instructions for installing and configuring a
/// piece of software. It consists of a set of artifacts that are
/// downloaded, and a set of steps that install, configure, and/or update the
/// software.
///
/// Recipes support installing and updating software from artifacts in the
/// following formats:
/// Zip archive, Tar archive, Windows MSI, Debian package, and RPM package.
///
/// Additionally, recipes support executing a script (either defined in a file or
/// directly in this api) in bash, sh, cmd, and powershell.
///
/// Updating a software recipe
///
/// If a recipe is assigned to an instance and there is a recipe with the same
/// name but a lower version already installed and the assigned state
/// of the recipe is `INSTALLED_KEEP_UPDATED`, then the recipe is updated to
/// the new version.
///
/// Script Working Directories
///
/// Each script or execution step is run in its own temporary directory which
/// is deleted after completing the step.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for the recipe. Only one recipe with a given name is
  /// installed on an instance.
  ///
  /// Names are also used to identify resources which helps to determine whether
  /// guest policies have conflicts. This means that requests to create multiple
  /// recipes with the same name and version are rejected since they
  /// could potentially have conflicting assignments.
  public var name: String = String()

  /// The version of this software recipe. Version can be up to 4 period
  /// separated numbers (e.g. 12.34.56.78).
  public var version: String = String()

  /// Resources available to be used in the steps in the recipe.
  public var artifacts: [Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact] = []

  /// Actions to be taken for installing this recipe. On failure it stops
  /// executing steps and does not attempt another installation. Any steps taken
  /// (including partially completed steps) are not rolled back.  Install steps
  /// must be specified and are used on first installation.
  public var installSteps: [Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step] = []

  /// Actions to be taken for updating this recipe. On failure it stops
  /// executing steps and  does not attempt another update for this recipe. Any
  /// steps taken (including partially completed steps) are not rolled back.
  /// Upgrade steps are not mandatory and are only used when upgrading.
  public var updateSteps: [Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step] = []

  /// Default is INSTALLED. The desired state the agent should maintain for this
  /// recipe.
  ///
  /// INSTALLED: The software recipe is installed on the instance but won't be
  ///                         updated to new versions.
  /// UPDATED: The software recipe is installed on the instance. The recipe is
  ///                         updated to a higher version, if a higher version of
  ///                         the recipe is assigned to this instance.
  /// REMOVE: Remove is unsupported for software recipes and attempts to
  ///         create or update a recipe to the REMOVE state is rejected.
  public var desiredState: Google_Cloud_Osconfig_Agentendpoint_V1beta_DesiredState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies a resource to be used in the recipe.
  public struct Artifact {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Id of the artifact, which the installation and update steps of this
    /// recipe can reference. Artifacts in a recipe cannot have the same id.
    public var id: String = String()

    /// A specific type of artifact.
    public var artifact: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.OneOf_Artifact? = nil

    /// A generic remote artifact.
    public var remote: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote {
      get {
        if case .remote(let v)? = artifact {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote()
      }
      set {artifact = .remote(newValue)}
    }

    /// A Cloud Storage artifact.
    public var gcs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs {
      get {
        if case .gcs(let v)? = artifact {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs()
      }
      set {artifact = .gcs(newValue)}
    }

    /// Defaults to false. When false, recipes are subject to validations
    /// based on the artifact type:
    ///
    /// Remote: A checksum must be specified, and only protocols with
    ///         transport-layer security are permitted.
    /// GCS:    An object generation number must be specified.
    public var allowInsecure: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A specific type of artifact.
    public enum OneOf_Artifact: Equatable {
      /// A generic remote artifact.
      case remote(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote)
      /// A Cloud Storage artifact.
      case gcs(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.OneOf_Artifact, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.OneOf_Artifact) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.remote, .remote): return {
          guard case .remote(let l) = lhs, case .remote(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.gcs, .gcs): return {
          guard case .gcs(let l) = lhs, case .gcs(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Specifies an artifact available via some URI.
    public struct Remote {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// URI from which to fetch the object. It should contain both the protocol
      /// and path following the format {protocol}://{location}.
      public var uri: String = String()

      /// Must be provided if `allow_insecure` is `false`.
      /// SHA256 checksum in hex format, to compare to the checksum of the
      /// artifact. If the checksum is not empty and it doesn't match the
      /// artifact then the recipe installation fails before running any of the
      /// steps.
      public var checksum: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Specifies an artifact available as a Cloud Storage object.
    public struct Gcs {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Bucket of the Cloud Storage object.
      /// Given an example URL:
      /// `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
      /// this value would be `my-bucket`.
      public var bucket: String = String()

      /// Name of the Cloud Storage object.
      /// As specified [here]
      /// (https://cloud.google.com/storage/docs/naming#objectnames)
      /// Given an example URL:
      /// `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
      /// this value would be `foo/bar`.
      public var object: String = String()

      /// Must be provided if allow_insecure is false.
      /// Generation number of the Cloud Storage object.
      /// `https://storage.googleapis.com/my-bucket/foo/bar#1234567`
      /// this value would be `1234567`.
      public var generation: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// An action that can be taken as part of installing or updating a recipe.
  public struct Step {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A specific type of step.
    public var step: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.OneOf_Step? = nil

    /// Copies a file onto the instance.
    public var fileCopy: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile {
      get {
        if case .fileCopy(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile()
      }
      set {step = .fileCopy(newValue)}
    }

    /// Extracts an archive into the specified directory.
    public var archiveExtraction: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive {
      get {
        if case .archiveExtraction(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive()
      }
      set {step = .archiveExtraction(newValue)}
    }

    /// Installs an MSI file.
    public var msiInstallation: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi {
      get {
        if case .msiInstallation(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi()
      }
      set {step = .msiInstallation(newValue)}
    }

    /// Installs a deb file via dpkg.
    public var dpkgInstallation: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg {
      get {
        if case .dpkgInstallation(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg()
      }
      set {step = .dpkgInstallation(newValue)}
    }

    /// Installs an rpm file via the rpm utility.
    public var rpmInstallation: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm {
      get {
        if case .rpmInstallation(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm()
      }
      set {step = .rpmInstallation(newValue)}
    }

    /// Executes an artifact or local file.
    public var fileExec: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile {
      get {
        if case .fileExec(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile()
      }
      set {step = .fileExec(newValue)}
    }

    /// Runs commands in a shell.
    public var scriptRun: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript {
      get {
        if case .scriptRun(let v)? = step {return v}
        return Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript()
      }
      set {step = .scriptRun(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// A specific type of step.
    public enum OneOf_Step: Equatable {
      /// Copies a file onto the instance.
      case fileCopy(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile)
      /// Extracts an archive into the specified directory.
      case archiveExtraction(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive)
      /// Installs an MSI file.
      case msiInstallation(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi)
      /// Installs a deb file via dpkg.
      case dpkgInstallation(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg)
      /// Installs an rpm file via the rpm utility.
      case rpmInstallation(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm)
      /// Executes an artifact or local file.
      case fileExec(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile)
      /// Runs commands in a shell.
      case scriptRun(Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.OneOf_Step, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.OneOf_Step) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.fileCopy, .fileCopy): return {
          guard case .fileCopy(let l) = lhs, case .fileCopy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.archiveExtraction, .archiveExtraction): return {
          guard case .archiveExtraction(let l) = lhs, case .archiveExtraction(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.msiInstallation, .msiInstallation): return {
          guard case .msiInstallation(let l) = lhs, case .msiInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.dpkgInstallation, .dpkgInstallation): return {
          guard case .dpkgInstallation(let l) = lhs, case .dpkgInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.rpmInstallation, .rpmInstallation): return {
          guard case .rpmInstallation(let l) = lhs, case .rpmInstallation(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.fileExec, .fileExec): return {
          guard case .fileExec(let l) = lhs, case .fileExec(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.scriptRun, .scriptRun): return {
          guard case .scriptRun(let l) = lhs, case .scriptRun(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Copies the artifact to the specified path on the instance.
    public struct CopyFile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      /// The absolute path on the instance to put the file.
      public var destination: String = String()

      /// Whether to allow this step to overwrite existing files. If this is
      /// false and the file already exists the file is not overwritten
      /// and the step is considered a success. Defaults to false.
      public var overwrite: Bool = false

      /// Consists of three octal digits which represent, in
      /// order, the permissions of the owner, group, and other users for the
      /// file (similarly to the numeric mode used in the linux chmod utility).
      /// Each digit represents a three bit number with the 4 bit
      /// corresponding to the read permissions, the 2 bit corresponds to the
      /// write bit, and the one bit corresponds to the execute permission.
      /// Default behavior is 755.
      ///
      /// Below are some examples of permissions and their associated values:
      /// read, write, and execute: 7
      /// read and execute: 5
      /// read and write: 6
      /// read only: 4
      public var permissions: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Extracts an archive of the type specified in the specified directory.
    public struct ExtractArchive {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      /// Directory to extract archive to.
      /// Defaults to `/` on Linux or `C:\` on Windows.
      public var destination: String = String()

      /// The type of the archive to extract.
      public var type: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Specifying the type of archive.
      public enum ArchiveType: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Indicates that the archive type isn't specified.
        case unspecified // = 0

        /// Indicates that the archive is a tar archive with no encryption.
        case tar // = 1

        /// Indicates that the archive is a tar archive with gzip encryption.
        case tarGzip // = 2

        /// Indicates that the archive is a tar archive with bzip encryption.
        case tarBzip // = 3

        /// Indicates that the archive is a tar archive with lzma encryption.
        case tarLzma // = 4

        /// Indicates that the archive is a tar archive with xz encryption.
        case tarXz // = 5

        /// Indicates that the archive is a zip archive.
        case zip // = 11
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .tar
          case 2: self = .tarGzip
          case 3: self = .tarBzip
          case 4: self = .tarLzma
          case 5: self = .tarXz
          case 11: self = .zip
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .tar: return 1
          case .tarGzip: return 2
          case .tarBzip: return 3
          case .tarLzma: return 4
          case .tarXz: return 5
          case .zip: return 11
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    /// Installs an MSI file.
    public struct InstallMsi {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      /// The flags to use when installing the MSI
      /// defaults to ["/i"] (i.e. the install flag).
      public var flags: [String] = []

      /// Return codes that indicate that the software installed or updated
      /// successfully. Behaviour defaults to [0]
      public var allowedExitCodes: [Int32] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Installs a deb via dpkg.
    public struct InstallDpkg {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Installs an rpm file via the rpm utility.
    public struct InstallRpm {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Executes an artifact or local file.
    public struct ExecFile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Location of the file to execute.
      public var locationType: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile.OneOf_LocationType? = nil

      /// The id of the relevant artifact in the recipe.
      public var artifactID: String {
        get {
          if case .artifactID(let v)? = locationType {return v}
          return String()
        }
        set {locationType = .artifactID(newValue)}
      }

      /// The absolute path of the file on the local filesystem.
      public var localPath: String {
        get {
          if case .localPath(let v)? = locationType {return v}
          return String()
        }
        set {locationType = .localPath(newValue)}
      }

      /// Arguments to be passed to the provided executable.
      public var args: [String] = []

      /// Defaults to [0]. A list of possible return values that the program
      /// can return to indicate a success.
      public var allowedExitCodes: [Int32] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Location of the file to execute.
      public enum OneOf_LocationType: Equatable {
        /// The id of the relevant artifact in the recipe.
        case artifactID(String)
        /// The absolute path of the file on the local filesystem.
        case localPath(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile.OneOf_LocationType, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile.OneOf_LocationType) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.artifactID, .artifactID): return {
            guard case .artifactID(let l) = lhs, case .artifactID(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.localPath, .localPath): return {
            guard case .localPath(let l) = lhs, case .localPath(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// Runs a script through an interpreter.
    public struct RunScript {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The shell script to be executed.
      public var script: String = String()

      /// Return codes that indicate that the software installed or updated
      /// successfully. Behaviour defaults to [0]
      public var allowedExitCodes: [Int32] = []

      /// The script interpreter to use to run the script. If no interpreter is
      /// specified the script is executed directly, which likely
      /// only succeed for scripts with
      /// [shebang lines](https://en.wikipedia.org/wiki/Shebang_(Unix)).
      public var interpreter: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript.Interpreter = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// The interpreter used to execute a script.
      public enum Interpreter: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// Default value for ScriptType.
        case unspecified // = 0

        /// Indicates that the script is run with `/bin/sh` on Linux and `cmd`
        /// on windows.
        case shell // = 1

        /// Indicates that the script is run with powershell.
        case powershell // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .unspecified
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unspecified
          case 1: self = .shell
          case 3: self = .powershell
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unspecified: return 0
          case .shell: return 1
          case .powershell: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType] = [
    .unspecified,
    .tar,
    .tarGzip,
    .tarBzip,
    .tarLzma,
    .tarXz,
    .zip,
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript.Interpreter: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript.Interpreter] = [
    .unspecified,
    .shell,
    .powershell,
  ]
}

#endif  // swift(>=4.2)

/// A request message for getting effective policy assigned to the instance.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_LookupEffectiveGuestPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. This is the GCE instance identity token described in
  /// https://cloud.google.com/compute/docs/instances/verifying-instance-identity
  /// where the audience is 'osconfig.googleapis.com' and the format is 'full'.
  public var instanceIDToken: String = String()

  /// Short name of the OS running on the instance. The OS Config agent only
  /// provideS this field for targeting if OS Inventory is enabled for that
  /// instance.
  public var osShortName: String = String()

  /// Version of the OS running on the instance. The OS Config agent only
  /// provide this field for targeting if OS Inventory is enabled for that
  /// VM instance.
  public var osVersion: String = String()

  /// Architecture of OS running on the instance. The OS Config agent only
  /// provide this field for targeting if OS Inventory is enabled for that
  /// instance.
  public var osArchitecture: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The effective guest policy assigned to the instance.
public struct Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of package configurations assigned to the VM instance.
  public var packages: [Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackage] = []

  /// List of package repository configurations assigned to the VM instance.
  public var packageRepositories: [Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackageRepository] = []

  /// List of recipes assigned to the VM instance.
  public var softwareRecipes: [Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A guest policy package including its source.
  public struct SourcedPackage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the guest policy providing this config.
    public var source: String = String()

    /// A software package to configure on the VM instance.
    public var package: Google_Cloud_Osconfig_Agentendpoint_V1beta_Package {
      get {return _package ?? Google_Cloud_Osconfig_Agentendpoint_V1beta_Package()}
      set {_package = newValue}
    }
    /// Returns true if `package` has been explicitly set.
    public var hasPackage: Bool {return self._package != nil}
    /// Clears the value of `package`. Subsequent reads from it will return its default value.
    public mutating func clearPackage() {self._package = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _package: Google_Cloud_Osconfig_Agentendpoint_V1beta_Package? = nil
  }

  /// A guest policy package repository including its source.
  public struct SourcedPackageRepository {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the guest policy providing this config.
    public var source: String = String()

    /// A software package repository to configure on the VM instance.
    public var packageRepository: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository {
      get {return _packageRepository ?? Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository()}
      set {_packageRepository = newValue}
    }
    /// Returns true if `packageRepository` has been explicitly set.
    public var hasPackageRepository: Bool {return self._packageRepository != nil}
    /// Clears the value of `packageRepository`. Subsequent reads from it will return its default value.
    public mutating func clearPackageRepository() {self._packageRepository = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _packageRepository: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository? = nil
  }

  /// A guest policy recipe including its source.
  public struct SourcedSoftwareRecipe {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the guest policy providing this config.
    public var source: String = String()

    /// A software recipe to configure on the VM instance.
    public var softwareRecipe: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe {
      get {return _softwareRecipe ?? Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe()}
      set {_softwareRecipe = newValue}
    }
    /// Returns true if `softwareRecipe` has been explicitly set.
    public var hasSoftwareRecipe: Bool {return self._softwareRecipe != nil}
    /// Clears the value of `softwareRecipe`. Subsequent reads from it will return its default value.
    public mutating func clearSoftwareRecipe() {self._softwareRecipe = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _softwareRecipe: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.osconfig.agentendpoint.v1beta"

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_DesiredState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DESIRED_STATE_UNSPECIFIED"),
    1: .same(proto: "INSTALLED"),
    2: .same(proto: "UPDATED"),
    3: .same(proto: "REMOVED"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_Package: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Package"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "desired_state"),
    3: .same(proto: "manager"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.desiredState) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.manager) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.desiredState != .unspecified {
      try visitor.visitSingularEnumField(value: self.desiredState, fieldNumber: 2)
    }
    if self.manager != .unspecified {
      try visitor.visitSingularEnumField(value: self.manager, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_Package, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_Package) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.desiredState != rhs.desiredState {return false}
    if lhs.manager != rhs.manager {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_Package.Manager: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANAGER_UNSPECIFIED"),
    1: .same(proto: "ANY"),
    2: .same(proto: "APT"),
    3: .same(proto: "YUM"),
    4: .same(proto: "ZYPPER"),
    5: .same(proto: "GOO"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AptRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "archive_type"),
    2: .same(proto: "uri"),
    3: .same(proto: "distribution"),
    4: .same(proto: "components"),
    5: .standard(proto: "gpg_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.archiveType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.distribution) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.components) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.gpgKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.archiveType != .unspecified {
      try visitor.visitSingularEnumField(value: self.archiveType, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if !self.distribution.isEmpty {
      try visitor.visitSingularStringField(value: self.distribution, fieldNumber: 3)
    }
    if !self.components.isEmpty {
      try visitor.visitRepeatedStringField(value: self.components, fieldNumber: 4)
    }
    if !self.gpgKey.isEmpty {
      try visitor.visitSingularStringField(value: self.gpgKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository) -> Bool {
    if lhs.archiveType != rhs.archiveType {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.distribution != rhs.distribution {return false}
    if lhs.components != rhs.components {return false}
    if lhs.gpgKey != rhs.gpgKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository.ArchiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARCHIVE_TYPE_UNSPECIFIED"),
    1: .same(proto: "DEB"),
    2: .same(proto: "DEB_SRC"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".YumRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "base_url"),
    4: .standard(proto: "gpg_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseURL) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.gpgKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.baseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURL, fieldNumber: 3)
    }
    if !self.gpgKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gpgKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.baseURL != rhs.baseURL {return false}
    if lhs.gpgKeys != rhs.gpgKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ZypperRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "base_url"),
    4: .standard(proto: "gpg_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.baseURL) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.gpgKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.baseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURL, fieldNumber: 3)
    }
    if !self.gpgKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.gpgKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.baseURL != rhs.baseURL {return false}
    if lhs.gpgKeys != rhs.gpgKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GooRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "apt"),
    2: .same(proto: "yum"),
    3: .same(proto: "zypper"),
    4: .same(proto: "goo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_AptRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .apt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .apt(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_YumRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .yum(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .yum(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_ZypperRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .zypper(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .zypper(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_GooRepository?
        if let current = self.repository {
          try decoder.handleConflictingOneOf()
          if case .goo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.repository = .goo(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.repository {
    case .apt?: try {
      guard case .apt(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .yum?: try {
      guard case .yum(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .zypper?: try {
      guard case .zypper(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .goo?: try {
      guard case .goo(let v)? = self.repository else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_PackageRepository) -> Bool {
    if lhs.repository != rhs.repository {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SoftwareRecipe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
    3: .same(proto: "artifacts"),
    4: .standard(proto: "install_steps"),
    5: .standard(proto: "update_steps"),
    6: .standard(proto: "desired_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.artifacts) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.installSteps) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.updateSteps) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.desiredState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.artifacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.artifacts, fieldNumber: 3)
    }
    if !self.installSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.installSteps, fieldNumber: 4)
    }
    if !self.updateSteps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.updateSteps, fieldNumber: 5)
    }
    if self.desiredState != .unspecified {
      try visitor.visitSingularEnumField(value: self.desiredState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.artifacts != rhs.artifacts {return false}
    if lhs.installSteps != rhs.installSteps {return false}
    if lhs.updateSteps != rhs.updateSteps {return false}
    if lhs.desiredState != rhs.desiredState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.protoMessageName + ".Artifact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "remote"),
    3: .same(proto: "gcs"),
    4: .standard(proto: "allow_insecure"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote?
        if let current = self.artifact {
          try decoder.handleConflictingOneOf()
          if case .remote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.artifact = .remote(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs?
        if let current = self.artifact {
          try decoder.handleConflictingOneOf()
          if case .gcs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.artifact = .gcs(v)}
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowInsecure) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.artifact {
    case .remote?: try {
      guard case .remote(let v)? = self.artifact else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .gcs?: try {
      guard case .gcs(let v)? = self.artifact else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.allowInsecure != false {
      try visitor.visitSingularBoolField(value: self.allowInsecure, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.artifact != rhs.artifact {return false}
    if lhs.allowInsecure != rhs.allowInsecure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.protoMessageName + ".Remote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "checksum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.checksum.isEmpty {
      try visitor.visitSingularStringField(value: self.checksum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Remote) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.checksum != rhs.checksum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.protoMessageName + ".Gcs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "object"),
    3: .same(proto: "generation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.generation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 2)
    }
    if self.generation != 0 {
      try visitor.visitSingularInt64Field(value: self.generation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Artifact.Gcs) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.object != rhs.object {return false}
    if lhs.generation != rhs.generation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.protoMessageName + ".Step"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_copy"),
    2: .standard(proto: "archive_extraction"),
    3: .standard(proto: "msi_installation"),
    4: .standard(proto: "dpkg_installation"),
    5: .standard(proto: "rpm_installation"),
    6: .standard(proto: "file_exec"),
    7: .standard(proto: "script_run"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .fileCopy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .fileCopy(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .archiveExtraction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .archiveExtraction(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .msiInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .msiInstallation(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .dpkgInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .dpkgInstallation(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .rpmInstallation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .rpmInstallation(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .fileExec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .fileExec(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript?
        if let current = self.step {
          try decoder.handleConflictingOneOf()
          if case .scriptRun(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.step = .scriptRun(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.step {
    case .fileCopy?: try {
      guard case .fileCopy(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .archiveExtraction?: try {
      guard case .archiveExtraction(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .msiInstallation?: try {
      guard case .msiInstallation(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dpkgInstallation?: try {
      guard case .dpkgInstallation(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .rpmInstallation?: try {
      guard case .rpmInstallation(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .fileExec?: try {
      guard case .fileExec(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .scriptRun?: try {
      guard case .scriptRun(let v)? = self.step else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step) -> Bool {
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".CopyFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .same(proto: "destination"),
    3: .same(proto: "overwrite"),
    4: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.overwrite) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 2)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 3)
    }
    if !self.permissions.isEmpty {
      try visitor.visitSingularStringField(value: self.permissions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.CopyFile) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".ExtractArchive"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .same(proto: "destination"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.destination) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.destination.isEmpty {
      try visitor.visitSingularStringField(value: self.destination, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExtractArchive.ArchiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ARCHIVE_TYPE_UNSPECIFIED"),
    1: .same(proto: "TAR"),
    2: .same(proto: "TAR_GZIP"),
    3: .same(proto: "TAR_BZIP"),
    4: .same(proto: "TAR_LZMA"),
    5: .same(proto: "TAR_XZ"),
    11: .same(proto: "ZIP"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".InstallMsi"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .same(proto: "flags"),
    3: .standard(proto: "allowed_exit_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.flags) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedExitCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    if !self.flags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.flags, fieldNumber: 2)
    }
    if !self.allowedExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedExitCodes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallMsi) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.allowedExitCodes != rhs.allowedExitCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".InstallDpkg"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallDpkg) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".InstallRpm"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.artifactID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.artifactID.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.InstallRpm) -> Bool {
    if lhs.artifactID != rhs.artifactID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".ExecFile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "artifact_id"),
    2: .standard(proto: "local_path"),
    3: .same(proto: "args"),
    4: .standard(proto: "allowed_exit_codes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.locationType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationType = .artifactID(v)}
      }()
      case 2: try {
        if self.locationType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.locationType = .localPath(v)}
      }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedExitCodes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.locationType {
    case .artifactID?: try {
      guard case .artifactID(let v)? = self.locationType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .localPath?: try {
      guard case .localPath(let v)? = self.locationType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 3)
    }
    if !self.allowedExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedExitCodes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.ExecFile) -> Bool {
    if lhs.locationType != rhs.locationType {return false}
    if lhs.args != rhs.args {return false}
    if lhs.allowedExitCodes != rhs.allowedExitCodes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.protoMessageName + ".RunScript"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "script"),
    2: .standard(proto: "allowed_exit_codes"),
    3: .same(proto: "interpreter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.script) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedExitCodes) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.interpreter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.script.isEmpty {
      try visitor.visitSingularStringField(value: self.script, fieldNumber: 1)
    }
    if !self.allowedExitCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedExitCodes, fieldNumber: 2)
    }
    if self.interpreter != .unspecified {
      try visitor.visitSingularEnumField(value: self.interpreter, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript) -> Bool {
    if lhs.script != rhs.script {return false}
    if lhs.allowedExitCodes != rhs.allowedExitCodes {return false}
    if lhs.interpreter != rhs.interpreter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_SoftwareRecipe.Step.RunScript.Interpreter: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERPRETER_UNSPECIFIED"),
    1: .same(proto: "SHELL"),
    3: .same(proto: "POWERSHELL"),
  ]
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_LookupEffectiveGuestPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookupEffectiveGuestPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_id_token"),
    2: .standard(proto: "os_short_name"),
    3: .standard(proto: "os_version"),
    4: .standard(proto: "os_architecture"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceIDToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.osShortName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osArchitecture) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceIDToken.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceIDToken, fieldNumber: 1)
    }
    if !self.osShortName.isEmpty {
      try visitor.visitSingularStringField(value: self.osShortName, fieldNumber: 2)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 3)
    }
    if !self.osArchitecture.isEmpty {
      try visitor.visitSingularStringField(value: self.osArchitecture, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_LookupEffectiveGuestPolicyRequest, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_LookupEffectiveGuestPolicyRequest) -> Bool {
    if lhs.instanceIDToken != rhs.instanceIDToken {return false}
    if lhs.osShortName != rhs.osShortName {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.osArchitecture != rhs.osArchitecture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EffectiveGuestPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "packages"),
    2: .standard(proto: "package_repositories"),
    3: .standard(proto: "software_recipes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.packages) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.packageRepositories) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.softwareRecipes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.packages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packages, fieldNumber: 1)
    }
    if !self.packageRepositories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packageRepositories, fieldNumber: 2)
    }
    if !self.softwareRecipes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.softwareRecipes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy) -> Bool {
    if lhs.packages != rhs.packages {return false}
    if lhs.packageRepositories != rhs.packageRepositories {return false}
    if lhs.softwareRecipes != rhs.softwareRecipes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.protoMessageName + ".SourcedPackage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .same(proto: "package"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._package) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if let v = self._package {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackage, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackage) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._package != rhs._package {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackageRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.protoMessageName + ".SourcedPackageRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "package_repository"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._packageRepository) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if let v = self._packageRepository {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackageRepository, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedPackageRepository) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._packageRepository != rhs._packageRepository {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.protoMessageName + ".SourcedSoftwareRecipe"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "software_recipe"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.source) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._softwareRecipe) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.source.isEmpty {
      try visitor.visitSingularStringField(value: self.source, fieldNumber: 1)
    }
    if let v = self._softwareRecipe {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe, rhs: Google_Cloud_Osconfig_Agentendpoint_V1beta_EffectiveGuestPolicy.SourcedSoftwareRecipe) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs._softwareRecipe != rhs._softwareRecipe {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

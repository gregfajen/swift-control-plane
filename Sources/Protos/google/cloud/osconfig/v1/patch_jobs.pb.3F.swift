// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/osconfig/v1/patch_jobs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A request message to initiate patching across Compute Engine
/// instances.
public struct Google_Cloud_Osconfig_V1_ExecutePatchJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project in which to run this patch in the form `projects/*`
  public var parent: String = String()

  /// Description of the patch job. Length of the description is limited
  /// to 1024 characters.
  public var description_p: String = String()

  /// Required. Instances to patch, either explicitly or filtered by some criteria such
  /// as zone or labels.
  public var instanceFilter: Google_Cloud_Osconfig_V1_PatchInstanceFilter {
    get {return _instanceFilter ?? Google_Cloud_Osconfig_V1_PatchInstanceFilter()}
    set {_instanceFilter = newValue}
  }
  /// Returns true if `instanceFilter` has been explicitly set.
  public var hasInstanceFilter: Bool {return self._instanceFilter != nil}
  /// Clears the value of `instanceFilter`. Subsequent reads from it will return its default value.
  public mutating func clearInstanceFilter() {self._instanceFilter = nil}

  /// Patch configuration being applied. If omitted, instances are
  /// patched using the default configurations.
  public var patchConfig: Google_Cloud_Osconfig_V1_PatchConfig {
    get {return _patchConfig ?? Google_Cloud_Osconfig_V1_PatchConfig()}
    set {_patchConfig = newValue}
  }
  /// Returns true if `patchConfig` has been explicitly set.
  public var hasPatchConfig: Bool {return self._patchConfig != nil}
  /// Clears the value of `patchConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPatchConfig() {self._patchConfig = nil}

  /// Duration of the patch job. After the duration ends, the patch job
  /// times out.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// If this patch is a dry-run only, instances are contacted but
  /// will do nothing.
  public var dryRun: Bool = false

  /// Display name for this patch job. This does not have to be unique.
  public var displayName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instanceFilter: Google_Cloud_Osconfig_V1_PatchInstanceFilter? = nil
  fileprivate var _patchConfig: Google_Cloud_Osconfig_V1_PatchConfig? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Request to get an active or completed patch job.
public struct Google_Cloud_Osconfig_V1_GetPatchJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the patch in the form `projects/*/patchJobs/*`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list details for all instances that are part of a patch job.
public struct Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent for the instances are in the form of `projects/*/patchJobs/*`.
  public var parent: String = String()

  /// The maximum number of instance details records to return.  Default is 100.
  public var pageSize: Int32 = 0

  /// A pagination token returned from a previous call
  /// that indicates where this listing should continue from.
  public var pageToken: String = String()

  /// A filter expression that filters results listed in the response. This
  /// field supports filtering results by instance zone, name, state, or
  /// `failure_reason`.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for listing the instances details for a patch job.
public struct Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of instance status.
  public var patchJobInstanceDetails: [Google_Cloud_Osconfig_V1_PatchJobInstanceDetails] = []

  /// A pagination token that can be used to get the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Patch details for a VM instance. For more information about reviewing VM
/// instance details, see
/// [Listing all VM instance details for a specific patch
/// job](https://cloud.google.com/compute/docs/os-patch-management/manage-patch-jobs#list-instance-details).
public struct Google_Cloud_Osconfig_V1_PatchJobInstanceDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance name in the form `projects/*/zones/*/instances/*`
  public var name: String = String()

  /// The unique identifier for the instance. This identifier is
  /// defined by the server.
  public var instanceSystemID: String = String()

  /// Current state of instance patch.
  public var state: Google_Cloud_Osconfig_V1_Instance.PatchState = .unspecified

  /// If the patch fails, this field provides the reason.
  public var failureReason: String = String()

  /// The number of times the agent that the agent attempts to apply the patch.
  public var attemptCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request message for listing patch jobs.
public struct Google_Cloud_Osconfig_V1_ListPatchJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. In the form of `projects/*`
  public var parent: String = String()

  /// The maximum number of instance status to return.
  public var pageSize: Int32 = 0

  /// A pagination token returned from a previous call
  /// that indicates where this listing should continue from.
  public var pageToken: String = String()

  /// If provided, this field specifies the criteria that must be met by patch
  /// jobs to be included in the response.
  /// Currently, filtering is only available on the patch_deployment field.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A response message for listing patch jobs.
public struct Google_Cloud_Osconfig_V1_ListPatchJobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of patch jobs.
  public var patchJobs: [Google_Cloud_Osconfig_V1_PatchJob] = []

  /// A pagination token that can be used to get the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A high level representation of a patch job that is either in progress
/// or has completed.
///
/// Instances details are not included in the job. To paginate through instance
/// details, use ListPatchJobInstanceDetails.
///
/// For more information about patch jobs, see
/// [Creating patch
/// jobs](https://cloud.google.com/compute/docs/os-patch-management/create-patch-job).
public struct Google_Cloud_Osconfig_V1_PatchJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for this patch job in the form
  /// `projects/*/patchJobs/*`
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Display name for this patch job. This is not a unique identifier.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Description of the patch job. Length of the description is limited
  /// to 1024 characters.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Time this patch job was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Last time this patch job was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// The current state of the PatchJob .
  public var state: Google_Cloud_Osconfig_V1_PatchJob.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Instances to patch.
  public var instanceFilter: Google_Cloud_Osconfig_V1_PatchInstanceFilter {
    get {return _storage._instanceFilter ?? Google_Cloud_Osconfig_V1_PatchInstanceFilter()}
    set {_uniqueStorage()._instanceFilter = newValue}
  }
  /// Returns true if `instanceFilter` has been explicitly set.
  public var hasInstanceFilter: Bool {return _storage._instanceFilter != nil}
  /// Clears the value of `instanceFilter`. Subsequent reads from it will return its default value.
  public mutating func clearInstanceFilter() {_uniqueStorage()._instanceFilter = nil}

  /// Patch configuration being applied.
  public var patchConfig: Google_Cloud_Osconfig_V1_PatchConfig {
    get {return _storage._patchConfig ?? Google_Cloud_Osconfig_V1_PatchConfig()}
    set {_uniqueStorage()._patchConfig = newValue}
  }
  /// Returns true if `patchConfig` has been explicitly set.
  public var hasPatchConfig: Bool {return _storage._patchConfig != nil}
  /// Clears the value of `patchConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPatchConfig() {_uniqueStorage()._patchConfig = nil}

  /// Duration of the patch job. After the duration ends, the
  /// patch job times out.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return _storage._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {_uniqueStorage()._duration = nil}

  /// Summary of instance details.
  public var instanceDetailsSummary: Google_Cloud_Osconfig_V1_PatchJob.InstanceDetailsSummary {
    get {return _storage._instanceDetailsSummary ?? Google_Cloud_Osconfig_V1_PatchJob.InstanceDetailsSummary()}
    set {_uniqueStorage()._instanceDetailsSummary = newValue}
  }
  /// Returns true if `instanceDetailsSummary` has been explicitly set.
  public var hasInstanceDetailsSummary: Bool {return _storage._instanceDetailsSummary != nil}
  /// Clears the value of `instanceDetailsSummary`. Subsequent reads from it will return its default value.
  public mutating func clearInstanceDetailsSummary() {_uniqueStorage()._instanceDetailsSummary = nil}

  /// If this patch job is a dry run, the agent reports that it has
  /// finished without running any updates on the VM instance.
  public var dryRun: Bool {
    get {return _storage._dryRun}
    set {_uniqueStorage()._dryRun = newValue}
  }

  /// If this patch job failed, this message provides information about the
  /// failure.
  public var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  /// Reflects the overall progress of the patch job in the range of
  /// 0.0 being no progress to 100.0 being complete.
  public var percentComplete: Double {
    get {return _storage._percentComplete}
    set {_uniqueStorage()._percentComplete = newValue}
  }

  /// Output only. Name of the patch deployment that created this patch job.
  public var patchDeployment: String {
    get {return _storage._patchDeployment}
    set {_uniqueStorage()._patchDeployment = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumeration of the various states a patch job passes through as it
  /// executes.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// State must be specified.
    case unspecified // = 0

    /// The patch job was successfully initiated.
    case started // = 1

    /// The patch job is looking up instances to run the patch on.
    case instanceLookup // = 2

    /// Instances are being patched.
    case patching // = 3

    /// Patch job completed successfully.
    case succeeded // = 4

    /// Patch job completed but there were errors.
    case completedWithErrors // = 5

    /// The patch job was canceled.
    case canceled // = 6

    /// The patch job timed out.
    case timedOut // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .started
      case 2: self = .instanceLookup
      case 3: self = .patching
      case 4: self = .succeeded
      case 5: self = .completedWithErrors
      case 6: self = .canceled
      case 7: self = .timedOut
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .started: return 1
      case .instanceLookup: return 2
      case .patching: return 3
      case .succeeded: return 4
      case .completedWithErrors: return 5
      case .canceled: return 6
      case .timedOut: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A summary of the current patch state across all instances that this patch
  /// job affects. Contains counts of instances in different states. These states
  /// map to `InstancePatchState`. List patch job instance details to see the
  /// specific states of each instance.
  public struct InstanceDetailsSummary {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Number of instances pending patch job.
    public var pendingInstanceCount: Int64 = 0

    /// Number of instances that are inactive.
    public var inactiveInstanceCount: Int64 = 0

    /// Number of instances notified about patch job.
    public var notifiedInstanceCount: Int64 = 0

    /// Number of instances that have started.
    public var startedInstanceCount: Int64 = 0

    /// Number of instances that are downloading patches.
    public var downloadingPatchesInstanceCount: Int64 = 0

    /// Number of instances that are applying patches.
    public var applyingPatchesInstanceCount: Int64 = 0

    /// Number of instances rebooting.
    public var rebootingInstanceCount: Int64 = 0

    /// Number of instances that have completed successfully.
    public var succeededInstanceCount: Int64 = 0

    /// Number of instances that require reboot.
    public var succeededRebootRequiredInstanceCount: Int64 = 0

    /// Number of instances that failed.
    public var failedInstanceCount: Int64 = 0

    /// Number of instances that have acked and will start shortly.
    public var ackedInstanceCount: Int64 = 0

    /// Number of instances that exceeded the time out while applying the patch.
    public var timedOutInstanceCount: Int64 = 0

    /// Number of instances that are running the pre-patch step.
    public var prePatchStepInstanceCount: Int64 = 0

    /// Number of instances that are running the post-patch step.
    public var postPatchStepInstanceCount: Int64 = 0

    /// Number of instances that do not appear to be running the agent. Check to
    /// ensure that the agent is installed, running, and able to communicate with
    /// the service.
    public var noAgentDetectedInstanceCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1_PatchJob.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1_PatchJob.State] = [
    .unspecified,
    .started,
    .instanceLookup,
    .patching,
    .succeeded,
    .completedWithErrors,
    .canceled,
    .timedOut,
  ]
}

#endif  // swift(>=4.2)

/// Patch configuration specifications. Contains details on how to apply the
/// patch(es) to a VM instance.
public struct Google_Cloud_Osconfig_V1_PatchConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Post-patch reboot settings.
  public var rebootConfig: Google_Cloud_Osconfig_V1_PatchConfig.RebootConfig {
    get {return _storage._rebootConfig}
    set {_uniqueStorage()._rebootConfig = newValue}
  }

  /// Apt update settings. Use this setting to override the default `apt` patch
  /// rules.
  public var apt: Google_Cloud_Osconfig_V1_AptSettings {
    get {return _storage._apt ?? Google_Cloud_Osconfig_V1_AptSettings()}
    set {_uniqueStorage()._apt = newValue}
  }
  /// Returns true if `apt` has been explicitly set.
  public var hasApt: Bool {return _storage._apt != nil}
  /// Clears the value of `apt`. Subsequent reads from it will return its default value.
  public mutating func clearApt() {_uniqueStorage()._apt = nil}

  /// Yum update settings. Use this setting to override the default `yum` patch
  /// rules.
  public var yum: Google_Cloud_Osconfig_V1_YumSettings {
    get {return _storage._yum ?? Google_Cloud_Osconfig_V1_YumSettings()}
    set {_uniqueStorage()._yum = newValue}
  }
  /// Returns true if `yum` has been explicitly set.
  public var hasYum: Bool {return _storage._yum != nil}
  /// Clears the value of `yum`. Subsequent reads from it will return its default value.
  public mutating func clearYum() {_uniqueStorage()._yum = nil}

  /// Goo update settings. Use this setting to override the default `goo` patch
  /// rules.
  public var goo: Google_Cloud_Osconfig_V1_GooSettings {
    get {return _storage._goo ?? Google_Cloud_Osconfig_V1_GooSettings()}
    set {_uniqueStorage()._goo = newValue}
  }
  /// Returns true if `goo` has been explicitly set.
  public var hasGoo: Bool {return _storage._goo != nil}
  /// Clears the value of `goo`. Subsequent reads from it will return its default value.
  public mutating func clearGoo() {_uniqueStorage()._goo = nil}

  /// Zypper update settings. Use this setting to override the default `zypper`
  /// patch rules.
  public var zypper: Google_Cloud_Osconfig_V1_ZypperSettings {
    get {return _storage._zypper ?? Google_Cloud_Osconfig_V1_ZypperSettings()}
    set {_uniqueStorage()._zypper = newValue}
  }
  /// Returns true if `zypper` has been explicitly set.
  public var hasZypper: Bool {return _storage._zypper != nil}
  /// Clears the value of `zypper`. Subsequent reads from it will return its default value.
  public mutating func clearZypper() {_uniqueStorage()._zypper = nil}

  /// Windows update settings. Use this override the default windows patch rules.
  public var windowsUpdate: Google_Cloud_Osconfig_V1_WindowsUpdateSettings {
    get {return _storage._windowsUpdate ?? Google_Cloud_Osconfig_V1_WindowsUpdateSettings()}
    set {_uniqueStorage()._windowsUpdate = newValue}
  }
  /// Returns true if `windowsUpdate` has been explicitly set.
  public var hasWindowsUpdate: Bool {return _storage._windowsUpdate != nil}
  /// Clears the value of `windowsUpdate`. Subsequent reads from it will return its default value.
  public mutating func clearWindowsUpdate() {_uniqueStorage()._windowsUpdate = nil}

  /// The `ExecStep` to run before the patch update.
  public var preStep: Google_Cloud_Osconfig_V1_ExecStep {
    get {return _storage._preStep ?? Google_Cloud_Osconfig_V1_ExecStep()}
    set {_uniqueStorage()._preStep = newValue}
  }
  /// Returns true if `preStep` has been explicitly set.
  public var hasPreStep: Bool {return _storage._preStep != nil}
  /// Clears the value of `preStep`. Subsequent reads from it will return its default value.
  public mutating func clearPreStep() {_uniqueStorage()._preStep = nil}

  /// The `ExecStep` to run after the patch update.
  public var postStep: Google_Cloud_Osconfig_V1_ExecStep {
    get {return _storage._postStep ?? Google_Cloud_Osconfig_V1_ExecStep()}
    set {_uniqueStorage()._postStep = newValue}
  }
  /// Returns true if `postStep` has been explicitly set.
  public var hasPostStep: Bool {return _storage._postStep != nil}
  /// Clears the value of `postStep`. Subsequent reads from it will return its default value.
  public mutating func clearPostStep() {_uniqueStorage()._postStep = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Post-patch reboot settings.
  public enum RebootConfig: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The default behavior is DEFAULT.
    case unspecified // = 0

    /// The agent decides if a reboot is necessary by checking signals such as
    /// registry keys on Windows or `/var/run/reboot-required` on APT based
    /// systems. On RPM based systems, a set of core system package install times
    /// are compared with system boot time.
    case `default` // = 1

    /// Always reboot the machine after the update completes.
    case always // = 2

    /// Never reboot the machine after the update completes.
    case never // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .default
      case 2: self = .always
      case 3: self = .never
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .default: return 1
      case .always: return 2
      case .never: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1_PatchConfig.RebootConfig: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1_PatchConfig.RebootConfig] = [
    .unspecified,
    .default,
    .always,
    .never,
  ]
}

#endif  // swift(>=4.2)

/// Namespace for instance state enums.
public struct Google_Cloud_Osconfig_V1_Instance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Patch state of an instance.
  public enum PatchState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// The instance is not yet notified.
    case pending // = 1

    /// Instance is inactive and cannot be patched.
    case inactive // = 2

    /// The instance is notified that it should be patched.
    case notified // = 3

    /// The instance has started the patching process.
    case started // = 4

    /// The instance is downloading patches.
    case downloadingPatches // = 5

    /// The instance is applying patches.
    case applyingPatches // = 6

    /// The instance is rebooting.
    case rebooting // = 7

    /// The instance has completed applying patches.
    case succeeded // = 8

    /// The instance has completed applying patches but a reboot is required.
    case succeededRebootRequired // = 9

    /// The instance has failed to apply the patch.
    case failed // = 10

    /// The instance acked the notification and will start shortly.
    case acked // = 11

    /// The instance exceeded the time out while applying the patch.
    case timedOut // = 12

    /// The instance is running the pre-patch step.
    case runningPrePatchStep // = 13

    /// The instance is running the post-patch step.
    case runningPostPatchStep // = 14

    /// The service could not detect the presence of the agent. Check to ensure
    /// that the agent is installed, running, and able to communicate with the
    /// service.
    case noAgentDetected // = 15
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .inactive
      case 3: self = .notified
      case 4: self = .started
      case 5: self = .downloadingPatches
      case 6: self = .applyingPatches
      case 7: self = .rebooting
      case 8: self = .succeeded
      case 9: self = .succeededRebootRequired
      case 10: self = .failed
      case 11: self = .acked
      case 12: self = .timedOut
      case 13: self = .runningPrePatchStep
      case 14: self = .runningPostPatchStep
      case 15: self = .noAgentDetected
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .inactive: return 2
      case .notified: return 3
      case .started: return 4
      case .downloadingPatches: return 5
      case .applyingPatches: return 6
      case .rebooting: return 7
      case .succeeded: return 8
      case .succeededRebootRequired: return 9
      case .failed: return 10
      case .acked: return 11
      case .timedOut: return 12
      case .runningPrePatchStep: return 13
      case .runningPostPatchStep: return 14
      case .noAgentDetected: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1_Instance.PatchState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1_Instance.PatchState] = [
    .unspecified,
    .pending,
    .inactive,
    .notified,
    .started,
    .downloadingPatches,
    .applyingPatches,
    .rebooting,
    .succeeded,
    .succeededRebootRequired,
    .failed,
    .acked,
    .timedOut,
    .runningPrePatchStep,
    .runningPostPatchStep,
    .noAgentDetected,
  ]
}

#endif  // swift(>=4.2)

/// Message for canceling a patch job.
public struct Google_Cloud_Osconfig_V1_CancelPatchJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the patch in the form `projects/*/patchJobs/*`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Apt patching is completed by executing `apt-get update && apt-get
/// upgrade`. Additional options can be set to control how this is executed.
public struct Google_Cloud_Osconfig_V1_AptSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// By changing the type to DIST, the patching is performed
  /// using `apt-get dist-upgrade` instead.
  public var type: Google_Cloud_Osconfig_V1_AptSettings.TypeEnum = .unspecified

  /// List of packages to exclude from update. These packages will be excluded
  public var excludes: [String] = []

  /// An exclusive list of packages to be updated. These are the only packages
  /// that will be updated. If these packages are not installed, they will be
  /// ignored. This field cannot be specified with any other patch configuration
  /// fields.
  public var exclusivePackages: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Apt patch type.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// By default, upgrade will be performed.
    case unspecified // = 0

    /// Runs `apt-get dist-upgrade`.
    case dist // = 1

    /// Runs `apt-get upgrade`.
    case upgrade // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .dist
      case 2: self = .upgrade
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .dist: return 1
      case .upgrade: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1_AptSettings.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1_AptSettings.TypeEnum] = [
    .unspecified,
    .dist,
    .upgrade,
  ]
}

#endif  // swift(>=4.2)

/// Yum patching is performed by executing `yum update`. Additional options
/// can be set to control how this is executed.
///
/// Note that not all settings are supported on all platforms.
public struct Google_Cloud_Osconfig_V1_YumSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Adds the `--security` flag to `yum update`. Not supported on
  /// all platforms.
  public var security: Bool = false

  /// Will cause patch to run `yum update-minimal` instead.
  public var minimal: Bool = false

  /// List of packages to exclude from update. These packages are excluded by
  /// using the yum `--exclude` flag.
  public var excludes: [String] = []

  /// An exclusive list of packages to be updated. These are the only packages
  /// that will be updated. If these packages are not installed, they will be
  /// ignored. This field must not be specified with any other patch
  /// configuration fields.
  public var exclusivePackages: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Googet patching is performed by running `googet update`.
public struct Google_Cloud_Osconfig_V1_GooSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Zypper patching is performed by running `zypper patch`.
/// See also https://en.opensuse.org/SDB:Zypper_manual.
public struct Google_Cloud_Osconfig_V1_ZypperSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Adds the `--with-optional` flag to `zypper patch`.
  public var withOptional: Bool = false

  /// Adds the `--with-update` flag, to `zypper patch`.
  public var withUpdate: Bool = false

  /// Install only patches with these categories.
  /// Common categories include security, recommended, and feature.
  public var categories: [String] = []

  /// Install only patches with these severities.
  /// Common severities include critical, important, moderate, and low.
  public var severities: [String] = []

  /// List of patches to exclude from update.
  public var excludes: [String] = []

  /// An exclusive list of patches to be updated. These are the only patches
  /// that will be installed using 'zypper patch patch:<patch_name>' command.
  /// This field must not be used with any other patch configuration fields.
  public var exclusivePatches: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Windows patching is performed using the Windows Update Agent.
public struct Google_Cloud_Osconfig_V1_WindowsUpdateSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only apply updates of these windows update classifications. If empty, all
  /// updates are applied.
  public var classifications: [Google_Cloud_Osconfig_V1_WindowsUpdateSettings.Classification] = []

  /// List of KBs to exclude from update.
  public var excludes: [String] = []

  /// An exclusive list of kbs to be updated. These are the only patches
  /// that will be updated. This field must not be used with other
  /// patch configurations.
  public var exclusivePatches: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Microsoft Windows update classifications as defined in
  /// [1]
  /// https://support.microsoft.com/en-us/help/824684/description-of-the-standard-terminology-that-is-used-to-describe-micro
  public enum Classification: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid. If classifications are included, they must be specified.
    case unspecified // = 0

    /// "A widely released fix for a specific problem that addresses a critical,
    /// non-security-related bug." [1]
    case critical // = 1

    /// "A widely released fix for a product-specific, security-related
    /// vulnerability. Security vulnerabilities are rated by their severity. The
    /// severity rating is indicated in the Microsoft security bulletin as
    /// critical, important, moderate, or low." [1]
    case security // = 2

    /// "A widely released and frequent software update that contains additions
    /// to a product's definition database. Definition databases are often used
    /// to detect objects that have specific attributes, such as malicious code,
    /// phishing websites, or junk mail." [1]
    case definition // = 3

    /// "Software that controls the input and output of a device." [1]
    case driver // = 4

    /// "New product functionality that is first distributed outside the context
    /// of a product release and that is typically included in the next full
    /// product release." [1]
    case featurePack // = 5

    /// "A tested, cumulative set of all hotfixes, security updates, critical
    /// updates, and updates. Additionally, service packs may contain additional
    /// fixes for problems that are found internally since the release of the
    /// product. Service packs my also contain a limited number of
    /// customer-requested design changes or features." [1]
    case servicePack // = 6

    /// "A utility or feature that helps complete a task or set of tasks." [1]
    case tool // = 7

    /// "A tested, cumulative set of hotfixes, security updates, critical
    /// updates, and updates that are packaged together for easy deployment. A
    /// rollup generally targets a specific area, such as security, or a
    /// component of a product, such as Internet Information Services (IIS)." [1]
    case updateRollup // = 8

    /// "A widely released fix for a specific problem. An update addresses a
    /// noncritical, non-security-related bug." [1]
    case update // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .critical
      case 2: self = .security
      case 3: self = .definition
      case 4: self = .driver
      case 5: self = .featurePack
      case 6: self = .servicePack
      case 7: self = .tool
      case 8: self = .updateRollup
      case 9: self = .update
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .critical: return 1
      case .security: return 2
      case .definition: return 3
      case .driver: return 4
      case .featurePack: return 5
      case .servicePack: return 6
      case .tool: return 7
      case .updateRollup: return 8
      case .update: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1_WindowsUpdateSettings.Classification: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1_WindowsUpdateSettings.Classification] = [
    .unspecified,
    .critical,
    .security,
    .definition,
    .driver,
    .featurePack,
    .servicePack,
    .tool,
    .updateRollup,
    .update,
  ]
}

#endif  // swift(>=4.2)

/// A step that runs an executable for a PatchJob.
public struct Google_Cloud_Osconfig_V1_ExecStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ExecStepConfig for all Linux VMs targeted by the PatchJob.
  public var linuxExecStepConfig: Google_Cloud_Osconfig_V1_ExecStepConfig {
    get {return _linuxExecStepConfig ?? Google_Cloud_Osconfig_V1_ExecStepConfig()}
    set {_linuxExecStepConfig = newValue}
  }
  /// Returns true if `linuxExecStepConfig` has been explicitly set.
  public var hasLinuxExecStepConfig: Bool {return self._linuxExecStepConfig != nil}
  /// Clears the value of `linuxExecStepConfig`. Subsequent reads from it will return its default value.
  public mutating func clearLinuxExecStepConfig() {self._linuxExecStepConfig = nil}

  /// The ExecStepConfig for all Windows VMs targeted by the PatchJob.
  public var windowsExecStepConfig: Google_Cloud_Osconfig_V1_ExecStepConfig {
    get {return _windowsExecStepConfig ?? Google_Cloud_Osconfig_V1_ExecStepConfig()}
    set {_windowsExecStepConfig = newValue}
  }
  /// Returns true if `windowsExecStepConfig` has been explicitly set.
  public var hasWindowsExecStepConfig: Bool {return self._windowsExecStepConfig != nil}
  /// Clears the value of `windowsExecStepConfig`. Subsequent reads from it will return its default value.
  public mutating func clearWindowsExecStepConfig() {self._windowsExecStepConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _linuxExecStepConfig: Google_Cloud_Osconfig_V1_ExecStepConfig? = nil
  fileprivate var _windowsExecStepConfig: Google_Cloud_Osconfig_V1_ExecStepConfig? = nil
}

/// Common configurations for an ExecStep.
public struct Google_Cloud_Osconfig_V1_ExecStepConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location of the executable.
  public var executable: Google_Cloud_Osconfig_V1_ExecStepConfig.OneOf_Executable? = nil

  /// An absolute path to the executable on the VM.
  public var localPath: String {
    get {
      if case .localPath(let v)? = executable {return v}
      return String()
    }
    set {executable = .localPath(newValue)}
  }

  /// A Cloud Storage object containing the executable.
  public var gcsObject: Google_Cloud_Osconfig_V1_GcsObject {
    get {
      if case .gcsObject(let v)? = executable {return v}
      return Google_Cloud_Osconfig_V1_GcsObject()
    }
    set {executable = .gcsObject(newValue)}
  }

  /// Defaults to [0]. A list of possible return values that the
  /// execution can return to indicate a success.
  public var allowedSuccessCodes: [Int32] = []

  /// The script interpreter to use to run the script. If no interpreter is
  /// specified the script will be executed directly, which will likely
  /// only succeed for scripts with [shebang lines]
  /// (https://en.wikipedia.org/wiki/Shebang_\(Unix\)).
  public var interpreter: Google_Cloud_Osconfig_V1_ExecStepConfig.Interpreter = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Location of the executable.
  public enum OneOf_Executable: Equatable {
    /// An absolute path to the executable on the VM.
    case localPath(String)
    /// A Cloud Storage object containing the executable.
    case gcsObject(Google_Cloud_Osconfig_V1_GcsObject)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Osconfig_V1_ExecStepConfig.OneOf_Executable, rhs: Google_Cloud_Osconfig_V1_ExecStepConfig.OneOf_Executable) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.localPath, .localPath): return {
        guard case .localPath(let l) = lhs, case .localPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsObject, .gcsObject): return {
        guard case .gcsObject(let l) = lhs, case .gcsObject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The interpreter used to execute the a file.
  public enum Interpreter: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Invalid for a Windows ExecStepConfig. For a Linux ExecStepConfig, the
    /// interpreter will be parsed from the shebang line of the script if
    /// unspecified.
    case unspecified // = 0

    /// Indicates that the script is run with `/bin/sh` on Linux and `cmd`
    /// on Windows.
    case shell // = 1

    /// Indicates that the file is run with PowerShell flags
    /// `-NonInteractive`, `-NoProfile`, and `-ExecutionPolicy Bypass`.
    case powershell // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .shell
      case 2: self = .powershell
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .shell: return 1
      case .powershell: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Osconfig_V1_ExecStepConfig.Interpreter: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Osconfig_V1_ExecStepConfig.Interpreter] = [
    .unspecified,
    .shell,
    .powershell,
  ]
}

#endif  // swift(>=4.2)

/// Cloud Storage object representation.
public struct Google_Cloud_Osconfig_V1_GcsObject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Bucket of the Cloud Storage object.
  public var bucket: String = String()

  /// Required. Name of the Cloud Storage object.
  public var object: String = String()

  /// Required. Generation number of the Cloud Storage object. This is used to
  /// ensure that the ExecStep specified by this PatchJob does not change.
  public var generationNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A filter to target VM instances for patching. The targeted
/// VMs must meet all criteria specified. So if both labels and zones are
/// specified, the patch job targets only VMs with those labels and in those
/// zones.
public struct Google_Cloud_Osconfig_V1_PatchInstanceFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target all VM instances in the project. If true, no other criteria is
  /// permitted.
  public var all: Bool = false

  /// Targets VM instances matching ANY of these GroupLabels. This allows
  /// targeting of disparate groups of VM instances.
  public var groupLabels: [Google_Cloud_Osconfig_V1_PatchInstanceFilter.GroupLabel] = []

  /// Targets VM instances in ANY of these zones. Leave empty to target VM
  /// instances in any zone.
  public var zones: [String] = []

  /// Targets any of the VM instances specified. Instances are specified by their
  /// URI in the form `zones/[ZONE]/instances/[INSTANCE_NAME]`,
  /// `projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`, or
  /// `https://www.googleapis.com/compute/v1/projects/[PROJECT_ID]/zones/[ZONE]/instances/[INSTANCE_NAME]`
  public var instances: [String] = []

  /// Targets VMs whose name starts with one of these prefixes. Similar to
  /// labels, this is another way to group VMs when targeting configs, for
  /// example prefix="prod-".
  public var instanceNamePrefixes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Targets a group of VM instances by using their [assigned
  /// labels](https://cloud.google.com/compute/docs/labeling-resources). Labels
  /// are key-value pairs. A `GroupLabel` is a combination of labels
  /// that is used to target VMs for a patch job.
  ///
  /// For example, a patch job can target VMs that have the following
  /// `GroupLabel`: `{"env":"test", "app":"web"}`. This means that the patch job
  /// is applied to VMs that have both the labels `env=test` and `app=web`.
  public struct GroupLabel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Compute Engine instance labels that must be present for a VM
    /// instance to be targeted by this filter.
    public var labels: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.osconfig.v1"

extension Google_Cloud_Osconfig_V1_ExecutePatchJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecutePatchJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "description"),
    7: .standard(proto: "instance_filter"),
    4: .standard(proto: "patch_config"),
    5: .same(proto: "duration"),
    6: .standard(proto: "dry_run"),
    8: .standard(proto: "display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._patchConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._instanceFilter) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._patchConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 6)
    }
    if let v = self._instanceFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ExecutePatchJobRequest, rhs: Google_Cloud_Osconfig_V1_ExecutePatchJobRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._instanceFilter != rhs._instanceFilter {return false}
    if lhs._patchConfig != rhs._patchConfig {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_GetPatchJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPatchJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_GetPatchJobRequest, rhs: Google_Cloud_Osconfig_V1_GetPatchJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPatchJobInstanceDetailsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsRequest, rhs: Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPatchJobInstanceDetailsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "patch_job_instance_details"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.patchJobInstanceDetails) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchJobInstanceDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patchJobInstanceDetails, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsResponse, rhs: Google_Cloud_Osconfig_V1_ListPatchJobInstanceDetailsResponse) -> Bool {
    if lhs.patchJobInstanceDetails != rhs.patchJobInstanceDetails {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchJobInstanceDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchJobInstanceDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "instance_system_id"),
    3: .same(proto: "state"),
    4: .standard(proto: "failure_reason"),
    5: .standard(proto: "attempt_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instanceSystemID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.failureReason) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.attemptCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.instanceSystemID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceSystemID, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.failureReason.isEmpty {
      try visitor.visitSingularStringField(value: self.failureReason, fieldNumber: 4)
    }
    if self.attemptCount != 0 {
      try visitor.visitSingularInt64Field(value: self.attemptCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_PatchJobInstanceDetails, rhs: Google_Cloud_Osconfig_V1_PatchJobInstanceDetails) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.instanceSystemID != rhs.instanceSystemID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.failureReason != rhs.failureReason {return false}
    if lhs.attemptCount != rhs.attemptCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ListPatchJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPatchJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ListPatchJobsRequest, rhs: Google_Cloud_Osconfig_V1_ListPatchJobsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ListPatchJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListPatchJobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "patch_jobs"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.patchJobs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchJobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.patchJobs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ListPatchJobsResponse, rhs: Google_Cloud_Osconfig_V1_ListPatchJobsResponse) -> Bool {
    if lhs.patchJobs != rhs.patchJobs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    14: .standard(proto: "display_name"),
    2: .same(proto: "description"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "update_time"),
    5: .same(proto: "state"),
    13: .standard(proto: "instance_filter"),
    7: .standard(proto: "patch_config"),
    8: .same(proto: "duration"),
    9: .standard(proto: "instance_details_summary"),
    10: .standard(proto: "dry_run"),
    11: .standard(proto: "error_message"),
    12: .standard(proto: "percent_complete"),
    15: .standard(proto: "patch_deployment"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _description_p: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Google_Cloud_Osconfig_V1_PatchJob.State = .unspecified
    var _instanceFilter: Google_Cloud_Osconfig_V1_PatchInstanceFilter? = nil
    var _patchConfig: Google_Cloud_Osconfig_V1_PatchConfig? = nil
    var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _instanceDetailsSummary: Google_Cloud_Osconfig_V1_PatchJob.InstanceDetailsSummary? = nil
    var _dryRun: Bool = false
    var _errorMessage: String = String()
    var _percentComplete: Double = 0
    var _patchDeployment: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _description_p = source._description_p
      _createTime = source._createTime
      _updateTime = source._updateTime
      _state = source._state
      _instanceFilter = source._instanceFilter
      _patchConfig = source._patchConfig
      _duration = source._duration
      _instanceDetailsSummary = source._instanceDetailsSummary
      _dryRun = source._dryRun
      _errorMessage = source._errorMessage
      _percentComplete = source._percentComplete
      _patchDeployment = source._patchDeployment
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._patchConfig) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._duration) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._instanceDetailsSummary) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._dryRun) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        case 12: try { try decoder.decodeSingularDoubleField(value: &_storage._percentComplete) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._instanceFilter) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._patchDeployment) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 5)
      }
      if let v = _storage._patchConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._duration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._instanceDetailsSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._dryRun != false {
        try visitor.visitSingularBoolField(value: _storage._dryRun, fieldNumber: 10)
      }
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 11)
      }
      if _storage._percentComplete != 0 {
        try visitor.visitSingularDoubleField(value: _storage._percentComplete, fieldNumber: 12)
      }
      if let v = _storage._instanceFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 14)
      }
      if !_storage._patchDeployment.isEmpty {
        try visitor.visitSingularStringField(value: _storage._patchDeployment, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_PatchJob, rhs: Google_Cloud_Osconfig_V1_PatchJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._instanceFilter != rhs_storage._instanceFilter {return false}
        if _storage._patchConfig != rhs_storage._patchConfig {return false}
        if _storage._duration != rhs_storage._duration {return false}
        if _storage._instanceDetailsSummary != rhs_storage._instanceDetailsSummary {return false}
        if _storage._dryRun != rhs_storage._dryRun {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._percentComplete != rhs_storage._percentComplete {return false}
        if _storage._patchDeployment != rhs_storage._patchDeployment {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchJob.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "STARTED"),
    2: .same(proto: "INSTANCE_LOOKUP"),
    3: .same(proto: "PATCHING"),
    4: .same(proto: "SUCCEEDED"),
    5: .same(proto: "COMPLETED_WITH_ERRORS"),
    6: .same(proto: "CANCELED"),
    7: .same(proto: "TIMED_OUT"),
  ]
}

extension Google_Cloud_Osconfig_V1_PatchJob.InstanceDetailsSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1_PatchJob.protoMessageName + ".InstanceDetailsSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_instance_count"),
    2: .standard(proto: "inactive_instance_count"),
    3: .standard(proto: "notified_instance_count"),
    4: .standard(proto: "started_instance_count"),
    5: .standard(proto: "downloading_patches_instance_count"),
    6: .standard(proto: "applying_patches_instance_count"),
    7: .standard(proto: "rebooting_instance_count"),
    8: .standard(proto: "succeeded_instance_count"),
    9: .standard(proto: "succeeded_reboot_required_instance_count"),
    10: .standard(proto: "failed_instance_count"),
    11: .standard(proto: "acked_instance_count"),
    12: .standard(proto: "timed_out_instance_count"),
    13: .standard(proto: "pre_patch_step_instance_count"),
    14: .standard(proto: "post_patch_step_instance_count"),
    15: .standard(proto: "no_agent_detected_instance_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.pendingInstanceCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.inactiveInstanceCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.notifiedInstanceCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startedInstanceCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.downloadingPatchesInstanceCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.applyingPatchesInstanceCount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.rebootingInstanceCount) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.succeededInstanceCount) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.succeededRebootRequiredInstanceCount) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.failedInstanceCount) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.ackedInstanceCount) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.timedOutInstanceCount) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.prePatchStepInstanceCount) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.postPatchStepInstanceCount) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.noAgentDetectedInstanceCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pendingInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.pendingInstanceCount, fieldNumber: 1)
    }
    if self.inactiveInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.inactiveInstanceCount, fieldNumber: 2)
    }
    if self.notifiedInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.notifiedInstanceCount, fieldNumber: 3)
    }
    if self.startedInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.startedInstanceCount, fieldNumber: 4)
    }
    if self.downloadingPatchesInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.downloadingPatchesInstanceCount, fieldNumber: 5)
    }
    if self.applyingPatchesInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.applyingPatchesInstanceCount, fieldNumber: 6)
    }
    if self.rebootingInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.rebootingInstanceCount, fieldNumber: 7)
    }
    if self.succeededInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.succeededInstanceCount, fieldNumber: 8)
    }
    if self.succeededRebootRequiredInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.succeededRebootRequiredInstanceCount, fieldNumber: 9)
    }
    if self.failedInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.failedInstanceCount, fieldNumber: 10)
    }
    if self.ackedInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.ackedInstanceCount, fieldNumber: 11)
    }
    if self.timedOutInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.timedOutInstanceCount, fieldNumber: 12)
    }
    if self.prePatchStepInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.prePatchStepInstanceCount, fieldNumber: 13)
    }
    if self.postPatchStepInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.postPatchStepInstanceCount, fieldNumber: 14)
    }
    if self.noAgentDetectedInstanceCount != 0 {
      try visitor.visitSingularInt64Field(value: self.noAgentDetectedInstanceCount, fieldNumber: 15)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_PatchJob.InstanceDetailsSummary, rhs: Google_Cloud_Osconfig_V1_PatchJob.InstanceDetailsSummary) -> Bool {
    if lhs.pendingInstanceCount != rhs.pendingInstanceCount {return false}
    if lhs.inactiveInstanceCount != rhs.inactiveInstanceCount {return false}
    if lhs.notifiedInstanceCount != rhs.notifiedInstanceCount {return false}
    if lhs.startedInstanceCount != rhs.startedInstanceCount {return false}
    if lhs.downloadingPatchesInstanceCount != rhs.downloadingPatchesInstanceCount {return false}
    if lhs.applyingPatchesInstanceCount != rhs.applyingPatchesInstanceCount {return false}
    if lhs.rebootingInstanceCount != rhs.rebootingInstanceCount {return false}
    if lhs.succeededInstanceCount != rhs.succeededInstanceCount {return false}
    if lhs.succeededRebootRequiredInstanceCount != rhs.succeededRebootRequiredInstanceCount {return false}
    if lhs.failedInstanceCount != rhs.failedInstanceCount {return false}
    if lhs.ackedInstanceCount != rhs.ackedInstanceCount {return false}
    if lhs.timedOutInstanceCount != rhs.timedOutInstanceCount {return false}
    if lhs.prePatchStepInstanceCount != rhs.prePatchStepInstanceCount {return false}
    if lhs.postPatchStepInstanceCount != rhs.postPatchStepInstanceCount {return false}
    if lhs.noAgentDetectedInstanceCount != rhs.noAgentDetectedInstanceCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reboot_config"),
    3: .same(proto: "apt"),
    4: .same(proto: "yum"),
    5: .same(proto: "goo"),
    6: .same(proto: "zypper"),
    7: .standard(proto: "windows_update"),
    8: .standard(proto: "pre_step"),
    9: .standard(proto: "post_step"),
  ]

  fileprivate class _StorageClass {
    var _rebootConfig: Google_Cloud_Osconfig_V1_PatchConfig.RebootConfig = .unspecified
    var _apt: Google_Cloud_Osconfig_V1_AptSettings? = nil
    var _yum: Google_Cloud_Osconfig_V1_YumSettings? = nil
    var _goo: Google_Cloud_Osconfig_V1_GooSettings? = nil
    var _zypper: Google_Cloud_Osconfig_V1_ZypperSettings? = nil
    var _windowsUpdate: Google_Cloud_Osconfig_V1_WindowsUpdateSettings? = nil
    var _preStep: Google_Cloud_Osconfig_V1_ExecStep? = nil
    var _postStep: Google_Cloud_Osconfig_V1_ExecStep? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _rebootConfig = source._rebootConfig
      _apt = source._apt
      _yum = source._yum
      _goo = source._goo
      _zypper = source._zypper
      _windowsUpdate = source._windowsUpdate
      _preStep = source._preStep
      _postStep = source._postStep
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._rebootConfig) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._apt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._yum) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._goo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._zypper) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._windowsUpdate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._preStep) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._postStep) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._rebootConfig != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._rebootConfig, fieldNumber: 1)
      }
      if let v = _storage._apt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._yum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._goo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._zypper {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._windowsUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._preStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._postStep {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_PatchConfig, rhs: Google_Cloud_Osconfig_V1_PatchConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._rebootConfig != rhs_storage._rebootConfig {return false}
        if _storage._apt != rhs_storage._apt {return false}
        if _storage._yum != rhs_storage._yum {return false}
        if _storage._goo != rhs_storage._goo {return false}
        if _storage._zypper != rhs_storage._zypper {return false}
        if _storage._windowsUpdate != rhs_storage._windowsUpdate {return false}
        if _storage._preStep != rhs_storage._preStep {return false}
        if _storage._postStep != rhs_storage._postStep {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchConfig.RebootConfig: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REBOOT_CONFIG_UNSPECIFIED"),
    1: .same(proto: "DEFAULT"),
    2: .same(proto: "ALWAYS"),
    3: .same(proto: "NEVER"),
  ]
}

extension Google_Cloud_Osconfig_V1_Instance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instance"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_Instance, rhs: Google_Cloud_Osconfig_V1_Instance) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_Instance.PatchState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PATCH_STATE_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "INACTIVE"),
    3: .same(proto: "NOTIFIED"),
    4: .same(proto: "STARTED"),
    5: .same(proto: "DOWNLOADING_PATCHES"),
    6: .same(proto: "APPLYING_PATCHES"),
    7: .same(proto: "REBOOTING"),
    8: .same(proto: "SUCCEEDED"),
    9: .same(proto: "SUCCEEDED_REBOOT_REQUIRED"),
    10: .same(proto: "FAILED"),
    11: .same(proto: "ACKED"),
    12: .same(proto: "TIMED_OUT"),
    13: .same(proto: "RUNNING_PRE_PATCH_STEP"),
    14: .same(proto: "RUNNING_POST_PATCH_STEP"),
    15: .same(proto: "NO_AGENT_DETECTED"),
  ]
}

extension Google_Cloud_Osconfig_V1_CancelPatchJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelPatchJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_CancelPatchJobRequest, rhs: Google_Cloud_Osconfig_V1_CancelPatchJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_AptSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AptSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "excludes"),
    3: .standard(proto: "exclusive_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 2)
    }
    if !self.exclusivePackages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePackages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_AptSettings, rhs: Google_Cloud_Osconfig_V1_AptSettings) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePackages != rhs.exclusivePackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_AptSettings.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "DIST"),
    2: .same(proto: "UPGRADE"),
  ]
}

extension Google_Cloud_Osconfig_V1_YumSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".YumSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "security"),
    2: .same(proto: "minimal"),
    3: .same(proto: "excludes"),
    4: .standard(proto: "exclusive_packages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.security) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.minimal) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePackages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.security != false {
      try visitor.visitSingularBoolField(value: self.security, fieldNumber: 1)
    }
    if self.minimal != false {
      try visitor.visitSingularBoolField(value: self.minimal, fieldNumber: 2)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 3)
    }
    if !self.exclusivePackages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePackages, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_YumSettings, rhs: Google_Cloud_Osconfig_V1_YumSettings) -> Bool {
    if lhs.security != rhs.security {return false}
    if lhs.minimal != rhs.minimal {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePackages != rhs.exclusivePackages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_GooSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GooSettings"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_GooSettings, rhs: Google_Cloud_Osconfig_V1_GooSettings) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ZypperSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ZypperSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "with_optional"),
    2: .standard(proto: "with_update"),
    3: .same(proto: "categories"),
    4: .same(proto: "severities"),
    5: .same(proto: "excludes"),
    6: .standard(proto: "exclusive_patches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.withOptional) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.withUpdate) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.categories) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.severities) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.withOptional != false {
      try visitor.visitSingularBoolField(value: self.withOptional, fieldNumber: 1)
    }
    if self.withUpdate != false {
      try visitor.visitSingularBoolField(value: self.withUpdate, fieldNumber: 2)
    }
    if !self.categories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categories, fieldNumber: 3)
    }
    if !self.severities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.severities, fieldNumber: 4)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 5)
    }
    if !self.exclusivePatches.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePatches, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ZypperSettings, rhs: Google_Cloud_Osconfig_V1_ZypperSettings) -> Bool {
    if lhs.withOptional != rhs.withOptional {return false}
    if lhs.withUpdate != rhs.withUpdate {return false}
    if lhs.categories != rhs.categories {return false}
    if lhs.severities != rhs.severities {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePatches != rhs.exclusivePatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_WindowsUpdateSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WindowsUpdateSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "classifications"),
    2: .same(proto: "excludes"),
    3: .standard(proto: "exclusive_patches"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.classifications) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.excludes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.exclusivePatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.classifications.isEmpty {
      try visitor.visitPackedEnumField(value: self.classifications, fieldNumber: 1)
    }
    if !self.excludes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludes, fieldNumber: 2)
    }
    if !self.exclusivePatches.isEmpty {
      try visitor.visitRepeatedStringField(value: self.exclusivePatches, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_WindowsUpdateSettings, rhs: Google_Cloud_Osconfig_V1_WindowsUpdateSettings) -> Bool {
    if lhs.classifications != rhs.classifications {return false}
    if lhs.excludes != rhs.excludes {return false}
    if lhs.exclusivePatches != rhs.exclusivePatches {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_WindowsUpdateSettings.Classification: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLASSIFICATION_UNSPECIFIED"),
    1: .same(proto: "CRITICAL"),
    2: .same(proto: "SECURITY"),
    3: .same(proto: "DEFINITION"),
    4: .same(proto: "DRIVER"),
    5: .same(proto: "FEATURE_PACK"),
    6: .same(proto: "SERVICE_PACK"),
    7: .same(proto: "TOOL"),
    8: .same(proto: "UPDATE_ROLLUP"),
    9: .same(proto: "UPDATE"),
  ]
}

extension Google_Cloud_Osconfig_V1_ExecStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linux_exec_step_config"),
    2: .standard(proto: "windows_exec_step_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._linuxExecStepConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._windowsExecStepConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._linuxExecStepConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._windowsExecStepConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ExecStep, rhs: Google_Cloud_Osconfig_V1_ExecStep) -> Bool {
    if lhs._linuxExecStepConfig != rhs._linuxExecStepConfig {return false}
    if lhs._windowsExecStepConfig != rhs._windowsExecStepConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ExecStepConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecStepConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_path"),
    2: .standard(proto: "gcs_object"),
    3: .standard(proto: "allowed_success_codes"),
    4: .same(proto: "interpreter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.executable != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.executable = .localPath(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Osconfig_V1_GcsObject?
        if let current = self.executable {
          try decoder.handleConflictingOneOf()
          if case .gcsObject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.executable = .gcsObject(v)}
      }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.allowedSuccessCodes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.interpreter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.executable {
    case .localPath?: try {
      guard case .localPath(let v)? = self.executable else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .gcsObject?: try {
      guard case .gcsObject(let v)? = self.executable else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.allowedSuccessCodes.isEmpty {
      try visitor.visitPackedInt32Field(value: self.allowedSuccessCodes, fieldNumber: 3)
    }
    if self.interpreter != .unspecified {
      try visitor.visitSingularEnumField(value: self.interpreter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_ExecStepConfig, rhs: Google_Cloud_Osconfig_V1_ExecStepConfig) -> Bool {
    if lhs.executable != rhs.executable {return false}
    if lhs.allowedSuccessCodes != rhs.allowedSuccessCodes {return false}
    if lhs.interpreter != rhs.interpreter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_ExecStepConfig.Interpreter: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTERPRETER_UNSPECIFIED"),
    1: .same(proto: "SHELL"),
    2: .same(proto: "POWERSHELL"),
  ]
}

extension Google_Cloud_Osconfig_V1_GcsObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsObject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "object"),
    3: .standard(proto: "generation_number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.generationNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 2)
    }
    if self.generationNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.generationNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_GcsObject, rhs: Google_Cloud_Osconfig_V1_GcsObject) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.object != rhs.object {return false}
    if lhs.generationNumber != rhs.generationNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchInstanceFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchInstanceFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "all"),
    2: .standard(proto: "group_labels"),
    3: .same(proto: "zones"),
    4: .same(proto: "instances"),
    5: .standard(proto: "instance_name_prefixes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.all) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupLabels) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.zones) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.instances) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.instanceNamePrefixes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.all != false {
      try visitor.visitSingularBoolField(value: self.all, fieldNumber: 1)
    }
    if !self.groupLabels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupLabels, fieldNumber: 2)
    }
    if !self.zones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.zones, fieldNumber: 3)
    }
    if !self.instances.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instances, fieldNumber: 4)
    }
    if !self.instanceNamePrefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.instanceNamePrefixes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_PatchInstanceFilter, rhs: Google_Cloud_Osconfig_V1_PatchInstanceFilter) -> Bool {
    if lhs.all != rhs.all {return false}
    if lhs.groupLabels != rhs.groupLabels {return false}
    if lhs.zones != rhs.zones {return false}
    if lhs.instances != rhs.instances {return false}
    if lhs.instanceNamePrefixes != rhs.instanceNamePrefixes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Osconfig_V1_PatchInstanceFilter.GroupLabel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Osconfig_V1_PatchInstanceFilter.protoMessageName + ".GroupLabel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Osconfig_V1_PatchInstanceFilter.GroupLabel, rhs: Google_Cloud_Osconfig_V1_PatchInstanceFilter.GroupLabel) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/tasks/v2beta2/queue.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A queue is a container of related tasks. Queues are configured to manage
/// how those tasks are dispatched. Configurable properties include rate limits,
/// retry options, target types, and others.
public struct Google_Cloud_Tasks_V2beta2_Queue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Caller-specified and required in [CreateQueue][google.cloud.tasks.v2beta2.CloudTasks.CreateQueue],
  /// after which it becomes output only.
  ///
  /// The queue name.
  ///
  /// The queue name must have the following format:
  /// `projects/PROJECT_ID/locations/LOCATION_ID/queues/QUEUE_ID`
  ///
  /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
  ///    hyphens (-), colons (:), or periods (.).
  ///    For more information, see
  ///    [Identifying
  ///    projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
  /// * `LOCATION_ID` is the canonical ID for the queue's location.
  ///    The list of available locations can be obtained by calling
  ///    [ListLocations][google.cloud.location.Locations.ListLocations].
  ///    For more information, see https://cloud.google.com/about/locations/.
  /// * `QUEUE_ID` can contain letters ([A-Za-z]), numbers ([0-9]), or
  ///   hyphens (-). The maximum length is 100 characters.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Caller-specified and required in [CreateQueue][google.cloud.tasks.v2beta2.CloudTasks.CreateQueue][],
  /// after which the queue config type becomes output only, though fields within
  /// the config are mutable.
  ///
  /// The queue's target.
  ///
  /// The target applies to all tasks in the queue.
  public var targetType: OneOf_TargetType? {
    get {return _storage._targetType}
    set {_uniqueStorage()._targetType = newValue}
  }

  /// App Engine HTTP target.
  ///
  /// An App Engine queue is a queue that has an [AppEngineHttpTarget][google.cloud.tasks.v2beta2.AppEngineHttpTarget].
  public var appEngineHTTPTarget: Google_Cloud_Tasks_V2beta2_AppEngineHttpTarget {
    get {
      if case .appEngineHTTPTarget(let v)? = _storage._targetType {return v}
      return Google_Cloud_Tasks_V2beta2_AppEngineHttpTarget()
    }
    set {_uniqueStorage()._targetType = .appEngineHTTPTarget(newValue)}
  }

  /// Pull target.
  ///
  /// A pull queue is a queue that has a [PullTarget][google.cloud.tasks.v2beta2.PullTarget].
  public var pullTarget: Google_Cloud_Tasks_V2beta2_PullTarget {
    get {
      if case .pullTarget(let v)? = _storage._targetType {return v}
      return Google_Cloud_Tasks_V2beta2_PullTarget()
    }
    set {_uniqueStorage()._targetType = .pullTarget(newValue)}
  }

  /// Rate limits for task dispatches.
  ///
  /// [rate_limits][google.cloud.tasks.v2beta2.Queue.rate_limits] and
  /// [retry_config][google.cloud.tasks.v2beta2.Queue.retry_config] are related because they both
  /// control task attempts however they control how tasks are
  /// attempted in different ways:
  ///
  /// * [rate_limits][google.cloud.tasks.v2beta2.Queue.rate_limits] controls the total rate of
  ///   dispatches from a queue (i.e. all traffic dispatched from the
  ///   queue, regardless of whether the dispatch is from a first
  ///   attempt or a retry).
  /// * [retry_config][google.cloud.tasks.v2beta2.Queue.retry_config] controls what happens to
  ///   particular a task after its first attempt fails. That is,
  ///   [retry_config][google.cloud.tasks.v2beta2.Queue.retry_config] controls task retries (the
  ///   second attempt, third attempt, etc).
  public var rateLimits: Google_Cloud_Tasks_V2beta2_RateLimits {
    get {return _storage._rateLimits ?? Google_Cloud_Tasks_V2beta2_RateLimits()}
    set {_uniqueStorage()._rateLimits = newValue}
  }
  /// Returns true if `rateLimits` has been explicitly set.
  public var hasRateLimits: Bool {return _storage._rateLimits != nil}
  /// Clears the value of `rateLimits`. Subsequent reads from it will return its default value.
  public mutating func clearRateLimits() {_uniqueStorage()._rateLimits = nil}

  /// Settings that determine the retry behavior.
  ///
  /// * For tasks created using Cloud Tasks: the queue-level retry settings
  ///   apply to all tasks in the queue that were created using Cloud Tasks.
  ///   Retry settings cannot be set on individual tasks.
  /// * For tasks created using the App Engine SDK: the queue-level retry
  ///   settings apply to all tasks in the queue which do not have retry settings
  ///   explicitly set on the task and were created by the App Engine SDK. See
  ///   [App Engine
  ///   documentation](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/retrying-tasks).
  public var retryConfig: Google_Cloud_Tasks_V2beta2_RetryConfig {
    get {return _storage._retryConfig ?? Google_Cloud_Tasks_V2beta2_RetryConfig()}
    set {_uniqueStorage()._retryConfig = newValue}
  }
  /// Returns true if `retryConfig` has been explicitly set.
  public var hasRetryConfig: Bool {return _storage._retryConfig != nil}
  /// Clears the value of `retryConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetryConfig() {_uniqueStorage()._retryConfig = nil}

  /// Output only. The state of the queue.
  ///
  /// `state` can only be changed by called
  /// [PauseQueue][google.cloud.tasks.v2beta2.CloudTasks.PauseQueue],
  /// [ResumeQueue][google.cloud.tasks.v2beta2.CloudTasks.ResumeQueue], or uploading
  /// [queue.yaml/xml](https://cloud.google.com/appengine/docs/python/config/queueref).
  /// [UpdateQueue][google.cloud.tasks.v2beta2.CloudTasks.UpdateQueue] cannot be used to change `state`.
  public var state: Google_Cloud_Tasks_V2beta2_Queue.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. The last time this queue was purged.
  ///
  /// All tasks that were [created][google.cloud.tasks.v2beta2.Task.create_time] before this time
  /// were purged.
  ///
  /// A queue can be purged using [PurgeQueue][google.cloud.tasks.v2beta2.CloudTasks.PurgeQueue], the
  /// [App Engine Task Queue SDK, or the Cloud
  /// Console](https://cloud.google.com/appengine/docs/standard/python/taskqueue/push/deleting-tasks-and-queues#purging_all_tasks_from_a_queue).
  ///
  /// Purge time will be truncated to the nearest microsecond. Purge
  /// time will be unset if the queue has never been purged.
  public var purgeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._purgeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._purgeTime = newValue}
  }
  /// Returns true if `purgeTime` has been explicitly set.
  public var hasPurgeTime: Bool {return _storage._purgeTime != nil}
  /// Clears the value of `purgeTime`. Subsequent reads from it will return its default value.
  public mutating func clearPurgeTime() {_uniqueStorage()._purgeTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Caller-specified and required in [CreateQueue][google.cloud.tasks.v2beta2.CloudTasks.CreateQueue][],
  /// after which the queue config type becomes output only, though fields within
  /// the config are mutable.
  ///
  /// The queue's target.
  ///
  /// The target applies to all tasks in the queue.
  public enum OneOf_TargetType: Equatable {
    /// App Engine HTTP target.
    ///
    /// An App Engine queue is a queue that has an [AppEngineHttpTarget][google.cloud.tasks.v2beta2.AppEngineHttpTarget].
    case appEngineHTTPTarget(Google_Cloud_Tasks_V2beta2_AppEngineHttpTarget)
    /// Pull target.
    ///
    /// A pull queue is a queue that has a [PullTarget][google.cloud.tasks.v2beta2.PullTarget].
    case pullTarget(Google_Cloud_Tasks_V2beta2_PullTarget)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Tasks_V2beta2_Queue.OneOf_TargetType, rhs: Google_Cloud_Tasks_V2beta2_Queue.OneOf_TargetType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.appEngineHTTPTarget, .appEngineHTTPTarget): return {
        guard case .appEngineHTTPTarget(let l) = lhs, case .appEngineHTTPTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pullTarget, .pullTarget): return {
        guard case .pullTarget(let l) = lhs, case .pullTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// State of the queue.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified state.
    case unspecified // = 0

    /// The queue is running. Tasks can be dispatched.
    ///
    /// If the queue was created using Cloud Tasks and the queue has
    /// had no activity (method calls or task dispatches) for 30 days,
    /// the queue may take a few minutes to re-activate. Some method
    /// calls may return [NOT_FOUND][google.rpc.Code.NOT_FOUND] and
    /// tasks may not be dispatched for a few minutes until the queue
    /// has been re-activated.
    case running // = 1

    /// Tasks are paused by the user. If the queue is paused then Cloud
    /// Tasks will stop delivering tasks from it, but more tasks can
    /// still be added to it by the user. When a pull queue is paused,
    /// all [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] calls will return a
    /// [FAILED_PRECONDITION][google.rpc.Code.FAILED_PRECONDITION].
    case paused // = 2

    /// The queue is disabled.
    ///
    /// A queue becomes `DISABLED` when
    /// [queue.yaml](https://cloud.google.com/appengine/docs/python/config/queueref)
    /// or
    /// [queue.xml](https://cloud.google.com/appengine/docs/standard/java/config/queueref)
    /// is uploaded which does not contain the queue. You cannot directly disable
    /// a queue.
    ///
    /// When a queue is disabled, tasks can still be added to a queue
    /// but the tasks are not dispatched and
    /// [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] calls return a
    /// `FAILED_PRECONDITION` error.
    ///
    /// To permanently delete this queue and all of its tasks, call
    /// [DeleteQueue][google.cloud.tasks.v2beta2.CloudTasks.DeleteQueue].
    case disabled // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .paused
      case 3: self = .disabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .paused: return 2
      case .disabled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Tasks_V2beta2_Queue.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Tasks_V2beta2_Queue.State] = [
    .unspecified,
    .running,
    .paused,
    .disabled,
  ]
}

#endif  // swift(>=4.2)

/// Rate limits.
///
/// This message determines the maximum rate that tasks can be dispatched by a
/// queue, regardless of whether the dispatch is a first task attempt or a retry.
///
/// Note: The debugging command, [RunTask][google.cloud.tasks.v2beta2.CloudTasks.RunTask], will run a task
/// even if the queue has reached its [RateLimits][google.cloud.tasks.v2beta2.RateLimits].
public struct Google_Cloud_Tasks_V2beta2_RateLimits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum rate at which tasks are dispatched from this queue.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  /// * For [App Engine queues][google.cloud.tasks.v2beta2.AppEngineHttpTarget], the maximum allowed value
  ///   is 500.
  /// * This field is output only   for [pull queues][google.cloud.tasks.v2beta2.PullTarget]. In addition to the
  ///   `max_tasks_dispatched_per_second` limit, a maximum of 10 QPS of
  ///   [LeaseTasks][google.cloud.tasks.v2beta2.CloudTasks.LeaseTasks] requests are allowed per pull queue.
  ///
  ///
  /// This field has the same meaning as
  /// [rate in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#rate).
  public var maxTasksDispatchedPerSecond: Double = 0

  /// Output only. The max burst size.
  ///
  /// Max burst size limits how fast tasks in queue are processed when
  /// many tasks are in the queue and the rate is high. This field
  /// allows the queue to have a high rate so processing starts shortly
  /// after a task is enqueued, but still limits resource usage when
  /// many tasks are enqueued in a short period of time.
  ///
  /// The [token bucket](https://wikipedia.org/wiki/Token_Bucket)
  /// algorithm is used to control the rate of task dispatches. Each
  /// queue has a token bucket that holds tokens, up to the maximum
  /// specified by `max_burst_size`. Each time a task is dispatched, a
  /// token is removed from the bucket. Tasks will be dispatched until
  /// the queue's bucket runs out of tokens. The bucket will be
  /// continuously refilled with new tokens based on
  /// [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second].
  ///
  /// Cloud Tasks will pick the value of `max_burst_size` based on the
  /// value of
  /// [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second].
  ///
  /// For App Engine queues that were created or updated using
  /// `queue.yaml/xml`, `max_burst_size` is equal to
  /// [bucket_size](https://cloud.google.com/appengine/docs/standard/python/config/queueref#bucket_size).
  /// Since `max_burst_size` is output only, if
  /// [UpdateQueue][google.cloud.tasks.v2beta2.CloudTasks.UpdateQueue] is called on a queue
  /// created by `queue.yaml/xml`, `max_burst_size` will be reset based
  /// on the value of
  /// [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second],
  /// regardless of whether
  /// [max_tasks_dispatched_per_second][google.cloud.tasks.v2beta2.RateLimits.max_tasks_dispatched_per_second]
  /// is updated.
  public var maxBurstSize: Int32 = 0

  /// The maximum number of concurrent tasks that Cloud Tasks allows
  /// to be dispatched for this queue. After this threshold has been
  /// reached, Cloud Tasks stops dispatching tasks until the number of
  /// concurrent requests decreases.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  ///
  /// The maximum allowed value is 5,000.
  ///
  /// This field is output only for
  /// [pull queues][google.cloud.tasks.v2beta2.PullTarget] and always -1, which indicates no limit. No other
  /// queue types can have `max_concurrent_tasks` set to -1.
  ///
  ///
  /// This field has the same meaning as
  /// [max_concurrent_requests in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#max_concurrent_requests).
  public var maxConcurrentTasks: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Retry config.
///
/// These settings determine how a failed task attempt is retried.
public struct Google_Cloud_Tasks_V2beta2_RetryConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of attempts per task.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  ///
  ///
  /// This field has the same meaning as
  /// [task_retry_limit in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  public var numAttempts: Google_Cloud_Tasks_V2beta2_RetryConfig.OneOf_NumAttempts? = nil

  /// The maximum number of attempts for a task.
  ///
  /// Cloud Tasks will attempt the task `max_attempts` times (that
  /// is, if the first attempt fails, then there will be
  /// `max_attempts - 1` retries).  Must be > 0.
  public var maxAttempts: Int32 {
    get {
      if case .maxAttempts(let v)? = numAttempts {return v}
      return 0
    }
    set {numAttempts = .maxAttempts(newValue)}
  }

  /// If true, then the number of attempts is unlimited.
  public var unlimitedAttempts: Bool {
    get {
      if case .unlimitedAttempts(let v)? = numAttempts {return v}
      return false
    }
    set {numAttempts = .unlimitedAttempts(newValue)}
  }

  /// If positive, `max_retry_duration` specifies the time limit for
  /// retrying a failed task, measured from when the task was first
  /// attempted. Once `max_retry_duration` time has passed *and* the
  /// task has been attempted [max_attempts][google.cloud.tasks.v2beta2.RetryConfig.max_attempts]
  /// times, no further attempts will be made and the task will be
  /// deleted.
  ///
  /// If zero, then the task age is unlimited.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  /// This field is output only for [pull queues][google.cloud.tasks.v2beta2.PullTarget].
  ///
  ///
  /// `max_retry_duration` will be truncated to the nearest second.
  ///
  /// This field has the same meaning as
  /// [task_age_limit in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  public var maxRetryDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxRetryDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxRetryDuration = newValue}
  }
  /// Returns true if `maxRetryDuration` has been explicitly set.
  public var hasMaxRetryDuration: Bool {return self._maxRetryDuration != nil}
  /// Clears the value of `maxRetryDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxRetryDuration() {self._maxRetryDuration = nil}

  /// A task will be [scheduled][google.cloud.tasks.v2beta2.Task.schedule_time] for retry between
  /// [min_backoff][google.cloud.tasks.v2beta2.RetryConfig.min_backoff] and
  /// [max_backoff][google.cloud.tasks.v2beta2.RetryConfig.max_backoff] duration after it fails,
  /// if the queue's [RetryConfig][google.cloud.tasks.v2beta2.RetryConfig] specifies that the task should be
  /// retried.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  /// This field is output only for [pull queues][google.cloud.tasks.v2beta2.PullTarget].
  ///
  ///
  /// `min_backoff` will be truncated to the nearest second.
  ///
  /// This field has the same meaning as
  /// [min_backoff_seconds in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  public var minBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minBackoff = newValue}
  }
  /// Returns true if `minBackoff` has been explicitly set.
  public var hasMinBackoff: Bool {return self._minBackoff != nil}
  /// Clears the value of `minBackoff`. Subsequent reads from it will return its default value.
  public mutating func clearMinBackoff() {self._minBackoff = nil}

  /// A task will be [scheduled][google.cloud.tasks.v2beta2.Task.schedule_time] for retry between
  /// [min_backoff][google.cloud.tasks.v2beta2.RetryConfig.min_backoff] and
  /// [max_backoff][google.cloud.tasks.v2beta2.RetryConfig.max_backoff] duration after it fails,
  /// if the queue's [RetryConfig][google.cloud.tasks.v2beta2.RetryConfig] specifies that the task should be
  /// retried.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  /// This field is output only for [pull queues][google.cloud.tasks.v2beta2.PullTarget].
  ///
  ///
  /// `max_backoff` will be truncated to the nearest second.
  ///
  /// This field has the same meaning as
  /// [max_backoff_seconds in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  public var maxBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxBackoff = newValue}
  }
  /// Returns true if `maxBackoff` has been explicitly set.
  public var hasMaxBackoff: Bool {return self._maxBackoff != nil}
  /// Clears the value of `maxBackoff`. Subsequent reads from it will return its default value.
  public mutating func clearMaxBackoff() {self._maxBackoff = nil}

  /// The time between retries will double `max_doublings` times.
  ///
  /// A task's retry interval starts at
  /// [min_backoff][google.cloud.tasks.v2beta2.RetryConfig.min_backoff], then doubles
  /// `max_doublings` times, then increases linearly, and finally
  /// retries retries at intervals of
  /// [max_backoff][google.cloud.tasks.v2beta2.RetryConfig.max_backoff] up to
  /// [max_attempts][google.cloud.tasks.v2beta2.RetryConfig.max_attempts] times.
  ///
  /// For example, if [min_backoff][google.cloud.tasks.v2beta2.RetryConfig.min_backoff] is 10s,
  /// [max_backoff][google.cloud.tasks.v2beta2.RetryConfig.max_backoff] is 300s, and
  /// `max_doublings` is 3, then the a task will first be retried in
  /// 10s. The retry interval will double three times, and then
  /// increase linearly by 2^3 * 10s.  Finally, the task will retry at
  /// intervals of [max_backoff][google.cloud.tasks.v2beta2.RetryConfig.max_backoff] until the
  /// task has been attempted [max_attempts][google.cloud.tasks.v2beta2.RetryConfig.max_attempts]
  /// times. Thus, the requests will retry at 10s, 20s, 40s, 80s, 160s,
  /// 240s, 300s, 300s, ....
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  /// This field is output only for [pull queues][google.cloud.tasks.v2beta2.PullTarget].
  ///
  ///
  /// This field has the same meaning as
  /// [max_doublings in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  public var maxDoublings: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Number of attempts per task.
  ///
  /// If unspecified when the queue is created, Cloud Tasks will pick the
  /// default.
  ///
  ///
  ///
  /// This field has the same meaning as
  /// [task_retry_limit in
  /// queue.yaml/xml](https://cloud.google.com/appengine/docs/standard/python/config/queueref#retry_parameters).
  public enum OneOf_NumAttempts: Equatable {
    /// The maximum number of attempts for a task.
    ///
    /// Cloud Tasks will attempt the task `max_attempts` times (that
    /// is, if the first attempt fails, then there will be
    /// `max_attempts - 1` retries).  Must be > 0.
    case maxAttempts(Int32)
    /// If true, then the number of attempts is unlimited.
    case unlimitedAttempts(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Tasks_V2beta2_RetryConfig.OneOf_NumAttempts, rhs: Google_Cloud_Tasks_V2beta2_RetryConfig.OneOf_NumAttempts) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.maxAttempts, .maxAttempts): return {
        guard case .maxAttempts(let l) = lhs, case .maxAttempts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.unlimitedAttempts, .unlimitedAttempts): return {
        guard case .unlimitedAttempts(let l) = lhs, case .unlimitedAttempts(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _maxRetryDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _minBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.tasks.v2beta2"

extension Google_Cloud_Tasks_V2beta2_Queue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Queue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "app_engine_http_target"),
    4: .standard(proto: "pull_target"),
    5: .standard(proto: "rate_limits"),
    6: .standard(proto: "retry_config"),
    7: .same(proto: "state"),
    8: .standard(proto: "purge_time"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _targetType: Google_Cloud_Tasks_V2beta2_Queue.OneOf_TargetType?
    var _rateLimits: Google_Cloud_Tasks_V2beta2_RateLimits? = nil
    var _retryConfig: Google_Cloud_Tasks_V2beta2_RetryConfig? = nil
    var _state: Google_Cloud_Tasks_V2beta2_Queue.State = .unspecified
    var _purgeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _targetType = source._targetType
      _rateLimits = source._rateLimits
      _retryConfig = source._retryConfig
      _state = source._state
      _purgeTime = source._purgeTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try {
          var v: Google_Cloud_Tasks_V2beta2_AppEngineHttpTarget?
          if let current = _storage._targetType {
            try decoder.handleConflictingOneOf()
            if case .appEngineHTTPTarget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._targetType = .appEngineHTTPTarget(v)}
        }()
        case 4: try {
          var v: Google_Cloud_Tasks_V2beta2_PullTarget?
          if let current = _storage._targetType {
            try decoder.handleConflictingOneOf()
            if case .pullTarget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._targetType = .pullTarget(v)}
        }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._rateLimits) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._retryConfig) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._purgeTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._targetType {
      case .appEngineHTTPTarget?: try {
        guard case .appEngineHTTPTarget(let v)? = _storage._targetType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .pullTarget?: try {
        guard case .pullTarget(let v)? = _storage._targetType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
      if let v = _storage._rateLimits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._retryConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 7)
      }
      if let v = _storage._purgeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Tasks_V2beta2_Queue, rhs: Google_Cloud_Tasks_V2beta2_Queue) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._targetType != rhs_storage._targetType {return false}
        if _storage._rateLimits != rhs_storage._rateLimits {return false}
        if _storage._retryConfig != rhs_storage._retryConfig {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._purgeTime != rhs_storage._purgeTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Tasks_V2beta2_Queue.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "RUNNING"),
    2: .same(proto: "PAUSED"),
    3: .same(proto: "DISABLED"),
  ]
}

extension Google_Cloud_Tasks_V2beta2_RateLimits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RateLimits"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_tasks_dispatched_per_second"),
    2: .standard(proto: "max_burst_size"),
    3: .standard(proto: "max_concurrent_tasks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.maxTasksDispatchedPerSecond) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxBurstSize) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxConcurrentTasks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxTasksDispatchedPerSecond != 0 {
      try visitor.visitSingularDoubleField(value: self.maxTasksDispatchedPerSecond, fieldNumber: 1)
    }
    if self.maxBurstSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maxBurstSize, fieldNumber: 2)
    }
    if self.maxConcurrentTasks != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConcurrentTasks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Tasks_V2beta2_RateLimits, rhs: Google_Cloud_Tasks_V2beta2_RateLimits) -> Bool {
    if lhs.maxTasksDispatchedPerSecond != rhs.maxTasksDispatchedPerSecond {return false}
    if lhs.maxBurstSize != rhs.maxBurstSize {return false}
    if lhs.maxConcurrentTasks != rhs.maxConcurrentTasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Tasks_V2beta2_RetryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_attempts"),
    2: .standard(proto: "unlimited_attempts"),
    3: .standard(proto: "max_retry_duration"),
    4: .standard(proto: "min_backoff"),
    5: .standard(proto: "max_backoff"),
    6: .standard(proto: "max_doublings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.numAttempts != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.numAttempts = .maxAttempts(v)}
      }()
      case 2: try {
        if self.numAttempts != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.numAttempts = .unlimitedAttempts(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maxRetryDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._minBackoff) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._maxBackoff) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.maxDoublings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.numAttempts {
    case .maxAttempts?: try {
      guard case .maxAttempts(let v)? = self.numAttempts else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .unlimitedAttempts?: try {
      guard case .unlimitedAttempts(let v)? = self.numAttempts else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._maxRetryDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._minBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._maxBackoff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.maxDoublings != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDoublings, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Tasks_V2beta2_RetryConfig, rhs: Google_Cloud_Tasks_V2beta2_RetryConfig) -> Bool {
    if lhs.numAttempts != rhs.numAttempts {return false}
    if lhs._maxRetryDuration != rhs._maxRetryDuration {return false}
    if lhs._minBackoff != rhs._minBackoff {return false}
    if lhs._maxBackoff != rhs._maxBackoff {return false}
    if lhs.maxDoublings != rhs.maxDoublings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

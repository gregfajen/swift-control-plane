// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/dialogflow/cx/v3beta1/response_message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents a response message that can be returned by a conversational agent.
///
/// Response messages are also used for output audio synthesis. The approach is
/// as follows:
///
/// * If at least one OutputAudioText response is present, then all
///   OutputAudioText responses are linearly concatenated, and the result is used
///   for output audio synthesis.
/// * If the OutputAudioText responses are a mixture of text and SSML, then the
///   concatenated result is treated as SSML; otherwise, the result is treated as
///   either text or SSML as appropriate. The agent designer should ideally use
///   either text or SSML consistently throughout the bot design.
/// * Otherwise, all Text responses are linearly concatenated, and the result is
///   used for output audio synthesis.
///
/// This approach allows for more sophisticated user experience scenarios, where
/// the text displayed to the user may differ from what is heard.
public struct Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The rich response message.
  public var message: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OneOf_Message? = nil

  /// Returns a text response.
  public var text: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text {
    get {
      if case .text(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text()
    }
    set {message = .text(newValue)}
  }

  /// Returns a response containing a custom, platform-specific payload.
  public var payload: SwiftProtobuf.Google_Protobuf_Struct {
    get {
      if case .payload(let v)? = message {return v}
      return SwiftProtobuf.Google_Protobuf_Struct()
    }
    set {message = .payload(newValue)}
  }

  /// Indicates that the conversation succeeded.
  public var conversationSuccess: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess {
    get {
      if case .conversationSuccess(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess()
    }
    set {message = .conversationSuccess(newValue)}
  }

  /// A text or ssml response that is preferentially used for TTS output audio
  /// synthesis, as described in the comment on the ResponseMessage message.
  public var outputAudioText: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText {
    get {
      if case .outputAudioText(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText()
    }
    set {message = .outputAudioText(newValue)}
  }

  /// Hands off conversation to a human agent.
  public var liveAgentHandoff: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff {
    get {
      if case .liveAgentHandoff(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff()
    }
    set {message = .liveAgentHandoff(newValue)}
  }

  /// Output only. A signal that indicates the interaction with the Dialogflow agent has
  /// ended.
  /// This message is generated by Dialogflow only when the conversation
  /// reaches `END_SESSION` or `END_PAGE` page. It is not supposed to be
  /// defined by the user.
  /// It's guaranteed that there is at most one such message in each response.
  public var endInteraction: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction {
    get {
      if case .endInteraction(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction()
    }
    set {message = .endInteraction(newValue)}
  }

  /// Signal that the client should play an audio clip hosted at a
  /// client-specific URI. Dialogflow uses this to construct
  /// [mixed_audio][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.mixed_audio]. However, Dialogflow itself
  /// does not try to read or process the URI in any way.
  public var playAudio: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio {
    get {
      if case .playAudio(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio()
    }
    set {message = .playAudio(newValue)}
  }

  /// Output only. An audio response message composed of both the synthesized Dialogflow
  /// agent responses and responses defined via
  /// [play_audio][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.play_audio].
  /// This message is generated by Dialogflow only and not supposed to be
  /// defined by the user.
  public var mixedAudio: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio {
    get {
      if case .mixedAudio(let v)? = message {return v}
      return Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio()
    }
    set {message = .mixedAudio(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The rich response message.
  public enum OneOf_Message: Equatable {
    /// Returns a text response.
    case text(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text)
    /// Returns a response containing a custom, platform-specific payload.
    case payload(SwiftProtobuf.Google_Protobuf_Struct)
    /// Indicates that the conversation succeeded.
    case conversationSuccess(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess)
    /// A text or ssml response that is preferentially used for TTS output audio
    /// synthesis, as described in the comment on the ResponseMessage message.
    case outputAudioText(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText)
    /// Hands off conversation to a human agent.
    case liveAgentHandoff(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff)
    /// Output only. A signal that indicates the interaction with the Dialogflow agent has
    /// ended.
    /// This message is generated by Dialogflow only when the conversation
    /// reaches `END_SESSION` or `END_PAGE` page. It is not supposed to be
    /// defined by the user.
    /// It's guaranteed that there is at most one such message in each response.
    case endInteraction(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction)
    /// Signal that the client should play an audio clip hosted at a
    /// client-specific URI. Dialogflow uses this to construct
    /// [mixed_audio][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.mixed_audio]. However, Dialogflow itself
    /// does not try to read or process the URI in any way.
    case playAudio(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio)
    /// Output only. An audio response message composed of both the synthesized Dialogflow
    /// agent responses and responses defined via
    /// [play_audio][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.play_audio].
    /// This message is generated by Dialogflow only and not supposed to be
    /// defined by the user.
    case mixedAudio(Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OneOf_Message, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OneOf_Message) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.payload, .payload): return {
        guard case .payload(let l) = lhs, case .payload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.conversationSuccess, .conversationSuccess): return {
        guard case .conversationSuccess(let l) = lhs, case .conversationSuccess(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.outputAudioText, .outputAudioText): return {
        guard case .outputAudioText(let l) = lhs, case .outputAudioText(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.liveAgentHandoff, .liveAgentHandoff): return {
        guard case .liveAgentHandoff(let l) = lhs, case .liveAgentHandoff(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endInteraction, .endInteraction): return {
        guard case .endInteraction(let l) = lhs, case .endInteraction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.playAudio, .playAudio): return {
        guard case .playAudio(let l) = lhs, case .playAudio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mixedAudio, .mixedAudio): return {
        guard case .mixedAudio(let l) = lhs, case .mixedAudio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The text response message.
  public struct Text {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. A collection of text responses.
    public var text: [String] = []

    /// Output only. Whether the playback of this message can be interrupted by the end
    /// user's speech and the client can then starts the next Dialogflow
    /// request.
    public var allowPlaybackInterruption: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Indicates that the conversation should be handed off to a live agent.
  ///
  /// Dialogflow only uses this to determine which conversations were handed off
  /// to a human agent for measurement purposes. What else to do with this signal
  /// is up to you and your handoff procedures.
  ///
  /// You may set this, for example:
  /// * In the [entry_fulfillment][google.cloud.dialogflow.cx.v3beta1.Page.entry_fulfillment] of a [Page][google.cloud.dialogflow.cx.v3beta1.Page] if
  ///   entering the page indicates something went extremely wrong in the
  ///   conversation.
  /// * In a webhook response when you determine that the customer issue can only
  ///   be handled by a human.
  public struct LiveAgentHandoff {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Custom metadata for your handoff procedure. Dialogflow doesn't impose
    /// any structure on this.
    public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  /// Indicates that the conversation succeeded, i.e., the bot handled the issue
  /// that the customer talked to it about.
  ///
  /// Dialogflow only uses this to determine which conversations should be
  /// counted as successful and doesn't process the metadata in this message in
  /// any way. Note that Dialogflow also considers conversations that get to the
  /// conversation end page as successful even if they don't return
  /// [ConversationSuccess][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.ConversationSuccess].
  ///
  /// You may set this, for example:
  /// * In the [entry_fulfillment][google.cloud.dialogflow.cx.v3beta1.Page.entry_fulfillment] of a [Page][google.cloud.dialogflow.cx.v3beta1.Page] if
  ///   entering the page indicates that the conversation succeeded.
  /// * In a webhook response when you determine that you handled the customer
  ///   issue.
  public struct ConversationSuccess {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Custom metadata. Dialogflow doesn't impose any structure on this.
    public var metadata: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _metadata ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {return self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _metadata: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  /// A text or ssml response that is preferentially used for TTS output audio
  /// synthesis, as described in the comment on the ResponseMessage message.
  public struct OutputAudioText {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The source, which is either plain text or SSML.
    public var source: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText.OneOf_Source? = nil

    /// The raw text to be synthesized.
    public var text: String {
      get {
        if case .text(let v)? = source {return v}
        return String()
      }
      set {source = .text(newValue)}
    }

    /// The SSML text to be synthesized. For more information, see
    /// [SSML](/speech/text-to-speech/docs/ssml).
    public var ssml: String {
      get {
        if case .ssml(let v)? = source {return v}
        return String()
      }
      set {source = .ssml(newValue)}
    }

    /// Output only. Whether the playback of this message can be interrupted by the end
    /// user's speech and the client can then starts the next Dialogflow
    /// request.
    public var allowPlaybackInterruption: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The source, which is either plain text or SSML.
    public enum OneOf_Source: Equatable {
      /// The raw text to be synthesized.
      case text(String)
      /// The SSML text to be synthesized. For more information, see
      /// [SSML](/speech/text-to-speech/docs/ssml).
      case ssml(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText.OneOf_Source, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText.OneOf_Source) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.text, .text): return {
          guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.ssml, .ssml): return {
          guard case .ssml(let l) = lhs, case .ssml(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// Represents an audio message that is composed of both segments
  /// synthesized from the Dialogflow agent prompts and ones hosted externally
  /// at the specified URIs.
  /// The external URIs are specified via
  /// [play_audio][google.cloud.dialogflow.cx.v3beta1.ResponseMessage.play_audio].
  /// This message is generated by Dialogflow only and not supposed to be
  /// defined by the user.
  public struct MixedAudio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Segments this audio response is composed of.
    public var segments: [Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Represents one segment of audio.
    public struct Segment {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Content of the segment.
      public var content: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment.OneOf_Content? = nil

      /// Raw audio synthesized from the Dialogflow agent's response using
      /// the output config specified in the request.
      public var audio: Data {
        get {
          if case .audio(let v)? = content {return v}
          return Data()
        }
        set {content = .audio(newValue)}
      }

      /// Client-specific URI that points to an audio clip accessible to the
      /// client. Dialogflow does not impose any validation on it.
      public var uri: String {
        get {
          if case .uri(let v)? = content {return v}
          return String()
        }
        set {content = .uri(newValue)}
      }

      /// Output only. Whether the playback of this segment can be interrupted by the end
      /// user's speech and the client should then start the next Dialogflow
      /// request.
      public var allowPlaybackInterruption: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Content of the segment.
      public enum OneOf_Content: Equatable {
        /// Raw audio synthesized from the Dialogflow agent's response using
        /// the output config specified in the request.
        case audio(Data)
        /// Client-specific URI that points to an audio clip accessible to the
        /// client. Dialogflow does not impose any validation on it.
        case uri(String)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment.OneOf_Content, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment.OneOf_Content) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.audio, .audio): return {
            guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.uri, .uri): return {
            guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    public init() {}
  }

  /// Indicates that interaction with the Dialogflow agent has ended.
  /// This message is generated by Dialogflow only and not supposed to be
  /// defined by the user.
  public struct EndInteraction {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Specifies an audio clip to be played by the client as part of the response.
  public struct PlayAudio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. URI of the audio clip. Dialogflow does not impose any validation on this
    /// value. It is specific to the client that reads it.
    public var audioUri: String = String()

    /// Output only. Whether the playback of this message can be interrupted by the end
    /// user's speech and the client can then starts the next Dialogflow
    /// request.
    public var allowPlaybackInterruption: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.dialogflow.cx.v3beta1"

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResponseMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "payload"),
    9: .standard(proto: "conversation_success"),
    8: .standard(proto: "output_audio_text"),
    10: .standard(proto: "live_agent_handoff"),
    11: .standard(proto: "end_interaction"),
    12: .standard(proto: "play_audio"),
    13: .standard(proto: "mixed_audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .text(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Struct?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .payload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .payload(v)}
      }()
      case 8: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .outputAudioText(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .outputAudioText(v)}
      }()
      case 9: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .conversationSuccess(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .conversationSuccess(v)}
      }()
      case 10: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .liveAgentHandoff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .liveAgentHandoff(v)}
      }()
      case 11: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .endInteraction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .endInteraction(v)}
      }()
      case 12: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .playAudio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .playAudio(v)}
      }()
      case 13: try {
        var v: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio?
        if let current = self.message {
          try decoder.handleConflictingOneOf()
          if case .mixedAudio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.message = .mixedAudio(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.message {
    case .text?: try {
      guard case .text(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .payload?: try {
      guard case .payload(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .outputAudioText?: try {
      guard case .outputAudioText(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .conversationSuccess?: try {
      guard case .conversationSuccess(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .liveAgentHandoff?: try {
      guard case .liveAgentHandoff(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .endInteraction?: try {
      guard case .endInteraction(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .playAudio?: try {
      guard case .playAudio(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .mixedAudio?: try {
      guard case .mixedAudio(let v)? = self.message else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".Text"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "allow_playback_interruption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowPlaybackInterruption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitRepeatedStringField(value: self.text, fieldNumber: 1)
    }
    if self.allowPlaybackInterruption != false {
      try visitor.visitSingularBoolField(value: self.allowPlaybackInterruption, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.Text) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.allowPlaybackInterruption != rhs.allowPlaybackInterruption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".LiveAgentHandoff"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.LiveAgentHandoff) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".ConversationSuccess"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.ConversationSuccess) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".OutputAudioText"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "ssml"),
    3: .standard(proto: "allow_playback_interruption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .text(v)}
      }()
      case 2: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .ssml(v)}
      }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowPlaybackInterruption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .text?: try {
      guard case .text(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .ssml?: try {
      guard case .ssml(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.allowPlaybackInterruption != false {
      try visitor.visitSingularBoolField(value: self.allowPlaybackInterruption, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.OutputAudioText) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.allowPlaybackInterruption != rhs.allowPlaybackInterruption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".MixedAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "segments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio) -> Bool {
    if lhs.segments != rhs.segments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.protoMessageName + ".Segment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "audio"),
    2: .same(proto: "uri"),
    3: .standard(proto: "allow_playback_interruption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.content != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.content = .audio(v)}
      }()
      case 2: try {
        if self.content != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.content = .uri(v)}
      }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allowPlaybackInterruption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .audio?: try {
      guard case .audio(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .uri?: try {
      guard case .uri(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.allowPlaybackInterruption != false {
      try visitor.visitSingularBoolField(value: self.allowPlaybackInterruption, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.MixedAudio.Segment) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.allowPlaybackInterruption != rhs.allowPlaybackInterruption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".EndInteraction"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.EndInteraction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.protoMessageName + ".PlayAudio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_uri"),
    2: .standard(proto: "allow_playback_interruption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.audioUri) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowPlaybackInterruption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.audioUri.isEmpty {
      try visitor.visitSingularStringField(value: self.audioUri, fieldNumber: 1)
    }
    if self.allowPlaybackInterruption != false {
      try visitor.visitSingularBoolField(value: self.allowPlaybackInterruption, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ResponseMessage.PlayAudio) -> Bool {
    if lhs.audioUri != rhs.audioUri {return false}
    if lhs.allowPlaybackInterruption != rhs.allowPlaybackInterruption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/dialogflow/cx/v3beta1/flow.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Settings related to NLU.
public struct Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates the type of NLU model.
  public var modelType: Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelType = .unspecified

  /// To filter out false positive results and still get variety in matched
  /// natural language inputs for your agent, you can tune the machine learning
  /// classification threshold. If the returned score value is less than the
  /// threshold value, then a no-match event will be triggered. The score values
  /// range from 0.0 (completely uncertain) to 1.0 (completely certain). If set
  /// to 0.0, the default of 0.3 is used.
  public var classificationThreshold: Float = 0

  /// Indicates NLU model training mode.
  public var modelTrainingMode: Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelTrainingMode = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// NLU model type.
  public enum ModelType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. `MODEL_TYPE_STANDARD` will be used.
    case unspecified // = 0

    /// Use standard NLU model.
    case standard // = 1

    /// Use advanced NLU model.
    case advanced // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .standard
      case 3: self = .advanced
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .standard: return 1
      case .advanced: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// NLU model training mode.
  public enum ModelTrainingMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. `MODEL_TRAINING_MODE_AUTOMATIC` will be used.
    case unspecified // = 0

    /// NLU model training is automatically triggered when a flow gets modified.
    /// User can also manually trigger model training in this mode.
    case automatic // = 1

    /// User needs to manually trigger NLU model training. Best for large flows
    /// whose models take long time to train.
    case manual // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .automatic
      case 2: self = .manual
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .automatic: return 1
      case .manual: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelType] = [
    .unspecified,
    .standard,
    .advanced,
  ]
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelTrainingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelTrainingMode] = [
    .unspecified,
    .automatic,
    .manual,
  ]
}

#endif  // swift(>=4.2)

/// Flows represents the conversation flows when you build your chatbot agent.
///
/// A flow consists of many pages connected by the transition routes.
/// Conversations always start with the built-in Start Flow (with an all-0 ID).
/// Transition routes can direct the conversation session from the current flow
/// (parent flow) to another flow (sub flow). When the sub flow is finished,
/// Dialogflow will bring the session back to the parent flow, where the sub flow
/// is started.
///
/// Usually, when a transition route is followed by a matched intent, the intent
/// will be "consumed". This means the intent won't activate more transition
/// routes. However, when the followed transition route moves the conversation
/// session into a different flow, the matched intent can be carried over and to
/// be consumed in the target flow.
public struct Google_Cloud_Dialogflow_Cx_V3beta1_Flow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique identifier of the flow.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/flows/<Flow ID>`.
  public var name: String = String()

  /// Required. The human-readable name of the flow.
  public var displayName: String = String()

  /// The description of the flow. The maximum length is 500 characters. If
  /// exceeded, the request is rejected.
  public var description_p: String = String()

  /// A flow's transition routes serve two purposes:
  ///
  /// *   They are responsible for matching the user's first utterances in the
  /// flow.
  /// *   They are inherited by every page's [transition
  /// routes][Page.transition_routes] and can support use cases such as the user
  /// saying "help" or "can I talk to a human?", which can be handled in a common
  /// way regardless of the current page. Transition routes defined in the page
  /// have higher priority than those defined in the flow.
  ///
  /// TransitionRoutes are evalauted in the following order:
  ///
  /// *   TransitionRoutes with intent specified..
  /// *   TransitionRoutes with only condition specified.
  ///
  /// TransitionRoutes with intent specified are inherited by pages in the flow.
  public var transitionRoutes: [Google_Cloud_Dialogflow_Cx_V3beta1_TransitionRoute] = []

  /// A flow's event handlers serve two purposes:
  ///
  /// *   They are responsible for handling events (e.g. no match,
  /// webhook errors) in the flow.
  /// *   They are inherited by every page's [event
  /// handlers][Page.event_handlers], which can be used to handle common events
  /// regardless of the current page. Event handlers defined in the page
  /// have higher priority than those defined in the flow.
  ///
  /// Unlike [transition_routes][google.cloud.dialogflow.cx.v3beta1.Flow.transition_routes], these handlers are
  /// evaluated on a first-match basis. The first one that matches the event
  /// get executed, with the rest being ignored.
  public var eventHandlers: [Google_Cloud_Dialogflow_Cx_V3beta1_EventHandler] = []

  /// NLU related settings of the flow.
  public var nluSettings: Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings {
    get {return _nluSettings ?? Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings()}
    set {_nluSettings = newValue}
  }
  /// Returns true if `nluSettings` has been explicitly set.
  public var hasNluSettings: Bool {return self._nluSettings != nil}
  /// Clears the value of `nluSettings`. Subsequent reads from it will return its default value.
  public mutating func clearNluSettings() {self._nluSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nluSettings: Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings? = nil
}

/// The request message for [Flows.CreateFlow][google.cloud.dialogflow.cx.v3beta1.Flows.CreateFlow].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_CreateFlowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The agent to create a flow for.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
  public var parent: String = String()

  /// Required. The flow to create.
  public var flow: Google_Cloud_Dialogflow_Cx_V3beta1_Flow {
    get {return _flow ?? Google_Cloud_Dialogflow_Cx_V3beta1_Flow()}
    set {_flow = newValue}
  }
  /// Returns true if `flow` has been explicitly set.
  public var hasFlow: Bool {return self._flow != nil}
  /// Clears the value of `flow`. Subsequent reads from it will return its default value.
  public mutating func clearFlow() {self._flow = nil}

  /// The language of the following fields in `flow`:
  ///
  /// *  `Flow.event_handlers.trigger_fulfillment.messages`
  /// *  `Flow.transition_routes.trigger_fulfillment.messages`
  ///
  /// If not specified, the agent's default language is used.
  /// [Many
  /// languages](https://cloud.google.com/dialogflow/docs/reference/language)
  /// are supported.
  /// Note: languages must be enabled in the agent before they can be used.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _flow: Google_Cloud_Dialogflow_Cx_V3beta1_Flow? = nil
}

/// The request message for [Flows.DeleteFlow][google.cloud.dialogflow.cx.v3beta1.Flows.DeleteFlow].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_DeleteFlowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the flow to delete.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/flows/<Flow ID>`.
  public var name: String = String()

  /// This field has no effect for flows with no incoming transitions.
  /// For flows with incoming transitions:
  ///
  /// *  If `force` is set to false, an error will be returned with message
  ///    indicating the incoming transitions.
  /// *  If `force` is set to true, Dialogflow will remove the flow, as well as
  ///    any transitions to the flow (i.e. [Target
  ///    flow][EventHandler.target_flow] in event handlers or [Target
  ///    flow][TransitionRoute.target_flow] in transition routes that point to
  ///    this flow will be cleared).
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for [Flows.ListFlows][google.cloud.dialogflow.cx.v3beta1.Flows.ListFlows].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The agent containing the flows.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>`.
  public var parent: String = String()

  /// The maximum number of items to return in a single page. By default 100 and
  /// at most 1000.
  public var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous list request.
  public var pageToken: String = String()

  /// The language to list flows for. The following fields are language
  /// dependent:
  ///
  /// *  `Flow.event_handlers.trigger_fulfillment.messages`
  /// *  `Flow.transition_routes.trigger_fulfillment.messages`
  ///
  /// If not specified, the agent's default language is used.
  /// [Many
  /// languages](https://cloud.google.com/dialogflow/docs/reference/language)
  /// are supported.
  /// Note: languages must be enabled in the agent before they can be used.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response message for [Flows.ListFlows][google.cloud.dialogflow.cx.v3beta1.Flows.ListFlows].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of flows. There will be a maximum number of items returned based
  /// on the page_size field in the request.
  public var flows: [Google_Cloud_Dialogflow_Cx_V3beta1_Flow] = []

  /// Token to retrieve the next page of results, or empty if there are no more
  /// results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response message for [Flows.GetFlow][google.cloud.dialogflow.cx.v3beta1.Flows.GetFlow].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_GetFlowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the flow to get.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/flows/<Flow ID>`.
  public var name: String = String()

  /// The language to retrieve the flow for. The following fields are language
  /// dependent:
  ///
  /// *  `Flow.event_handlers.trigger_fulfillment.messages`
  /// *  `Flow.transition_routes.trigger_fulfillment.messages`
  ///
  /// If not specified, the agent's default language is used.
  /// [Many
  /// languages](https://cloud.google.com/dialogflow/docs/reference/language)
  /// are supported.
  /// Note: languages must be enabled in the agent before they can be used.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for [Flows.UpdateFlow][google.cloud.dialogflow.cx.v3beta1.Flows.UpdateFlow].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_UpdateFlowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The flow to update.
  public var flow: Google_Cloud_Dialogflow_Cx_V3beta1_Flow {
    get {return _flow ?? Google_Cloud_Dialogflow_Cx_V3beta1_Flow()}
    set {_flow = newValue}
  }
  /// Returns true if `flow` has been explicitly set.
  public var hasFlow: Bool {return self._flow != nil}
  /// Clears the value of `flow`. Subsequent reads from it will return its default value.
  public mutating func clearFlow() {self._flow = nil}

  /// Required. The mask to control which fields get updated. If `update_mask` is not
  /// specified, an error will be returned.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// The language of the following fields in `flow`:
  ///
  /// *  `Flow.event_handlers.trigger_fulfillment.messages`
  /// *  `Flow.transition_routes.trigger_fulfillment.messages`
  ///
  /// If not specified, the agent's default language is used.
  /// [Many
  /// languages](https://cloud.google.com/dialogflow/docs/reference/language)
  /// are supported.
  /// Note: languages must be enabled in the agent before they can be used.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _flow: Google_Cloud_Dialogflow_Cx_V3beta1_Flow? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request message for [Flows.TrainFlow][google.cloud.dialogflow.cx.v3beta1.Flows.TrainFlow].
public struct Google_Cloud_Dialogflow_Cx_V3beta1_TrainFlowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The flow to train.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/flows/<Flow ID>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.dialogflow.cx.v3beta1"

extension Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NluSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_type"),
    3: .standard(proto: "classification_threshold"),
    4: .standard(proto: "model_training_mode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.modelType) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.classificationThreshold) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.modelTrainingMode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.modelType != .unspecified {
      try visitor.visitSingularEnumField(value: self.modelType, fieldNumber: 1)
    }
    if self.classificationThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.classificationThreshold, fieldNumber: 3)
    }
    if self.modelTrainingMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.modelTrainingMode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings) -> Bool {
    if lhs.modelType != rhs.modelType {return false}
    if lhs.classificationThreshold != rhs.classificationThreshold {return false}
    if lhs.modelTrainingMode != rhs.modelTrainingMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODEL_TYPE_UNSPECIFIED"),
    1: .same(proto: "MODEL_TYPE_STANDARD"),
    3: .same(proto: "MODEL_TYPE_ADVANCED"),
  ]
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_NluSettings.ModelTrainingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MODEL_TRAINING_MODE_UNSPECIFIED"),
    1: .same(proto: "MODEL_TRAINING_MODE_AUTOMATIC"),
    2: .same(proto: "MODEL_TRAINING_MODE_MANUAL"),
  ]
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_Flow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Flow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "transition_routes"),
    10: .standard(proto: "event_handlers"),
    11: .standard(proto: "nlu_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.transitionRoutes) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.eventHandlers) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._nluSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.transitionRoutes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transitionRoutes, fieldNumber: 4)
    }
    if !self.eventHandlers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.eventHandlers, fieldNumber: 10)
    }
    if let v = self._nluSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_Flow, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_Flow) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.transitionRoutes != rhs.transitionRoutes {return false}
    if lhs.eventHandlers != rhs.eventHandlers {return false}
    if lhs._nluSettings != rhs._nluSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_CreateFlowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFlowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "flow"),
    3: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._flow) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._flow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_CreateFlowRequest, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_CreateFlowRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._flow != rhs._flow {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_DeleteFlowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFlowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_DeleteFlowRequest, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_DeleteFlowRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFlowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsRequest, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFlowsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flows"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.flows) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.flows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flows, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsResponse, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_ListFlowsResponse) -> Bool {
    if lhs.flows != rhs.flows {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_GetFlowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFlowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_GetFlowRequest, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_GetFlowRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_UpdateFlowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFlowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "flow"),
    2: .standard(proto: "update_mask"),
    3: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._flow) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._flow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_UpdateFlowRequest, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_UpdateFlowRequest) -> Bool {
    if lhs._flow != rhs._flow {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3beta1_TrainFlowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainFlowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3beta1_TrainFlowRequest, rhs: Google_Cloud_Dialogflow_Cx_V3beta1_TrainFlowRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/dialogflow/cx/v3/session.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request to detect user's intent.
public struct Google_Cloud_Dialogflow_Cx_V3_DetectIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the session this query is sent to.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/sessions/<Session ID>` or `projects/<Project ID>/locations/<Location
  /// ID>/agents/<Agent ID>/environments/<Environment ID>/sessions/<Session ID>`.
  /// If `Environment ID` is not specified, we assume default 'draft'
  /// environment.
  /// It's up to the API caller to choose an appropriate `Session ID`. It can be
  /// a random number or some type of session identifiers (preferably hashed).
  /// The length of the `Session ID` must not exceed 36 characters.
  ///
  /// For more information, see the [sessions
  /// guide](https://cloud.google.com/dialogflow/cx/docs/concept/session).
  public var session: String {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  /// The parameters of this query.
  public var queryParams: Google_Cloud_Dialogflow_Cx_V3_QueryParameters {
    get {return _storage._queryParams ?? Google_Cloud_Dialogflow_Cx_V3_QueryParameters()}
    set {_uniqueStorage()._queryParams = newValue}
  }
  /// Returns true if `queryParams` has been explicitly set.
  public var hasQueryParams: Bool {return _storage._queryParams != nil}
  /// Clears the value of `queryParams`. Subsequent reads from it will return its default value.
  public mutating func clearQueryParams() {_uniqueStorage()._queryParams = nil}

  /// Required. The input specification.
  public var queryInput: Google_Cloud_Dialogflow_Cx_V3_QueryInput {
    get {return _storage._queryInput ?? Google_Cloud_Dialogflow_Cx_V3_QueryInput()}
    set {_uniqueStorage()._queryInput = newValue}
  }
  /// Returns true if `queryInput` has been explicitly set.
  public var hasQueryInput: Bool {return _storage._queryInput != nil}
  /// Clears the value of `queryInput`. Subsequent reads from it will return its default value.
  public mutating func clearQueryInput() {_uniqueStorage()._queryInput = nil}

  /// Instructs the speech synthesizer how to generate the output audio.
  public var outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig {
    get {return _storage._outputAudioConfig ?? Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig()}
    set {_uniqueStorage()._outputAudioConfig = newValue}
  }
  /// Returns true if `outputAudioConfig` has been explicitly set.
  public var hasOutputAudioConfig: Bool {return _storage._outputAudioConfig != nil}
  /// Clears the value of `outputAudioConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputAudioConfig() {_uniqueStorage()._outputAudioConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The message returned from the DetectIntent method.
public struct Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The unique identifier of the response. It can be used to
  /// locate a response in the training example set or for reporting issues.
  public var responseID: String = String()

  /// The result of the conversational query.
  public var queryResult: Google_Cloud_Dialogflow_Cx_V3_QueryResult {
    get {return _queryResult ?? Google_Cloud_Dialogflow_Cx_V3_QueryResult()}
    set {_queryResult = newValue}
  }
  /// Returns true if `queryResult` has been explicitly set.
  public var hasQueryResult: Bool {return self._queryResult != nil}
  /// Clears the value of `queryResult`. Subsequent reads from it will return its default value.
  public mutating func clearQueryResult() {self._queryResult = nil}

  /// The audio data bytes encoded as specified in the request.
  /// Note: The output audio is generated based on the values of default platform
  /// text responses found in the
  /// [`query_result.response_messages`][google.cloud.dialogflow.cx.v3.QueryResult.response_messages] field. If
  /// multiple default text responses exist, they will be concatenated when
  /// generating audio. If no default platform text responses exist, the
  /// generated audio content will be empty.
  ///
  /// In some scenarios, multiple output audio fields may be present in the
  /// response structure. In these cases, only the top-most-level audio output
  /// has content.
  public var outputAudio: Data = Data()

  /// The config used by the speech synthesizer to generate the output audio.
  public var outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig {
    get {return _outputAudioConfig ?? Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig()}
    set {_outputAudioConfig = newValue}
  }
  /// Returns true if `outputAudioConfig` has been explicitly set.
  public var hasOutputAudioConfig: Bool {return self._outputAudioConfig != nil}
  /// Clears the value of `outputAudioConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputAudioConfig() {self._outputAudioConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _queryResult: Google_Cloud_Dialogflow_Cx_V3_QueryResult? = nil
  fileprivate var _outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig? = nil
}

/// The top-level message sent by the client to the
/// [Sessions.StreamingDetectIntent][google.cloud.dialogflow.cx.v3.Sessions.StreamingDetectIntent] method.
///
/// Multiple request messages should be sent in order:
///
/// 1.  The first message must contain
/// [session][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.session],
///     [query_input][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_input] plus optionally
///     [query_params][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_params]. If the client
///     wants to receive an audio response, it should also contain
///     [output_audio_config][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.output_audio_config].
///
/// 2.  If [query_input][google.cloud.dialogflow.cx.v3.StreamingDetectIntentRequest.query_input] was set to
///     [query_input.audio.config][google.cloud.dialogflow.cx.v3.AudioInput.config], all subsequent messages
///     must contain [query_input.audio.audio][google.cloud.dialogflow.cx.v3.AudioInput.audio] to continue with
///     Speech recognition.
///     If you decide to rather detect an intent from text
///     input after you already started Speech recognition, please send a message
///     with [query_input.text][google.cloud.dialogflow.cx.v3.QueryInput.text].
///
///     However, note that:
///
///     * Dialogflow will bill you for the audio duration so far.
///     * Dialogflow discards all Speech recognition results in favor of the
///       input text.
///     * Dialogflow will use the language code from the first message.
///
/// After you sent all input, you must half-close or abort the request stream.
public struct Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the session this query is sent to.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/sessions/<Session ID>` or `projects/<Project ID>/locations/<Location
  /// ID>/agents/<Agent ID>/environments/<Environment ID>/sessions/<Session ID>`.
  /// If `Environment ID` is not specified, we assume default 'draft'
  /// environment.
  /// It's up to the API caller to choose an appropriate `Session ID`. It can be
  /// a random number or some type of session identifiers (preferably hashed).
  /// The length of the `Session ID` must not exceed 36 characters.
  /// Note: session must be set in the first request.
  ///
  /// For more information, see the [sessions
  /// guide](https://cloud.google.com/dialogflow/cx/docs/concept/session).
  public var session: String {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  /// The parameters of this query.
  public var queryParams: Google_Cloud_Dialogflow_Cx_V3_QueryParameters {
    get {return _storage._queryParams ?? Google_Cloud_Dialogflow_Cx_V3_QueryParameters()}
    set {_uniqueStorage()._queryParams = newValue}
  }
  /// Returns true if `queryParams` has been explicitly set.
  public var hasQueryParams: Bool {return _storage._queryParams != nil}
  /// Clears the value of `queryParams`. Subsequent reads from it will return its default value.
  public mutating func clearQueryParams() {_uniqueStorage()._queryParams = nil}

  /// Required. The input specification.
  public var queryInput: Google_Cloud_Dialogflow_Cx_V3_QueryInput {
    get {return _storage._queryInput ?? Google_Cloud_Dialogflow_Cx_V3_QueryInput()}
    set {_uniqueStorage()._queryInput = newValue}
  }
  /// Returns true if `queryInput` has been explicitly set.
  public var hasQueryInput: Bool {return _storage._queryInput != nil}
  /// Clears the value of `queryInput`. Subsequent reads from it will return its default value.
  public mutating func clearQueryInput() {_uniqueStorage()._queryInput = nil}

  /// Instructs the speech synthesizer how to generate the output audio.
  public var outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig {
    get {return _storage._outputAudioConfig ?? Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig()}
    set {_uniqueStorage()._outputAudioConfig = newValue}
  }
  /// Returns true if `outputAudioConfig` has been explicitly set.
  public var hasOutputAudioConfig: Bool {return _storage._outputAudioConfig != nil}
  /// Clears the value of `outputAudioConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputAudioConfig() {_uniqueStorage()._outputAudioConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The top-level message returned from the `StreamingDetectIntent` method.
///
/// Multiple response messages can be returned in order:
///
/// 1.  If the input was set to streaming audio, the first one or more messages
///     contain `recognition_result`. Each `recognition_result` represents a more
///     complete transcript of what the user said. The last `recognition_result`
///     has `is_final` set to `true`.
///
/// 2.  The last message contains `detect_intent_response`.
public struct Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The output response.
  public var response: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse.OneOf_Response? = nil

  /// The result of speech recognition.
  public var recognitionResult: Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult {
    get {
      if case .recognitionResult(let v)? = response {return v}
      return Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult()
    }
    set {response = .recognitionResult(newValue)}
  }

  /// The response from detect intent.
  public var detectIntentResponse: Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse {
    get {
      if case .detectIntentResponse(let v)? = response {return v}
      return Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse()
    }
    set {response = .detectIntentResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The output response.
  public enum OneOf_Response: Equatable {
    /// The result of speech recognition.
    case recognitionResult(Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult)
    /// The response from detect intent.
    case detectIntentResponse(Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse.OneOf_Response, rhs: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.recognitionResult, .recognitionResult): return {
        guard case .recognitionResult(let l) = lhs, case .recognitionResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.detectIntentResponse, .detectIntentResponse): return {
        guard case .detectIntentResponse(let l) = lhs, case .detectIntentResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Contains a speech recognition result corresponding to a portion of the audio
/// that is currently being processed or an indication that this is the end
/// of the single requested utterance.
///
/// Example:
///
/// 1.  transcript: "tube"
///
/// 2.  transcript: "to be a"
///
/// 3.  transcript: "to be"
///
/// 4.  transcript: "to be or not to be"
///     is_final: true
///
/// 5.  transcript: " that's"
///
/// 6.  transcript: " that is"
///
/// 7.  message_type: `END_OF_SINGLE_UTTERANCE`
///
/// 8.  transcript: " that is the question"
///     is_final: true
///
/// Only two of the responses contain final results (#4 and #8 indicated by
/// `is_final: true`). Concatenating these generates the full transcript: "to be
/// or not to be that is the question".
///
/// In each response we populate:
///
/// *  for `TRANSCRIPT`: `transcript` and possibly `is_final`.
///
/// *  for `END_OF_SINGLE_UTTERANCE`: only `message_type`.
public struct Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the result message.
  public var messageType: Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult.MessageType = .unspecified

  /// Transcript text representing the words that the user spoke.
  /// Populated if and only if `message_type` = `TRANSCRIPT`.
  public var transcript: String = String()

  /// If `false`, the `StreamingRecognitionResult` represents an
  /// interim result that may change. If `true`, the recognizer will not return
  /// any further hypotheses about this piece of the audio. May only be populated
  /// for `message_type` = `TRANSCRIPT`.
  public var isFinal: Bool = false

  /// The Speech confidence between 0.0 and 1.0 for the current portion of audio.
  /// A higher number indicates an estimated greater likelihood that the
  /// recognized words are correct. The default of 0.0 is a sentinel value
  /// indicating that confidence was not set.
  ///
  /// This field is typically only provided if `is_final` is true and you should
  /// not rely on it being accurate or even set.
  public var confidence: Float = 0

  /// An estimate of the likelihood that the speech recognizer will
  /// not change its guess about this interim recognition result:
  /// * If the value is unspecified or 0.0, Dialogflow didn't compute the
  ///   stability. In particular, Dialogflow will only provide stability for
  ///   `TRANSCRIPT` results with `is_final = false`.
  /// * Otherwise, the value is in (0.0, 1.0] where 0.0 means completely
  ///   unstable and 1.0 means completely stable.
  public var stability: Float = 0

  /// Word-specific information for the words recognized by Speech in
  /// [transcript][google.cloud.dialogflow.cx.v3.StreamingRecognitionResult.transcript]. Populated if and only if `message_type` = `TRANSCRIPT` and
  /// [InputAudioConfig.enable_word_info] is set.
  public var speechWordInfo: [Google_Cloud_Dialogflow_Cx_V3_SpeechWordInfo] = []

  /// Time offset of the end of this Speech recognition result relative to the
  /// beginning of the audio. Only populated for `message_type` =
  /// `TRANSCRIPT`.
  public var speechEndOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _speechEndOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_speechEndOffset = newValue}
  }
  /// Returns true if `speechEndOffset` has been explicitly set.
  public var hasSpeechEndOffset: Bool {return self._speechEndOffset != nil}
  /// Clears the value of `speechEndOffset`. Subsequent reads from it will return its default value.
  public mutating func clearSpeechEndOffset() {self._speechEndOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of the response message.
  public enum MessageType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. Should never be used.
    case unspecified // = 0

    /// Message contains a (possibly partial) transcript.
    case transcript // = 1

    /// Event indicates that the server has detected the end of the user's speech
    /// utterance and expects no additional speech. Therefore, the server will
    /// not process additional audio (although it may subsequently return
    /// additional results). The client should stop sending additional audio
    /// data, half-close the gRPC connection, and wait for any additional results
    /// until the server closes the gRPC connection. This message is only sent if
    /// [`single_utterance`][google.cloud.dialogflow.cx.v3.InputAudioConfig.single_utterance] was set to
    /// `true`, and is not used otherwise.
    case endOfSingleUtterance // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .transcript
      case 2: self = .endOfSingleUtterance
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .transcript: return 1
      case .endOfSingleUtterance: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _speechEndOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult.MessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult.MessageType] = [
    .unspecified,
    .transcript,
    .endOfSingleUtterance,
  ]
}

#endif  // swift(>=4.2)

/// Represents the parameters of a conversational query.
public struct Google_Cloud_Dialogflow_Cx_V3_QueryParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time zone of this conversational query from the [time zone
  /// database](https://www.iana.org/time-zones), e.g., America/New_York,
  /// Europe/Paris. If not provided, the time zone specified in the agent is
  /// used.
  public var timeZone: String = String()

  /// The geo location of this conversational query.
  public var geoLocation: Google_Type_LatLng {
    get {return _geoLocation ?? Google_Type_LatLng()}
    set {_geoLocation = newValue}
  }
  /// Returns true if `geoLocation` has been explicitly set.
  public var hasGeoLocation: Bool {return self._geoLocation != nil}
  /// Clears the value of `geoLocation`. Subsequent reads from it will return its default value.
  public mutating func clearGeoLocation() {self._geoLocation = nil}

  /// Additional session entity types to replace or extend developer entity types
  /// with. The entity synonyms apply to all languages and persist for the
  /// session of this query.
  public var sessionEntityTypes: [Google_Cloud_Dialogflow_Cx_V3_SessionEntityType] = []

  /// This field can be used to pass custom data into the webhook associated with
  /// the agent. Arbitrary JSON objects are supported.
  public var payload: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _payload ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_payload = newValue}
  }
  /// Returns true if `payload` has been explicitly set.
  public var hasPayload: Bool {return self._payload != nil}
  /// Clears the value of `payload`. Subsequent reads from it will return its default value.
  public mutating func clearPayload() {self._payload = nil}

  /// Additional parameters to be put into [session
  /// parameters][SessionInfo.parameters]. To remove a
  /// parameter from the session, clients should explicitly set the parameter
  /// value to null.
  ///
  /// Depending on your protocol or client library language, this is a
  /// map, associative array, symbol table, dictionary, or JSON object
  /// composed of a collection of (MapKey, MapValue) pairs:
  ///
  /// -   MapKey type: string
  /// -   MapKey value: parameter name
  /// -   MapValue type:
  ///     -   If parameter's entity type is a composite entity: map
  ///     -   Else: string or number, depending on parameter value type
  /// -   MapValue value:
  ///     -   If parameter's entity type is a composite entity:
  ///         map from composite entity property names to property values
  ///     -   Else: parameter value
  public var parameters: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _parameters ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  /// Configures whether sentiment analysis should be performed. If not
  /// provided, sentiment analysis is not performed.
  public var analyzeQueryTextSentiment: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _geoLocation: Google_Type_LatLng? = nil
  fileprivate var _payload: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _parameters: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// Represents the query input. It can contain one of:
///
/// 1.  A conversational query in the form of text.
///
/// 2.  An intent query that specifies which intent to trigger.
///
/// 3.  Natural language speech audio to be processed.
///
/// 4.  An event to be triggered.
public struct Google_Cloud_Dialogflow_Cx_V3_QueryInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The input specification.
  public var input: Google_Cloud_Dialogflow_Cx_V3_QueryInput.OneOf_Input? = nil

  /// The natural language text to be processed.
  public var text: Google_Cloud_Dialogflow_Cx_V3_TextInput {
    get {
      if case .text(let v)? = input {return v}
      return Google_Cloud_Dialogflow_Cx_V3_TextInput()
    }
    set {input = .text(newValue)}
  }

  /// The intent to be triggered.
  public var intent: Google_Cloud_Dialogflow_Cx_V3_IntentInput {
    get {
      if case .intent(let v)? = input {return v}
      return Google_Cloud_Dialogflow_Cx_V3_IntentInput()
    }
    set {input = .intent(newValue)}
  }

  /// The natural language speech audio to be processed.
  public var audio: Google_Cloud_Dialogflow_Cx_V3_AudioInput {
    get {
      if case .audio(let v)? = input {return v}
      return Google_Cloud_Dialogflow_Cx_V3_AudioInput()
    }
    set {input = .audio(newValue)}
  }

  /// The event to be triggered.
  public var event: Google_Cloud_Dialogflow_Cx_V3_EventInput {
    get {
      if case .event(let v)? = input {return v}
      return Google_Cloud_Dialogflow_Cx_V3_EventInput()
    }
    set {input = .event(newValue)}
  }

  /// The DTMF event to be handled.
  public var dtmf: Google_Cloud_Dialogflow_Cx_V3_DtmfInput {
    get {
      if case .dtmf(let v)? = input {return v}
      return Google_Cloud_Dialogflow_Cx_V3_DtmfInput()
    }
    set {input = .dtmf(newValue)}
  }

  /// Required. The language of the input. See [Language
  /// Support](https://cloud.google.com/dialogflow/docs/reference/language) for a
  /// list of the currently supported language codes. Note that queries in the
  /// same session do not necessarily need to specify the same language.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The input specification.
  public enum OneOf_Input: Equatable {
    /// The natural language text to be processed.
    case text(Google_Cloud_Dialogflow_Cx_V3_TextInput)
    /// The intent to be triggered.
    case intent(Google_Cloud_Dialogflow_Cx_V3_IntentInput)
    /// The natural language speech audio to be processed.
    case audio(Google_Cloud_Dialogflow_Cx_V3_AudioInput)
    /// The event to be triggered.
    case event(Google_Cloud_Dialogflow_Cx_V3_EventInput)
    /// The DTMF event to be handled.
    case dtmf(Google_Cloud_Dialogflow_Cx_V3_DtmfInput)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_QueryInput.OneOf_Input, rhs: Google_Cloud_Dialogflow_Cx_V3_QueryInput.OneOf_Input) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intent, .intent): return {
        guard case .intent(let l) = lhs, case .intent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audio, .audio): return {
        guard case .audio(let l) = lhs, case .audio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.event, .event): return {
        guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dtmf, .dtmf): return {
        guard case .dtmf(let l) = lhs, case .dtmf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Represents the result of a conversational query.
public struct Google_Cloud_Dialogflow_Cx_V3_QueryResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The original conversational query.
  public var query: OneOf_Query? {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was provided as input, this field
  /// will contain a copy of the text.
  public var text: String {
    get {
      if case .text(let v)? = _storage._query {return v}
      return String()
    }
    set {_uniqueStorage()._query = .text(newValue)}
  }

  /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as input, this field will
  /// contain a copy of the intent identifier.
  public var triggerIntent: String {
    get {
      if case .triggerIntent(let v)? = _storage._query {return v}
      return String()
    }
    set {_uniqueStorage()._query = .triggerIntent(newValue)}
  }

  /// If [natural language speech audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
  /// this field will contain the trascript for the audio.
  public var transcript: String {
    get {
      if case .transcript(let v)? = _storage._query {return v}
      return String()
    }
    set {_uniqueStorage()._query = .transcript(newValue)}
  }

  /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as input, this field will contain
  /// the name of the event.
  public var triggerEvent: String {
    get {
      if case .triggerEvent(let v)? = _storage._query {return v}
      return String()
    }
    set {_uniqueStorage()._query = .triggerEvent(newValue)}
  }

  /// The language that was triggered during intent detection.
  /// See [Language
  /// Support](https://cloud.google.com/dialogflow/docs/reference/language)
  /// for a list of the currently supported language codes.
  public var languageCode: String {
    get {return _storage._languageCode}
    set {_uniqueStorage()._languageCode = newValue}
  }

  /// The collected [session parameters][google.cloud.dialogflow.cx.v3.SessionInfo.parameters].
  ///
  /// Depending on your protocol or client library language, this is a
  /// map, associative array, symbol table, dictionary, or JSON object
  /// composed of a collection of (MapKey, MapValue) pairs:
  ///
  /// -   MapKey type: string
  /// -   MapKey value: parameter name
  /// -   MapValue type:
  ///     -   If parameter's entity type is a composite entity: map
  ///     -   Else: string or number, depending on parameter value type
  /// -   MapValue value:
  ///     -   If parameter's entity type is a composite entity:
  ///         map from composite entity property names to property values
  ///     -   Else: parameter value
  public var parameters: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._parameters ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return _storage._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {_uniqueStorage()._parameters = nil}

  /// The list of rich messages returned to the client. Responses vary from
  /// simple text messages to more sophisticated, structured payloads used
  /// to drive complex logic.
  public var responseMessages: [Google_Cloud_Dialogflow_Cx_V3_ResponseMessage] {
    get {return _storage._responseMessages}
    set {_uniqueStorage()._responseMessages = newValue}
  }

  /// The list of webhook call status in the order of call sequence.
  public var webhookStatuses: [Google_Rpc_Status] {
    get {return _storage._webhookStatuses}
    set {_uniqueStorage()._webhookStatuses = newValue}
  }

  /// The list of webhook payload in [WebhookResponse.payload][google.cloud.dialogflow.cx.v3.WebhookResponse.payload], in
  /// the order of call sequence. If some webhook call fails or doesn't return
  /// any payload, an empty `Struct` would be used instead.
  public var webhookPayloads: [SwiftProtobuf.Google_Protobuf_Struct] {
    get {return _storage._webhookPayloads}
    set {_uniqueStorage()._webhookPayloads = newValue}
  }

  /// The current [Page][google.cloud.dialogflow.cx.v3.Page]. Some, not all fields are filled in this message,
  /// including but not limited to `name` and `display_name`.
  public var currentPage: Google_Cloud_Dialogflow_Cx_V3_Page {
    get {return _storage._currentPage ?? Google_Cloud_Dialogflow_Cx_V3_Page()}
    set {_uniqueStorage()._currentPage = newValue}
  }
  /// Returns true if `currentPage` has been explicitly set.
  public var hasCurrentPage: Bool {return _storage._currentPage != nil}
  /// Clears the value of `currentPage`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPage() {_uniqueStorage()._currentPage = nil}

  /// The [Intent][google.cloud.dialogflow.cx.v3.Intent] that matched the conversational query. Some, not all fields
  /// are filled in this message, including but not limited to: `name` and
  /// `display_name`.
  /// This field is deprecated, please use [QueryResult.match][google.cloud.dialogflow.cx.v3.QueryResult.match] instead.
  public var intent: Google_Cloud_Dialogflow_Cx_V3_Intent {
    get {return _storage._intent ?? Google_Cloud_Dialogflow_Cx_V3_Intent()}
    set {_uniqueStorage()._intent = newValue}
  }
  /// Returns true if `intent` has been explicitly set.
  public var hasIntent: Bool {return _storage._intent != nil}
  /// Clears the value of `intent`. Subsequent reads from it will return its default value.
  public mutating func clearIntent() {_uniqueStorage()._intent = nil}

  /// The intent detection confidence. Values range from 0.0 (completely
  /// uncertain) to 1.0 (completely certain).
  /// This value is for informational purpose only and is only used to
  /// help match the best intent within the classification threshold.
  /// This value may change for the same end-user expression at any time due to a
  /// model retraining or change in implementation.
  /// This field is deprecated, please use [QueryResult.match][google.cloud.dialogflow.cx.v3.QueryResult.match] instead.
  public var intentDetectionConfidence: Float {
    get {return _storage._intentDetectionConfidence}
    set {_uniqueStorage()._intentDetectionConfidence = newValue}
  }

  /// Intent match result, could be an intent or an event.
  public var match: Google_Cloud_Dialogflow_Cx_V3_Match {
    get {return _storage._match ?? Google_Cloud_Dialogflow_Cx_V3_Match()}
    set {_uniqueStorage()._match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return _storage._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {_uniqueStorage()._match = nil}

  /// The free-form diagnostic info. For example, this field could contain
  /// webhook call latency. The string keys of the Struct's fields map can change
  /// without notice.
  public var diagnosticInfo: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _storage._diagnosticInfo ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_uniqueStorage()._diagnosticInfo = newValue}
  }
  /// Returns true if `diagnosticInfo` has been explicitly set.
  public var hasDiagnosticInfo: Bool {return _storage._diagnosticInfo != nil}
  /// Clears the value of `diagnosticInfo`. Subsequent reads from it will return its default value.
  public mutating func clearDiagnosticInfo() {_uniqueStorage()._diagnosticInfo = nil}

  /// The sentiment analyss result, which depends on
  /// [`analyze_query_text_sentiment`]
  /// [google.cloud.dialogflow.cx.v3.QueryParameters.analyze_query_text_sentiment], specified in the request.
  public var sentimentAnalysisResult: Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult {
    get {return _storage._sentimentAnalysisResult ?? Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult()}
    set {_uniqueStorage()._sentimentAnalysisResult = newValue}
  }
  /// Returns true if `sentimentAnalysisResult` has been explicitly set.
  public var hasSentimentAnalysisResult: Bool {return _storage._sentimentAnalysisResult != nil}
  /// Clears the value of `sentimentAnalysisResult`. Subsequent reads from it will return its default value.
  public mutating func clearSentimentAnalysisResult() {_uniqueStorage()._sentimentAnalysisResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The original conversational query.
  public enum OneOf_Query: Equatable {
    /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was provided as input, this field
    /// will contain a copy of the text.
    case text(String)
    /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as input, this field will
    /// contain a copy of the intent identifier.
    case triggerIntent(String)
    /// If [natural language speech audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
    /// this field will contain the trascript for the audio.
    case transcript(String)
    /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as input, this field will contain
    /// the name of the event.
    case triggerEvent(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_QueryResult.OneOf_Query, rhs: Google_Cloud_Dialogflow_Cx_V3_QueryResult.OneOf_Query) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.triggerIntent, .triggerIntent): return {
        guard case .triggerIntent(let l) = lhs, case .triggerIntent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transcript, .transcript): return {
        guard case .transcript(let l) = lhs, case .transcript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.triggerEvent, .triggerEvent): return {
        guard case .triggerEvent(let l) = lhs, case .triggerEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Represents the natural language text to be processed.
public struct Google_Cloud_Dialogflow_Cx_V3_TextInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The UTF-8 encoded natural language text to be processed. Text length must
  /// not exceed 256 characters.
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the intent to trigger programmatically rather than as a result of
/// natural language processing.
public struct Google_Cloud_Dialogflow_Cx_V3_IntentInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique identifier of the intent.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/intents/<Intent ID>`.
  public var intent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the natural speech audio to be processed.
public struct Google_Cloud_Dialogflow_Cx_V3_AudioInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Instructs the speech recognizer how to process the speech audio.
  public var config: Google_Cloud_Dialogflow_Cx_V3_InputAudioConfig {
    get {return _config ?? Google_Cloud_Dialogflow_Cx_V3_InputAudioConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// The natural language speech audio to be processed.
  /// A single request can contain up to 1 minute of speech audio data.
  /// The [transcribed text][google.cloud.dialogflow.cx.v3.QueryResult.transcript] cannot contain more than 256
  /// bytes.
  ///
  /// For non-streaming audio detect intent, both `config` and `audio` must be
  /// provided.
  /// For streaming audio detect intent, `config` must be provided in
  /// the first request and `audio` must be provided in all following requests.
  public var audio: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Google_Cloud_Dialogflow_Cx_V3_InputAudioConfig? = nil
}

/// Represents the event to trigger.
public struct Google_Cloud_Dialogflow_Cx_V3_EventInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the event.
  public var event: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the input for dtmf event.
public struct Google_Cloud_Dialogflow_Cx_V3_DtmfInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The dtmf digits.
  public var digits: String = String()

  /// The finish digit (if any).
  public var finishDigit: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents one match result of [MatchIntent][].
public struct Google_Cloud_Dialogflow_Cx_V3_Match {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The [Intent][google.cloud.dialogflow.cx.v3.Intent] that matched the query. Some, not all fields are filled in
  /// this message, including but not limited to: `name` and `display_name`. Only
  /// filled for [`INTENT`][google.cloud.dialogflow.cx.v3.Match.MatchType] match type.
  public var intent: Google_Cloud_Dialogflow_Cx_V3_Intent {
    get {return _intent ?? Google_Cloud_Dialogflow_Cx_V3_Intent()}
    set {_intent = newValue}
  }
  /// Returns true if `intent` has been explicitly set.
  public var hasIntent: Bool {return self._intent != nil}
  /// Clears the value of `intent`. Subsequent reads from it will return its default value.
  public mutating func clearIntent() {self._intent = nil}

  /// The event that matched the query. Only filled for
  /// [`EVENT`][google.cloud.dialogflow.cx.v3.Match.MatchType] match type.
  public var event: String = String()

  /// The collection of parameters extracted from the query.
  ///
  /// Depending on your protocol or client library language, this is a
  /// map, associative array, symbol table, dictionary, or JSON object
  /// composed of a collection of (MapKey, MapValue) pairs:
  ///
  /// -   MapKey type: string
  /// -   MapKey value: parameter name
  /// -   MapValue type:
  ///     -   If parameter's entity type is a composite entity: map
  ///     -   Else: string or number, depending on parameter value type
  /// -   MapValue value:
  ///     -   If parameter's entity type is a composite entity:
  ///         map from composite entity property names to property values
  ///     -   Else: parameter value
  public var parameters: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _parameters ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  /// Final text input which was matched during MatchIntent. This value can be
  /// different from original input sent in request because of spelling
  /// correction or other processing.
  public var resolvedInput: String = String()

  /// Type of this [Match][google.cloud.dialogflow.cx.v3.Match].
  public var matchType: Google_Cloud_Dialogflow_Cx_V3_Match.MatchType = .unspecified

  /// The confidence of this match. Values range from 0.0 (completely uncertain)
  /// to 1.0 (completely certain).
  /// This value is for informational purpose only and is only used to help match
  /// the best intent within the classification threshold. This value may change
  /// for the same end-user expression at any time due to a model retraining or
  /// change in implementation.
  public var confidence: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of a Match.
  public enum MatchType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. Should never be used.
    case unspecified // = 0

    /// The query was matched to an intent.
    case intent // = 1

    /// The query directly triggered an intent.
    case directIntent // = 2

    /// The query was used for parameter filling.
    case parameterFilling // = 3

    /// No match was found for the query.
    case noMatch // = 4

    /// Indicates an empty query.
    case noInput // = 5

    /// The query directly triggered an event.
    case event // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .intent
      case 2: self = .directIntent
      case 3: self = .parameterFilling
      case 4: self = .noMatch
      case 5: self = .noInput
      case 6: self = .event
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .intent: return 1
      case .directIntent: return 2
      case .parameterFilling: return 3
      case .noMatch: return 4
      case .noInput: return 5
      case .event: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _intent: Google_Cloud_Dialogflow_Cx_V3_Intent? = nil
  fileprivate var _parameters: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Dialogflow_Cx_V3_Match.MatchType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Dialogflow_Cx_V3_Match.MatchType] = [
    .unspecified,
    .intent,
    .directIntent,
    .parameterFilling,
    .noMatch,
    .noInput,
    .event,
  ]
}

#endif  // swift(>=4.2)

/// Request of [MatchIntent][].
public struct Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the session this query is sent to.
  /// Format: `projects/<Project ID>/locations/<Location ID>/agents/<Agent
  /// ID>/sessions/<Session ID>` or `projects/<Project ID>/locations/<Location
  /// ID>/agents/<Agent ID>/environments/<Environment ID>/sessions/<Session ID>`.
  /// If `Environment ID` is not specified, we assume default 'draft'
  /// environment.
  /// It's up to the API caller to choose an appropriate `Session ID`. It can be
  /// a random number or some type of session identifiers (preferably hashed).
  /// The length of the `Session ID` must not exceed 36 characters.
  ///
  /// For more information, see the [sessions
  /// guide](https://cloud.google.com/dialogflow/cx/docs/concept/session).
  public var session: String {
    get {return _storage._session}
    set {_uniqueStorage()._session = newValue}
  }

  /// The parameters of this query.
  public var queryParams: Google_Cloud_Dialogflow_Cx_V3_QueryParameters {
    get {return _storage._queryParams ?? Google_Cloud_Dialogflow_Cx_V3_QueryParameters()}
    set {_uniqueStorage()._queryParams = newValue}
  }
  /// Returns true if `queryParams` has been explicitly set.
  public var hasQueryParams: Bool {return _storage._queryParams != nil}
  /// Clears the value of `queryParams`. Subsequent reads from it will return its default value.
  public mutating func clearQueryParams() {_uniqueStorage()._queryParams = nil}

  /// Required. The input specification.
  public var queryInput: Google_Cloud_Dialogflow_Cx_V3_QueryInput {
    get {return _storage._queryInput ?? Google_Cloud_Dialogflow_Cx_V3_QueryInput()}
    set {_uniqueStorage()._queryInput = newValue}
  }
  /// Returns true if `queryInput` has been explicitly set.
  public var hasQueryInput: Bool {return _storage._queryInput != nil}
  /// Clears the value of `queryInput`. Subsequent reads from it will return its default value.
  public mutating func clearQueryInput() {_uniqueStorage()._queryInput = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Response of [MatchIntent][].
public struct Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The original conversational query.
  public var query: Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse.OneOf_Query? = nil

  /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was provided as input, this field
  /// will contain a copy of the text.
  public var text: String {
    get {
      if case .text(let v)? = query {return v}
      return String()
    }
    set {query = .text(newValue)}
  }

  /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as input, this field will
  /// contain a copy of the intent identifier.
  public var triggerIntent: String {
    get {
      if case .triggerIntent(let v)? = query {return v}
      return String()
    }
    set {query = .triggerIntent(newValue)}
  }

  /// If [natural language speech audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
  /// this field will contain the trascript for the audio.
  public var transcript: String {
    get {
      if case .transcript(let v)? = query {return v}
      return String()
    }
    set {query = .transcript(newValue)}
  }

  /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as input, this field will
  /// contain a copy of the event name.
  public var triggerEvent: String {
    get {
      if case .triggerEvent(let v)? = query {return v}
      return String()
    }
    set {query = .triggerEvent(newValue)}
  }

  /// Match results, if more than one, ordered descendingly by the confidence
  /// we have that the particular intent matches the query.
  public var matches: [Google_Cloud_Dialogflow_Cx_V3_Match] = []

  /// The current [Page][google.cloud.dialogflow.cx.v3.Page]. Some, not all fields are filled in this message,
  /// including but not limited to `name` and `display_name`.
  public var currentPage: Google_Cloud_Dialogflow_Cx_V3_Page {
    get {return _currentPage ?? Google_Cloud_Dialogflow_Cx_V3_Page()}
    set {_currentPage = newValue}
  }
  /// Returns true if `currentPage` has been explicitly set.
  public var hasCurrentPage: Bool {return self._currentPage != nil}
  /// Clears the value of `currentPage`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentPage() {self._currentPage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The original conversational query.
  public enum OneOf_Query: Equatable {
    /// If [natural language text][google.cloud.dialogflow.cx.v3.TextInput] was provided as input, this field
    /// will contain a copy of the text.
    case text(String)
    /// If an [intent][google.cloud.dialogflow.cx.v3.IntentInput] was provided as input, this field will
    /// contain a copy of the intent identifier.
    case triggerIntent(String)
    /// If [natural language speech audio][google.cloud.dialogflow.cx.v3.AudioInput] was provided as input,
    /// this field will contain the trascript for the audio.
    case transcript(String)
    /// If an [event][google.cloud.dialogflow.cx.v3.EventInput] was provided as input, this field will
    /// contain a copy of the event name.
    case triggerEvent(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse.OneOf_Query, rhs: Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse.OneOf_Query) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.triggerIntent, .triggerIntent): return {
        guard case .triggerIntent(let l) = lhs, case .triggerIntent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transcript, .transcript): return {
        guard case .transcript(let l) = lhs, case .transcript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.triggerEvent, .triggerEvent): return {
        guard case .triggerEvent(let l) = lhs, case .triggerEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _currentPage: Google_Cloud_Dialogflow_Cx_V3_Page? = nil
}

/// Request of [FulfillIntent][]
public struct Google_Cloud_Dialogflow_Cx_V3_FulfillIntentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must be same as the corresponding MatchIntent request, otherwise the
  /// behavior is undefined.
  public var matchIntentRequest: Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest {
    get {return _storage._matchIntentRequest ?? Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest()}
    set {_uniqueStorage()._matchIntentRequest = newValue}
  }
  /// Returns true if `matchIntentRequest` has been explicitly set.
  public var hasMatchIntentRequest: Bool {return _storage._matchIntentRequest != nil}
  /// Clears the value of `matchIntentRequest`. Subsequent reads from it will return its default value.
  public mutating func clearMatchIntentRequest() {_uniqueStorage()._matchIntentRequest = nil}

  /// The matched intent/event to fulfill.
  public var match: Google_Cloud_Dialogflow_Cx_V3_Match {
    get {return _storage._match ?? Google_Cloud_Dialogflow_Cx_V3_Match()}
    set {_uniqueStorage()._match = newValue}
  }
  /// Returns true if `match` has been explicitly set.
  public var hasMatch: Bool {return _storage._match != nil}
  /// Clears the value of `match`. Subsequent reads from it will return its default value.
  public mutating func clearMatch() {_uniqueStorage()._match = nil}

  /// Instructs the speech synthesizer how to generate output audio.
  public var outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig {
    get {return _storage._outputAudioConfig ?? Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig()}
    set {_uniqueStorage()._outputAudioConfig = newValue}
  }
  /// Returns true if `outputAudioConfig` has been explicitly set.
  public var hasOutputAudioConfig: Bool {return _storage._outputAudioConfig != nil}
  /// Clears the value of `outputAudioConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputAudioConfig() {_uniqueStorage()._outputAudioConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Response of [FulfillIntent][]
public struct Google_Cloud_Dialogflow_Cx_V3_FulfillIntentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The unique identifier of the response. It can be used to
  /// locate a response in the training example set or for reporting issues.
  public var responseID: String = String()

  /// The result of the conversational query.
  public var queryResult: Google_Cloud_Dialogflow_Cx_V3_QueryResult {
    get {return _queryResult ?? Google_Cloud_Dialogflow_Cx_V3_QueryResult()}
    set {_queryResult = newValue}
  }
  /// Returns true if `queryResult` has been explicitly set.
  public var hasQueryResult: Bool {return self._queryResult != nil}
  /// Clears the value of `queryResult`. Subsequent reads from it will return its default value.
  public mutating func clearQueryResult() {self._queryResult = nil}

  /// The audio data bytes encoded as specified in the request.
  /// Note: The output audio is generated based on the values of default platform
  /// text responses found in the
  /// [`query_result.response_messages`][google.cloud.dialogflow.cx.v3.QueryResult.response_messages] field. If
  /// multiple default text responses exist, they will be concatenated when
  /// generating audio. If no default platform text responses exist, the
  /// generated audio content will be empty.
  ///
  /// In some scenarios, multiple output audio fields may be present in the
  /// response structure. In these cases, only the top-most-level audio output
  /// has content.
  public var outputAudio: Data = Data()

  /// The config used by the speech synthesizer to generate the output audio.
  public var outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig {
    get {return _outputAudioConfig ?? Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig()}
    set {_outputAudioConfig = newValue}
  }
  /// Returns true if `outputAudioConfig` has been explicitly set.
  public var hasOutputAudioConfig: Bool {return self._outputAudioConfig != nil}
  /// Clears the value of `outputAudioConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputAudioConfig() {self._outputAudioConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _queryResult: Google_Cloud_Dialogflow_Cx_V3_QueryResult? = nil
  fileprivate var _outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig? = nil
}

/// The result of sentiment analysis. Sentiment analysis inspects user input
/// and identifies the prevailing subjective opinion, especially to determine a
/// user's attitude as positive, negative, or neutral.
public struct Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sentiment score between -1.0 (negative sentiment) and 1.0 (positive
  /// sentiment).
  public var score: Float = 0

  /// A non-negative number in the [0, +inf) range, which represents the absolute
  /// magnitude of sentiment, regardless of score (positive or negative).
  public var magnitude: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.dialogflow.cx.v3"

extension Google_Cloud_Dialogflow_Cx_V3_DetectIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetectIntentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "query_params"),
    3: .standard(proto: "query_input"),
    4: .standard(proto: "output_audio_config"),
  ]

  fileprivate class _StorageClass {
    var _session: String = String()
    var _queryParams: Google_Cloud_Dialogflow_Cx_V3_QueryParameters? = nil
    var _queryInput: Google_Cloud_Dialogflow_Cx_V3_QueryInput? = nil
    var _outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _session = source._session
      _queryParams = source._queryParams
      _queryInput = source._queryInput
      _outputAudioConfig = source._outputAudioConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._session) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._queryParams) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._queryInput) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._outputAudioConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 1)
      }
      if let v = _storage._queryParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._queryInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._outputAudioConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_DetectIntentRequest, rhs: Google_Cloud_Dialogflow_Cx_V3_DetectIntentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._session != rhs_storage._session {return false}
        if _storage._queryParams != rhs_storage._queryParams {return false}
        if _storage._queryInput != rhs_storage._queryInput {return false}
        if _storage._outputAudioConfig != rhs_storage._outputAudioConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DetectIntentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_id"),
    2: .standard(proto: "query_result"),
    4: .standard(proto: "output_audio"),
    5: .standard(proto: "output_audio_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.responseID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._queryResult) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.outputAudio) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputAudioConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responseID.isEmpty {
      try visitor.visitSingularStringField(value: self.responseID, fieldNumber: 1)
    }
    if let v = self._queryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.outputAudio.isEmpty {
      try visitor.visitSingularBytesField(value: self.outputAudio, fieldNumber: 4)
    }
    if let v = self._outputAudioConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse, rhs: Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse) -> Bool {
    if lhs.responseID != rhs.responseID {return false}
    if lhs._queryResult != rhs._queryResult {return false}
    if lhs.outputAudio != rhs.outputAudio {return false}
    if lhs._outputAudioConfig != rhs._outputAudioConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingDetectIntentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "query_params"),
    3: .standard(proto: "query_input"),
    4: .standard(proto: "output_audio_config"),
  ]

  fileprivate class _StorageClass {
    var _session: String = String()
    var _queryParams: Google_Cloud_Dialogflow_Cx_V3_QueryParameters? = nil
    var _queryInput: Google_Cloud_Dialogflow_Cx_V3_QueryInput? = nil
    var _outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _session = source._session
      _queryParams = source._queryParams
      _queryInput = source._queryInput
      _outputAudioConfig = source._outputAudioConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._session) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._queryParams) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._queryInput) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._outputAudioConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 1)
      }
      if let v = _storage._queryParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._queryInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._outputAudioConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentRequest, rhs: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._session != rhs_storage._session {return false}
        if _storage._queryParams != rhs_storage._queryParams {return false}
        if _storage._queryInput != rhs_storage._queryInput {return false}
        if _storage._outputAudioConfig != rhs_storage._outputAudioConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingDetectIntentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "recognition_result"),
    2: .standard(proto: "detect_intent_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult?
        if let current = self.response {
          try decoder.handleConflictingOneOf()
          if case .recognitionResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.response = .recognitionResult(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_DetectIntentResponse?
        if let current = self.response {
          try decoder.handleConflictingOneOf()
          if case .detectIntentResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.response = .detectIntentResponse(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.response {
    case .recognitionResult?: try {
      guard case .recognitionResult(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .detectIntentResponse?: try {
      guard case .detectIntentResponse(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse, rhs: Google_Cloud_Dialogflow_Cx_V3_StreamingDetectIntentResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StreamingRecognitionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_type"),
    2: .same(proto: "transcript"),
    3: .standard(proto: "is_final"),
    4: .same(proto: "confidence"),
    6: .same(proto: "stability"),
    7: .standard(proto: "speech_word_info"),
    8: .standard(proto: "speech_end_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.messageType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.transcript) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isFinal) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.confidence) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.stability) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.speechWordInfo) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._speechEndOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageType != .unspecified {
      try visitor.visitSingularEnumField(value: self.messageType, fieldNumber: 1)
    }
    if !self.transcript.isEmpty {
      try visitor.visitSingularStringField(value: self.transcript, fieldNumber: 2)
    }
    if self.isFinal != false {
      try visitor.visitSingularBoolField(value: self.isFinal, fieldNumber: 3)
    }
    if self.confidence != 0 {
      try visitor.visitSingularFloatField(value: self.confidence, fieldNumber: 4)
    }
    if self.stability != 0 {
      try visitor.visitSingularFloatField(value: self.stability, fieldNumber: 6)
    }
    if !self.speechWordInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.speechWordInfo, fieldNumber: 7)
    }
    if let v = self._speechEndOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult, rhs: Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.transcript != rhs.transcript {return false}
    if lhs.isFinal != rhs.isFinal {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.stability != rhs.stability {return false}
    if lhs.speechWordInfo != rhs.speechWordInfo {return false}
    if lhs._speechEndOffset != rhs._speechEndOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_StreamingRecognitionResult.MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MESSAGE_TYPE_UNSPECIFIED"),
    1: .same(proto: "TRANSCRIPT"),
    2: .same(proto: "END_OF_SINGLE_UTTERANCE"),
  ]
}

extension Google_Cloud_Dialogflow_Cx_V3_QueryParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_zone"),
    2: .standard(proto: "geo_location"),
    3: .standard(proto: "session_entity_types"),
    4: .same(proto: "payload"),
    5: .same(proto: "parameters"),
    8: .standard(proto: "analyze_query_text_sentiment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timeZone) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._geoLocation) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sessionEntityTypes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._payload) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.analyzeQueryTextSentiment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timeZone.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZone, fieldNumber: 1)
    }
    if let v = self._geoLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.sessionEntityTypes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessionEntityTypes, fieldNumber: 3)
    }
    if let v = self._payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.analyzeQueryTextSentiment != false {
      try visitor.visitSingularBoolField(value: self.analyzeQueryTextSentiment, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_QueryParameters, rhs: Google_Cloud_Dialogflow_Cx_V3_QueryParameters) -> Bool {
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs._geoLocation != rhs._geoLocation {return false}
    if lhs.sessionEntityTypes != rhs.sessionEntityTypes {return false}
    if lhs._payload != rhs._payload {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.analyzeQueryTextSentiment != rhs.analyzeQueryTextSentiment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_QueryInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "text"),
    3: .same(proto: "intent"),
    5: .same(proto: "audio"),
    6: .same(proto: "event"),
    7: .same(proto: "dtmf"),
    4: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_TextInput?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .text(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_IntentInput?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .intent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .intent(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 5: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_AudioInput?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .audio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .audio(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_EventInput?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .event(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Dialogflow_Cx_V3_DtmfInput?
        if let current = self.input {
          try decoder.handleConflictingOneOf()
          if case .dtmf(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.input = .dtmf(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.input {
    case .text?: try {
      guard case .text(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .intent?: try {
      guard case .intent(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.input {
    case .audio?: try {
      guard case .audio(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .event?: try {
      guard case .event(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .dtmf?: try {
      guard case .dtmf(let v)? = self.input else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_QueryInput, rhs: Google_Cloud_Dialogflow_Cx_V3_QueryInput) -> Bool {
    if lhs.input != rhs.input {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_QueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    11: .standard(proto: "trigger_intent"),
    12: .same(proto: "transcript"),
    14: .standard(proto: "trigger_event"),
    2: .standard(proto: "language_code"),
    3: .same(proto: "parameters"),
    4: .standard(proto: "response_messages"),
    13: .standard(proto: "webhook_statuses"),
    6: .standard(proto: "webhook_payloads"),
    7: .standard(proto: "current_page"),
    8: .same(proto: "intent"),
    9: .standard(proto: "intent_detection_confidence"),
    15: .same(proto: "match"),
    10: .standard(proto: "diagnostic_info"),
    17: .standard(proto: "sentiment_analysis_result"),
  ]

  fileprivate class _StorageClass {
    var _query: Google_Cloud_Dialogflow_Cx_V3_QueryResult.OneOf_Query?
    var _languageCode: String = String()
    var _parameters: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _responseMessages: [Google_Cloud_Dialogflow_Cx_V3_ResponseMessage] = []
    var _webhookStatuses: [Google_Rpc_Status] = []
    var _webhookPayloads: [SwiftProtobuf.Google_Protobuf_Struct] = []
    var _currentPage: Google_Cloud_Dialogflow_Cx_V3_Page? = nil
    var _intent: Google_Cloud_Dialogflow_Cx_V3_Intent? = nil
    var _intentDetectionConfidence: Float = 0
    var _match: Google_Cloud_Dialogflow_Cx_V3_Match? = nil
    var _diagnosticInfo: SwiftProtobuf.Google_Protobuf_Struct? = nil
    var _sentimentAnalysisResult: Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _query = source._query
      _languageCode = source._languageCode
      _parameters = source._parameters
      _responseMessages = source._responseMessages
      _webhookStatuses = source._webhookStatuses
      _webhookPayloads = source._webhookPayloads
      _currentPage = source._currentPage
      _intent = source._intent
      _intentDetectionConfidence = source._intentDetectionConfidence
      _match = source._match
      _diagnosticInfo = source._diagnosticInfo
      _sentimentAnalysisResult = source._sentimentAnalysisResult
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          if _storage._query != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._query = .text(v)}
        }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._languageCode) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._parameters) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._responseMessages) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._webhookPayloads) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._currentPage) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._intent) }()
        case 9: try { try decoder.decodeSingularFloatField(value: &_storage._intentDetectionConfidence) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._diagnosticInfo) }()
        case 11: try {
          if _storage._query != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._query = .triggerIntent(v)}
        }()
        case 12: try {
          if _storage._query != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._query = .transcript(v)}
        }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._webhookStatuses) }()
        case 14: try {
          if _storage._query != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._query = .triggerEvent(v)}
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._match) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._sentimentAnalysisResult) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if case .text(let v)? = _storage._query {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._languageCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._languageCode, fieldNumber: 2)
      }
      if let v = _storage._parameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._responseMessages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._responseMessages, fieldNumber: 4)
      }
      if !_storage._webhookPayloads.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._webhookPayloads, fieldNumber: 6)
      }
      if let v = _storage._currentPage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._intent {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._intentDetectionConfidence != 0 {
        try visitor.visitSingularFloatField(value: _storage._intentDetectionConfidence, fieldNumber: 9)
      }
      if let v = _storage._diagnosticInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._query {
      case .triggerIntent?: try {
        guard case .triggerIntent(let v)? = _storage._query else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }()
      case .transcript?: try {
        guard case .transcript(let v)? = _storage._query else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      }()
      default: break
      }
      if !_storage._webhookStatuses.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._webhookStatuses, fieldNumber: 13)
      }
      if case .triggerEvent(let v)? = _storage._query {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._match {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._sentimentAnalysisResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_QueryResult, rhs: Google_Cloud_Dialogflow_Cx_V3_QueryResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._query != rhs_storage._query {return false}
        if _storage._languageCode != rhs_storage._languageCode {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._responseMessages != rhs_storage._responseMessages {return false}
        if _storage._webhookStatuses != rhs_storage._webhookStatuses {return false}
        if _storage._webhookPayloads != rhs_storage._webhookPayloads {return false}
        if _storage._currentPage != rhs_storage._currentPage {return false}
        if _storage._intent != rhs_storage._intent {return false}
        if _storage._intentDetectionConfidence != rhs_storage._intentDetectionConfidence {return false}
        if _storage._match != rhs_storage._match {return false}
        if _storage._diagnosticInfo != rhs_storage._diagnosticInfo {return false}
        if _storage._sentimentAnalysisResult != rhs_storage._sentimentAnalysisResult {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_TextInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_TextInput, rhs: Google_Cloud_Dialogflow_Cx_V3_TextInput) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_IntentInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntentInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "intent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.intent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.intent.isEmpty {
      try visitor.visitSingularStringField(value: self.intent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_IntentInput, rhs: Google_Cloud_Dialogflow_Cx_V3_IntentInput) -> Bool {
    if lhs.intent != rhs.intent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_AudioInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
    2: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.audio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.audio.isEmpty {
      try visitor.visitSingularBytesField(value: self.audio, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_AudioInput, rhs: Google_Cloud_Dialogflow_Cx_V3_AudioInput) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.audio != rhs.audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_EventInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.event.isEmpty {
      try visitor.visitSingularStringField(value: self.event, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_EventInput, rhs: Google_Cloud_Dialogflow_Cx_V3_EventInput) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_DtmfInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DtmfInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digits"),
    2: .standard(proto: "finish_digit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.digits) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.finishDigit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.digits.isEmpty {
      try visitor.visitSingularStringField(value: self.digits, fieldNumber: 1)
    }
    if !self.finishDigit.isEmpty {
      try visitor.visitSingularStringField(value: self.finishDigit, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_DtmfInput, rhs: Google_Cloud_Dialogflow_Cx_V3_DtmfInput) -> Bool {
    if lhs.digits != rhs.digits {return false}
    if lhs.finishDigit != rhs.finishDigit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_Match: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Match"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "intent"),
    6: .same(proto: "event"),
    2: .same(proto: "parameters"),
    3: .standard(proto: "resolved_input"),
    4: .standard(proto: "match_type"),
    5: .same(proto: "confidence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._intent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resolvedInput) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.matchType) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.confidence) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.event) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._intent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.resolvedInput.isEmpty {
      try visitor.visitSingularStringField(value: self.resolvedInput, fieldNumber: 3)
    }
    if self.matchType != .unspecified {
      try visitor.visitSingularEnumField(value: self.matchType, fieldNumber: 4)
    }
    if self.confidence != 0 {
      try visitor.visitSingularFloatField(value: self.confidence, fieldNumber: 5)
    }
    if !self.event.isEmpty {
      try visitor.visitSingularStringField(value: self.event, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_Match, rhs: Google_Cloud_Dialogflow_Cx_V3_Match) -> Bool {
    if lhs._intent != rhs._intent {return false}
    if lhs.event != rhs.event {return false}
    if lhs._parameters != rhs._parameters {return false}
    if lhs.resolvedInput != rhs.resolvedInput {return false}
    if lhs.matchType != rhs.matchType {return false}
    if lhs.confidence != rhs.confidence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_Match.MatchType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MATCH_TYPE_UNSPECIFIED"),
    1: .same(proto: "INTENT"),
    2: .same(proto: "DIRECT_INTENT"),
    3: .same(proto: "PARAMETER_FILLING"),
    4: .same(proto: "NO_MATCH"),
    5: .same(proto: "NO_INPUT"),
    6: .same(proto: "EVENT"),
  ]
}

extension Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchIntentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "query_params"),
    3: .standard(proto: "query_input"),
  ]

  fileprivate class _StorageClass {
    var _session: String = String()
    var _queryParams: Google_Cloud_Dialogflow_Cx_V3_QueryParameters? = nil
    var _queryInput: Google_Cloud_Dialogflow_Cx_V3_QueryInput? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _session = source._session
      _queryParams = source._queryParams
      _queryInput = source._queryInput
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._session) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._queryParams) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._queryInput) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._session.isEmpty {
        try visitor.visitSingularStringField(value: _storage._session, fieldNumber: 1)
      }
      if let v = _storage._queryParams {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._queryInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest, rhs: Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._session != rhs_storage._session {return false}
        if _storage._queryParams != rhs_storage._queryParams {return false}
        if _storage._queryInput != rhs_storage._queryInput {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MatchIntentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "trigger_intent"),
    3: .same(proto: "transcript"),
    6: .standard(proto: "trigger_event"),
    4: .same(proto: "matches"),
    5: .standard(proto: "current_page"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.query != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.query = .text(v)}
      }()
      case 2: try {
        if self.query != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.query = .triggerIntent(v)}
      }()
      case 3: try {
        if self.query != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.query = .transcript(v)}
      }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.matches) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._currentPage) }()
      case 6: try {
        if self.query != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.query = .triggerEvent(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.query {
    case .text?: try {
      guard case .text(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .triggerIntent?: try {
      guard case .triggerIntent(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .transcript?: try {
      guard case .transcript(let v)? = self.query else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if !self.matches.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.matches, fieldNumber: 4)
    }
    if let v = self._currentPage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if case .triggerEvent(let v)? = self.query {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse, rhs: Google_Cloud_Dialogflow_Cx_V3_MatchIntentResponse) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.matches != rhs.matches {return false}
    if lhs._currentPage != rhs._currentPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_FulfillIntentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FulfillIntentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "match_intent_request"),
    2: .same(proto: "match"),
    3: .standard(proto: "output_audio_config"),
  ]

  fileprivate class _StorageClass {
    var _matchIntentRequest: Google_Cloud_Dialogflow_Cx_V3_MatchIntentRequest? = nil
    var _match: Google_Cloud_Dialogflow_Cx_V3_Match? = nil
    var _outputAudioConfig: Google_Cloud_Dialogflow_Cx_V3_OutputAudioConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _matchIntentRequest = source._matchIntentRequest
      _match = source._match
      _outputAudioConfig = source._outputAudioConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._matchIntentRequest) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._match) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._outputAudioConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._matchIntentRequest {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._match {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._outputAudioConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_FulfillIntentRequest, rhs: Google_Cloud_Dialogflow_Cx_V3_FulfillIntentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._matchIntentRequest != rhs_storage._matchIntentRequest {return false}
        if _storage._match != rhs_storage._match {return false}
        if _storage._outputAudioConfig != rhs_storage._outputAudioConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_FulfillIntentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FulfillIntentResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "response_id"),
    2: .standard(proto: "query_result"),
    3: .standard(proto: "output_audio"),
    4: .standard(proto: "output_audio_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.responseID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._queryResult) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.outputAudio) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outputAudioConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responseID.isEmpty {
      try visitor.visitSingularStringField(value: self.responseID, fieldNumber: 1)
    }
    if let v = self._queryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.outputAudio.isEmpty {
      try visitor.visitSingularBytesField(value: self.outputAudio, fieldNumber: 3)
    }
    if let v = self._outputAudioConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_FulfillIntentResponse, rhs: Google_Cloud_Dialogflow_Cx_V3_FulfillIntentResponse) -> Bool {
    if lhs.responseID != rhs.responseID {return false}
    if lhs._queryResult != rhs._queryResult {return false}
    if lhs.outputAudio != rhs.outputAudio {return false}
    if lhs._outputAudioConfig != rhs._outputAudioConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SentimentAnalysisResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .same(proto: "magnitude"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.magnitude) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 1)
    }
    if self.magnitude != 0 {
      try visitor.visitSingularFloatField(value: self.magnitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult, rhs: Google_Cloud_Dialogflow_Cx_V3_SentimentAnalysisResult) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.magnitude != rhs.magnitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/dialogflow/v2beta1/document.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A knowledge document to be used by a [KnowledgeBase][google.cloud.dialogflow.v2beta1.KnowledgeBase].
///
/// For more information, see the [knowledge base
/// guide](https://cloud.google.com/dialogflow/docs/how/knowledge-bases).
///
/// Note: The `projects.agent.knowledgeBases.documents` resource is deprecated;
/// only use `projects.knowledgeBases.documents`.
public struct Google_Cloud_Dialogflow_V2beta1_Document {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The document resource name.
  /// The name must be empty when creating a document.
  /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
  /// ID>/documents/<Document ID>`.
  public var name: String = String()

  /// Required. The display name of the document. The name must be 1024 bytes or
  /// less; otherwise, the creation request fails.
  public var displayName: String = String()

  /// Required. The MIME type of this document.
  public var mimeType: String = String()

  /// Required. The knowledge type of document content.
  public var knowledgeTypes: [Google_Cloud_Dialogflow_V2beta1_Document.KnowledgeType] = []

  /// The source of this document.
  public var source: Google_Cloud_Dialogflow_V2beta1_Document.OneOf_Source? = nil

  /// The URI where the file content is located.
  ///
  /// For documents stored in Google Cloud Storage, these URIs must have
  /// the form `gs://<bucket-name>/<object-name>`.
  ///
  /// NOTE: External URLs must correspond to public webpages, i.e., they must
  /// be indexed by Google Search. In particular, URLs for showing documents in
  /// Google Cloud Storage (i.e. the URL in your browser) are not supported.
  /// Instead use the `gs://` format URI described above.
  public var contentUri: String {
    get {
      if case .contentUri(let v)? = source {return v}
      return String()
    }
    set {source = .contentUri(newValue)}
  }

  /// The raw content of the document. This field is only permitted for
  /// EXTRACTIVE_QA and FAQ knowledge types.
  /// Note: This field is in the process of being deprecated, please use
  /// raw_content instead.
  public var content: String {
    get {
      if case .content(let v)? = source {return v}
      return String()
    }
    set {source = .content(newValue)}
  }

  /// The raw content of the document. This field is only permitted for
  /// EXTRACTIVE_QA and FAQ knowledge types.
  public var rawContent: Data {
    get {
      if case .rawContent(let v)? = source {return v}
      return Data()
    }
    set {source = .rawContent(newValue)}
  }

  /// Optional. If true, we try to automatically reload the document every day
  /// (at a time picked by the system). If false or unspecified, we don't try
  /// to automatically reload the document.
  ///
  /// Currently you can only enable automatic reload for documents sourced from
  /// a public url, see `source` field for the source types.
  ///
  /// Reload status can be tracked in `latest_reload_status`. If a reload
  /// fails, we will keep the document unchanged.
  ///
  /// If a reload fails with internal errors, the system will try to reload the
  /// document on the next day.
  /// If a reload fails with non-retriable errors (e.g. PERMISION_DENIED), the
  /// system will not try to reload the document anymore. You need to manually
  /// reload the document successfully by calling `ReloadDocument` and clear the
  /// errors.
  public var enableAutoReload: Bool = false

  /// Output only. The time and status of the latest reload.
  /// This reload may have been triggered automatically or manually
  /// and may not have succeeded.
  public var latestReloadStatus: Google_Cloud_Dialogflow_V2beta1_Document.ReloadStatus {
    get {return _latestReloadStatus ?? Google_Cloud_Dialogflow_V2beta1_Document.ReloadStatus()}
    set {_latestReloadStatus = newValue}
  }
  /// Returns true if `latestReloadStatus` has been explicitly set.
  public var hasLatestReloadStatus: Bool {return self._latestReloadStatus != nil}
  /// Clears the value of `latestReloadStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLatestReloadStatus() {self._latestReloadStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The source of this document.
  public enum OneOf_Source: Equatable {
    /// The URI where the file content is located.
    ///
    /// For documents stored in Google Cloud Storage, these URIs must have
    /// the form `gs://<bucket-name>/<object-name>`.
    ///
    /// NOTE: External URLs must correspond to public webpages, i.e., they must
    /// be indexed by Google Search. In particular, URLs for showing documents in
    /// Google Cloud Storage (i.e. the URL in your browser) are not supported.
    /// Instead use the `gs://` format URI described above.
    case contentUri(String)
    /// The raw content of the document. This field is only permitted for
    /// EXTRACTIVE_QA and FAQ knowledge types.
    /// Note: This field is in the process of being deprecated, please use
    /// raw_content instead.
    case content(String)
    /// The raw content of the document. This field is only permitted for
    /// EXTRACTIVE_QA and FAQ knowledge types.
    case rawContent(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_Document.OneOf_Source, rhs: Google_Cloud_Dialogflow_V2beta1_Document.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.contentUri, .contentUri): return {
        guard case .contentUri(let l) = lhs, case .contentUri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.content, .content): return {
        guard case .content(let l) = lhs, case .content(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rawContent, .rawContent): return {
        guard case .rawContent(let l) = lhs, case .rawContent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The knowledge type of document content.
  public enum KnowledgeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The type is unspecified or arbitrary.
    case unspecified // = 0

    /// The document content contains question and answer pairs as either HTML or
    /// CSV. Typical FAQ HTML formats are parsed accurately, but unusual formats
    /// may fail to be parsed.
    ///
    /// CSV must have questions in the first column and answers in the second,
    /// with no header. Because of this explicit format, they are always parsed
    /// accurately.
    case faq // = 1

    /// Documents for which unstructured text is extracted and used for
    /// question answering.
    case extractiveQa // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .faq
      case 2: self = .extractiveQa
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .faq: return 1
      case .extractiveQa: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The status of a reload attempt.
  public struct ReloadStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. The time of a reload attempt.
    /// This reload may have been triggered automatically or manually and may
    /// not have succeeded.
    public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {self._time = nil}

    /// Output only. The status of a reload attempt or the initial load.
    public var status: Google_Rpc_Status {
      get {return _status ?? Google_Rpc_Status()}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _status: Google_Rpc_Status? = nil
  }

  public init() {}

  fileprivate var _latestReloadStatus: Google_Cloud_Dialogflow_V2beta1_Document.ReloadStatus? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Dialogflow_V2beta1_Document.KnowledgeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Dialogflow_V2beta1_Document.KnowledgeType] = [
    .unspecified,
    .faq,
    .extractiveQa,
  ]
}

#endif  // swift(>=4.2)

/// Request message for [Documents.GetDocument][google.cloud.dialogflow.v2beta1.Documents.GetDocument].
public struct Google_Cloud_Dialogflow_V2beta1_GetDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the document to retrieve.
  /// Format `projects/<Project ID>/knowledgeBases/<Knowledge Base
  /// ID>/documents/<Document ID>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [Documents.ListDocuments][google.cloud.dialogflow.v2beta1.Documents.ListDocuments].
public struct Google_Cloud_Dialogflow_V2beta1_ListDocumentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The knowledge base to list all documents for.
  /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
  public var parent: String = String()

  /// The maximum number of items to return in a single page. By
  /// default 10 and at most 100.
  public var pageSize: Int32 = 0

  /// The next_page_token value returned from a previous list request.
  public var pageToken: String = String()

  /// The filter expression used to filter documents returned by the list method.
  /// The expression has the following syntax:
  ///
  ///   <field> <operator> <value> [AND <field> <operator> <value>] ...
  ///
  /// The following fields and operators are supported:
  ///
  /// * knowledge_types with has(:) operator
  /// * display_name with has(:) operator
  /// * state with equals(=) operator
  ///
  /// Examples:
  ///
  /// * "knowledge_types:FAQ" matches documents with FAQ knowledge type.
  /// * "display_name:customer" matches documents whose display name contains
  ///   "customer".
  /// * "state=ACTIVE" matches documents with ACTIVE state.
  /// * "knowledge_types:FAQ AND state=ACTIVE" matches all active FAQ documents.
  ///
  /// For more information about filtering, see
  /// [API Filtering](https://aip.dev/160).
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [Documents.ListDocuments][google.cloud.dialogflow.v2beta1.Documents.ListDocuments].
public struct Google_Cloud_Dialogflow_V2beta1_ListDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of documents.
  public var documents: [Google_Cloud_Dialogflow_V2beta1_Document] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [Documents.CreateDocument][google.cloud.dialogflow.v2beta1.Documents.CreateDocument].
public struct Google_Cloud_Dialogflow_V2beta1_CreateDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The knowledge base to create a document for.
  /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base ID>`.
  public var parent: String = String()

  /// Required. The document to create.
  public var document: Google_Cloud_Dialogflow_V2beta1_Document {
    get {return _document ?? Google_Cloud_Dialogflow_V2beta1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Cloud_Dialogflow_V2beta1_Document? = nil
}

/// Request message for [Documents.DeleteDocument][google.cloud.dialogflow.v2beta1.Documents.DeleteDocument].
public struct Google_Cloud_Dialogflow_V2beta1_DeleteDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the document to delete.
  /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
  /// ID>/documents/<Document ID>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [Documents.UpdateDocument][google.cloud.dialogflow.v2beta1.Documents.UpdateDocument].
public struct Google_Cloud_Dialogflow_V2beta1_UpdateDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The document to update.
  public var document: Google_Cloud_Dialogflow_V2beta1_Document {
    get {return _document ?? Google_Cloud_Dialogflow_V2beta1_Document()}
    set {_document = newValue}
  }
  /// Returns true if `document` has been explicitly set.
  public var hasDocument: Bool {return self._document != nil}
  /// Clears the value of `document`. Subsequent reads from it will return its default value.
  public mutating func clearDocument() {self._document = nil}

  /// Optional. Not specified means `update all`.
  /// Currently, only `display_name` can be updated, an InvalidArgument will be
  /// returned for attempting to update other fields.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _document: Google_Cloud_Dialogflow_V2beta1_Document? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Metadata in google::longrunning::Operation for Knowledge operations.
public struct Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Output only. The current state of this operation.
  public var state: Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata.State = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// States of the operation.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// State unspecified.
    case unspecified // = 0

    /// The operation has been created.
    case pending // = 1

    /// The operation is currently running.
    case running // = 2

    /// The operation is done, either cancelled or completed.
    case done // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .running
      case 3: self = .done
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .running: return 2
      case .done: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata.State] = [
    .unspecified,
    .pending,
    .running,
    .done,
  ]
}

#endif  // swift(>=4.2)

/// Request message for [Documents.ReloadDocument][google.cloud.dialogflow.v2beta1.Documents.ReloadDocument].
public struct Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the document to reload.
  /// Format: `projects/<Project ID>/knowledgeBases/<Knowledge Base
  /// ID>/documents/<Document ID>`
  public var name: String = String()

  /// The source for document reloading.
  /// Optional. If provided, the service will load the contents from the source
  /// and update document in the knowledge base.
  public var source: Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest.OneOf_Source? = nil

  /// The path for a Cloud Storage source file for reloading document content.
  /// If not provided, the Document's existing source will be reloaded.
  public var gcsSource: Google_Cloud_Dialogflow_V2beta1_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Dialogflow_V2beta1_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The source for document reloading.
  /// Optional. If provided, the service will load the contents from the source
  /// and update document in the knowledge base.
  public enum OneOf_Source: Equatable {
    /// The path for a Cloud Storage source file for reloading document content.
    /// If not provided, the Document's existing source will be reloaded.
    case gcsSource(Google_Cloud_Dialogflow_V2beta1_GcsSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest.OneOf_Source, rhs: Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsSource, .gcsSource): return {
        guard case .gcsSource(let l) = lhs, case .gcsSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.dialogflow.v2beta1"

extension Google_Cloud_Dialogflow_V2beta1_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Document"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "mime_type"),
    4: .standard(proto: "knowledge_types"),
    5: .standard(proto: "content_uri"),
    6: .same(proto: "content"),
    9: .standard(proto: "raw_content"),
    11: .standard(proto: "enable_auto_reload"),
    12: .standard(proto: "latest_reload_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeRepeatedEnumField(value: &self.knowledgeTypes) }()
      case 5: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .contentUri(v)}
      }()
      case 6: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .content(v)}
      }()
      case 9: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.source = .rawContent(v)}
      }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.enableAutoReload) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._latestReloadStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    if !self.knowledgeTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.knowledgeTypes, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .contentUri?: try {
      guard case .contentUri(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .content?: try {
      guard case .content(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .rawContent?: try {
      guard case .rawContent(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    if self.enableAutoReload != false {
      try visitor.visitSingularBoolField(value: self.enableAutoReload, fieldNumber: 11)
    }
    if let v = self._latestReloadStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_Document, rhs: Google_Cloud_Dialogflow_V2beta1_Document) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.knowledgeTypes != rhs.knowledgeTypes {return false}
    if lhs.source != rhs.source {return false}
    if lhs.enableAutoReload != rhs.enableAutoReload {return false}
    if lhs._latestReloadStatus != rhs._latestReloadStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_Document.KnowledgeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KNOWLEDGE_TYPE_UNSPECIFIED"),
    1: .same(proto: "FAQ"),
    2: .same(proto: "EXTRACTIVE_QA"),
  ]
}

extension Google_Cloud_Dialogflow_V2beta1_Document.ReloadStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Dialogflow_V2beta1_Document.protoMessageName + ".ReloadStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_Document.ReloadStatus, rhs: Google_Cloud_Dialogflow_V2beta1_Document.ReloadStatus) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_GetDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_GetDocumentRequest, rhs: Google_Cloud_Dialogflow_V2beta1_GetDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_ListDocumentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDocumentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_ListDocumentsRequest, rhs: Google_Cloud_Dialogflow_V2beta1_ListDocumentsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_ListDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDocumentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documents"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.documents) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.documents, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_ListDocumentsResponse, rhs: Google_Cloud_Dialogflow_V2beta1_ListDocumentsResponse) -> Bool {
    if lhs.documents != rhs.documents {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_CreateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "document"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_CreateDocumentRequest, rhs: Google_Cloud_Dialogflow_V2beta1_CreateDocumentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._document != rhs._document {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_DeleteDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_DeleteDocumentRequest, rhs: Google_Cloud_Dialogflow_V2beta1_DeleteDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_UpdateDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "document"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._document) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._document {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_UpdateDocumentRequest, rhs: Google_Cloud_Dialogflow_V2beta1_UpdateDocumentRequest) -> Bool {
    if lhs._document != rhs._document {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KnowledgeOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata, rhs: Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Dialogflow_V2beta1_KnowledgeOperationMetadata.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "DONE"),
  ]
}

extension Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReloadDocumentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "gcs_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try {
        var v: Google_Cloud_Dialogflow_V2beta1_GcsSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .gcsSource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .gcsSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest, rhs: Google_Cloud_Dialogflow_V2beta1_ReloadDocumentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

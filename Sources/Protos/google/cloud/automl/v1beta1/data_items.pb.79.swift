// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/automl/v1beta1/data_items.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A representation of an image.
/// Only images up to 30MB in size are supported.
public struct Google_Cloud_Automl_V1beta1_Image {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input only. The data representing the image.
  /// For Predict calls [image_bytes][google.cloud.automl.v1beta1.Image.image_bytes] must be set, as other options are not
  /// currently supported by prediction API. You can read the contents of an
  /// uploaded image by using the [content_uri][google.cloud.automl.v1beta1.Image.content_uri] field.
  public var data: Google_Cloud_Automl_V1beta1_Image.OneOf_Data? = nil

  /// Image content represented as a stream of bytes.
  /// Note: As with all `bytes` fields, protobuffers use a pure binary
  /// representation, whereas JSON representations use base64.
  public var imageBytes: Data {
    get {
      if case .imageBytes(let v)? = data {return v}
      return Data()
    }
    set {data = .imageBytes(newValue)}
  }

  /// An input config specifying the content of the image.
  public var inputConfig: Google_Cloud_Automl_V1beta1_InputConfig {
    get {
      if case .inputConfig(let v)? = data {return v}
      return Google_Cloud_Automl_V1beta1_InputConfig()
    }
    set {data = .inputConfig(newValue)}
  }

  /// Output only. HTTP URI to the thumbnail image.
  public var thumbnailUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Input only. The data representing the image.
  /// For Predict calls [image_bytes][google.cloud.automl.v1beta1.Image.image_bytes] must be set, as other options are not
  /// currently supported by prediction API. You can read the contents of an
  /// uploaded image by using the [content_uri][google.cloud.automl.v1beta1.Image.content_uri] field.
  public enum OneOf_Data: Equatable {
    /// Image content represented as a stream of bytes.
    /// Note: As with all `bytes` fields, protobuffers use a pure binary
    /// representation, whereas JSON representations use base64.
    case imageBytes(Data)
    /// An input config specifying the content of the image.
    case inputConfig(Google_Cloud_Automl_V1beta1_InputConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Automl_V1beta1_Image.OneOf_Data, rhs: Google_Cloud_Automl_V1beta1_Image.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.imageBytes, .imageBytes): return {
        guard case .imageBytes(let l) = lhs, case .imageBytes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.inputConfig, .inputConfig): return {
        guard case .inputConfig(let l) = lhs, case .inputConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A representation of a text snippet.
public struct Google_Cloud_Automl_V1beta1_TextSnippet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The content of the text snippet as a string. Up to 250000
  /// characters long.
  public var content: String = String()

  /// Optional. The format of [content][google.cloud.automl.v1beta1.TextSnippet.content]. Currently the only two allowed
  /// values are "text/html" and "text/plain". If left blank, the format is
  /// automatically determined from the type of the uploaded [content][google.cloud.automl.v1beta1.TextSnippet.content].
  public var mimeType: String = String()

  /// Output only. HTTP URI where you can download the content.
  public var contentUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message that describes dimension of a document.
public struct Google_Cloud_Automl_V1beta1_DocumentDimensions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unit of the dimension.
  public var unit: Google_Cloud_Automl_V1beta1_DocumentDimensions.DocumentDimensionUnit = .unspecified

  /// Width value of the document, works together with the unit.
  public var width: Float = 0

  /// Height value of the document, works together with the unit.
  public var height: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Unit of the document dimension.
  public enum DocumentDimensionUnit: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Should not be used.
    case unspecified // = 0

    /// Document dimension is measured in inches.
    case inch // = 1

    /// Document dimension is measured in centimeters.
    case centimeter // = 2

    /// Document dimension is measured in points. 72 points = 1 inch.
    case point // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .inch
      case 2: self = .centimeter
      case 3: self = .point
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .inch: return 1
      case .centimeter: return 2
      case .point: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Automl_V1beta1_DocumentDimensions.DocumentDimensionUnit: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Automl_V1beta1_DocumentDimensions.DocumentDimensionUnit] = [
    .unspecified,
    .inch,
    .centimeter,
    .point,
  ]
}

#endif  // swift(>=4.2)

/// A structured text document e.g. a PDF.
public struct Google_Cloud_Automl_V1beta1_Document {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An input config specifying the content of the document.
  public var inputConfig: Google_Cloud_Automl_V1beta1_DocumentInputConfig {
    get {return _inputConfig ?? Google_Cloud_Automl_V1beta1_DocumentInputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  public var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInputConfig() {self._inputConfig = nil}

  /// The plain text version of this document.
  public var documentText: Google_Cloud_Automl_V1beta1_TextSnippet {
    get {return _documentText ?? Google_Cloud_Automl_V1beta1_TextSnippet()}
    set {_documentText = newValue}
  }
  /// Returns true if `documentText` has been explicitly set.
  public var hasDocumentText: Bool {return self._documentText != nil}
  /// Clears the value of `documentText`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentText() {self._documentText = nil}

  /// Describes the layout of the document.
  /// Sorted by [page_number][].
  public var layout: [Google_Cloud_Automl_V1beta1_Document.Layout] = []

  /// The dimensions of the page in the document.
  public var documentDimensions: Google_Cloud_Automl_V1beta1_DocumentDimensions {
    get {return _documentDimensions ?? Google_Cloud_Automl_V1beta1_DocumentDimensions()}
    set {_documentDimensions = newValue}
  }
  /// Returns true if `documentDimensions` has been explicitly set.
  public var hasDocumentDimensions: Bool {return self._documentDimensions != nil}
  /// Clears the value of `documentDimensions`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentDimensions() {self._documentDimensions = nil}

  /// Number of pages in the document.
  public var pageCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the layout information of a [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in the document.
  public struct Layout {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Text Segment that represents a segment in
    /// [document_text][google.cloud.automl.v1beta1.Document.document_text].
    public var textSegment: Google_Cloud_Automl_V1beta1_TextSegment {
      get {return _textSegment ?? Google_Cloud_Automl_V1beta1_TextSegment()}
      set {_textSegment = newValue}
    }
    /// Returns true if `textSegment` has been explicitly set.
    public var hasTextSegment: Bool {return self._textSegment != nil}
    /// Clears the value of `textSegment`. Subsequent reads from it will return its default value.
    public mutating func clearTextSegment() {self._textSegment = nil}

    /// Page number of the [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in the original document, starts
    /// from 1.
    public var pageNumber: Int32 = 0

    /// The position of the [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in the page.
    /// Contains exactly 4
    ///
    /// [normalized_vertices][google.cloud.automl.v1beta1.BoundingPoly.normalized_vertices]
    /// and they are connected by edges in the order provided, which will
    /// represent a rectangle parallel to the frame. The
    /// [NormalizedVertex-s][google.cloud.automl.v1beta1.NormalizedVertex] are
    /// relative to the page.
    /// Coordinates are based on top-left as point (0,0).
    public var boundingPoly: Google_Cloud_Automl_V1beta1_BoundingPoly {
      get {return _boundingPoly ?? Google_Cloud_Automl_V1beta1_BoundingPoly()}
      set {_boundingPoly = newValue}
    }
    /// Returns true if `boundingPoly` has been explicitly set.
    public var hasBoundingPoly: Bool {return self._boundingPoly != nil}
    /// Clears the value of `boundingPoly`. Subsequent reads from it will return its default value.
    public mutating func clearBoundingPoly() {self._boundingPoly = nil}

    /// The type of the [text_segment][google.cloud.automl.v1beta1.Document.Layout.text_segment] in document.
    public var textSegmentType: Google_Cloud_Automl_V1beta1_Document.Layout.TextSegmentType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The type of TextSegment in the context of the original document.
    public enum TextSegmentType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Should not be used.
      case unspecified // = 0

      /// The text segment is a token. e.g. word.
      case token // = 1

      /// The text segment is a paragraph.
      case paragraph // = 2

      /// The text segment is a form field.
      case formField // = 3

      /// The text segment is the name part of a form field. It will be treated
      /// as child of another FORM_FIELD TextSegment if its span is subspan of
      /// another TextSegment with type FORM_FIELD.
      case formFieldName // = 4

      /// The text segment is the text content part of a form field. It will be
      /// treated as child of another FORM_FIELD TextSegment if its span is
      /// subspan of another TextSegment with type FORM_FIELD.
      case formFieldContents // = 5

      /// The text segment is a whole table, including headers, and all rows.
      case table // = 6

      /// The text segment is a table's headers. It will be treated as child of
      /// another TABLE TextSegment if its span is subspan of another TextSegment
      /// with type TABLE.
      case tableHeader // = 7

      /// The text segment is a row in table. It will be treated as child of
      /// another TABLE TextSegment if its span is subspan of another TextSegment
      /// with type TABLE.
      case tableRow // = 8

      /// The text segment is a cell in table. It will be treated as child of
      /// another TABLE_ROW TextSegment if its span is subspan of another
      /// TextSegment with type TABLE_ROW.
      case tableCell // = 9
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .token
        case 2: self = .paragraph
        case 3: self = .formField
        case 4: self = .formFieldName
        case 5: self = .formFieldContents
        case 6: self = .table
        case 7: self = .tableHeader
        case 8: self = .tableRow
        case 9: self = .tableCell
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .token: return 1
        case .paragraph: return 2
        case .formField: return 3
        case .formFieldName: return 4
        case .formFieldContents: return 5
        case .table: return 6
        case .tableHeader: return 7
        case .tableRow: return 8
        case .tableCell: return 9
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _textSegment: Google_Cloud_Automl_V1beta1_TextSegment? = nil
    fileprivate var _boundingPoly: Google_Cloud_Automl_V1beta1_BoundingPoly? = nil
  }

  public init() {}

  fileprivate var _inputConfig: Google_Cloud_Automl_V1beta1_DocumentInputConfig? = nil
  fileprivate var _documentText: Google_Cloud_Automl_V1beta1_TextSnippet? = nil
  fileprivate var _documentDimensions: Google_Cloud_Automl_V1beta1_DocumentDimensions? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Automl_V1beta1_Document.Layout.TextSegmentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Automl_V1beta1_Document.Layout.TextSegmentType] = [
    .unspecified,
    .token,
    .paragraph,
    .formField,
    .formFieldName,
    .formFieldContents,
    .table,
    .tableHeader,
    .tableRow,
    .tableCell,
  ]
}

#endif  // swift(>=4.2)

/// A representation of a row in a relational table.
public struct Google_Cloud_Automl_V1beta1_Row {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource IDs of the column specs describing the columns of the row.
  /// If set must contain, but possibly in a different order, all input
  /// feature
  ///
  /// [column_spec_ids][google.cloud.automl.v1beta1.TablesModelMetadata.input_feature_column_specs]
  /// of the Model this row is being passed to.
  /// Note: The below `values` field must match order of this field, if this
  /// field is set.
  public var columnSpecIds: [String] = []

  /// Required. The values of the row cells, given in the same order as the
  /// column_spec_ids, or, if not set, then in the same order as input
  /// feature
  ///
  /// [column_specs][google.cloud.automl.v1beta1.TablesModelMetadata.input_feature_column_specs]
  /// of the Model this row is being passed to.
  public var values: [SwiftProtobuf.Google_Protobuf_Value] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Example data used for training or prediction.
public struct Google_Cloud_Automl_V1beta1_ExamplePayload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Input only. The example data.
  public var payload: Google_Cloud_Automl_V1beta1_ExamplePayload.OneOf_Payload? = nil

  /// Example image.
  public var image: Google_Cloud_Automl_V1beta1_Image {
    get {
      if case .image(let v)? = payload {return v}
      return Google_Cloud_Automl_V1beta1_Image()
    }
    set {payload = .image(newValue)}
  }

  /// Example text.
  public var textSnippet: Google_Cloud_Automl_V1beta1_TextSnippet {
    get {
      if case .textSnippet(let v)? = payload {return v}
      return Google_Cloud_Automl_V1beta1_TextSnippet()
    }
    set {payload = .textSnippet(newValue)}
  }

  /// Example document.
  public var document: Google_Cloud_Automl_V1beta1_Document {
    get {
      if case .document(let v)? = payload {return v}
      return Google_Cloud_Automl_V1beta1_Document()
    }
    set {payload = .document(newValue)}
  }

  /// Example relational table row.
  public var row: Google_Cloud_Automl_V1beta1_Row {
    get {
      if case .row(let v)? = payload {return v}
      return Google_Cloud_Automl_V1beta1_Row()
    }
    set {payload = .row(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Input only. The example data.
  public enum OneOf_Payload: Equatable {
    /// Example image.
    case image(Google_Cloud_Automl_V1beta1_Image)
    /// Example text.
    case textSnippet(Google_Cloud_Automl_V1beta1_TextSnippet)
    /// Example document.
    case document(Google_Cloud_Automl_V1beta1_Document)
    /// Example relational table row.
    case row(Google_Cloud_Automl_V1beta1_Row)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Automl_V1beta1_ExamplePayload.OneOf_Payload, rhs: Google_Cloud_Automl_V1beta1_ExamplePayload.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textSnippet, .textSnippet): return {
        guard case .textSnippet(let l) = lhs, case .textSnippet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.document, .document): return {
        guard case .document(let l) = lhs, case .document(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.row, .row): return {
        guard case .row(let l) = lhs, case .row(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.automl.v1beta1"

extension Google_Cloud_Automl_V1beta1_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Image"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_bytes"),
    6: .standard(proto: "input_config"),
    4: .standard(proto: "thumbnail_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.data != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.data = .imageBytes(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.thumbnailUri) }()
      case 6: try {
        var v: Google_Cloud_Automl_V1beta1_InputConfig?
        if let current = self.data {
          try decoder.handleConflictingOneOf()
          if case .inputConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.data = .inputConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .imageBytes(let v)? = self.data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if !self.thumbnailUri.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailUri, fieldNumber: 4)
    }
    if case .inputConfig(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_Image, rhs: Google_Cloud_Automl_V1beta1_Image) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.thumbnailUri != rhs.thumbnailUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_TextSnippet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextSnippet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .standard(proto: "mime_type"),
    4: .standard(proto: "content_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.contentUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if !self.contentUri.isEmpty {
      try visitor.visitSingularStringField(value: self.contentUri, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_TextSnippet, rhs: Google_Cloud_Automl_V1beta1_TextSnippet) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.contentUri != rhs.contentUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_DocumentDimensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DocumentDimensions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unit"),
    2: .same(proto: "width"),
    3: .same(proto: "height"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.unit) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.width) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unit != .unspecified {
      try visitor.visitSingularEnumField(value: self.unit, fieldNumber: 1)
    }
    if self.width != 0 {
      try visitor.visitSingularFloatField(value: self.width, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularFloatField(value: self.height, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_DocumentDimensions, rhs: Google_Cloud_Automl_V1beta1_DocumentDimensions) -> Bool {
    if lhs.unit != rhs.unit {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_DocumentDimensions.DocumentDimensionUnit: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DOCUMENT_DIMENSION_UNIT_UNSPECIFIED"),
    1: .same(proto: "INCH"),
    2: .same(proto: "CENTIMETER"),
    3: .same(proto: "POINT"),
  ]
}

extension Google_Cloud_Automl_V1beta1_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Document"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_config"),
    2: .standard(proto: "document_text"),
    3: .same(proto: "layout"),
    4: .standard(proto: "document_dimensions"),
    5: .standard(proto: "page_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._documentText) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._documentDimensions) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._documentText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.layout.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layout, fieldNumber: 3)
    }
    if let v = self._documentDimensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.pageCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pageCount, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_Document, rhs: Google_Cloud_Automl_V1beta1_Document) -> Bool {
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs._documentText != rhs._documentText {return false}
    if lhs.layout != rhs.layout {return false}
    if lhs._documentDimensions != rhs._documentDimensions {return false}
    if lhs.pageCount != rhs.pageCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_Document.Layout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Automl_V1beta1_Document.protoMessageName + ".Layout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "text_segment"),
    2: .standard(proto: "page_number"),
    3: .standard(proto: "bounding_poly"),
    4: .standard(proto: "text_segment_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._textSegment) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageNumber) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._boundingPoly) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.textSegmentType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._textSegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.pageNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.pageNumber, fieldNumber: 2)
    }
    if let v = self._boundingPoly {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.textSegmentType != .unspecified {
      try visitor.visitSingularEnumField(value: self.textSegmentType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_Document.Layout, rhs: Google_Cloud_Automl_V1beta1_Document.Layout) -> Bool {
    if lhs._textSegment != rhs._textSegment {return false}
    if lhs.pageNumber != rhs.pageNumber {return false}
    if lhs._boundingPoly != rhs._boundingPoly {return false}
    if lhs.textSegmentType != rhs.textSegmentType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_Document.Layout.TextSegmentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_SEGMENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "TOKEN"),
    2: .same(proto: "PARAGRAPH"),
    3: .same(proto: "FORM_FIELD"),
    4: .same(proto: "FORM_FIELD_NAME"),
    5: .same(proto: "FORM_FIELD_CONTENTS"),
    6: .same(proto: "TABLE"),
    7: .same(proto: "TABLE_HEADER"),
    8: .same(proto: "TABLE_ROW"),
    9: .same(proto: "TABLE_CELL"),
  ]
}

extension Google_Cloud_Automl_V1beta1_Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Row"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "column_spec_ids"),
    3: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.columnSpecIds) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.columnSpecIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.columnSpecIds, fieldNumber: 2)
    }
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_Row, rhs: Google_Cloud_Automl_V1beta1_Row) -> Bool {
    if lhs.columnSpecIds != rhs.columnSpecIds {return false}
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_ExamplePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExamplePayload"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .standard(proto: "text_snippet"),
    4: .same(proto: "document"),
    3: .same(proto: "row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Automl_V1beta1_Image?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .image(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Automl_V1beta1_TextSnippet?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .textSnippet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .textSnippet(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Automl_V1beta1_Row?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .row(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .row(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Automl_V1beta1_Document?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .document(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .document(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .image?: try {
      guard case .image(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .textSnippet?: try {
      guard case .textSnippet(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .row?: try {
      guard case .row(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .document?: try {
      guard case .document(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_ExamplePayload, rhs: Google_Cloud_Automl_V1beta1_ExamplePayload) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

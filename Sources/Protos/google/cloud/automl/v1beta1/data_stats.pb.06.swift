// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/automl/v1beta1/data_stats.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The data statistics of a series of values that share the same DataType.
public struct Google_Cloud_Automl_V1beta1_DataStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The data statistics specific to a DataType.
  public var stats: OneOf_Stats? {
    get {return _storage._stats}
    set {_uniqueStorage()._stats = newValue}
  }

  /// The statistics for FLOAT64 DataType.
  public var float64Stats: Google_Cloud_Automl_V1beta1_Float64Stats {
    get {
      if case .float64Stats(let v)? = _storage._stats {return v}
      return Google_Cloud_Automl_V1beta1_Float64Stats()
    }
    set {_uniqueStorage()._stats = .float64Stats(newValue)}
  }

  /// The statistics for STRING DataType.
  public var stringStats: Google_Cloud_Automl_V1beta1_StringStats {
    get {
      if case .stringStats(let v)? = _storage._stats {return v}
      return Google_Cloud_Automl_V1beta1_StringStats()
    }
    set {_uniqueStorage()._stats = .stringStats(newValue)}
  }

  /// The statistics for TIMESTAMP DataType.
  public var timestampStats: Google_Cloud_Automl_V1beta1_TimestampStats {
    get {
      if case .timestampStats(let v)? = _storage._stats {return v}
      return Google_Cloud_Automl_V1beta1_TimestampStats()
    }
    set {_uniqueStorage()._stats = .timestampStats(newValue)}
  }

  /// The statistics for ARRAY DataType.
  public var arrayStats: Google_Cloud_Automl_V1beta1_ArrayStats {
    get {
      if case .arrayStats(let v)? = _storage._stats {return v}
      return Google_Cloud_Automl_V1beta1_ArrayStats()
    }
    set {_uniqueStorage()._stats = .arrayStats(newValue)}
  }

  /// The statistics for STRUCT DataType.
  public var structStats: Google_Cloud_Automl_V1beta1_StructStats {
    get {
      if case .structStats(let v)? = _storage._stats {return v}
      return Google_Cloud_Automl_V1beta1_StructStats()
    }
    set {_uniqueStorage()._stats = .structStats(newValue)}
  }

  /// The statistics for CATEGORY DataType.
  public var categoryStats: Google_Cloud_Automl_V1beta1_CategoryStats {
    get {
      if case .categoryStats(let v)? = _storage._stats {return v}
      return Google_Cloud_Automl_V1beta1_CategoryStats()
    }
    set {_uniqueStorage()._stats = .categoryStats(newValue)}
  }

  /// The number of distinct values.
  public var distinctValueCount: Int64 {
    get {return _storage._distinctValueCount}
    set {_uniqueStorage()._distinctValueCount = newValue}
  }

  /// The number of values that are null.
  public var nullValueCount: Int64 {
    get {return _storage._nullValueCount}
    set {_uniqueStorage()._nullValueCount = newValue}
  }

  /// The number of values that are valid.
  public var validValueCount: Int64 {
    get {return _storage._validValueCount}
    set {_uniqueStorage()._validValueCount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The data statistics specific to a DataType.
  public enum OneOf_Stats: Equatable {
    /// The statistics for FLOAT64 DataType.
    case float64Stats(Google_Cloud_Automl_V1beta1_Float64Stats)
    /// The statistics for STRING DataType.
    case stringStats(Google_Cloud_Automl_V1beta1_StringStats)
    /// The statistics for TIMESTAMP DataType.
    case timestampStats(Google_Cloud_Automl_V1beta1_TimestampStats)
    /// The statistics for ARRAY DataType.
    case arrayStats(Google_Cloud_Automl_V1beta1_ArrayStats)
    /// The statistics for STRUCT DataType.
    case structStats(Google_Cloud_Automl_V1beta1_StructStats)
    /// The statistics for CATEGORY DataType.
    case categoryStats(Google_Cloud_Automl_V1beta1_CategoryStats)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Automl_V1beta1_DataStats.OneOf_Stats, rhs: Google_Cloud_Automl_V1beta1_DataStats.OneOf_Stats) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.float64Stats, .float64Stats): return {
        guard case .float64Stats(let l) = lhs, case .float64Stats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringStats, .stringStats): return {
        guard case .stringStats(let l) = lhs, case .stringStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestampStats, .timestampStats): return {
        guard case .timestampStats(let l) = lhs, case .timestampStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrayStats, .arrayStats): return {
        guard case .arrayStats(let l) = lhs, case .arrayStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.structStats, .structStats): return {
        guard case .structStats(let l) = lhs, case .structStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.categoryStats, .categoryStats): return {
        guard case .categoryStats(let l) = lhs, case .categoryStats(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The data statistics of a series of FLOAT64 values.
public struct Google_Cloud_Automl_V1beta1_Float64Stats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mean of the series.
  public var mean: Double = 0

  /// The standard deviation of the series.
  public var standardDeviation: Double = 0

  /// Ordered from 0 to k k-quantile values of the data series of n values.
  /// The value at index i is, approximately, the i*n/k-th smallest value in the
  /// series; for i = 0 and i = k these are, respectively, the min and max
  /// values.
  public var quantiles: [Double] = []

  /// Histogram buckets of the data series. Sorted by the min value of the
  /// bucket, ascendingly, and the number of the buckets is dynamically
  /// generated. The buckets are non-overlapping and completely cover whole
  /// FLOAT64 range with min of first bucket being `"-Infinity"`, and max of
  /// the last one being `"Infinity"`.
  public var histogramBuckets: [Google_Cloud_Automl_V1beta1_Float64Stats.HistogramBucket] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A bucket of a histogram.
  public struct HistogramBucket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The minimum value of the bucket, inclusive.
    public var min: Double = 0

    /// The maximum value of the bucket, exclusive unless max = `"Infinity"`, in
    /// which case it's inclusive.
    public var max: Double = 0

    /// The number of data values that are in the bucket, i.e. are between
    /// min and max values.
    public var count: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// The data statistics of a series of STRING values.
public struct Google_Cloud_Automl_V1beta1_StringStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The statistics of the top 20 unigrams, ordered by
  /// [count][google.cloud.automl.v1beta1.StringStats.UnigramStats.count].
  public var topUnigramStats: [Google_Cloud_Automl_V1beta1_StringStats.UnigramStats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The statistics of a unigram.
  public struct UnigramStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unigram.
    public var value: String = String()

    /// The number of occurrences of this unigram in the series.
    public var count: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// The data statistics of a series of TIMESTAMP values.
public struct Google_Cloud_Automl_V1beta1_TimestampStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The string key is the pre-defined granularity. Currently supported:
  /// hour_of_day, day_of_week, month_of_year.
  /// Granularities finer that the granularity of timestamp data are not
  /// populated (e.g. if timestamps are at day granularity, then hour_of_day
  /// is not populated).
  public var granularStats: Dictionary<String,Google_Cloud_Automl_V1beta1_TimestampStats.GranularStats> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Stats split by a defined in context granularity.
  public struct GranularStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A map from granularity key to example count for that key.
    /// E.g. for hour_of_day `13` means 1pm, or for month_of_year `5` means May).
    public var buckets: Dictionary<Int32,Int64> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// The data statistics of a series of ARRAY values.
public struct Google_Cloud_Automl_V1beta1_ArrayStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Stats of all the values of all arrays, as if they were a single long
  /// series of data. The type depends on the element type of the array.
  public var memberStats: Google_Cloud_Automl_V1beta1_DataStats {
    get {return _storage._memberStats ?? Google_Cloud_Automl_V1beta1_DataStats()}
    set {_uniqueStorage()._memberStats = newValue}
  }
  /// Returns true if `memberStats` has been explicitly set.
  public var hasMemberStats: Bool {return _storage._memberStats != nil}
  /// Clears the value of `memberStats`. Subsequent reads from it will return its default value.
  public mutating func clearMemberStats() {_uniqueStorage()._memberStats = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The data statistics of a series of STRUCT values.
public struct Google_Cloud_Automl_V1beta1_StructStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map from a field name of the struct to data stats aggregated over series
  /// of all data in that field across all the structs.
  public var fieldStats: Dictionary<String,Google_Cloud_Automl_V1beta1_DataStats> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The data statistics of a series of CATEGORY values.
public struct Google_Cloud_Automl_V1beta1_CategoryStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The statistics of the top 20 CATEGORY values, ordered by
  ///
  /// [count][google.cloud.automl.v1beta1.CategoryStats.SingleCategoryStats.count].
  public var topCategoryStats: [Google_Cloud_Automl_V1beta1_CategoryStats.SingleCategoryStats] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The statistics of a single CATEGORY value.
  public struct SingleCategoryStats {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The CATEGORY value.
    public var value: String = String()

    /// The number of occurrences of this value in the series.
    public var count: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A correlation statistics between two series of DataType values. The series
/// may have differing DataType-s, but within a single series the DataType must
/// be the same.
public struct Google_Cloud_Automl_V1beta1_CorrelationStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The correlation value using the Cramer's V measure.
  public var cramersV: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.automl.v1beta1"

extension Google_Cloud_Automl_V1beta1_DataStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "float64_stats"),
    4: .standard(proto: "string_stats"),
    5: .standard(proto: "timestamp_stats"),
    6: .standard(proto: "array_stats"),
    7: .standard(proto: "struct_stats"),
    8: .standard(proto: "category_stats"),
    1: .standard(proto: "distinct_value_count"),
    2: .standard(proto: "null_value_count"),
    9: .standard(proto: "valid_value_count"),
  ]

  fileprivate class _StorageClass {
    var _stats: Google_Cloud_Automl_V1beta1_DataStats.OneOf_Stats?
    var _distinctValueCount: Int64 = 0
    var _nullValueCount: Int64 = 0
    var _validValueCount: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _stats = source._stats
      _distinctValueCount = source._distinctValueCount
      _nullValueCount = source._nullValueCount
      _validValueCount = source._validValueCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._distinctValueCount) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._nullValueCount) }()
        case 3: try {
          var v: Google_Cloud_Automl_V1beta1_Float64Stats?
          if let current = _storage._stats {
            try decoder.handleConflictingOneOf()
            if case .float64Stats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._stats = .float64Stats(v)}
        }()
        case 4: try {
          var v: Google_Cloud_Automl_V1beta1_StringStats?
          if let current = _storage._stats {
            try decoder.handleConflictingOneOf()
            if case .stringStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._stats = .stringStats(v)}
        }()
        case 5: try {
          var v: Google_Cloud_Automl_V1beta1_TimestampStats?
          if let current = _storage._stats {
            try decoder.handleConflictingOneOf()
            if case .timestampStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._stats = .timestampStats(v)}
        }()
        case 6: try {
          var v: Google_Cloud_Automl_V1beta1_ArrayStats?
          if let current = _storage._stats {
            try decoder.handleConflictingOneOf()
            if case .arrayStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._stats = .arrayStats(v)}
        }()
        case 7: try {
          var v: Google_Cloud_Automl_V1beta1_StructStats?
          if let current = _storage._stats {
            try decoder.handleConflictingOneOf()
            if case .structStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._stats = .structStats(v)}
        }()
        case 8: try {
          var v: Google_Cloud_Automl_V1beta1_CategoryStats?
          if let current = _storage._stats {
            try decoder.handleConflictingOneOf()
            if case .categoryStats(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._stats = .categoryStats(v)}
        }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._validValueCount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._distinctValueCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._distinctValueCount, fieldNumber: 1)
      }
      if _storage._nullValueCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._nullValueCount, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._stats {
      case .float64Stats?: try {
        guard case .float64Stats(let v)? = _storage._stats else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .stringStats?: try {
        guard case .stringStats(let v)? = _storage._stats else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .timestampStats?: try {
        guard case .timestampStats(let v)? = _storage._stats else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .arrayStats?: try {
        guard case .arrayStats(let v)? = _storage._stats else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .structStats?: try {
        guard case .structStats(let v)? = _storage._stats else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .categoryStats?: try {
        guard case .categoryStats(let v)? = _storage._stats else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case nil: break
      }
      if _storage._validValueCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._validValueCount, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_DataStats, rhs: Google_Cloud_Automl_V1beta1_DataStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._stats != rhs_storage._stats {return false}
        if _storage._distinctValueCount != rhs_storage._distinctValueCount {return false}
        if _storage._nullValueCount != rhs_storage._nullValueCount {return false}
        if _storage._validValueCount != rhs_storage._validValueCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_Float64Stats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Float64Stats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mean"),
    2: .standard(proto: "standard_deviation"),
    3: .same(proto: "quantiles"),
    4: .standard(proto: "histogram_buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.mean) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.standardDeviation) }()
      case 3: try { try decoder.decodeRepeatedDoubleField(value: &self.quantiles) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.histogramBuckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mean != 0 {
      try visitor.visitSingularDoubleField(value: self.mean, fieldNumber: 1)
    }
    if self.standardDeviation != 0 {
      try visitor.visitSingularDoubleField(value: self.standardDeviation, fieldNumber: 2)
    }
    if !self.quantiles.isEmpty {
      try visitor.visitPackedDoubleField(value: self.quantiles, fieldNumber: 3)
    }
    if !self.histogramBuckets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.histogramBuckets, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_Float64Stats, rhs: Google_Cloud_Automl_V1beta1_Float64Stats) -> Bool {
    if lhs.mean != rhs.mean {return false}
    if lhs.standardDeviation != rhs.standardDeviation {return false}
    if lhs.quantiles != rhs.quantiles {return false}
    if lhs.histogramBuckets != rhs.histogramBuckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_Float64Stats.HistogramBucket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Automl_V1beta1_Float64Stats.protoMessageName + ".HistogramBucket"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
    3: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_Float64Stats.HistogramBucket, rhs: Google_Cloud_Automl_V1beta1_Float64Stats.HistogramBucket) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_StringStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StringStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top_unigram_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topUnigramStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topUnigramStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topUnigramStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_StringStats, rhs: Google_Cloud_Automl_V1beta1_StringStats) -> Bool {
    if lhs.topUnigramStats != rhs.topUnigramStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_StringStats.UnigramStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Automl_V1beta1_StringStats.protoMessageName + ".UnigramStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_StringStats.UnigramStats, rhs: Google_Cloud_Automl_V1beta1_StringStats.UnigramStats) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_TimestampStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimestampStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "granular_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Automl_V1beta1_TimestampStats.GranularStats>.self, value: &self.granularStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.granularStats.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Automl_V1beta1_TimestampStats.GranularStats>.self, value: self.granularStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_TimestampStats, rhs: Google_Cloud_Automl_V1beta1_TimestampStats) -> Bool {
    if lhs.granularStats != rhs.granularStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_TimestampStats.GranularStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Automl_V1beta1_TimestampStats.protoMessageName + ".GranularStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "buckets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: &self.buckets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buckets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufInt64>.self, value: self.buckets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_TimestampStats.GranularStats, rhs: Google_Cloud_Automl_V1beta1_TimestampStats.GranularStats) -> Bool {
    if lhs.buckets != rhs.buckets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_ArrayStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArrayStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "member_stats"),
  ]

  fileprivate class _StorageClass {
    var _memberStats: Google_Cloud_Automl_V1beta1_DataStats? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _memberStats = source._memberStats
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._memberStats) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._memberStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_ArrayStats, rhs: Google_Cloud_Automl_V1beta1_ArrayStats) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._memberStats != rhs_storage._memberStats {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_StructStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StructStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Automl_V1beta1_DataStats>.self, value: &self.fieldStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldStats.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Automl_V1beta1_DataStats>.self, value: self.fieldStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_StructStats, rhs: Google_Cloud_Automl_V1beta1_StructStats) -> Bool {
    if lhs.fieldStats != rhs.fieldStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_CategoryStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CategoryStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "top_category_stats"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.topCategoryStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topCategoryStats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.topCategoryStats, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_CategoryStats, rhs: Google_Cloud_Automl_V1beta1_CategoryStats) -> Bool {
    if lhs.topCategoryStats != rhs.topCategoryStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_CategoryStats.SingleCategoryStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Automl_V1beta1_CategoryStats.protoMessageName + ".SingleCategoryStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_CategoryStats.SingleCategoryStats, rhs: Google_Cloud_Automl_V1beta1_CategoryStats.SingleCategoryStats) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Automl_V1beta1_CorrelationStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CorrelationStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cramers_v"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.cramersV) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cramersV != 0 {
      try visitor.visitSingularDoubleField(value: self.cramersV, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Automl_V1beta1_CorrelationStats, rhs: Google_Cloud_Automl_V1beta1_CorrelationStats) -> Bool {
    if lhs.cramersV != rhs.cramersV {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

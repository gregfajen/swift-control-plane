// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/billing/budgets/v1alpha1/budget_model.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A budget is a plan that describes what you expect to spend on Cloud
/// projects, plus the rules to execute as spend is tracked against that plan,
/// (for example, send an alert when 90% of the target spend is met).
/// Currently all plans are monthly budgets so the usage period(s) tracked are
/// implied (calendar months of usage back-to-back).
public struct Google_Cloud_Billing_Budgets_V1alpha1_Budget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Resource name of the budget.
  /// The resource name implies the scope of a budget. Values are of the form
  /// `billingAccounts/{billingAccountId}/budgets/{budgetId}`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// User data for display name in UI.
  /// Validation: <= 60 chars.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Optional. Filters that define which resources are used to compute
  /// the actual spend against the budget.
  public var budgetFilter: Google_Cloud_Billing_Budgets_V1alpha1_Filter {
    get {return _storage._budgetFilter ?? Google_Cloud_Billing_Budgets_V1alpha1_Filter()}
    set {_uniqueStorage()._budgetFilter = newValue}
  }
  /// Returns true if `budgetFilter` has been explicitly set.
  public var hasBudgetFilter: Bool {return _storage._budgetFilter != nil}
  /// Clears the value of `budgetFilter`. Subsequent reads from it will return its default value.
  public mutating func clearBudgetFilter() {_uniqueStorage()._budgetFilter = nil}

  /// Required. Budgeted amount.
  public var amount: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount {
    get {return _storage._amount ?? Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount()}
    set {_uniqueStorage()._amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  public var hasAmount: Bool {return _storage._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  public mutating func clearAmount() {_uniqueStorage()._amount = nil}

  /// Optional. Rules that trigger alerts (notifications of thresholds
  /// being crossed) when spend exceeds the specified percentages of the budget.
  public var thresholdRules: [Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule] {
    get {return _storage._thresholdRules}
    set {_uniqueStorage()._thresholdRules = newValue}
  }

  /// Optional. Rules to apply to notifications sent based on budget spend and
  /// thresholds.
  public var allUpdatesRule: Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule {
    get {return _storage._allUpdatesRule ?? Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule()}
    set {_uniqueStorage()._allUpdatesRule = newValue}
  }
  /// Returns true if `allUpdatesRule` has been explicitly set.
  public var hasAllUpdatesRule: Bool {return _storage._allUpdatesRule != nil}
  /// Clears the value of `allUpdatesRule`. Subsequent reads from it will return its default value.
  public mutating func clearAllUpdatesRule() {_uniqueStorage()._allUpdatesRule = nil}

  /// Optional. Etag to validate that the object is unchanged for a
  /// read-modify-write operation.
  /// An empty etag will cause an update to overwrite other changes.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The budgeted amount for each usage period.
public struct Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specification for what amount to use as the budget.
  public var budgetAmount: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount.OneOf_BudgetAmount? = nil

  /// A specified amount to use as the budget.
  /// `currency_code` is optional. If specified, it must match the
  /// currency of the billing account. The `currency_code` is provided on
  /// output.
  public var specifiedAmount: Google_Type_Money {
    get {
      if case .specifiedAmount(let v)? = budgetAmount {return v}
      return Google_Type_Money()
    }
    set {budgetAmount = .specifiedAmount(newValue)}
  }

  /// Use the last period's actual spend as the budget for the present period.
  public var lastPeriodAmount: Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount {
    get {
      if case .lastPeriodAmount(let v)? = budgetAmount {return v}
      return Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount()
    }
    set {budgetAmount = .lastPeriodAmount(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specification for what amount to use as the budget.
  public enum OneOf_BudgetAmount: Equatable {
    /// A specified amount to use as the budget.
    /// `currency_code` is optional. If specified, it must match the
    /// currency of the billing account. The `currency_code` is provided on
    /// output.
    case specifiedAmount(Google_Type_Money)
    /// Use the last period's actual spend as the budget for the present period.
    case lastPeriodAmount(Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount.OneOf_BudgetAmount, rhs: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount.OneOf_BudgetAmount) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.specifiedAmount, .specifiedAmount): return {
        guard case .specifiedAmount(let l) = lhs, case .specifiedAmount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.lastPeriodAmount, .lastPeriodAmount): return {
        guard case .lastPeriodAmount(let l) = lhs, case .lastPeriodAmount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Describes a budget amount targeted to last period's spend.
/// At this time, the amount is automatically 100% of last period's spend;
/// that is, there are no other options yet.
/// Future configuration will be described here (for example, configuring a
/// percentage of last period's spend).
public struct Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ThresholdRule contains a definition of a threshold which triggers
/// an alert (a notification of a threshold being crossed) to be sent when
/// spend goes above the specified amount.
/// Alerts are automatically e-mailed to users with the Billing Account
/// Administrator role or the Billing Account User role.
/// The thresholds here have no effect on notifications sent to anything
/// configured under `Budget.all_updates_rule`.
public struct Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Send an alert when this threshold is exceeded.
  /// This is a 1.0-based percentage, so 0.5 = 50%.
  /// Validation: non-negative number.
  public var thresholdPercent: Double = 0

  /// Optional. The type of basis used to determine if spend has passed the
  /// threshold. Behavior defaults to CURRENT_SPEND if not set.
  public var spendBasis: Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule.Basis = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of basis used to determine if spend has passed the threshold.
  public enum Basis: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified threshold basis.
    case unspecified // = 0

    /// Use current spend as the basis for comparison against the threshold.
    case currentSpend // = 1

    /// Use forecasted spend for the period as the basis for comparison against
    /// the threshold.
    case forecastedSpend // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .currentSpend
      case 2: self = .forecastedSpend
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .currentSpend: return 1
      case .forecastedSpend: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule.Basis: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule.Basis] = [
    .unspecified,
    .currentSpend,
    .forecastedSpend,
  ]
}

#endif  // swift(>=4.2)

/// AllUpdatesRule defines notifications that are sent based on budget spend
/// and thresholds.
public struct Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The name of the Pub/Sub topic where budget related messages will
  /// be published, in the form `projects/{project_id}/topics/{topic_id}`.
  /// Updates are sent at regular intervals to the topic. The topic needs to be
  /// created before the budget is created; see
  /// https://cloud.google.com/billing/docs/how-to/budgets#manage-notifications
  /// for more details.
  /// Caller is expected to have
  /// `pubsub.topics.setIamPolicy` permission on the topic when it's set for a
  /// budget, otherwise, the API call will fail with PERMISSION_DENIED. See
  /// https://cloud.google.com/billing/docs/how-to/budgets-programmatic-notifications
  /// for more details on Pub/Sub roles and permissions.
  public var pubsubTopic: String = String()

  /// Optional. The schema version of the notification sent to `pubsub_topic`.
  /// Only "1.0" is accepted. It represents the JSON schema as defined in
  /// https://cloud.google.com/billing/docs/how-to/budgets-programmatic-notifications#notification_format
  public var schemaVersion: String = String()

  /// Optional. Targets to send notifications to when a threshold is exceeded.
  /// This is in addition to default recipients who have billing account IAM
  /// roles. The value is the full REST resource name of a monitoring
  /// notification channel with the form
  /// `projects/{project_id}/notificationChannels/{channel_id}`. A maximum of 5
  /// channels are allowed. See
  /// https://cloud.google.com/billing/docs/how-to/budgets-notification-recipients
  /// for more details.
  public var monitoringNotificationChannels: [String] = []

  /// Optional. When set to true, disables default notifications sent when a
  /// threshold is exceeded. Default notifications are sent to those with Billing
  /// Account Administrator and Billing Account User IAM roles for the target
  /// account.
  public var disableDefaultIamRecipients: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A filter for a budget, limiting the scope of the cost to calculate.
public struct Google_Cloud_Billing_Budgets_V1alpha1_Filter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A set of projects of the form `projects/{project}`,
  /// specifying that usage from only this set of projects should be
  /// included in the budget. If omitted, the report will include all usage for
  /// the billing account, regardless of which project the usage occurred on.
  /// Only zero or one project can be specified currently.
  public var projects: [String] = []

  /// Optional. A list of credit types to be subtracted from gross cost to
  /// determine the spend for threshold calculations if and only if
  /// credit_types_treatment is INCLUDE_SPECIFIED_CREDITS. If
  /// credit_types_treatment is not INCLUDE_SPECIFIED_CREDITS, this field must be
  /// empty. See credits.type at
  /// https://cloud.google.com/billing/docs/how-to/export-data-bigquery-tables#data-schema
  /// for a list of acceptable credit type values in this field.
  public var creditTypes: [String] = []

  /// Optional. If not set, default behavior is `INCLUDE_ALL_CREDITS`.
  public var creditTypesTreatment: Google_Cloud_Billing_Budgets_V1alpha1_Filter.CreditTypesTreatment = .unspecified

  /// Optional. A set of services of the form `services/{service_id}`,
  /// specifying that usage from only this set of services should be
  /// included in the budget. If omitted, the report will include usage for
  /// all the services.
  /// The service names are available through the Catalog API:
  /// https://cloud.google.com/billing/v1/how-tos/catalog-api.
  public var services: [String] = []

  /// Optional. A set of subaccounts of the form `billingAccounts/{account_id}`,
  /// specifying that usage from only this set of subaccounts should be included
  /// in the budget. If a subaccount is set to the name of the parent account,
  /// usage from the parent account will be included. If omitted, the
  /// report will include usage from the parent account and all
  /// subaccounts, if they exist.
  public var subaccounts: [String] = []

  /// Optional. A single label and value pair specifying that usage from only
  /// this set of labeled resources should be included in the budget. Currently,
  /// multiple entries or multiple values per entry are not allowed. If omitted,
  /// the report will include all labeled and unlabeled usage.
  public var labels: Dictionary<String,SwiftProtobuf.Google_Protobuf_ListValue> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies how credits should be treated when determining spend for
  /// threshold calculations.
  public enum CreditTypesTreatment: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// All types of credit are subtracted from the gross cost to determine the
    /// spend for threshold calculations.
    case includeAllCredits // = 1

    /// All types of credit are added to the net cost to determine the spend for
    /// threshold calculations.
    case excludeAllCredits // = 2

    /// Credit types specified in the credit_types field are subtracted from the
    /// gross cost to determine the spend for threshold calculations.
    case includeSpecifiedCredits // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .includeAllCredits
      case 2: self = .excludeAllCredits
      case 3: self = .includeSpecifiedCredits
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .includeAllCredits: return 1
      case .excludeAllCredits: return 2
      case .includeSpecifiedCredits: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Billing_Budgets_V1alpha1_Filter.CreditTypesTreatment: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Billing_Budgets_V1alpha1_Filter.CreditTypesTreatment] = [
    .unspecified,
    .includeAllCredits,
    .excludeAllCredits,
    .includeSpecifiedCredits,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.billing.budgets.v1alpha1"

extension Google_Cloud_Billing_Budgets_V1alpha1_Budget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Budget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "budget_filter"),
    4: .same(proto: "amount"),
    5: .standard(proto: "threshold_rules"),
    6: .standard(proto: "all_updates_rule"),
    7: .same(proto: "etag"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _budgetFilter: Google_Cloud_Billing_Budgets_V1alpha1_Filter? = nil
    var _amount: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount? = nil
    var _thresholdRules: [Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule] = []
    var _allUpdatesRule: Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule? = nil
    var _etag: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _budgetFilter = source._budgetFilter
      _amount = source._amount
      _thresholdRules = source._thresholdRules
      _allUpdatesRule = source._allUpdatesRule
      _etag = source._etag
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._budgetFilter) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._amount) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._thresholdRules) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._allUpdatesRule) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if let v = _storage._budgetFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._amount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._thresholdRules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._thresholdRules, fieldNumber: 5)
      }
      if let v = _storage._allUpdatesRule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_Budget, rhs: Google_Cloud_Billing_Budgets_V1alpha1_Budget) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._budgetFilter != rhs_storage._budgetFilter {return false}
        if _storage._amount != rhs_storage._amount {return false}
        if _storage._thresholdRules != rhs_storage._thresholdRules {return false}
        if _storage._allUpdatesRule != rhs_storage._allUpdatesRule {return false}
        if _storage._etag != rhs_storage._etag {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BudgetAmount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "specified_amount"),
    2: .standard(proto: "last_period_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Type_Money?
        if let current = self.budgetAmount {
          try decoder.handleConflictingOneOf()
          if case .specifiedAmount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.budgetAmount = .specifiedAmount(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount?
        if let current = self.budgetAmount {
          try decoder.handleConflictingOneOf()
          if case .lastPeriodAmount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.budgetAmount = .lastPeriodAmount(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.budgetAmount {
    case .specifiedAmount?: try {
      guard case .specifiedAmount(let v)? = self.budgetAmount else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .lastPeriodAmount?: try {
      guard case .lastPeriodAmount(let v)? = self.budgetAmount else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount, rhs: Google_Cloud_Billing_Budgets_V1alpha1_BudgetAmount) -> Bool {
    if lhs.budgetAmount != rhs.budgetAmount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LastPeriodAmount"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount, rhs: Google_Cloud_Billing_Budgets_V1alpha1_LastPeriodAmount) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThresholdRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "threshold_percent"),
    2: .standard(proto: "spend_basis"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.thresholdPercent) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.spendBasis) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.thresholdPercent != 0 {
      try visitor.visitSingularDoubleField(value: self.thresholdPercent, fieldNumber: 1)
    }
    if self.spendBasis != .unspecified {
      try visitor.visitSingularEnumField(value: self.spendBasis, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule, rhs: Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule) -> Bool {
    if lhs.thresholdPercent != rhs.thresholdPercent {return false}
    if lhs.spendBasis != rhs.spendBasis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Billing_Budgets_V1alpha1_ThresholdRule.Basis: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BASIS_UNSPECIFIED"),
    1: .same(proto: "CURRENT_SPEND"),
    2: .same(proto: "FORECASTED_SPEND"),
  ]
}

extension Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AllUpdatesRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pubsub_topic"),
    2: .standard(proto: "schema_version"),
    3: .standard(proto: "monitoring_notification_channels"),
    4: .standard(proto: "disable_default_iam_recipients"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubsubTopic) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.schemaVersion) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.monitoringNotificationChannels) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableDefaultIamRecipients) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubsubTopic.isEmpty {
      try visitor.visitSingularStringField(value: self.pubsubTopic, fieldNumber: 1)
    }
    if !self.schemaVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.schemaVersion, fieldNumber: 2)
    }
    if !self.monitoringNotificationChannels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.monitoringNotificationChannels, fieldNumber: 3)
    }
    if self.disableDefaultIamRecipients != false {
      try visitor.visitSingularBoolField(value: self.disableDefaultIamRecipients, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule, rhs: Google_Cloud_Billing_Budgets_V1alpha1_AllUpdatesRule) -> Bool {
    if lhs.pubsubTopic != rhs.pubsubTopic {return false}
    if lhs.schemaVersion != rhs.schemaVersion {return false}
    if lhs.monitoringNotificationChannels != rhs.monitoringNotificationChannels {return false}
    if lhs.disableDefaultIamRecipients != rhs.disableDefaultIamRecipients {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Billing_Budgets_V1alpha1_Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "projects"),
    7: .standard(proto: "credit_types"),
    4: .standard(proto: "credit_types_treatment"),
    3: .same(proto: "services"),
    5: .same(proto: "subaccounts"),
    6: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.projects) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.services) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.creditTypesTreatment) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.subaccounts) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: &self.labels) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.creditTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projects.isEmpty {
      try visitor.visitRepeatedStringField(value: self.projects, fieldNumber: 1)
    }
    if !self.services.isEmpty {
      try visitor.visitRepeatedStringField(value: self.services, fieldNumber: 3)
    }
    if self.creditTypesTreatment != .unspecified {
      try visitor.visitSingularEnumField(value: self.creditTypesTreatment, fieldNumber: 4)
    }
    if !self.subaccounts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subaccounts, fieldNumber: 5)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_ListValue>.self, value: self.labels, fieldNumber: 6)
    }
    if !self.creditTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.creditTypes, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Billing_Budgets_V1alpha1_Filter, rhs: Google_Cloud_Billing_Budgets_V1alpha1_Filter) -> Bool {
    if lhs.projects != rhs.projects {return false}
    if lhs.creditTypes != rhs.creditTypes {return false}
    if lhs.creditTypesTreatment != rhs.creditTypesTreatment {return false}
    if lhs.services != rhs.services {return false}
    if lhs.subaccounts != rhs.subaccounts {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Billing_Budgets_V1alpha1_Filter.CreditTypesTreatment: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREDIT_TYPES_TREATMENT_UNSPECIFIED"),
    1: .same(proto: "INCLUDE_ALL_CREDITS"),
    2: .same(proto: "EXCLUDE_ALL_CREDITS"),
    3: .same(proto: "INCLUDE_SPECIFIED_CREDITS"),
  ]
}

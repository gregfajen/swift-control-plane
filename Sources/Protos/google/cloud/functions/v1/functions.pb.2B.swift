// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/functions/v1/functions.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes the current stage of a deployment.
public enum Google_Cloud_Functions_V1_CloudFunctionStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified. Invalid state.
  case unspecified // = 0

  /// Function has been successfully deployed and is serving.
  case active // = 1

  /// Function deployment failed and the function isnâ€™t serving.
  case offline // = 2

  /// Function is being created or updated.
  case deployInProgress // = 3

  /// Function is being deleted.
  case deleteInProgress // = 4

  /// Function deployment failed and the function serving state is undefined.
  /// The function should be updated or deleted to move it out of this state.
  case unknown // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .active
    case 2: self = .offline
    case 3: self = .deployInProgress
    case 4: self = .deleteInProgress
    case 5: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .active: return 1
    case .offline: return 2
    case .deployInProgress: return 3
    case .deleteInProgress: return 4
    case .unknown: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Functions_V1_CloudFunctionStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Functions_V1_CloudFunctionStatus] = [
    .unspecified,
    .active,
    .offline,
    .deployInProgress,
    .deleteInProgress,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

/// Describes a Cloud Function that contains user computation executed in
/// response to an event. It encapsulate function and triggers configurations.
public struct Google_Cloud_Functions_V1_CloudFunction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A user-defined name of the function. Function names must be unique
  /// globally and match pattern `projects/*/locations/*/functions/*`
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// User-provided description of a function.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The location of the function source code.
  public var sourceCode: OneOf_SourceCode? {
    get {return _storage._sourceCode}
    set {_uniqueStorage()._sourceCode = newValue}
  }

  /// The Google Cloud Storage URL, starting with gs://, pointing to the zip
  /// archive which contains the function.
  public var sourceArchiveURL: String {
    get {
      if case .sourceArchiveURL(let v)? = _storage._sourceCode {return v}
      return String()
    }
    set {_uniqueStorage()._sourceCode = .sourceArchiveURL(newValue)}
  }

  /// **Beta Feature**
  ///
  /// The source repository where a function is hosted.
  public var sourceRepository: Google_Cloud_Functions_V1_SourceRepository {
    get {
      if case .sourceRepository(let v)? = _storage._sourceCode {return v}
      return Google_Cloud_Functions_V1_SourceRepository()
    }
    set {_uniqueStorage()._sourceCode = .sourceRepository(newValue)}
  }

  /// The Google Cloud Storage signed URL used for source uploading, generated
  /// by [google.cloud.functions.v1.GenerateUploadUrl][]
  public var sourceUploadURL: String {
    get {
      if case .sourceUploadURL(let v)? = _storage._sourceCode {return v}
      return String()
    }
    set {_uniqueStorage()._sourceCode = .sourceUploadURL(newValue)}
  }

  /// An event that triggers the function.
  public var trigger: OneOf_Trigger? {
    get {return _storage._trigger}
    set {_uniqueStorage()._trigger = newValue}
  }

  /// An HTTPS endpoint type of source that can be triggered via URL.
  public var httpsTrigger: Google_Cloud_Functions_V1_HttpsTrigger {
    get {
      if case .httpsTrigger(let v)? = _storage._trigger {return v}
      return Google_Cloud_Functions_V1_HttpsTrigger()
    }
    set {_uniqueStorage()._trigger = .httpsTrigger(newValue)}
  }

  /// A source that fires events in response to a condition in another service.
  public var eventTrigger: Google_Cloud_Functions_V1_EventTrigger {
    get {
      if case .eventTrigger(let v)? = _storage._trigger {return v}
      return Google_Cloud_Functions_V1_EventTrigger()
    }
    set {_uniqueStorage()._trigger = .eventTrigger(newValue)}
  }

  /// Output only. Status of the function deployment.
  public var status: Google_Cloud_Functions_V1_CloudFunctionStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// The name of the function (as defined in source code) that will be
  /// executed. Defaults to the resource name suffix, if not specified. For
  /// backward compatibility, if function with given name is not found, then the
  /// system will try to use function named "function".
  /// For Node.js this is name of a function exported by the module specified
  /// in `source_location`.
  public var entryPoint: String {
    get {return _storage._entryPoint}
    set {_uniqueStorage()._entryPoint = newValue}
  }

  /// The runtime in which to run the function. Required when deploying a new
  /// function, optional when updating an existing function. For a complete
  /// list of possible choices, see the
  /// [`gcloud` command
  /// reference](/sdk/gcloud/reference/functions/deploy#--runtime).
  public var runtime: String {
    get {return _storage._runtime}
    set {_uniqueStorage()._runtime = newValue}
  }

  /// The function execution timeout. Execution is considered failed and
  /// can be terminated if the function is not completed at the end of the
  /// timeout period. Defaults to 60 seconds.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// The amount of memory in MB available for a function.
  /// Defaults to 256MB.
  public var availableMemoryMb: Int32 {
    get {return _storage._availableMemoryMb}
    set {_uniqueStorage()._availableMemoryMb = newValue}
  }

  /// The email of the function's service account. If empty, defaults to
  /// `{project_id}@appspot.gserviceaccount.com`.
  public var serviceAccountEmail: String {
    get {return _storage._serviceAccountEmail}
    set {_uniqueStorage()._serviceAccountEmail = newValue}
  }

  /// Output only. The last update timestamp of a Cloud Function.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. The version identifier of the Cloud Function. Each deployment attempt
  /// results in a new version of a function being created.
  public var versionID: Int64 {
    get {return _storage._versionID}
    set {_uniqueStorage()._versionID = newValue}
  }

  /// Labels associated with this Cloud Function.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  /// Environment variables that shall be available during function execution.
  public var environmentVariables: Dictionary<String,String> {
    get {return _storage._environmentVariables}
    set {_uniqueStorage()._environmentVariables = newValue}
  }

  /// The VPC Network that this cloud function can connect to. It can be
  /// either the fully-qualified URI, or the short name of the network resource.
  /// If the short network name is used, the network must belong to the same
  /// project. Otherwise, it must belong to a project within the same
  /// organization. The format of this field is either
  /// `projects/{project}/global/networks/{network}` or `{network}`, where
  /// {project} is a project id where the network is defined, and {network} is
  /// the short name of the network.
  ///
  /// This field is mutually exclusive with `vpc_connector` and will be replaced
  /// by it.
  ///
  /// See [the VPC documentation](https://cloud.google.com/compute/docs/vpc) for
  /// more information on connecting Cloud projects.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// The limit on the maximum number of function instances that may coexist at a
  /// given time.
  public var maxInstances: Int32 {
    get {return _storage._maxInstances}
    set {_uniqueStorage()._maxInstances = newValue}
  }

  /// The VPC Network Connector that this cloud function can connect to. It can
  /// be either the fully-qualified URI, or the short name of the network
  /// connector resource. The format of this field is
  /// `projects/*/locations/*/connectors/*`
  ///
  /// This field is mutually exclusive with `network` field and will eventually
  /// replace it.
  ///
  /// See [the VPC documentation](https://cloud.google.com/compute/docs/vpc) for
  /// more information on connecting Cloud projects.
  public var vpcConnector: String {
    get {return _storage._vpcConnector}
    set {_uniqueStorage()._vpcConnector = newValue}
  }

  /// The egress settings for the connector, controlling what traffic is diverted
  /// through it.
  public var vpcConnectorEgressSettings: Google_Cloud_Functions_V1_CloudFunction.VpcConnectorEgressSettings {
    get {return _storage._vpcConnectorEgressSettings}
    set {_uniqueStorage()._vpcConnectorEgressSettings = newValue}
  }

  /// The ingress settings for the function, controlling what traffic can reach
  /// it.
  public var ingressSettings: Google_Cloud_Functions_V1_CloudFunction.IngressSettings {
    get {return _storage._ingressSettings}
    set {_uniqueStorage()._ingressSettings = newValue}
  }

  /// Output only. The Cloud Build ID of the latest successful deployment of the
  /// function.
  public var buildID: String {
    get {return _storage._buildID}
    set {_uniqueStorage()._buildID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The location of the function source code.
  public enum OneOf_SourceCode: Equatable {
    /// The Google Cloud Storage URL, starting with gs://, pointing to the zip
    /// archive which contains the function.
    case sourceArchiveURL(String)
    /// **Beta Feature**
    ///
    /// The source repository where a function is hosted.
    case sourceRepository(Google_Cloud_Functions_V1_SourceRepository)
    /// The Google Cloud Storage signed URL used for source uploading, generated
    /// by [google.cloud.functions.v1.GenerateUploadUrl][]
    case sourceUploadURL(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Functions_V1_CloudFunction.OneOf_SourceCode, rhs: Google_Cloud_Functions_V1_CloudFunction.OneOf_SourceCode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sourceArchiveURL, .sourceArchiveURL): return {
        guard case .sourceArchiveURL(let l) = lhs, case .sourceArchiveURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sourceRepository, .sourceRepository): return {
        guard case .sourceRepository(let l) = lhs, case .sourceRepository(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sourceUploadURL, .sourceUploadURL): return {
        guard case .sourceUploadURL(let l) = lhs, case .sourceUploadURL(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// An event that triggers the function.
  public enum OneOf_Trigger: Equatable {
    /// An HTTPS endpoint type of source that can be triggered via URL.
    case httpsTrigger(Google_Cloud_Functions_V1_HttpsTrigger)
    /// A source that fires events in response to a condition in another service.
    case eventTrigger(Google_Cloud_Functions_V1_EventTrigger)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Functions_V1_CloudFunction.OneOf_Trigger, rhs: Google_Cloud_Functions_V1_CloudFunction.OneOf_Trigger) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.httpsTrigger, .httpsTrigger): return {
        guard case .httpsTrigger(let l) = lhs, case .httpsTrigger(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eventTrigger, .eventTrigger): return {
        guard case .eventTrigger(let l) = lhs, case .eventTrigger(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Available egress settings.
  ///
  /// This controls what traffic is diverted through the VPC Access Connector
  /// resource. By default PRIVATE_RANGES_ONLY will be used.
  public enum VpcConnectorEgressSettings: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Use the VPC Access Connector only for private IP space from RFC1918.
    case privateRangesOnly // = 1

    /// Force the use of VPC Access Connector for all egress traffic from the
    /// function.
    case allTraffic // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .privateRangesOnly
      case 2: self = .allTraffic
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .privateRangesOnly: return 1
      case .allTraffic: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Available ingress settings.
  ///
  /// This controls what traffic can reach the function.
  ///
  /// If unspecified, ALLOW_ALL will be used.
  public enum IngressSettings: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Allow HTTP traffic from public and private sources.
    case allowAll // = 1

    /// Allow HTTP traffic from only private VPC sources.
    case allowInternalOnly // = 2

    /// Allow HTTP traffic from private VPC sources and through GCLB.
    case allowInternalAndGclb // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .allowAll
      case 2: self = .allowInternalOnly
      case 3: self = .allowInternalAndGclb
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .allowAll: return 1
      case .allowInternalOnly: return 2
      case .allowInternalAndGclb: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Functions_V1_CloudFunction.VpcConnectorEgressSettings: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Functions_V1_CloudFunction.VpcConnectorEgressSettings] = [
    .unspecified,
    .privateRangesOnly,
    .allTraffic,
  ]
}

extension Google_Cloud_Functions_V1_CloudFunction.IngressSettings: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Functions_V1_CloudFunction.IngressSettings] = [
    .unspecified,
    .allowAll,
    .allowInternalOnly,
    .allowInternalAndGclb,
  ]
}

#endif  // swift(>=4.2)

/// Describes SourceRepository, used to represent parameters related to
/// source repository where a function is hosted.
public struct Google_Cloud_Functions_V1_SourceRepository {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The URL pointing to the hosted repository where the function is defined.
  /// There are supported Cloud Source Repository URLs in the following
  /// formats:
  ///
  /// To refer to a specific commit:
  /// `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`
  /// To refer to a moveable alias (branch):
  /// `https://source.developers.google.com/projects/*/repos/*/moveable-aliases/*/paths/*`
  /// In particular, to refer to HEAD use `master` moveable alias.
  /// To refer to a specific fixed alias (tag):
  /// `https://source.developers.google.com/projects/*/repos/*/fixed-aliases/*/paths/*`
  ///
  /// You may omit `paths/*` if you want to use the main directory.
  public var url: String = String()

  /// Output only. The URL pointing to the hosted repository where the function
  /// were defined at the time of deployment. It always points to a specific
  /// commit in the format described above.
  public var deployedURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes HttpsTrigger, could be used to connect web hooks to function.
public struct Google_Cloud_Functions_V1_HttpsTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The deployed url for the function.
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes EventTrigger, used to request events be sent from another
/// service.
public struct Google_Cloud_Functions_V1_EventTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The type of event to observe. For example:
  /// `providers/cloud.storage/eventTypes/object.change` and
  /// `providers/cloud.pubsub/eventTypes/topic.publish`.
  ///
  /// Event types match pattern `providers/*/eventTypes/*.*`.
  /// The pattern contains:
  ///
  /// 1. namespace: For example, `cloud.storage` and
  ///    `google.firebase.analytics`.
  /// 2. resource type: The type of resource on which event occurs. For
  ///    example, the Google Cloud Storage API includes the type `object`.
  /// 3. action: The action that generates the event. For example, action for
  ///    a Google Cloud Storage Object is 'change'.
  /// These parts are lower case.
  public var eventType: String = String()

  /// Required. The resource(s) from which to observe events, for example,
  /// `projects/_/buckets/myBucket`.
  ///
  /// Not all syntactically correct values are accepted by all services. For
  /// example:
  ///
  /// 1. The authorization model must support it. Google Cloud Functions
  ///    only allows EventTriggers to be deployed that observe resources in the
  ///    same project as the `CloudFunction`.
  /// 2. The resource type must match the pattern expected for an
  ///    `event_type`. For example, an `EventTrigger` that has an
  ///    `event_type` of "google.pubsub.topic.publish" should have a resource
  ///    that matches Google Cloud Pub/Sub topics.
  ///
  /// Additionally, some services may support short names when creating an
  /// `EventTrigger`. These will always be returned in the normalized "long"
  /// format.
  ///
  /// See each *service's* documentation for supported formats.
  public var resource: String = String()

  /// The hostname of the service that should be observed.
  ///
  /// If no string is provided, the default service implementing the API will
  /// be used. For example, `storage.googleapis.com` is the default for all
  /// event types in the `google.storage` namespace.
  public var service: String = String()

  /// Specifies policy for failed executions.
  public var failurePolicy: Google_Cloud_Functions_V1_FailurePolicy {
    get {return _failurePolicy ?? Google_Cloud_Functions_V1_FailurePolicy()}
    set {_failurePolicy = newValue}
  }
  /// Returns true if `failurePolicy` has been explicitly set.
  public var hasFailurePolicy: Bool {return self._failurePolicy != nil}
  /// Clears the value of `failurePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearFailurePolicy() {self._failurePolicy = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _failurePolicy: Google_Cloud_Functions_V1_FailurePolicy? = nil
}

/// Describes the policy in case of function's execution failure.
/// If empty, then defaults to ignoring failures (i.e. not retrying them).
public struct Google_Cloud_Functions_V1_FailurePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines the action taken in case of a function execution failure.
  public var action: Google_Cloud_Functions_V1_FailurePolicy.OneOf_Action? = nil

  /// If specified, then the function will be retried in case of a failure.
  public var retry: Google_Cloud_Functions_V1_FailurePolicy.Retry {
    get {
      if case .retry(let v)? = action {return v}
      return Google_Cloud_Functions_V1_FailurePolicy.Retry()
    }
    set {action = .retry(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Defines the action taken in case of a function execution failure.
  public enum OneOf_Action: Equatable {
    /// If specified, then the function will be retried in case of a failure.
    case retry(Google_Cloud_Functions_V1_FailurePolicy.Retry)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Functions_V1_FailurePolicy.OneOf_Action, rhs: Google_Cloud_Functions_V1_FailurePolicy.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.retry, .retry): return {
        guard case .retry(let l) = lhs, case .retry(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Describes the retry policy in case of function's execution failure.
  /// A function execution will be retried on any failure.
  /// A failed execution will be retried up to 7 days with an exponential backoff
  /// (capped at 10 seconds).
  /// Retried execution is charged as any other execution.
  public struct Retry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Request for the `CreateFunction` method.
public struct Google_Cloud_Functions_V1_CreateFunctionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project and location in which the function should be created, specified
  /// in the format `projects/*/locations/*`
  public var location: String = String()

  /// Required. Function to be created.
  public var function: Google_Cloud_Functions_V1_CloudFunction {
    get {return _function ?? Google_Cloud_Functions_V1_CloudFunction()}
    set {_function = newValue}
  }
  /// Returns true if `function` has been explicitly set.
  public var hasFunction: Bool {return self._function != nil}
  /// Clears the value of `function`. Subsequent reads from it will return its default value.
  public mutating func clearFunction() {self._function = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _function: Google_Cloud_Functions_V1_CloudFunction? = nil
}

/// Request for the `UpdateFunction` method.
public struct Google_Cloud_Functions_V1_UpdateFunctionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. New version of the function.
  public var function: Google_Cloud_Functions_V1_CloudFunction {
    get {return _function ?? Google_Cloud_Functions_V1_CloudFunction()}
    set {_function = newValue}
  }
  /// Returns true if `function` has been explicitly set.
  public var hasFunction: Bool {return self._function != nil}
  /// Clears the value of `function`. Subsequent reads from it will return its default value.
  public mutating func clearFunction() {self._function = nil}

  /// Required list of fields to be updated in this request.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _function: Google_Cloud_Functions_V1_CloudFunction? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for the `GetFunction` method.
public struct Google_Cloud_Functions_V1_GetFunctionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the function which details should be obtained.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for the `ListFunctions` method.
public struct Google_Cloud_Functions_V1_ListFunctionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The project and location from which the function should be listed,
  /// specified in the format `projects/*/locations/*`
  /// If you want to list functions in all locations, use "-" in place of a
  /// location. When listing functions in all locations, if one or more
  /// location(s) are unreachable, the response will contain functions from all
  /// reachable locations along with the names of any unreachable locations.
  public var parent: String = String()

  /// Maximum number of functions to return per call.
  public var pageSize: Int32 = 0

  /// The value returned by the last
  /// `ListFunctionsResponse`; indicates that
  /// this is a continuation of a prior `ListFunctions` call, and that the
  /// system should return the next page of data.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for the `ListFunctions` method.
public struct Google_Cloud_Functions_V1_ListFunctionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The functions that match the request.
  public var functions: [Google_Cloud_Functions_V1_CloudFunction] = []

  /// If not empty, indicates that there may be more functions that match
  /// the request; this value should be passed in a new
  /// [google.cloud.functions.v1.ListFunctionsRequest][google.cloud.functions.v1.ListFunctionsRequest]
  /// to get more functions.
  public var nextPageToken: String = String()

  /// Locations that could not be reached. The response does not include any
  /// functions from these locations.
  public var unreachable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for the `DeleteFunction` method.
public struct Google_Cloud_Functions_V1_DeleteFunctionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the function which should be deleted.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for the `CallFunction` method.
public struct Google_Cloud_Functions_V1_CallFunctionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the function to be called.
  public var name: String = String()

  /// Required. Input to be passed to the function.
  public var data: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response of `CallFunction` method.
public struct Google_Cloud_Functions_V1_CallFunctionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Execution id of function invocation.
  public var executionID: String = String()

  /// Result populated for successful execution of synchronous function. Will
  /// not be populated if function does not return a result through context.
  public var result: String = String()

  /// Either system or user-function generated error. Set if execution
  /// was not successful.
  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request of `GenerateSourceUploadUrl` method.
public struct Google_Cloud_Functions_V1_GenerateUploadUrlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The project and location in which the Google Cloud Storage signed URL
  /// should be generated, specified in the format `projects/*/locations/*`.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response of `GenerateSourceUploadUrl` method.
public struct Google_Cloud_Functions_V1_GenerateUploadUrlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The generated Google Cloud Storage signed URL that should be used for a
  /// function source code upload. The uploaded file should be a zip archive
  /// which contains a function.
  public var uploadURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request of `GenerateDownloadUrl` method.
public struct Google_Cloud_Functions_V1_GenerateDownloadUrlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of function for which source code Google Cloud Storage signed
  /// URL should be generated.
  public var name: String = String()

  /// The optional version of function. If not set, default, current version
  /// is used.
  public var versionID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response of `GenerateDownloadUrl` method.
public struct Google_Cloud_Functions_V1_GenerateDownloadUrlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The generated Google Cloud Storage signed URL that should be used for
  /// function source code download.
  public var downloadURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.functions.v1"

extension Google_Cloud_Functions_V1_CloudFunctionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLOUD_FUNCTION_STATUS_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "OFFLINE"),
    3: .same(proto: "DEPLOY_IN_PROGRESS"),
    4: .same(proto: "DELETE_IN_PROGRESS"),
    5: .same(proto: "UNKNOWN"),
  ]
}

extension Google_Cloud_Functions_V1_CloudFunction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudFunction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "source_archive_url"),
    4: .standard(proto: "source_repository"),
    16: .standard(proto: "source_upload_url"),
    5: .standard(proto: "https_trigger"),
    6: .standard(proto: "event_trigger"),
    7: .same(proto: "status"),
    8: .standard(proto: "entry_point"),
    19: .same(proto: "runtime"),
    9: .same(proto: "timeout"),
    10: .standard(proto: "available_memory_mb"),
    11: .standard(proto: "service_account_email"),
    12: .standard(proto: "update_time"),
    14: .standard(proto: "version_id"),
    15: .same(proto: "labels"),
    17: .standard(proto: "environment_variables"),
    18: .same(proto: "network"),
    20: .standard(proto: "max_instances"),
    22: .standard(proto: "vpc_connector"),
    23: .standard(proto: "vpc_connector_egress_settings"),
    24: .standard(proto: "ingress_settings"),
    27: .standard(proto: "build_id"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _sourceCode: Google_Cloud_Functions_V1_CloudFunction.OneOf_SourceCode?
    var _trigger: Google_Cloud_Functions_V1_CloudFunction.OneOf_Trigger?
    var _status: Google_Cloud_Functions_V1_CloudFunctionStatus = .unspecified
    var _entryPoint: String = String()
    var _runtime: String = String()
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _availableMemoryMb: Int32 = 0
    var _serviceAccountEmail: String = String()
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _versionID: Int64 = 0
    var _labels: Dictionary<String,String> = [:]
    var _environmentVariables: Dictionary<String,String> = [:]
    var _network: String = String()
    var _maxInstances: Int32 = 0
    var _vpcConnector: String = String()
    var _vpcConnectorEgressSettings: Google_Cloud_Functions_V1_CloudFunction.VpcConnectorEgressSettings = .unspecified
    var _ingressSettings: Google_Cloud_Functions_V1_CloudFunction.IngressSettings = .unspecified
    var _buildID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _sourceCode = source._sourceCode
      _trigger = source._trigger
      _status = source._status
      _entryPoint = source._entryPoint
      _runtime = source._runtime
      _timeout = source._timeout
      _availableMemoryMb = source._availableMemoryMb
      _serviceAccountEmail = source._serviceAccountEmail
      _updateTime = source._updateTime
      _versionID = source._versionID
      _labels = source._labels
      _environmentVariables = source._environmentVariables
      _network = source._network
      _maxInstances = source._maxInstances
      _vpcConnector = source._vpcConnector
      _vpcConnectorEgressSettings = source._vpcConnectorEgressSettings
      _ingressSettings = source._ingressSettings
      _buildID = source._buildID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try {
          if _storage._sourceCode != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._sourceCode = .sourceArchiveURL(v)}
        }()
        case 4: try {
          var v: Google_Cloud_Functions_V1_SourceRepository?
          if let current = _storage._sourceCode {
            try decoder.handleConflictingOneOf()
            if case .sourceRepository(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._sourceCode = .sourceRepository(v)}
        }()
        case 5: try {
          var v: Google_Cloud_Functions_V1_HttpsTrigger?
          if let current = _storage._trigger {
            try decoder.handleConflictingOneOf()
            if case .httpsTrigger(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._trigger = .httpsTrigger(v)}
        }()
        case 6: try {
          var v: Google_Cloud_Functions_V1_EventTrigger?
          if let current = _storage._trigger {
            try decoder.handleConflictingOneOf()
            if case .eventTrigger(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._trigger = .eventTrigger(v)}
        }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._entryPoint) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._availableMemoryMb) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._serviceAccountEmail) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._versionID) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 16: try {
          if _storage._sourceCode != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._sourceCode = .sourceUploadURL(v)}
        }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._environmentVariables) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._runtime) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._maxInstances) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._vpcConnector) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._vpcConnectorEgressSettings) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._ingressSettings) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._buildID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._sourceCode {
      case .sourceArchiveURL?: try {
        guard case .sourceArchiveURL(let v)? = _storage._sourceCode else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }()
      case .sourceRepository?: try {
        guard case .sourceRepository(let v)? = _storage._sourceCode else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      default: break
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._trigger {
      case .httpsTrigger?: try {
        guard case .httpsTrigger(let v)? = _storage._trigger else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .eventTrigger?: try {
        guard case .eventTrigger(let v)? = _storage._trigger else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 7)
      }
      if !_storage._entryPoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entryPoint, fieldNumber: 8)
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._availableMemoryMb != 0 {
        try visitor.visitSingularInt32Field(value: _storage._availableMemoryMb, fieldNumber: 10)
      }
      if !_storage._serviceAccountEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serviceAccountEmail, fieldNumber: 11)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._versionID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._versionID, fieldNumber: 14)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 15)
      }
      if case .sourceUploadURL(let v)? = _storage._sourceCode {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if !_storage._environmentVariables.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._environmentVariables, fieldNumber: 17)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 18)
      }
      if !_storage._runtime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtime, fieldNumber: 19)
      }
      if _storage._maxInstances != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxInstances, fieldNumber: 20)
      }
      if !_storage._vpcConnector.isEmpty {
        try visitor.visitSingularStringField(value: _storage._vpcConnector, fieldNumber: 22)
      }
      if _storage._vpcConnectorEgressSettings != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._vpcConnectorEgressSettings, fieldNumber: 23)
      }
      if _storage._ingressSettings != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._ingressSettings, fieldNumber: 24)
      }
      if !_storage._buildID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buildID, fieldNumber: 27)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_CloudFunction, rhs: Google_Cloud_Functions_V1_CloudFunction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._sourceCode != rhs_storage._sourceCode {return false}
        if _storage._trigger != rhs_storage._trigger {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._entryPoint != rhs_storage._entryPoint {return false}
        if _storage._runtime != rhs_storage._runtime {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._availableMemoryMb != rhs_storage._availableMemoryMb {return false}
        if _storage._serviceAccountEmail != rhs_storage._serviceAccountEmail {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._versionID != rhs_storage._versionID {return false}
        if _storage._labels != rhs_storage._labels {return false}
        if _storage._environmentVariables != rhs_storage._environmentVariables {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._maxInstances != rhs_storage._maxInstances {return false}
        if _storage._vpcConnector != rhs_storage._vpcConnector {return false}
        if _storage._vpcConnectorEgressSettings != rhs_storage._vpcConnectorEgressSettings {return false}
        if _storage._ingressSettings != rhs_storage._ingressSettings {return false}
        if _storage._buildID != rhs_storage._buildID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_CloudFunction.VpcConnectorEgressSettings: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED"),
    1: .same(proto: "PRIVATE_RANGES_ONLY"),
    2: .same(proto: "ALL_TRAFFIC"),
  ]
}

extension Google_Cloud_Functions_V1_CloudFunction.IngressSettings: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INGRESS_SETTINGS_UNSPECIFIED"),
    1: .same(proto: "ALLOW_ALL"),
    2: .same(proto: "ALLOW_INTERNAL_ONLY"),
    3: .same(proto: "ALLOW_INTERNAL_AND_GCLB"),
  ]
}

extension Google_Cloud_Functions_V1_SourceRepository: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceRepository"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "deployed_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deployedURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.deployedURL.isEmpty {
      try visitor.visitSingularStringField(value: self.deployedURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_SourceRepository, rhs: Google_Cloud_Functions_V1_SourceRepository) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.deployedURL != rhs.deployedURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_HttpsTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpsTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_HttpsTrigger, rhs: Google_Cloud_Functions_V1_HttpsTrigger) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_EventTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_type"),
    2: .same(proto: "resource"),
    3: .same(proto: "service"),
    5: .standard(proto: "failure_policy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._failurePolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventType.isEmpty {
      try visitor.visitSingularStringField(value: self.eventType, fieldNumber: 1)
    }
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 2)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 3)
    }
    if let v = self._failurePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_EventTrigger, rhs: Google_Cloud_Functions_V1_EventTrigger) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.service != rhs.service {return false}
    if lhs._failurePolicy != rhs._failurePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_FailurePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailurePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "retry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Functions_V1_FailurePolicy.Retry?
        if let current = self.action {
          try decoder.handleConflictingOneOf()
          if case .retry(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.action = .retry(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .retry(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_FailurePolicy, rhs: Google_Cloud_Functions_V1_FailurePolicy) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_FailurePolicy.Retry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Functions_V1_FailurePolicy.protoMessageName + ".Retry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_FailurePolicy.Retry, rhs: Google_Cloud_Functions_V1_FailurePolicy.Retry) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_CreateFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFunctionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "function"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._function) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if let v = self._function {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_CreateFunctionRequest, rhs: Google_Cloud_Functions_V1_CreateFunctionRequest) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs._function != rhs._function {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_UpdateFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFunctionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "function"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._function) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._function {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_UpdateFunctionRequest, rhs: Google_Cloud_Functions_V1_UpdateFunctionRequest) -> Bool {
    if lhs._function != rhs._function {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_GetFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFunctionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_GetFunctionRequest, rhs: Google_Cloud_Functions_V1_GetFunctionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_ListFunctionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFunctionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_ListFunctionsRequest, rhs: Google_Cloud_Functions_V1_ListFunctionsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_ListFunctionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFunctionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "functions"),
    2: .standard(proto: "next_page_token"),
    3: .same(proto: "unreachable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.functions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.functions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.functions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_ListFunctionsResponse, rhs: Google_Cloud_Functions_V1_ListFunctionsResponse) -> Bool {
    if lhs.functions != rhs.functions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_DeleteFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFunctionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_DeleteFunctionRequest, rhs: Google_Cloud_Functions_V1_DeleteFunctionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_CallFunctionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallFunctionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_CallFunctionRequest, rhs: Google_Cloud_Functions_V1_CallFunctionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_CallFunctionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallFunctionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "execution_id"),
    2: .same(proto: "result"),
    3: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.executionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executionID.isEmpty {
      try visitor.visitSingularStringField(value: self.executionID, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_CallFunctionResponse, rhs: Google_Cloud_Functions_V1_CallFunctionResponse) -> Bool {
    if lhs.executionID != rhs.executionID {return false}
    if lhs.result != rhs.result {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_GenerateUploadUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateUploadUrlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_GenerateUploadUrlRequest, rhs: Google_Cloud_Functions_V1_GenerateUploadUrlRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_GenerateUploadUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateUploadUrlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upload_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uploadURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uploadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_GenerateUploadUrlResponse, rhs: Google_Cloud_Functions_V1_GenerateUploadUrlResponse) -> Bool {
    if lhs.uploadURL != rhs.uploadURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_GenerateDownloadUrlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateDownloadUrlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.versionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.versionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.versionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_GenerateDownloadUrlRequest, rhs: Google_Cloud_Functions_V1_GenerateDownloadUrlRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.versionID != rhs.versionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Functions_V1_GenerateDownloadUrlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateDownloadUrlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "download_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.downloadURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.downloadURL.isEmpty {
      try visitor.visitSingularStringField(value: self.downloadURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Functions_V1_GenerateDownloadUrlResponse, rhs: Google_Cloud_Functions_V1_GenerateDownloadUrlResponse) -> Bool {
    if lhs.downloadURL != rhs.downloadURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

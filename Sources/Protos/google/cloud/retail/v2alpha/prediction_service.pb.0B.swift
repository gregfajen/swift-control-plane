// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/retail/v2alpha/prediction_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for Predict method.
public struct Google_Cloud_Retail_V2alpha_PredictRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Full resource name of the format:
  /// {name=projects/*/locations/global/catalogs/default_catalog/placements/*}
  /// The id of the recommendation engine placement. This id is used to identify
  /// the set of models that will be used to make the prediction.
  ///
  /// We currently support three placements with the following IDs by default:
  ///
  /// * `shopping_cart`: Predicts products frequently bought together with one or
  ///   more  products in the same shopping session. Commonly displayed after
  ///   `add-to-cart` events, on product detail pages, or on the shopping cart
  ///   page.
  ///
  /// * `home_page`: Predicts the next product that a user will most likely
  ///   engage with or purchase based on the shopping or viewing history of the
  ///   specified `userId` or `visitorId`. For example - Recommendations for you.
  ///
  /// * `product_detail`: Predicts the next product that a user will most likely
  ///   engage with or purchase. The prediction is based on the shopping or
  ///   viewing history of the specified `userId` or `visitorId` and its
  ///   relevance to a specified `CatalogItem`. Typically used on product detail
  ///   pages. For example - More products like this.
  ///
  /// * `recently_viewed_default`: Returns up to 75 products recently viewed by
  ///   the specified `userId` or `visitorId`, most recent ones first. Returns
  ///   nothing if neither of them has viewed any products yet. For example -
  ///   Recently viewed.
  ///
  /// The full list of available placements can be seen at
  ///
  /// https:
  /// //console.cloud.google.com/recommendatio
  /// // n/datafeeds/default_catalog/dashboard
  public var placement: String = String()

  /// Required. Context about the user, what they are looking at and what action
  /// they took to trigger the predict request. Note that this user event detail
  /// won't be ingested to userEvent logs. Thus, a separate userEvent write
  /// request is required for event logging.
  public var userEvent: Google_Cloud_Retail_V2alpha_UserEvent {
    get {return _userEvent ?? Google_Cloud_Retail_V2alpha_UserEvent()}
    set {_userEvent = newValue}
  }
  /// Returns true if `userEvent` has been explicitly set.
  public var hasUserEvent: Bool {return self._userEvent != nil}
  /// Clears the value of `userEvent`. Subsequent reads from it will return its default value.
  public mutating func clearUserEvent() {self._userEvent = nil}

  /// Maximum number of results to return per page. Set this property
  /// to the number of prediction results needed. If zero, the service will
  /// choose a reasonable default. The maximum allowed value is 100. Values
  /// above 100 will be coerced to 100.
  public var pageSize: Int32 = 0

  /// The previous PredictResponse.next_page_token.
  public var pageToken: String = String()

  /// Filter for restricting prediction results with a length limit of 5,000
  /// characters. Accepts values for tags and the `filterOutOfStockItems` flag.
  ///
  ///  * Tag expressions. Restricts predictions to products that match all of the
  ///    specified tags. Boolean operators `OR` and `NOT` are supported if the
  ///    expression is enclosed in parentheses, and must be separated from the
  ///    tag values by a space. `-"tagA"` is also supported and is equivalent to
  ///    `NOT "tagA"`. Tag values must be double quoted UTF-8 encoded strings
  ///    with a size limit of 1,000 characters.
  ///
  ///  * filterOutOfStockItems. Restricts predictions to products that do not
  ///  have a
  ///    stockState value of OUT_OF_STOCK.
  ///
  /// Examples:
  ///
  ///  * tag=("Red" OR "Blue") tag="New-Arrival" tag=(NOT "promotional")
  ///  * filterOutOfStockItems  tag=(-"promotional")
  ///  * filterOutOfStockItems
  ///
  /// If your filter blocks all prediction results, nothing will be returned. If
  /// you want generic (unfiltered) popular products to be returned instead, set
  /// `strictFiltering` to false in `PredictRequest.params`.
  public var filter: String = String()

  /// Use validate only mode for this prediction query. If set to true, a
  /// dummy model will be used that returns arbitrary products.
  /// Note that the validate only mode should only be used for testing the API,
  /// or if the model is not ready.
  public var validateOnly: Bool = false

  /// Additional domain specific parameters for the predictions.
  ///
  /// Allowed values:
  ///
  /// * `returnProduct`: Boolean. If set to true, the associated product
  ///    object will be returned in the `results.metadata` field in the
  ///    prediction response.
  /// * `returnScore`: Boolean. If set to true, the prediction 'score'
  ///    corresponding to each returned product will be set in the
  ///    `results.metadata` field in the prediction response. The given
  ///    'score' indicates the probability of an product being clicked/purchased
  ///    given the user's context and history.
  /// * `strictFiltering`: Boolean. True by default. If set to false, the service
  ///    will return generic (unfiltered) popular products instead of empty if
  ///    your filter blocks all prediction results.
  public var params: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  /// The labels for the predict request.
  ///
  ///  * Label keys can contain lowercase letters, digits and hyphens, must start
  ///    with a letter, and must end with a letter or digit.
  ///  * Non-zero label values can contain lowercase letters, digits and hyphens,
  ///    must start with a letter, and must end with a letter or digit.
  ///  * No more than 64 labels can be associated with a given request.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userEvent: Google_Cloud_Retail_V2alpha_UserEvent? = nil
}

/// Response message for predict method.
public struct Google_Cloud_Retail_V2alpha_PredictResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of recommended products. The order represents the ranking (from the
  /// most relevant product to the least).
  public var results: [Google_Cloud_Retail_V2alpha_PredictResponse.PredictionResult] = []

  /// A unique attribution token. This should be included in the
  /// [UserEvent][google.cloud.retail.v2alpha.UserEvent] logs resulting from this
  /// recommendation, which enables accurate attribution of recommendation model
  /// performance.
  public var attributionToken: String = String()

  /// IDs of products in the request that were missing from the inventory.
  public var missingIds: [String] = []

  /// True if the validateOnly property was set in the request.
  public var validateOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// PredictionResult represents the recommendation prediction results.
  public struct PredictionResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the recommended product
    public var id: String = String()

    /// Additional product metadata / annotations.
    ///
    /// Possible values:
    ///
    /// * `product`: JSON representation of the product. Will be set if
    ///   `returnProduct` is set to true in `PredictRequest.params`.
    /// * `score`: Prediction score in double value. Will be set if
    ///   `returnScore` is set to true in `PredictRequest.params`.
    public var metadata: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.retail.v2alpha"

extension Google_Cloud_Retail_V2alpha_PredictRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "placement"),
    2: .standard(proto: "user_event"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .same(proto: "filter"),
    6: .standard(proto: "validate_only"),
    7: .same(proto: "params"),
    8: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.placement) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userEvent) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.validateOnly) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.params) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.placement.isEmpty {
      try visitor.visitSingularStringField(value: self.placement, fieldNumber: 1)
    }
    if let v = self._userEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    if self.validateOnly != false {
      try visitor.visitSingularBoolField(value: self.validateOnly, fieldNumber: 6)
    }
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.params, fieldNumber: 7)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_PredictRequest, rhs: Google_Cloud_Retail_V2alpha_PredictRequest) -> Bool {
    if lhs.placement != rhs.placement {return false}
    if lhs._userEvent != rhs._userEvent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.validateOnly != rhs.validateOnly {return false}
    if lhs.params != rhs.params {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_PredictResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "attribution_token"),
    3: .standard(proto: "missing_ids"),
    4: .standard(proto: "validate_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attributionToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.missingIds) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.validateOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.attributionToken.isEmpty {
      try visitor.visitSingularStringField(value: self.attributionToken, fieldNumber: 2)
    }
    if !self.missingIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missingIds, fieldNumber: 3)
    }
    if self.validateOnly != false {
      try visitor.visitSingularBoolField(value: self.validateOnly, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_PredictResponse, rhs: Google_Cloud_Retail_V2alpha_PredictResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.attributionToken != rhs.attributionToken {return false}
    if lhs.missingIds != rhs.missingIds {return false}
    if lhs.validateOnly != rhs.validateOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_PredictResponse.PredictionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Retail_V2alpha_PredictResponse.protoMessageName + ".PredictionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.metadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_PredictResponse.PredictionResult, rhs: Google_Cloud_Retail_V2alpha_PredictResponse.PredictionResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

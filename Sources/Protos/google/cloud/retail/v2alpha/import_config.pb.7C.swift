// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/retail/v2alpha/import_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Google Cloud Storage location for input content.
/// format.
public struct Google_Cloud_Retail_V2alpha_GcsSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Google Cloud Storage URIs to input files. URI can be up to
  /// 2000 characters long. URIs can match the full object path (for example,
  /// gs://bucket/directory/object.json) or a pattern matching one or more
  /// files, such as gs://bucket/directory/*.json. A request can
  /// contain at most 100 files, and each file can be up to 2 GB. See
  /// [Importing product information](/recommendations-ai/docs/upload-catalog)
  /// for the expected file format and setup instructions.
  public var inputUris: [String] = []

  /// The schema to use when parsing the data from the source.
  ///
  /// Supported values for product imports:
  ///
  ///  1: "product" using
  ///    https://cloud.google.com/recommendations-ai/docs/upload-catalog#json
  ///    (Default for products.import)
  ///
  ///  2: "product_merchant_center" using
  ///    https://cloud.google.com/recommendations-ai/docs/upload-catalog#mc
  ///
  /// Supported values for user events imports:
  ///
  ///  1: "user_event" using
  ///  https://cloud.google.com/recommendations-ai/docs/manage-user-events#import
  ///  (Default for userEvents.import)
  ///
  ///  2. "user_event_ga360" using
  ///  https://support.google.com/analytics/answer/3437719?hl=en
  public var dataSchema: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// BigQuery source import data from.
public struct Google_Cloud_Retail_V2alpha_BigQuerySource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The project id (can be project # or id) that the BigQuery source is in with
  /// a length limit of 128 characters. If not specified, inherits the project
  /// id from the parent request.
  public var projectID: String = String()

  /// Required. The BigQuery data set to copy the data from with a length limit
  /// of 1,024 characters.
  public var datasetID: String = String()

  /// Required. The BigQuery table to copy the data from with a length limit of
  /// 1,024 characters.
  public var tableID: String = String()

  /// Intermediate Cloud Storage directory used for the import with a length
  /// limit of 2,000 characters. Can be specified if one wants to have the
  /// BigQuery export to a specific Cloud Storage directory.
  public var gcsStagingDir: String = String()

  /// The schema to use when parsing the data from the source.
  ///
  /// Supported values for catalog imports:
  ///
  ///  1: "product" using
  ///    https://cloud.google.com/recommendations-ai/docs/upload-catalog#json
  ///    (Default for products.import)
  ///
  ///  2: "product_merchant_center" using
  ///    https://cloud.google.com/recommendations-ai/docs/upload-catalog#mc
  ///
  /// Supported values for user event imports:
  ///
  ///  1: "user_event" using
  ///  https://cloud.google.com/recommendations-ai/docs/manage-user-events#import
  ///  (Default for userEvents.import)
  ///
  ///  2. "user_event_ga360" using
  ///  https://support.google.com/analytics/answer/3437719?hl=en
  public var dataSchema: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The inline source for the input config for ImportProducts method.
public struct Google_Cloud_Retail_V2alpha_ProductInlineSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A list of products to update/create. Recommended max of 10k
  /// items.
  public var products: [Google_Cloud_Retail_V2alpha_Product] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The inline source for the input config for ImportUserEvents method.
public struct Google_Cloud_Retail_V2alpha_UserEventInlineSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A list of user events to import. Recommended max of 10k items.
  public var userEvents: [Google_Cloud_Retail_V2alpha_UserEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration of destination for Import related errors.
public struct Google_Cloud_Retail_V2alpha_ImportErrorsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Errors destination.
  public var destination: Google_Cloud_Retail_V2alpha_ImportErrorsConfig.OneOf_Destination? = nil

  /// Google Cloud Storage path for import errors. This must be an empty,
  /// existing Cloud Storage bucket. Import errors will be written to a file in
  /// this bucket, one per line, as a JSON-encoded
  /// `google.rpc.Status` message.
  public var gcsPrefix: String {
    get {
      if case .gcsPrefix(let v)? = destination {return v}
      return String()
    }
    set {destination = .gcsPrefix(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Errors destination.
  public enum OneOf_Destination: Equatable {
    /// Google Cloud Storage path for import errors. This must be an empty,
    /// existing Cloud Storage bucket. Import errors will be written to a file in
    /// this bucket, one per line, as a JSON-encoded
    /// `google.rpc.Status` message.
    case gcsPrefix(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportErrorsConfig.OneOf_Destination, rhs: Google_Cloud_Retail_V2alpha_ImportErrorsConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsPrefix, .gcsPrefix): return {
        guard case .gcsPrefix(let l) = lhs, case .gcsPrefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Request message for Import methods.
public struct Google_Cloud_Retail_V2alpha_ImportProductsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  /// "projects/1234/locations/global/catalogs/default_catalog/branches/default_branch"
  ///
  /// If no updateMask is specified, requires products.create permission.
  /// If updateMask is specified, requires products.update permission.
  public var parent: String = String()

  /// Required. The desired input location of the data.
  public var inputConfig: Google_Cloud_Retail_V2alpha_ProductInputConfig {
    get {return _inputConfig ?? Google_Cloud_Retail_V2alpha_ProductInputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  public var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInputConfig() {self._inputConfig = nil}

  /// The desired location of errors incurred during the Import.
  public var errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Retail_V2alpha_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  /// Indicates which fields in the provided imported 'products' to update. If
  /// not set, will by default update all fields.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputConfig: Google_Cloud_Retail_V2alpha_ProductInputConfig? = nil
  fileprivate var _errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for the ImportUserEvents request.
public struct Google_Cloud_Retail_V2alpha_ImportUserEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. "projects/1234/locations/global/catalogs/default_catalog"
  public var parent: String = String()

  /// Required. The desired input location of the data.
  public var inputConfig: Google_Cloud_Retail_V2alpha_UserEventInputConfig {
    get {return _inputConfig ?? Google_Cloud_Retail_V2alpha_UserEventInputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  public var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInputConfig() {self._inputConfig = nil}

  /// The desired location of errors incurred during the Import. Cannot be set
  /// for inline user event imports.
  public var errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Retail_V2alpha_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputConfig: Google_Cloud_Retail_V2alpha_UserEventInputConfig? = nil
  fileprivate var _errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig? = nil
}

/// The input config source for products.
public struct Google_Cloud_Retail_V2alpha_ProductInputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The source of the input.
  public var source: Google_Cloud_Retail_V2alpha_ProductInputConfig.OneOf_Source? = nil

  /// The Inline source for the input content for products.
  public var productInlineSource: Google_Cloud_Retail_V2alpha_ProductInlineSource {
    get {
      if case .productInlineSource(let v)? = source {return v}
      return Google_Cloud_Retail_V2alpha_ProductInlineSource()
    }
    set {source = .productInlineSource(newValue)}
  }

  /// Google Cloud Storage location for the input content.
  public var gcsSource: Google_Cloud_Retail_V2alpha_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Retail_V2alpha_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  /// BigQuery input source.
  public var bigQuerySource: Google_Cloud_Retail_V2alpha_BigQuerySource {
    get {
      if case .bigQuerySource(let v)? = source {return v}
      return Google_Cloud_Retail_V2alpha_BigQuerySource()
    }
    set {source = .bigQuerySource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The source of the input.
  public enum OneOf_Source: Equatable {
    /// The Inline source for the input content for products.
    case productInlineSource(Google_Cloud_Retail_V2alpha_ProductInlineSource)
    /// Google Cloud Storage location for the input content.
    case gcsSource(Google_Cloud_Retail_V2alpha_GcsSource)
    /// BigQuery input source.
    case bigQuerySource(Google_Cloud_Retail_V2alpha_BigQuerySource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Retail_V2alpha_ProductInputConfig.OneOf_Source, rhs: Google_Cloud_Retail_V2alpha_ProductInputConfig.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.productInlineSource, .productInlineSource): return {
        guard case .productInlineSource(let l) = lhs, case .productInlineSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsSource, .gcsSource): return {
        guard case .gcsSource(let l) = lhs, case .gcsSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigQuerySource, .bigQuerySource): return {
        guard case .bigQuerySource(let l) = lhs, case .bigQuerySource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The input config source for user events.
public struct Google_Cloud_Retail_V2alpha_UserEventInputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The source of the input.
  public var source: Google_Cloud_Retail_V2alpha_UserEventInputConfig.OneOf_Source? = nil

  /// Required. The Inline source for the input content for UserEvents.
  public var userEventInlineSource: Google_Cloud_Retail_V2alpha_UserEventInlineSource {
    get {
      if case .userEventInlineSource(let v)? = source {return v}
      return Google_Cloud_Retail_V2alpha_UserEventInlineSource()
    }
    set {source = .userEventInlineSource(newValue)}
  }

  /// Required. Google Cloud Storage location for the input content.
  public var gcsSource: Google_Cloud_Retail_V2alpha_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Retail_V2alpha_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  /// Required. BigQuery input source.
  public var bigQuerySource: Google_Cloud_Retail_V2alpha_BigQuerySource {
    get {
      if case .bigQuerySource(let v)? = source {return v}
      return Google_Cloud_Retail_V2alpha_BigQuerySource()
    }
    set {source = .bigQuerySource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The source of the input.
  public enum OneOf_Source: Equatable {
    /// Required. The Inline source for the input content for UserEvents.
    case userEventInlineSource(Google_Cloud_Retail_V2alpha_UserEventInlineSource)
    /// Required. Google Cloud Storage location for the input content.
    case gcsSource(Google_Cloud_Retail_V2alpha_GcsSource)
    /// Required. BigQuery input source.
    case bigQuerySource(Google_Cloud_Retail_V2alpha_BigQuerySource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Retail_V2alpha_UserEventInputConfig.OneOf_Source, rhs: Google_Cloud_Retail_V2alpha_UserEventInputConfig.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.userEventInlineSource, .userEventInlineSource): return {
        guard case .userEventInlineSource(let l) = lhs, case .userEventInlineSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsSource, .gcsSource): return {
        guard case .gcsSource(let l) = lhs, case .gcsSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigQuerySource, .bigQuerySource): return {
        guard case .bigQuerySource(let l) = lhs, case .bigQuerySource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Metadata related to the progress of the Import operation. This will be
/// returned by the google.longrunning.Operation.metadata field.
public struct Google_Cloud_Retail_V2alpha_ImportMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operation create time.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Operation last update time. If the operation is done, this is also the
  /// finish time.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Count of entries that were processed successfully.
  public var successCount: Int64 = 0

  /// Count of entries that encountered errors while processing.
  public var failureCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Response of the
/// [ImportProductsRequest][google.cloud.retail.v2alpha.ImportProductsRequest].
/// If the long running operation is done, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
public struct Google_Cloud_Retail_V2alpha_ImportProductsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sample of errors encountered while processing the request.
  public var errorSamples: [Google_Rpc_Status] = []

  /// Echoes the destination for the complete errors in the request if set.
  public var errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Retail_V2alpha_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig? = nil
}

/// Response of the ImportUserEventsRequest. If the long running
/// operation was successful, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
public struct Google_Cloud_Retail_V2alpha_ImportUserEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sample of errors encountered while processing the request.
  public var errorSamples: [Google_Rpc_Status] = []

  /// Echoes the destination for the complete errors if this field was set in
  /// the request.
  public var errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Retail_V2alpha_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  /// Aggregated statistics of user event import status.
  public var importSummary: Google_Cloud_Retail_V2alpha_UserEventImportSummary {
    get {return _importSummary ?? Google_Cloud_Retail_V2alpha_UserEventImportSummary()}
    set {_importSummary = newValue}
  }
  /// Returns true if `importSummary` has been explicitly set.
  public var hasImportSummary: Bool {return self._importSummary != nil}
  /// Clears the value of `importSummary`. Subsequent reads from it will return its default value.
  public mutating func clearImportSummary() {self._importSummary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorsConfig: Google_Cloud_Retail_V2alpha_ImportErrorsConfig? = nil
  fileprivate var _importSummary: Google_Cloud_Retail_V2alpha_UserEventImportSummary? = nil
}

/// A summary of import result. The UserEventImportSummary summarizes
/// the import status for user events.
public struct Google_Cloud_Retail_V2alpha_UserEventImportSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of user events imported with complete existing catalog information.
  public var joinedEventsCount: Int64 = 0

  /// Count of user events imported, but with catalog information not found
  /// in the imported catalog.
  public var unjoinedEventsCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.retail.v2alpha"

extension Google_Cloud_Retail_V2alpha_GcsSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_uris"),
    2: .standard(proto: "data_schema"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.inputUris) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dataSchema) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputUris, fieldNumber: 1)
    }
    if !self.dataSchema.isEmpty {
      try visitor.visitSingularStringField(value: self.dataSchema, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_GcsSource, rhs: Google_Cloud_Retail_V2alpha_GcsSource) -> Bool {
    if lhs.inputUris != rhs.inputUris {return false}
    if lhs.dataSchema != rhs.dataSchema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_BigQuerySource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQuerySource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "project_id"),
    1: .standard(proto: "dataset_id"),
    2: .standard(proto: "table_id"),
    3: .standard(proto: "gcs_staging_dir"),
    4: .standard(proto: "data_schema"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tableID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.gcsStagingDir) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dataSchema) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    if !self.tableID.isEmpty {
      try visitor.visitSingularStringField(value: self.tableID, fieldNumber: 2)
    }
    if !self.gcsStagingDir.isEmpty {
      try visitor.visitSingularStringField(value: self.gcsStagingDir, fieldNumber: 3)
    }
    if !self.dataSchema.isEmpty {
      try visitor.visitSingularStringField(value: self.dataSchema, fieldNumber: 4)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_BigQuerySource, rhs: Google_Cloud_Retail_V2alpha_BigQuerySource) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.tableID != rhs.tableID {return false}
    if lhs.gcsStagingDir != rhs.gcsStagingDir {return false}
    if lhs.dataSchema != rhs.dataSchema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ProductInlineSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductInlineSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "products"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.products) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.products.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.products, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ProductInlineSource, rhs: Google_Cloud_Retail_V2alpha_ProductInlineSource) -> Bool {
    if lhs.products != rhs.products {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_UserEventInlineSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserEventInlineSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userEvents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_UserEventInlineSource, rhs: Google_Cloud_Retail_V2alpha_UserEventInlineSource) -> Bool {
    if lhs.userEvents != rhs.userEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ImportErrorsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportErrorsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.destination != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.destination = .gcsPrefix(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .gcsPrefix(let v)? = self.destination {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportErrorsConfig, rhs: Google_Cloud_Retail_V2alpha_ImportErrorsConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ImportProductsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportProductsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "input_config"),
    3: .standard(proto: "errors_config"),
    4: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportProductsRequest, rhs: Google_Cloud_Retail_V2alpha_ImportProductsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ImportUserEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportUserEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "input_config"),
    3: .standard(proto: "errors_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportUserEventsRequest, rhs: Google_Cloud_Retail_V2alpha_ImportUserEventsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ProductInputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProductInputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "product_inline_source"),
    2: .standard(proto: "gcs_source"),
    3: .standard(proto: "big_query_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Retail_V2alpha_ProductInlineSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .productInlineSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .productInlineSource(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Retail_V2alpha_GcsSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .gcsSource(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Retail_V2alpha_BigQuerySource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .bigQuerySource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .bigQuerySource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .productInlineSource?: try {
      guard case .productInlineSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gcsSource?: try {
      guard case .gcsSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bigQuerySource?: try {
      guard case .bigQuerySource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ProductInputConfig, rhs: Google_Cloud_Retail_V2alpha_ProductInputConfig) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_UserEventInputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserEventInputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_event_inline_source"),
    2: .standard(proto: "gcs_source"),
    3: .standard(proto: "big_query_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Retail_V2alpha_UserEventInlineSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .userEventInlineSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .userEventInlineSource(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Retail_V2alpha_GcsSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .gcsSource(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Retail_V2alpha_BigQuerySource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .bigQuerySource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .bigQuerySource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .userEventInlineSource?: try {
      guard case .userEventInlineSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gcsSource?: try {
      guard case .gcsSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .bigQuerySource?: try {
      guard case .bigQuerySource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_UserEventInputConfig, rhs: Google_Cloud_Retail_V2alpha_UserEventInputConfig) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ImportMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_time"),
    2: .standard(proto: "update_time"),
    3: .standard(proto: "success_count"),
    4: .standard(proto: "failure_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.successCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.failureCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.successCount != 0 {
      try visitor.visitSingularInt64Field(value: self.successCount, fieldNumber: 3)
    }
    if self.failureCount != 0 {
      try visitor.visitSingularInt64Field(value: self.failureCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportMetadata, rhs: Google_Cloud_Retail_V2alpha_ImportMetadata) -> Bool {
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.successCount != rhs.successCount {return false}
    if lhs.failureCount != rhs.failureCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ImportProductsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportProductsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_samples"),
    2: .standard(proto: "errors_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errorSamples) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorSamples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorSamples, fieldNumber: 1)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportProductsResponse, rhs: Google_Cloud_Retail_V2alpha_ImportProductsResponse) -> Bool {
    if lhs.errorSamples != rhs.errorSamples {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_ImportUserEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportUserEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_samples"),
    2: .standard(proto: "errors_config"),
    3: .standard(proto: "import_summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errorSamples) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._importSummary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorSamples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorSamples, fieldNumber: 1)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._importSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_ImportUserEventsResponse, rhs: Google_Cloud_Retail_V2alpha_ImportUserEventsResponse) -> Bool {
    if lhs.errorSamples != rhs.errorSamples {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs._importSummary != rhs._importSummary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Retail_V2alpha_UserEventImportSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserEventImportSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "joined_events_count"),
    2: .standard(proto: "unjoined_events_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.joinedEventsCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.unjoinedEventsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.joinedEventsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.joinedEventsCount, fieldNumber: 1)
    }
    if self.unjoinedEventsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.unjoinedEventsCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Retail_V2alpha_UserEventImportSummary, rhs: Google_Cloud_Retail_V2alpha_UserEventImportSummary) -> Bool {
    if lhs.joinedEventsCount != rhs.joinedEventsCount {return false}
    if lhs.unjoinedEventsCount != rhs.unjoinedEventsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

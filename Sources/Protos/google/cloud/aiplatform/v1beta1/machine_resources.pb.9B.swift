// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1beta1/machine_resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specification of a single machine.
public struct Google_Cloud_Aiplatform_V1beta1_MachineSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The type of the machine.
  /// Following machine types are supported:
  ///
  /// * `n1-standard-2`
  ///
  /// * `n1-standard-4`
  ///
  /// * `n1-standard-8`
  ///
  /// * `n1-standard-16`
  ///
  /// * `n1-standard-32`
  ///
  /// * `n1-highmem-2`
  ///
  /// * `n1-highmem-4`
  ///
  /// * `n1-highmem-8`
  ///
  /// * `n1-highmem-16`
  ///
  /// * `n1-highmem-32`
  ///
  /// * `n1-highcpu-2`
  ///
  /// * `n1-highcpu-4`
  ///
  /// * `n1-highcpu-8`
  ///
  /// * `n1-highcpu-16`
  ///
  /// * `n1-highcpu-32`
  ///
  /// When used for [DeployedMode][] this field is optional and the default value
  /// is `n1-standard-2`. If used for [BatchPredictionJob][google.cloud.aiplatform.v1beta1.BatchPredictionJob] or as part of
  /// [WorkerPoolSpec][google.cloud.aiplatform.v1beta1.WorkerPoolSpec] this field is required.
  public var machineType: String = String()

  /// Immutable. The type of accelerator(s) that may be attached to the machine as per
  /// [accelerator_count][google.cloud.aiplatform.v1beta1.MachineSpec.accelerator_count].
  public var acceleratorType: Google_Cloud_Aiplatform_V1beta1_AcceleratorType = .unspecified

  /// The number of accelerators to attach to the machine.
  public var acceleratorCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A description of resources that are dedicated to a DeployedModel, and
/// that need a higher degree of manual configuration.
public struct Google_Cloud_Aiplatform_V1beta1_DedicatedResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Immutable. The specification of a single machine used by the prediction.
  public var machineSpec: Google_Cloud_Aiplatform_V1beta1_MachineSpec {
    get {return _machineSpec ?? Google_Cloud_Aiplatform_V1beta1_MachineSpec()}
    set {_machineSpec = newValue}
  }
  /// Returns true if `machineSpec` has been explicitly set.
  public var hasMachineSpec: Bool {return self._machineSpec != nil}
  /// Clears the value of `machineSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMachineSpec() {self._machineSpec = nil}

  /// Required. Immutable. The minimum number of machine replicas this DeployedModel will be always
  /// deployed on. If traffic against it increases, it may dynamically be
  /// deployed onto more replicas, and as traffic decreases, some of these extra
  /// replicas may be freed.
  /// Note: if [machine_spec.accelerator_count][google.cloud.aiplatform.v1beta1.MachineSpec.accelerator_count] is
  /// above 0, currently the model will be always deployed precisely on
  /// [min_replica_count][google.cloud.aiplatform.v1beta1.DedicatedResources.min_replica_count].
  public var minReplicaCount: Int32 = 0

  /// Immutable. The maximum number of replicas this DeployedModel may be deployed on when
  /// the traffic against it increases. If requested value is too large,
  /// the deployment will error, but if deployment succeeds then the ability
  /// to scale the model to that many replicas is guaranteed (barring service
  /// outages). If traffic against the DeployedModel increases beyond what its
  /// replicas at maximum may handle, a portion of the traffic will be dropped.
  /// If this value is not provided, will use [min_replica_count][google.cloud.aiplatform.v1beta1.DedicatedResources.min_replica_count] as the
  /// default value.
  public var maxReplicaCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _machineSpec: Google_Cloud_Aiplatform_V1beta1_MachineSpec? = nil
}

/// A description of resources that to large degree are decided by AI Platform,
/// and require only a modest additional configuration.
/// Each Model supporting these resources documents its specific guidelines.
public struct Google_Cloud_Aiplatform_V1beta1_AutomaticResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The minimum number of replicas this DeployedModel will be always deployed
  /// on. If traffic against it increases, it may dynamically be deployed onto
  /// more replicas up to [max_replica_count][google.cloud.aiplatform.v1beta1.AutomaticResources.max_replica_count], and as traffic decreases, some
  /// of these extra replicas may be freed.
  /// If requested value is too large, the deployment will error.
  public var minReplicaCount: Int32 = 0

  /// Immutable. The maximum number of replicas this DeployedModel may be deployed on when
  /// the traffic against it increases. If requested value is too large,
  /// the deployment will error, but if deployment succeeds then the ability
  /// to scale the model to that many replicas is guaranteed (barring service
  /// outages). If traffic against the DeployedModel increases beyond what its
  /// replicas at maximum may handle, a portion of the traffic will be dropped.
  /// If this value is not provided, a no upper bound for scaling under heavy
  /// traffic will be assume, though AI Platform may be unable to scale beyond
  /// certain replica number.
  public var maxReplicaCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A description of resources that are used for performing batch operations, are
/// dedicated to a Model, and need manual configuration.
public struct Google_Cloud_Aiplatform_V1beta1_BatchDedicatedResources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Immutable. The specification of a single machine.
  public var machineSpec: Google_Cloud_Aiplatform_V1beta1_MachineSpec {
    get {return _machineSpec ?? Google_Cloud_Aiplatform_V1beta1_MachineSpec()}
    set {_machineSpec = newValue}
  }
  /// Returns true if `machineSpec` has been explicitly set.
  public var hasMachineSpec: Bool {return self._machineSpec != nil}
  /// Clears the value of `machineSpec`. Subsequent reads from it will return its default value.
  public mutating func clearMachineSpec() {self._machineSpec = nil}

  /// Immutable. The number of machine replicas used at the start of the batch operation.
  /// If not set, AI Platform decides starting number, not greater than
  /// [max_replica_count][google.cloud.aiplatform.v1beta1.BatchDedicatedResources.max_replica_count]
  public var startingReplicaCount: Int32 = 0

  /// Immutable. The maximum number of machine replicas the batch operation may be scaled
  /// to. The default value is 10.
  public var maxReplicaCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _machineSpec: Google_Cloud_Aiplatform_V1beta1_MachineSpec? = nil
}

/// Statistics information about resource consumption.
public struct Google_Cloud_Aiplatform_V1beta1_ResourcesConsumed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The number of replica hours used. Note that many replicas may run in
  /// parallel, and additionally any given work may be queued for some time.
  /// Therefore this value is not strictly related to wall time.
  public var replicaHours: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents the spec of disk options.
public struct Google_Cloud_Aiplatform_V1beta1_DiskSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of the boot disk (default is "pd-standard").
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive) or
  /// "pd-standard" (Persistent Disk Hard Disk Drive).
  public var bootDiskType: String = String()

  /// Size in GB of the boot disk (default is 100GB).
  public var bootDiskSizeGb: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1beta1"

extension Google_Cloud_Aiplatform_V1beta1_MachineSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MachineSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "machine_type"),
    2: .standard(proto: "accelerator_type"),
    3: .standard(proto: "accelerator_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.machineType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.acceleratorType) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.acceleratorCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.machineType.isEmpty {
      try visitor.visitSingularStringField(value: self.machineType, fieldNumber: 1)
    }
    if self.acceleratorType != .unspecified {
      try visitor.visitSingularEnumField(value: self.acceleratorType, fieldNumber: 2)
    }
    if self.acceleratorCount != 0 {
      try visitor.visitSingularInt32Field(value: self.acceleratorCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_MachineSpec, rhs: Google_Cloud_Aiplatform_V1beta1_MachineSpec) -> Bool {
    if lhs.machineType != rhs.machineType {return false}
    if lhs.acceleratorType != rhs.acceleratorType {return false}
    if lhs.acceleratorCount != rhs.acceleratorCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_DedicatedResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DedicatedResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "machine_spec"),
    2: .standard(proto: "min_replica_count"),
    3: .standard(proto: "max_replica_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._machineSpec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minReplicaCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxReplicaCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._machineSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.minReplicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minReplicaCount, fieldNumber: 2)
    }
    if self.maxReplicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxReplicaCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_DedicatedResources, rhs: Google_Cloud_Aiplatform_V1beta1_DedicatedResources) -> Bool {
    if lhs._machineSpec != rhs._machineSpec {return false}
    if lhs.minReplicaCount != rhs.minReplicaCount {return false}
    if lhs.maxReplicaCount != rhs.maxReplicaCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_AutomaticResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomaticResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_replica_count"),
    2: .standard(proto: "max_replica_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minReplicaCount) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxReplicaCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minReplicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minReplicaCount, fieldNumber: 1)
    }
    if self.maxReplicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxReplicaCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_AutomaticResources, rhs: Google_Cloud_Aiplatform_V1beta1_AutomaticResources) -> Bool {
    if lhs.minReplicaCount != rhs.minReplicaCount {return false}
    if lhs.maxReplicaCount != rhs.maxReplicaCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_BatchDedicatedResources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchDedicatedResources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "machine_spec"),
    2: .standard(proto: "starting_replica_count"),
    3: .standard(proto: "max_replica_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._machineSpec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startingReplicaCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxReplicaCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._machineSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.startingReplicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.startingReplicaCount, fieldNumber: 2)
    }
    if self.maxReplicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxReplicaCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_BatchDedicatedResources, rhs: Google_Cloud_Aiplatform_V1beta1_BatchDedicatedResources) -> Bool {
    if lhs._machineSpec != rhs._machineSpec {return false}
    if lhs.startingReplicaCount != rhs.startingReplicaCount {return false}
    if lhs.maxReplicaCount != rhs.maxReplicaCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_ResourcesConsumed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourcesConsumed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replica_hours"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.replicaHours) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.replicaHours != 0 {
      try visitor.visitSingularDoubleField(value: self.replicaHours, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_ResourcesConsumed, rhs: Google_Cloud_Aiplatform_V1beta1_ResourcesConsumed) -> Bool {
    if lhs.replicaHours != rhs.replicaHours {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_DiskSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiskSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "boot_disk_type"),
    2: .standard(proto: "boot_disk_size_gb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bootDiskType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.bootDiskSizeGb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bootDiskType.isEmpty {
      try visitor.visitSingularStringField(value: self.bootDiskType, fieldNumber: 1)
    }
    if self.bootDiskSizeGb != 0 {
      try visitor.visitSingularInt32Field(value: self.bootDiskSizeGb, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_DiskSpec, rhs: Google_Cloud_Aiplatform_V1beta1_DiskSpec) -> Bool {
    if lhs.bootDiskType != rhs.bootDiskType {return false}
    if lhs.bootDiskSizeGb != rhs.bootDiskSizeGb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/aiplatform/v1beta1/explanation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Explanation of a prediction (provided in [PredictResponse.predictions][google.cloud.aiplatform.v1beta1.PredictResponse.predictions])
/// produced by the Model on a given [instance][google.cloud.aiplatform.v1beta1.ExplainRequest.instances].
public struct Google_Cloud_Aiplatform_V1beta1_Explanation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item. [Attribution.output_index][google.cloud.aiplatform.v1beta1.Attribution.output_index] can be used to identify which
  /// output this attribution is explaining.
  ///
  /// If users set [ExplanationParameters.top_k][google.cloud.aiplatform.v1beta1.ExplanationParameters.top_k], the attributions are sorted
  /// by [instance_output_value][Attributions.instance_output_value] in
  /// descending order. If [ExplanationParameters.output_indices][google.cloud.aiplatform.v1beta1.ExplanationParameters.output_indices] is specified,
  /// the attributions are stored by [Attribution.output_index][google.cloud.aiplatform.v1beta1.Attribution.output_index] in the same
  /// order as they appear in the output_indices.
  public var attributions: [Google_Cloud_Aiplatform_V1beta1_Attribution] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Aggregated explanation metrics for a Model over a set of instances.
public struct Google_Cloud_Aiplatform_V1beta1_ModelExplanation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Aggregated attributions explaning the Model's prediction outputs over the
  /// set of instances. The attributions are grouped by outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item. [Attribution.output_index][google.cloud.aiplatform.v1beta1.Attribution.output_index] can be used to identify which
  /// output this attribution is explaining.
  ///
  /// The [baselineOutputValue][google.cloud.aiplatform.v1beta1.Attribution.baseline_output_value],
  /// [instanceOutputValue][google.cloud.aiplatform.v1beta1.Attribution.instance_output_value] and
  /// [featureAttributions][google.cloud.aiplatform.v1beta1.Attribution.feature_attributions] fields are
  /// averaged over the test data.
  ///
  /// NOTE: Currently AutoML tabular classification Models produce only one
  /// attribution, which averages attributions over all the classes it predicts.
  /// [Attribution.approximation_error][google.cloud.aiplatform.v1beta1.Attribution.approximation_error] is not populated.
  public var meanAttributions: [Google_Cloud_Aiplatform_V1beta1_Attribution] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Attribution that explains a particular prediction output.
public struct Google_Cloud_Aiplatform_V1beta1_Attribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Model predicted output if the input instance is constructed from the
  /// baselines of all the features defined in [ExplanationMetadata.inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
  /// The field name of the output is determined by the key in
  /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.outputs].
  ///
  /// If the Model's predicted output has multiple dimensions (rank > 1), this is
  /// the value in the output located by [output_index][google.cloud.aiplatform.v1beta1.Attribution.output_index].
  ///
  /// If there are multiple baselines, their output values are averaged.
  public var baselineOutputValue: Double = 0

  /// Output only. Model predicted output on the corresponding [explanation
  /// instance][ExplainRequest.instances]. The field name of the output is
  /// determined by the key in [ExplanationMetadata.outputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.outputs].
  ///
  /// If the Model predicted output has multiple dimensions, this is the value in
  /// the output located by [output_index][google.cloud.aiplatform.v1beta1.Attribution.output_index].
  public var instanceOutputValue: Double = 0

  /// Output only. Attributions of each explained feature. Features are extracted from
  /// the [prediction instances][google.cloud.aiplatform.v1beta1.ExplainRequest.instances] according to
  /// [explanation metadata for inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
  ///
  /// The value is a struct, whose keys are the name of the feature. The values
  /// are how much the feature in the [instance][google.cloud.aiplatform.v1beta1.ExplainRequest.instances]
  /// contributed to the predicted result.
  ///
  /// The format of the value is determined by the feature's input format:
  ///
  ///   * If the feature is a scalar value, the attribution value is a
  ///     [floating number][google.protobuf.Value.number_value].
  ///
  ///   * If the feature is an array of scalar values, the attribution value is
  ///     an [array][google.protobuf.Value.list_value].
  ///
  ///   * If the feature is a struct, the attribution value is a
  ///     [struct][google.protobuf.Value.struct_value]. The keys in the
  ///     attribution value struct are the same as the keys in the feature
  ///     struct. The formats of the values in the attribution struct are
  ///     determined by the formats of the values in the feature struct.
  ///
  /// The [ExplanationMetadata.feature_attributions_schema_uri][google.cloud.aiplatform.v1beta1.ExplanationMetadata.feature_attributions_schema_uri] field,
  /// pointed to by the [ExplanationSpec][google.cloud.aiplatform.v1beta1.ExplanationSpec] field of the
  /// [Endpoint.deployed_models][google.cloud.aiplatform.v1beta1.Endpoint.deployed_models] object, points to the schema file that
  /// describes the features and their attribution values (if it is populated).
  public var featureAttributions: SwiftProtobuf.Google_Protobuf_Value {
    get {return _featureAttributions ?? SwiftProtobuf.Google_Protobuf_Value()}
    set {_featureAttributions = newValue}
  }
  /// Returns true if `featureAttributions` has been explicitly set.
  public var hasFeatureAttributions: Bool {return self._featureAttributions != nil}
  /// Clears the value of `featureAttributions`. Subsequent reads from it will return its default value.
  public mutating func clearFeatureAttributions() {self._featureAttributions = nil}

  /// Output only. The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th dimension
  /// of the output vector. Indices start from 0.
  public var outputIndex: [Int32] = []

  /// Output only. The display name of the output identified by [output_index][google.cloud.aiplatform.v1beta1.Attribution.output_index], e.g. the
  /// predicted class name by a multi-classification Model.
  ///
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  public var outputDisplayName: String = String()

  /// Output only. Error of [feature_attributions][google.cloud.aiplatform.v1beta1.Attribution.feature_attributions] caused by approximation used in the
  /// explanation method. Lower value means more precise attributions.
  ///
  /// * For [Sampled Shapley
  /// attribution][ExplanationParameters.sampled_shapley_attribution], increasing
  /// [path_count][google.cloud.aiplatform.v1beta1.SampledShapleyAttribution.path_count] may reduce the error.
  /// * For [Integrated Gradients
  /// attribution][ExplanationParameters.integrated_gradients_attribution],
  /// increasing [step_count][google.cloud.aiplatform.v1beta1.IntegratedGradientsAttribution.step_count] may
  /// reduce the error.
  /// * For [XRAI
  /// attribution][ExplanationParameters.xrai_attribution], increasing
  /// [step_count][google.cloud.aiplatform.v1beta1.XraiAttribution.step_count] may reduce the error.
  ///
  /// Refer to  AI Explanations Whitepaper for more details:
  ///
  /// https:
  /// //storage.googleapis.com/cloud-ai-whitep
  /// // apers/AI%20Explainability%20Whitepaper.pdf
  public var approximationError: Double = 0

  /// Output only. Name of the explain output. Specified as the key in
  /// [ExplanationMetadata.outputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.outputs].
  public var outputName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _featureAttributions: SwiftProtobuf.Google_Protobuf_Value? = nil
}

/// Specification of Model explanation.
public struct Google_Cloud_Aiplatform_V1beta1_ExplanationSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parameters that configure explaining of the Model's predictions.
  public var parameters: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters {
    get {return _parameters ?? Google_Cloud_Aiplatform_V1beta1_ExplanationParameters()}
    set {_parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return self._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {self._parameters = nil}

  /// Required. Metadata describing the Model's input and output for explanation.
  public var metadata: Google_Cloud_Aiplatform_V1beta1_ExplanationMetadata {
    get {return _metadata ?? Google_Cloud_Aiplatform_V1beta1_ExplanationMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _parameters: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters? = nil
  fileprivate var _metadata: Google_Cloud_Aiplatform_V1beta1_ExplanationMetadata? = nil
}

/// Parameters to configure explaining for Model's predictions.
public struct Google_Cloud_Aiplatform_V1beta1_ExplanationParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters.OneOf_Method? = nil

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted. A sampling strategy is used to
  /// approximate the value rather than considering all subsets of features.
  /// Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
  public var sampledShapleyAttribution: Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution {
    get {
      if case .sampledShapleyAttribution(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution()
    }
    set {method = .sampledShapleyAttribution(newValue)}
  }

  /// An attribution method that computes Aumann-Shapley values taking
  /// advantage of the model's fully differentiable structure. Refer to this
  /// paper for more details: https://arxiv.org/abs/1703.01365
  public var integratedGradientsAttribution: Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution {
    get {
      if case .integratedGradientsAttribution(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution()
    }
    set {method = .integratedGradientsAttribution(newValue)}
  }

  /// An attribution method that redistributes Integrated Gradients
  /// attribution to segmented regions, taking advantage of the model's fully
  /// differentiable structure. Refer to this paper for
  /// more details: https://arxiv.org/abs/1906.02825
  ///
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  public var xraiAttribution: Google_Cloud_Aiplatform_V1beta1_XraiAttribution {
    get {
      if case .xraiAttribution(let v)? = method {return v}
      return Google_Cloud_Aiplatform_V1beta1_XraiAttribution()
    }
    set {method = .xraiAttribution(newValue)}
  }

  /// If populated, returns attributions for top K indices of outputs
  /// (defaults to 1). Only applies to Models that predicts more than one outputs
  /// (e,g, multi-class Models). When set to -1, returns explanations for all
  /// outputs.
  public var topK: Int32 = 0

  /// If populated, only returns attributions that have
  /// [output_index][Attributions.output_index] contained in output_indices. It
  /// must be an ndarray of integers, with the same shape of the output it's
  /// explaining.
  ///
  /// If not populated, returns attributions for [top_k][google.cloud.aiplatform.v1beta1.ExplanationParameters.top_k] indices of outputs.
  /// If neither top_k nor output_indeices is populated, returns the argmax
  /// index of the outputs.
  ///
  /// Only applicable to Models that predict multiple outputs (e,g, multi-class
  /// Models that predict multiple classes).
  public var outputIndices: SwiftProtobuf.Google_Protobuf_ListValue {
    get {return _outputIndices ?? SwiftProtobuf.Google_Protobuf_ListValue()}
    set {_outputIndices = newValue}
  }
  /// Returns true if `outputIndices` has been explicitly set.
  public var hasOutputIndices: Bool {return self._outputIndices != nil}
  /// Clears the value of `outputIndices`. Subsequent reads from it will return its default value.
  public mutating func clearOutputIndices() {self._outputIndices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Method: Equatable {
    /// An attribution method that approximates Shapley values for features that
    /// contribute to the label being predicted. A sampling strategy is used to
    /// approximate the value rather than considering all subsets of features.
    /// Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
    case sampledShapleyAttribution(Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution)
    /// An attribution method that computes Aumann-Shapley values taking
    /// advantage of the model's fully differentiable structure. Refer to this
    /// paper for more details: https://arxiv.org/abs/1703.01365
    case integratedGradientsAttribution(Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution)
    /// An attribution method that redistributes Integrated Gradients
    /// attribution to segmented regions, taking advantage of the model's fully
    /// differentiable structure. Refer to this paper for
    /// more details: https://arxiv.org/abs/1906.02825
    ///
    /// XRAI currently performs better on natural images, like a picture of a
    /// house or an animal. If the images are taken in artificial environments,
    /// like a lab or manufacturing line, or from diagnostic equipment, like
    /// x-rays or quality-control cameras, use Integrated Gradients instead.
    case xraiAttribution(Google_Cloud_Aiplatform_V1beta1_XraiAttribution)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters.OneOf_Method, rhs: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters.OneOf_Method) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sampledShapleyAttribution, .sampledShapleyAttribution): return {
        guard case .sampledShapleyAttribution(let l) = lhs, case .sampledShapleyAttribution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integratedGradientsAttribution, .integratedGradientsAttribution): return {
        guard case .integratedGradientsAttribution(let l) = lhs, case .integratedGradientsAttribution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.xraiAttribution, .xraiAttribution): return {
        guard case .xraiAttribution(let l) = lhs, case .xraiAttribution(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _outputIndices: SwiftProtobuf.Google_Protobuf_ListValue? = nil
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted. A sampling strategy is used to
/// approximate the value rather than considering all subsets of features.
public struct Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The number of feature permutations to consider when approximating the
  /// Shapley values.
  ///
  /// Valid range of its value is [1, 50], inclusively.
  public var pathCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An attribution method that computes the Aumann-Shapley value taking advantage
/// of the model's fully differentiable structure. Refer to this paper for
/// more details: https://arxiv.org/abs/1703.01365
public struct Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  public var stepCount: Int32 = 0

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  public var smoothGradConfig: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig {
    get {return _smoothGradConfig ?? Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig()}
    set {_smoothGradConfig = newValue}
  }
  /// Returns true if `smoothGradConfig` has been explicitly set.
  public var hasSmoothGradConfig: Bool {return self._smoothGradConfig != nil}
  /// Clears the value of `smoothGradConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSmoothGradConfig() {self._smoothGradConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _smoothGradConfig: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig? = nil
}

/// An explanation method that redistributes Integrated Gradients
/// attributions to segmented regions, taking advantage of the model's fully
/// differentiable structure. Refer to this paper for more details:
/// https://arxiv.org/abs/1906.02825
///
/// Only supports image Models ([modality][InputMetadata.modality] is IMAGE).
public struct Google_Cloud_Aiplatform_V1beta1_XraiAttribution {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is met within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  public var stepCount: Int32 = 0

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  public var smoothGradConfig: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig {
    get {return _smoothGradConfig ?? Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig()}
    set {_smoothGradConfig = newValue}
  }
  /// Returns true if `smoothGradConfig` has been explicitly set.
  public var hasSmoothGradConfig: Bool {return self._smoothGradConfig != nil}
  /// Clears the value of `smoothGradConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSmoothGradConfig() {self._smoothGradConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _smoothGradConfig: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig? = nil
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
public struct Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Represents the standard deviation of the gaussian kernel
  /// that will be used to add noise to the interpolated inputs
  /// prior to computing gradients.
  public var gradientNoiseSigma: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig.OneOf_GradientNoiseSigma? = nil

  /// This is a single float value and will be used to add noise to all the
  /// features. Use this field when all features are normalized to have the
  /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Refer to
  /// this doc for more details about normalization:
  ///
  /// https:
  /// //developers.google.com/machine-learning
  /// // /data-prep/transform/normalization.
  ///
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1.
  ///
  /// If the distribution is different per feature, set
  /// [feature_noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.feature_noise_sigma] instead
  /// for each feature.
  public var noiseSigma: Float {
    get {
      if case .noiseSigma(let v)? = gradientNoiseSigma {return v}
      return 0
    }
    set {gradientNoiseSigma = .noiseSigma(newValue)}
  }

  /// This is similar to [noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.noise_sigma], but
  /// provides additional flexibility. A separate noise sigma can be provided
  /// for each feature, which is useful if their distributions are different.
  /// No noise is added to features that are not set. If this field is unset,
  /// [noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.noise_sigma] will be used for all
  /// features.
  public var featureNoiseSigma: Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma {
    get {
      if case .featureNoiseSigma(let v)? = gradientNoiseSigma {return v}
      return Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma()
    }
    set {gradientNoiseSigma = .featureNoiseSigma(newValue)}
  }

  /// The number of gradient samples to use for
  /// approximation. The higher this number, the more accurate the gradient
  /// is, but the runtime complexity increases by this factor as well.
  /// Valid range of its value is [1, 50]. Defaults to 3.
  public var noisySampleCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents the standard deviation of the gaussian kernel
  /// that will be used to add noise to the interpolated inputs
  /// prior to computing gradients.
  public enum OneOf_GradientNoiseSigma: Equatable {
    /// This is a single float value and will be used to add noise to all the
    /// features. Use this field when all features are normalized to have the
    /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
    /// features are normalized to have 0-mean and 1-variance. Refer to
    /// this doc for more details about normalization:
    ///
    /// https:
    /// //developers.google.com/machine-learning
    /// // /data-prep/transform/normalization.
    ///
    /// For best results the recommended value is about 10% - 20% of the standard
    /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
    /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1.
    ///
    /// If the distribution is different per feature, set
    /// [feature_noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.feature_noise_sigma] instead
    /// for each feature.
    case noiseSigma(Float)
    /// This is similar to [noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.noise_sigma], but
    /// provides additional flexibility. A separate noise sigma can be provided
    /// for each feature, which is useful if their distributions are different.
    /// No noise is added to features that are not set. If this field is unset,
    /// [noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.noise_sigma] will be used for all
    /// features.
    case featureNoiseSigma(Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig.OneOf_GradientNoiseSigma, rhs: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig.OneOf_GradientNoiseSigma) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.noiseSigma, .noiseSigma): return {
        guard case .noiseSigma(let l) = lhs, case .noiseSigma(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.featureNoiseSigma, .featureNoiseSigma): return {
        guard case .featureNoiseSigma(let l) = lhs, case .featureNoiseSigma(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Noise sigma by features. Noise sigma represents the standard deviation of the
/// gaussian kernel that will be used to add noise to interpolated inputs prior
/// to computing gradients.
public struct Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Noise sigma per feature. No noise is added to features that are not set.
  public var noiseSigma: [Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma.NoiseSigmaForFeature] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Noise sigma for a single feature.
  public struct NoiseSigmaForFeature {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the input feature for which noise sigma is provided. The
    /// features are defined in
    /// [explanation metadata inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
    public var name: String = String()

    /// This represents the standard deviation of the Gaussian kernel that will
    /// be used to add noise to the feature prior to computing gradients. Similar
    /// to [noise_sigma][google.cloud.aiplatform.v1beta1.SmoothGradConfig.noise_sigma] but represents the
    /// noise added to the current feature. Defaults to 0.1.
    public var sigma: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.aiplatform.v1beta1"

extension Google_Cloud_Aiplatform_V1beta1_Explanation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Explanation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "attributions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.attributions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attributions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_Explanation, rhs: Google_Cloud_Aiplatform_V1beta1_Explanation) -> Bool {
    if lhs.attributions != rhs.attributions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_ModelExplanation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModelExplanation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mean_attributions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.meanAttributions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.meanAttributions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.meanAttributions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_ModelExplanation, rhs: Google_Cloud_Aiplatform_V1beta1_ModelExplanation) -> Bool {
    if lhs.meanAttributions != rhs.meanAttributions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_Attribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Attribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "baseline_output_value"),
    2: .standard(proto: "instance_output_value"),
    3: .standard(proto: "feature_attributions"),
    4: .standard(proto: "output_index"),
    5: .standard(proto: "output_display_name"),
    6: .standard(proto: "approximation_error"),
    7: .standard(proto: "output_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.baselineOutputValue) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.instanceOutputValue) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._featureAttributions) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.outputIndex) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.outputDisplayName) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.approximationError) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.outputName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.baselineOutputValue != 0 {
      try visitor.visitSingularDoubleField(value: self.baselineOutputValue, fieldNumber: 1)
    }
    if self.instanceOutputValue != 0 {
      try visitor.visitSingularDoubleField(value: self.instanceOutputValue, fieldNumber: 2)
    }
    if let v = self._featureAttributions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.outputIndex.isEmpty {
      try visitor.visitPackedInt32Field(value: self.outputIndex, fieldNumber: 4)
    }
    if !self.outputDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.outputDisplayName, fieldNumber: 5)
    }
    if self.approximationError != 0 {
      try visitor.visitSingularDoubleField(value: self.approximationError, fieldNumber: 6)
    }
    if !self.outputName.isEmpty {
      try visitor.visitSingularStringField(value: self.outputName, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_Attribution, rhs: Google_Cloud_Aiplatform_V1beta1_Attribution) -> Bool {
    if lhs.baselineOutputValue != rhs.baselineOutputValue {return false}
    if lhs.instanceOutputValue != rhs.instanceOutputValue {return false}
    if lhs._featureAttributions != rhs._featureAttributions {return false}
    if lhs.outputIndex != rhs.outputIndex {return false}
    if lhs.outputDisplayName != rhs.outputDisplayName {return false}
    if lhs.approximationError != rhs.approximationError {return false}
    if lhs.outputName != rhs.outputName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_ExplanationSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplanationSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parameters"),
    2: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._parameters) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._parameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_ExplanationSpec, rhs: Google_Cloud_Aiplatform_V1beta1_ExplanationSpec) -> Bool {
    if lhs._parameters != rhs._parameters {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_ExplanationParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExplanationParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sampled_shapley_attribution"),
    2: .standard(proto: "integrated_gradients_attribution"),
    3: .standard(proto: "xrai_attribution"),
    4: .standard(proto: "top_k"),
    5: .standard(proto: "output_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution?
        if let current = self.method {
          try decoder.handleConflictingOneOf()
          if case .sampledShapleyAttribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.method = .sampledShapleyAttribution(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution?
        if let current = self.method {
          try decoder.handleConflictingOneOf()
          if case .integratedGradientsAttribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.method = .integratedGradientsAttribution(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Aiplatform_V1beta1_XraiAttribution?
        if let current = self.method {
          try decoder.handleConflictingOneOf()
          if case .xraiAttribution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.method = .xraiAttribution(v)}
      }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.topK) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputIndices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.method {
    case .sampledShapleyAttribution?: try {
      guard case .sampledShapleyAttribution(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .integratedGradientsAttribution?: try {
      guard case .integratedGradientsAttribution(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .xraiAttribution?: try {
      guard case .xraiAttribution(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.topK != 0 {
      try visitor.visitSingularInt32Field(value: self.topK, fieldNumber: 4)
    }
    if let v = self._outputIndices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters, rhs: Google_Cloud_Aiplatform_V1beta1_ExplanationParameters) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.topK != rhs.topK {return false}
    if lhs._outputIndices != rhs._outputIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampledShapleyAttribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pathCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathCount != 0 {
      try visitor.visitSingularInt32Field(value: self.pathCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution, rhs: Google_Cloud_Aiplatform_V1beta1_SampledShapleyAttribution) -> Bool {
    if lhs.pathCount != rhs.pathCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntegratedGradientsAttribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_count"),
    2: .standard(proto: "smooth_grad_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stepCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._smoothGradConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stepCount != 0 {
      try visitor.visitSingularInt32Field(value: self.stepCount, fieldNumber: 1)
    }
    if let v = self._smoothGradConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution, rhs: Google_Cloud_Aiplatform_V1beta1_IntegratedGradientsAttribution) -> Bool {
    if lhs.stepCount != rhs.stepCount {return false}
    if lhs._smoothGradConfig != rhs._smoothGradConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_XraiAttribution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".XraiAttribution"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_count"),
    2: .standard(proto: "smooth_grad_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.stepCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._smoothGradConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.stepCount != 0 {
      try visitor.visitSingularInt32Field(value: self.stepCount, fieldNumber: 1)
    }
    if let v = self._smoothGradConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_XraiAttribution, rhs: Google_Cloud_Aiplatform_V1beta1_XraiAttribution) -> Bool {
    if lhs.stepCount != rhs.stepCount {return false}
    if lhs._smoothGradConfig != rhs._smoothGradConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SmoothGradConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "noise_sigma"),
    2: .standard(proto: "feature_noise_sigma"),
    3: .standard(proto: "noisy_sample_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.gradientNoiseSigma != nil {try decoder.handleConflictingOneOf()}
        var v: Float?
        try decoder.decodeSingularFloatField(value: &v)
        if let v = v {self.gradientNoiseSigma = .noiseSigma(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma?
        if let current = self.gradientNoiseSigma {
          try decoder.handleConflictingOneOf()
          if case .featureNoiseSigma(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.gradientNoiseSigma = .featureNoiseSigma(v)}
      }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.noisySampleCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.gradientNoiseSigma {
    case .noiseSigma?: try {
      guard case .noiseSigma(let v)? = self.gradientNoiseSigma else { preconditionFailure() }
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    }()
    case .featureNoiseSigma?: try {
      guard case .featureNoiseSigma(let v)? = self.gradientNoiseSigma else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if self.noisySampleCount != 0 {
      try visitor.visitSingularInt32Field(value: self.noisySampleCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig, rhs: Google_Cloud_Aiplatform_V1beta1_SmoothGradConfig) -> Bool {
    if lhs.gradientNoiseSigma != rhs.gradientNoiseSigma {return false}
    if lhs.noisySampleCount != rhs.noisySampleCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeatureNoiseSigma"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "noise_sigma"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.noiseSigma) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.noiseSigma.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.noiseSigma, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma, rhs: Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma) -> Bool {
    if lhs.noiseSigma != rhs.noiseSigma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma.NoiseSigmaForFeature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma.protoMessageName + ".NoiseSigmaForFeature"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "sigma"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.sigma) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.sigma != 0 {
      try visitor.visitSingularFloatField(value: self.sigma, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma.NoiseSigmaForFeature, rhs: Google_Cloud_Aiplatform_V1beta1_FeatureNoiseSigma.NoiseSigmaForFeature) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sigma != rhs.sigma {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/video/transcoder/v1beta1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Transcoding job resource.
public struct Google_Cloud_Video_Transcoder_V1beta1_Job {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the job.
  /// Format: `projects/{project}/locations/{location}/jobs/{job}`
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Input only. Specify the `input_uri` to populate empty `uri` fields in each element of
  /// `Job.config.inputs` or `JobTemplate.config.inputs` when using template.
  /// URI of the media. It must be stored in Cloud Storage. For example,
  /// `gs://bucket/inputs/file.mp4`.
  public var inputUri: String {
    get {return _storage._inputUri}
    set {_uniqueStorage()._inputUri = newValue}
  }

  /// Input only. Specify the `output_uri` to populate an empty `Job.config.output.uri` or
  /// `JobTemplate.config.output.uri` when using template.
  /// URI for the output file(s). For example, `gs://my-bucket/outputs/`.
  public var outputUri: String {
    get {return _storage._outputUri}
    set {_uniqueStorage()._outputUri = newValue}
  }

  /// Specify the `job_config` for transcoding job. When you use a `template_id`
  /// to create a job, the `Job.config` is populated by the `JobTemplate.config`.
  public var jobConfig: OneOf_JobConfig? {
    get {return _storage._jobConfig}
    set {_uniqueStorage()._jobConfig = newValue}
  }

  /// Input only. Specify the `template_id` to use for populating `Job.config`. The default
  /// is `preset/web-hd`.
  ///
  /// Preset Transcoder templates:
  /// - `preset/{preset_id}`
  ///
  /// - User defined JobTemplate:
  ///   `{job_template_id}`
  public var templateID: String {
    get {
      if case .templateID(let v)? = _storage._jobConfig {return v}
      return String()
    }
    set {_uniqueStorage()._jobConfig = .templateID(newValue)}
  }

  /// The configuration for this job.
  public var config: Google_Cloud_Video_Transcoder_V1beta1_JobConfig {
    get {
      if case .config(let v)? = _storage._jobConfig {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_JobConfig()
    }
    set {_uniqueStorage()._jobConfig = .config(newValue)}
  }

  /// Specify the priority of the job. Enter a value between 0 and 100, where 0
  /// is the lowest priority and 100 is the highest priority. The default is 0.
  public var priority: Int32 {
    get {return _storage._priority}
    set {_uniqueStorage()._priority = newValue}
  }

  /// Output only. The origin URI.
  public var originUri: Google_Cloud_Video_Transcoder_V1beta1_Job.OriginUri {
    get {return _storage._originUri ?? Google_Cloud_Video_Transcoder_V1beta1_Job.OriginUri()}
    set {_uniqueStorage()._originUri = newValue}
  }
  /// Returns true if `originUri` has been explicitly set.
  public var hasOriginUri: Bool {return _storage._originUri != nil}
  /// Clears the value of `originUri`. Subsequent reads from it will return its default value.
  public mutating func clearOriginUri() {_uniqueStorage()._originUri = nil}

  /// Output only. The current state of the job.
  public var state: Google_Cloud_Video_Transcoder_V1beta1_Job.ProcessingState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. Estimated fractional progress, from `0` to `1` for each
  /// step.
  public var progress: Google_Cloud_Video_Transcoder_V1beta1_Progress {
    get {return _storage._progress ?? Google_Cloud_Video_Transcoder_V1beta1_Progress()}
    set {_uniqueStorage()._progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return _storage._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {_uniqueStorage()._progress = nil}

  /// Output only. A description of the reason for the failure. This property is
  /// always present when `state` is `FAILED`.
  public var failureReason: String {
    get {return _storage._failureReason}
    set {_uniqueStorage()._failureReason = newValue}
  }

  /// Output only. List of failure details. This property may contain additional
  /// information about the failure when `failure_reason` is present.
  public var failureDetails: [Google_Cloud_Video_Transcoder_V1beta1_FailureDetail] {
    get {return _storage._failureDetails}
    set {_uniqueStorage()._failureDetails = newValue}
  }

  /// Output only. The time the job was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time the transcoding started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Output only. The time the transcoding finished.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify the `job_config` for transcoding job. When you use a `template_id`
  /// to create a job, the `Job.config` is populated by the `JobTemplate.config`.
  public enum OneOf_JobConfig: Equatable {
    /// Input only. Specify the `template_id` to use for populating `Job.config`. The default
    /// is `preset/web-hd`.
    ///
    /// Preset Transcoder templates:
    /// - `preset/{preset_id}`
    ///
    /// - User defined JobTemplate:
    ///   `{job_template_id}`
    case templateID(String)
    /// The configuration for this job.
    case config(Google_Cloud_Video_Transcoder_V1beta1_JobConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Job.OneOf_JobConfig, rhs: Google_Cloud_Video_Transcoder_V1beta1_Job.OneOf_JobConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.templateID, .templateID): return {
        guard case .templateID(let l) = lhs, case .templateID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.config, .config): return {
        guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The current state of the job.
  public enum ProcessingState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The processing state is not specified.
    case unspecified // = 0

    /// The job is enqueued and will be picked up for processing soon.
    case pending // = 1

    /// The job is being processed.
    case running // = 2

    /// The job has been completed successfully.
    case succeeded // = 3

    /// The job has failed. For additional information, see `failure_reason` and
    /// `failure_details`
    case failed // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .running
      case 3: self = .succeeded
      case 4: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .running: return 2
      case .succeeded: return 3
      case .failed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The origin URI.
  public struct OriginUri {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// HLS master manifest URI. If multiple HLS master manifests are created
    /// only first one is listed.
    public var hls: String = String()

    /// Dash manifest URI. If multiple Dash manifests are created, only the first
    /// one is listed.
    public var dash: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Video_Transcoder_V1beta1_Job.ProcessingState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Video_Transcoder_V1beta1_Job.ProcessingState] = [
    .unspecified,
    .pending,
    .running,
    .succeeded,
    .failed,
  ]
}

#endif  // swift(>=4.2)

/// Transcoding job template resource.
public struct Google_Cloud_Video_Transcoder_V1beta1_JobTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the job template.
  /// Format:
  /// `projects/{project}/locations/{location}/jobTemplates/{job_template}`
  public var name: String = String()

  /// The configuration for this template.
  public var config: Google_Cloud_Video_Transcoder_V1beta1_JobConfig {
    get {return _config ?? Google_Cloud_Video_Transcoder_V1beta1_JobConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Google_Cloud_Video_Transcoder_V1beta1_JobConfig? = nil
}

/// Job configuration
public struct Google_Cloud_Video_Transcoder_V1beta1_JobConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of input assets stored in Cloud Storage.
  public var inputs: [Google_Cloud_Video_Transcoder_V1beta1_Input] = []

  /// List of `Edit atom`s. Defines the ultimate timeline of the resulting
  /// file or manifest.
  public var editList: [Google_Cloud_Video_Transcoder_V1beta1_EditAtom] = []

  /// List of elementary streams.
  public var elementaryStreams: [Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream] = []

  /// List of multiplexing settings for output streams.
  public var muxStreams: [Google_Cloud_Video_Transcoder_V1beta1_MuxStream] = []

  /// List of output manifests.
  public var manifests: [Google_Cloud_Video_Transcoder_V1beta1_Manifest] = []

  /// Output configuration.
  public var output: Google_Cloud_Video_Transcoder_V1beta1_Output {
    get {return _output ?? Google_Cloud_Video_Transcoder_V1beta1_Output()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  public var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  public mutating func clearOutput() {self._output = nil}

  /// List of ad breaks. Specifies where to insert ad break tags in the output
  /// manifests.
  public var adBreaks: [Google_Cloud_Video_Transcoder_V1beta1_AdBreak] = []

  /// Destination on Pub/Sub.
  public var pubsubDestination: Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination {
    get {return _pubsubDestination ?? Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination()}
    set {_pubsubDestination = newValue}
  }
  /// Returns true if `pubsubDestination` has been explicitly set.
  public var hasPubsubDestination: Bool {return self._pubsubDestination != nil}
  /// Clears the value of `pubsubDestination`. Subsequent reads from it will return its default value.
  public mutating func clearPubsubDestination() {self._pubsubDestination = nil}

  /// List of output sprite sheets.
  public var spriteSheets: [Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet] = []

  /// List of overlays on the output video, in descending Z-order.
  public var overlays: [Google_Cloud_Video_Transcoder_V1beta1_Overlay] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _output: Google_Cloud_Video_Transcoder_V1beta1_Output? = nil
  fileprivate var _pubsubDestination: Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination? = nil
}

/// Input asset.
public struct Google_Cloud_Video_Transcoder_V1beta1_Input {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique key for this input. Must be specified when using advanced
  /// mapping and edit lists.
  public var key: String = String()

  /// URI of the media. It must be stored in Cloud Storage. Example
  /// `gs://bucket/inputs/file.mp4`.
  /// If empty the value will be populated from `Job.input_uri`.
  public var uri: String = String()

  /// Preprocessing configurations.
  public var preprocessingConfig: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig {
    get {return _preprocessingConfig ?? Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig()}
    set {_preprocessingConfig = newValue}
  }
  /// Returns true if `preprocessingConfig` has been explicitly set.
  public var hasPreprocessingConfig: Bool {return self._preprocessingConfig != nil}
  /// Clears the value of `preprocessingConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPreprocessingConfig() {self._preprocessingConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _preprocessingConfig: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig? = nil
}

/// Location of output file(s) in a Cloud Storage bucket.
public struct Google_Cloud_Video_Transcoder_V1beta1_Output {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URI for the output file(s). For example, `gs://my-bucket/outputs/`.
  /// If empty the value is populated from `Job.output_uri`.
  public var uri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Edit atom.
public struct Google_Cloud_Video_Transcoder_V1beta1_EditAtom {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique key for this atom. Must be specified when using advanced
  /// mapping.
  public var key: String = String()

  /// List of `Input.key`s identifying files that should be used in this atom.
  /// The listed `inputs` must have the same timeline.
  public var inputs: [String] = []

  /// End time in seconds for the atom, relative to the input file timeline.
  /// When `end_time_offset` is not specified, the `inputs` are used until
  /// the end of the atom.
  public var endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _endTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_endTimeOffset = newValue}
  }
  /// Returns true if `endTimeOffset` has been explicitly set.
  public var hasEndTimeOffset: Bool {return self._endTimeOffset != nil}
  /// Clears the value of `endTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearEndTimeOffset() {self._endTimeOffset = nil}

  /// Start time in seconds for the atom, relative to the input file timeline.
  /// The default is `0s`.
  public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTimeOffset = newValue}
  }
  /// Returns true if `startTimeOffset` has been explicitly set.
  public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
  /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Ad break.
public struct Google_Cloud_Video_Transcoder_V1beta1_AdBreak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start time in seconds for the ad break, relative to the output file
  /// timeline. The default is `0s`.
  public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTimeOffset = newValue}
  }
  /// Returns true if `startTimeOffset` has been explicitly set.
  public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
  /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Encoding of an input file such as an audio, video, or text track.
/// Elementary streams must be packaged before
/// mapping and sharing between different output formats.
public struct Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique key for this elementary stream.
  public var key: String = String()

  /// Encoding of an audio, video, or text track.
  public var elementaryStream: Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream.OneOf_ElementaryStream? = nil

  /// Encoding of a video stream.
  public var videoStream: Google_Cloud_Video_Transcoder_V1beta1_VideoStream {
    get {
      if case .videoStream(let v)? = elementaryStream {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_VideoStream()
    }
    set {elementaryStream = .videoStream(newValue)}
  }

  /// Encoding of an audio stream.
  public var audioStream: Google_Cloud_Video_Transcoder_V1beta1_AudioStream {
    get {
      if case .audioStream(let v)? = elementaryStream {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_AudioStream()
    }
    set {elementaryStream = .audioStream(newValue)}
  }

  /// Encoding of a text stream. For example, closed captions or subtitles.
  public var textStream: Google_Cloud_Video_Transcoder_V1beta1_TextStream {
    get {
      if case .textStream(let v)? = elementaryStream {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_TextStream()
    }
    set {elementaryStream = .textStream(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Encoding of an audio, video, or text track.
  public enum OneOf_ElementaryStream: Equatable {
    /// Encoding of a video stream.
    case videoStream(Google_Cloud_Video_Transcoder_V1beta1_VideoStream)
    /// Encoding of an audio stream.
    case audioStream(Google_Cloud_Video_Transcoder_V1beta1_AudioStream)
    /// Encoding of a text stream. For example, closed captions or subtitles.
    case textStream(Google_Cloud_Video_Transcoder_V1beta1_TextStream)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream.OneOf_ElementaryStream, rhs: Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream.OneOf_ElementaryStream) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.videoStream, .videoStream): return {
        guard case .videoStream(let l) = lhs, case .videoStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioStream, .audioStream): return {
        guard case .audioStream(let l) = lhs, case .audioStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textStream, .textStream): return {
        guard case .textStream(let l) = lhs, case .textStream(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Multiplexing settings for output stream.
public struct Google_Cloud_Video_Transcoder_V1beta1_MuxStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique key for this multiplexed stream. HLS media manifests will be
  /// named `MuxStream.key` with the `".m3u8"` extension suffix.
  public var key: String = String()

  /// The name of the generated file. The default is `MuxStream.key` with the
  /// extension suffix corresponding to the `MuxStream.container`.
  ///
  /// Individual segments also have an incremental 10-digit zero-padded suffix
  /// starting from 0 before the extension, such as `"mux_stream0000000123.ts"`.
  public var fileName: String = String()

  /// The container format. The default is `"mp4"`
  ///
  /// Supported container formats:
  /// - 'ts'
  /// - 'fmp4'- the corresponding file extension is `".m4s"`
  /// - 'mp4'
  /// - 'vtt'
  public var container: String = String()

  /// List of `ElementaryStream.key`s multiplexed in this stream.
  public var elementaryStreams: [String] = []

  /// Segment settings for `"ts"`, `"fmp4"` and `"vtt"`.
  public var segmentSettings: Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings {
    get {return _segmentSettings ?? Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings()}
    set {_segmentSettings = newValue}
  }
  /// Returns true if `segmentSettings` has been explicitly set.
  public var hasSegmentSettings: Bool {return self._segmentSettings != nil}
  /// Clears the value of `segmentSettings`. Subsequent reads from it will return its default value.
  public mutating func clearSegmentSettings() {self._segmentSettings = nil}

  /// Encryption settings.
  public var encryption: Google_Cloud_Video_Transcoder_V1beta1_Encryption {
    get {return _encryption ?? Google_Cloud_Video_Transcoder_V1beta1_Encryption()}
    set {_encryption = newValue}
  }
  /// Returns true if `encryption` has been explicitly set.
  public var hasEncryption: Bool {return self._encryption != nil}
  /// Clears the value of `encryption`. Subsequent reads from it will return its default value.
  public mutating func clearEncryption() {self._encryption = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _segmentSettings: Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings? = nil
  fileprivate var _encryption: Google_Cloud_Video_Transcoder_V1beta1_Encryption? = nil
}

/// Manifest configuration.
public struct Google_Cloud_Video_Transcoder_V1beta1_Manifest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the generated file. The default is `"manifest"` with the
  /// extension suffix corresponding to the `Manifest.type`.
  public var fileName: String = String()

  /// Required. Type of the manifest, can be "HLS" or "DASH".
  public var type: Google_Cloud_Video_Transcoder_V1beta1_Manifest.ManifestType = .unspecified

  /// Required. List of user given `MuxStream.key`s that should appear in this manifest.
  ///
  /// When `Manifest.type` is `HLS`, a media manifest with name `MuxStream.key`
  /// and `.m3u8` extension is generated for each element of the
  /// `Manifest.mux_streams`.
  public var muxStreams: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The manifest type can be either `"HLS"` or `"DASH"`.
  public enum ManifestType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The manifest type is not specified.
    case unspecified // = 0

    /// Create `"HLS"` manifest. The corresponding file extension is `".m3u8"`.
    case hls // = 1

    /// Create `"DASH"` manifest. The corresponding file extension is `".mpd"`.
    case dash // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .hls
      case 2: self = .dash
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .hls: return 1
      case .dash: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Video_Transcoder_V1beta1_Manifest.ManifestType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Video_Transcoder_V1beta1_Manifest.ManifestType] = [
    .unspecified,
    .hls,
    .dash,
  ]
}

#endif  // swift(>=4.2)

/// A Pub/Sub destination.
public struct Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the Pub/Sub topic to publish job completion notification
  /// to. For example: `projects/{project}/topics/{topic}`.
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Sprite sheet configuration.
public struct Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Format type. The default is `"jpeg"`.
  ///
  /// Supported formats:
  /// - 'jpeg'
  public var format: String = String()

  /// Required. File name prefix for the generated sprite sheets.
  ///
  /// Each sprite sheet has an incremental 10-digit zero-padded suffix starting
  /// from 0 before the extension, such as `"sprite_sheet0000000123.jpeg"`.
  public var filePrefix: String = String()

  /// Required. The width of sprite in pixels. Must be an even integer.
  public var spriteWidthPixels: Int32 = 0

  /// Required. The height of sprite in pixels. Must be an even integer.
  public var spriteHeightPixels: Int32 = 0

  /// The maximum number of sprites per row in a sprite sheet. The default is 0,
  /// which indicates no maximum limit.
  public var columnCount: Int32 = 0

  /// The maximum number of rows per sprite sheet. When the sprite sheet is full,
  /// a new sprite sheet is created. The default is 0, which indicates no maximum
  /// limit.
  public var rowCount: Int32 = 0

  /// Start time in seconds, relative to the output file timeline. Determines the
  /// first sprite to pick. The default is `0s`.
  public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTimeOffset = newValue}
  }
  /// Returns true if `startTimeOffset` has been explicitly set.
  public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
  /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

  /// End time in seconds, relative to the output file timeline. When
  /// `end_time_offset` is not specified, the sprites are generated until the end
  /// of the output file.
  public var endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _endTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_endTimeOffset = newValue}
  }
  /// Returns true if `endTimeOffset` has been explicitly set.
  public var hasEndTimeOffset: Bool {return self._endTimeOffset != nil}
  /// Clears the value of `endTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearEndTimeOffset() {self._endTimeOffset = nil}

  /// Specify either total number of sprites or interval to create sprites.
  public var extractionStrategy: Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet.OneOf_ExtractionStrategy? = nil

  /// Total number of sprites. Create the specified number of sprites
  /// distributed evenly across the timeline of the output media. The default
  /// is 100.
  public var totalCount: Int32 {
    get {
      if case .totalCount(let v)? = extractionStrategy {return v}
      return 0
    }
    set {extractionStrategy = .totalCount(newValue)}
  }

  /// Starting from `0s`, create sprites at regular intervals. Specify the
  /// interval value in seconds.
  public var interval: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .interval(let v)? = extractionStrategy {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {extractionStrategy = .interval(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify either total number of sprites or interval to create sprites.
  public enum OneOf_ExtractionStrategy: Equatable {
    /// Total number of sprites. Create the specified number of sprites
    /// distributed evenly across the timeline of the output media. The default
    /// is 100.
    case totalCount(Int32)
    /// Starting from `0s`, create sprites at regular intervals. Specify the
    /// interval value in seconds.
    case interval(SwiftProtobuf.Google_Protobuf_Duration)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet.OneOf_ExtractionStrategy, rhs: Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet.OneOf_ExtractionStrategy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.totalCount, .totalCount): return {
        guard case .totalCount(let l) = lhs, case .totalCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interval, .interval): return {
        guard case .interval(let l) = lhs, case .interval(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Overlay configuration.
public struct Google_Cloud_Video_Transcoder_V1beta1_Overlay {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Image overlay.
  public var image: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Image {
    get {return _image ?? Google_Cloud_Video_Transcoder_V1beta1_Overlay.Image()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  /// List of Animations. The list should be chronological, without any time
  /// overlap.
  public var animations: [Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Fade type for the overlay: `FADE_IN` or `FADE_OUT`.
  public enum FadeType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The fade type is not specified.
    case unspecified // = 0

    /// Fade the overlay object into view.
    case fadeIn // = 1

    /// Fade the overlay object out of view.
    case fadeOut // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .fadeIn
      case 2: self = .fadeOut
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .fadeIn: return 1
      case .fadeOut: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// 2D normalized coordinates. Default: `{0.0, 0.0}`
  public struct NormalizedCoordinate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Normalized x coordinate.
    public var x: Double = 0

    /// Normalized y coordinate.
    public var y: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Overlaid jpeg image.
  public struct Image {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. URI of the image in Cloud Storage. For example,
    /// `gs://bucket/inputs/image.jpeg`.
    public var uri: String = String()

    /// Normalized image resolution, based on output video resolution. Valid
    /// values: `0.0`–`1.0`. To respect the original image aspect ratio, set
    /// either `x` or `y` to `0.0`. To use the original image resolution, set
    /// both `x` and `y` to `0.0`.
    public var resolution: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate {
      get {return _resolution ?? Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate()}
      set {_resolution = newValue}
    }
    /// Returns true if `resolution` has been explicitly set.
    public var hasResolution: Bool {return self._resolution != nil}
    /// Clears the value of `resolution`. Subsequent reads from it will return its default value.
    public mutating func clearResolution() {self._resolution = nil}

    /// Target image opacity. Valid values: `1` (solid, default),
    /// `0` (transparent).
    public var alpha: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _resolution: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate? = nil
  }

  /// Display static overlay object.
  public struct AnimationStatic {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Normalized coordinates based on output video resolution. Valid
    /// values: `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay
    /// object.
    public var xy: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate {
      get {return _xy ?? Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate()}
      set {_xy = newValue}
    }
    /// Returns true if `xy` has been explicitly set.
    public var hasXy: Bool {return self._xy != nil}
    /// Clears the value of `xy`. Subsequent reads from it will return its default value.
    public mutating func clearXy() {self._xy = nil}

    /// The time to start displaying the overlay object, in seconds. Default: 0
    public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startTimeOffset = newValue}
    }
    /// Returns true if `startTimeOffset` has been explicitly set.
    public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
    /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
    public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _xy: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate? = nil
    fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  /// Display overlay object with fade animation.
  public struct AnimationFade {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Type of fade animation: `FADE_IN` or `FADE_OUT`.
    public var fadeType: Google_Cloud_Video_Transcoder_V1beta1_Overlay.FadeType = .unspecified

    /// Normalized coordinates based on output video resolution. Valid
    /// values: `0.0`–`1.0`. `xy` is the upper-left coordinate of the overlay
    /// object.
    public var xy: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate {
      get {return _xy ?? Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate()}
      set {_xy = newValue}
    }
    /// Returns true if `xy` has been explicitly set.
    public var hasXy: Bool {return self._xy != nil}
    /// Clears the value of `xy`. Subsequent reads from it will return its default value.
    public mutating func clearXy() {self._xy = nil}

    /// The time to start the fade animation, in seconds. Default: 0
    public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startTimeOffset = newValue}
    }
    /// Returns true if `startTimeOffset` has been explicitly set.
    public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
    /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
    public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

    /// The time to end the fade animation, in seconds. Default:
    /// `start_time_offset` + 1s
    public var endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _endTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_endTimeOffset = newValue}
    }
    /// Returns true if `endTimeOffset` has been explicitly set.
    public var hasEndTimeOffset: Bool {return self._endTimeOffset != nil}
    /// Clears the value of `endTimeOffset`. Subsequent reads from it will return its default value.
    public mutating func clearEndTimeOffset() {self._endTimeOffset = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _xy: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate? = nil
    fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  /// End previous overlay animation from the video. Without AnimationEnd, the
  /// overlay object will keep the state of previous animation until the end of
  /// the video.
  public struct AnimationEnd {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The time to end overlay object, in seconds. Default: 0
    public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startTimeOffset = newValue}
    }
    /// Returns true if `startTimeOffset` has been explicitly set.
    public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
    /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
    public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  /// Animation types.
  public struct Animation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Animations can be static or fade, or they can end the previous animation.
    public var animationType: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation.OneOf_AnimationType? = nil

    /// Display static overlay object.
    public var animationStatic: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic {
      get {
        if case .animationStatic(let v)? = animationType {return v}
        return Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic()
      }
      set {animationType = .animationStatic(newValue)}
    }

    /// Display overlay object with fade animation.
    public var animationFade: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade {
      get {
        if case .animationFade(let v)? = animationType {return v}
        return Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade()
      }
      set {animationType = .animationFade(newValue)}
    }

    /// End previous animation.
    public var animationEnd: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd {
      get {
        if case .animationEnd(let v)? = animationType {return v}
        return Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd()
      }
      set {animationType = .animationEnd(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Animations can be static or fade, or they can end the previous animation.
    public enum OneOf_AnimationType: Equatable {
      /// Display static overlay object.
      case animationStatic(Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic)
      /// Display overlay object with fade animation.
      case animationFade(Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade)
      /// End previous animation.
      case animationEnd(Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation.OneOf_AnimationType, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation.OneOf_AnimationType) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.animationStatic, .animationStatic): return {
          guard case .animationStatic(let l) = lhs, case .animationStatic(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.animationFade, .animationFade): return {
          guard case .animationFade(let l) = lhs, case .animationFade(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.animationEnd, .animationEnd): return {
          guard case .animationEnd(let l) = lhs, case .animationEnd(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _image: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Image? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.FadeType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Video_Transcoder_V1beta1_Overlay.FadeType] = [
    .unspecified,
    .fadeIn,
    .fadeOut,
  ]
}

#endif  // swift(>=4.2)

/// Preprocessing configurations.
public struct Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Color preprocessing configuration.
  public var color: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Color {
    get {return _color ?? Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Color()}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  public var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  public mutating func clearColor() {self._color = nil}

  /// Denoise preprocessing configuration.
  public var denoise: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Denoise {
    get {return _denoise ?? Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Denoise()}
    set {_denoise = newValue}
  }
  /// Returns true if `denoise` has been explicitly set.
  public var hasDenoise: Bool {return self._denoise != nil}
  /// Clears the value of `denoise`. Subsequent reads from it will return its default value.
  public mutating func clearDenoise() {self._denoise = nil}

  /// Deblock preprocessing configuration.
  public var deblock: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Deblock {
    get {return _deblock ?? Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Deblock()}
    set {_deblock = newValue}
  }
  /// Returns true if `deblock` has been explicitly set.
  public var hasDeblock: Bool {return self._deblock != nil}
  /// Clears the value of `deblock`. Subsequent reads from it will return its default value.
  public mutating func clearDeblock() {self._deblock = nil}

  /// Audio preprocessing configuration.
  public var audio: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Audio {
    get {return _audio ?? Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Audio()}
    set {_audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  public var hasAudio: Bool {return self._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  public mutating func clearAudio() {self._audio = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Color preprocessing configuration.
  public struct Color {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Control color saturation of the video. Enter a value between -1 and 1,
    /// where -1 is fully desaturated and 1 is maximum saturation. 0 is no
    /// change. The default is 0.
    public var saturation: Double = 0

    /// Control black and white contrast of the video. Enter a value between -1
    /// and 1, where -1 is minimum contrast and 1 is maximum contrast. 0 is no
    /// change. The default is 0.
    public var contrast: Double = 0

    /// Control brightness of the video. Enter a value between -1 and 1, where -1
    /// is minimum brightness and 1 is maximum brightness. 0 is no change. The
    /// default is 0.
    public var brightness: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Denoise preprocessing configuration.
  public struct Denoise {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Set strength of the denoise. Enter a value between 0 and 1. The higher
    /// the value, the smoother the image. 0 is no denoising. The default is 0.
    public var strength: Double = 0

    /// Set the denoiser mode. The default is `"standard"`.
    ///
    /// Supported denoiser modes:
    /// - 'standard'
    /// - 'grain'
    public var tune: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Deblock preprocessing configuration.
  public struct Deblock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Set strength of the deblocker. Enter a value between 0 and 1. The higher
    /// the value, the stronger the block removal. 0 is no deblocking. The
    /// default is 0.
    public var strength: Double = 0

    /// Enable deblocker. The default is `false`.
    public var enabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Audio preprocessing configuration.
  public struct Audio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specify audio loudness normalization in loudness units relative to full
    /// scale (LUFS). Enter a value between -24 and 0, where -24 is the Advanced
    /// Television Systems Committee (ATSC A/85), -23 is the EU R128 broadcast
    /// standard, -19 is the prior standard for online mono audio, -18 is the
    /// ReplayGain standard, -16 is the prior standard for stereo audio, -14 is
    /// the new online audio standard recommended by Spotify, as well as Amazon
    /// Echo, and 0 disables normalization. The default is 0.
    public var lufs: Double = 0

    /// Enable boosting high frequency components. The default is `false`.
    public var highBoost: Bool = false

    /// Enable boosting low frequency components. The default is `false`.
    public var lowBoost: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _color: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Color? = nil
  fileprivate var _denoise: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Denoise? = nil
  fileprivate var _deblock: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Deblock? = nil
  fileprivate var _audio: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Audio? = nil
}

/// Video stream resource.
public struct Google_Cloud_Video_Transcoder_V1beta1_VideoStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Codec type. The default is `"h264"`.
  ///
  /// Supported codecs:
  /// - 'h264'
  /// - 'h265'
  /// - 'vp9'
  public var codec: String {
    get {return _storage._codec}
    set {_uniqueStorage()._codec = newValue}
  }

  /// Enforce specified codec profile. The default is `"high"`.
  ///
  /// Supported codec profiles:
  /// - 'baseline'
  /// - 'main'
  /// - 'high'
  public var profile: String {
    get {return _storage._profile}
    set {_uniqueStorage()._profile = newValue}
  }

  /// Enforce specified codec tune.
  public var tune: String {
    get {return _storage._tune}
    set {_uniqueStorage()._tune = newValue}
  }

  /// Enforce specified codec preset. The default is `"veryfast"`.
  public var preset: String {
    get {return _storage._preset}
    set {_uniqueStorage()._preset = newValue}
  }

  /// The height of the video in pixels. Must be an even integer.
  /// When not specified, the height is adjusted to match the specified width and
  /// input aspect ratio. If both are omitted, the input height is used.
  public var heightPixels: Int32 {
    get {return _storage._heightPixels}
    set {_uniqueStorage()._heightPixels = newValue}
  }

  /// The width of the video in pixels. Must be an even integer.
  /// When not specified, the width is adjusted to match the specified height and
  /// input aspect ratio. If both are omitted, the input width is used.
  public var widthPixels: Int32 {
    get {return _storage._widthPixels}
    set {_uniqueStorage()._widthPixels = newValue}
  }

  /// Pixel format to use. The default is `"yuv420p"`.
  ///
  /// Supported pixel formats:
  /// - 'yuv420p' pixel format.
  /// - 'yuv422p' pixel format.
  /// - 'yuv444p' pixel format.
  /// - 'yuv420p10' 10-bit HDR pixel format.
  /// - 'yuv422p10' 10-bit HDR pixel format.
  /// - 'yuv444p10' 10-bit HDR pixel format.
  /// - 'yuv420p12' 12-bit HDR pixel format.
  /// - 'yuv422p12' 12-bit HDR pixel format.
  /// - 'yuv444p12' 12-bit HDR pixel format.
  public var pixelFormat: String {
    get {return _storage._pixelFormat}
    set {_uniqueStorage()._pixelFormat = newValue}
  }

  /// Required. The video bitrate in bits per second. Must be between 1 and 1,000,000,000.
  public var bitrateBps: Int32 {
    get {return _storage._bitrateBps}
    set {_uniqueStorage()._bitrateBps = newValue}
  }

  /// Specify the `rate_control_mode`. The default is `"vbr"`.
  ///
  /// Supported rate control modes:
  /// - 'vbr' - variable bitrate
  /// - 'crf' - constant rate factor
  public var rateControlMode: String {
    get {return _storage._rateControlMode}
    set {_uniqueStorage()._rateControlMode = newValue}
  }

  /// Use two-pass encoding strategy to achieve better video quality.
  /// `VideoStream.rate_control_mode` must be `"vbr"`. The default is `false`.
  public var enableTwoPass: Bool {
    get {return _storage._enableTwoPass}
    set {_uniqueStorage()._enableTwoPass = newValue}
  }

  /// Target CRF level. Must be between 10 and 36, where 10 is the highest
  /// quality and 36 is the most efficient compression. The default is 21.
  public var crfLevel: Int32 {
    get {return _storage._crfLevel}
    set {_uniqueStorage()._crfLevel = newValue}
  }

  /// Size of the Video Buffering Verifier (VBV) buffer in bits. Must be greater
  /// than zero. The default is equal to `VideoStream.bitrate_bps`.
  public var vbvSizeBits: Int32 {
    get {return _storage._vbvSizeBits}
    set {_uniqueStorage()._vbvSizeBits = newValue}
  }

  /// Initial fullness of the Video Buffering Verifier (VBV) buffer in bits. Must
  /// be greater than zero. The default is equal to 90% of
  /// `VideoStream.vbv_size_bits`.
  public var vbvFullnessBits: Int32 {
    get {return _storage._vbvFullnessBits}
    set {_uniqueStorage()._vbvFullnessBits = newValue}
  }

  /// Specifies whether an open Group of Pictures (GOP) structure should be
  /// allowed or not. The default is `false`.
  public var allowOpenGop: Bool {
    get {return _storage._allowOpenGop}
    set {_uniqueStorage()._allowOpenGop = newValue}
  }

  /// GOP mode can be either by frame count or duration.
  public var gopMode: OneOf_GopMode? {
    get {return _storage._gopMode}
    set {_uniqueStorage()._gopMode = newValue}
  }

  /// Select the GOP size based on the specified frame count. Must be greater
  /// than zero.
  public var gopFrameCount: Int32 {
    get {
      if case .gopFrameCount(let v)? = _storage._gopMode {return v}
      return 0
    }
    set {_uniqueStorage()._gopMode = .gopFrameCount(newValue)}
  }

  /// Select the GOP size based on the specified duration. The default is
  /// `"3s"`.
  public var gopDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .gopDuration(let v)? = _storage._gopMode {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {_uniqueStorage()._gopMode = .gopDuration(newValue)}
  }

  /// The entropy coder to use. The default is `"cabac"`.
  ///
  /// Supported entropy coders:
  /// - 'cavlc'
  /// - 'cabac'
  public var entropyCoder: String {
    get {return _storage._entropyCoder}
    set {_uniqueStorage()._entropyCoder = newValue}
  }

  /// Allow B-pyramid for reference frame selection. This may not be supported
  /// on all decoders. The default is `false`.
  public var bPyramid: Bool {
    get {return _storage._bPyramid}
    set {_uniqueStorage()._bPyramid = newValue}
  }

  /// The number of consecutive B-frames. Must be greater than or equal to zero.
  /// Must be less than `VideoStream.gop_frame_count` if set. The default is 0.
  public var bFrameCount: Int32 {
    get {return _storage._bFrameCount}
    set {_uniqueStorage()._bFrameCount = newValue}
  }

  /// Required. The target video frame rate in frames per second (FPS). Must be less than
  /// or equal to 120. Will default to the input frame rate if larger than the
  /// input frame rate. The API will generate an output FPS that is divisible by
  /// the input FPS, and smaller or equal to the target FPS.
  ///
  /// The following table shows the computed video FPS given the target FPS (in
  /// parenthesis) and input FPS (in the first column):
  ///
  /// |        | (30)   | (60)   | (25) | (50) |
  /// |--------|--------|--------|------|------|
  /// | 240    | Fail   | Fail   | Fail | Fail |
  /// | 120    | 30     | 60     | 20   | 30   |
  /// | 100    | 25     | 50     | 20   | 30   |
  /// | 50     | 25     | 50     | 20   | 30   |
  /// | 60     | 30     | 60     | 20   | 30   |
  /// | 59.94  | 29.97  | 59.94  | 20   | 30   |
  /// | 48     | 24     | 48     | 20   | 30   |
  /// | 30     | 30     | 30     | 20   | 30   |
  /// | 25     | 25     | 25     | 20   | 30   |
  /// | 24     | 24     | 24     | 20   | 30   |
  /// | 23.976 | 23.976 | 23.976 | 20   | 30   |
  /// | 15     | 15     | 15     | 20   | 30   |
  /// | 12     | 12     | 12     | 20   | 30   |
  /// | 10     | 10     | 10     | 20   | 30   |
  public var frameRate: Double {
    get {return _storage._frameRate}
    set {_uniqueStorage()._frameRate = newValue}
  }

  /// Specify the intensity of the adaptive quantizer (AQ). Must be between 0 and
  /// 1, where 0 disables the quantizer and 1 maximizes the quantizer. A
  /// higher value equals a lower bitrate but smoother image. The default is 0.
  public var aqStrength: Double {
    get {return _storage._aqStrength}
    set {_uniqueStorage()._aqStrength = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// GOP mode can be either by frame count or duration.
  public enum OneOf_GopMode: Equatable {
    /// Select the GOP size based on the specified frame count. Must be greater
    /// than zero.
    case gopFrameCount(Int32)
    /// Select the GOP size based on the specified duration. The default is
    /// `"3s"`.
    case gopDuration(SwiftProtobuf.Google_Protobuf_Duration)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_VideoStream.OneOf_GopMode, rhs: Google_Cloud_Video_Transcoder_V1beta1_VideoStream.OneOf_GopMode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gopFrameCount, .gopFrameCount): return {
        guard case .gopFrameCount(let l) = lhs, case .gopFrameCount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gopDuration, .gopDuration): return {
        guard case .gopDuration(let l) = lhs, case .gopDuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Audio stream resource.
public struct Google_Cloud_Video_Transcoder_V1beta1_AudioStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The codec for this audio stream. The default is `"aac"`.
  ///
  /// Supported audio codecs:
  /// - 'aac'
  /// - 'aac-he'
  /// - 'aac-he-v2'
  /// - 'mp3'
  /// - 'ac3'
  /// - 'eac3'
  public var codec: String = String()

  /// Required. Audio bitrate in bits per second. Must be between 1 and 10,000,000.
  public var bitrateBps: Int32 = 0

  /// Number of audio channels. Must be between 1 and 6. The default is 2.
  public var channelCount: Int32 = 0

  /// A list of channel names specifying layout of the audio channels.
  /// This only affects the metadata embedded in the container headers, if
  /// supported by the specified format. The default is `["fl", "fr"]`.
  ///
  /// Supported channel names:
  /// - 'fl' - Front left channel
  /// - 'fr' - Front right channel
  /// - 'sl' - Side left channel
  /// - 'sr' - Side right channel
  /// - 'fc' - Front center channel
  /// - 'lfe' - Low frequency
  public var channelLayout: [String] = []

  /// The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`.
  public var mapping: [Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom] = []

  /// The audio sample rate in Hertz. The default is 48000 Hertz.
  public var sampleRateHertz: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The mapping for the `Job.edit_list` atoms with audio `EditAtom.inputs`.
  public struct AudioAtom {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The `EditAtom.key` that references the atom with audio inputs in the
    /// `Job.edit_list`.
    public var key: String = String()

    /// List of `Channel`s for this audio stream.
    /// for in-depth explanation.
    public var channels: [Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The audio channel.
    public struct AudioChannel {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// List of `Job.inputs` for this audio channel.
      public var inputs: [Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel.AudioChannelInput] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Identifies which input file, track, and channel should be used.
      public struct AudioChannelInput {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// Required. The `Input.key` that identifies the input file.
        public var key: String = String()

        /// Required. The zero-based index of the track in the input file.
        public var track: Int32 = 0

        /// Required. The zero-based index of the channel in the input file.
        public var channel: Int32 = 0

        /// Audio volume control in dB. Negative values decrease volume,
        /// positive values increase. The default is 0.
        public var gainDb: Double = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// Encoding of a text stream. For example, closed captions or subtitles.
public struct Google_Cloud_Video_Transcoder_V1beta1_TextStream {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The codec for this text stream. The default is `"webvtt"`.
  ///
  /// Supported text codecs:
  /// - 'srt'
  /// - 'ttml'
  /// - 'cea608'
  /// - 'cea708'
  /// - 'webvtt'
  public var codec: String = String()

  /// Required. The BCP-47 language code, such as `"en-US"` or `"sr-Latn"`. For more
  /// information, see
  /// https://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  public var languageCode: String = String()

  /// The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`.
  public var mapping: [Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The mapping for the `Job.edit_list` atoms with text `EditAtom.inputs`.
  public struct TextAtom {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The `EditAtom.key` that references atom with text inputs in the
    /// `Job.edit_list`.
    public var key: String = String()

    /// List of `Job.inputs` that should be embedded in this atom. Only one
    /// input is supported.
    public var inputs: [Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom.TextInput] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Identifies which input file and track should be used.
    public struct TextInput {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The `Input.key` that identifies the input file.
      public var key: String = String()

      /// Required. The zero-based index of the track in the input file.
      public var track: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

/// Segment settings for `"ts"`, `"fmp4"` and `"vtt"`.
public struct Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Duration of the segments in seconds. The default is `"6.0s"`.
  public var segmentDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _segmentDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_segmentDuration = newValue}
  }
  /// Returns true if `segmentDuration` has been explicitly set.
  public var hasSegmentDuration: Bool {return self._segmentDuration != nil}
  /// Clears the value of `segmentDuration`. Subsequent reads from it will return its default value.
  public mutating func clearSegmentDuration() {self._segmentDuration = nil}

  /// Required. Create an individual segment file. The default is `false`.
  public var individualSegments: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _segmentDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Encryption settings.
public struct Google_Cloud_Video_Transcoder_V1beta1_Encryption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. 128 bit encryption key represented as lowercase hexadecimal digits.
  public var key: String = String()

  /// Required. 128 bit Initialization Vector (IV) represented as lowercase hexadecimal
  /// digits.
  public var iv: String = String()

  /// Encryption mode can be either `aes` or `cenc`.
  public var encryptionMode: Google_Cloud_Video_Transcoder_V1beta1_Encryption.OneOf_EncryptionMode? = nil

  /// Configuration for AES-128 encryption.
  public var aes128: Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption {
    get {
      if case .aes128(let v)? = encryptionMode {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption()
    }
    set {encryptionMode = .aes128(newValue)}
  }

  /// Configuration for SAMPLE-AES encryption.
  public var sampleAes: Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption {
    get {
      if case .sampleAes(let v)? = encryptionMode {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption()
    }
    set {encryptionMode = .sampleAes(newValue)}
  }

  /// Configuration for MPEG Common Encryption (MPEG-CENC).
  public var mpegCenc: Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption {
    get {
      if case .mpegCenc(let v)? = encryptionMode {return v}
      return Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption()
    }
    set {encryptionMode = .mpegCenc(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Encryption mode can be either `aes` or `cenc`.
  public enum OneOf_EncryptionMode: Equatable {
    /// Configuration for AES-128 encryption.
    case aes128(Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption)
    /// Configuration for SAMPLE-AES encryption.
    case sampleAes(Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption)
    /// Configuration for MPEG Common Encryption (MPEG-CENC).
    case mpegCenc(Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.OneOf_EncryptionMode, rhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.OneOf_EncryptionMode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.aes128, .aes128): return {
        guard case .aes128(let l) = lhs, case .aes128(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sampleAes, .sampleAes): return {
        guard case .sampleAes(let l) = lhs, case .sampleAes(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mpegCenc, .mpegCenc): return {
        guard case .mpegCenc(let l) = lhs, case .mpegCenc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Configuration for AES-128 encryption.
  public struct Aes128Encryption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. URI of the key delivery service. This URI is inserted into the M3U8
    /// header.
    public var keyUri: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Configuration for SAMPLE-AES encryption.
  public struct SampleAesEncryption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. URI of the key delivery service. This URI is inserted into the M3U8
    /// header.
    public var keyUri: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Configuration for MPEG Common Encryption (MPEG-CENC).
  public struct MpegCommonEncryption {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. 128 bit Key ID represented as lowercase hexadecimal digits for use with
    /// common encryption.
    public var keyID: String = String()

    /// Required. Specify the encryption scheme.
    ///
    /// Supported encryption schemes:
    /// - 'cenc'
    /// - 'cbcs'
    public var scheme: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Estimated fractional progress for each step, from `0` to `1`.
public struct Google_Cloud_Video_Transcoder_V1beta1_Progress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Estimated fractional progress for `analyzing` step.
  public var analyzed: Double = 0

  /// Estimated fractional progress for `encoding` step.
  public var encoded: Double = 0

  /// Estimated fractional progress for `uploading` step.
  public var uploaded: Double = 0

  /// Estimated fractional progress for `notifying` step.
  public var notified: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Additional information about the reasons for the failure.
public struct Google_Cloud_Video_Transcoder_V1beta1_FailureDetail {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A description of the failure.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.video.transcoder.v1beta1"

extension Google_Cloud_Video_Transcoder_V1beta1_Job: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Job"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "input_uri"),
    3: .standard(proto: "output_uri"),
    4: .standard(proto: "template_id"),
    5: .same(proto: "config"),
    6: .same(proto: "priority"),
    7: .standard(proto: "origin_uri"),
    8: .same(proto: "state"),
    9: .same(proto: "progress"),
    10: .standard(proto: "failure_reason"),
    11: .standard(proto: "failure_details"),
    12: .standard(proto: "create_time"),
    13: .standard(proto: "start_time"),
    14: .standard(proto: "end_time"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _inputUri: String = String()
    var _outputUri: String = String()
    var _jobConfig: Google_Cloud_Video_Transcoder_V1beta1_Job.OneOf_JobConfig?
    var _priority: Int32 = 0
    var _originUri: Google_Cloud_Video_Transcoder_V1beta1_Job.OriginUri? = nil
    var _state: Google_Cloud_Video_Transcoder_V1beta1_Job.ProcessingState = .unspecified
    var _progress: Google_Cloud_Video_Transcoder_V1beta1_Progress? = nil
    var _failureReason: String = String()
    var _failureDetails: [Google_Cloud_Video_Transcoder_V1beta1_FailureDetail] = []
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _inputUri = source._inputUri
      _outputUri = source._outputUri
      _jobConfig = source._jobConfig
      _priority = source._priority
      _originUri = source._originUri
      _state = source._state
      _progress = source._progress
      _failureReason = source._failureReason
      _failureDetails = source._failureDetails
      _createTime = source._createTime
      _startTime = source._startTime
      _endTime = source._endTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._inputUri) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._outputUri) }()
        case 4: try {
          if _storage._jobConfig != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._jobConfig = .templateID(v)}
        }()
        case 5: try {
          var v: Google_Cloud_Video_Transcoder_V1beta1_JobConfig?
          if let current = _storage._jobConfig {
            try decoder.handleConflictingOneOf()
            if case .config(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._jobConfig = .config(v)}
        }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._priority) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._originUri) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._progress) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._failureReason) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._failureDetails) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._inputUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inputUri, fieldNumber: 2)
      }
      if !_storage._outputUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._outputUri, fieldNumber: 3)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._jobConfig {
      case .templateID?: try {
        guard case .templateID(let v)? = _storage._jobConfig else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }()
      case .config?: try {
        guard case .config(let v)? = _storage._jobConfig else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if _storage._priority != 0 {
        try visitor.visitSingularInt32Field(value: _storage._priority, fieldNumber: 6)
      }
      if let v = _storage._originUri {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 8)
      }
      if let v = _storage._progress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._failureReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._failureReason, fieldNumber: 10)
      }
      if !_storage._failureDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._failureDetails, fieldNumber: 11)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Job, rhs: Google_Cloud_Video_Transcoder_V1beta1_Job) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._inputUri != rhs_storage._inputUri {return false}
        if _storage._outputUri != rhs_storage._outputUri {return false}
        if _storage._jobConfig != rhs_storage._jobConfig {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._originUri != rhs_storage._originUri {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._progress != rhs_storage._progress {return false}
        if _storage._failureReason != rhs_storage._failureReason {return false}
        if _storage._failureDetails != rhs_storage._failureDetails {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Job.ProcessingState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROCESSING_STATE_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "SUCCEEDED"),
    4: .same(proto: "FAILED"),
  ]
}

extension Google_Cloud_Video_Transcoder_V1beta1_Job.OriginUri: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Job.protoMessageName + ".OriginUri"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hls"),
    2: .same(proto: "dash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hls) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.dash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hls.isEmpty {
      try visitor.visitSingularStringField(value: self.hls, fieldNumber: 1)
    }
    if !self.dash.isEmpty {
      try visitor.visitSingularStringField(value: self.dash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Job.OriginUri, rhs: Google_Cloud_Video_Transcoder_V1beta1_Job.OriginUri) -> Bool {
    if lhs.hls != rhs.hls {return false}
    if lhs.dash != rhs.dash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_JobTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_JobTemplate, rhs: Google_Cloud_Video_Transcoder_V1beta1_JobTemplate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_JobConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .standard(proto: "edit_list"),
    3: .standard(proto: "elementary_streams"),
    4: .standard(proto: "mux_streams"),
    5: .same(proto: "manifests"),
    6: .same(proto: "output"),
    7: .standard(proto: "ad_breaks"),
    8: .standard(proto: "pubsub_destination"),
    9: .standard(proto: "sprite_sheets"),
    10: .same(proto: "overlays"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.editList) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.elementaryStreams) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.muxStreams) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.manifests) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._output) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.adBreaks) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._pubsubDestination) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.spriteSheets) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.overlays) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.editList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.editList, fieldNumber: 2)
    }
    if !self.elementaryStreams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elementaryStreams, fieldNumber: 3)
    }
    if !self.muxStreams.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.muxStreams, fieldNumber: 4)
    }
    if !self.manifests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.manifests, fieldNumber: 5)
    }
    if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.adBreaks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.adBreaks, fieldNumber: 7)
    }
    if let v = self._pubsubDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.spriteSheets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spriteSheets, fieldNumber: 9)
    }
    if !self.overlays.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.overlays, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_JobConfig, rhs: Google_Cloud_Video_Transcoder_V1beta1_JobConfig) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.editList != rhs.editList {return false}
    if lhs.elementaryStreams != rhs.elementaryStreams {return false}
    if lhs.muxStreams != rhs.muxStreams {return false}
    if lhs.manifests != rhs.manifests {return false}
    if lhs._output != rhs._output {return false}
    if lhs.adBreaks != rhs.adBreaks {return false}
    if lhs._pubsubDestination != rhs._pubsubDestination {return false}
    if lhs.spriteSheets != rhs.spriteSheets {return false}
    if lhs.overlays != rhs.overlays {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Input"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "uri"),
    3: .standard(proto: "preprocessing_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._preprocessingConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if let v = self._preprocessingConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Input, rhs: Google_Cloud_Video_Transcoder_V1beta1_Input) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs._preprocessingConfig != rhs._preprocessingConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Output"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Output, rhs: Google_Cloud_Video_Transcoder_V1beta1_Output) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_EditAtom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditAtom"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "inputs"),
    3: .standard(proto: "end_time_offset"),
    4: .standard(proto: "start_time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.inputs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endTimeOffset) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputs, fieldNumber: 2)
    }
    if let v = self._endTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_EditAtom, rhs: Google_Cloud_Video_Transcoder_V1beta1_EditAtom) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs._endTimeOffset != rhs._endTimeOffset {return false}
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_AdBreak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AdBreak"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_AdBreak, rhs: Google_Cloud_Video_Transcoder_V1beta1_AdBreak) -> Bool {
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ElementaryStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "key"),
    1: .standard(proto: "video_stream"),
    2: .standard(proto: "audio_stream"),
    3: .standard(proto: "text_stream"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_VideoStream?
        if let current = self.elementaryStream {
          try decoder.handleConflictingOneOf()
          if case .videoStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementaryStream = .videoStream(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_AudioStream?
        if let current = self.elementaryStream {
          try decoder.handleConflictingOneOf()
          if case .audioStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementaryStream = .audioStream(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_TextStream?
        if let current = self.elementaryStream {
          try decoder.handleConflictingOneOf()
          if case .textStream(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.elementaryStream = .textStream(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.elementaryStream {
    case .videoStream?: try {
      guard case .videoStream(let v)? = self.elementaryStream else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .audioStream?: try {
      guard case .audioStream(let v)? = self.elementaryStream else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .textStream?: try {
      guard case .textStream(let v)? = self.elementaryStream else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream, rhs: Google_Cloud_Video_Transcoder_V1beta1_ElementaryStream) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.elementaryStream != rhs.elementaryStream {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_MuxStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MuxStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "file_name"),
    3: .same(proto: "container"),
    4: .standard(proto: "elementary_streams"),
    5: .standard(proto: "segment_settings"),
    6: .same(proto: "encryption"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.container) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.elementaryStreams) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._segmentSettings) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._encryption) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 2)
    }
    if !self.container.isEmpty {
      try visitor.visitSingularStringField(value: self.container, fieldNumber: 3)
    }
    if !self.elementaryStreams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.elementaryStreams, fieldNumber: 4)
    }
    if let v = self._segmentSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._encryption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_MuxStream, rhs: Google_Cloud_Video_Transcoder_V1beta1_MuxStream) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.fileName != rhs.fileName {return false}
    if lhs.container != rhs.container {return false}
    if lhs.elementaryStreams != rhs.elementaryStreams {return false}
    if lhs._segmentSettings != rhs._segmentSettings {return false}
    if lhs._encryption != rhs._encryption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Manifest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Manifest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_name"),
    2: .same(proto: "type"),
    3: .standard(proto: "mux_streams"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fileName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.muxStreams) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileName.isEmpty {
      try visitor.visitSingularStringField(value: self.fileName, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if !self.muxStreams.isEmpty {
      try visitor.visitRepeatedStringField(value: self.muxStreams, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Manifest, rhs: Google_Cloud_Video_Transcoder_V1beta1_Manifest) -> Bool {
    if lhs.fileName != rhs.fileName {return false}
    if lhs.type != rhs.type {return false}
    if lhs.muxStreams != rhs.muxStreams {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Manifest.ManifestType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANIFEST_TYPE_UNSPECIFIED"),
    1: .same(proto: "HLS"),
    2: .same(proto: "DASH"),
  ]
}

extension Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubsubDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination, rhs: Google_Cloud_Video_Transcoder_V1beta1_PubsubDestination) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpriteSheet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .standard(proto: "file_prefix"),
    3: .standard(proto: "sprite_width_pixels"),
    4: .standard(proto: "sprite_height_pixels"),
    5: .standard(proto: "column_count"),
    6: .standard(proto: "row_count"),
    7: .standard(proto: "start_time_offset"),
    8: .standard(proto: "end_time_offset"),
    9: .standard(proto: "total_count"),
    10: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filePrefix) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.spriteWidthPixels) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.spriteHeightPixels) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.columnCount) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.rowCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._endTimeOffset) }()
      case 9: try {
        if self.extractionStrategy != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.extractionStrategy = .totalCount(v)}
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.extractionStrategy {
          try decoder.handleConflictingOneOf()
          if case .interval(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.extractionStrategy = .interval(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if !self.filePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.filePrefix, fieldNumber: 2)
    }
    if self.spriteWidthPixels != 0 {
      try visitor.visitSingularInt32Field(value: self.spriteWidthPixels, fieldNumber: 3)
    }
    if self.spriteHeightPixels != 0 {
      try visitor.visitSingularInt32Field(value: self.spriteHeightPixels, fieldNumber: 4)
    }
    if self.columnCount != 0 {
      try visitor.visitSingularInt32Field(value: self.columnCount, fieldNumber: 5)
    }
    if self.rowCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rowCount, fieldNumber: 6)
    }
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._endTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.extractionStrategy {
    case .totalCount?: try {
      guard case .totalCount(let v)? = self.extractionStrategy else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 9)
    }()
    case .interval?: try {
      guard case .interval(let v)? = self.extractionStrategy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet, rhs: Google_Cloud_Video_Transcoder_V1beta1_SpriteSheet) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.filePrefix != rhs.filePrefix {return false}
    if lhs.spriteWidthPixels != rhs.spriteWidthPixels {return false}
    if lhs.spriteHeightPixels != rhs.spriteHeightPixels {return false}
    if lhs.columnCount != rhs.columnCount {return false}
    if lhs.rowCount != rhs.rowCount {return false}
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs._endTimeOffset != rhs._endTimeOffset {return false}
    if lhs.extractionStrategy != rhs.extractionStrategy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Overlay"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "animations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.animations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.animations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.animations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay) -> Bool {
    if lhs._image != rhs._image {return false}
    if lhs.animations != rhs.animations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.FadeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FADE_TYPE_UNSPECIFIED"),
    1: .same(proto: "FADE_IN"),
    2: .same(proto: "FADE_OUT"),
  ]
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Overlay.protoMessageName + ".NormalizedCoordinate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularDoubleField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularDoubleField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.NormalizedCoordinate) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Overlay.protoMessageName + ".Image"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .same(proto: "resolution"),
    3: .same(proto: "alpha"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resolution) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.alpha) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if let v = self._resolution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.alpha != 0 {
      try visitor.visitSingularDoubleField(value: self.alpha, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Image, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Image) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs._resolution != rhs._resolution {return false}
    if lhs.alpha != rhs.alpha {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Overlay.protoMessageName + ".AnimationStatic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "xy"),
    2: .standard(proto: "start_time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._xy) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._xy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic) -> Bool {
    if lhs._xy != rhs._xy {return false}
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Overlay.protoMessageName + ".AnimationFade"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fade_type"),
    2: .same(proto: "xy"),
    3: .standard(proto: "start_time_offset"),
    4: .standard(proto: "end_time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.fadeType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._xy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTimeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fadeType != .unspecified {
      try visitor.visitSingularEnumField(value: self.fadeType, fieldNumber: 1)
    }
    if let v = self._xy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade) -> Bool {
    if lhs.fadeType != rhs.fadeType {return false}
    if lhs._xy != rhs._xy {return false}
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs._endTimeOffset != rhs._endTimeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Overlay.protoMessageName + ".AnimationEnd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd) -> Bool {
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Overlay.protoMessageName + ".Animation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "animation_static"),
    2: .standard(proto: "animation_fade"),
    3: .standard(proto: "animation_end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationStatic?
        if let current = self.animationType {
          try decoder.handleConflictingOneOf()
          if case .animationStatic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.animationType = .animationStatic(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationFade?
        if let current = self.animationType {
          try decoder.handleConflictingOneOf()
          if case .animationFade(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.animationType = .animationFade(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_Overlay.AnimationEnd?
        if let current = self.animationType {
          try decoder.handleConflictingOneOf()
          if case .animationEnd(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.animationType = .animationEnd(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.animationType {
    case .animationStatic?: try {
      guard case .animationStatic(let v)? = self.animationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .animationFade?: try {
      guard case .animationFade(let v)? = self.animationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .animationEnd?: try {
      guard case .animationEnd(let v)? = self.animationType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation, rhs: Google_Cloud_Video_Transcoder_V1beta1_Overlay.Animation) -> Bool {
    if lhs.animationType != rhs.animationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreprocessingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "color"),
    2: .same(proto: "denoise"),
    3: .same(proto: "deblock"),
    4: .same(proto: "audio"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._color) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._denoise) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deblock) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._audio) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._color {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._denoise {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._deblock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._audio {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig, rhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig) -> Bool {
    if lhs._color != rhs._color {return false}
    if lhs._denoise != rhs._denoise {return false}
    if lhs._deblock != rhs._deblock {return false}
    if lhs._audio != rhs._audio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Color: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.protoMessageName + ".Color"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "saturation"),
    2: .same(proto: "contrast"),
    3: .same(proto: "brightness"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.saturation) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.contrast) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.brightness) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.saturation != 0 {
      try visitor.visitSingularDoubleField(value: self.saturation, fieldNumber: 1)
    }
    if self.contrast != 0 {
      try visitor.visitSingularDoubleField(value: self.contrast, fieldNumber: 2)
    }
    if self.brightness != 0 {
      try visitor.visitSingularDoubleField(value: self.brightness, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Color, rhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Color) -> Bool {
    if lhs.saturation != rhs.saturation {return false}
    if lhs.contrast != rhs.contrast {return false}
    if lhs.brightness != rhs.brightness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Denoise: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.protoMessageName + ".Denoise"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strength"),
    2: .same(proto: "tune"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.strength) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tune) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.strength != 0 {
      try visitor.visitSingularDoubleField(value: self.strength, fieldNumber: 1)
    }
    if !self.tune.isEmpty {
      try visitor.visitSingularStringField(value: self.tune, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Denoise, rhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Denoise) -> Bool {
    if lhs.strength != rhs.strength {return false}
    if lhs.tune != rhs.tune {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Deblock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.protoMessageName + ".Deblock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strength"),
    2: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.strength) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.strength != 0 {
      try visitor.visitSingularDoubleField(value: self.strength, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Deblock, rhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Deblock) -> Bool {
    if lhs.strength != rhs.strength {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Audio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.protoMessageName + ".Audio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lufs"),
    2: .standard(proto: "high_boost"),
    3: .standard(proto: "low_boost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.lufs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.highBoost) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.lowBoost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lufs != 0 {
      try visitor.visitSingularDoubleField(value: self.lufs, fieldNumber: 1)
    }
    if self.highBoost != false {
      try visitor.visitSingularBoolField(value: self.highBoost, fieldNumber: 2)
    }
    if self.lowBoost != false {
      try visitor.visitSingularBoolField(value: self.lowBoost, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Audio, rhs: Google_Cloud_Video_Transcoder_V1beta1_PreprocessingConfig.Audio) -> Bool {
    if lhs.lufs != rhs.lufs {return false}
    if lhs.highBoost != rhs.highBoost {return false}
    if lhs.lowBoost != rhs.lowBoost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_VideoStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codec"),
    2: .same(proto: "profile"),
    3: .same(proto: "tune"),
    4: .same(proto: "preset"),
    5: .standard(proto: "height_pixels"),
    6: .standard(proto: "width_pixels"),
    7: .standard(proto: "pixel_format"),
    8: .standard(proto: "bitrate_bps"),
    9: .standard(proto: "rate_control_mode"),
    10: .standard(proto: "enable_two_pass"),
    11: .standard(proto: "crf_level"),
    12: .standard(proto: "vbv_size_bits"),
    13: .standard(proto: "vbv_fullness_bits"),
    14: .standard(proto: "allow_open_gop"),
    15: .standard(proto: "gop_frame_count"),
    16: .standard(proto: "gop_duration"),
    17: .standard(proto: "entropy_coder"),
    18: .standard(proto: "b_pyramid"),
    19: .standard(proto: "b_frame_count"),
    20: .standard(proto: "frame_rate"),
    21: .standard(proto: "aq_strength"),
  ]

  fileprivate class _StorageClass {
    var _codec: String = String()
    var _profile: String = String()
    var _tune: String = String()
    var _preset: String = String()
    var _heightPixels: Int32 = 0
    var _widthPixels: Int32 = 0
    var _pixelFormat: String = String()
    var _bitrateBps: Int32 = 0
    var _rateControlMode: String = String()
    var _enableTwoPass: Bool = false
    var _crfLevel: Int32 = 0
    var _vbvSizeBits: Int32 = 0
    var _vbvFullnessBits: Int32 = 0
    var _allowOpenGop: Bool = false
    var _gopMode: Google_Cloud_Video_Transcoder_V1beta1_VideoStream.OneOf_GopMode?
    var _entropyCoder: String = String()
    var _bPyramid: Bool = false
    var _bFrameCount: Int32 = 0
    var _frameRate: Double = 0
    var _aqStrength: Double = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _codec = source._codec
      _profile = source._profile
      _tune = source._tune
      _preset = source._preset
      _heightPixels = source._heightPixels
      _widthPixels = source._widthPixels
      _pixelFormat = source._pixelFormat
      _bitrateBps = source._bitrateBps
      _rateControlMode = source._rateControlMode
      _enableTwoPass = source._enableTwoPass
      _crfLevel = source._crfLevel
      _vbvSizeBits = source._vbvSizeBits
      _vbvFullnessBits = source._vbvFullnessBits
      _allowOpenGop = source._allowOpenGop
      _gopMode = source._gopMode
      _entropyCoder = source._entropyCoder
      _bPyramid = source._bPyramid
      _bFrameCount = source._bFrameCount
      _frameRate = source._frameRate
      _aqStrength = source._aqStrength
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._codec) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._profile) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._tune) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._preset) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._heightPixels) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._widthPixels) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._pixelFormat) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._bitrateBps) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._rateControlMode) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._enableTwoPass) }()
        case 11: try { try decoder.decodeSingularInt32Field(value: &_storage._crfLevel) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._vbvSizeBits) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._vbvFullnessBits) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._allowOpenGop) }()
        case 15: try {
          if _storage._gopMode != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {_storage._gopMode = .gopFrameCount(v)}
        }()
        case 16: try {
          var v: SwiftProtobuf.Google_Protobuf_Duration?
          if let current = _storage._gopMode {
            try decoder.handleConflictingOneOf()
            if case .gopDuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._gopMode = .gopDuration(v)}
        }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._entropyCoder) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._bPyramid) }()
        case 19: try { try decoder.decodeSingularInt32Field(value: &_storage._bFrameCount) }()
        case 20: try { try decoder.decodeSingularDoubleField(value: &_storage._frameRate) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._aqStrength) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._codec.isEmpty {
        try visitor.visitSingularStringField(value: _storage._codec, fieldNumber: 1)
      }
      if !_storage._profile.isEmpty {
        try visitor.visitSingularStringField(value: _storage._profile, fieldNumber: 2)
      }
      if !_storage._tune.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tune, fieldNumber: 3)
      }
      if !_storage._preset.isEmpty {
        try visitor.visitSingularStringField(value: _storage._preset, fieldNumber: 4)
      }
      if _storage._heightPixels != 0 {
        try visitor.visitSingularInt32Field(value: _storage._heightPixels, fieldNumber: 5)
      }
      if _storage._widthPixels != 0 {
        try visitor.visitSingularInt32Field(value: _storage._widthPixels, fieldNumber: 6)
      }
      if !_storage._pixelFormat.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pixelFormat, fieldNumber: 7)
      }
      if _storage._bitrateBps != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bitrateBps, fieldNumber: 8)
      }
      if !_storage._rateControlMode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._rateControlMode, fieldNumber: 9)
      }
      if _storage._enableTwoPass != false {
        try visitor.visitSingularBoolField(value: _storage._enableTwoPass, fieldNumber: 10)
      }
      if _storage._crfLevel != 0 {
        try visitor.visitSingularInt32Field(value: _storage._crfLevel, fieldNumber: 11)
      }
      if _storage._vbvSizeBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vbvSizeBits, fieldNumber: 12)
      }
      if _storage._vbvFullnessBits != 0 {
        try visitor.visitSingularInt32Field(value: _storage._vbvFullnessBits, fieldNumber: 13)
      }
      if _storage._allowOpenGop != false {
        try visitor.visitSingularBoolField(value: _storage._allowOpenGop, fieldNumber: 14)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._gopMode {
      case .gopFrameCount?: try {
        guard case .gopFrameCount(let v)? = _storage._gopMode else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 15)
      }()
      case .gopDuration?: try {
        guard case .gopDuration(let v)? = _storage._gopMode else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case nil: break
      }
      if !_storage._entropyCoder.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entropyCoder, fieldNumber: 17)
      }
      if _storage._bPyramid != false {
        try visitor.visitSingularBoolField(value: _storage._bPyramid, fieldNumber: 18)
      }
      if _storage._bFrameCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._bFrameCount, fieldNumber: 19)
      }
      if _storage._frameRate != 0 {
        try visitor.visitSingularDoubleField(value: _storage._frameRate, fieldNumber: 20)
      }
      if _storage._aqStrength != 0 {
        try visitor.visitSingularDoubleField(value: _storage._aqStrength, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_VideoStream, rhs: Google_Cloud_Video_Transcoder_V1beta1_VideoStream) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._codec != rhs_storage._codec {return false}
        if _storage._profile != rhs_storage._profile {return false}
        if _storage._tune != rhs_storage._tune {return false}
        if _storage._preset != rhs_storage._preset {return false}
        if _storage._heightPixels != rhs_storage._heightPixels {return false}
        if _storage._widthPixels != rhs_storage._widthPixels {return false}
        if _storage._pixelFormat != rhs_storage._pixelFormat {return false}
        if _storage._bitrateBps != rhs_storage._bitrateBps {return false}
        if _storage._rateControlMode != rhs_storage._rateControlMode {return false}
        if _storage._enableTwoPass != rhs_storage._enableTwoPass {return false}
        if _storage._crfLevel != rhs_storage._crfLevel {return false}
        if _storage._vbvSizeBits != rhs_storage._vbvSizeBits {return false}
        if _storage._vbvFullnessBits != rhs_storage._vbvFullnessBits {return false}
        if _storage._allowOpenGop != rhs_storage._allowOpenGop {return false}
        if _storage._gopMode != rhs_storage._gopMode {return false}
        if _storage._entropyCoder != rhs_storage._entropyCoder {return false}
        if _storage._bPyramid != rhs_storage._bPyramid {return false}
        if _storage._bFrameCount != rhs_storage._bFrameCount {return false}
        if _storage._frameRate != rhs_storage._frameRate {return false}
        if _storage._aqStrength != rhs_storage._aqStrength {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_AudioStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AudioStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codec"),
    2: .standard(proto: "bitrate_bps"),
    3: .standard(proto: "channel_count"),
    4: .standard(proto: "channel_layout"),
    5: .same(proto: "mapping"),
    6: .standard(proto: "sample_rate_hertz"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.codec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.bitrateBps) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.channelCount) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.channelLayout) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.mapping) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.sampleRateHertz) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codec.isEmpty {
      try visitor.visitSingularStringField(value: self.codec, fieldNumber: 1)
    }
    if self.bitrateBps != 0 {
      try visitor.visitSingularInt32Field(value: self.bitrateBps, fieldNumber: 2)
    }
    if self.channelCount != 0 {
      try visitor.visitSingularInt32Field(value: self.channelCount, fieldNumber: 3)
    }
    if !self.channelLayout.isEmpty {
      try visitor.visitRepeatedStringField(value: self.channelLayout, fieldNumber: 4)
    }
    if !self.mapping.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapping, fieldNumber: 5)
    }
    if self.sampleRateHertz != 0 {
      try visitor.visitSingularInt32Field(value: self.sampleRateHertz, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream, rhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream) -> Bool {
    if lhs.codec != rhs.codec {return false}
    if lhs.bitrateBps != rhs.bitrateBps {return false}
    if lhs.channelCount != rhs.channelCount {return false}
    if lhs.channelLayout != rhs.channelLayout {return false}
    if lhs.mapping != rhs.mapping {return false}
    if lhs.sampleRateHertz != rhs.sampleRateHertz {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_AudioStream.protoMessageName + ".AudioAtom"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "channels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.channels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.channels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channels, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom, rhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.channels != rhs.channels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.protoMessageName + ".AudioChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel, rhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel.AudioChannelInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel.protoMessageName + ".AudioChannelInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "track"),
    3: .same(proto: "channel"),
    4: .standard(proto: "gain_db"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.track) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.channel) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.gainDb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.track != 0 {
      try visitor.visitSingularInt32Field(value: self.track, fieldNumber: 2)
    }
    if self.channel != 0 {
      try visitor.visitSingularInt32Field(value: self.channel, fieldNumber: 3)
    }
    if self.gainDb != 0 {
      try visitor.visitSingularDoubleField(value: self.gainDb, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel.AudioChannelInput, rhs: Google_Cloud_Video_Transcoder_V1beta1_AudioStream.AudioAtom.AudioChannel.AudioChannelInput) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.track != rhs.track {return false}
    if lhs.channel != rhs.channel {return false}
    if lhs.gainDb != rhs.gainDb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_TextStream: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextStream"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codec"),
    2: .standard(proto: "language_code"),
    3: .same(proto: "mapping"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.codec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mapping) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codec.isEmpty {
      try visitor.visitSingularStringField(value: self.codec, fieldNumber: 1)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 2)
    }
    if !self.mapping.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapping, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_TextStream, rhs: Google_Cloud_Video_Transcoder_V1beta1_TextStream) -> Bool {
    if lhs.codec != rhs.codec {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.mapping != rhs.mapping {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_TextStream.protoMessageName + ".TextAtom"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "inputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom, rhs: Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.inputs != rhs.inputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom.TextInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom.protoMessageName + ".TextInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "track"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.track) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.track != 0 {
      try visitor.visitSingularInt32Field(value: self.track, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom.TextInput, rhs: Google_Cloud_Video_Transcoder_V1beta1_TextStream.TextAtom.TextInput) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.track != rhs.track {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SegmentSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "segment_duration"),
    3: .standard(proto: "individual_segments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._segmentDuration) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.individualSegments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._segmentDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.individualSegments != false {
      try visitor.visitSingularBoolField(value: self.individualSegments, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings, rhs: Google_Cloud_Video_Transcoder_V1beta1_SegmentSettings) -> Bool {
    if lhs._segmentDuration != rhs._segmentDuration {return false}
    if lhs.individualSegments != rhs.individualSegments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Encryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Encryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "iv"),
    3: .standard(proto: "aes_128"),
    4: .standard(proto: "sample_aes"),
    5: .standard(proto: "mpeg_cenc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.iv) }()
      case 3: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption?
        if let current = self.encryptionMode {
          try decoder.handleConflictingOneOf()
          if case .aes128(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.encryptionMode = .aes128(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption?
        if let current = self.encryptionMode {
          try decoder.handleConflictingOneOf()
          if case .sampleAes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.encryptionMode = .sampleAes(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption?
        if let current = self.encryptionMode {
          try decoder.handleConflictingOneOf()
          if case .mpegCenc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.encryptionMode = .mpegCenc(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.iv.isEmpty {
      try visitor.visitSingularStringField(value: self.iv, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.encryptionMode {
    case .aes128?: try {
      guard case .aes128(let v)? = self.encryptionMode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .sampleAes?: try {
      guard case .sampleAes(let v)? = self.encryptionMode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .mpegCenc?: try {
      guard case .mpegCenc(let v)? = self.encryptionMode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption, rhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.iv != rhs.iv {return false}
    if lhs.encryptionMode != rhs.encryptionMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Encryption.protoMessageName + ".Aes128Encryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyUri.isEmpty {
      try visitor.visitSingularStringField(value: self.keyUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption, rhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.Aes128Encryption) -> Bool {
    if lhs.keyUri != rhs.keyUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Encryption.protoMessageName + ".SampleAesEncryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyUri.isEmpty {
      try visitor.visitSingularStringField(value: self.keyUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption, rhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.SampleAesEncryption) -> Bool {
    if lhs.keyUri != rhs.keyUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Video_Transcoder_V1beta1_Encryption.protoMessageName + ".MpegCommonEncryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .same(proto: "scheme"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheme) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.scheme.isEmpty {
      try visitor.visitSingularStringField(value: self.scheme, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption, rhs: Google_Cloud_Video_Transcoder_V1beta1_Encryption.MpegCommonEncryption) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.scheme != rhs.scheme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_Progress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Progress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "analyzed"),
    2: .same(proto: "encoded"),
    3: .same(proto: "uploaded"),
    4: .same(proto: "notified"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.analyzed) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.encoded) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.uploaded) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.notified) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.analyzed != 0 {
      try visitor.visitSingularDoubleField(value: self.analyzed, fieldNumber: 1)
    }
    if self.encoded != 0 {
      try visitor.visitSingularDoubleField(value: self.encoded, fieldNumber: 2)
    }
    if self.uploaded != 0 {
      try visitor.visitSingularDoubleField(value: self.uploaded, fieldNumber: 3)
    }
    if self.notified != 0 {
      try visitor.visitSingularDoubleField(value: self.notified, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_Progress, rhs: Google_Cloud_Video_Transcoder_V1beta1_Progress) -> Bool {
    if lhs.analyzed != rhs.analyzed {return false}
    if lhs.encoded != rhs.encoded {return false}
    if lhs.uploaded != rhs.uploaded {return false}
    if lhs.notified != rhs.notified {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Video_Transcoder_V1beta1_FailureDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailureDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Video_Transcoder_V1beta1_FailureDetail, rhs: Google_Cloud_Video_Transcoder_V1beta1_FailureDetail) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

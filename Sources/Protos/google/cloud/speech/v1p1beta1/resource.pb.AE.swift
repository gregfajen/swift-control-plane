// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/speech/v1p1beta1/resource.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A set of words or phrases that represents a common concept likely to appear
/// in your audio, for example a list of passenger ship names. CustomClass items
/// can be substituted into placeholders that you set in PhraseSet phrases.
public struct Google_Cloud_Speech_V1p1beta1_CustomClass {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the custom class.
  public var name: String = String()

  /// If this custom class is a resource, the custom_class_id is the resource id
  /// of the CustomClass.
  public var customClassID: String = String()

  /// A collection of class items.
  public var items: [Google_Cloud_Speech_V1p1beta1_CustomClass.ClassItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An item of the class.
  public struct ClassItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The class item's value.
    public var value: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Provides "hints" to the speech recognizer to favor specific words and phrases
/// in the results.
public struct Google_Cloud_Speech_V1p1beta1_PhraseSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the phrase set.
  public var name: String = String()

  /// A list of word and phrases.
  public var phrases: [Google_Cloud_Speech_V1p1beta1_PhraseSet.Phrase] = []

  /// Hint Boost. Positive value will increase the probability that a specific
  /// phrase will be recognized over other similar sounding phrases. The higher
  /// the boost, the higher the chance of false positive recognition as well.
  /// Negative boost values would correspond to anti-biasing. Anti-biasing is not
  /// enabled, so negative boost will simply be ignored. Though `boost` can
  /// accept a wide range of positive values, most use cases are best served with
  /// values between 0 (exclusive) and 20. We recommend using a binary search
  /// approach to finding the optimal value for your use case. Speech recognition
  /// will skip PhraseSets with a boost value of 0.
  public var boost: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A phrases containing words and phrase "hints" so that
  /// the speech recognition is more likely to recognize them. This can be used
  /// to improve the accuracy for specific words and phrases, for example, if
  /// specific commands are typically spoken by the user. This can also be used
  /// to add additional words to the vocabulary of the recognizer. See
  /// [usage limits](https://cloud.google.com/speech-to-text/quotas#content).
  ///
  /// List items can also include pre-built or custom classes containing groups
  /// of words that represent common concepts that occur in natural language. For
  /// example, rather than providing a phrase hint for every month of the
  /// year (e.g. "i was born in january", "i was born in febuary", ...), use the
  /// pre-built `$MONTH` class improves the likelihood of correctly transcribing
  /// audio that includes months (e.g. "i was born in $month").
  /// To refer to pre-built classes, use the class' symbol prepended with `$`
  /// e.g. `$MONTH`. To refer to custom classes that were defined inline in the
  /// request, set the class's `custom_class_id` to a string unique to all class
  /// resources and inline classes. Then use the class' id wrapped in $`{...}`
  /// e.g. "${my-months}". To refer to custom classes resources, use the class'
  /// id wrapped in `${}` (e.g. `${my-months}`).
  public struct Phrase {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The phrase itself.
    public var value: String = String()

    /// Hint Boost. Overrides the boost set at the phrase set level.
    /// Positive value will increase the probability that a specific phrase will
    /// be recognized over other similar sounding phrases. The higher the boost,
    /// the higher the chance of false positive recognition as well. Negative
    /// boost values would correspond to anti-biasing. Anti-biasing is not
    /// enabled, so negative boost will simply be ignored. Though `boost` can
    /// accept a wide range of positive values, most use cases are best served
    /// with values between 0 and 20. We recommend using a binary search approach
    /// to finding the optimal value for your use case. Speech recognition
    /// will skip PhraseSets with a boost value of 0.
    public var boost: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Speech adaptation configuration.
public struct Google_Cloud_Speech_V1p1beta1_SpeechAdaptation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of phrase sets. To specify the hints inline, leave the
  /// phrase set's `name` blank and fill in the rest of its fields. Any
  /// phrase set can use any custom class.
  public var phraseSets: [Google_Cloud_Speech_V1p1beta1_PhraseSet] = []

  /// A collection of custom classes. To specify the classes inline, leave the
  /// class' `name` blank and fill in the rest of its fields, giving it a unique
  /// `custom_class_id`. Refer to the inline defined class in phrase hints by its
  /// `custom_class_id`.
  public var customClasses: [Google_Cloud_Speech_V1p1beta1_CustomClass] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.speech.v1p1beta1"

extension Google_Cloud_Speech_V1p1beta1_CustomClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomClass"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "custom_class_id"),
    3: .same(proto: "items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.customClassID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.items) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.customClassID.isEmpty {
      try visitor.visitSingularStringField(value: self.customClassID, fieldNumber: 2)
    }
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Speech_V1p1beta1_CustomClass, rhs: Google_Cloud_Speech_V1p1beta1_CustomClass) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.customClassID != rhs.customClassID {return false}
    if lhs.items != rhs.items {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Speech_V1p1beta1_CustomClass.ClassItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Speech_V1p1beta1_CustomClass.protoMessageName + ".ClassItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Speech_V1p1beta1_CustomClass.ClassItem, rhs: Google_Cloud_Speech_V1p1beta1_CustomClass.ClassItem) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Speech_V1p1beta1_PhraseSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PhraseSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "phrases"),
    4: .same(proto: "boost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.phrases) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.boost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.phrases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phrases, fieldNumber: 2)
    }
    if self.boost != 0 {
      try visitor.visitSingularFloatField(value: self.boost, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Speech_V1p1beta1_PhraseSet, rhs: Google_Cloud_Speech_V1p1beta1_PhraseSet) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.phrases != rhs.phrases {return false}
    if lhs.boost != rhs.boost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Speech_V1p1beta1_PhraseSet.Phrase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Speech_V1p1beta1_PhraseSet.protoMessageName + ".Phrase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "boost"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.boost) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 1)
    }
    if self.boost != 0 {
      try visitor.visitSingularFloatField(value: self.boost, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Speech_V1p1beta1_PhraseSet.Phrase, rhs: Google_Cloud_Speech_V1p1beta1_PhraseSet.Phrase) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.boost != rhs.boost {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Speech_V1p1beta1_SpeechAdaptation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpeechAdaptation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phrase_sets"),
    2: .standard(proto: "custom_classes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.phraseSets) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.customClasses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.phraseSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.phraseSets, fieldNumber: 1)
    }
    if !self.customClasses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customClasses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Speech_V1p1beta1_SpeechAdaptation, rhs: Google_Cloud_Speech_V1p1beta1_SpeechAdaptation) -> Bool {
    if lhs.phraseSets != rhs.phraseSets {return false}
    if lhs.customClasses != rhs.customClasses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

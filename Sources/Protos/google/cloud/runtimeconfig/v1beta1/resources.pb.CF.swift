// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/runtimeconfig/v1beta1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The `VariableState` describes the last known state of the variable and is
/// used during a `variables().watch` call to distinguish the state of the
/// variable.
public enum Google_Cloud_Runtimeconfig_V1beta1_VariableState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default variable state.
  case unspecified // = 0

  /// The variable was updated, while `variables().watch` was executing.
  case updated // = 1

  /// The variable was deleted, while `variables().watch` was executing.
  case deleted // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .updated
    case 2: self = .deleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .updated: return 1
    case .deleted: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Runtimeconfig_V1beta1_VariableState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Runtimeconfig_V1beta1_VariableState] = [
    .unspecified,
    .updated,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

/// A RuntimeConfig resource is the primary resource in the Cloud RuntimeConfig
/// service. A RuntimeConfig resource consists of metadata and a hierarchy of
/// variables.
public struct Google_Cloud_Runtimeconfig_V1beta1_RuntimeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of a runtime config. The name must have the format:
  ///
  ///     projects/[PROJECT_ID]/configs/[CONFIG_NAME]
  ///
  /// The `[PROJECT_ID]` must be a valid project ID, and `[CONFIG_NAME]` is an
  /// arbitrary name that matches RFC 1035 segment specification. The length of
  /// `[CONFIG_NAME]` must be less than 64 bytes.
  ///
  /// You pick the RuntimeConfig resource name, but the server will validate that
  /// the name adheres to this format. After you create the resource, you cannot
  /// change the resource's name.
  public var name: String = String()

  /// An optional description of the RuntimeConfig object.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a single variable within a RuntimeConfig resource.
/// The name denotes the hierarchical variable name. For example,
/// `ports/serving_port` is a valid variable name. The variable value is an
/// opaque string and only leaf variables can have values (that is, variables
/// that do not have any child variables).
public struct Google_Cloud_Runtimeconfig_V1beta1_Variable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the variable resource, in the format:
  ///
  ///     projects/[PROJECT_ID]/configs/[CONFIG_NAME]/variables/[VARIABLE_NAME]
  ///
  /// The `[PROJECT_ID]` must be a valid project ID, `[CONFIG_NAME]` must be a
  /// valid RuntimeConfig reource and `[VARIABLE_NAME]` follows Unix file system
  /// file path naming.
  ///
  /// The `[VARIABLE_NAME]` can contain ASCII letters, numbers, slashes and
  /// dashes. Slashes are used as path element separators and are not part of the
  /// `[VARIABLE_NAME]` itself, so `[VARIABLE_NAME]` must contain at least one
  /// non-slash character. Multiple slashes are coalesced into single slash
  /// character. Each path segment should follow RFC 1035 segment specification.
  /// The length of a `[VARIABLE_NAME]` must be less than 256 bytes.
  ///
  /// Once you create a variable, you cannot change the variable name.
  public var name: String = String()

  /// The value of the variable. It can be either a binary or a string
  /// value. You must specify one of either `value` or `text`. Specifying both
  /// will cause the server to return an error.
  public var contents: Google_Cloud_Runtimeconfig_V1beta1_Variable.OneOf_Contents? = nil

  /// The binary value of the variable. The length of the value must be less
  /// than 4096 bytes. Empty values are also accepted. The value must be
  /// base64 encoded. Only one of `value` or `text` can be set.
  public var value: Data {
    get {
      if case .value(let v)? = contents {return v}
      return Data()
    }
    set {contents = .value(newValue)}
  }

  /// The string value of the variable. The length of the value must be less
  /// than 4096 bytes. Empty values are also accepted. For example,
  /// `text: "my text value"`. The string must be valid UTF-8.
  public var text: String {
    get {
      if case .text(let v)? = contents {return v}
      return String()
    }
    set {contents = .text(newValue)}
  }

  /// [Output Only] The time of the last variable update.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// [Ouput only] The current state of the variable. The variable state
  /// indicates the outcome of the `variables().watch` call and is visible
  /// through the `get` and `list` calls.
  public var state: Google_Cloud_Runtimeconfig_V1beta1_VariableState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The value of the variable. It can be either a binary or a string
  /// value. You must specify one of either `value` or `text`. Specifying both
  /// will cause the server to return an error.
  public enum OneOf_Contents: Equatable {
    /// The binary value of the variable. The length of the value must be less
    /// than 4096 bytes. Empty values are also accepted. The value must be
    /// base64 encoded. Only one of `value` or `text` can be set.
    case value(Data)
    /// The string value of the variable. The length of the value must be less
    /// than 4096 bytes. Empty values are also accepted. For example,
    /// `text: "my text value"`. The string must be valid UTF-8.
    case text(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_Variable.OneOf_Contents, rhs: Google_Cloud_Runtimeconfig_V1beta1_Variable.OneOf_Contents) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The condition that a Waiter resource is waiting for.
public struct Google_Cloud_Runtimeconfig_V1beta1_EndCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The condition oneof holds the available condition types for this
  /// EndCondition. Currently, the only available type is Cardinality.
  public var condition: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.OneOf_Condition? = nil

  /// The cardinality of the `EndCondition`.
  public var cardinality: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality {
    get {
      if case .cardinality(let v)? = condition {return v}
      return Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality()
    }
    set {condition = .cardinality(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The condition oneof holds the available condition types for this
  /// EndCondition. Currently, the only available type is Cardinality.
  public enum OneOf_Condition: Equatable {
    /// The cardinality of the `EndCondition`.
    case cardinality(Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.OneOf_Condition, rhs: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.OneOf_Condition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cardinality, .cardinality): return {
        guard case .cardinality(let l) = lhs, case .cardinality(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// A Cardinality condition for the Waiter resource. A cardinality condition is
  /// met when the number of variables under a specified path prefix reaches a
  /// predefined number. For example, if you set a Cardinality condition where
  /// the `path` is set to `/foo` and the number of paths is set to 2, the
  /// following variables would meet the condition in a RuntimeConfig resource:
  ///
  /// + `/foo/variable1 = "value1"`
  /// + `/foo/variable2 = "value2"`
  /// + `/bar/variable3 = "value3"`
  ///
  /// It would not would not satisify the same condition with the `number` set to
  /// 3, however, because there is only 2 paths that start with `/foo`.
  /// Cardinality conditions are recursive; all subtrees under the specific
  /// path prefix are counted.
  public struct Cardinality {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The root of the variable subtree to monitor. For example, `/foo`.
    public var path: String = String()

    /// The number variables under the `path` that must exist to meet this
    /// condition. Defaults to 1 if not specified.
    public var number: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A Waiter resource waits for some end condition within a RuntimeConfig
/// resource to be met before it returns. For example, assume you have a
/// distributed system where each node writes to a Variable resource indidicating
/// the node's readiness as part of the startup process.
///
/// You then configure a Waiter resource with the success condition set to wait
/// until some number of nodes have checked in. Afterwards, your application
/// runs some arbitrary code after the condition has been met and the waiter
/// returns successfully.
///
/// Once created, a Waiter resource is immutable.
///
/// To learn more about using waiters, read the
/// [Creating a
/// Waiter](/deployment-manager/runtime-configurator/creating-a-waiter)
/// documentation.
public struct Google_Cloud_Runtimeconfig_V1beta1_Waiter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the Waiter resource, in the format:
  ///
  ///     projects/[PROJECT_ID]/configs/[CONFIG_NAME]/waiters/[WAITER_NAME]
  ///
  /// The `[PROJECT_ID]` must be a valid Google Cloud project ID,
  /// the `[CONFIG_NAME]` must be a valid RuntimeConfig resource, the
  /// `[WAITER_NAME]` must match RFC 1035 segment specification, and the length
  /// of `[WAITER_NAME]` must be less than 64 bytes.
  ///
  /// After you create a Waiter resource, you cannot change the resource name.
  public var name: String = String()

  /// [Required] Specifies the timeout of the waiter in seconds, beginning from
  /// the instant that `waiters().create` method is called. If this time elapses
  /// before the success or failure conditions are met, the waiter fails and sets
  /// the `error` code to `DEADLINE_EXCEEDED`.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// [Optional] The failure condition of this waiter. If this condition is met,
  /// `done` will be set to `true` and the `error` code will be set to `ABORTED`.
  /// The failure condition takes precedence over the success condition. If both
  /// conditions are met, a failure will be indicated. This value is optional; if
  /// no failure condition is set, the only failure scenario will be a timeout.
  public var failure: Google_Cloud_Runtimeconfig_V1beta1_EndCondition {
    get {return _failure ?? Google_Cloud_Runtimeconfig_V1beta1_EndCondition()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  public var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  public mutating func clearFailure() {self._failure = nil}

  /// [Required] The success condition. If this condition is met, `done` will be
  /// set to `true` and the `error` value will remain unset. The failure
  /// condition takes precedence over the success condition. If both conditions
  /// are met, a failure will be indicated.
  public var success: Google_Cloud_Runtimeconfig_V1beta1_EndCondition {
    get {return _success ?? Google_Cloud_Runtimeconfig_V1beta1_EndCondition()}
    set {_success = newValue}
  }
  /// Returns true if `success` has been explicitly set.
  public var hasSuccess: Bool {return self._success != nil}
  /// Clears the value of `success`. Subsequent reads from it will return its default value.
  public mutating func clearSuccess() {self._success = nil}

  /// [Output Only] The instant at which this Waiter resource was created. Adding
  /// the value of `timeout` to this instant yields the timeout deadline for the
  /// waiter.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// [Output Only] If the value is `false`, it means the waiter is still waiting
  /// for one of its conditions to be met.
  ///
  /// If true, the waiter has finished. If the waiter finished due to a timeout
  /// or failure, `error` will be set.
  public var done: Bool = false

  /// [Output Only] If the waiter ended due to a failure or timeout, this value
  /// will be set.
  public var error: Google_Rpc_Status {
    get {return _error ?? Google_Rpc_Status()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  public var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  public mutating func clearError() {self._error = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _failure: Google_Cloud_Runtimeconfig_V1beta1_EndCondition? = nil
  fileprivate var _success: Google_Cloud_Runtimeconfig_V1beta1_EndCondition? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _error: Google_Rpc_Status? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.runtimeconfig.v1beta1"

extension Google_Cloud_Runtimeconfig_V1beta1_VariableState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VARIABLE_STATE_UNSPECIFIED"),
    1: .same(proto: "UPDATED"),
    2: .same(proto: "DELETED"),
  ]
}

extension Google_Cloud_Runtimeconfig_V1beta1_RuntimeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RuntimeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_RuntimeConfig, rhs: Google_Cloud_Runtimeconfig_V1beta1_RuntimeConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Runtimeconfig_V1beta1_Variable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Variable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    5: .same(proto: "text"),
    3: .standard(proto: "update_time"),
    4: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        if self.contents != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.contents = .value(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try {
        if self.contents != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.contents = .text(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .value(let v)? = self.contents {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if case .text(let v)? = self.contents {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_Variable, rhs: Google_Cloud_Runtimeconfig_V1beta1_Variable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Runtimeconfig_V1beta1_EndCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cardinality"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .cardinality(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .cardinality(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .cardinality(let v)? = self.condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_EndCondition, rhs: Google_Cloud_Runtimeconfig_V1beta1_EndCondition) -> Bool {
    if lhs.condition != rhs.condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Runtimeconfig_V1beta1_EndCondition.protoMessageName + ".Cardinality"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt32Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality, rhs: Google_Cloud_Runtimeconfig_V1beta1_EndCondition.Cardinality) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Runtimeconfig_V1beta1_Waiter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Waiter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "timeout"),
    3: .same(proto: "failure"),
    4: .same(proto: "success"),
    5: .standard(proto: "create_time"),
    6: .same(proto: "done"),
    7: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._success) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._success {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 6)
    }
    if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Runtimeconfig_V1beta1_Waiter, rhs: Google_Cloud_Runtimeconfig_V1beta1_Waiter) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs._success != rhs._success {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/kms/v1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] specifies how cryptographic operations are performed.
/// For more information, see [Protection levels]
/// (https://cloud.google.com/kms/docs/algorithms#protection_levels).
public enum Google_Cloud_Kms_V1_ProtectionLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified.
  case unspecified // = 0

  /// Crypto operations are performed in software.
  case software // = 1

  /// Crypto operations are performed in a Hardware Security Module.
  case hsm // = 2

  /// Crypto operations are performed by an external key manager.
  case external // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .software
    case 2: self = .hsm
    case 3: self = .external
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .software: return 1
    case .hsm: return 2
    case .external: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Kms_V1_ProtectionLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_ProtectionLevel] = [
    .unspecified,
    .software,
    .hsm,
    .external,
  ]
}

#endif  // swift(>=4.2)

/// A [KeyRing][google.cloud.kms.v1.KeyRing] is a toplevel logical grouping of [CryptoKeys][google.cloud.kms.v1.CryptoKey].
public struct Google_Cloud_Kms_V1_KeyRing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name for the [KeyRing][google.cloud.kms.v1.KeyRing] in the format
  /// `projects/*/locations/*/keyRings/*`.
  public var name: String = String()

  /// Output only. The time at which this [KeyRing][google.cloud.kms.v1.KeyRing] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A [CryptoKey][google.cloud.kms.v1.CryptoKey] represents a logical key that can be used for cryptographic
/// operations.
///
/// A [CryptoKey][google.cloud.kms.v1.CryptoKey] is made up of zero or more [versions][google.cloud.kms.v1.CryptoKeyVersion],
/// which represent the actual key material used in cryptographic operations.
public struct Google_Cloud_Kms_V1_CryptoKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name for this [CryptoKey][google.cloud.kms.v1.CryptoKey] in the format
  /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
  public var name: String = String()

  /// Output only. A copy of the "primary" [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that will be used
  /// by [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] when this [CryptoKey][google.cloud.kms.v1.CryptoKey] is given
  /// in [EncryptRequest.name][google.cloud.kms.v1.EncryptRequest.name].
  ///
  /// The [CryptoKey][google.cloud.kms.v1.CryptoKey]'s primary version can be updated via
  /// [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
  ///
  /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT] may have a
  /// primary. For other keys, this field will be omitted.
  public var primary: Google_Cloud_Kms_V1_CryptoKeyVersion {
    get {return _primary ?? Google_Cloud_Kms_V1_CryptoKeyVersion()}
    set {_primary = newValue}
  }
  /// Returns true if `primary` has been explicitly set.
  public var hasPrimary: Bool {return self._primary != nil}
  /// Clears the value of `primary`. Subsequent reads from it will return its default value.
  public mutating func clearPrimary() {self._primary = nil}

  /// Immutable. The immutable purpose of this [CryptoKey][google.cloud.kms.v1.CryptoKey].
  public var purpose: Google_Cloud_Kms_V1_CryptoKey.CryptoKeyPurpose = .unspecified

  /// Output only. The time at which this [CryptoKey][google.cloud.kms.v1.CryptoKey] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// At [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time], the Key Management Service will automatically:
  ///
  /// 1. Create a new version of this [CryptoKey][google.cloud.kms.v1.CryptoKey].
  /// 2. Mark the new version as primary.
  ///
  /// Key rotations performed manually via
  /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion] and
  /// [UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion]
  /// do not affect [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time].
  ///
  /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT] support
  /// automatic rotation. For other keys, this field must be omitted.
  public var nextRotationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextRotationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextRotationTime = newValue}
  }
  /// Returns true if `nextRotationTime` has been explicitly set.
  public var hasNextRotationTime: Bool {return self._nextRotationTime != nil}
  /// Clears the value of `nextRotationTime`. Subsequent reads from it will return its default value.
  public mutating func clearNextRotationTime() {self._nextRotationTime = nil}

  /// Controls the rate of automatic rotation.
  public var rotationSchedule: Google_Cloud_Kms_V1_CryptoKey.OneOf_RotationSchedule? = nil

  /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time] will be advanced by this period when the service
  /// automatically rotates a key. Must be at least 24 hours and at most
  /// 876,000 hours.
  ///
  /// If [rotation_period][google.cloud.kms.v1.CryptoKey.rotation_period] is set, [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time] must also be set.
  ///
  /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT] support
  /// automatic rotation. For other keys, this field must be omitted.
  public var rotationPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .rotationPeriod(let v)? = rotationSchedule {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {rotationSchedule = .rotationPeriod(newValue)}
  }

  /// A template describing settings for new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] instances.
  /// The properties of new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] instances created by either
  /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion] or
  /// auto-rotation are controlled by this template.
  public var versionTemplate: Google_Cloud_Kms_V1_CryptoKeyVersionTemplate {
    get {return _versionTemplate ?? Google_Cloud_Kms_V1_CryptoKeyVersionTemplate()}
    set {_versionTemplate = newValue}
  }
  /// Returns true if `versionTemplate` has been explicitly set.
  public var hasVersionTemplate: Bool {return self._versionTemplate != nil}
  /// Clears the value of `versionTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearVersionTemplate() {self._versionTemplate = nil}

  /// Labels with user-defined metadata. For more information, see
  /// [Labeling Keys](https://cloud.google.com/kms/docs/labeling-keys).
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Controls the rate of automatic rotation.
  public enum OneOf_RotationSchedule: Equatable {
    /// [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time] will be advanced by this period when the service
    /// automatically rotates a key. Must be at least 24 hours and at most
    /// 876,000 hours.
    ///
    /// If [rotation_period][google.cloud.kms.v1.CryptoKey.rotation_period] is set, [next_rotation_time][google.cloud.kms.v1.CryptoKey.next_rotation_time] must also be set.
    ///
    /// Keys with [purpose][google.cloud.kms.v1.CryptoKey.purpose]
    /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT] support
    /// automatic rotation. For other keys, this field must be omitted.
    case rotationPeriod(SwiftProtobuf.Google_Protobuf_Duration)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Kms_V1_CryptoKey.OneOf_RotationSchedule, rhs: Google_Cloud_Kms_V1_CryptoKey.OneOf_RotationSchedule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rotationPeriod, .rotationPeriod): return {
        guard case .rotationPeriod(let l) = lhs, case .rotationPeriod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] describes the cryptographic capabilities of a
  /// [CryptoKey][google.cloud.kms.v1.CryptoKey]. A given key can only be used for the operations allowed by
  /// its purpose. For more information, see
  /// [Key purposes](https://cloud.google.com/kms/docs/algorithms#key_purposes).
  public enum CryptoKeyPurpose: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used with
    /// [Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt] and
    /// [Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
    case encryptDecrypt // = 1

    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used with
    /// [AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign] and
    /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
    case asymmetricSign // = 5

    /// [CryptoKeys][google.cloud.kms.v1.CryptoKey] with this purpose may be used with
    /// [AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt] and
    /// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
    case asymmetricDecrypt // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .encryptDecrypt
      case 5: self = .asymmetricSign
      case 6: self = .asymmetricDecrypt
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .encryptDecrypt: return 1
      case .asymmetricSign: return 5
      case .asymmetricDecrypt: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _primary: Google_Cloud_Kms_V1_CryptoKeyVersion? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _nextRotationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _versionTemplate: Google_Cloud_Kms_V1_CryptoKeyVersionTemplate? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Kms_V1_CryptoKey.CryptoKeyPurpose: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_CryptoKey.CryptoKeyPurpose] = [
    .unspecified,
    .encryptDecrypt,
    .asymmetricSign,
    .asymmetricDecrypt,
  ]
}

#endif  // swift(>=4.2)

/// A [CryptoKeyVersionTemplate][google.cloud.kms.v1.CryptoKeyVersionTemplate] specifies the properties to use when creating
/// a new [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], either manually with
/// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion] or
/// automatically as a result of auto-rotation.
public struct Google_Cloud_Kms_V1_CryptoKeyVersionTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] to use when creating a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on
  /// this template. Immutable. Defaults to [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE].
  public var protectionLevel: Google_Cloud_Kms_V1_ProtectionLevel = .unspecified

  /// Required. [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm] to use
  /// when creating a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] based on this template.
  ///
  /// For backwards compatibility, GOOGLE_SYMMETRIC_ENCRYPTION is implied if both
  /// this field is omitted and [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose] is
  /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
  public var algorithm: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains an HSM-generated attestation about a key operation. For more
/// information, see [Verifying attestations]
/// (https://cloud.google.com/kms/docs/attest-key).
public struct Google_Cloud_Kms_V1_KeyOperationAttestation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The format of the attestation data.
  public var format: Google_Cloud_Kms_V1_KeyOperationAttestation.AttestationFormat = .unspecified

  /// Output only. The attestation data provided by the HSM when the key
  /// operation was performed.
  public var content: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Attestation formats provided by the HSM.
  public enum AttestationFormat: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// Cavium HSM attestation compressed with gzip. Note that this format is
    /// defined by Cavium and subject to change at any time.
    case caviumV1Compressed // = 3

    /// Cavium HSM attestation V2 compressed with gzip. This is a new format
    /// introduced in Cavium's version 3.2-08.
    case caviumV2Compressed // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 3: self = .caviumV1Compressed
      case 4: self = .caviumV2Compressed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .caviumV1Compressed: return 3
      case .caviumV2Compressed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Kms_V1_KeyOperationAttestation.AttestationFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_KeyOperationAttestation.AttestationFormat] = [
    .unspecified,
    .caviumV1Compressed,
    .caviumV2Compressed,
  ]
}

#endif  // swift(>=4.2)

/// A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents an individual cryptographic key, and the
/// associated key material.
///
/// An [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED] version can be
/// used for cryptographic operations.
///
/// For security reasons, the raw cryptographic key material represented by a
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] can never be viewed or exported. It can only be used to
/// encrypt, decrypt, or sign data when an authorized user or application invokes
/// Cloud KMS.
public struct Google_Cloud_Kms_V1_CryptoKeyVersion {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name for this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in the format
  /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The current state of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
  public var state: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. The [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] describing how crypto operations are
  /// performed with this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion].
  public var protectionLevel: Google_Cloud_Kms_V1_ProtectionLevel {
    get {return _storage._protectionLevel}
    set {_uniqueStorage()._protectionLevel = newValue}
  }

  /// Output only. The [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm] that this
  /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] supports.
  public var algorithm: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm {
    get {return _storage._algorithm}
    set {_uniqueStorage()._algorithm = newValue}
  }

  /// Output only. Statement that was generated and signed by the HSM at key
  /// creation time. Use this statement to verify attributes of the key as stored
  /// on the HSM, independently of Google. Only provided for key versions with
  /// [protection_level][google.cloud.kms.v1.CryptoKeyVersion.protection_level] [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
  public var attestation: Google_Cloud_Kms_V1_KeyOperationAttestation {
    get {return _storage._attestation ?? Google_Cloud_Kms_V1_KeyOperationAttestation()}
    set {_uniqueStorage()._attestation = newValue}
  }
  /// Returns true if `attestation` has been explicitly set.
  public var hasAttestation: Bool {return _storage._attestation != nil}
  /// Clears the value of `attestation`. Subsequent reads from it will return its default value.
  public mutating func clearAttestation() {_uniqueStorage()._attestation = nil}

  /// Output only. The time at which this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material was
  /// generated.
  public var generateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._generateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._generateTime = newValue}
  }
  /// Returns true if `generateTime` has been explicitly set.
  public var hasGenerateTime: Bool {return _storage._generateTime != nil}
  /// Clears the value of `generateTime`. Subsequent reads from it will return its default value.
  public mutating func clearGenerateTime() {_uniqueStorage()._generateTime = nil}

  /// Output only. The time this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material is scheduled
  /// for destruction. Only present if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
  /// [DESTROY_SCHEDULED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROY_SCHEDULED].
  public var destroyTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._destroyTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._destroyTime = newValue}
  }
  /// Returns true if `destroyTime` has been explicitly set.
  public var hasDestroyTime: Bool {return _storage._destroyTime != nil}
  /// Clears the value of `destroyTime`. Subsequent reads from it will return its default value.
  public mutating func clearDestroyTime() {_uniqueStorage()._destroyTime = nil}

  /// Output only. The time this CryptoKeyVersion's key material was
  /// destroyed. Only present if [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
  /// [DESTROYED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DESTROYED].
  public var destroyEventTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._destroyEventTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._destroyEventTime = newValue}
  }
  /// Returns true if `destroyEventTime` has been explicitly set.
  public var hasDestroyEventTime: Bool {return _storage._destroyEventTime != nil}
  /// Clears the value of `destroyEventTime`. Subsequent reads from it will return its default value.
  public mutating func clearDestroyEventTime() {_uniqueStorage()._destroyEventTime = nil}

  /// Output only. The name of the [ImportJob][google.cloud.kms.v1.ImportJob] used to import this
  /// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Only present if the underlying key material was
  /// imported.
  public var importJob: String {
    get {return _storage._importJob}
    set {_uniqueStorage()._importJob = newValue}
  }

  /// Output only. The time at which this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s key material
  /// was imported.
  public var importTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._importTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._importTime = newValue}
  }
  /// Returns true if `importTime` has been explicitly set.
  public var hasImportTime: Bool {return _storage._importTime != nil}
  /// Clears the value of `importTime`. Subsequent reads from it will return its default value.
  public mutating func clearImportTime() {_uniqueStorage()._importTime = nil}

  /// Output only. The root cause of an import failure. Only present if
  /// [state][google.cloud.kms.v1.CryptoKeyVersion.state] is
  /// [IMPORT_FAILED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.IMPORT_FAILED].
  public var importFailureReason: String {
    get {return _storage._importFailureReason}
    set {_uniqueStorage()._importFailureReason = newValue}
  }

  /// ExternalProtectionLevelOptions stores a group of additional fields for
  /// configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that are specific to the
  /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] protection level.
  public var externalProtectionLevelOptions: Google_Cloud_Kms_V1_ExternalProtectionLevelOptions {
    get {return _storage._externalProtectionLevelOptions ?? Google_Cloud_Kms_V1_ExternalProtectionLevelOptions()}
    set {_uniqueStorage()._externalProtectionLevelOptions = newValue}
  }
  /// Returns true if `externalProtectionLevelOptions` has been explicitly set.
  public var hasExternalProtectionLevelOptions: Bool {return _storage._externalProtectionLevelOptions != nil}
  /// Clears the value of `externalProtectionLevelOptions`. Subsequent reads from it will return its default value.
  public mutating func clearExternalProtectionLevelOptions() {_uniqueStorage()._externalProtectionLevelOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The algorithm of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], indicating what
  /// parameters must be used for each cryptographic operation.
  ///
  /// The
  /// [GOOGLE_SYMMETRIC_ENCRYPTION][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.GOOGLE_SYMMETRIC_ENCRYPTION]
  /// algorithm is usable with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ENCRYPT_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ENCRYPT_DECRYPT].
  ///
  /// Algorithms beginning with "RSA_SIGN_" are usable with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
  ///
  /// The fields in the name after "RSA_SIGN_" correspond to the following
  /// parameters: padding algorithm, modulus bit length, and digest algorithm.
  ///
  /// For PSS, the salt length used is equal to the length of digest
  /// algorithm. For example,
  /// [RSA_SIGN_PSS_2048_SHA256][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256]
  /// will use PSS with a salt length of 256 bits or 32 bytes.
  ///
  /// Algorithms beginning with "RSA_DECRYPT_" are usable with
  /// [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ASYMMETRIC_DECRYPT][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_DECRYPT].
  ///
  /// The fields in the name after "RSA_DECRYPT_" correspond to the following
  /// parameters: padding algorithm, modulus bit length, and digest algorithm.
  ///
  /// Algorithms beginning with "EC_SIGN_" are usable with [CryptoKey.purpose][google.cloud.kms.v1.CryptoKey.purpose]
  /// [ASYMMETRIC_SIGN][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose.ASYMMETRIC_SIGN].
  ///
  /// The fields in the name after "EC_SIGN_" correspond to the following
  /// parameters: elliptic curve, digest algorithm.
  ///
  /// For more information, see [Key purposes and algorithms]
  /// (https://cloud.google.com/kms/docs/algorithms).
  public enum CryptoKeyVersionAlgorithm: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// Creates symmetric encryption keys.
    case googleSymmetricEncryption // = 1

    /// RSASSA-PSS 2048 bit key with a SHA256 digest.
    case rsaSignPss2048Sha256 // = 2

    /// RSASSA-PSS 3072 bit key with a SHA256 digest.
    case rsaSignPss3072Sha256 // = 3

    /// RSASSA-PSS 4096 bit key with a SHA256 digest.
    case rsaSignPss4096Sha256 // = 4

    /// RSASSA-PSS 4096 bit key with a SHA512 digest.
    case rsaSignPss4096Sha512 // = 15

    /// RSASSA-PKCS1-v1_5 with a 2048 bit key and a SHA256 digest.
    case rsaSignPkcs12048Sha256 // = 5

    /// RSASSA-PKCS1-v1_5 with a 3072 bit key and a SHA256 digest.
    case rsaSignPkcs13072Sha256 // = 6

    /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA256 digest.
    case rsaSignPkcs14096Sha256 // = 7

    /// RSASSA-PKCS1-v1_5 with a 4096 bit key and a SHA512 digest.
    case rsaSignPkcs14096Sha512 // = 16

    /// RSAES-OAEP 2048 bit key with a SHA256 digest.
    case rsaDecryptOaep2048Sha256 // = 8

    /// RSAES-OAEP 3072 bit key with a SHA256 digest.
    case rsaDecryptOaep3072Sha256 // = 9

    /// RSAES-OAEP 4096 bit key with a SHA256 digest.
    case rsaDecryptOaep4096Sha256 // = 10

    /// RSAES-OAEP 4096 bit key with a SHA512 digest.
    case rsaDecryptOaep4096Sha512 // = 17

    /// ECDSA on the NIST P-256 curve with a SHA256 digest.
    case ecSignP256Sha256 // = 12

    /// ECDSA on the NIST P-384 curve with a SHA384 digest.
    case ecSignP384Sha384 // = 13

    /// Algorithm representing symmetric encryption by an external key manager.
    case externalSymmetricEncryption // = 18
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .googleSymmetricEncryption
      case 2: self = .rsaSignPss2048Sha256
      case 3: self = .rsaSignPss3072Sha256
      case 4: self = .rsaSignPss4096Sha256
      case 5: self = .rsaSignPkcs12048Sha256
      case 6: self = .rsaSignPkcs13072Sha256
      case 7: self = .rsaSignPkcs14096Sha256
      case 8: self = .rsaDecryptOaep2048Sha256
      case 9: self = .rsaDecryptOaep3072Sha256
      case 10: self = .rsaDecryptOaep4096Sha256
      case 12: self = .ecSignP256Sha256
      case 13: self = .ecSignP384Sha384
      case 15: self = .rsaSignPss4096Sha512
      case 16: self = .rsaSignPkcs14096Sha512
      case 17: self = .rsaDecryptOaep4096Sha512
      case 18: self = .externalSymmetricEncryption
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .googleSymmetricEncryption: return 1
      case .rsaSignPss2048Sha256: return 2
      case .rsaSignPss3072Sha256: return 3
      case .rsaSignPss4096Sha256: return 4
      case .rsaSignPkcs12048Sha256: return 5
      case .rsaSignPkcs13072Sha256: return 6
      case .rsaSignPkcs14096Sha256: return 7
      case .rsaDecryptOaep2048Sha256: return 8
      case .rsaDecryptOaep3072Sha256: return 9
      case .rsaDecryptOaep4096Sha256: return 10
      case .ecSignP256Sha256: return 12
      case .ecSignP384Sha384: return 13
      case .rsaSignPss4096Sha512: return 15
      case .rsaSignPkcs14096Sha512: return 16
      case .rsaDecryptOaep4096Sha512: return 17
      case .externalSymmetricEncryption: return 18
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The state of a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], indicating if it can be used.
  public enum CryptoKeyVersionState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// This version is still being generated. It may not be used, enabled,
    /// disabled, or destroyed yet. Cloud KMS will automatically mark this
    /// version [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED] as soon as the version is ready.
    case pendingGeneration // = 5

    /// This version may be used for cryptographic operations.
    case enabled // = 1

    /// This version may not be used, but the key material is still available,
    /// and the version can be placed back into the [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED] state.
    case disabled // = 2

    /// This version is destroyed, and the key material is no longer stored.
    /// A version may not leave this state once entered.
    case destroyed // = 3

    /// This version is scheduled for destruction, and will be destroyed soon.
    /// Call
    /// [RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion]
    /// to put it back into the [DISABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.DISABLED] state.
    case destroyScheduled // = 4

    /// This version is still being imported. It may not be used, enabled,
    /// disabled, or destroyed yet. Cloud KMS will automatically mark this
    /// version [ENABLED][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionState.ENABLED] as soon as the version is ready.
    case pendingImport // = 6

    /// This version was not imported successfully. It may not be used, enabled,
    /// disabled, or destroyed. The submitted key material has been discarded.
    /// Additional details can be found in
    /// [CryptoKeyVersion.import_failure_reason][google.cloud.kms.v1.CryptoKeyVersion.import_failure_reason].
    case importFailed // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enabled
      case 2: self = .disabled
      case 3: self = .destroyed
      case 4: self = .destroyScheduled
      case 5: self = .pendingGeneration
      case 6: self = .pendingImport
      case 7: self = .importFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enabled: return 1
      case .disabled: return 2
      case .destroyed: return 3
      case .destroyScheduled: return 4
      case .pendingGeneration: return 5
      case .pendingImport: return 6
      case .importFailed: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A view for [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]s. Controls the level of detail returned
  /// for [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] in
  /// [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions] and
  /// [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
  public enum CryptoKeyVersionView: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default view for each [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Does not include
    /// the [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation] field.
    case unspecified // = 0

    /// Provides all fields in each [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion], including the
    /// [attestation][google.cloud.kms.v1.CryptoKeyVersion.attestation].
    case full // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .full
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .full: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm] = [
    .unspecified,
    .googleSymmetricEncryption,
    .rsaSignPss2048Sha256,
    .rsaSignPss3072Sha256,
    .rsaSignPss4096Sha256,
    .rsaSignPss4096Sha512,
    .rsaSignPkcs12048Sha256,
    .rsaSignPkcs13072Sha256,
    .rsaSignPkcs14096Sha256,
    .rsaSignPkcs14096Sha512,
    .rsaDecryptOaep2048Sha256,
    .rsaDecryptOaep3072Sha256,
    .rsaDecryptOaep4096Sha256,
    .rsaDecryptOaep4096Sha512,
    .ecSignP256Sha256,
    .ecSignP384Sha384,
    .externalSymmetricEncryption,
  ]
}

extension Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionState] = [
    .unspecified,
    .pendingGeneration,
    .enabled,
    .disabled,
    .destroyed,
    .destroyScheduled,
    .pendingImport,
    .importFailed,
  ]
}

extension Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionView: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionView] = [
    .unspecified,
    .full,
  ]
}

#endif  // swift(>=4.2)

/// The public key for a given [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]. Obtained via
/// [GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
public struct Google_Cloud_Kms_V1_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public key, encoded in PEM format. For more information, see the
  /// [RFC 7468](https://tools.ietf.org/html/rfc7468) sections for
  /// [General Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
  /// [Textual Encoding of Subject Public Key Info]
  /// (https://tools.ietf.org/html/rfc7468#section-13).
  public var pem: String = String()

  /// The [Algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm] associated
  /// with this key.
  public var algorithm: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm = .unspecified

  /// Integrity verification field. A CRC32C checksum of the returned
  /// [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem]. An integrity check of [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] can be performed
  /// by computing the CRC32C checksum of [PublicKey.pem][google.cloud.kms.v1.PublicKey.pem] and
  /// comparing your results to this field. Discard the response in case of
  /// non-matching checksum values, and perform a limited number of retries. A
  /// persistent mismatch may indicate an issue in your computation of the CRC32C
  /// checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var pemCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _pemCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_pemCrc32C = newValue}
  }
  /// Returns true if `pemCrc32C` has been explicitly set.
  public var hasPemCrc32C: Bool {return self._pemCrc32C != nil}
  /// Clears the value of `pemCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearPemCrc32C() {self._pemCrc32C = nil}

  /// The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key.
  /// Provided here for verification.
  ///
  /// NOTE: This field is in Beta.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pemCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// An [ImportJob][google.cloud.kms.v1.ImportJob] can be used to create [CryptoKeys][google.cloud.kms.v1.CryptoKey] and
/// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] using pre-existing key material,
/// generated outside of Cloud KMS.
///
/// When an [ImportJob][google.cloud.kms.v1.ImportJob] is created, Cloud KMS will generate a "wrapping key",
/// which is a public/private key pair. You use the wrapping key to encrypt (also
/// known as wrap) the pre-existing key material to protect it during the import
/// process. The nature of the wrapping key depends on the choice of
/// [import_method][google.cloud.kms.v1.ImportJob.import_method]. When the wrapping key generation
/// is complete, the [state][google.cloud.kms.v1.ImportJob.state] will be set to
/// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] and the [public_key][google.cloud.kms.v1.ImportJob.public_key]
/// can be fetched. The fetched public key can then be used to wrap your
/// pre-existing key material.
///
/// Once the key material is wrapped, it can be imported into a new
/// [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] in an existing [CryptoKey][google.cloud.kms.v1.CryptoKey] by calling
/// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
/// Multiple [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] can be imported with a single
/// [ImportJob][google.cloud.kms.v1.ImportJob]. Cloud KMS uses the private key portion of the wrapping key to
/// unwrap the key material. Only Cloud KMS has access to the private key.
///
/// An [ImportJob][google.cloud.kms.v1.ImportJob] expires 3 days after it is created. Once expired, Cloud KMS
/// will no longer be able to import or unwrap any key material that was wrapped
/// with the [ImportJob][google.cloud.kms.v1.ImportJob]'s public key.
///
/// For more information, see
/// [Importing a key](https://cloud.google.com/kms/docs/importing-a-key).
public struct Google_Cloud_Kms_V1_ImportJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name for this [ImportJob][google.cloud.kms.v1.ImportJob] in the format
  /// `projects/*/locations/*/keyRings/*/importJobs/*`.
  public var name: String = String()

  /// Required. Immutable. The wrapping method to be used for incoming key material.
  public var importMethod: Google_Cloud_Kms_V1_ImportJob.ImportMethod = .unspecified

  /// Required. Immutable. The protection level of the [ImportJob][google.cloud.kms.v1.ImportJob]. This must match the
  /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level] of the
  /// [version_template][google.cloud.kms.v1.CryptoKey.version_template] on the [CryptoKey][google.cloud.kms.v1.CryptoKey] you
  /// attempt to import into.
  public var protectionLevel: Google_Cloud_Kms_V1_ProtectionLevel = .unspecified

  /// Output only. The time at which this [ImportJob][google.cloud.kms.v1.ImportJob] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob]'s key material was generated.
  public var generateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _generateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_generateTime = newValue}
  }
  /// Returns true if `generateTime` has been explicitly set.
  public var hasGenerateTime: Bool {return self._generateTime != nil}
  /// Clears the value of `generateTime`. Subsequent reads from it will return its default value.
  public mutating func clearGenerateTime() {self._generateTime = nil}

  /// Output only. The time at which this [ImportJob][google.cloud.kms.v1.ImportJob] is scheduled for
  /// expiration and can no longer be used to import key material.
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  /// Output only. The time this [ImportJob][google.cloud.kms.v1.ImportJob] expired. Only present if
  /// [state][google.cloud.kms.v1.ImportJob.state] is [EXPIRED][google.cloud.kms.v1.ImportJob.ImportJobState.EXPIRED].
  public var expireEventTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireEventTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireEventTime = newValue}
  }
  /// Returns true if `expireEventTime` has been explicitly set.
  public var hasExpireEventTime: Bool {return self._expireEventTime != nil}
  /// Clears the value of `expireEventTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireEventTime() {self._expireEventTime = nil}

  /// Output only. The current state of the [ImportJob][google.cloud.kms.v1.ImportJob], indicating if it can
  /// be used.
  public var state: Google_Cloud_Kms_V1_ImportJob.ImportJobState = .unspecified

  /// Output only. The public key with which to wrap key material prior to
  /// import. Only returned if [state][google.cloud.kms.v1.ImportJob.state] is
  /// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE].
  public var publicKey: Google_Cloud_Kms_V1_ImportJob.WrappingPublicKey {
    get {return _publicKey ?? Google_Cloud_Kms_V1_ImportJob.WrappingPublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  /// Output only. Statement that was generated and signed by the key creator
  /// (for example, an HSM) at key creation time. Use this statement to verify
  /// attributes of the key as stored on the HSM, independently of Google.
  /// Only present if the chosen [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] is one with a protection
  /// level of [HSM][google.cloud.kms.v1.ProtectionLevel.HSM].
  public var attestation: Google_Cloud_Kms_V1_KeyOperationAttestation {
    get {return _attestation ?? Google_Cloud_Kms_V1_KeyOperationAttestation()}
    set {_attestation = newValue}
  }
  /// Returns true if `attestation` has been explicitly set.
  public var hasAttestation: Bool {return self._attestation != nil}
  /// Clears the value of `attestation`. Subsequent reads from it will return its default value.
  public mutating func clearAttestation() {self._attestation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod] describes the key wrapping method chosen for this
  /// [ImportJob][google.cloud.kms.v1.ImportJob].
  public enum ImportMethod: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
    /// scheme defined in the PKCS #11 standard. In summary, this involves
    /// wrapping the raw key with an ephemeral AES key, and wrapping the
    /// ephemeral AES key with a 3072 bit RSA key. For more details, see
    /// [RSA AES key wrap
    /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
    case rsaOaep3072Sha1Aes256 // = 1

    /// This ImportMethod represents the CKM_RSA_AES_KEY_WRAP key wrapping
    /// scheme defined in the PKCS #11 standard. In summary, this involves
    /// wrapping the raw key with an ephemeral AES key, and wrapping the
    /// ephemeral AES key with a 4096 bit RSA key. For more details, see
    /// [RSA AES key wrap
    /// mechanism](http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/cos01/pkcs11-curr-v2.40-cos01.html#_Toc408226908).
    case rsaOaep4096Sha1Aes256 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .rsaOaep3072Sha1Aes256
      case 2: self = .rsaOaep4096Sha1Aes256
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .rsaOaep3072Sha1Aes256: return 1
      case .rsaOaep4096Sha1Aes256: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The state of the [ImportJob][google.cloud.kms.v1.ImportJob], indicating if it can be used.
  public enum ImportJobState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// The wrapping key for this job is still being generated. It may not be
    /// used. Cloud KMS will automatically mark this job as
    /// [ACTIVE][google.cloud.kms.v1.ImportJob.ImportJobState.ACTIVE] as soon as the wrapping key is generated.
    case pendingGeneration // = 1

    /// This job may be used in
    /// [CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey] and
    /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion]
    /// requests.
    case active // = 2

    /// This job can no longer be used and may not leave this state once entered.
    case expired // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pendingGeneration
      case 2: self = .active
      case 3: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pendingGeneration: return 1
      case .active: return 2
      case .expired: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The public key component of the wrapping key. For details of the type of
  /// key this public key corresponds to, see the [ImportMethod][google.cloud.kms.v1.ImportJob.ImportMethod].
  public struct WrappingPublicKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The public key, encoded in PEM format. For more information, see the [RFC
    /// 7468](https://tools.ietf.org/html/rfc7468) sections for [General
    /// Considerations](https://tools.ietf.org/html/rfc7468#section-2) and
    /// [Textual Encoding of Subject Public Key Info]
    /// (https://tools.ietf.org/html/rfc7468#section-13).
    public var pem: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _generateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expireEventTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _publicKey: Google_Cloud_Kms_V1_ImportJob.WrappingPublicKey? = nil
  fileprivate var _attestation: Google_Cloud_Kms_V1_KeyOperationAttestation? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Kms_V1_ImportJob.ImportMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_ImportJob.ImportMethod] = [
    .unspecified,
    .rsaOaep3072Sha1Aes256,
    .rsaOaep4096Sha1Aes256,
  ]
}

extension Google_Cloud_Kms_V1_ImportJob.ImportJobState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Kms_V1_ImportJob.ImportJobState] = [
    .unspecified,
    .pendingGeneration,
    .active,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// ExternalProtectionLevelOptions stores a group of additional fields for
/// configuring a [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] that are specific to the
/// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] protection level.
public struct Google_Cloud_Kms_V1_ExternalProtectionLevelOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The URI for an external resource that this [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] represents.
  public var externalKeyUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.kms.v1"

extension Google_Cloud_Kms_V1_ProtectionLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROTECTION_LEVEL_UNSPECIFIED"),
    1: .same(proto: "SOFTWARE"),
    2: .same(proto: "HSM"),
    3: .same(proto: "EXTERNAL"),
  ]
}

extension Google_Cloud_Kms_V1_KeyRing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyRing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "create_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_KeyRing, rhs: Google_Cloud_Kms_V1_KeyRing) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CryptoKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "primary"),
    3: .same(proto: "purpose"),
    5: .standard(proto: "create_time"),
    7: .standard(proto: "next_rotation_time"),
    8: .standard(proto: "rotation_period"),
    11: .standard(proto: "version_template"),
    10: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._primary) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.purpose) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._nextRotationTime) }()
      case 8: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.rotationSchedule {
          try decoder.handleConflictingOneOf()
          if case .rotationPeriod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rotationSchedule = .rotationPeriod(v)}
      }()
      case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._versionTemplate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._primary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.purpose != .unspecified {
      try visitor.visitSingularEnumField(value: self.purpose, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._nextRotationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if case .rotationPeriod(let v)? = self.rotationSchedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 10)
    }
    if let v = self._versionTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CryptoKey, rhs: Google_Cloud_Kms_V1_CryptoKey) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._primary != rhs._primary {return false}
    if lhs.purpose != rhs.purpose {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._nextRotationTime != rhs._nextRotationTime {return false}
    if lhs.rotationSchedule != rhs.rotationSchedule {return false}
    if lhs._versionTemplate != rhs._versionTemplate {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CryptoKey.CryptoKeyPurpose: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRYPTO_KEY_PURPOSE_UNSPECIFIED"),
    1: .same(proto: "ENCRYPT_DECRYPT"),
    5: .same(proto: "ASYMMETRIC_SIGN"),
    6: .same(proto: "ASYMMETRIC_DECRYPT"),
  ]
}

extension Google_Cloud_Kms_V1_CryptoKeyVersionTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoKeyVersionTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protection_level"),
    3: .same(proto: "algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.protectionLevel) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.algorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protectionLevel != .unspecified {
      try visitor.visitSingularEnumField(value: self.protectionLevel, fieldNumber: 1)
    }
    if self.algorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CryptoKeyVersionTemplate, rhs: Google_Cloud_Kms_V1_CryptoKeyVersionTemplate) -> Bool {
    if lhs.protectionLevel != rhs.protectionLevel {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_KeyOperationAttestation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyOperationAttestation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "format"),
    5: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 4)
    }
    if !self.content.isEmpty {
      try visitor.visitSingularBytesField(value: self.content, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_KeyOperationAttestation, rhs: Google_Cloud_Kms_V1_KeyOperationAttestation) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_KeyOperationAttestation.AttestationFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ATTESTATION_FORMAT_UNSPECIFIED"),
    3: .same(proto: "CAVIUM_V1_COMPRESSED"),
    4: .same(proto: "CAVIUM_V2_COMPRESSED"),
  ]
}

extension Google_Cloud_Kms_V1_CryptoKeyVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CryptoKeyVersion"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "state"),
    7: .standard(proto: "protection_level"),
    10: .same(proto: "algorithm"),
    8: .same(proto: "attestation"),
    4: .standard(proto: "create_time"),
    11: .standard(proto: "generate_time"),
    5: .standard(proto: "destroy_time"),
    6: .standard(proto: "destroy_event_time"),
    14: .standard(proto: "import_job"),
    15: .standard(proto: "import_time"),
    16: .standard(proto: "import_failure_reason"),
    17: .standard(proto: "external_protection_level_options"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _state: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionState = .unspecified
    var _protectionLevel: Google_Cloud_Kms_V1_ProtectionLevel = .unspecified
    var _algorithm: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm = .unspecified
    var _attestation: Google_Cloud_Kms_V1_KeyOperationAttestation? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _generateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _destroyTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _destroyEventTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _importJob: String = String()
    var _importTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _importFailureReason: String = String()
    var _externalProtectionLevelOptions: Google_Cloud_Kms_V1_ExternalProtectionLevelOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _state = source._state
      _protectionLevel = source._protectionLevel
      _algorithm = source._algorithm
      _attestation = source._attestation
      _createTime = source._createTime
      _generateTime = source._generateTime
      _destroyTime = source._destroyTime
      _destroyEventTime = source._destroyEventTime
      _importJob = source._importJob
      _importTime = source._importTime
      _importFailureReason = source._importFailureReason
      _externalProtectionLevelOptions = source._externalProtectionLevelOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._destroyTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._destroyEventTime) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._protectionLevel) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._attestation) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._algorithm) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._generateTime) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._importJob) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._importTime) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._importFailureReason) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._externalProtectionLevelOptions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._destroyTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._destroyEventTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._protectionLevel != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._protectionLevel, fieldNumber: 7)
      }
      if let v = _storage._attestation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._algorithm != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._algorithm, fieldNumber: 10)
      }
      if let v = _storage._generateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._importJob.isEmpty {
        try visitor.visitSingularStringField(value: _storage._importJob, fieldNumber: 14)
      }
      if let v = _storage._importTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if !_storage._importFailureReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._importFailureReason, fieldNumber: 16)
      }
      if let v = _storage._externalProtectionLevelOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CryptoKeyVersion, rhs: Google_Cloud_Kms_V1_CryptoKeyVersion) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._protectionLevel != rhs_storage._protectionLevel {return false}
        if _storage._algorithm != rhs_storage._algorithm {return false}
        if _storage._attestation != rhs_storage._attestation {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._generateTime != rhs_storage._generateTime {return false}
        if _storage._destroyTime != rhs_storage._destroyTime {return false}
        if _storage._destroyEventTime != rhs_storage._destroyEventTime {return false}
        if _storage._importJob != rhs_storage._importJob {return false}
        if _storage._importTime != rhs_storage._importTime {return false}
        if _storage._importFailureReason != rhs_storage._importFailureReason {return false}
        if _storage._externalProtectionLevelOptions != rhs_storage._externalProtectionLevelOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRYPTO_KEY_VERSION_ALGORITHM_UNSPECIFIED"),
    1: .same(proto: "GOOGLE_SYMMETRIC_ENCRYPTION"),
    2: .same(proto: "RSA_SIGN_PSS_2048_SHA256"),
    3: .same(proto: "RSA_SIGN_PSS_3072_SHA256"),
    4: .same(proto: "RSA_SIGN_PSS_4096_SHA256"),
    5: .same(proto: "RSA_SIGN_PKCS1_2048_SHA256"),
    6: .same(proto: "RSA_SIGN_PKCS1_3072_SHA256"),
    7: .same(proto: "RSA_SIGN_PKCS1_4096_SHA256"),
    8: .same(proto: "RSA_DECRYPT_OAEP_2048_SHA256"),
    9: .same(proto: "RSA_DECRYPT_OAEP_3072_SHA256"),
    10: .same(proto: "RSA_DECRYPT_OAEP_4096_SHA256"),
    12: .same(proto: "EC_SIGN_P256_SHA256"),
    13: .same(proto: "EC_SIGN_P384_SHA384"),
    15: .same(proto: "RSA_SIGN_PSS_4096_SHA512"),
    16: .same(proto: "RSA_SIGN_PKCS1_4096_SHA512"),
    17: .same(proto: "RSA_DECRYPT_OAEP_4096_SHA512"),
    18: .same(proto: "EXTERNAL_SYMMETRIC_ENCRYPTION"),
  ]
}

extension Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRYPTO_KEY_VERSION_STATE_UNSPECIFIED"),
    1: .same(proto: "ENABLED"),
    2: .same(proto: "DISABLED"),
    3: .same(proto: "DESTROYED"),
    4: .same(proto: "DESTROY_SCHEDULED"),
    5: .same(proto: "PENDING_GENERATION"),
    6: .same(proto: "PENDING_IMPORT"),
    7: .same(proto: "IMPORT_FAILED"),
  ]
}

extension Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionView: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CRYPTO_KEY_VERSION_VIEW_UNSPECIFIED"),
    1: .same(proto: "FULL"),
  ]
}

extension Google_Cloud_Kms_V1_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pem"),
    2: .same(proto: "algorithm"),
    3: .standard(proto: "pem_crc32c"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pem) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.algorithm) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pemCrc32C) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pem.isEmpty {
      try visitor.visitSingularStringField(value: self.pem, fieldNumber: 1)
    }
    if self.algorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 2)
    }
    if let v = self._pemCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_PublicKey, rhs: Google_Cloud_Kms_V1_PublicKey) -> Bool {
    if lhs.pem != rhs.pem {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs._pemCrc32C != rhs._pemCrc32C {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ImportJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "import_method"),
    9: .standard(proto: "protection_level"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "generate_time"),
    5: .standard(proto: "expire_time"),
    10: .standard(proto: "expire_event_time"),
    6: .same(proto: "state"),
    7: .standard(proto: "public_key"),
    8: .same(proto: "attestation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.importMethod) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._generateTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._attestation) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.protectionLevel) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._expireEventTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.importMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.importMethod, fieldNumber: 2)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._generateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._attestation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if self.protectionLevel != .unspecified {
      try visitor.visitSingularEnumField(value: self.protectionLevel, fieldNumber: 9)
    }
    if let v = self._expireEventTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ImportJob, rhs: Google_Cloud_Kms_V1_ImportJob) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.importMethod != rhs.importMethod {return false}
    if lhs.protectionLevel != rhs.protectionLevel {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._generateTime != rhs._generateTime {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs._expireEventTime != rhs._expireEventTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._attestation != rhs._attestation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ImportJob.ImportMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMPORT_METHOD_UNSPECIFIED"),
    1: .same(proto: "RSA_OAEP_3072_SHA1_AES_256"),
    2: .same(proto: "RSA_OAEP_4096_SHA1_AES_256"),
  ]
}

extension Google_Cloud_Kms_V1_ImportJob.ImportJobState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IMPORT_JOB_STATE_UNSPECIFIED"),
    1: .same(proto: "PENDING_GENERATION"),
    2: .same(proto: "ACTIVE"),
    3: .same(proto: "EXPIRED"),
  ]
}

extension Google_Cloud_Kms_V1_ImportJob.WrappingPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Kms_V1_ImportJob.protoMessageName + ".WrappingPublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pem"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pem) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pem.isEmpty {
      try visitor.visitSingularStringField(value: self.pem, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ImportJob.WrappingPublicKey, rhs: Google_Cloud_Kms_V1_ImportJob.WrappingPublicKey) -> Bool {
    if lhs.pem != rhs.pem {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ExternalProtectionLevelOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalProtectionLevelOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "external_key_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.externalKeyUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalKeyUri.isEmpty {
      try visitor.visitSingularStringField(value: self.externalKeyUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ExternalProtectionLevelOptions, rhs: Google_Cloud_Kms_V1_ExternalProtectionLevelOptions) -> Bool {
    if lhs.externalKeyUri != rhs.externalKeyUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

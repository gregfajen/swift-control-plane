// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/kms/v1/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
public struct Google_Cloud_Kms_V1_ListKeyRingsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the location associated with the
  /// [KeyRings][google.cloud.kms.v1.KeyRing], in the format `projects/*/locations/*`.
  public var parent: String = String()

  /// Optional. Optional limit on the number of [KeyRings][google.cloud.kms.v1.KeyRing] to include in the
  /// response.  Further [KeyRings][google.cloud.kms.v1.KeyRing] can subsequently be obtained by
  /// including the [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token] in a subsequent
  /// request.  If unspecified, the server will pick an appropriate default.
  public var pageSize: Int32 = 0

  /// Optional. Optional pagination token, returned earlier via
  /// [ListKeyRingsResponse.next_page_token][google.cloud.kms.v1.ListKeyRingsResponse.next_page_token].
  public var pageToken: String = String()

  /// Optional. Only include resources that match the filter in the response. For
  /// more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var filter: String = String()

  /// Optional. Specify how the results should be sorted. If not specified, the
  /// results will be sorted in the default order.  For more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
public struct Google_Cloud_Kms_V1_ListCryptoKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing] to list, in the format
  /// `projects/*/locations/*/keyRings/*`.
  public var parent: String = String()

  /// Optional. Optional limit on the number of [CryptoKeys][google.cloud.kms.v1.CryptoKey] to include in the
  /// response.  Further [CryptoKeys][google.cloud.kms.v1.CryptoKey] can subsequently be obtained by
  /// including the [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token] in a subsequent
  /// request.  If unspecified, the server will pick an appropriate default.
  public var pageSize: Int32 = 0

  /// Optional. Optional pagination token, returned earlier via
  /// [ListCryptoKeysResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeysResponse.next_page_token].
  public var pageToken: String = String()

  /// The fields of the primary version to include in the response.
  public var versionView: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionView = .unspecified

  /// Optional. Only include resources that match the filter in the response. For
  /// more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var filter: String = String()

  /// Optional. Specify how the results should be sorted. If not specified, the
  /// results will be sorted in the default order. For more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
public struct Google_Cloud_Kms_V1_ListCryptoKeyVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKey][google.cloud.kms.v1.CryptoKey] to list, in the format
  /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
  public var parent: String = String()

  /// Optional. Optional limit on the number of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] to
  /// include in the response. Further [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] can
  /// subsequently be obtained by including the
  /// [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token] in a subsequent request.
  /// If unspecified, the server will pick an appropriate default.
  public var pageSize: Int32 = 0

  /// Optional. Optional pagination token, returned earlier via
  /// [ListCryptoKeyVersionsResponse.next_page_token][google.cloud.kms.v1.ListCryptoKeyVersionsResponse.next_page_token].
  public var pageToken: String = String()

  /// The fields to include in the response.
  public var view: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionView = .unspecified

  /// Optional. Only include resources that match the filter in the response. For
  /// more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var filter: String = String()

  /// Optional. Specify how the results should be sorted. If not specified, the
  /// results will be sorted in the default order. For more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
public struct Google_Cloud_Kms_V1_ListImportJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [KeyRing][google.cloud.kms.v1.KeyRing] to list, in the format
  /// `projects/*/locations/*/keyRings/*`.
  public var parent: String = String()

  /// Optional. Optional limit on the number of [ImportJobs][google.cloud.kms.v1.ImportJob] to include in the
  /// response. Further [ImportJobs][google.cloud.kms.v1.ImportJob] can subsequently be obtained by
  /// including the [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token] in a subsequent
  /// request. If unspecified, the server will pick an appropriate default.
  public var pageSize: Int32 = 0

  /// Optional. Optional pagination token, returned earlier via
  /// [ListImportJobsResponse.next_page_token][google.cloud.kms.v1.ListImportJobsResponse.next_page_token].
  public var pageToken: String = String()

  /// Optional. Only include resources that match the filter in the response. For
  /// more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var filter: String = String()

  /// Optional. Specify how the results should be sorted. If not specified, the
  /// results will be sorted in the default order. For more information, see
  /// [Sorting and filtering list
  /// results](https://cloud.google.com/kms/docs/sorting-and-filtering).
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [KeyManagementService.ListKeyRings][google.cloud.kms.v1.KeyManagementService.ListKeyRings].
public struct Google_Cloud_Kms_V1_ListKeyRingsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of [KeyRings][google.cloud.kms.v1.KeyRing].
  public var keyRings: [Google_Cloud_Kms_V1_KeyRing] = []

  /// A token to retrieve next page of results. Pass this value in
  /// [ListKeyRingsRequest.page_token][google.cloud.kms.v1.ListKeyRingsRequest.page_token] to retrieve the next page of results.
  public var nextPageToken: String = String()

  /// The total number of [KeyRings][google.cloud.kms.v1.KeyRing] that matched the query.
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [KeyManagementService.ListCryptoKeys][google.cloud.kms.v1.KeyManagementService.ListCryptoKeys].
public struct Google_Cloud_Kms_V1_ListCryptoKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of [CryptoKeys][google.cloud.kms.v1.CryptoKey].
  public var cryptoKeys: [Google_Cloud_Kms_V1_CryptoKey] = []

  /// A token to retrieve next page of results. Pass this value in
  /// [ListCryptoKeysRequest.page_token][google.cloud.kms.v1.ListCryptoKeysRequest.page_token] to retrieve the next page of results.
  public var nextPageToken: String = String()

  /// The total number of [CryptoKeys][google.cloud.kms.v1.CryptoKey] that matched the query.
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [KeyManagementService.ListCryptoKeyVersions][google.cloud.kms.v1.KeyManagementService.ListCryptoKeyVersions].
public struct Google_Cloud_Kms_V1_ListCryptoKeyVersionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
  public var cryptoKeyVersions: [Google_Cloud_Kms_V1_CryptoKeyVersion] = []

  /// A token to retrieve next page of results. Pass this value in
  /// [ListCryptoKeyVersionsRequest.page_token][google.cloud.kms.v1.ListCryptoKeyVersionsRequest.page_token] to retrieve the next page of
  /// results.
  public var nextPageToken: String = String()

  /// The total number of [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion] that matched the
  /// query.
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for [KeyManagementService.ListImportJobs][google.cloud.kms.v1.KeyManagementService.ListImportJobs].
public struct Google_Cloud_Kms_V1_ListImportJobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of [ImportJobs][google.cloud.kms.v1.ImportJob].
  public var importJobs: [Google_Cloud_Kms_V1_ImportJob] = []

  /// A token to retrieve next page of results. Pass this value in
  /// [ListImportJobsRequest.page_token][google.cloud.kms.v1.ListImportJobsRequest.page_token] to retrieve the next page of results.
  public var nextPageToken: String = String()

  /// The total number of [ImportJobs][google.cloud.kms.v1.ImportJob] that matched the query.
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.GetKeyRing][google.cloud.kms.v1.KeyManagementService.GetKeyRing].
public struct Google_Cloud_Kms_V1_GetKeyRingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the [KeyRing][google.cloud.kms.v1.KeyRing] to get.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.GetCryptoKey][google.cloud.kms.v1.KeyManagementService.GetCryptoKey].
public struct Google_Cloud_Kms_V1_GetCryptoKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the [CryptoKey][google.cloud.kms.v1.CryptoKey] to get.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.GetCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.GetCryptoKeyVersion].
public struct Google_Cloud_Kms_V1_GetCryptoKeyVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to get.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.GetPublicKey][google.cloud.kms.v1.KeyManagementService.GetPublicKey].
public struct Google_Cloud_Kms_V1_GetPublicKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.CryptoKeyVersion.name] of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] public key to
  /// get.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.GetImportJob][google.cloud.kms.v1.KeyManagementService.GetImportJob].
public struct Google_Cloud_Kms_V1_GetImportJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.ImportJob.name] of the [ImportJob][google.cloud.kms.v1.ImportJob] to get.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.CreateKeyRing][google.cloud.kms.v1.KeyManagementService.CreateKeyRing].
public struct Google_Cloud_Kms_V1_CreateKeyRingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the location associated with the
  /// [KeyRings][google.cloud.kms.v1.KeyRing], in the format `projects/*/locations/*`.
  public var parent: String = String()

  /// Required. It must be unique within a location and match the regular
  /// expression `[a-zA-Z0-9_-]{1,63}`
  public var keyRingID: String = String()

  /// Required. A [KeyRing][google.cloud.kms.v1.KeyRing] with initial field values.
  public var keyRing: Google_Cloud_Kms_V1_KeyRing {
    get {return _keyRing ?? Google_Cloud_Kms_V1_KeyRing()}
    set {_keyRing = newValue}
  }
  /// Returns true if `keyRing` has been explicitly set.
  public var hasKeyRing: Bool {return self._keyRing != nil}
  /// Clears the value of `keyRing`. Subsequent reads from it will return its default value.
  public mutating func clearKeyRing() {self._keyRing = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _keyRing: Google_Cloud_Kms_V1_KeyRing? = nil
}

/// Request message for [KeyManagementService.CreateCryptoKey][google.cloud.kms.v1.KeyManagementService.CreateCryptoKey].
public struct Google_Cloud_Kms_V1_CreateCryptoKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the KeyRing associated with the
  /// [CryptoKeys][google.cloud.kms.v1.CryptoKey].
  public var parent: String = String()

  /// Required. It must be unique within a KeyRing and match the regular
  /// expression `[a-zA-Z0-9_-]{1,63}`
  public var cryptoKeyID: String = String()

  /// Required. A [CryptoKey][google.cloud.kms.v1.CryptoKey] with initial field values.
  public var cryptoKey: Google_Cloud_Kms_V1_CryptoKey {
    get {return _cryptoKey ?? Google_Cloud_Kms_V1_CryptoKey()}
    set {_cryptoKey = newValue}
  }
  /// Returns true if `cryptoKey` has been explicitly set.
  public var hasCryptoKey: Bool {return self._cryptoKey != nil}
  /// Clears the value of `cryptoKey`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKey() {self._cryptoKey = nil}

  /// If set to true, the request will create a [CryptoKey][google.cloud.kms.v1.CryptoKey] without any
  /// [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion]. You must manually call
  /// [CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion] or
  /// [ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion]
  /// before you can use this [CryptoKey][google.cloud.kms.v1.CryptoKey].
  public var skipInitialVersionCreation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cryptoKey: Google_Cloud_Kms_V1_CryptoKey? = nil
}

/// Request message for [KeyManagementService.CreateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.CreateCryptoKeyVersion].
public struct Google_Cloud_Kms_V1_CreateCryptoKeyVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the [CryptoKey][google.cloud.kms.v1.CryptoKey] associated with
  /// the [CryptoKeyVersions][google.cloud.kms.v1.CryptoKeyVersion].
  public var parent: String = String()

  /// Required. A [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with initial field values.
  public var cryptoKeyVersion: Google_Cloud_Kms_V1_CryptoKeyVersion {
    get {return _cryptoKeyVersion ?? Google_Cloud_Kms_V1_CryptoKeyVersion()}
    set {_cryptoKeyVersion = newValue}
  }
  /// Returns true if `cryptoKeyVersion` has been explicitly set.
  public var hasCryptoKeyVersion: Bool {return self._cryptoKeyVersion != nil}
  /// Clears the value of `cryptoKeyVersion`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKeyVersion() {self._cryptoKeyVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cryptoKeyVersion: Google_Cloud_Kms_V1_CryptoKeyVersion? = nil
}

/// Request message for [KeyManagementService.ImportCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.ImportCryptoKeyVersion].
public struct Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.CryptoKey.name] of the [CryptoKey][google.cloud.kms.v1.CryptoKey] to
  /// be imported into.
  public var parent: String = String()

  /// Required. The [algorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm] of
  /// the key being imported. This does not need to match the
  /// [version_template][google.cloud.kms.v1.CryptoKey.version_template] of the [CryptoKey][google.cloud.kms.v1.CryptoKey] this
  /// version imports into.
  public var algorithm: Google_Cloud_Kms_V1_CryptoKeyVersion.CryptoKeyVersionAlgorithm = .unspecified

  /// Required. The [name][google.cloud.kms.v1.ImportJob.name] of the [ImportJob][google.cloud.kms.v1.ImportJob] that was used to
  /// wrap this key material.
  public var importJob: String = String()

  /// Required. The incoming wrapped key material that is to be imported.
  public var wrappedKeyMaterial: Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest.OneOf_WrappedKeyMaterial? = nil

  /// Wrapped key material produced with
  /// [RSA_OAEP_3072_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]
  /// or
  /// [RSA_OAEP_4096_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256].
  ///
  /// This field contains the concatenation of two wrapped keys:
  /// <ol>
  ///   <li>An ephemeral AES-256 wrapping key wrapped with the
  ///       [public_key][google.cloud.kms.v1.ImportJob.public_key] using RSAES-OAEP with SHA-1,
  ///       MGF1 with SHA-1, and an empty label.
  ///   </li>
  ///   <li>The key to be imported, wrapped with the ephemeral AES-256 key
  ///       using AES-KWP (RFC 5649).
  ///   </li>
  /// </ol>
  ///
  /// If importing symmetric key material, it is expected that the unwrapped
  /// key contains plain bytes. If importing asymmetric key material, it is
  /// expected that the unwrapped key is in PKCS#8-encoded DER format (the
  /// PrivateKeyInfo structure from RFC 5208).
  ///
  /// This format is the same as the format produced by PKCS#11 mechanism
  /// CKM_RSA_AES_KEY_WRAP.
  public var rsaAesWrappedKey: Data {
    get {
      if case .rsaAesWrappedKey(let v)? = wrappedKeyMaterial {return v}
      return Data()
    }
    set {wrappedKeyMaterial = .rsaAesWrappedKey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The incoming wrapped key material that is to be imported.
  public enum OneOf_WrappedKeyMaterial: Equatable {
    /// Wrapped key material produced with
    /// [RSA_OAEP_3072_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_3072_SHA1_AES_256]
    /// or
    /// [RSA_OAEP_4096_SHA1_AES_256][google.cloud.kms.v1.ImportJob.ImportMethod.RSA_OAEP_4096_SHA1_AES_256].
    ///
    /// This field contains the concatenation of two wrapped keys:
    /// <ol>
    ///   <li>An ephemeral AES-256 wrapping key wrapped with the
    ///       [public_key][google.cloud.kms.v1.ImportJob.public_key] using RSAES-OAEP with SHA-1,
    ///       MGF1 with SHA-1, and an empty label.
    ///   </li>
    ///   <li>The key to be imported, wrapped with the ephemeral AES-256 key
    ///       using AES-KWP (RFC 5649).
    ///   </li>
    /// </ol>
    ///
    /// If importing symmetric key material, it is expected that the unwrapped
    /// key contains plain bytes. If importing asymmetric key material, it is
    /// expected that the unwrapped key is in PKCS#8-encoded DER format (the
    /// PrivateKeyInfo structure from RFC 5208).
    ///
    /// This format is the same as the format produced by PKCS#11 mechanism
    /// CKM_RSA_AES_KEY_WRAP.
    case rsaAesWrappedKey(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest.OneOf_WrappedKeyMaterial, rhs: Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest.OneOf_WrappedKeyMaterial) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rsaAesWrappedKey, .rsaAesWrappedKey): return {
        guard case .rsaAesWrappedKey(let l) = lhs, case .rsaAesWrappedKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Request message for [KeyManagementService.CreateImportJob][google.cloud.kms.v1.KeyManagementService.CreateImportJob].
public struct Google_Cloud_Kms_V1_CreateImportJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [name][google.cloud.kms.v1.KeyRing.name] of the [KeyRing][google.cloud.kms.v1.KeyRing] associated with the
  /// [ImportJobs][google.cloud.kms.v1.ImportJob].
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Required. It must be unique within a KeyRing and match the regular
  /// expression `[a-zA-Z0-9_-]{1,63}`
  public var importJobID: String {
    get {return _storage._importJobID}
    set {_uniqueStorage()._importJobID = newValue}
  }

  /// Required. An [ImportJob][google.cloud.kms.v1.ImportJob] with initial field values.
  public var importJob: Google_Cloud_Kms_V1_ImportJob {
    get {return _storage._importJob ?? Google_Cloud_Kms_V1_ImportJob()}
    set {_uniqueStorage()._importJob = newValue}
  }
  /// Returns true if `importJob` has been explicitly set.
  public var hasImportJob: Bool {return _storage._importJob != nil}
  /// Clears the value of `importJob`. Subsequent reads from it will return its default value.
  public mutating func clearImportJob() {_uniqueStorage()._importJob = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request message for [KeyManagementService.UpdateCryptoKey][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKey].
public struct Google_Cloud_Kms_V1_UpdateCryptoKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. [CryptoKey][google.cloud.kms.v1.CryptoKey] with updated values.
  public var cryptoKey: Google_Cloud_Kms_V1_CryptoKey {
    get {return _cryptoKey ?? Google_Cloud_Kms_V1_CryptoKey()}
    set {_cryptoKey = newValue}
  }
  /// Returns true if `cryptoKey` has been explicitly set.
  public var hasCryptoKey: Bool {return self._cryptoKey != nil}
  /// Clears the value of `cryptoKey`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKey() {self._cryptoKey = nil}

  /// Required. List of fields to be updated in this request.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cryptoKey: Google_Cloud_Kms_V1_CryptoKey? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for [KeyManagementService.UpdateCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyVersion].
public struct Google_Cloud_Kms_V1_UpdateCryptoKeyVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] with updated values.
  public var cryptoKeyVersion: Google_Cloud_Kms_V1_CryptoKeyVersion {
    get {return _cryptoKeyVersion ?? Google_Cloud_Kms_V1_CryptoKeyVersion()}
    set {_cryptoKeyVersion = newValue}
  }
  /// Returns true if `cryptoKeyVersion` has been explicitly set.
  public var hasCryptoKeyVersion: Bool {return self._cryptoKeyVersion != nil}
  /// Clears the value of `cryptoKeyVersion`. Subsequent reads from it will return its default value.
  public mutating func clearCryptoKeyVersion() {self._cryptoKeyVersion = nil}

  /// Required. List of fields to be updated in this request.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cryptoKeyVersion: Google_Cloud_Kms_V1_CryptoKeyVersion? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
public struct Google_Cloud_Kms_V1_EncryptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKey][google.cloud.kms.v1.CryptoKey] or [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]
  /// to use for encryption.
  ///
  /// If a [CryptoKey][google.cloud.kms.v1.CryptoKey] is specified, the server will use its
  /// [primary version][google.cloud.kms.v1.CryptoKey.primary].
  public var name: String = String()

  /// Required. The data to encrypt. Must be no larger than 64KiB.
  ///
  /// The maximum size depends on the key version's
  /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]. For
  /// [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the plaintext must be no larger
  /// than 64KiB. For [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of the
  /// plaintext and additional_authenticated_data fields must be no larger than
  /// 8KiB.
  public var plaintext: Data = Data()

  /// Optional. Optional data that, if specified, must also be provided during decryption
  /// through [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data].
  ///
  /// The maximum size depends on the key version's
  /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]. For
  /// [SOFTWARE][google.cloud.kms.v1.ProtectionLevel.SOFTWARE] keys, the AAD must be no larger than
  /// 64KiB. For [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] keys, the combined length of the
  /// plaintext and additional_authenticated_data fields must be no larger than
  /// 8KiB.
  public var additionalAuthenticatedData: Data = Data()

  /// Optional. An optional CRC32C checksum of the [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]. If
  /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will verify the integrity of the
  /// received [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext] using this checksum.
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will report an error if the checksum verification
  /// fails. If you receive a checksum error, your client should verify that
  /// CRC32C([EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]) is equal to
  /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c], and if so, perform a limited number of
  /// retries. A persistent mismatch may indicate an issue in your computation of
  /// the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var plaintextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _plaintextCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_plaintextCrc32C = newValue}
  }
  /// Returns true if `plaintextCrc32C` has been explicitly set.
  public var hasPlaintextCrc32C: Bool {return self._plaintextCrc32C != nil}
  /// Clears the value of `plaintextCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearPlaintextCrc32C() {self._plaintextCrc32C = nil}

  /// Optional. An optional CRC32C checksum of the
  /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]. If specified,
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will verify the integrity of the received
  /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data] using this checksum.
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will report an error if the checksum verification
  /// fails. If you receive a checksum error, your client should verify that
  /// CRC32C([EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]) is equal to
  /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c], and if so, perform
  /// a limited number of retries. A persistent mismatch may indicate an issue in
  /// your computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var additionalAuthenticatedDataCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _additionalAuthenticatedDataCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_additionalAuthenticatedDataCrc32C = newValue}
  }
  /// Returns true if `additionalAuthenticatedDataCrc32C` has been explicitly set.
  public var hasAdditionalAuthenticatedDataCrc32C: Bool {return self._additionalAuthenticatedDataCrc32C != nil}
  /// Clears the value of `additionalAuthenticatedDataCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearAdditionalAuthenticatedDataCrc32C() {self._additionalAuthenticatedDataCrc32C = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _plaintextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _additionalAuthenticatedDataCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Request message for [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
public struct Google_Cloud_Kms_V1_DecryptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKey][google.cloud.kms.v1.CryptoKey] to use for decryption.
  /// The server will choose the appropriate version.
  public var name: String = String()

  /// Required. The encrypted data originally returned in
  /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext].
  public var ciphertext: Data = Data()

  /// Optional. Optional data that must match the data originally supplied in
  /// [EncryptRequest.additional_authenticated_data][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data].
  public var additionalAuthenticatedData: Data = Data()

  /// Optional. An optional CRC32C checksum of the [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]. If
  /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will verify the integrity of the
  /// received [DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext] using this checksum.
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will report an error if the checksum verification
  /// fails. If you receive a checksum error, your client should verify that
  /// CRC32C([DecryptRequest.ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext]) is equal to
  /// [DecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.DecryptRequest.ciphertext_crc32c], and if so, perform a limited number
  /// of retries. A persistent mismatch may indicate an issue in your computation
  /// of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var ciphertextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _ciphertextCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_ciphertextCrc32C = newValue}
  }
  /// Returns true if `ciphertextCrc32C` has been explicitly set.
  public var hasCiphertextCrc32C: Bool {return self._ciphertextCrc32C != nil}
  /// Clears the value of `ciphertextCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearCiphertextCrc32C() {self._ciphertextCrc32C = nil}

  /// Optional. An optional CRC32C checksum of the
  /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]. If specified,
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will verify the integrity of the received
  /// [DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data] using this checksum.
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will report an error if the checksum verification
  /// fails. If you receive a checksum error, your client should verify that
  /// CRC32C([DecryptRequest.additional_authenticated_data][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data]) is equal to
  /// [DecryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.DecryptRequest.additional_authenticated_data_crc32c], and if so, perform
  /// a limited number of retries. A persistent mismatch may indicate an issue in
  /// your computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var additionalAuthenticatedDataCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _additionalAuthenticatedDataCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_additionalAuthenticatedDataCrc32C = newValue}
  }
  /// Returns true if `additionalAuthenticatedDataCrc32C` has been explicitly set.
  public var hasAdditionalAuthenticatedDataCrc32C: Bool {return self._additionalAuthenticatedDataCrc32C != nil}
  /// Clears the value of `additionalAuthenticatedDataCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearAdditionalAuthenticatedDataCrc32C() {self._additionalAuthenticatedDataCrc32C = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ciphertextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
  fileprivate var _additionalAuthenticatedDataCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Request message for [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
public struct Google_Cloud_Kms_V1_AsymmetricSignRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for signing.
  public var name: String = String()

  /// Required. The digest of the data to sign. The digest must be produced with
  /// the same digest algorithm as specified by the key version's
  /// [algorithm][google.cloud.kms.v1.CryptoKeyVersion.algorithm].
  public var digest: Google_Cloud_Kms_V1_Digest {
    get {return _digest ?? Google_Cloud_Kms_V1_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  /// Optional. An optional CRC32C checksum of the [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]. If
  /// specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will verify the integrity of the
  /// received [AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest] using this checksum.
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will report an error if the checksum verification
  /// fails. If you receive a checksum error, your client should verify that
  /// CRC32C([AsymmetricSignRequest.digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]) is equal to
  /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c], and if so, perform a limited
  /// number of retries. A persistent mismatch may indicate an issue in your
  /// computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var digestCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _digestCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_digestCrc32C = newValue}
  }
  /// Returns true if `digestCrc32C` has been explicitly set.
  public var hasDigestCrc32C: Bool {return self._digestCrc32C != nil}
  /// Clears the value of `digestCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearDigestCrc32C() {self._digestCrc32C = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Google_Cloud_Kms_V1_Digest? = nil
  fileprivate var _digestCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Request message for [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
public struct Google_Cloud_Kms_V1_AsymmetricDecryptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use for
  /// decryption.
  public var name: String = String()

  /// Required. The data encrypted with the named [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion]'s public
  /// key using OAEP.
  public var ciphertext: Data = Data()

  /// Optional. An optional CRC32C checksum of the [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext].
  /// If specified, [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will verify the integrity of the
  /// received [AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext] using this checksum.
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] will report an error if the checksum verification
  /// fails. If you receive a checksum error, your client should verify that
  /// CRC32C([AsymmetricDecryptRequest.ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]) is equal to
  /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c], and if so, perform a
  /// limited number of retries. A persistent mismatch may indicate an issue in
  /// your computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var ciphertextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _ciphertextCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_ciphertextCrc32C = newValue}
  }
  /// Returns true if `ciphertextCrc32C` has been explicitly set.
  public var hasCiphertextCrc32C: Bool {return self._ciphertextCrc32C != nil}
  /// Clears the value of `ciphertextCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearCiphertextCrc32C() {self._ciphertextCrc32C = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ciphertextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Response message for [KeyManagementService.Decrypt][google.cloud.kms.v1.KeyManagementService.Decrypt].
public struct Google_Cloud_Kms_V1_DecryptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The decrypted data originally supplied in [EncryptRequest.plaintext][google.cloud.kms.v1.EncryptRequest.plaintext].
  public var plaintext: Data = Data()

  /// Integrity verification field. A CRC32C checksum of the returned
  /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext]. An integrity check of
  /// [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext] can be performed by computing the CRC32C
  /// checksum of [DecryptResponse.plaintext][google.cloud.kms.v1.DecryptResponse.plaintext] and comparing your results to
  /// this field. Discard the response in case of non-matching checksum values,
  /// and perform a limited number of retries. A persistent mismatch may indicate
  /// an issue in your computation of the CRC32C checksum. Note: receiving this
  /// response message indicates that [KeyManagementService][google.cloud.kms.v1.KeyManagementService] is able to
  /// successfully decrypt the [ciphertext][google.cloud.kms.v1.DecryptRequest.ciphertext].
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var plaintextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _plaintextCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_plaintextCrc32C = newValue}
  }
  /// Returns true if `plaintextCrc32C` has been explicitly set.
  public var hasPlaintextCrc32C: Bool {return self._plaintextCrc32C != nil}
  /// Clears the value of `plaintextCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearPlaintextCrc32C() {self._plaintextCrc32C = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _plaintextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Response message for [KeyManagementService.Encrypt][google.cloud.kms.v1.KeyManagementService.Encrypt].
public struct Google_Cloud_Kms_V1_EncryptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used in encryption. Check
  /// this field to verify that the intended resource was used for encryption.
  public var name: String = String()

  /// The encrypted data.
  public var ciphertext: Data = Data()

  /// Integrity verification field. A CRC32C checksum of the returned
  /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext]. An integrity check of
  /// [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext] can be performed by computing the CRC32C
  /// checksum of [EncryptResponse.ciphertext][google.cloud.kms.v1.EncryptResponse.ciphertext] and comparing your results to
  /// this field. Discard the response in case of non-matching checksum values,
  /// and perform a limited number of retries. A persistent mismatch may indicate
  /// an issue in your computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var ciphertextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _ciphertextCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_ciphertextCrc32C = newValue}
  }
  /// Returns true if `ciphertextCrc32C` has been explicitly set.
  public var hasCiphertextCrc32C: Bool {return self._ciphertextCrc32C != nil}
  /// Clears the value of `ciphertextCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearCiphertextCrc32C() {self._ciphertextCrc32C = nil}

  /// Integrity verification field. A flag indicating whether
  /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c] was received by
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used for the integrity verification of the
  /// [plaintext][google.cloud.kms.v1.EncryptRequest.plaintext]. A false value of this field
  /// indicates either that [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c] was left unset or
  /// that it was not delivered to [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've set
  /// [EncryptRequest.plaintext_crc32c][google.cloud.kms.v1.EncryptRequest.plaintext_crc32c] but this field is still false, discard
  /// the response and perform a limited number of retries.
  ///
  /// NOTE: This field is in Beta.
  public var verifiedPlaintextCrc32C: Bool = false

  /// Integrity verification field. A flag indicating whether
  /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c] was received by
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used for the integrity verification of the
  /// [AAD][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data]. A false value of this
  /// field indicates either that
  /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c] was left unset or
  /// that it was not delivered to [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've set
  /// [EncryptRequest.additional_authenticated_data_crc32c][google.cloud.kms.v1.EncryptRequest.additional_authenticated_data_crc32c] but this field is
  /// still false, discard the response and perform a limited number of retries.
  ///
  /// NOTE: This field is in Beta.
  public var verifiedAdditionalAuthenticatedDataCrc32C: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ciphertextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Response message for [KeyManagementService.AsymmetricSign][google.cloud.kms.v1.KeyManagementService.AsymmetricSign].
public struct Google_Cloud_Kms_V1_AsymmetricSignResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The created signature.
  public var signature: Data = Data()

  /// Integrity verification field. A CRC32C checksum of the returned
  /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature]. An integrity check of
  /// [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature] can be performed by computing the
  /// CRC32C checksum of [AsymmetricSignResponse.signature][google.cloud.kms.v1.AsymmetricSignResponse.signature] and comparing your
  /// results to this field. Discard the response in case of non-matching
  /// checksum values, and perform a limited number of retries. A persistent
  /// mismatch may indicate an issue in your computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var signatureCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _signatureCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_signatureCrc32C = newValue}
  }
  /// Returns true if `signatureCrc32C` has been explicitly set.
  public var hasSignatureCrc32C: Bool {return self._signatureCrc32C != nil}
  /// Clears the value of `signatureCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearSignatureCrc32C() {self._signatureCrc32C = nil}

  /// Integrity verification field. A flag indicating whether
  /// [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c] was received by
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used for the integrity verification of the
  /// [digest][google.cloud.kms.v1.AsymmetricSignRequest.digest]. A false value of this field
  /// indicates either that [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c] was left
  /// unset or that it was not delivered to [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If you've
  /// set [AsymmetricSignRequest.digest_crc32c][google.cloud.kms.v1.AsymmetricSignRequest.digest_crc32c] but this field is still false,
  /// discard the response and perform a limited number of retries.
  ///
  /// NOTE: This field is in Beta.
  public var verifiedDigestCrc32C: Bool = false

  /// The resource name of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] used for signing. Check
  /// this field to verify that the intended resource was used for signing.
  ///
  /// NOTE: This field is in Beta.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _signatureCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Response message for [KeyManagementService.AsymmetricDecrypt][google.cloud.kms.v1.KeyManagementService.AsymmetricDecrypt].
public struct Google_Cloud_Kms_V1_AsymmetricDecryptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The decrypted data originally encrypted with the matching public key.
  public var plaintext: Data = Data()

  /// Integrity verification field. A CRC32C checksum of the returned
  /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext]. An integrity check of
  /// [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext] can be performed by computing the
  /// CRC32C checksum of [AsymmetricDecryptResponse.plaintext][google.cloud.kms.v1.AsymmetricDecryptResponse.plaintext] and comparing
  /// your results to this field. Discard the response in case of non-matching
  /// checksum values, and perform a limited number of retries. A persistent
  /// mismatch may indicate an issue in your computation of the CRC32C checksum.
  /// Note: This field is defined as int64 for reasons of compatibility across
  /// different languages. However, it is a non-negative integer, which will
  /// never exceed 2^32-1, and can be safely downconverted to uint32 in languages
  /// that support this type.
  ///
  /// NOTE: This field is in Beta.
  public var plaintextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value {
    get {return _plaintextCrc32C ?? SwiftProtobuf.Google_Protobuf_Int64Value()}
    set {_plaintextCrc32C = newValue}
  }
  /// Returns true if `plaintextCrc32C` has been explicitly set.
  public var hasPlaintextCrc32C: Bool {return self._plaintextCrc32C != nil}
  /// Clears the value of `plaintextCrc32C`. Subsequent reads from it will return its default value.
  public mutating func clearPlaintextCrc32C() {self._plaintextCrc32C = nil}

  /// Integrity verification field. A flag indicating whether
  /// [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c] was received by
  /// [KeyManagementService][google.cloud.kms.v1.KeyManagementService] and used for the integrity verification of the
  /// [ciphertext][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext]. A false value of this
  /// field indicates either that [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c]
  /// was left unset or that it was not delivered to [KeyManagementService][google.cloud.kms.v1.KeyManagementService]. If
  /// you've set [AsymmetricDecryptRequest.ciphertext_crc32c][google.cloud.kms.v1.AsymmetricDecryptRequest.ciphertext_crc32c] but this field is
  /// still false, discard the response and perform a limited number of retries.
  ///
  /// NOTE: This field is in Beta.
  public var verifiedCiphertextCrc32C: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _plaintextCrc32C: SwiftProtobuf.Google_Protobuf_Int64Value? = nil
}

/// Request message for [KeyManagementService.UpdateCryptoKeyPrimaryVersion][google.cloud.kms.v1.KeyManagementService.UpdateCryptoKeyPrimaryVersion].
public struct Google_Cloud_Kms_V1_UpdateCryptoKeyPrimaryVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKey][google.cloud.kms.v1.CryptoKey] to update.
  public var name: String = String()

  /// Required. The id of the child [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to use as primary.
  public var cryptoKeyVersionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.DestroyCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.DestroyCryptoKeyVersion].
public struct Google_Cloud_Kms_V1_DestroyCryptoKeyVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to destroy.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for [KeyManagementService.RestoreCryptoKeyVersion][google.cloud.kms.v1.KeyManagementService.RestoreCryptoKeyVersion].
public struct Google_Cloud_Kms_V1_RestoreCryptoKeyVersionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the [CryptoKeyVersion][google.cloud.kms.v1.CryptoKeyVersion] to restore.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A [Digest][google.cloud.kms.v1.Digest] holds a cryptographic message digest.
public struct Google_Cloud_Kms_V1_Digest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The message digest.
  public var digest: Google_Cloud_Kms_V1_Digest.OneOf_Digest? = nil

  /// A message digest produced with the SHA-256 algorithm.
  public var sha256: Data {
    get {
      if case .sha256(let v)? = digest {return v}
      return Data()
    }
    set {digest = .sha256(newValue)}
  }

  /// A message digest produced with the SHA-384 algorithm.
  public var sha384: Data {
    get {
      if case .sha384(let v)? = digest {return v}
      return Data()
    }
    set {digest = .sha384(newValue)}
  }

  /// A message digest produced with the SHA-512 algorithm.
  public var sha512: Data {
    get {
      if case .sha512(let v)? = digest {return v}
      return Data()
    }
    set {digest = .sha512(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The message digest.
  public enum OneOf_Digest: Equatable {
    /// A message digest produced with the SHA-256 algorithm.
    case sha256(Data)
    /// A message digest produced with the SHA-384 algorithm.
    case sha384(Data)
    /// A message digest produced with the SHA-512 algorithm.
    case sha512(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Kms_V1_Digest.OneOf_Digest, rhs: Google_Cloud_Kms_V1_Digest.OneOf_Digest) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.sha256, .sha256): return {
        guard case .sha256(let l) = lhs, case .sha256(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sha384, .sha384): return {
        guard case .sha384(let l) = lhs, case .sha384(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sha512, .sha512): return {
        guard case .sha512(let l) = lhs, case .sha512(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Cloud KMS metadata for the given [google.cloud.location.Location][google.cloud.location.Location].
public struct Google_Cloud_Kms_V1_LocationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
  /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
  /// [HSM][google.cloud.kms.v1.ProtectionLevel.HSM] can be created in this location.
  public var hsmAvailable: Bool = false

  /// Indicates whether [CryptoKeys][google.cloud.kms.v1.CryptoKey] with
  /// [protection_level][google.cloud.kms.v1.CryptoKeyVersionTemplate.protection_level]
  /// [EXTERNAL][google.cloud.kms.v1.ProtectionLevel.EXTERNAL] can be created in this location.
  public var ekmAvailable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.kms.v1"

extension Google_Cloud_Kms_V1_ListKeyRingsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKeyRingsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListKeyRingsRequest, rhs: Google_Cloud_Kms_V1_ListKeyRingsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListCryptoKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCryptoKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "version_view"),
    5: .same(proto: "filter"),
    6: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.versionView) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.versionView != .unspecified {
      try visitor.visitSingularEnumField(value: self.versionView, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListCryptoKeysRequest, rhs: Google_Cloud_Kms_V1_ListCryptoKeysRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.versionView != rhs.versionView {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListCryptoKeyVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCryptoKeyVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "view"),
    5: .same(proto: "filter"),
    6: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.view != .unspecified {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListCryptoKeyVersionsRequest, rhs: Google_Cloud_Kms_V1_ListCryptoKeyVersionsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.view != rhs.view {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListImportJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListImportJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListImportJobsRequest, rhs: Google_Cloud_Kms_V1_ListImportJobsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListKeyRingsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKeyRingsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_rings"),
    2: .standard(proto: "next_page_token"),
    3: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keyRings) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyRings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyRings, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListKeyRingsResponse, rhs: Google_Cloud_Kms_V1_ListKeyRingsResponse) -> Bool {
    if lhs.keyRings != rhs.keyRings {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListCryptoKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCryptoKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_keys"),
    2: .standard(proto: "next_page_token"),
    3: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cryptoKeys) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cryptoKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cryptoKeys, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListCryptoKeysResponse, rhs: Google_Cloud_Kms_V1_ListCryptoKeysResponse) -> Bool {
    if lhs.cryptoKeys != rhs.cryptoKeys {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListCryptoKeyVersionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListCryptoKeyVersionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_key_versions"),
    2: .standard(proto: "next_page_token"),
    3: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cryptoKeyVersions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cryptoKeyVersions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cryptoKeyVersions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListCryptoKeyVersionsResponse, rhs: Google_Cloud_Kms_V1_ListCryptoKeyVersionsResponse) -> Bool {
    if lhs.cryptoKeyVersions != rhs.cryptoKeyVersions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ListImportJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListImportJobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "import_jobs"),
    2: .standard(proto: "next_page_token"),
    3: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.importJobs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.importJobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.importJobs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ListImportJobsResponse, rhs: Google_Cloud_Kms_V1_ListImportJobsResponse) -> Bool {
    if lhs.importJobs != rhs.importJobs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_GetKeyRingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetKeyRingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_GetKeyRingRequest, rhs: Google_Cloud_Kms_V1_GetKeyRingRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_GetCryptoKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCryptoKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_GetCryptoKeyRequest, rhs: Google_Cloud_Kms_V1_GetCryptoKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_GetCryptoKeyVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCryptoKeyVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_GetCryptoKeyVersionRequest, rhs: Google_Cloud_Kms_V1_GetCryptoKeyVersionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_GetPublicKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetPublicKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_GetPublicKeyRequest, rhs: Google_Cloud_Kms_V1_GetPublicKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_GetImportJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetImportJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_GetImportJobRequest, rhs: Google_Cloud_Kms_V1_GetImportJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CreateKeyRingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeyRingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "key_ring_id"),
    3: .standard(proto: "key_ring"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.keyRingID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._keyRing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.keyRingID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyRingID, fieldNumber: 2)
    }
    if let v = self._keyRing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CreateKeyRingRequest, rhs: Google_Cloud_Kms_V1_CreateKeyRingRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.keyRingID != rhs.keyRingID {return false}
    if lhs._keyRing != rhs._keyRing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CreateCryptoKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCryptoKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "crypto_key_id"),
    3: .standard(proto: "crypto_key"),
    5: .standard(proto: "skip_initial_version_creation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cryptoKeyID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cryptoKey) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.skipInitialVersionCreation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.cryptoKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptoKeyID, fieldNumber: 2)
    }
    if let v = self._cryptoKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.skipInitialVersionCreation != false {
      try visitor.visitSingularBoolField(value: self.skipInitialVersionCreation, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CreateCryptoKeyRequest, rhs: Google_Cloud_Kms_V1_CreateCryptoKeyRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.cryptoKeyID != rhs.cryptoKeyID {return false}
    if lhs._cryptoKey != rhs._cryptoKey {return false}
    if lhs.skipInitialVersionCreation != rhs.skipInitialVersionCreation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CreateCryptoKeyVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateCryptoKeyVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "crypto_key_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cryptoKeyVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._cryptoKeyVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CreateCryptoKeyVersionRequest, rhs: Google_Cloud_Kms_V1_CreateCryptoKeyVersionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._cryptoKeyVersion != rhs._cryptoKeyVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportCryptoKeyVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "algorithm"),
    4: .standard(proto: "import_job"),
    5: .standard(proto: "rsa_aes_wrapped_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.algorithm) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.importJob) }()
      case 5: try {
        if self.wrappedKeyMaterial != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.wrappedKeyMaterial = .rsaAesWrappedKey(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.algorithm != .unspecified {
      try visitor.visitSingularEnumField(value: self.algorithm, fieldNumber: 2)
    }
    if !self.importJob.isEmpty {
      try visitor.visitSingularStringField(value: self.importJob, fieldNumber: 4)
    }
    if case .rsaAesWrappedKey(let v)? = self.wrappedKeyMaterial {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest, rhs: Google_Cloud_Kms_V1_ImportCryptoKeyVersionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.algorithm != rhs.algorithm {return false}
    if lhs.importJob != rhs.importJob {return false}
    if lhs.wrappedKeyMaterial != rhs.wrappedKeyMaterial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_CreateImportJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateImportJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "import_job_id"),
    3: .standard(proto: "import_job"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _importJobID: String = String()
    var _importJob: Google_Cloud_Kms_V1_ImportJob? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _importJobID = source._importJobID
      _importJob = source._importJob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._importJobID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._importJob) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      if !_storage._importJobID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._importJobID, fieldNumber: 2)
      }
      if let v = _storage._importJob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_CreateImportJobRequest, rhs: Google_Cloud_Kms_V1_CreateImportJobRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._importJobID != rhs_storage._importJobID {return false}
        if _storage._importJob != rhs_storage._importJob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_UpdateCryptoKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCryptoKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_key"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cryptoKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cryptoKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_UpdateCryptoKeyRequest, rhs: Google_Cloud_Kms_V1_UpdateCryptoKeyRequest) -> Bool {
    if lhs._cryptoKey != rhs._cryptoKey {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_UpdateCryptoKeyVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCryptoKeyVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "crypto_key_version"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cryptoKeyVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cryptoKeyVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_UpdateCryptoKeyVersionRequest, rhs: Google_Cloud_Kms_V1_UpdateCryptoKeyVersionRequest) -> Bool {
    if lhs._cryptoKeyVersion != rhs._cryptoKeyVersion {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_EncryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "plaintext"),
    3: .standard(proto: "additional_authenticated_data"),
    7: .standard(proto: "plaintext_crc32c"),
    8: .standard(proto: "additional_authenticated_data_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.plaintext) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.additionalAuthenticatedData) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._plaintextCrc32C) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._additionalAuthenticatedDataCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.plaintext.isEmpty {
      try visitor.visitSingularBytesField(value: self.plaintext, fieldNumber: 2)
    }
    if !self.additionalAuthenticatedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.additionalAuthenticatedData, fieldNumber: 3)
    }
    if let v = self._plaintextCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._additionalAuthenticatedDataCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_EncryptRequest, rhs: Google_Cloud_Kms_V1_EncryptRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.plaintext != rhs.plaintext {return false}
    if lhs.additionalAuthenticatedData != rhs.additionalAuthenticatedData {return false}
    if lhs._plaintextCrc32C != rhs._plaintextCrc32C {return false}
    if lhs._additionalAuthenticatedDataCrc32C != rhs._additionalAuthenticatedDataCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_DecryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ciphertext"),
    3: .standard(proto: "additional_authenticated_data"),
    5: .standard(proto: "ciphertext_crc32c"),
    6: .standard(proto: "additional_authenticated_data_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ciphertext) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.additionalAuthenticatedData) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._ciphertextCrc32C) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._additionalAuthenticatedDataCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.ciphertext.isEmpty {
      try visitor.visitSingularBytesField(value: self.ciphertext, fieldNumber: 2)
    }
    if !self.additionalAuthenticatedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.additionalAuthenticatedData, fieldNumber: 3)
    }
    if let v = self._ciphertextCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._additionalAuthenticatedDataCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_DecryptRequest, rhs: Google_Cloud_Kms_V1_DecryptRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ciphertext != rhs.ciphertext {return false}
    if lhs.additionalAuthenticatedData != rhs.additionalAuthenticatedData {return false}
    if lhs._ciphertextCrc32C != rhs._ciphertextCrc32C {return false}
    if lhs._additionalAuthenticatedDataCrc32C != rhs._additionalAuthenticatedDataCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_AsymmetricSignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsymmetricSignRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "digest"),
    4: .standard(proto: "digest_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._digestCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._digestCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_AsymmetricSignRequest, rhs: Google_Cloud_Kms_V1_AsymmetricSignRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._digestCrc32C != rhs._digestCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_AsymmetricDecryptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsymmetricDecryptRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "ciphertext"),
    4: .standard(proto: "ciphertext_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.ciphertext) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ciphertextCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.ciphertext.isEmpty {
      try visitor.visitSingularBytesField(value: self.ciphertext, fieldNumber: 3)
    }
    if let v = self._ciphertextCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_AsymmetricDecryptRequest, rhs: Google_Cloud_Kms_V1_AsymmetricDecryptRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ciphertext != rhs.ciphertext {return false}
    if lhs._ciphertextCrc32C != rhs._ciphertextCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_DecryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DecryptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plaintext"),
    2: .standard(proto: "plaintext_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.plaintext) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._plaintextCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plaintext.isEmpty {
      try visitor.visitSingularBytesField(value: self.plaintext, fieldNumber: 1)
    }
    if let v = self._plaintextCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_DecryptResponse, rhs: Google_Cloud_Kms_V1_DecryptResponse) -> Bool {
    if lhs.plaintext != rhs.plaintext {return false}
    if lhs._plaintextCrc32C != rhs._plaintextCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_EncryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "ciphertext"),
    4: .standard(proto: "ciphertext_crc32c"),
    5: .standard(proto: "verified_plaintext_crc32c"),
    6: .standard(proto: "verified_additional_authenticated_data_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.ciphertext) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ciphertextCrc32C) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.verifiedPlaintextCrc32C) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.verifiedAdditionalAuthenticatedDataCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.ciphertext.isEmpty {
      try visitor.visitSingularBytesField(value: self.ciphertext, fieldNumber: 2)
    }
    if let v = self._ciphertextCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.verifiedPlaintextCrc32C != false {
      try visitor.visitSingularBoolField(value: self.verifiedPlaintextCrc32C, fieldNumber: 5)
    }
    if self.verifiedAdditionalAuthenticatedDataCrc32C != false {
      try visitor.visitSingularBoolField(value: self.verifiedAdditionalAuthenticatedDataCrc32C, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_EncryptResponse, rhs: Google_Cloud_Kms_V1_EncryptResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.ciphertext != rhs.ciphertext {return false}
    if lhs._ciphertextCrc32C != rhs._ciphertextCrc32C {return false}
    if lhs.verifiedPlaintextCrc32C != rhs.verifiedPlaintextCrc32C {return false}
    if lhs.verifiedAdditionalAuthenticatedDataCrc32C != rhs.verifiedAdditionalAuthenticatedDataCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_AsymmetricSignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsymmetricSignResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "signature"),
    2: .standard(proto: "signature_crc32c"),
    3: .standard(proto: "verified_digest_crc32c"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signatureCrc32C) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.verifiedDigestCrc32C) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 1)
    }
    if let v = self._signatureCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.verifiedDigestCrc32C != false {
      try visitor.visitSingularBoolField(value: self.verifiedDigestCrc32C, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_AsymmetricSignResponse, rhs: Google_Cloud_Kms_V1_AsymmetricSignResponse) -> Bool {
    if lhs.signature != rhs.signature {return false}
    if lhs._signatureCrc32C != rhs._signatureCrc32C {return false}
    if lhs.verifiedDigestCrc32C != rhs.verifiedDigestCrc32C {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_AsymmetricDecryptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AsymmetricDecryptResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plaintext"),
    2: .standard(proto: "plaintext_crc32c"),
    3: .standard(proto: "verified_ciphertext_crc32c"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.plaintext) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._plaintextCrc32C) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.verifiedCiphertextCrc32C) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plaintext.isEmpty {
      try visitor.visitSingularBytesField(value: self.plaintext, fieldNumber: 1)
    }
    if let v = self._plaintextCrc32C {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.verifiedCiphertextCrc32C != false {
      try visitor.visitSingularBoolField(value: self.verifiedCiphertextCrc32C, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_AsymmetricDecryptResponse, rhs: Google_Cloud_Kms_V1_AsymmetricDecryptResponse) -> Bool {
    if lhs.plaintext != rhs.plaintext {return false}
    if lhs._plaintextCrc32C != rhs._plaintextCrc32C {return false}
    if lhs.verifiedCiphertextCrc32C != rhs.verifiedCiphertextCrc32C {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_UpdateCryptoKeyPrimaryVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateCryptoKeyPrimaryVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "crypto_key_version_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cryptoKeyVersionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.cryptoKeyVersionID.isEmpty {
      try visitor.visitSingularStringField(value: self.cryptoKeyVersionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_UpdateCryptoKeyPrimaryVersionRequest, rhs: Google_Cloud_Kms_V1_UpdateCryptoKeyPrimaryVersionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.cryptoKeyVersionID != rhs.cryptoKeyVersionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_DestroyCryptoKeyVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DestroyCryptoKeyVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_DestroyCryptoKeyVersionRequest, rhs: Google_Cloud_Kms_V1_DestroyCryptoKeyVersionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_RestoreCryptoKeyVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreCryptoKeyVersionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_RestoreCryptoKeyVersionRequest, rhs: Google_Cloud_Kms_V1_RestoreCryptoKeyVersionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_Digest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Digest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sha256"),
    2: .same(proto: "sha384"),
    3: .same(proto: "sha512"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.digest != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.digest = .sha256(v)}
      }()
      case 2: try {
        if self.digest != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.digest = .sha384(v)}
      }()
      case 3: try {
        if self.digest != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.digest = .sha512(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.digest {
    case .sha256?: try {
      guard case .sha256(let v)? = self.digest else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .sha384?: try {
      guard case .sha384(let v)? = self.digest else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .sha512?: try {
      guard case .sha512(let v)? = self.digest else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_Digest, rhs: Google_Cloud_Kms_V1_Digest) -> Bool {
    if lhs.digest != rhs.digest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Kms_V1_LocationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hsm_available"),
    2: .standard(proto: "ekm_available"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.hsmAvailable) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.ekmAvailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hsmAvailable != false {
      try visitor.visitSingularBoolField(value: self.hsmAvailable, fieldNumber: 1)
    }
    if self.ekmAvailable != false {
      try visitor.visitSingularBoolField(value: self.ekmAvailable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Kms_V1_LocationMetadata, rhs: Google_Cloud_Kms_V1_LocationMetadata) -> Bool {
    if lhs.hsmAvailable != rhs.hsmAvailable {return false}
    if lhs.ekmAvailable != rhs.ekmAvailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

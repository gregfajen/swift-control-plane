// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/recommendationengine/v1beta1/prediction_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for Predict method.
public struct Google_Cloud_Recommendationengine_V1beta1_PredictRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Full resource name of the format:
  /// {name=projects/*/locations/global/catalogs/default_catalog/eventStores/default_event_store/placements/*}
  /// The id of the recommendation engine placement. This id is used to identify
  /// the set of models that will be used to make the prediction.
  ///
  /// We currently support three placements with the following IDs by default:
  ///
  /// * `shopping_cart`: Predicts items frequently bought together with one or
  ///   more catalog items in the same shopping session. Commonly displayed after
  ///   `add-to-cart` events, on product detail pages, or on the shopping cart
  ///   page.
  ///
  /// * `home_page`: Predicts the next product that a user will most likely
  ///   engage with or purchase based on the shopping or viewing history of the
  ///   specified `userId` or `visitorId`. For example - Recommendations for you.
  ///
  /// * `product_detail`: Predicts the next product that a user will most likely
  ///   engage with or purchase. The prediction is based on the shopping or
  ///   viewing history of the specified `userId` or `visitorId` and its
  ///   relevance to a specified `CatalogItem`. Typically used on product detail
  ///   pages. For example - More items like this.
  ///
  /// * `recently_viewed_default`: Returns up to 75 items recently viewed by the
  ///   specified `userId` or `visitorId`, most recent ones first. Returns
  ///   nothing if neither of them has viewed any items yet. For example -
  ///   Recently viewed.
  ///
  /// The full list of available placements can be seen at
  /// https://console.cloud.google.com/recommendation/datafeeds/default_catalog/dashboard
  public var name: String = String()

  /// Required. Context about the user, what they are looking at and what action
  /// they took to trigger the predict request. Note that this user event detail
  /// won't be ingested to userEvent logs. Thus, a separate userEvent write
  /// request is required for event logging.
  public var userEvent: Google_Cloud_Recommendationengine_V1beta1_UserEvent {
    get {return _userEvent ?? Google_Cloud_Recommendationengine_V1beta1_UserEvent()}
    set {_userEvent = newValue}
  }
  /// Returns true if `userEvent` has been explicitly set.
  public var hasUserEvent: Bool {return self._userEvent != nil}
  /// Clears the value of `userEvent`. Subsequent reads from it will return its default value.
  public mutating func clearUserEvent() {self._userEvent = nil}

  /// Optional. Maximum number of results to return per page. Set this property
  /// to the number of prediction results required. If zero, the service will
  /// choose a reasonable default.
  public var pageSize: Int32 = 0

  /// Optional. The previous PredictResponse.next_page_token.
  public var pageToken: String = String()

  /// Optional. Filter for restricting prediction results. Accepts values for
  /// tags and the `filterOutOfStockItems` flag.
  ///
  ///  * Tag expressions. Restricts predictions to items that match all of the
  ///    specified tags. Boolean operators `OR` and `NOT` are supported if the
  ///    expression is enclosed in parentheses, and must be separated from the
  ///    tag values by a space. `-"tagA"` is also supported and is equivalent to
  ///    `NOT "tagA"`. Tag values must be double quoted UTF-8 encoded strings
  ///    with a size limit of 1 KiB.
  ///
  ///  * filterOutOfStockItems. Restricts predictions to items that do not have a
  ///    stockState value of OUT_OF_STOCK.
  ///
  /// Examples:
  ///
  ///  * tag=("Red" OR "Blue") tag="New-Arrival" tag=(NOT "promotional")
  ///  * filterOutOfStockItems  tag=(-"promotional")
  ///  * filterOutOfStockItems
  public var filter: String = String()

  /// Optional. Use dryRun mode for this prediction query. If set to true, a
  /// dummy model will be used that returns arbitrary catalog items.
  /// Note that the dryRun mode should only be used for testing the API, or if
  /// the model is not ready.
  public var dryRun: Bool = false

  /// Optional. Additional domain specific parameters for the predictions.
  ///
  /// Allowed values:
  ///
  /// * `returnCatalogItem`: Boolean. If set to true, the associated catalogItem
  ///    object will be returned in the
  ///   `PredictResponse.PredictionResult.itemMetadata` object in the method
  ///    response.
  /// * `returnItemScore`: Boolean. If set to true, the prediction 'score'
  ///    corresponding to each returned item will be set in the `metadata`
  ///    field in the prediction response. The given 'score' indicates the
  ///    probability of an item being clicked/purchased given the user's context
  ///    and history.
  public var params: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  /// Optional. The labels for the predict request.
  ///
  ///  * Label keys can contain lowercase letters, digits and hyphens, must start
  ///    with a letter, and must end with a letter or digit.
  ///  * Non-zero label values can contain lowercase letters, digits and hyphens,
  ///    must start with a letter, and must end with a letter or digit.
  ///  * No more than 64 labels can be associated with a given request.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _userEvent: Google_Cloud_Recommendationengine_V1beta1_UserEvent? = nil
}

/// Response message for predict method.
public struct Google_Cloud_Recommendationengine_V1beta1_PredictResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of recommended items. The order represents the ranking (from the
  /// most relevant item to the least).
  public var results: [Google_Cloud_Recommendationengine_V1beta1_PredictResponse.PredictionResult] = []

  /// A unique recommendation token. This should be included in the user event
  /// logs resulting from this recommendation, which enables accurate attribution
  /// of recommendation model performance.
  public var recommendationToken: String = String()

  /// IDs of items in the request that were missing from the catalog.
  public var itemsMissingInCatalog: [String] = []

  /// True if the dryRun property was set in the request.
  public var dryRun: Bool = false

  /// Additional domain specific prediction response metadata.
  public var metadata: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  /// If empty, the list is complete. If nonempty, the token to pass to the next
  /// request's PredictRequest.page_token.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// PredictionResult represents the recommendation prediction results.
  public struct PredictionResult {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the recommended catalog item
    public var id: String = String()

    /// Additional item metadata / annotations.
    ///
    /// Possible values:
    ///
    /// * `catalogItem`: JSON representation of the catalogItem. Will be set if
    ///   `returnCatalogItem` is set to true in `PredictRequest.params`.
    /// * `score`: Prediction score in double value. Will be set if
    ///   `returnItemScore` is set to true in `PredictRequest.params`.
    public var itemMetadata: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.recommendationengine.v1beta1"

extension Google_Cloud_Recommendationengine_V1beta1_PredictRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "user_event"),
    7: .standard(proto: "page_size"),
    8: .standard(proto: "page_token"),
    3: .same(proto: "filter"),
    4: .standard(proto: "dry_run"),
    6: .same(proto: "params"),
    9: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._userEvent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.params) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._userEvent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 3)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 4)
    }
    if !self.params.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.params, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 7)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 8)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_PredictRequest, rhs: Google_Cloud_Recommendationengine_V1beta1_PredictRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._userEvent != rhs._userEvent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.params != rhs.params {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_PredictResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "recommendation_token"),
    3: .standard(proto: "items_missing_in_catalog"),
    4: .standard(proto: "dry_run"),
    5: .same(proto: "metadata"),
    6: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recommendationToken) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.itemsMissingInCatalog) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.dryRun) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.metadata) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.recommendationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.recommendationToken, fieldNumber: 2)
    }
    if !self.itemsMissingInCatalog.isEmpty {
      try visitor.visitRepeatedStringField(value: self.itemsMissingInCatalog, fieldNumber: 3)
    }
    if self.dryRun != false {
      try visitor.visitSingularBoolField(value: self.dryRun, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.metadata, fieldNumber: 5)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_PredictResponse, rhs: Google_Cloud_Recommendationengine_V1beta1_PredictResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.recommendationToken != rhs.recommendationToken {return false}
    if lhs.itemsMissingInCatalog != rhs.itemsMissingInCatalog {return false}
    if lhs.dryRun != rhs.dryRun {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_PredictResponse.PredictionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Recommendationengine_V1beta1_PredictResponse.protoMessageName + ".PredictionResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "item_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.itemMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.itemMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.itemMetadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_PredictResponse.PredictionResult, rhs: Google_Cloud_Recommendationengine_V1beta1_PredictResponse.PredictionResult) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.itemMetadata != rhs.itemMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

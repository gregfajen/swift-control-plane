// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/recommendationengine/v1beta1/import.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Google Cloud Storage location for input content.
/// format.
public struct Google_Cloud_Recommendationengine_V1beta1_GcsSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Google Cloud Storage URIs to input files. URI can be up to
  /// 2000 characters long. URIs can match the full object path (for example,
  /// gs://bucket/directory/object.json) or a pattern matching one or more
  /// files, such as gs://bucket/directory/*.json. A request can
  /// contain at most 100 files, and each file can be up to 2 GB. See
  /// [Importing catalog information](/recommendations-ai/docs/upload-catalog)
  /// for the expected file format and setup instructions.
  public var inputUris: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The inline source for the input config for ImportCatalogItems method.
public struct Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A list of catalog items to update/create. Recommended max of 10k
  /// items.
  public var catalogItems: [Google_Cloud_Recommendationengine_V1beta1_CatalogItem] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The inline source for the input config for ImportUserEvents method.
public struct Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A list of user events to import. Recommended max of 10k items.
  public var userEvents: [Google_Cloud_Recommendationengine_V1beta1_UserEvent] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration of destination for Import related errors.
public struct Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Errors destination.
  public var destination: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig.OneOf_Destination? = nil

  /// Google Cloud Storage path for import errors. This must be an empty,
  /// existing Cloud Storage bucket. Import errors will be written to a file in
  /// this bucket, one per line, as a JSON-encoded
  /// `google.rpc.Status` message.
  public var gcsPrefix: String {
    get {
      if case .gcsPrefix(let v)? = destination {return v}
      return String()
    }
    set {destination = .gcsPrefix(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Errors destination.
  public enum OneOf_Destination: Equatable {
    /// Google Cloud Storage path for import errors. This must be an empty,
    /// existing Cloud Storage bucket. Import errors will be written to a file in
    /// this bucket, one per line, as a JSON-encoded
    /// `google.rpc.Status` message.
    case gcsPrefix(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig.OneOf_Destination, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsPrefix, .gcsPrefix): return {
        guard case .gcsPrefix(let l) = lhs, case .gcsPrefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Request message for Import methods.
public struct Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. "projects/1234/locations/global/catalogs/default_catalog"
  public var parent: String = String()

  /// Optional. Unique identifier provided by client, within the ancestor
  /// dataset scope. Ensures idempotency and used for request deduplication.
  /// Server-generated if unspecified. Up to 128 characters long. This is
  /// returned as google.longrunning.Operation.name in the response.
  public var requestID: String = String()

  /// Required. The desired input location of the data.
  public var inputConfig: Google_Cloud_Recommendationengine_V1beta1_InputConfig {
    get {return _inputConfig ?? Google_Cloud_Recommendationengine_V1beta1_InputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  public var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInputConfig() {self._inputConfig = nil}

  /// Optional. The desired location of errors incurred during the Import.
  public var errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputConfig: Google_Cloud_Recommendationengine_V1beta1_InputConfig? = nil
  fileprivate var _errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig? = nil
}

/// Request message for the ImportUserEvents request.
public struct Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  /// "projects/1234/locations/global/catalogs/default_catalog/eventStores/default_event_store"
  public var parent: String = String()

  /// Optional. Unique identifier provided by client, within the ancestor
  /// dataset scope. Ensures idempotency for expensive long running operations.
  /// Server-generated if unspecified. Up to 128 characters long. This is
  /// returned as google.longrunning.Operation.name in the response. Note that
  /// this field must not be set if the desired input config is
  /// catalog_inline_source.
  public var requestID: String = String()

  /// Required. The desired input location of the data.
  public var inputConfig: Google_Cloud_Recommendationengine_V1beta1_InputConfig {
    get {return _inputConfig ?? Google_Cloud_Recommendationengine_V1beta1_InputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  public var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInputConfig() {self._inputConfig = nil}

  /// Optional. The desired location of errors incurred during the Import.
  public var errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputConfig: Google_Cloud_Recommendationengine_V1beta1_InputConfig? = nil
  fileprivate var _errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig? = nil
}

/// The input config source.
public struct Google_Cloud_Recommendationengine_V1beta1_InputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The source of the input.
  public var source: Google_Cloud_Recommendationengine_V1beta1_InputConfig.OneOf_Source? = nil

  /// The Inline source for the input content for Catalog items.
  public var catalogInlineSource: Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource {
    get {
      if case .catalogInlineSource(let v)? = source {return v}
      return Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource()
    }
    set {source = .catalogInlineSource(newValue)}
  }

  /// Google Cloud Storage location for the input content.
  public var gcsSource: Google_Cloud_Recommendationengine_V1beta1_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Recommendationengine_V1beta1_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  /// The Inline source for the input content for UserEvents.
  public var userEventInlineSource: Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource {
    get {
      if case .userEventInlineSource(let v)? = source {return v}
      return Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource()
    }
    set {source = .userEventInlineSource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The source of the input.
  public enum OneOf_Source: Equatable {
    /// The Inline source for the input content for Catalog items.
    case catalogInlineSource(Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource)
    /// Google Cloud Storage location for the input content.
    case gcsSource(Google_Cloud_Recommendationengine_V1beta1_GcsSource)
    /// The Inline source for the input content for UserEvents.
    case userEventInlineSource(Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_InputConfig.OneOf_Source, rhs: Google_Cloud_Recommendationengine_V1beta1_InputConfig.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.catalogInlineSource, .catalogInlineSource): return {
        guard case .catalogInlineSource(let l) = lhs, case .catalogInlineSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsSource, .gcsSource): return {
        guard case .gcsSource(let l) = lhs, case .gcsSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userEventInlineSource, .userEventInlineSource): return {
        guard case .userEventInlineSource(let l) = lhs, case .userEventInlineSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Metadata related to the progress of the Import operation. This will be
/// returned by the google.longrunning.Operation.metadata field.
public struct Google_Cloud_Recommendationengine_V1beta1_ImportMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the operation.
  public var operationName: String = String()

  /// Id of the request / operation. This is parroting back the requestId that
  /// was passed in the request.
  public var requestID: String = String()

  /// Operation create time.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Count of entries that were processed successfully.
  public var successCount: Int64 = 0

  /// Count of entries that encountered errors while processing.
  public var failureCount: Int64 = 0

  /// Operation last update time. If the operation is done, this is also the
  /// finish time.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Response of the ImportCatalogItemsRequest. If the long running
/// operation is done, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
public struct Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sample of errors encountered while processing the request.
  public var errorSamples: [Google_Rpc_Status] = []

  /// Echoes the destination for the complete errors in the request if set.
  public var errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig? = nil
}

/// Response of the ImportUserEventsRequest. If the long running
/// operation was successful, then this message is returned by the
/// google.longrunning.Operations.response field if the operation was successful.
public struct Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A sample of errors encountered while processing the request.
  public var errorSamples: [Google_Rpc_Status] = []

  /// Echoes the destination for the complete errors if this field was set in
  /// the request.
  public var errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig {
    get {return _errorsConfig ?? Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig()}
    set {_errorsConfig = newValue}
  }
  /// Returns true if `errorsConfig` has been explicitly set.
  public var hasErrorsConfig: Bool {return self._errorsConfig != nil}
  /// Clears the value of `errorsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearErrorsConfig() {self._errorsConfig = nil}

  /// Aggregated statistics of user event import status.
  public var importSummary: Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary {
    get {return _importSummary ?? Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary()}
    set {_importSummary = newValue}
  }
  /// Returns true if `importSummary` has been explicitly set.
  public var hasImportSummary: Bool {return self._importSummary != nil}
  /// Clears the value of `importSummary`. Subsequent reads from it will return its default value.
  public mutating func clearImportSummary() {self._importSummary = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _errorsConfig: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig? = nil
  fileprivate var _importSummary: Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary? = nil
}

/// A summary of import result. The UserEventImportSummary summarizes
/// the import status for user events.
public struct Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of user events imported with complete existing catalog information.
  public var joinedEventsCount: Int64 = 0

  /// Count of user events imported, but with catalog information not found
  /// in the imported catalog.
  public var unjoinedEventsCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.recommendationengine.v1beta1"

extension Google_Cloud_Recommendationengine_V1beta1_GcsSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_uris"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.inputUris) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputUris, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_GcsSource, rhs: Google_Cloud_Recommendationengine_V1beta1_GcsSource) -> Bool {
    if lhs.inputUris != rhs.inputUris {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CatalogInlineSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "catalog_items"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.catalogItems) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.catalogItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.catalogItems, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource, rhs: Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource) -> Bool {
    if lhs.catalogItems != rhs.catalogItems {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserEventInlineSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_events"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.userEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userEvents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.userEvents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource, rhs: Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource) -> Bool {
    if lhs.userEvents != rhs.userEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportErrorsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.destination != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.destination = .gcsPrefix(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .gcsPrefix(let v)? = self.destination {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportErrorsConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportCatalogItemsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "input_config"),
    4: .standard(proto: "errors_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsRequest, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportUserEventsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "input_config"),
    4: .standard(proto: "errors_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsRequest, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_InputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "catalog_inline_source"),
    2: .standard(proto: "gcs_source"),
    3: .standard(proto: "user_event_inline_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Recommendationengine_V1beta1_CatalogInlineSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .catalogInlineSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .catalogInlineSource(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Recommendationengine_V1beta1_GcsSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .gcsSource(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Recommendationengine_V1beta1_UserEventInlineSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .userEventInlineSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .userEventInlineSource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .catalogInlineSource?: try {
      guard case .catalogInlineSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gcsSource?: try {
      guard case .gcsSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .userEventInlineSource?: try {
      guard case .userEventInlineSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_InputConfig, rhs: Google_Cloud_Recommendationengine_V1beta1_InputConfig) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_ImportMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "operation_name"),
    3: .standard(proto: "request_id"),
    4: .standard(proto: "create_time"),
    1: .standard(proto: "success_count"),
    2: .standard(proto: "failure_count"),
    6: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.successCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.failureCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.operationName) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.successCount != 0 {
      try visitor.visitSingularInt64Field(value: self.successCount, fieldNumber: 1)
    }
    if self.failureCount != 0 {
      try visitor.visitSingularInt64Field(value: self.failureCount, fieldNumber: 2)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.operationName.isEmpty {
      try visitor.visitSingularStringField(value: self.operationName, fieldNumber: 5)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportMetadata, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportMetadata) -> Bool {
    if lhs.operationName != rhs.operationName {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.successCount != rhs.successCount {return false}
    if lhs.failureCount != rhs.failureCount {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportCatalogItemsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_samples"),
    2: .standard(proto: "errors_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errorSamples) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorSamples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorSamples, fieldNumber: 1)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsResponse, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportCatalogItemsResponse) -> Bool {
    if lhs.errorSamples != rhs.errorSamples {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportUserEventsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_samples"),
    2: .standard(proto: "errors_config"),
    3: .standard(proto: "import_summary"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.errorSamples) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._errorsConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._importSummary) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorSamples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorSamples, fieldNumber: 1)
    }
    if let v = self._errorsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._importSummary {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsResponse, rhs: Google_Cloud_Recommendationengine_V1beta1_ImportUserEventsResponse) -> Bool {
    if lhs.errorSamples != rhs.errorSamples {return false}
    if lhs._errorsConfig != rhs._errorsConfig {return false}
    if lhs._importSummary != rhs._importSummary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserEventImportSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "joined_events_count"),
    2: .standard(proto: "unjoined_events_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.joinedEventsCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.unjoinedEventsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.joinedEventsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.joinedEventsCount, fieldNumber: 1)
    }
    if self.unjoinedEventsCount != 0 {
      try visitor.visitSingularInt64Field(value: self.unjoinedEventsCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary, rhs: Google_Cloud_Recommendationengine_V1beta1_UserEventImportSummary) -> Bool {
    if lhs.joinedEventsCount != rhs.joinedEventsCount {return false}
    if lhs.unjoinedEventsCount != rhs.unjoinedEventsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

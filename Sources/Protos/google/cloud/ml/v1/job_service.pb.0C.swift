// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/ml/v1/job_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents input parameters for a training job.
public struct Google_Cloud_Ml_V1_TrainingInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Specifies the machine types, the number of replicas for workers
  /// and parameter servers.
  public var scaleTier: Google_Cloud_Ml_V1_TrainingInput.ScaleTier {
    get {return _storage._scaleTier}
    set {_uniqueStorage()._scaleTier = newValue}
  }

  /// Optional. Specifies the type of virtual machine to use for your training
  /// job's master worker.
  ///
  /// The following types are supported:
  ///
  /// <dl>
  ///   <dt>standard</dt>
  ///   <dd>
  ///   A basic machine configuration suitable for training simple models with
  ///   small to moderate datasets.
  ///   </dd>
  ///   <dt>large_model</dt>
  ///   <dd>
  ///   A machine with a lot of memory, specially suited for parameter servers
  ///   when your model is large (having many hidden layers or layers with very
  ///   large numbers of nodes).
  ///   </dd>
  ///   <dt>complex_model_s</dt>
  ///   <dd>
  ///   A machine suitable for the master and workers of the cluster when your
  ///   model requires more computation than the standard machine can handle
  ///   satisfactorily.
  ///   </dd>
  ///   <dt>complex_model_m</dt>
  ///   <dd>
  ///   A machine with roughly twice the number of cores and roughly double the
  ///   memory of <code suppresswarning="true">complex_model_s</code>.
  ///   </dd>
  ///   <dt>complex_model_l</dt>
  ///   <dd>
  ///   A machine with roughly twice the number of cores and roughly double the
  ///   memory of <code suppresswarning="true">complex_model_m</code>.
  ///   </dd>
  ///   <dt>standard_gpu</dt>
  ///   <dd>
  ///   A machine equivalent to <code suppresswarning="true">standard</code> that
  ///   also includes a
  ///   <a href="ml/docs/how-tos/using-gpus">
  ///   GPU that you can use in your trainer</a>.
  ///   </dd>
  ///   <dt>complex_model_m_gpu</dt>
  ///   <dd>
  ///   A machine equivalent to
  ///   <code suppresswarning="true">coplex_model_m</code> that also includes
  ///   four GPUs.
  ///   </dd>
  /// </dl>
  ///
  /// You must set this value when `scaleTier` is set to `CUSTOM`.
  public var masterType: String {
    get {return _storage._masterType}
    set {_uniqueStorage()._masterType = newValue}
  }

  /// Optional. Specifies the type of virtual machine to use for your training
  /// job's worker nodes.
  ///
  /// The supported values are the same as those described in the entry for
  /// `masterType`.
  ///
  /// This value must be present when `scaleTier` is set to `CUSTOM` and
  /// `workerCount` is greater than zero.
  public var workerType: String {
    get {return _storage._workerType}
    set {_uniqueStorage()._workerType = newValue}
  }

  /// Optional. Specifies the type of virtual machine to use for your training
  /// job's parameter server.
  ///
  /// The supported values are the same as those described in the entry for
  /// `master_type`.
  ///
  /// This value must be present when `scaleTier` is set to `CUSTOM` and
  /// `parameter_server_count` is greater than zero.
  public var parameterServerType: String {
    get {return _storage._parameterServerType}
    set {_uniqueStorage()._parameterServerType = newValue}
  }

  /// Optional. The number of worker replicas to use for the training job. Each
  /// replica in the cluster will be of the type specified in `worker_type`.
  ///
  /// This value can only be used when `scale_tier` is set to `CUSTOM`. If you
  /// set this value, you must also set `worker_type`.
  public var workerCount: Int64 {
    get {return _storage._workerCount}
    set {_uniqueStorage()._workerCount = newValue}
  }

  /// Optional. The number of parameter server replicas to use for the training
  /// job. Each replica in the cluster will be of the type specified in
  /// `parameter_server_type`.
  ///
  /// This value can only be used when `scale_tier` is set to `CUSTOM`.If you
  /// set this value, you must also set `parameter_server_type`.
  public var parameterServerCount: Int64 {
    get {return _storage._parameterServerCount}
    set {_uniqueStorage()._parameterServerCount = newValue}
  }

  /// Required. The Google Cloud Storage location of the packages with
  /// the training program and any additional dependencies.
  public var packageUris: [String] {
    get {return _storage._packageUris}
    set {_uniqueStorage()._packageUris = newValue}
  }

  /// Required. The Python module name to run after installing the packages.
  public var pythonModule: String {
    get {return _storage._pythonModule}
    set {_uniqueStorage()._pythonModule = newValue}
  }

  /// Optional. Command line arguments to pass to the program.
  public var args: [String] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Optional. The set of Hyperparameters to tune.
  public var hyperparameters: Google_Cloud_Ml_V1_HyperparameterSpec {
    get {return _storage._hyperparameters ?? Google_Cloud_Ml_V1_HyperparameterSpec()}
    set {_uniqueStorage()._hyperparameters = newValue}
  }
  /// Returns true if `hyperparameters` has been explicitly set.
  public var hasHyperparameters: Bool {return _storage._hyperparameters != nil}
  /// Clears the value of `hyperparameters`. Subsequent reads from it will return its default value.
  public mutating func clearHyperparameters() {_uniqueStorage()._hyperparameters = nil}

  /// Required. The Google Compute Engine region to run the training job in.
  public var region: String {
    get {return _storage._region}
    set {_uniqueStorage()._region = newValue}
  }

  /// Optional. A Google Cloud Storage path in which to store training outputs
  /// and other data needed for training. This path is passed to your TensorFlow
  /// program as the 'job_dir' command-line argument. The benefit of specifying
  /// this field is that Cloud ML validates the path for use in training.
  public var jobDir: String {
    get {return _storage._jobDir}
    set {_uniqueStorage()._jobDir = newValue}
  }

  /// Optional. The Google Cloud ML runtime version to use for training.  If not
  /// set, Google Cloud ML will choose the latest stable version.
  public var runtimeVersion: String {
    get {return _storage._runtimeVersion}
    set {_uniqueStorage()._runtimeVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A scale tier is an abstract representation of the resources Cloud ML
  /// will allocate to a training job. When selecting a scale tier for your
  /// training job, you should consider the size of your training dataset and
  /// the complexity of your model. As the tiers increase, virtual machines are
  /// added to handle your job, and the individual machines in the cluster
  /// generally have more memory and greater processing power than they do at
  /// lower tiers. The number of training units charged per hour of processing
  /// increases as tiers get more advanced. Refer to the
  /// [pricing guide](/ml/pricing) for more details. Note that in addition to
  /// incurring costs, your use of training resources is constrained by the
  /// [quota policy](/ml/quota).
  public enum ScaleTier: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// A single worker instance. This tier is suitable for learning how to use
    /// Cloud ML, and for experimenting with new models using small datasets.
    case basic // = 0

    /// Many workers and a few parameter servers.
    case standard1 // = 1

    /// A large number of workers with many parameter servers.
    case premium1 // = 3

    /// A single worker instance [with a GPU](ml/docs/how-tos/using-gpus).
    case basicGpu // = 6

    /// The CUSTOM tier is not a set tier, but rather enables you to use your
    /// own cluster specification. When you use this tier, set values to
    /// configure your processing cluster according to these guidelines:
    ///
    /// *   You _must_ set `TrainingInput.masterType` to specify the type
    ///     of machine to use for your master node. This is the only required
    ///     setting.
    ///
    /// *   You _may_ set `TrainingInput.workerCount` to specify the number of
    ///     workers to use. If you specify one or more workers, you _must_ also
    ///     set `TrainingInput.workerType` to specify the type of machine to use
    ///     for your worker nodes.
    ///
    /// *   You _may_ set `TrainingInput.parameterServerCount` to specify the
    ///     number of parameter servers to use. If you specify one or more
    ///     parameter servers, you _must_ also set
    ///     `TrainingInput.parameterServerType` to specify the type of machine to
    ///     use for your parameter servers.
    ///
    /// Note that all of your workers must use the same machine type, which can
    /// be different from your parameter server type and master type. Your
    /// parameter servers must likewise use the same machine type, which can be
    /// different from your worker type and master type.
    case custom // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .basic
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .basic
      case 1: self = .standard1
      case 3: self = .premium1
      case 5: self = .custom
      case 6: self = .basicGpu
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .basic: return 0
      case .standard1: return 1
      case .premium1: return 3
      case .custom: return 5
      case .basicGpu: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Ml_V1_TrainingInput.ScaleTier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Ml_V1_TrainingInput.ScaleTier] = [
    .basic,
    .standard1,
    .premium1,
    .basicGpu,
    .custom,
  ]
}

#endif  // swift(>=4.2)

/// Represents a set of hyperparameters to optimize.
public struct Google_Cloud_Ml_V1_HyperparameterSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The type of goal to use for tuning. Available types are
  /// `MAXIMIZE` and `MINIMIZE`.
  ///
  /// Defaults to `MAXIMIZE`.
  public var goal: Google_Cloud_Ml_V1_HyperparameterSpec.GoalType = .unspecified

  /// Required. The set of parameters to tune.
  public var params: [Google_Cloud_Ml_V1_ParameterSpec] = []

  /// Optional. How many training trials should be attempted to optimize
  /// the specified hyperparameters.
  ///
  /// Defaults to one.
  public var maxTrials: Int32 = 0

  /// Optional. The number of training trials to run concurrently.
  /// You can reduce the time it takes to perform hyperparameter tuning by adding
  /// trials in parallel. However, each trail only benefits from the information
  /// gained in completed trials. That means that a trial does not get access to
  /// the results of trials running at the same time, which could reduce the
  /// quality of the overall optimization.
  ///
  /// Each trial will use the same scale tier and machine types.
  ///
  /// Defaults to one.
  public var maxParallelTrials: Int32 = 0

  /// Optional. The Tensorflow summary tag name to use for optimizing trials. For
  /// current versions of Tensorflow, this tag name should exactly match what is
  /// shown in Tensorboard, including all scopes.  For versions of Tensorflow
  /// prior to 0.12, this should be only the tag passed to tf.Summary.
  /// By default, "training/hptuning/metric" will be used.
  public var hyperparameterMetricTag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The available types of optimization goals.
  public enum GoalType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Goal Type will default to maximize.
    case unspecified // = 0

    /// Maximize the goal metric.
    case maximize // = 1

    /// Minimize the goal metric.
    case minimize // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .maximize
      case 2: self = .minimize
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .maximize: return 1
      case .minimize: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Ml_V1_HyperparameterSpec.GoalType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Ml_V1_HyperparameterSpec.GoalType] = [
    .unspecified,
    .maximize,
    .minimize,
  ]
}

#endif  // swift(>=4.2)

/// Represents a single hyperparameter to optimize.
public struct Google_Cloud_Ml_V1_ParameterSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parameter name must be unique amongst all ParameterConfigs in
  /// a HyperparameterSpec message. E.g., "learning_rate".
  public var parameterName: String = String()

  /// Required. The type of the parameter.
  public var type: Google_Cloud_Ml_V1_ParameterSpec.ParameterType = .unspecified

  /// Required if type is `DOUBLE` or `INTEGER`. This field
  /// should be unset if type is `CATEGORICAL`. This value should be integers if
  /// type is INTEGER.
  public var minValue: Double = 0

  /// Required if typeis `DOUBLE` or `INTEGER`. This field
  /// should be unset if type is `CATEGORICAL`. This value should be integers if
  /// type is `INTEGER`.
  public var maxValue: Double = 0

  /// Required if type is `CATEGORICAL`. The list of possible categories.
  public var categoricalValues: [String] = []

  /// Required if type is `DISCRETE`.
  /// A list of feasible points.
  /// The list should be in strictly increasing order. For instance, this
  /// parameter might have possible settings of 1.5, 2.5, and 4.0. This list
  /// should not contain more than 1,000 values.
  public var discreteValues: [Double] = []

  /// Optional. How the parameter should be scaled to the hypercube.
  /// Leave unset for categorical parameters.
  /// Some kind of scaling is strongly recommended for real or integral
  /// parameters (e.g., `UNIT_LINEAR_SCALE`).
  public var scaleType: Google_Cloud_Ml_V1_ParameterSpec.ScaleType = .none

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of the parameter.
  public enum ParameterType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// You must specify a valid type. Using this unspecified type will result in
    /// an error.
    case unspecified // = 0

    /// Type for real-valued parameters.
    case double // = 1

    /// Type for integral parameters.
    case integer // = 2

    /// The parameter is categorical, with a value chosen from the categories
    /// field.
    case categorical // = 3

    /// The parameter is real valued, with a fixed set of feasible points. If
    /// `type==DISCRETE`, feasible_points must be provided, and
    /// {`min_value`, `max_value`} will be ignored.
    case discrete // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .double
      case 2: self = .integer
      case 3: self = .categorical
      case 4: self = .discrete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .double: return 1
      case .integer: return 2
      case .categorical: return 3
      case .discrete: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The type of scaling that should be applied to this parameter.
  public enum ScaleType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// By default, no scaling is applied.
    case none // = 0

    /// Scales the feasible space to (0, 1) linearly.
    case unitLinearScale // = 1

    /// Scales the feasible space logarithmically to (0, 1). The entire feasible
    /// space must be strictly positive.
    case unitLogScale // = 2

    /// Scales the feasible space "reverse" logarithmically to (0, 1). The result
    /// is that values close to the top of the feasible space are spread out more
    /// than points near the bottom. The entire feasible space must be strictly
    /// positive.
    case unitReverseLogScale // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .unitLinearScale
      case 2: self = .unitLogScale
      case 3: self = .unitReverseLogScale
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .unitLinearScale: return 1
      case .unitLogScale: return 2
      case .unitReverseLogScale: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Ml_V1_ParameterSpec.ParameterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Ml_V1_ParameterSpec.ParameterType] = [
    .unspecified,
    .double,
    .integer,
    .categorical,
    .discrete,
  ]
}

extension Google_Cloud_Ml_V1_ParameterSpec.ScaleType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Ml_V1_ParameterSpec.ScaleType] = [
    .none,
    .unitLinearScale,
    .unitLogScale,
    .unitReverseLogScale,
  ]
}

#endif  // swift(>=4.2)

/// Represents the result of a single hyperparameter tuning trial from a
/// training job. The TrainingOutput object that is returned on successful
/// completion of a training job with hyperparameter tuning includes a list
/// of HyperparameterOutput objects, one for each successful trial.
public struct Google_Cloud_Ml_V1_HyperparameterOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The trial id for these results.
  public var trialID: String = String()

  /// The hyperparameters given to this trial.
  public var hyperparameters: Dictionary<String,String> = [:]

  /// The final objective metric seen for this trial.
  public var finalMetric: Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric {
    get {return _finalMetric ?? Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric()}
    set {_finalMetric = newValue}
  }
  /// Returns true if `finalMetric` has been explicitly set.
  public var hasFinalMetric: Bool {return self._finalMetric != nil}
  /// Clears the value of `finalMetric`. Subsequent reads from it will return its default value.
  public mutating func clearFinalMetric() {self._finalMetric = nil}

  /// All recorded object metrics for this trial.
  public var allMetrics: [Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An observed value of a metric.
  public struct HyperparameterMetric {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The global training step for this metric.
    public var trainingStep: Int64 = 0

    /// The objective value at this training step.
    public var objectiveValue: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _finalMetric: Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric? = nil
}

/// Represents results of a training job. Output only.
public struct Google_Cloud_Ml_V1_TrainingOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of hyperparameter tuning trials that completed successfully.
  /// Only set for hyperparameter tuning jobs.
  public var completedTrialCount: Int64 = 0

  /// Results for individual Hyperparameter trials.
  /// Only set for hyperparameter tuning jobs.
  public var trials: [Google_Cloud_Ml_V1_HyperparameterOutput] = []

  /// The amount of ML units consumed by the job.
  public var consumedMlUnits: Double = 0

  /// Whether this job is a hyperparameter tuning job.
  public var isHyperparameterTuningJob: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents input parameters for a prediction job.
public struct Google_Cloud_Ml_V1_PredictionInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The model or the version to use for prediction.
  public var modelVersion: Google_Cloud_Ml_V1_PredictionInput.OneOf_ModelVersion? = nil

  /// Use this field if you want to use the default version for the specified
  /// model. The string must use the following format:
  ///
  /// `"projects/<var>[YOUR_PROJECT]</var>/models/<var>[YOUR_MODEL]</var>"`
  public var modelName: String {
    get {
      if case .modelName(let v)? = modelVersion {return v}
      return String()
    }
    set {modelVersion = .modelName(newValue)}
  }

  /// Use this field if you want to specify a version of the model to use. The
  /// string is formatted the same way as `model_version`, with the addition
  /// of the version information:
  ///
  /// `"projects/<var>[YOUR_PROJECT]</var>/models/<var>YOUR_MODEL/versions/<var>[YOUR_VERSION]</var>"`
  public var versionName: String {
    get {
      if case .versionName(let v)? = modelVersion {return v}
      return String()
    }
    set {modelVersion = .versionName(newValue)}
  }

  /// Use this field if you want to specify a Google Cloud Storage path for
  /// the model to use.
  public var uri: String {
    get {
      if case .uri(let v)? = modelVersion {return v}
      return String()
    }
    set {modelVersion = .uri(newValue)}
  }

  /// Required. The format of the input data files.
  public var dataFormat: Google_Cloud_Ml_V1_PredictionInput.DataFormat = .unspecified

  /// Required. The Google Cloud Storage location of the input data files.
  /// May contain wildcards.
  public var inputPaths: [String] = []

  /// Required. The output Google Cloud Storage location.
  public var outputPath: String = String()

  /// Optional. The maximum number of workers to be used for parallel processing.
  /// Defaults to 10 if not specified.
  public var maxWorkerCount: Int64 = 0

  /// Required. The Google Compute Engine region to run the prediction job in.
  public var region: String = String()

  /// Optional. The Google Cloud ML runtime version to use for this batch
  /// prediction. If not set, Google Cloud ML will pick the runtime version used
  /// during the CreateVersion request for this model version, or choose the
  /// latest stable version when model version information is not available
  /// such as when the model is specified by uri.
  public var runtimeVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The model or the version to use for prediction.
  public enum OneOf_ModelVersion: Equatable {
    /// Use this field if you want to use the default version for the specified
    /// model. The string must use the following format:
    ///
    /// `"projects/<var>[YOUR_PROJECT]</var>/models/<var>[YOUR_MODEL]</var>"`
    case modelName(String)
    /// Use this field if you want to specify a version of the model to use. The
    /// string is formatted the same way as `model_version`, with the addition
    /// of the version information:
    ///
    /// `"projects/<var>[YOUR_PROJECT]</var>/models/<var>YOUR_MODEL/versions/<var>[YOUR_VERSION]</var>"`
    case versionName(String)
    /// Use this field if you want to specify a Google Cloud Storage path for
    /// the model to use.
    case uri(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Ml_V1_PredictionInput.OneOf_ModelVersion, rhs: Google_Cloud_Ml_V1_PredictionInput.OneOf_ModelVersion) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.modelName, .modelName): return {
        guard case .modelName(let l) = lhs, case .modelName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.versionName, .versionName): return {
        guard case .versionName(let l) = lhs, case .versionName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uri, .uri): return {
        guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The format used to separate data instances in the source files.
  public enum DataFormat: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified format.
    case unspecified // = 0

    /// The source file is a text file with instances separated by the
    /// new-line character.
    case text // = 1

    /// The source file is a TFRecord file.
    case tfRecord // = 2

    /// The source file is a GZIP-compressed TFRecord file.
    case tfRecordGzip // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .text
      case 2: self = .tfRecord
      case 3: self = .tfRecordGzip
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .text: return 1
      case .tfRecord: return 2
      case .tfRecordGzip: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Ml_V1_PredictionInput.DataFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Ml_V1_PredictionInput.DataFormat] = [
    .unspecified,
    .text,
    .tfRecord,
    .tfRecordGzip,
  ]
}

#endif  // swift(>=4.2)

/// Represents results of a prediction job.
public struct Google_Cloud_Ml_V1_PredictionOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The output Google Cloud Storage location provided at the job creation time.
  public var outputPath: String = String()

  /// The number of generated predictions.
  public var predictionCount: Int64 = 0

  /// The number of data instances which resulted in errors.
  public var errorCount: Int64 = 0

  /// Node hours used by the batch prediction job.
  public var nodeHours: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a training or prediction job.
public struct Google_Cloud_Ml_V1_Job {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The user-specified id of the job.
  public var jobID: String {
    get {return _storage._jobID}
    set {_uniqueStorage()._jobID = newValue}
  }

  /// Required. Parameters to create a job.
  public var input: OneOf_Input? {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  /// Input parameters to create a training job.
  public var trainingInput: Google_Cloud_Ml_V1_TrainingInput {
    get {
      if case .trainingInput(let v)? = _storage._input {return v}
      return Google_Cloud_Ml_V1_TrainingInput()
    }
    set {_uniqueStorage()._input = .trainingInput(newValue)}
  }

  /// Input parameters to create a prediction job.
  public var predictionInput: Google_Cloud_Ml_V1_PredictionInput {
    get {
      if case .predictionInput(let v)? = _storage._input {return v}
      return Google_Cloud_Ml_V1_PredictionInput()
    }
    set {_uniqueStorage()._input = .predictionInput(newValue)}
  }

  /// Output only. When the job was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. When the job processing was started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Output only. When the job processing was completed.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Output only. The detailed state of a job.
  public var state: Google_Cloud_Ml_V1_Job.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. The details of a failure or a cancellation.
  public var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  /// Output only. The current result of the job.
  public var output: OneOf_Output? {
    get {return _storage._output}
    set {_uniqueStorage()._output = newValue}
  }

  /// The current training job result.
  public var trainingOutput: Google_Cloud_Ml_V1_TrainingOutput {
    get {
      if case .trainingOutput(let v)? = _storage._output {return v}
      return Google_Cloud_Ml_V1_TrainingOutput()
    }
    set {_uniqueStorage()._output = .trainingOutput(newValue)}
  }

  /// The current prediction job result.
  public var predictionOutput: Google_Cloud_Ml_V1_PredictionOutput {
    get {
      if case .predictionOutput(let v)? = _storage._output {return v}
      return Google_Cloud_Ml_V1_PredictionOutput()
    }
    set {_uniqueStorage()._output = .predictionOutput(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Parameters to create a job.
  public enum OneOf_Input: Equatable {
    /// Input parameters to create a training job.
    case trainingInput(Google_Cloud_Ml_V1_TrainingInput)
    /// Input parameters to create a prediction job.
    case predictionInput(Google_Cloud_Ml_V1_PredictionInput)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Ml_V1_Job.OneOf_Input, rhs: Google_Cloud_Ml_V1_Job.OneOf_Input) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.trainingInput, .trainingInput): return {
        guard case .trainingInput(let l) = lhs, case .trainingInput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.predictionInput, .predictionInput): return {
        guard case .predictionInput(let l) = lhs, case .predictionInput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Output only. The current result of the job.
  public enum OneOf_Output: Equatable {
    /// The current training job result.
    case trainingOutput(Google_Cloud_Ml_V1_TrainingOutput)
    /// The current prediction job result.
    case predictionOutput(Google_Cloud_Ml_V1_PredictionOutput)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Ml_V1_Job.OneOf_Output, rhs: Google_Cloud_Ml_V1_Job.OneOf_Output) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.trainingOutput, .trainingOutput): return {
        guard case .trainingOutput(let l) = lhs, case .trainingOutput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.predictionOutput, .predictionOutput): return {
        guard case .predictionOutput(let l) = lhs, case .predictionOutput(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Describes the job state.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The job state is unspecified.
    case unspecified // = 0

    /// The job has been just created and processing has not yet begun.
    case queued // = 1

    /// The service is preparing to run the job.
    case preparing // = 2

    /// The job is in progress.
    case running // = 3

    /// The job completed successfully.
    case succeeded // = 4

    /// The job failed.
    /// `error_message` should contain the details of the failure.
    case failed // = 5

    /// The job is being cancelled.
    /// `error_message` should describe the reason for the cancellation.
    case cancelling // = 6

    /// The job has been cancelled.
    /// `error_message` should describe the reason for the cancellation.
    case cancelled // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .queued
      case 2: self = .preparing
      case 3: self = .running
      case 4: self = .succeeded
      case 5: self = .failed
      case 6: self = .cancelling
      case 7: self = .cancelled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .queued: return 1
      case .preparing: return 2
      case .running: return 3
      case .succeeded: return 4
      case .failed: return 5
      case .cancelling: return 6
      case .cancelled: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Ml_V1_Job.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Ml_V1_Job.State] = [
    .unspecified,
    .queued,
    .preparing,
    .running,
    .succeeded,
    .failed,
    .cancelling,
    .cancelled,
  ]
}

#endif  // swift(>=4.2)

/// Request message for the CreateJob method.
public struct Google_Cloud_Ml_V1_CreateJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project name.
  ///
  /// Authorization: requires `Editor` role on the specified project.
  public var parent: String = String()

  /// Required. The job to create.
  public var job: Google_Cloud_Ml_V1_Job {
    get {return _job ?? Google_Cloud_Ml_V1_Job()}
    set {_job = newValue}
  }
  /// Returns true if `job` has been explicitly set.
  public var hasJob: Bool {return self._job != nil}
  /// Clears the value of `job`. Subsequent reads from it will return its default value.
  public mutating func clearJob() {self._job = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _job: Google_Cloud_Ml_V1_Job? = nil
}

/// Request message for the ListJobs method.
public struct Google_Cloud_Ml_V1_ListJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project for which to list jobs.
  ///
  /// Authorization: requires `Viewer` role on the specified project.
  public var parent: String = String()

  /// Optional. Specifies the subset of jobs to retrieve.
  public var filter: String = String()

  /// Optional. A page token to request the next page of results.
  ///
  /// You get the token from the `next_page_token` field of the response from
  /// the previous call.
  public var pageToken: String = String()

  /// Optional. The number of jobs to retrieve per "page" of results. If there
  /// are more remaining results than this number, the response message will
  /// contain a valid value in the `next_page_token` field.
  ///
  /// The default value is 20, and the maximum page size is 100.
  public var pageSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for the ListJobs method.
public struct Google_Cloud_Ml_V1_ListJobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of jobs.
  public var jobs: [Google_Cloud_Ml_V1_Job] = []

  /// Optional. Pass this token as the `page_token` field of the request for a
  /// subsequent call.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for the GetJob method.
public struct Google_Cloud_Ml_V1_GetJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the job to get the description of.
  ///
  /// Authorization: requires `Viewer` role on the parent project.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for the CancelJob method.
public struct Google_Cloud_Ml_V1_CancelJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the job to cancel.
  ///
  /// Authorization: requires `Editor` role on the parent project.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.ml.v1"

extension Google_Cloud_Ml_V1_TrainingInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainingInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "scale_tier"),
    2: .standard(proto: "master_type"),
    3: .standard(proto: "worker_type"),
    4: .standard(proto: "parameter_server_type"),
    5: .standard(proto: "worker_count"),
    6: .standard(proto: "parameter_server_count"),
    7: .standard(proto: "package_uris"),
    8: .standard(proto: "python_module"),
    10: .same(proto: "args"),
    12: .same(proto: "hyperparameters"),
    14: .same(proto: "region"),
    16: .standard(proto: "job_dir"),
    15: .standard(proto: "runtime_version"),
  ]

  fileprivate class _StorageClass {
    var _scaleTier: Google_Cloud_Ml_V1_TrainingInput.ScaleTier = .basic
    var _masterType: String = String()
    var _workerType: String = String()
    var _parameterServerType: String = String()
    var _workerCount: Int64 = 0
    var _parameterServerCount: Int64 = 0
    var _packageUris: [String] = []
    var _pythonModule: String = String()
    var _args: [String] = []
    var _hyperparameters: Google_Cloud_Ml_V1_HyperparameterSpec? = nil
    var _region: String = String()
    var _jobDir: String = String()
    var _runtimeVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scaleTier = source._scaleTier
      _masterType = source._masterType
      _workerType = source._workerType
      _parameterServerType = source._parameterServerType
      _workerCount = source._workerCount
      _parameterServerCount = source._parameterServerCount
      _packageUris = source._packageUris
      _pythonModule = source._pythonModule
      _args = source._args
      _hyperparameters = source._hyperparameters
      _region = source._region
      _jobDir = source._jobDir
      _runtimeVersion = source._runtimeVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._scaleTier) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._masterType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._workerType) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._parameterServerType) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._workerCount) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._parameterServerCount) }()
        case 7: try { try decoder.decodeRepeatedStringField(value: &_storage._packageUris) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._pythonModule) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._args) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._hyperparameters) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._region) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._runtimeVersion) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._jobDir) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._scaleTier != .basic {
        try visitor.visitSingularEnumField(value: _storage._scaleTier, fieldNumber: 1)
      }
      if !_storage._masterType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._masterType, fieldNumber: 2)
      }
      if !_storage._workerType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerType, fieldNumber: 3)
      }
      if !_storage._parameterServerType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parameterServerType, fieldNumber: 4)
      }
      if _storage._workerCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workerCount, fieldNumber: 5)
      }
      if _storage._parameterServerCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parameterServerCount, fieldNumber: 6)
      }
      if !_storage._packageUris.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._packageUris, fieldNumber: 7)
      }
      if !_storage._pythonModule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pythonModule, fieldNumber: 8)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 10)
      }
      if let v = _storage._hyperparameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._region.isEmpty {
        try visitor.visitSingularStringField(value: _storage._region, fieldNumber: 14)
      }
      if !_storage._runtimeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtimeVersion, fieldNumber: 15)
      }
      if !_storage._jobDir.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobDir, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_TrainingInput, rhs: Google_Cloud_Ml_V1_TrainingInput) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scaleTier != rhs_storage._scaleTier {return false}
        if _storage._masterType != rhs_storage._masterType {return false}
        if _storage._workerType != rhs_storage._workerType {return false}
        if _storage._parameterServerType != rhs_storage._parameterServerType {return false}
        if _storage._workerCount != rhs_storage._workerCount {return false}
        if _storage._parameterServerCount != rhs_storage._parameterServerCount {return false}
        if _storage._packageUris != rhs_storage._packageUris {return false}
        if _storage._pythonModule != rhs_storage._pythonModule {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._hyperparameters != rhs_storage._hyperparameters {return false}
        if _storage._region != rhs_storage._region {return false}
        if _storage._jobDir != rhs_storage._jobDir {return false}
        if _storage._runtimeVersion != rhs_storage._runtimeVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_TrainingInput.ScaleTier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BASIC"),
    1: .same(proto: "STANDARD_1"),
    3: .same(proto: "PREMIUM_1"),
    5: .same(proto: "CUSTOM"),
    6: .same(proto: "BASIC_GPU"),
  ]
}

extension Google_Cloud_Ml_V1_HyperparameterSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HyperparameterSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "goal"),
    2: .same(proto: "params"),
    3: .standard(proto: "max_trials"),
    4: .standard(proto: "max_parallel_trials"),
    5: .standard(proto: "hyperparameter_metric_tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.goal) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.params) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxTrials) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxParallelTrials) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.hyperparameterMetricTag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.goal != .unspecified {
      try visitor.visitSingularEnumField(value: self.goal, fieldNumber: 1)
    }
    if !self.params.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.params, fieldNumber: 2)
    }
    if self.maxTrials != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTrials, fieldNumber: 3)
    }
    if self.maxParallelTrials != 0 {
      try visitor.visitSingularInt32Field(value: self.maxParallelTrials, fieldNumber: 4)
    }
    if !self.hyperparameterMetricTag.isEmpty {
      try visitor.visitSingularStringField(value: self.hyperparameterMetricTag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_HyperparameterSpec, rhs: Google_Cloud_Ml_V1_HyperparameterSpec) -> Bool {
    if lhs.goal != rhs.goal {return false}
    if lhs.params != rhs.params {return false}
    if lhs.maxTrials != rhs.maxTrials {return false}
    if lhs.maxParallelTrials != rhs.maxParallelTrials {return false}
    if lhs.hyperparameterMetricTag != rhs.hyperparameterMetricTag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_HyperparameterSpec.GoalType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GOAL_TYPE_UNSPECIFIED"),
    1: .same(proto: "MAXIMIZE"),
    2: .same(proto: "MINIMIZE"),
  ]
}

extension Google_Cloud_Ml_V1_ParameterSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ParameterSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "parameter_name"),
    4: .same(proto: "type"),
    2: .standard(proto: "min_value"),
    3: .standard(proto: "max_value"),
    5: .standard(proto: "categorical_values"),
    6: .standard(proto: "discrete_values"),
    7: .standard(proto: "scale_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parameterName) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.minValue) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.maxValue) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.categoricalValues) }()
      case 6: try { try decoder.decodeRepeatedDoubleField(value: &self.discreteValues) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.scaleType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parameterName.isEmpty {
      try visitor.visitSingularStringField(value: self.parameterName, fieldNumber: 1)
    }
    if self.minValue != 0 {
      try visitor.visitSingularDoubleField(value: self.minValue, fieldNumber: 2)
    }
    if self.maxValue != 0 {
      try visitor.visitSingularDoubleField(value: self.maxValue, fieldNumber: 3)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.categoricalValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.categoricalValues, fieldNumber: 5)
    }
    if !self.discreteValues.isEmpty {
      try visitor.visitPackedDoubleField(value: self.discreteValues, fieldNumber: 6)
    }
    if self.scaleType != .none {
      try visitor.visitSingularEnumField(value: self.scaleType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_ParameterSpec, rhs: Google_Cloud_Ml_V1_ParameterSpec) -> Bool {
    if lhs.parameterName != rhs.parameterName {return false}
    if lhs.type != rhs.type {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs.categoricalValues != rhs.categoricalValues {return false}
    if lhs.discreteValues != rhs.discreteValues {return false}
    if lhs.scaleType != rhs.scaleType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_ParameterSpec.ParameterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARAMETER_TYPE_UNSPECIFIED"),
    1: .same(proto: "DOUBLE"),
    2: .same(proto: "INTEGER"),
    3: .same(proto: "CATEGORICAL"),
    4: .same(proto: "DISCRETE"),
  ]
}

extension Google_Cloud_Ml_V1_ParameterSpec.ScaleType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "UNIT_LINEAR_SCALE"),
    2: .same(proto: "UNIT_LOG_SCALE"),
    3: .same(proto: "UNIT_REVERSE_LOG_SCALE"),
  ]
}

extension Google_Cloud_Ml_V1_HyperparameterOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HyperparameterOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trial_id"),
    2: .same(proto: "hyperparameters"),
    3: .standard(proto: "final_metric"),
    4: .standard(proto: "all_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.trialID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.hyperparameters) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finalMetric) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.allMetrics) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.trialID.isEmpty {
      try visitor.visitSingularStringField(value: self.trialID, fieldNumber: 1)
    }
    if !self.hyperparameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.hyperparameters, fieldNumber: 2)
    }
    if let v = self._finalMetric {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.allMetrics.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allMetrics, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_HyperparameterOutput, rhs: Google_Cloud_Ml_V1_HyperparameterOutput) -> Bool {
    if lhs.trialID != rhs.trialID {return false}
    if lhs.hyperparameters != rhs.hyperparameters {return false}
    if lhs._finalMetric != rhs._finalMetric {return false}
    if lhs.allMetrics != rhs.allMetrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Ml_V1_HyperparameterOutput.protoMessageName + ".HyperparameterMetric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "training_step"),
    2: .standard(proto: "objective_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.trainingStep) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.objectiveValue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.trainingStep != 0 {
      try visitor.visitSingularInt64Field(value: self.trainingStep, fieldNumber: 1)
    }
    if self.objectiveValue != 0 {
      try visitor.visitSingularDoubleField(value: self.objectiveValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric, rhs: Google_Cloud_Ml_V1_HyperparameterOutput.HyperparameterMetric) -> Bool {
    if lhs.trainingStep != rhs.trainingStep {return false}
    if lhs.objectiveValue != rhs.objectiveValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_TrainingOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TrainingOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "completed_trial_count"),
    2: .same(proto: "trials"),
    3: .standard(proto: "consumed_ml_units"),
    4: .standard(proto: "is_hyperparameter_tuning_job"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.completedTrialCount) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.trials) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.consumedMlUnits) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isHyperparameterTuningJob) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.completedTrialCount != 0 {
      try visitor.visitSingularInt64Field(value: self.completedTrialCount, fieldNumber: 1)
    }
    if !self.trials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trials, fieldNumber: 2)
    }
    if self.consumedMlUnits != 0 {
      try visitor.visitSingularDoubleField(value: self.consumedMlUnits, fieldNumber: 3)
    }
    if self.isHyperparameterTuningJob != false {
      try visitor.visitSingularBoolField(value: self.isHyperparameterTuningJob, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_TrainingOutput, rhs: Google_Cloud_Ml_V1_TrainingOutput) -> Bool {
    if lhs.completedTrialCount != rhs.completedTrialCount {return false}
    if lhs.trials != rhs.trials {return false}
    if lhs.consumedMlUnits != rhs.consumedMlUnits {return false}
    if lhs.isHyperparameterTuningJob != rhs.isHyperparameterTuningJob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_PredictionInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictionInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "model_name"),
    2: .standard(proto: "version_name"),
    9: .same(proto: "uri"),
    3: .standard(proto: "data_format"),
    4: .standard(proto: "input_paths"),
    5: .standard(proto: "output_path"),
    6: .standard(proto: "max_worker_count"),
    7: .same(proto: "region"),
    8: .standard(proto: "runtime_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.modelVersion != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.modelVersion = .modelName(v)}
      }()
      case 2: try {
        if self.modelVersion != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.modelVersion = .versionName(v)}
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.dataFormat) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.inputPaths) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.outputPath) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.maxWorkerCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.runtimeVersion) }()
      case 9: try {
        if self.modelVersion != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.modelVersion = .uri(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.modelVersion {
    case .modelName?: try {
      guard case .modelName(let v)? = self.modelVersion else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .versionName?: try {
      guard case .versionName(let v)? = self.modelVersion else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    default: break
    }
    if self.dataFormat != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataFormat, fieldNumber: 3)
    }
    if !self.inputPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.inputPaths, fieldNumber: 4)
    }
    if !self.outputPath.isEmpty {
      try visitor.visitSingularStringField(value: self.outputPath, fieldNumber: 5)
    }
    if self.maxWorkerCount != 0 {
      try visitor.visitSingularInt64Field(value: self.maxWorkerCount, fieldNumber: 6)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 7)
    }
    if !self.runtimeVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.runtimeVersion, fieldNumber: 8)
    }
    if case .uri(let v)? = self.modelVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_PredictionInput, rhs: Google_Cloud_Ml_V1_PredictionInput) -> Bool {
    if lhs.modelVersion != rhs.modelVersion {return false}
    if lhs.dataFormat != rhs.dataFormat {return false}
    if lhs.inputPaths != rhs.inputPaths {return false}
    if lhs.outputPath != rhs.outputPath {return false}
    if lhs.maxWorkerCount != rhs.maxWorkerCount {return false}
    if lhs.region != rhs.region {return false}
    if lhs.runtimeVersion != rhs.runtimeVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_PredictionInput.DataFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_FORMAT_UNSPECIFIED"),
    1: .same(proto: "TEXT"),
    2: .same(proto: "TF_RECORD"),
    3: .same(proto: "TF_RECORD_GZIP"),
  ]
}

extension Google_Cloud_Ml_V1_PredictionOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PredictionOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_path"),
    2: .standard(proto: "prediction_count"),
    3: .standard(proto: "error_count"),
    4: .standard(proto: "node_hours"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputPath) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.predictionCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.errorCount) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.nodeHours) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputPath.isEmpty {
      try visitor.visitSingularStringField(value: self.outputPath, fieldNumber: 1)
    }
    if self.predictionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.predictionCount, fieldNumber: 2)
    }
    if self.errorCount != 0 {
      try visitor.visitSingularInt64Field(value: self.errorCount, fieldNumber: 3)
    }
    if self.nodeHours != 0 {
      try visitor.visitSingularDoubleField(value: self.nodeHours, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_PredictionOutput, rhs: Google_Cloud_Ml_V1_PredictionOutput) -> Bool {
    if lhs.outputPath != rhs.outputPath {return false}
    if lhs.predictionCount != rhs.predictionCount {return false}
    if lhs.errorCount != rhs.errorCount {return false}
    if lhs.nodeHours != rhs.nodeHours {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_Job: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Job"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
    2: .standard(proto: "training_input"),
    3: .standard(proto: "prediction_input"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
    7: .same(proto: "state"),
    8: .standard(proto: "error_message"),
    9: .standard(proto: "training_output"),
    10: .standard(proto: "prediction_output"),
  ]

  fileprivate class _StorageClass {
    var _jobID: String = String()
    var _input: Google_Cloud_Ml_V1_Job.OneOf_Input?
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Google_Cloud_Ml_V1_Job.State = .unspecified
    var _errorMessage: String = String()
    var _output: Google_Cloud_Ml_V1_Job.OneOf_Output?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _jobID = source._jobID
      _input = source._input
      _createTime = source._createTime
      _startTime = source._startTime
      _endTime = source._endTime
      _state = source._state
      _errorMessage = source._errorMessage
      _output = source._output
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._jobID) }()
        case 2: try {
          var v: Google_Cloud_Ml_V1_TrainingInput?
          if let current = _storage._input {
            try decoder.handleConflictingOneOf()
            if case .trainingInput(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._input = .trainingInput(v)}
        }()
        case 3: try {
          var v: Google_Cloud_Ml_V1_PredictionInput?
          if let current = _storage._input {
            try decoder.handleConflictingOneOf()
            if case .predictionInput(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._input = .predictionInput(v)}
        }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        case 9: try {
          var v: Google_Cloud_Ml_V1_TrainingOutput?
          if let current = _storage._output {
            try decoder.handleConflictingOneOf()
            if case .trainingOutput(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._output = .trainingOutput(v)}
        }()
        case 10: try {
          var v: Google_Cloud_Ml_V1_PredictionOutput?
          if let current = _storage._output {
            try decoder.handleConflictingOneOf()
            if case .predictionOutput(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._output = .predictionOutput(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._jobID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobID, fieldNumber: 1)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._input {
      case .trainingInput?: try {
        guard case .trainingInput(let v)? = _storage._input else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .predictionInput?: try {
        guard case .predictionInput(let v)? = _storage._input else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 7)
      }
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 8)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._output {
      case .trainingOutput?: try {
        guard case .trainingOutput(let v)? = _storage._output else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .predictionOutput?: try {
        guard case .predictionOutput(let v)? = _storage._output else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_Job, rhs: Google_Cloud_Ml_V1_Job) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._jobID != rhs_storage._jobID {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._output != rhs_storage._output {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_Job.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "QUEUED"),
    2: .same(proto: "PREPARING"),
    3: .same(proto: "RUNNING"),
    4: .same(proto: "SUCCEEDED"),
    5: .same(proto: "FAILED"),
    6: .same(proto: "CANCELLING"),
    7: .same(proto: "CANCELLED"),
  ]
}

extension Google_Cloud_Ml_V1_CreateJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "job"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._job) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._job {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_CreateJobRequest, rhs: Google_Cloud_Ml_V1_CreateJobRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._job != rhs._job {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_ListJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "page_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_ListJobsRequest, rhs: Google_Cloud_Ml_V1_ListJobsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_ListJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListJobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "jobs"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.jobs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jobs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_ListJobsResponse, rhs: Google_Cloud_Ml_V1_ListJobsResponse) -> Bool {
    if lhs.jobs != rhs.jobs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_GetJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_GetJobRequest, rhs: Google_Cloud_Ml_V1_GetJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Ml_V1_CancelJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Ml_V1_CancelJobRequest, rhs: Google_Cloud_Ml_V1_CancelJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

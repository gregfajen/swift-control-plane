// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datalabeling/v1beta1/dataset.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Google_Cloud_Datalabeling_V1beta1_DataType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Allowed for continuous evaluation.
  case image // = 1
  case video // = 2

  /// Allowed for continuous evaluation.
  case text // = 4

  /// Allowed for continuous evaluation.
  case generalData // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .image
    case 2: self = .video
    case 4: self = .text
    case 6: self = .generalData
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .image: return 1
    case .video: return 2
    case .text: return 4
    case .generalData: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_DataType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_DataType] = [
    .unspecified,
    .image,
    .video,
    .text,
    .generalData,
  ]
}

#endif  // swift(>=4.2)

/// Dataset is the resource to hold your data. You can request multiple labeling
/// tasks for a dataset while each one will generate an AnnotatedDataset.
public struct Google_Cloud_Datalabeling_V1beta1_Dataset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Dataset resource name, format is:
  /// projects/{project_id}/datasets/{dataset_id}
  public var name: String = String()

  /// Required. The display name of the dataset. Maximum of 64 characters.
  public var displayName: String = String()

  /// Optional. User-provided description of the annotation specification set.
  /// The description can be up to 10000 characters long.
  public var description_p: String = String()

  /// Output only. Time the dataset is created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. This is populated with the original input configs
  /// where ImportData is called. It is available only after the clients
  /// import data to this dataset.
  public var inputConfigs: [Google_Cloud_Datalabeling_V1beta1_InputConfig] = []

  /// Output only. The names of any related resources that are blocking changes
  /// to the dataset.
  public var blockingResources: [String] = []

  /// Output only. The number of data items in the dataset.
  public var dataItemCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The configuration of input data, including data type, location, etc.
public struct Google_Cloud_Datalabeling_V1beta1_InputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The metadata associated with each data type.
  public var dataTypeMetadata: Google_Cloud_Datalabeling_V1beta1_InputConfig.OneOf_DataTypeMetadata? = nil

  /// Required for text import, as language code must be specified.
  public var textMetadata: Google_Cloud_Datalabeling_V1beta1_TextMetadata {
    get {
      if case .textMetadata(let v)? = dataTypeMetadata {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextMetadata()
    }
    set {dataTypeMetadata = .textMetadata(newValue)}
  }

  /// Required. Where the data is from.
  public var source: Google_Cloud_Datalabeling_V1beta1_InputConfig.OneOf_Source? = nil

  /// Source located in Cloud Storage.
  public var gcsSource: Google_Cloud_Datalabeling_V1beta1_GcsSource {
    get {
      if case .gcsSource(let v)? = source {return v}
      return Google_Cloud_Datalabeling_V1beta1_GcsSource()
    }
    set {source = .gcsSource(newValue)}
  }

  /// Source located in BigQuery. You must specify this field if you are using
  /// this InputConfig in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob].
  public var bigquerySource: Google_Cloud_Datalabeling_V1beta1_BigQuerySource {
    get {
      if case .bigquerySource(let v)? = source {return v}
      return Google_Cloud_Datalabeling_V1beta1_BigQuerySource()
    }
    set {source = .bigquerySource(newValue)}
  }

  /// Required. Data type must be specifed when user tries to import data.
  public var dataType: Google_Cloud_Datalabeling_V1beta1_DataType = .unspecified

  /// Optional. The type of annotation to be performed on this data. You must
  /// specify this field if you are using this InputConfig in an
  /// [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob].
  public var annotationType: Google_Cloud_Datalabeling_V1beta1_AnnotationType = .unspecified

  /// Optional. Metadata about annotations for the input. You must specify this
  /// field if you are using this InputConfig in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob] for a
  /// model version that performs classification.
  public var classificationMetadata: Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata {
    get {return _classificationMetadata ?? Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata()}
    set {_classificationMetadata = newValue}
  }
  /// Returns true if `classificationMetadata` has been explicitly set.
  public var hasClassificationMetadata: Bool {return self._classificationMetadata != nil}
  /// Clears the value of `classificationMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearClassificationMetadata() {self._classificationMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Optional. The metadata associated with each data type.
  public enum OneOf_DataTypeMetadata: Equatable {
    /// Required for text import, as language code must be specified.
    case textMetadata(Google_Cloud_Datalabeling_V1beta1_TextMetadata)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_InputConfig.OneOf_DataTypeMetadata, rhs: Google_Cloud_Datalabeling_V1beta1_InputConfig.OneOf_DataTypeMetadata) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.textMetadata, .textMetadata): return {
        guard case .textMetadata(let l) = lhs, case .textMetadata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Required. Where the data is from.
  public enum OneOf_Source: Equatable {
    /// Source located in Cloud Storage.
    case gcsSource(Google_Cloud_Datalabeling_V1beta1_GcsSource)
    /// Source located in BigQuery. You must specify this field if you are using
    /// this InputConfig in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob].
    case bigquerySource(Google_Cloud_Datalabeling_V1beta1_BigQuerySource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_InputConfig.OneOf_Source, rhs: Google_Cloud_Datalabeling_V1beta1_InputConfig.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsSource, .gcsSource): return {
        guard case .gcsSource(let l) = lhs, case .gcsSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigquerySource, .bigquerySource): return {
        guard case .bigquerySource(let l) = lhs, case .bigquerySource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _classificationMetadata: Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata? = nil
}

/// Metadata for the text.
public struct Google_Cloud_Datalabeling_V1beta1_TextMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The language of this text, as a
  /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
  /// Default value is en-US.
  public var languageCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata for classification annotations.
public struct Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the classification task is multi-label or not.
  public var isMultiLabel: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Source of the Cloud Storage file to be imported.
public struct Google_Cloud_Datalabeling_V1beta1_GcsSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The input URI of source file. This must be a Cloud Storage path
  /// (`gs://...`).
  public var inputUri: String = String()

  /// Required. The format of the source file. Only "text/csv" is supported.
  public var mimeType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The BigQuery location for input data. If used in an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob], this
/// is where the service saves the prediction input and output sampled from the
/// model version.
public struct Google_Cloud_Datalabeling_V1beta1_BigQuerySource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. BigQuery URI to a table, up to 2,000 characters long. If you
  /// specify the URI of a table that does not exist, Data Labeling Service
  /// creates a table at the URI with the correct schema when you create your
  /// [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob]. If you specify the URI of a table that already exists,
  /// it must have the
  /// [correct
  /// schema](/ml-engine/docs/continuous-evaluation/create-job#table-schema).
  ///
  /// Provide the table URI in the following format:
  ///
  /// "bq://<var>{your_project_id}</var>/<var>{your_dataset_name}</var>/<var>{your_table_name}</var>"
  ///
  /// [Learn
  /// more](/ml-engine/docs/continuous-evaluation/create-job#table-schema).
  public var inputUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The configuration of output data.
public struct Google_Cloud_Datalabeling_V1beta1_OutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Location to output data to.
  public var destination: Google_Cloud_Datalabeling_V1beta1_OutputConfig.OneOf_Destination? = nil

  /// Output to a file in Cloud Storage. Should be used for labeling output
  /// other than image segmentation.
  public var gcsDestination: Google_Cloud_Datalabeling_V1beta1_GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Datalabeling_V1beta1_GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  /// Output to a folder in Cloud Storage. Should be used for image
  /// segmentation labeling output.
  public var gcsFolderDestination: Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination {
    get {
      if case .gcsFolderDestination(let v)? = destination {return v}
      return Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination()
    }
    set {destination = .gcsFolderDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Location to output data to.
  public enum OneOf_Destination: Equatable {
    /// Output to a file in Cloud Storage. Should be used for labeling output
    /// other than image segmentation.
    case gcsDestination(Google_Cloud_Datalabeling_V1beta1_GcsDestination)
    /// Output to a folder in Cloud Storage. Should be used for image
    /// segmentation labeling output.
    case gcsFolderDestination(Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_OutputConfig.OneOf_Destination, rhs: Google_Cloud_Datalabeling_V1beta1_OutputConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsDestination, .gcsDestination): return {
        guard case .gcsDestination(let l) = lhs, case .gcsDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gcsFolderDestination, .gcsFolderDestination): return {
        guard case .gcsFolderDestination(let l) = lhs, case .gcsFolderDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Export destination of the data.Only gcs path is allowed in
/// output_uri.
public struct Google_Cloud_Datalabeling_V1beta1_GcsDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The output uri of destination file.
  public var outputUri: String = String()

  /// Required. The format of the gcs destination. Only "text/csv" and
  /// "application/json"
  /// are supported.
  public var mimeType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Export folder destination of the data.
public struct Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Cloud Storage directory to export data to.
  public var outputFolderUri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// DataItem is a piece of data, without annotation. For example, an image.
public struct Google_Cloud_Datalabeling_V1beta1_DataItem {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only.
  public var payload: Google_Cloud_Datalabeling_V1beta1_DataItem.OneOf_Payload? = nil

  /// The image payload, a container of the image bytes/uri.
  public var imagePayload: Google_Cloud_Datalabeling_V1beta1_ImagePayload {
    get {
      if case .imagePayload(let v)? = payload {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImagePayload()
    }
    set {payload = .imagePayload(newValue)}
  }

  /// The text payload, a container of text content.
  public var textPayload: Google_Cloud_Datalabeling_V1beta1_TextPayload {
    get {
      if case .textPayload(let v)? = payload {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextPayload()
    }
    set {payload = .textPayload(newValue)}
  }

  /// The video payload, a container of the video uri.
  public var videoPayload: Google_Cloud_Datalabeling_V1beta1_VideoPayload {
    get {
      if case .videoPayload(let v)? = payload {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoPayload()
    }
    set {payload = .videoPayload(newValue)}
  }

  /// Output only. Name of the data item, in format of:
  /// projects/{project_id}/datasets/{dataset_id}/dataItems/{data_item_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Output only.
  public enum OneOf_Payload: Equatable {
    /// The image payload, a container of the image bytes/uri.
    case imagePayload(Google_Cloud_Datalabeling_V1beta1_ImagePayload)
    /// The text payload, a container of text content.
    case textPayload(Google_Cloud_Datalabeling_V1beta1_TextPayload)
    /// The video payload, a container of the video uri.
    case videoPayload(Google_Cloud_Datalabeling_V1beta1_VideoPayload)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DataItem.OneOf_Payload, rhs: Google_Cloud_Datalabeling_V1beta1_DataItem.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.imagePayload, .imagePayload): return {
        guard case .imagePayload(let l) = lhs, case .imagePayload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textPayload, .textPayload): return {
        guard case .textPayload(let l) = lhs, case .textPayload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoPayload, .videoPayload): return {
        guard case .videoPayload(let l) = lhs, case .videoPayload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// AnnotatedDataset is a set holding annotations for data in a Dataset. Each
/// labeling task will generate an AnnotatedDataset under the Dataset that the
/// task is requested for.
public struct Google_Cloud_Datalabeling_V1beta1_AnnotatedDataset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. AnnotatedDataset resource name in format of:
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
  /// {annotated_dataset_id}
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. The display name of the AnnotatedDataset. It is specified in
  /// HumanAnnotationConfig when user starts a labeling task. Maximum of 64
  /// characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Output only. The description of the AnnotatedDataset. It is specified in
  /// HumanAnnotationConfig when user starts a labeling task. Maximum of 10000
  /// characters.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Output only. Source of the annotation.
  public var annotationSource: Google_Cloud_Datalabeling_V1beta1_AnnotationSource {
    get {return _storage._annotationSource}
    set {_uniqueStorage()._annotationSource = newValue}
  }

  /// Output only. Type of the annotation. It is specified when starting labeling
  /// task.
  public var annotationType: Google_Cloud_Datalabeling_V1beta1_AnnotationType {
    get {return _storage._annotationType}
    set {_uniqueStorage()._annotationType = newValue}
  }

  /// Output only. Number of examples in the annotated dataset.
  public var exampleCount: Int64 {
    get {return _storage._exampleCount}
    set {_uniqueStorage()._exampleCount = newValue}
  }

  /// Output only. Number of examples that have annotation in the annotated
  /// dataset.
  public var completedExampleCount: Int64 {
    get {return _storage._completedExampleCount}
    set {_uniqueStorage()._completedExampleCount = newValue}
  }

  /// Output only. Per label statistics.
  public var labelStats: Google_Cloud_Datalabeling_V1beta1_LabelStats {
    get {return _storage._labelStats ?? Google_Cloud_Datalabeling_V1beta1_LabelStats()}
    set {_uniqueStorage()._labelStats = newValue}
  }
  /// Returns true if `labelStats` has been explicitly set.
  public var hasLabelStats: Bool {return _storage._labelStats != nil}
  /// Clears the value of `labelStats`. Subsequent reads from it will return its default value.
  public mutating func clearLabelStats() {_uniqueStorage()._labelStats = nil}

  /// Output only. Time the AnnotatedDataset was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Additional information about AnnotatedDataset.
  public var metadata: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata {
    get {return _storage._metadata ?? Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  /// Output only. The names of any related resources that are blocking changes
  /// to the annotated dataset.
  public var blockingResources: [String] {
    get {return _storage._blockingResources}
    set {_uniqueStorage()._blockingResources = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Statistics about annotation specs.
public struct Google_Cloud_Datalabeling_V1beta1_LabelStats {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Map of each annotation spec's example count. Key is the annotation spec
  /// name and value is the number of examples for that annotation spec.
  /// If the annotated dataset does not have annotation spec, the map will return
  /// a pair where the key is empty string and value is the total number of
  /// annotations.
  public var exampleCount: Dictionary<String,Int64> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata on AnnotatedDataset.
public struct Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specific request configuration used when requesting the labeling task.
  public var annotationRequestConfig: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata.OneOf_AnnotationRequestConfig? = nil

  /// Configuration for image classification task.
  public var imageClassificationConfig: Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig {
    get {
      if case .imageClassificationConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig()
    }
    set {annotationRequestConfig = .imageClassificationConfig(newValue)}
  }

  /// Configuration for image bounding box and bounding poly task.
  public var boundingPolyConfig: Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig {
    get {
      if case .boundingPolyConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig()
    }
    set {annotationRequestConfig = .boundingPolyConfig(newValue)}
  }

  /// Configuration for image polyline task.
  public var polylineConfig: Google_Cloud_Datalabeling_V1beta1_PolylineConfig {
    get {
      if case .polylineConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_PolylineConfig()
    }
    set {annotationRequestConfig = .polylineConfig(newValue)}
  }

  /// Configuration for image segmentation task.
  public var segmentationConfig: Google_Cloud_Datalabeling_V1beta1_SegmentationConfig {
    get {
      if case .segmentationConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_SegmentationConfig()
    }
    set {annotationRequestConfig = .segmentationConfig(newValue)}
  }

  /// Configuration for video classification task.
  public var videoClassificationConfig: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig {
    get {
      if case .videoClassificationConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig()
    }
    set {annotationRequestConfig = .videoClassificationConfig(newValue)}
  }

  /// Configuration for video object detection task.
  public var objectDetectionConfig: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig {
    get {
      if case .objectDetectionConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig()
    }
    set {annotationRequestConfig = .objectDetectionConfig(newValue)}
  }

  /// Configuration for video object tracking task.
  public var objectTrackingConfig: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig {
    get {
      if case .objectTrackingConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig()
    }
    set {annotationRequestConfig = .objectTrackingConfig(newValue)}
  }

  /// Configuration for video event labeling task.
  public var eventConfig: Google_Cloud_Datalabeling_V1beta1_EventConfig {
    get {
      if case .eventConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_EventConfig()
    }
    set {annotationRequestConfig = .eventConfig(newValue)}
  }

  /// Configuration for text classification task.
  public var textClassificationConfig: Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig {
    get {
      if case .textClassificationConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig()
    }
    set {annotationRequestConfig = .textClassificationConfig(newValue)}
  }

  /// Configuration for text entity extraction task.
  public var textEntityExtractionConfig: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig {
    get {
      if case .textEntityExtractionConfig(let v)? = annotationRequestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig()
    }
    set {annotationRequestConfig = .textEntityExtractionConfig(newValue)}
  }

  /// HumanAnnotationConfig used when requesting the human labeling task for this
  /// AnnotatedDataset.
  public var humanAnnotationConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig {
    get {return _humanAnnotationConfig ?? Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig()}
    set {_humanAnnotationConfig = newValue}
  }
  /// Returns true if `humanAnnotationConfig` has been explicitly set.
  public var hasHumanAnnotationConfig: Bool {return self._humanAnnotationConfig != nil}
  /// Clears the value of `humanAnnotationConfig`. Subsequent reads from it will return its default value.
  public mutating func clearHumanAnnotationConfig() {self._humanAnnotationConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specific request configuration used when requesting the labeling task.
  public enum OneOf_AnnotationRequestConfig: Equatable {
    /// Configuration for image classification task.
    case imageClassificationConfig(Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig)
    /// Configuration for image bounding box and bounding poly task.
    case boundingPolyConfig(Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig)
    /// Configuration for image polyline task.
    case polylineConfig(Google_Cloud_Datalabeling_V1beta1_PolylineConfig)
    /// Configuration for image segmentation task.
    case segmentationConfig(Google_Cloud_Datalabeling_V1beta1_SegmentationConfig)
    /// Configuration for video classification task.
    case videoClassificationConfig(Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig)
    /// Configuration for video object detection task.
    case objectDetectionConfig(Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig)
    /// Configuration for video object tracking task.
    case objectTrackingConfig(Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig)
    /// Configuration for video event labeling task.
    case eventConfig(Google_Cloud_Datalabeling_V1beta1_EventConfig)
    /// Configuration for text classification task.
    case textClassificationConfig(Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig)
    /// Configuration for text entity extraction task.
    case textEntityExtractionConfig(Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata.OneOf_AnnotationRequestConfig, rhs: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata.OneOf_AnnotationRequestConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.imageClassificationConfig, .imageClassificationConfig): return {
        guard case .imageClassificationConfig(let l) = lhs, case .imageClassificationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boundingPolyConfig, .boundingPolyConfig): return {
        guard case .boundingPolyConfig(let l) = lhs, case .boundingPolyConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.polylineConfig, .polylineConfig): return {
        guard case .polylineConfig(let l) = lhs, case .polylineConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.segmentationConfig, .segmentationConfig): return {
        guard case .segmentationConfig(let l) = lhs, case .segmentationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoClassificationConfig, .videoClassificationConfig): return {
        guard case .videoClassificationConfig(let l) = lhs, case .videoClassificationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectDetectionConfig, .objectDetectionConfig): return {
        guard case .objectDetectionConfig(let l) = lhs, case .objectDetectionConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectTrackingConfig, .objectTrackingConfig): return {
        guard case .objectTrackingConfig(let l) = lhs, case .objectTrackingConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eventConfig, .eventConfig): return {
        guard case .eventConfig(let l) = lhs, case .eventConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textClassificationConfig, .textClassificationConfig): return {
        guard case .textClassificationConfig(let l) = lhs, case .textClassificationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textEntityExtractionConfig, .textEntityExtractionConfig): return {
        guard case .textEntityExtractionConfig(let l) = lhs, case .textEntityExtractionConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _humanAnnotationConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig? = nil
}

/// An Example is a piece of data and its annotation. For example, an image with
/// label "house".
public struct Google_Cloud_Datalabeling_V1beta1_Example {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The data part of Example.
  public var payload: Google_Cloud_Datalabeling_V1beta1_Example.OneOf_Payload? = nil

  /// The image payload, a container of the image bytes/uri.
  public var imagePayload: Google_Cloud_Datalabeling_V1beta1_ImagePayload {
    get {
      if case .imagePayload(let v)? = payload {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImagePayload()
    }
    set {payload = .imagePayload(newValue)}
  }

  /// The text payload, a container of the text content.
  public var textPayload: Google_Cloud_Datalabeling_V1beta1_TextPayload {
    get {
      if case .textPayload(let v)? = payload {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextPayload()
    }
    set {payload = .textPayload(newValue)}
  }

  /// The video payload, a container of the video uri.
  public var videoPayload: Google_Cloud_Datalabeling_V1beta1_VideoPayload {
    get {
      if case .videoPayload(let v)? = payload {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoPayload()
    }
    set {payload = .videoPayload(newValue)}
  }

  /// Output only. Name of the example, in format of:
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
  /// {annotated_dataset_id}/examples/{example_id}
  public var name: String = String()

  /// Output only. Annotations for the piece of data in Example.
  /// One piece of data can have multiple annotations.
  public var annotations: [Google_Cloud_Datalabeling_V1beta1_Annotation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Output only. The data part of Example.
  public enum OneOf_Payload: Equatable {
    /// The image payload, a container of the image bytes/uri.
    case imagePayload(Google_Cloud_Datalabeling_V1beta1_ImagePayload)
    /// The text payload, a container of the text content.
    case textPayload(Google_Cloud_Datalabeling_V1beta1_TextPayload)
    /// The video payload, a container of the video uri.
    case videoPayload(Google_Cloud_Datalabeling_V1beta1_VideoPayload)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Example.OneOf_Payload, rhs: Google_Cloud_Datalabeling_V1beta1_Example.OneOf_Payload) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.imagePayload, .imagePayload): return {
        guard case .imagePayload(let l) = lhs, case .imagePayload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textPayload, .textPayload): return {
        guard case .textPayload(let l) = lhs, case .textPayload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoPayload, .videoPayload): return {
        guard case .videoPayload(let l) = lhs, case .videoPayload(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datalabeling.v1beta1"

extension Google_Cloud_Datalabeling_V1beta1_DataType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATA_TYPE_UNSPECIFIED"),
    1: .same(proto: "IMAGE"),
    2: .same(proto: "VIDEO"),
    4: .same(proto: "TEXT"),
    6: .same(proto: "GENERAL_DATA"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_Dataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dataset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "input_configs"),
    6: .standard(proto: "blocking_resources"),
    7: .standard(proto: "data_item_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.inputConfigs) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.blockingResources) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.dataItemCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.inputConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputConfigs, fieldNumber: 5)
    }
    if !self.blockingResources.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockingResources, fieldNumber: 6)
    }
    if self.dataItemCount != 0 {
      try visitor.visitSingularInt64Field(value: self.dataItemCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Dataset, rhs: Google_Cloud_Datalabeling_V1beta1_Dataset) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.inputConfigs != rhs.inputConfigs {return false}
    if lhs.blockingResources != rhs.blockingResources {return false}
    if lhs.dataItemCount != rhs.dataItemCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_InputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "text_metadata"),
    2: .standard(proto: "gcs_source"),
    5: .standard(proto: "bigquery_source"),
    1: .standard(proto: "data_type"),
    3: .standard(proto: "annotation_type"),
    4: .standard(proto: "classification_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dataType) }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_GcsSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .gcsSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .gcsSource(v)}
      }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.annotationType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._classificationMetadata) }()
      case 5: try {
        var v: Google_Cloud_Datalabeling_V1beta1_BigQuerySource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .bigquerySource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .bigquerySource(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextMetadata?
        if let current = self.dataTypeMetadata {
          try decoder.handleConflictingOneOf()
          if case .textMetadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataTypeMetadata = .textMetadata(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dataType != .unspecified {
      try visitor.visitSingularEnumField(value: self.dataType, fieldNumber: 1)
    }
    if case .gcsSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.annotationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.annotationType, fieldNumber: 3)
    }
    if let v = self._classificationMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if case .bigquerySource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if case .textMetadata(let v)? = self.dataTypeMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_InputConfig, rhs: Google_Cloud_Datalabeling_V1beta1_InputConfig) -> Bool {
    if lhs.dataTypeMetadata != rhs.dataTypeMetadata {return false}
    if lhs.source != rhs.source {return false}
    if lhs.dataType != rhs.dataType {return false}
    if lhs.annotationType != rhs.annotationType {return false}
    if lhs._classificationMetadata != rhs._classificationMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_TextMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "language_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_TextMetadata, rhs: Google_Cloud_Datalabeling_V1beta1_TextMetadata) -> Bool {
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassificationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_multi_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isMultiLabel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMultiLabel != false {
      try visitor.visitSingularBoolField(value: self.isMultiLabel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata, rhs: Google_Cloud_Datalabeling_V1beta1_ClassificationMetadata) -> Bool {
    if lhs.isMultiLabel != rhs.isMultiLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GcsSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_uri"),
    2: .standard(proto: "mime_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inputUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputUri.isEmpty {
      try visitor.visitSingularStringField(value: self.inputUri, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GcsSource, rhs: Google_Cloud_Datalabeling_V1beta1_GcsSource) -> Bool {
    if lhs.inputUri != rhs.inputUri {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_BigQuerySource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQuerySource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "input_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.inputUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputUri.isEmpty {
      try visitor.visitSingularStringField(value: self.inputUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_BigQuerySource, rhs: Google_Cloud_Datalabeling_V1beta1_BigQuerySource) -> Bool {
    if lhs.inputUri != rhs.inputUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
    2: .standard(proto: "gcs_folder_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Datalabeling_V1beta1_GcsDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .gcsDestination(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .gcsFolderDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .gcsFolderDestination(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.destination {
    case .gcsDestination?: try {
      guard case .gcsDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gcsFolderDestination?: try {
      guard case .gcsFolderDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_OutputConfig, rhs: Google_Cloud_Datalabeling_V1beta1_OutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GcsDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_uri"),
    2: .standard(proto: "mime_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputUri.isEmpty {
      try visitor.visitSingularStringField(value: self.outputUri, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GcsDestination, rhs: Google_Cloud_Datalabeling_V1beta1_GcsDestination) -> Bool {
    if lhs.outputUri != rhs.outputUri {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsFolderDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "output_folder_uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outputFolderUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputFolderUri.isEmpty {
      try visitor.visitSingularStringField(value: self.outputFolderUri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination, rhs: Google_Cloud_Datalabeling_V1beta1_GcsFolderDestination) -> Bool {
    if lhs.outputFolderUri != rhs.outputFolderUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_DataItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DataItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "image_payload"),
    3: .standard(proto: "text_payload"),
    4: .standard(proto: "video_payload"),
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImagePayload?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .imagePayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .imagePayload(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextPayload?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .textPayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .textPayload(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoPayload?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .videoPayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .videoPayload(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .imagePayload?: try {
      guard case .imagePayload(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .textPayload?: try {
      guard case .textPayload(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .videoPayload?: try {
      guard case .videoPayload(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DataItem, rhs: Google_Cloud_Datalabeling_V1beta1_DataItem) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_AnnotatedDataset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotatedDataset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    9: .same(proto: "description"),
    3: .standard(proto: "annotation_source"),
    8: .standard(proto: "annotation_type"),
    4: .standard(proto: "example_count"),
    5: .standard(proto: "completed_example_count"),
    6: .standard(proto: "label_stats"),
    7: .standard(proto: "create_time"),
    10: .same(proto: "metadata"),
    11: .standard(proto: "blocking_resources"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _description_p: String = String()
    var _annotationSource: Google_Cloud_Datalabeling_V1beta1_AnnotationSource = .unspecified
    var _annotationType: Google_Cloud_Datalabeling_V1beta1_AnnotationType = .unspecified
    var _exampleCount: Int64 = 0
    var _completedExampleCount: Int64 = 0
    var _labelStats: Google_Cloud_Datalabeling_V1beta1_LabelStats? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _metadata: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata? = nil
    var _blockingResources: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _description_p = source._description_p
      _annotationSource = source._annotationSource
      _annotationType = source._annotationType
      _exampleCount = source._exampleCount
      _completedExampleCount = source._completedExampleCount
      _labelStats = source._labelStats
      _createTime = source._createTime
      _metadata = source._metadata
      _blockingResources = source._blockingResources
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._annotationSource) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._exampleCount) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._completedExampleCount) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._labelStats) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._annotationType) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._blockingResources) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if _storage._annotationSource != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._annotationSource, fieldNumber: 3)
      }
      if _storage._exampleCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exampleCount, fieldNumber: 4)
      }
      if _storage._completedExampleCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._completedExampleCount, fieldNumber: 5)
      }
      if let v = _storage._labelStats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if _storage._annotationType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._annotationType, fieldNumber: 8)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 9)
      }
      if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._blockingResources.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._blockingResources, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_AnnotatedDataset, rhs: Google_Cloud_Datalabeling_V1beta1_AnnotatedDataset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._annotationSource != rhs_storage._annotationSource {return false}
        if _storage._annotationType != rhs_storage._annotationType {return false}
        if _storage._exampleCount != rhs_storage._exampleCount {return false}
        if _storage._completedExampleCount != rhs_storage._completedExampleCount {return false}
        if _storage._labelStats != rhs_storage._labelStats {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._blockingResources != rhs_storage._blockingResources {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_LabelStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelStats"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "example_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &self.exampleCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exampleCount.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: self.exampleCount, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelStats, rhs: Google_Cloud_Datalabeling_V1beta1_LabelStats) -> Bool {
    if lhs.exampleCount != rhs.exampleCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotatedDatasetMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "image_classification_config"),
    3: .standard(proto: "bounding_poly_config"),
    4: .standard(proto: "polyline_config"),
    5: .standard(proto: "segmentation_config"),
    6: .standard(proto: "video_classification_config"),
    7: .standard(proto: "object_detection_config"),
    8: .standard(proto: "object_tracking_config"),
    9: .standard(proto: "event_config"),
    10: .standard(proto: "text_classification_config"),
    11: .standard(proto: "text_entity_extraction_config"),
    1: .standard(proto: "human_annotation_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._humanAnnotationConfig) }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .imageClassificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .imageClassificationConfig(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .boundingPolyConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .boundingPolyConfig(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Datalabeling_V1beta1_PolylineConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .polylineConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .polylineConfig(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Datalabeling_V1beta1_SegmentationConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .segmentationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .segmentationConfig(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .videoClassificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .videoClassificationConfig(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .objectDetectionConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .objectDetectionConfig(v)}
      }()
      case 8: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .objectTrackingConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .objectTrackingConfig(v)}
      }()
      case 9: try {
        var v: Google_Cloud_Datalabeling_V1beta1_EventConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .eventConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .eventConfig(v)}
      }()
      case 10: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .textClassificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .textClassificationConfig(v)}
      }()
      case 11: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig?
        if let current = self.annotationRequestConfig {
          try decoder.handleConflictingOneOf()
          if case .textEntityExtractionConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.annotationRequestConfig = .textEntityExtractionConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._humanAnnotationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.annotationRequestConfig {
    case .imageClassificationConfig?: try {
      guard case .imageClassificationConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .boundingPolyConfig?: try {
      guard case .boundingPolyConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .polylineConfig?: try {
      guard case .polylineConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .segmentationConfig?: try {
      guard case .segmentationConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .videoClassificationConfig?: try {
      guard case .videoClassificationConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .objectDetectionConfig?: try {
      guard case .objectDetectionConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .objectTrackingConfig?: try {
      guard case .objectTrackingConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .eventConfig?: try {
      guard case .eventConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .textClassificationConfig?: try {
      guard case .textClassificationConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .textEntityExtractionConfig?: try {
      guard case .textEntityExtractionConfig(let v)? = self.annotationRequestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata, rhs: Google_Cloud_Datalabeling_V1beta1_AnnotatedDatasetMetadata) -> Bool {
    if lhs.annotationRequestConfig != rhs.annotationRequestConfig {return false}
    if lhs._humanAnnotationConfig != rhs._humanAnnotationConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_Example: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Example"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "image_payload"),
    6: .standard(proto: "text_payload"),
    7: .standard(proto: "video_payload"),
    1: .same(proto: "name"),
    5: .same(proto: "annotations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImagePayload?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .imagePayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .imagePayload(v)}
      }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.annotations) }()
      case 6: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextPayload?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .textPayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .textPayload(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoPayload?
        if let current = self.payload {
          try decoder.handleConflictingOneOf()
          if case .videoPayload(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.payload = .videoPayload(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .imagePayload(let v)? = self.payload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.annotations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotations, fieldNumber: 5)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.payload {
    case .textPayload?: try {
      guard case .textPayload(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .videoPayload?: try {
      guard case .videoPayload(let v)? = self.payload else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Example, rhs: Google_Cloud_Datalabeling_V1beta1_Example) -> Bool {
    if lhs.payload != rhs.payload {return false}
    if lhs.name != rhs.name {return false}
    if lhs.annotations != rhs.annotations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

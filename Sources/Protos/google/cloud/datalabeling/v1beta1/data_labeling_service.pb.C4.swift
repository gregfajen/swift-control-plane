// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datalabeling/v1beta1/data_labeling_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for CreateDataset.
public struct Google_Cloud_Datalabeling_V1beta1_CreateDatasetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Dataset resource parent, format:
  /// projects/{project_id}
  public var parent: String = String()

  /// Required. The dataset to be created.
  public var dataset: Google_Cloud_Datalabeling_V1beta1_Dataset {
    get {return _dataset ?? Google_Cloud_Datalabeling_V1beta1_Dataset()}
    set {_dataset = newValue}
  }
  /// Returns true if `dataset` has been explicitly set.
  public var hasDataset: Bool {return self._dataset != nil}
  /// Clears the value of `dataset`. Subsequent reads from it will return its default value.
  public mutating func clearDataset() {self._dataset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dataset: Google_Cloud_Datalabeling_V1beta1_Dataset? = nil
}

/// Request message for GetDataSet.
public struct Google_Cloud_Datalabeling_V1beta1_GetDatasetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Dataset resource name, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListDataset.
public struct Google_Cloud_Datalabeling_V1beta1_ListDatasetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Dataset resource parent, format:
  /// projects/{project_id}
  public var parent: String = String()

  /// Optional. Filter on dataset is not supported at this moment.
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by
  /// [ListDatasetsResponse.next_page_token][google.cloud.datalabeling.v1beta1.ListDatasetsResponse.next_page_token] of the previous
  /// [DataLabelingService.ListDatasets] call.
  /// Returns the first page if empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of listing datasets within a project.
public struct Google_Cloud_Datalabeling_V1beta1_ListDatasetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of datasets to return.
  public var datasets: [Google_Cloud_Datalabeling_V1beta1_Dataset] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteDataset.
public struct Google_Cloud_Datalabeling_V1beta1_DeleteDatasetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Dataset resource name, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ImportData API.
public struct Google_Cloud_Datalabeling_V1beta1_ImportDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Dataset resource name, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var name: String = String()

  /// Required. Specify the input source of the data.
  public var inputConfig: Google_Cloud_Datalabeling_V1beta1_InputConfig {
    get {return _inputConfig ?? Google_Cloud_Datalabeling_V1beta1_InputConfig()}
    set {_inputConfig = newValue}
  }
  /// Returns true if `inputConfig` has been explicitly set.
  public var hasInputConfig: Bool {return self._inputConfig != nil}
  /// Clears the value of `inputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearInputConfig() {self._inputConfig = nil}

  /// Email of the user who started the import task and should be notified by
  /// email. If empty no notification will be sent.
  public var userEmailAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputConfig: Google_Cloud_Datalabeling_V1beta1_InputConfig? = nil
}

/// Request message for ExportData API.
public struct Google_Cloud_Datalabeling_V1beta1_ExportDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Dataset resource name, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var name: String = String()

  /// Required. Annotated dataset resource name. DataItem in
  /// Dataset and their annotations in specified annotated dataset will be
  /// exported. It's in format of
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
  /// {annotated_dataset_id}
  public var annotatedDataset: String = String()

  /// Optional. Filter is not supported at this moment.
  public var filter: String = String()

  /// Required. Specify the output destination.
  public var outputConfig: Google_Cloud_Datalabeling_V1beta1_OutputConfig {
    get {return _outputConfig ?? Google_Cloud_Datalabeling_V1beta1_OutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {self._outputConfig = nil}

  /// Email of the user who started the export task and should be notified by
  /// email. If empty no notification will be sent.
  public var userEmailAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outputConfig: Google_Cloud_Datalabeling_V1beta1_OutputConfig? = nil
}

/// Request message for GetDataItem.
public struct Google_Cloud_Datalabeling_V1beta1_GetDataItemRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the data item to get, format:
  /// projects/{project_id}/datasets/{dataset_id}/dataItems/{data_item_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListDataItems.
public struct Google_Cloud_Datalabeling_V1beta1_ListDataItemsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the dataset to list data items, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var parent: String = String()

  /// Optional. Filter is not supported at this moment.
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by
  /// [ListDataItemsResponse.next_page_token][google.cloud.datalabeling.v1beta1.ListDataItemsResponse.next_page_token] of the previous
  /// [DataLabelingService.ListDataItems] call.
  /// Return first page if empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of listing data items in a dataset.
public struct Google_Cloud_Datalabeling_V1beta1_ListDataItemsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of data items to return.
  public var dataItems: [Google_Cloud_Datalabeling_V1beta1_DataItem] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GetAnnotatedDataset.
public struct Google_Cloud_Datalabeling_V1beta1_GetAnnotatedDatasetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the annotated dataset to get, format:
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
  /// {annotated_dataset_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListAnnotatedDatasets.
public struct Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the dataset to list annotated datasets, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var parent: String = String()

  /// Optional. Filter is not supported at this moment.
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by
  /// [ListAnnotatedDatasetsResponse.next_page_token][google.cloud.datalabeling.v1beta1.ListAnnotatedDatasetsResponse.next_page_token] of the previous
  /// [DataLabelingService.ListAnnotatedDatasets] call.
  /// Return first page if empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of listing annotated datasets for a dataset.
public struct Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of annotated datasets to return.
  public var annotatedDatasets: [Google_Cloud_Datalabeling_V1beta1_AnnotatedDataset] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteAnnotatedDataset.
public struct Google_Cloud_Datalabeling_V1beta1_DeleteAnnotatedDatasetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the annotated dataset to delete, format:
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
  /// {annotated_dataset_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for starting an image labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_LabelImageRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Config for labeling tasks. The type of request config must
  /// match the selected feature.
  public var requestConfig: Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.OneOf_RequestConfig? = nil

  /// Configuration for image classification task.
  /// One of image_classification_config, bounding_poly_config,
  /// polyline_config and segmentation_config are required.
  public var imageClassificationConfig: Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig {
    get {
      if case .imageClassificationConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig()
    }
    set {requestConfig = .imageClassificationConfig(newValue)}
  }

  /// Configuration for bounding box and bounding poly task.
  /// One of image_classification_config, bounding_poly_config,
  /// polyline_config and segmentation_config are required.
  public var boundingPolyConfig: Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig {
    get {
      if case .boundingPolyConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig()
    }
    set {requestConfig = .boundingPolyConfig(newValue)}
  }

  /// Configuration for polyline task.
  /// One of image_classification_config, bounding_poly_config,
  /// polyline_config and segmentation_config are required.
  public var polylineConfig: Google_Cloud_Datalabeling_V1beta1_PolylineConfig {
    get {
      if case .polylineConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_PolylineConfig()
    }
    set {requestConfig = .polylineConfig(newValue)}
  }

  /// Configuration for segmentation task.
  /// One of image_classification_config, bounding_poly_config,
  /// polyline_config and segmentation_config are required.
  public var segmentationConfig: Google_Cloud_Datalabeling_V1beta1_SegmentationConfig {
    get {
      if case .segmentationConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_SegmentationConfig()
    }
    set {requestConfig = .segmentationConfig(newValue)}
  }

  /// Required. Name of the dataset to request labeling task, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var parent: String = String()

  /// Required. Basic human annotation config.
  public var basicConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig {
    get {return _basicConfig ?? Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig()}
    set {_basicConfig = newValue}
  }
  /// Returns true if `basicConfig` has been explicitly set.
  public var hasBasicConfig: Bool {return self._basicConfig != nil}
  /// Clears the value of `basicConfig`. Subsequent reads from it will return its default value.
  public mutating func clearBasicConfig() {self._basicConfig = nil}

  /// Required. The type of image labeling task.
  public var feature: Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.Feature = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Config for labeling tasks. The type of request config must
  /// match the selected feature.
  public enum OneOf_RequestConfig: Equatable {
    /// Configuration for image classification task.
    /// One of image_classification_config, bounding_poly_config,
    /// polyline_config and segmentation_config are required.
    case imageClassificationConfig(Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig)
    /// Configuration for bounding box and bounding poly task.
    /// One of image_classification_config, bounding_poly_config,
    /// polyline_config and segmentation_config are required.
    case boundingPolyConfig(Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig)
    /// Configuration for polyline task.
    /// One of image_classification_config, bounding_poly_config,
    /// polyline_config and segmentation_config are required.
    case polylineConfig(Google_Cloud_Datalabeling_V1beta1_PolylineConfig)
    /// Configuration for segmentation task.
    /// One of image_classification_config, bounding_poly_config,
    /// polyline_config and segmentation_config are required.
    case segmentationConfig(Google_Cloud_Datalabeling_V1beta1_SegmentationConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.OneOf_RequestConfig, rhs: Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.OneOf_RequestConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.imageClassificationConfig, .imageClassificationConfig): return {
        guard case .imageClassificationConfig(let l) = lhs, case .imageClassificationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boundingPolyConfig, .boundingPolyConfig): return {
        guard case .boundingPolyConfig(let l) = lhs, case .boundingPolyConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.polylineConfig, .polylineConfig): return {
        guard case .polylineConfig(let l) = lhs, case .polylineConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.segmentationConfig, .segmentationConfig): return {
        guard case .segmentationConfig(let l) = lhs, case .segmentationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Image labeling task feature.
  public enum Feature: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Label whole image with one or more of labels.
    case classification // = 1

    /// Label image with bounding boxes for labels.
    case boundingBox // = 2

    /// Label oriented bounding box. The box does not have to be parallel to
    /// horizontal line.
    case orientedBoundingBox // = 6

    /// Label images with bounding poly. A bounding poly is a plane figure that
    /// is bounded by a finite chain of straight line segments closing in a loop.
    case boundingPoly // = 3

    /// Label images with polyline. Polyline is formed by connected line segments
    /// which are not in closed form.
    case polyline // = 4

    /// Label images with segmentation. Segmentation is different from bounding
    /// poly since it is more fine-grained, pixel level annotation.
    case segmentation // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .classification
      case 2: self = .boundingBox
      case 3: self = .boundingPoly
      case 4: self = .polyline
      case 5: self = .segmentation
      case 6: self = .orientedBoundingBox
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .classification: return 1
      case .boundingBox: return 2
      case .boundingPoly: return 3
      case .polyline: return 4
      case .segmentation: return 5
      case .orientedBoundingBox: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _basicConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.Feature: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.Feature] = [
    .unspecified,
    .classification,
    .boundingBox,
    .orientedBoundingBox,
    .boundingPoly,
    .polyline,
    .segmentation,
  ]
}

#endif  // swift(>=4.2)

/// Request message for LabelVideo.
public struct Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Config for labeling tasks. The type of request config must
  /// match the selected feature.
  public var requestConfig: Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.OneOf_RequestConfig? = nil

  /// Configuration for video classification task.
  /// One of video_classification_config, object_detection_config,
  /// object_tracking_config and event_config is required.
  public var videoClassificationConfig: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig {
    get {
      if case .videoClassificationConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig()
    }
    set {requestConfig = .videoClassificationConfig(newValue)}
  }

  /// Configuration for video object detection task.
  /// One of video_classification_config, object_detection_config,
  /// object_tracking_config and event_config is required.
  public var objectDetectionConfig: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig {
    get {
      if case .objectDetectionConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig()
    }
    set {requestConfig = .objectDetectionConfig(newValue)}
  }

  /// Configuration for video object tracking task.
  /// One of video_classification_config, object_detection_config,
  /// object_tracking_config and event_config is required.
  public var objectTrackingConfig: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig {
    get {
      if case .objectTrackingConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig()
    }
    set {requestConfig = .objectTrackingConfig(newValue)}
  }

  /// Configuration for video event task.
  /// One of video_classification_config, object_detection_config,
  /// object_tracking_config and event_config is required.
  public var eventConfig: Google_Cloud_Datalabeling_V1beta1_EventConfig {
    get {
      if case .eventConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_EventConfig()
    }
    set {requestConfig = .eventConfig(newValue)}
  }

  /// Required. Name of the dataset to request labeling task, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var parent: String = String()

  /// Required. Basic human annotation config.
  public var basicConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig {
    get {return _basicConfig ?? Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig()}
    set {_basicConfig = newValue}
  }
  /// Returns true if `basicConfig` has been explicitly set.
  public var hasBasicConfig: Bool {return self._basicConfig != nil}
  /// Clears the value of `basicConfig`. Subsequent reads from it will return its default value.
  public mutating func clearBasicConfig() {self._basicConfig = nil}

  /// Required. The type of video labeling task.
  public var feature: Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.Feature = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Config for labeling tasks. The type of request config must
  /// match the selected feature.
  public enum OneOf_RequestConfig: Equatable {
    /// Configuration for video classification task.
    /// One of video_classification_config, object_detection_config,
    /// object_tracking_config and event_config is required.
    case videoClassificationConfig(Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig)
    /// Configuration for video object detection task.
    /// One of video_classification_config, object_detection_config,
    /// object_tracking_config and event_config is required.
    case objectDetectionConfig(Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig)
    /// Configuration for video object tracking task.
    /// One of video_classification_config, object_detection_config,
    /// object_tracking_config and event_config is required.
    case objectTrackingConfig(Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig)
    /// Configuration for video event task.
    /// One of video_classification_config, object_detection_config,
    /// object_tracking_config and event_config is required.
    case eventConfig(Google_Cloud_Datalabeling_V1beta1_EventConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.OneOf_RequestConfig, rhs: Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.OneOf_RequestConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.videoClassificationConfig, .videoClassificationConfig): return {
        guard case .videoClassificationConfig(let l) = lhs, case .videoClassificationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectDetectionConfig, .objectDetectionConfig): return {
        guard case .objectDetectionConfig(let l) = lhs, case .objectDetectionConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectTrackingConfig, .objectTrackingConfig): return {
        guard case .objectTrackingConfig(let l) = lhs, case .objectTrackingConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.eventConfig, .eventConfig): return {
        guard case .eventConfig(let l) = lhs, case .eventConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Video labeling task feature.
  public enum Feature: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Label whole video or video segment with one or more labels.
    case classification // = 1

    /// Label objects with bounding box on image frames extracted from the video.
    case objectDetection // = 2

    /// Label and track objects in video.
    case objectTracking // = 3

    /// Label the range of video for the specified events.
    case event // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .classification
      case 2: self = .objectDetection
      case 3: self = .objectTracking
      case 4: self = .event
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .classification: return 1
      case .objectDetection: return 2
      case .objectTracking: return 3
      case .event: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _basicConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.Feature: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.Feature] = [
    .unspecified,
    .classification,
    .objectDetection,
    .objectTracking,
    .event,
  ]
}

#endif  // swift(>=4.2)

/// Request message for LabelText.
public struct Google_Cloud_Datalabeling_V1beta1_LabelTextRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Config for labeling tasks. The type of request config must
  /// match the selected feature.
  public var requestConfig: Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.OneOf_RequestConfig? = nil

  /// Configuration for text classification task.
  /// One of text_classification_config and text_entity_extraction_config
  /// is required.
  public var textClassificationConfig: Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig {
    get {
      if case .textClassificationConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig()
    }
    set {requestConfig = .textClassificationConfig(newValue)}
  }

  /// Configuration for entity extraction task.
  /// One of text_classification_config and text_entity_extraction_config
  /// is required.
  public var textEntityExtractionConfig: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig {
    get {
      if case .textEntityExtractionConfig(let v)? = requestConfig {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig()
    }
    set {requestConfig = .textEntityExtractionConfig(newValue)}
  }

  /// Required. Name of the data set to request labeling task, format:
  /// projects/{project_id}/datasets/{dataset_id}
  public var parent: String = String()

  /// Required. Basic human annotation config.
  public var basicConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig {
    get {return _basicConfig ?? Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig()}
    set {_basicConfig = newValue}
  }
  /// Returns true if `basicConfig` has been explicitly set.
  public var hasBasicConfig: Bool {return self._basicConfig != nil}
  /// Clears the value of `basicConfig`. Subsequent reads from it will return its default value.
  public mutating func clearBasicConfig() {self._basicConfig = nil}

  /// Required. The type of text labeling task.
  public var feature: Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.Feature = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Config for labeling tasks. The type of request config must
  /// match the selected feature.
  public enum OneOf_RequestConfig: Equatable {
    /// Configuration for text classification task.
    /// One of text_classification_config and text_entity_extraction_config
    /// is required.
    case textClassificationConfig(Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig)
    /// Configuration for entity extraction task.
    /// One of text_classification_config and text_entity_extraction_config
    /// is required.
    case textEntityExtractionConfig(Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.OneOf_RequestConfig, rhs: Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.OneOf_RequestConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.textClassificationConfig, .textClassificationConfig): return {
        guard case .textClassificationConfig(let l) = lhs, case .textClassificationConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textEntityExtractionConfig, .textEntityExtractionConfig): return {
        guard case .textEntityExtractionConfig(let l) = lhs, case .textEntityExtractionConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Text labeling task feature.
  public enum Feature: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Label text content to one of more labels.
    case textClassification // = 1

    /// Label entities and their span in text.
    case textEntityExtraction // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .textClassification
      case 2: self = .textEntityExtraction
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .textClassification: return 1
      case .textEntityExtraction: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _basicConfig: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.Feature: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.Feature] = [
    .unspecified,
    .textClassification,
    .textEntityExtraction,
  ]
}

#endif  // swift(>=4.2)

/// Request message for GetExample
public struct Google_Cloud_Datalabeling_V1beta1_GetExampleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of example, format:
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/
  /// {annotated_dataset_id}/examples/{example_id}
  public var name: String = String()

  /// Optional. An expression for filtering Examples. Filter by
  /// annotation_spec.display_name is supported. Format
  /// "annotation_spec.display_name = {display_name}"
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListExamples.
public struct Google_Cloud_Datalabeling_V1beta1_ListExamplesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Example resource parent.
  public var parent: String = String()

  /// Optional. An expression for filtering Examples. For annotated datasets that
  /// have annotation spec set, filter by
  /// annotation_spec.display_name is supported. Format
  /// "annotation_spec.display_name = {display_name}"
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by
  /// [ListExamplesResponse.next_page_token][google.cloud.datalabeling.v1beta1.ListExamplesResponse.next_page_token] of the previous
  /// [DataLabelingService.ListExamples] call.
  /// Return first page if empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of listing Examples in and annotated dataset.
public struct Google_Cloud_Datalabeling_V1beta1_ListExamplesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of examples to return.
  public var examples: [Google_Cloud_Datalabeling_V1beta1_Example] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateAnnotationSpecSet.
public struct Google_Cloud_Datalabeling_V1beta1_CreateAnnotationSpecSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. AnnotationSpecSet resource parent, format:
  /// projects/{project_id}
  public var parent: String = String()

  /// Required. Annotation spec set to create. Annotation specs must be included.
  /// Only one annotation spec will be accepted for annotation specs with same
  /// display_name.
  public var annotationSpecSet: Google_Cloud_Datalabeling_V1beta1_AnnotationSpecSet {
    get {return _annotationSpecSet ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpecSet()}
    set {_annotationSpecSet = newValue}
  }
  /// Returns true if `annotationSpecSet` has been explicitly set.
  public var hasAnnotationSpecSet: Bool {return self._annotationSpecSet != nil}
  /// Clears the value of `annotationSpecSet`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpecSet() {self._annotationSpecSet = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSpecSet: Google_Cloud_Datalabeling_V1beta1_AnnotationSpecSet? = nil
}

/// Request message for GetAnnotationSpecSet.
public struct Google_Cloud_Datalabeling_V1beta1_GetAnnotationSpecSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. AnnotationSpecSet resource name, format:
  /// projects/{project_id}/annotationSpecSets/{annotation_spec_set_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListAnnotationSpecSets.
public struct Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent of AnnotationSpecSet resource, format:
  /// projects/{project_id}
  public var parent: String = String()

  /// Optional. Filter is not supported at this moment.
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by
  /// [ListAnnotationSpecSetsResponse.next_page_token][google.cloud.datalabeling.v1beta1.ListAnnotationSpecSetsResponse.next_page_token] of the previous
  /// [DataLabelingService.ListAnnotationSpecSets] call.
  /// Return first page if empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of listing annotation spec set under a project.
public struct Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of annotation spec sets.
  public var annotationSpecSets: [Google_Cloud_Datalabeling_V1beta1_AnnotationSpecSet] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteAnnotationSpecSet.
public struct Google_Cloud_Datalabeling_V1beta1_DeleteAnnotationSpecSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. AnnotationSpec resource name, format:
  /// `projects/{project_id}/annotationSpecSets/{annotation_spec_set_id}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateInstruction.
public struct Google_Cloud_Datalabeling_V1beta1_CreateInstructionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Instruction resource parent, format:
  /// projects/{project_id}
  public var parent: String = String()

  /// Required. Instruction of how to perform the labeling task.
  public var instruction: Google_Cloud_Datalabeling_V1beta1_Instruction {
    get {return _instruction ?? Google_Cloud_Datalabeling_V1beta1_Instruction()}
    set {_instruction = newValue}
  }
  /// Returns true if `instruction` has been explicitly set.
  public var hasInstruction: Bool {return self._instruction != nil}
  /// Clears the value of `instruction`. Subsequent reads from it will return its default value.
  public mutating func clearInstruction() {self._instruction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instruction: Google_Cloud_Datalabeling_V1beta1_Instruction? = nil
}

/// Request message for GetInstruction.
public struct Google_Cloud_Datalabeling_V1beta1_GetInstructionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Instruction resource name, format:
  /// projects/{project_id}/instructions/{instruction_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for DeleteInstruction.
public struct Google_Cloud_Datalabeling_V1beta1_DeleteInstructionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Instruction resource name, format:
  /// projects/{project_id}/instructions/{instruction_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListInstructions.
public struct Google_Cloud_Datalabeling_V1beta1_ListInstructionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Instruction resource parent, format:
  /// projects/{project_id}
  public var parent: String = String()

  /// Optional. Filter is not supported at this moment.
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by
  /// [ListInstructionsResponse.next_page_token][google.cloud.datalabeling.v1beta1.ListInstructionsResponse.next_page_token] of the previous
  /// [DataLabelingService.ListInstructions] call.
  /// Return first page if empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of listing instructions under a project.
public struct Google_Cloud_Datalabeling_V1beta1_ListInstructionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of Instructions to return.
  public var instructions: [Google_Cloud_Datalabeling_V1beta1_Instruction] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GetEvaluation.
public struct Google_Cloud_Datalabeling_V1beta1_GetEvaluationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the evaluation. Format:
  ///
  /// "projects/<var>{project_id}</var>/datasets/<var>{dataset_id}</var>/evaluations/<var>{evaluation_id}</var>'
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for SearchEvaluation.
public struct Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Evaluation search parent (project ID). Format:
  /// "projects/<var>{project_id}</var>"
  public var parent: String = String()

  /// Optional. To search evaluations, you can filter by the following:
  ///
  /// * evaluation<span>_</span>job.evaluation_job_id (the last part of
  ///   [EvaluationJob.name][google.cloud.datalabeling.v1beta1.EvaluationJob.name])
  /// * evaluation<span>_</span>job.model_id (the <var>{model_name}</var> portion
  ///   of [EvaluationJob.modelVersion][google.cloud.datalabeling.v1beta1.EvaluationJob.model_version])
  /// * evaluation<span>_</span>job.evaluation_job_run_time_start (Minimum
  ///   threshold for the
  ///   [evaluationJobRunTime][google.cloud.datalabeling.v1beta1.Evaluation.evaluation_job_run_time] that created
  ///   the evaluation)
  /// * evaluation<span>_</span>job.evaluation_job_run_time_end (Maximum
  ///   threshold for the
  ///   [evaluationJobRunTime][google.cloud.datalabeling.v1beta1.Evaluation.evaluation_job_run_time] that created
  ///   the evaluation)
  /// * evaluation<span>_</span>job.job_state ([EvaluationJob.state][google.cloud.datalabeling.v1beta1.EvaluationJob.state])
  /// * annotation<span>_</span>spec.display_name (the Evaluation contains a
  ///   metric for the annotation spec with this
  ///   [displayName][google.cloud.datalabeling.v1beta1.AnnotationSpec.display_name])
  ///
  /// To filter by multiple critiera, use the `AND` operator or the `OR`
  /// operator. The following examples shows a string that filters by several
  /// critiera:
  ///
  /// "evaluation<span>_</span>job.evaluation_job_id =
  /// <var>{evaluation_job_id}</var> AND evaluation<span>_</span>job.model_id =
  /// <var>{model_name}</var> AND
  /// evaluation<span>_</span>job.evaluation_job_run_time_start =
  /// <var>{timestamp_1}</var> AND
  /// evaluation<span>_</span>job.evaluation_job_run_time_end =
  /// <var>{timestamp_2}</var> AND annotation<span>_</span>spec.display_name =
  /// <var>{display_name}</var>"
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by the
  /// [nextPageToken][google.cloud.datalabeling.v1beta1.SearchEvaluationsResponse.next_page_token] of the response
  /// to a previous search request.
  ///
  /// If you don't specify this field, the API call requests the first page of
  /// the search.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of searching evaluations.
public struct Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of evaluations matching the search.
  public var evaluations: [Google_Cloud_Datalabeling_V1beta1_Evaluation] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message of SearchExampleComparisons.
public struct Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the [Evaluation][google.cloud.datalabeling.v1beta1.Evaluation] resource to search for example
  /// comparisons from. Format:
  ///
  /// "projects/<var>{project_id}</var>/datasets/<var>{dataset_id}</var>/evaluations/<var>{evaluation_id}</var>"
  public var parent: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by the
  /// [nextPageToken][SearchExampleComparisons.next_page_token] of the response
  /// to a previous search rquest.
  ///
  /// If you don't specify this field, the API call requests the first page of
  /// the search.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results of searching example comparisons.
public struct Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of example comparisons matching the search criteria.
  public var exampleComparisons: [Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse.ExampleComparison] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Example comparisons comparing ground truth output and predictions for a
  /// specific input.
  public struct ExampleComparison {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ground truth output for the input.
    public var groundTruthExample: Google_Cloud_Datalabeling_V1beta1_Example {
      get {return _groundTruthExample ?? Google_Cloud_Datalabeling_V1beta1_Example()}
      set {_groundTruthExample = newValue}
    }
    /// Returns true if `groundTruthExample` has been explicitly set.
    public var hasGroundTruthExample: Bool {return self._groundTruthExample != nil}
    /// Clears the value of `groundTruthExample`. Subsequent reads from it will return its default value.
    public mutating func clearGroundTruthExample() {self._groundTruthExample = nil}

    /// Predictions by the model for the input.
    public var modelCreatedExamples: [Google_Cloud_Datalabeling_V1beta1_Example] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _groundTruthExample: Google_Cloud_Datalabeling_V1beta1_Example? = nil
  }

  public init() {}
}

/// Request message for CreateEvaluationJob.
public struct Google_Cloud_Datalabeling_V1beta1_CreateEvaluationJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Evaluation job resource parent. Format:
  /// "projects/<var>{project_id}</var>"
  public var parent: String = String()

  /// Required. The evaluation job to create.
  public var job: Google_Cloud_Datalabeling_V1beta1_EvaluationJob {
    get {return _job ?? Google_Cloud_Datalabeling_V1beta1_EvaluationJob()}
    set {_job = newValue}
  }
  /// Returns true if `job` has been explicitly set.
  public var hasJob: Bool {return self._job != nil}
  /// Clears the value of `job`. Subsequent reads from it will return its default value.
  public mutating func clearJob() {self._job = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _job: Google_Cloud_Datalabeling_V1beta1_EvaluationJob? = nil
}

/// Request message for UpdateEvaluationJob.
public struct Google_Cloud_Datalabeling_V1beta1_UpdateEvaluationJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Evaluation job that is going to be updated.
  public var evaluationJob: Google_Cloud_Datalabeling_V1beta1_EvaluationJob {
    get {return _evaluationJob ?? Google_Cloud_Datalabeling_V1beta1_EvaluationJob()}
    set {_evaluationJob = newValue}
  }
  /// Returns true if `evaluationJob` has been explicitly set.
  public var hasEvaluationJob: Bool {return self._evaluationJob != nil}
  /// Clears the value of `evaluationJob`. Subsequent reads from it will return its default value.
  public mutating func clearEvaluationJob() {self._evaluationJob = nil}

  /// Optional. Mask for which fields to update. You can only provide the
  /// following fields:
  ///
  /// * `evaluationJobConfig.humanAnnotationConfig.instruction`
  /// * `evaluationJobConfig.exampleCount`
  /// * `evaluationJobConfig.exampleSamplePercentage`
  ///
  /// You can provide more than one of these fields by separating them with
  /// commas.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _evaluationJob: Google_Cloud_Datalabeling_V1beta1_EvaluationJob? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GetEvaluationJob.
public struct Google_Cloud_Datalabeling_V1beta1_GetEvaluationJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the evaluation job. Format:
  ///
  /// "projects/<var>{project_id}</var>/evaluationJobs/<var>{evaluation_job_id}</var>"
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for PauseEvaluationJob.
public struct Google_Cloud_Datalabeling_V1beta1_PauseEvaluationJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the evaluation job that is going to be paused. Format:
  ///
  /// "projects/<var>{project_id}</var>/evaluationJobs/<var>{evaluation_job_id}</var>"
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message ResumeEvaluationJob.
public struct Google_Cloud_Datalabeling_V1beta1_ResumeEvaluationJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the evaluation job that is going to be resumed. Format:
  ///
  /// "projects/<var>{project_id}</var>/evaluationJobs/<var>{evaluation_job_id}</var>"
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message DeleteEvaluationJob.
public struct Google_Cloud_Datalabeling_V1beta1_DeleteEvaluationJobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the evaluation job that is going to be deleted. Format:
  ///
  /// "projects/<var>{project_id}</var>/evaluationJobs/<var>{evaluation_job_id}</var>"
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListEvaluationJobs.
public struct Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Evaluation job resource parent. Format:
  /// "projects/<var>{project_id}</var>"
  public var parent: String = String()

  /// Optional. You can filter the jobs to list by model_id (also known as
  /// model_name, as described in
  /// [EvaluationJob.modelVersion][google.cloud.datalabeling.v1beta1.EvaluationJob.model_version]) or by
  /// evaluation job state (as described in [EvaluationJob.state][google.cloud.datalabeling.v1beta1.EvaluationJob.state]). To filter
  /// by both criteria, use the `AND` operator or the `OR` operator. For example,
  /// you can use the following string for your filter:
  /// "evaluation<span>_</span>job.model_id = <var>{model_name}</var> AND
  /// evaluation<span>_</span>job.state = <var>{evaluation_job_state}</var>"
  public var filter: String = String()

  /// Optional. Requested page size. Server may return fewer results than
  /// requested. Default value is 100.
  public var pageSize: Int32 = 0

  /// Optional. A token identifying a page of results for the server to return.
  /// Typically obtained by the
  /// [nextPageToken][google.cloud.datalabeling.v1beta1.ListEvaluationJobsResponse.next_page_token] in the response
  /// to the previous request. The request returns the first page if this is
  /// empty.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Results for listing evaluation jobs.
public struct Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of evaluation jobs to return.
  public var evaluationJobs: [Google_Cloud_Datalabeling_V1beta1_EvaluationJob] = []

  /// A token to retrieve next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datalabeling.v1beta1"

extension Google_Cloud_Datalabeling_V1beta1_CreateDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDatasetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "dataset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dataset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._dataset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_CreateDatasetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_CreateDatasetRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._dataset != rhs._dataset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatasetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetDatasetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetDatasetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatasetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListDatasetsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListDatasetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListDatasetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatasetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datasets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.datasets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.datasets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListDatasetsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListDatasetsResponse) -> Bool {
    if lhs.datasets != rhs.datasets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_DeleteDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDatasetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DeleteDatasetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_DeleteDatasetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ImportDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "input_config"),
    3: .standard(proto: "user_email_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inputConfig) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userEmailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._inputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.userEmailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmailAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImportDataRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ImportDataRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._inputConfig != rhs._inputConfig {return false}
    if lhs.userEmailAddress != rhs.userEmailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ExportDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportDataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "annotated_dataset"),
    3: .same(proto: "filter"),
    4: .standard(proto: "output_config"),
    5: .standard(proto: "user_email_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.annotatedDataset) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userEmailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.annotatedDataset.isEmpty {
      try visitor.visitSingularStringField(value: self.annotatedDataset, fieldNumber: 2)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 3)
    }
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.userEmailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmailAddress, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ExportDataRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ExportDataRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.annotatedDataset != rhs.annotatedDataset {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.userEmailAddress != rhs.userEmailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetDataItemRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDataItemRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetDataItemRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetDataItemRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListDataItemsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDataItemsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListDataItemsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListDataItemsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListDataItemsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDataItemsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_items"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.dataItems) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataItems.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dataItems, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListDataItemsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListDataItemsResponse) -> Bool {
    if lhs.dataItems != rhs.dataItems {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetAnnotatedDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotatedDatasetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetAnnotatedDatasetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetAnnotatedDatasetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotatedDatasetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotatedDatasetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotated_datasets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotatedDatasets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotatedDatasets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotatedDatasets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotatedDatasetsResponse) -> Bool {
    if lhs.annotatedDatasets != rhs.annotatedDatasets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_DeleteAnnotatedDatasetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotatedDatasetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DeleteAnnotatedDatasetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_DeleteAnnotatedDatasetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_LabelImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelImageRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "image_classification_config"),
    5: .standard(proto: "bounding_poly_config"),
    6: .standard(proto: "polyline_config"),
    7: .standard(proto: "segmentation_config"),
    1: .same(proto: "parent"),
    2: .standard(proto: "basic_config"),
    3: .same(proto: "feature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._basicConfig) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.feature) }()
      case 4: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .imageClassificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .imageClassificationConfig(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .boundingPolyConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .boundingPolyConfig(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Datalabeling_V1beta1_PolylineConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .polylineConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .polylineConfig(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Datalabeling_V1beta1_SegmentationConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .segmentationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .segmentationConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._basicConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.feature != .unspecified {
      try visitor.visitSingularEnumField(value: self.feature, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requestConfig {
    case .imageClassificationConfig?: try {
      guard case .imageClassificationConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .boundingPolyConfig?: try {
      guard case .boundingPolyConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .polylineConfig?: try {
      guard case .polylineConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .segmentationConfig?: try {
      guard case .segmentationConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelImageRequest, rhs: Google_Cloud_Datalabeling_V1beta1_LabelImageRequest) -> Bool {
    if lhs.requestConfig != rhs.requestConfig {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs._basicConfig != rhs._basicConfig {return false}
    if lhs.feature != rhs.feature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_LabelImageRequest.Feature: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_UNSPECIFIED"),
    1: .same(proto: "CLASSIFICATION"),
    2: .same(proto: "BOUNDING_BOX"),
    3: .same(proto: "BOUNDING_POLY"),
    4: .same(proto: "POLYLINE"),
    5: .same(proto: "SEGMENTATION"),
    6: .same(proto: "ORIENTED_BOUNDING_BOX"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelVideoRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "video_classification_config"),
    5: .standard(proto: "object_detection_config"),
    6: .standard(proto: "object_tracking_config"),
    7: .standard(proto: "event_config"),
    1: .same(proto: "parent"),
    2: .standard(proto: "basic_config"),
    3: .same(proto: "feature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._basicConfig) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.feature) }()
      case 4: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .videoClassificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .videoClassificationConfig(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .objectDetectionConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .objectDetectionConfig(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .objectTrackingConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .objectTrackingConfig(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Datalabeling_V1beta1_EventConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .eventConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .eventConfig(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._basicConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.feature != .unspecified {
      try visitor.visitSingularEnumField(value: self.feature, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requestConfig {
    case .videoClassificationConfig?: try {
      guard case .videoClassificationConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .objectDetectionConfig?: try {
      guard case .objectDetectionConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .objectTrackingConfig?: try {
      guard case .objectTrackingConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .eventConfig?: try {
      guard case .eventConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest, rhs: Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest) -> Bool {
    if lhs.requestConfig != rhs.requestConfig {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs._basicConfig != rhs._basicConfig {return false}
    if lhs.feature != rhs.feature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_LabelVideoRequest.Feature: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_UNSPECIFIED"),
    1: .same(proto: "CLASSIFICATION"),
    2: .same(proto: "OBJECT_DETECTION"),
    3: .same(proto: "OBJECT_TRACKING"),
    4: .same(proto: "EVENT"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_LabelTextRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelTextRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "text_classification_config"),
    5: .standard(proto: "text_entity_extraction_config"),
    1: .same(proto: "parent"),
    2: .standard(proto: "basic_config"),
    6: .same(proto: "feature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._basicConfig) }()
      case 4: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .textClassificationConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .textClassificationConfig(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig?
        if let current = self.requestConfig {
          try decoder.handleConflictingOneOf()
          if case .textEntityExtractionConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestConfig = .textEntityExtractionConfig(v)}
      }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.feature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._basicConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requestConfig {
    case .textClassificationConfig?: try {
      guard case .textClassificationConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .textEntityExtractionConfig?: try {
      guard case .textEntityExtractionConfig(let v)? = self.requestConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.feature != .unspecified {
      try visitor.visitSingularEnumField(value: self.feature, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_LabelTextRequest, rhs: Google_Cloud_Datalabeling_V1beta1_LabelTextRequest) -> Bool {
    if lhs.requestConfig != rhs.requestConfig {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs._basicConfig != rhs._basicConfig {return false}
    if lhs.feature != rhs.feature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_LabelTextRequest.Feature: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FEATURE_UNSPECIFIED"),
    1: .same(proto: "TEXT_CLASSIFICATION"),
    2: .same(proto: "TEXT_ENTITY_EXTRACTION"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_GetExampleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetExampleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetExampleRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetExampleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListExamplesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListExamplesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListExamplesRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListExamplesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListExamplesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListExamplesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "examples"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.examples) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.examples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.examples, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListExamplesResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListExamplesResponse) -> Bool {
    if lhs.examples != rhs.examples {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_CreateAnnotationSpecSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAnnotationSpecSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "annotation_spec_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotationSpecSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._annotationSpecSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_CreateAnnotationSpecSetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_CreateAnnotationSpecSetRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._annotationSpecSet != rhs._annotationSpecSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetAnnotationSpecSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAnnotationSpecSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetAnnotationSpecSetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetAnnotationSpecSetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationSpecSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListAnnotationSpecSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotationSpecSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationSpecSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListAnnotationSpecSetsResponse) -> Bool {
    if lhs.annotationSpecSets != rhs.annotationSpecSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_DeleteAnnotationSpecSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAnnotationSpecSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DeleteAnnotationSpecSetRequest, rhs: Google_Cloud_Datalabeling_V1beta1_DeleteAnnotationSpecSetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_CreateInstructionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInstructionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "instruction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._instruction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._instruction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_CreateInstructionRequest, rhs: Google_Cloud_Datalabeling_V1beta1_CreateInstructionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._instruction != rhs._instruction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetInstructionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInstructionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetInstructionRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetInstructionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_DeleteInstructionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInstructionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DeleteInstructionRequest, rhs: Google_Cloud_Datalabeling_V1beta1_DeleteInstructionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListInstructionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstructionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListInstructionsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListInstructionsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListInstructionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstructionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instructions"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instructions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instructions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instructions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListInstructionsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListInstructionsResponse) -> Bool {
    if lhs.instructions != rhs.instructions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetEvaluationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEvaluationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetEvaluationRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetEvaluationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchEvaluationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchEvaluationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "evaluations"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.evaluations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.evaluations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evaluations, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_SearchEvaluationsResponse) -> Bool {
    if lhs.evaluations != rhs.evaluations {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchExampleComparisonsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchExampleComparisonsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "example_comparisons"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.exampleComparisons) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.exampleComparisons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.exampleComparisons, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse) -> Bool {
    if lhs.exampleComparisons != rhs.exampleComparisons {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse.ExampleComparison: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse.protoMessageName + ".ExampleComparison"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ground_truth_example"),
    2: .standard(proto: "model_created_examples"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groundTruthExample) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modelCreatedExamples) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groundTruthExample {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.modelCreatedExamples.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modelCreatedExamples, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse.ExampleComparison, rhs: Google_Cloud_Datalabeling_V1beta1_SearchExampleComparisonsResponse.ExampleComparison) -> Bool {
    if lhs._groundTruthExample != rhs._groundTruthExample {return false}
    if lhs.modelCreatedExamples != rhs.modelCreatedExamples {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_CreateEvaluationJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEvaluationJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "job"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._job) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._job {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_CreateEvaluationJobRequest, rhs: Google_Cloud_Datalabeling_V1beta1_CreateEvaluationJobRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._job != rhs._job {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_UpdateEvaluationJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEvaluationJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "evaluation_job"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._evaluationJob) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._evaluationJob {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_UpdateEvaluationJobRequest, rhs: Google_Cloud_Datalabeling_V1beta1_UpdateEvaluationJobRequest) -> Bool {
    if lhs._evaluationJob != rhs._evaluationJob {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_GetEvaluationJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEvaluationJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_GetEvaluationJobRequest, rhs: Google_Cloud_Datalabeling_V1beta1_GetEvaluationJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_PauseEvaluationJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PauseEvaluationJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_PauseEvaluationJobRequest, rhs: Google_Cloud_Datalabeling_V1beta1_PauseEvaluationJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ResumeEvaluationJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResumeEvaluationJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ResumeEvaluationJobRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ResumeEvaluationJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_DeleteEvaluationJobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteEvaluationJobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_DeleteEvaluationJobRequest, rhs: Google_Cloud_Datalabeling_V1beta1_DeleteEvaluationJobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEvaluationJobsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsRequest, rhs: Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEvaluationJobsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "evaluation_jobs"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.evaluationJobs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.evaluationJobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.evaluationJobs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsResponse, rhs: Google_Cloud_Datalabeling_V1beta1_ListEvaluationJobsResponse) -> Bool {
    if lhs.evaluationJobs != rhs.evaluationJobs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

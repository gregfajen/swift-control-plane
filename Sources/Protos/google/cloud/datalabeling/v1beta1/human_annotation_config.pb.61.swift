// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datalabeling/v1beta1/human_annotation_config.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Google_Cloud_Datalabeling_V1beta1_StringAggregationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Majority vote to aggregate answers.
  case majorityVote // = 1

  /// Unanimous answers will be adopted.
  case unanimousVote // = 2

  /// Preserve all answers by crowd compute.
  case noAggregation // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .majorityVote
    case 2: self = .unanimousVote
    case 3: self = .noAggregation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .majorityVote: return 1
    case .unanimousVote: return 2
    case .noAggregation: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_StringAggregationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_StringAggregationType] = [
    .unspecified,
    .majorityVote,
    .unanimousVote,
    .noAggregation,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for how human labeling task should be done.
public struct Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Instruction resource name.
  public var instruction: String = String()

  /// Required. A human-readable name for AnnotatedDataset defined by
  /// users. Maximum of 64 characters
  /// .
  public var annotatedDatasetDisplayName: String = String()

  /// Optional. A human-readable description for AnnotatedDataset.
  /// The description can be up to 10000 characters long.
  public var annotatedDatasetDescription: String = String()

  /// Optional. A human-readable label used to logically group labeling tasks.
  /// This string must match the regular expression `[a-zA-Z\\d_-]{0,128}`.
  public var labelGroup: String = String()

  /// Optional. The Language of this question, as a
  /// [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt).
  /// Default value is en-US.
  /// Only need to set this when task is language related. For example, French
  /// text classification.
  public var languageCode: String = String()

  /// Optional. Replication of questions. Each question will be sent to up to
  /// this number of contributors to label. Aggregated answers will be returned.
  /// Default is set to 1.
  /// For image related labeling, valid values are 1, 3, 5.
  public var replicaCount: Int32 = 0

  /// Optional. Maximum duration for contributors to answer a question. Maximum
  /// is 3600 seconds. Default is 3600 seconds.
  public var questionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _questionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_questionDuration = newValue}
  }
  /// Returns true if `questionDuration` has been explicitly set.
  public var hasQuestionDuration: Bool {return self._questionDuration != nil}
  /// Clears the value of `questionDuration`. Subsequent reads from it will return its default value.
  public mutating func clearQuestionDuration() {self._questionDuration = nil}

  /// Optional. If you want your own labeling contributors to manage and work on
  /// this labeling request, you can set these contributors here. We will give
  /// them access to the question types in crowdcompute. Note that these
  /// emails must be registered in crowdcompute worker UI:
  /// https://crowd-compute.appspot.com/
  public var contributorEmails: [String] = []

  /// Email of the user who started the labeling task and should be notified by
  /// email. If empty no notification will be sent.
  public var userEmailAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _questionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Config for image classification human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  /// Optional. If allow_multi_label is true, contributors are able to choose
  /// multiple labels for one image.
  public var allowMultiLabel: Bool = false

  /// Optional. The type of how to aggregate answers.
  public var answerAggregationType: Google_Cloud_Datalabeling_V1beta1_StringAggregationType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for image bounding poly (and bounding box) human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  /// Optional. Instruction message showed on contributors UI.
  public var instructionMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for image polyline human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_PolylineConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  /// Optional. Instruction message showed on contributors UI.
  public var instructionMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for image segmentation
public struct Google_Cloud_Datalabeling_V1beta1_SegmentationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name. format:
  /// projects/{project_id}/annotationSpecSets/{annotation_spec_set_id}
  public var annotationSpecSet: String = String()

  /// Instruction message showed on labelers UI.
  public var instructionMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for video classification human labeling task.
/// Currently two types of video classification are supported:
/// 1. Assign labels on the entire video.
/// 2. Split the video into multiple video clips based on camera shot, and
/// assign labels on each video clip.
public struct Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The list of annotation spec set configs.
  /// Since watching a video clip takes much longer time than an image, we
  /// support label with multiple AnnotationSpecSet at the same time. Labels
  /// in each AnnotationSpecSet will be shown in a group to contributors.
  /// Contributors can select one or more (depending on whether to allow multi
  /// label) from each group.
  public var annotationSpecSetConfigs: [Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig.AnnotationSpecSetConfig] = []

  /// Optional. Option to apply shot detection on the video.
  public var applyShotDetection: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Annotation spec set with the setting of allowing multi labels or not.
  public struct AnnotationSpecSetConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Annotation spec set resource name.
    public var annotationSpecSet: String = String()

    /// Optional. If allow_multi_label is true, contributors are able to
    /// choose multiple labels from one annotation spec set.
    public var allowMultiLabel: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Config for video object detection human labeling task.
/// Object detection will be conducted on the images extracted from the video,
/// and those objects will be labeled with bounding boxes.
/// User need to specify the number of images to be extracted per second as the
/// extraction frame rate.
public struct Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  /// Required. Number of frames per second to be extracted from the video.
  public var extractionFrameRate: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for video object tracking human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for video event human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_EventConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The list of annotation spec set resource name. Similar to video
  /// classification, we support selecting event from multiple AnnotationSpecSet
  /// at the same time.
  public var annotationSpecSets: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for text classification human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. If allow_multi_label is true, contributors are able to choose
  /// multiple labels for one text segment.
  public var allowMultiLabel: Bool = false

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  /// Optional. Configs for sentiment selection.
  public var sentimentConfig: Google_Cloud_Datalabeling_V1beta1_SentimentConfig {
    get {return _sentimentConfig ?? Google_Cloud_Datalabeling_V1beta1_SentimentConfig()}
    set {_sentimentConfig = newValue}
  }
  /// Returns true if `sentimentConfig` has been explicitly set.
  public var hasSentimentConfig: Bool {return self._sentimentConfig != nil}
  /// Clears the value of `sentimentConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSentimentConfig() {self._sentimentConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sentimentConfig: Google_Cloud_Datalabeling_V1beta1_SentimentConfig? = nil
}

/// Config for setting up sentiments.
public struct Google_Cloud_Datalabeling_V1beta1_SentimentConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set to true, contributors will have the option to select sentiment of
  /// the label they selected, to mark it as negative or positive label. Default
  /// is false.
  public var enableLabelSentimentSelection: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Config for text entity extraction human labeling task.
public struct Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Annotation spec set resource name.
  public var annotationSpecSet: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datalabeling.v1beta1"

extension Google_Cloud_Datalabeling_V1beta1_StringAggregationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STRING_AGGREGATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "MAJORITY_VOTE"),
    2: .same(proto: "UNANIMOUS_VOTE"),
    3: .same(proto: "NO_AGGREGATION"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HumanAnnotationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instruction"),
    2: .standard(proto: "annotated_dataset_display_name"),
    3: .standard(proto: "annotated_dataset_description"),
    4: .standard(proto: "label_group"),
    5: .standard(proto: "language_code"),
    6: .standard(proto: "replica_count"),
    7: .standard(proto: "question_duration"),
    9: .standard(proto: "contributor_emails"),
    10: .standard(proto: "user_email_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instruction) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.annotatedDatasetDisplayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.annotatedDatasetDescription) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.labelGroup) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.replicaCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._questionDuration) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.contributorEmails) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.userEmailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instruction.isEmpty {
      try visitor.visitSingularStringField(value: self.instruction, fieldNumber: 1)
    }
    if !self.annotatedDatasetDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.annotatedDatasetDisplayName, fieldNumber: 2)
    }
    if !self.annotatedDatasetDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.annotatedDatasetDescription, fieldNumber: 3)
    }
    if !self.labelGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.labelGroup, fieldNumber: 4)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 5)
    }
    if self.replicaCount != 0 {
      try visitor.visitSingularInt32Field(value: self.replicaCount, fieldNumber: 6)
    }
    if let v = self._questionDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.contributorEmails.isEmpty {
      try visitor.visitRepeatedStringField(value: self.contributorEmails, fieldNumber: 9)
    }
    if !self.userEmailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmailAddress, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig, rhs: Google_Cloud_Datalabeling_V1beta1_HumanAnnotationConfig) -> Bool {
    if lhs.instruction != rhs.instruction {return false}
    if lhs.annotatedDatasetDisplayName != rhs.annotatedDatasetDisplayName {return false}
    if lhs.annotatedDatasetDescription != rhs.annotatedDatasetDescription {return false}
    if lhs.labelGroup != rhs.labelGroup {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.replicaCount != rhs.replicaCount {return false}
    if lhs._questionDuration != rhs._questionDuration {return false}
    if lhs.contributorEmails != rhs.contributorEmails {return false}
    if lhs.userEmailAddress != rhs.userEmailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageClassificationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
    2: .standard(proto: "allow_multi_label"),
    3: .standard(proto: "answer_aggregation_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowMultiLabel) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.answerAggregationType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    if self.allowMultiLabel != false {
      try visitor.visitSingularBoolField(value: self.allowMultiLabel, fieldNumber: 2)
    }
    if self.answerAggregationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.answerAggregationType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig, rhs: Google_Cloud_Datalabeling_V1beta1_ImageClassificationConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.allowMultiLabel != rhs.allowMultiLabel {return false}
    if lhs.answerAggregationType != rhs.answerAggregationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingPolyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
    2: .standard(proto: "instruction_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instructionMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    if !self.instructionMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig, rhs: Google_Cloud_Datalabeling_V1beta1_BoundingPolyConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.instructionMessage != rhs.instructionMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_PolylineConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PolylineConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
    2: .standard(proto: "instruction_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instructionMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    if !self.instructionMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_PolylineConfig, rhs: Google_Cloud_Datalabeling_V1beta1_PolylineConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.instructionMessage != rhs.instructionMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SegmentationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SegmentationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
    2: .standard(proto: "instruction_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instructionMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    if !self.instructionMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.instructionMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SegmentationConfig, rhs: Google_Cloud_Datalabeling_V1beta1_SegmentationConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.instructionMessage != rhs.instructionMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoClassificationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set_configs"),
    2: .standard(proto: "apply_shot_detection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.annotationSpecSetConfigs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.applyShotDetection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSetConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annotationSpecSetConfigs, fieldNumber: 1)
    }
    if self.applyShotDetection != false {
      try visitor.visitSingularBoolField(value: self.applyShotDetection, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig, rhs: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig) -> Bool {
    if lhs.annotationSpecSetConfigs != rhs.annotationSpecSetConfigs {return false}
    if lhs.applyShotDetection != rhs.applyShotDetection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig.AnnotationSpecSetConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig.protoMessageName + ".AnnotationSpecSetConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
    2: .standard(proto: "allow_multi_label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowMultiLabel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    if self.allowMultiLabel != false {
      try visitor.visitSingularBoolField(value: self.allowMultiLabel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig.AnnotationSpecSetConfig, rhs: Google_Cloud_Datalabeling_V1beta1_VideoClassificationConfig.AnnotationSpecSetConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.allowMultiLabel != rhs.allowMultiLabel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectDetectionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
    3: .standard(proto: "extraction_frame_rate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.extractionFrameRate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    if self.extractionFrameRate != 0 {
      try visitor.visitSingularDoubleField(value: self.extractionFrameRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig, rhs: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.extractionFrameRate != rhs.extractionFrameRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectTrackingConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig, rhs: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_EventConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_sets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.annotationSpecSets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.annotationSpecSets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_EventConfig, rhs: Google_Cloud_Datalabeling_V1beta1_EventConfig) -> Bool {
    if lhs.annotationSpecSets != rhs.annotationSpecSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextClassificationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_multi_label"),
    2: .standard(proto: "annotation_spec_set"),
    3: .standard(proto: "sentiment_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.allowMultiLabel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sentimentConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.allowMultiLabel != false {
      try visitor.visitSingularBoolField(value: self.allowMultiLabel, fieldNumber: 1)
    }
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 2)
    }
    if let v = self._sentimentConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig, rhs: Google_Cloud_Datalabeling_V1beta1_TextClassificationConfig) -> Bool {
    if lhs.allowMultiLabel != rhs.allowMultiLabel {return false}
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs._sentimentConfig != rhs._sentimentConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SentimentConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SentimentConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_label_sentiment_selection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableLabelSentimentSelection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableLabelSentimentSelection != false {
      try visitor.visitSingularBoolField(value: self.enableLabelSentimentSelection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SentimentConfig, rhs: Google_Cloud_Datalabeling_V1beta1_SentimentConfig) -> Bool {
    if lhs.enableLabelSentimentSelection != rhs.enableLabelSentimentSelection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextEntityExtractionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec_set"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.annotationSpecSet) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationSpecSet.isEmpty {
      try visitor.visitSingularStringField(value: self.annotationSpecSet, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig, rhs: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionConfig) -> Bool {
    if lhs.annotationSpecSet != rhs.annotationSpecSet {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

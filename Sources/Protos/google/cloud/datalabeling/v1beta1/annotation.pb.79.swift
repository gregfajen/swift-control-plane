// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datalabeling/v1beta1/annotation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies where the annotation comes from (whether it was provided by a
/// human labeler or a different source).
public enum Google_Cloud_Datalabeling_V1beta1_AnnotationSource: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Answer is provided by a human contributor.
  case `operator` // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 3: self = .operator
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .operator: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_AnnotationSource: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_AnnotationSource] = [
    .unspecified,
    .operator,
  ]
}

#endif  // swift(>=4.2)

public enum Google_Cloud_Datalabeling_V1beta1_AnnotationSentiment: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// This annotation describes negatively about the data.
  case negative // = 1

  /// This label describes positively about the data.
  case positive // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .negative
    case 2: self = .positive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .negative: return 1
    case .positive: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_AnnotationSentiment: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_AnnotationSentiment] = [
    .unspecified,
    .negative,
    .positive,
  ]
}

#endif  // swift(>=4.2)

public enum Google_Cloud_Datalabeling_V1beta1_AnnotationType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Classification annotations in an image. Allowed for continuous evaluation.
  case imageClassificationAnnotation // = 1

  /// Bounding box annotations in an image. A form of image object detection.
  /// Allowed for continuous evaluation.
  case imageBoundingBoxAnnotation // = 2

  /// Oriented bounding box. The box does not have to be parallel to horizontal
  /// line.
  case imageOrientedBoundingBoxAnnotation // = 13

  /// Bounding poly annotations in an image.
  case imageBoundingPolyAnnotation // = 10

  /// Polyline annotations in an image.
  case imagePolylineAnnotation // = 11

  /// Segmentation annotations in an image.
  case imageSegmentationAnnotation // = 12

  /// Classification annotations in video shots.
  case videoShotsClassificationAnnotation // = 3

  /// Video object tracking annotation.
  case videoObjectTrackingAnnotation // = 4

  /// Video object detection annotation.
  case videoObjectDetectionAnnotation // = 5

  /// Video event annotation.
  case videoEventAnnotation // = 6

  /// Classification for text. Allowed for continuous evaluation.
  case textClassificationAnnotation // = 8

  /// Entity extraction for text.
  case textEntityExtractionAnnotation // = 9

  /// General classification. Allowed for continuous evaluation.
  case generalClassificationAnnotation // = 14
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .imageClassificationAnnotation
    case 2: self = .imageBoundingBoxAnnotation
    case 3: self = .videoShotsClassificationAnnotation
    case 4: self = .videoObjectTrackingAnnotation
    case 5: self = .videoObjectDetectionAnnotation
    case 6: self = .videoEventAnnotation
    case 8: self = .textClassificationAnnotation
    case 9: self = .textEntityExtractionAnnotation
    case 10: self = .imageBoundingPolyAnnotation
    case 11: self = .imagePolylineAnnotation
    case 12: self = .imageSegmentationAnnotation
    case 13: self = .imageOrientedBoundingBoxAnnotation
    case 14: self = .generalClassificationAnnotation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .imageClassificationAnnotation: return 1
    case .imageBoundingBoxAnnotation: return 2
    case .videoShotsClassificationAnnotation: return 3
    case .videoObjectTrackingAnnotation: return 4
    case .videoObjectDetectionAnnotation: return 5
    case .videoEventAnnotation: return 6
    case .textClassificationAnnotation: return 8
    case .textEntityExtractionAnnotation: return 9
    case .imageBoundingPolyAnnotation: return 10
    case .imagePolylineAnnotation: return 11
    case .imageSegmentationAnnotation: return 12
    case .imageOrientedBoundingBoxAnnotation: return 13
    case .generalClassificationAnnotation: return 14
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Datalabeling_V1beta1_AnnotationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datalabeling_V1beta1_AnnotationType] = [
    .unspecified,
    .imageClassificationAnnotation,
    .imageBoundingBoxAnnotation,
    .imageOrientedBoundingBoxAnnotation,
    .imageBoundingPolyAnnotation,
    .imagePolylineAnnotation,
    .imageSegmentationAnnotation,
    .videoShotsClassificationAnnotation,
    .videoObjectTrackingAnnotation,
    .videoObjectDetectionAnnotation,
    .videoEventAnnotation,
    .textClassificationAnnotation,
    .textEntityExtractionAnnotation,
    .generalClassificationAnnotation,
  ]
}

#endif  // swift(>=4.2)

/// Annotation for Example. Each example may have one or more annotations. For
/// example in image classification problem, each image might have one or more
/// labels. We call labels binded with this image an Annotation.
public struct Google_Cloud_Datalabeling_V1beta1_Annotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Unique name of this annotation, format is:
  ///
  /// projects/{project_id}/datasets/{dataset_id}/annotatedDatasets/{annotated_dataset}/examples/{example_id}/annotations/{annotation_id}
  public var name: String = String()

  /// Output only. The source of the annotation.
  public var annotationSource: Google_Cloud_Datalabeling_V1beta1_AnnotationSource = .unspecified

  /// Output only. This is the actual annotation value, e.g classification,
  /// bounding box values are stored here.
  public var annotationValue: Google_Cloud_Datalabeling_V1beta1_AnnotationValue {
    get {return _annotationValue ?? Google_Cloud_Datalabeling_V1beta1_AnnotationValue()}
    set {_annotationValue = newValue}
  }
  /// Returns true if `annotationValue` has been explicitly set.
  public var hasAnnotationValue: Bool {return self._annotationValue != nil}
  /// Clears the value of `annotationValue`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationValue() {self._annotationValue = nil}

  /// Output only. Annotation metadata, including information like votes
  /// for labels.
  public var annotationMetadata: Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata {
    get {return _annotationMetadata ?? Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata()}
    set {_annotationMetadata = newValue}
  }
  /// Returns true if `annotationMetadata` has been explicitly set.
  public var hasAnnotationMetadata: Bool {return self._annotationMetadata != nil}
  /// Clears the value of `annotationMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationMetadata() {self._annotationMetadata = nil}

  /// Output only. Sentiment for this annotation.
  public var annotationSentiment: Google_Cloud_Datalabeling_V1beta1_AnnotationSentiment = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationValue: Google_Cloud_Datalabeling_V1beta1_AnnotationValue? = nil
  fileprivate var _annotationMetadata: Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata? = nil
}

/// Annotation value for an example.
public struct Google_Cloud_Datalabeling_V1beta1_AnnotationValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var valueType: Google_Cloud_Datalabeling_V1beta1_AnnotationValue.OneOf_ValueType? = nil

  /// Annotation value for image classification case.
  public var imageClassificationAnnotation: Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation {
    get {
      if case .imageClassificationAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation()
    }
    set {valueType = .imageClassificationAnnotation(newValue)}
  }

  /// Annotation value for image bounding box, oriented bounding box
  /// and polygon cases.
  public var imageBoundingPolyAnnotation: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation {
    get {
      if case .imageBoundingPolyAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation()
    }
    set {valueType = .imageBoundingPolyAnnotation(newValue)}
  }

  /// Annotation value for image polyline cases.
  /// Polyline here is different from BoundingPoly. It is formed by
  /// line segments connected to each other but not closed form(Bounding Poly).
  /// The line segments can cross each other.
  public var imagePolylineAnnotation: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation {
    get {
      if case .imagePolylineAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation()
    }
    set {valueType = .imagePolylineAnnotation(newValue)}
  }

  /// Annotation value for image segmentation.
  public var imageSegmentationAnnotation: Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation {
    get {
      if case .imageSegmentationAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation()
    }
    set {valueType = .imageSegmentationAnnotation(newValue)}
  }

  /// Annotation value for text classification case.
  public var textClassificationAnnotation: Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation {
    get {
      if case .textClassificationAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation()
    }
    set {valueType = .textClassificationAnnotation(newValue)}
  }

  /// Annotation value for text entity extraction case.
  public var textEntityExtractionAnnotation: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation {
    get {
      if case .textEntityExtractionAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation()
    }
    set {valueType = .textEntityExtractionAnnotation(newValue)}
  }

  /// Annotation value for video classification case.
  public var videoClassificationAnnotation: Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation {
    get {
      if case .videoClassificationAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation()
    }
    set {valueType = .videoClassificationAnnotation(newValue)}
  }

  /// Annotation value for video object detection and tracking case.
  public var videoObjectTrackingAnnotation: Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation {
    get {
      if case .videoObjectTrackingAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation()
    }
    set {valueType = .videoObjectTrackingAnnotation(newValue)}
  }

  /// Annotation value for video event case.
  public var videoEventAnnotation: Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation {
    get {
      if case .videoEventAnnotation(let v)? = valueType {return v}
      return Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation()
    }
    set {valueType = .videoEventAnnotation(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_ValueType: Equatable {
    /// Annotation value for image classification case.
    case imageClassificationAnnotation(Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation)
    /// Annotation value for image bounding box, oriented bounding box
    /// and polygon cases.
    case imageBoundingPolyAnnotation(Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation)
    /// Annotation value for image polyline cases.
    /// Polyline here is different from BoundingPoly. It is formed by
    /// line segments connected to each other but not closed form(Bounding Poly).
    /// The line segments can cross each other.
    case imagePolylineAnnotation(Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation)
    /// Annotation value for image segmentation.
    case imageSegmentationAnnotation(Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation)
    /// Annotation value for text classification case.
    case textClassificationAnnotation(Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation)
    /// Annotation value for text entity extraction case.
    case textEntityExtractionAnnotation(Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation)
    /// Annotation value for video classification case.
    case videoClassificationAnnotation(Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation)
    /// Annotation value for video object detection and tracking case.
    case videoObjectTrackingAnnotation(Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation)
    /// Annotation value for video event case.
    case videoEventAnnotation(Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_AnnotationValue.OneOf_ValueType, rhs: Google_Cloud_Datalabeling_V1beta1_AnnotationValue.OneOf_ValueType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.imageClassificationAnnotation, .imageClassificationAnnotation): return {
        guard case .imageClassificationAnnotation(let l) = lhs, case .imageClassificationAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imageBoundingPolyAnnotation, .imageBoundingPolyAnnotation): return {
        guard case .imageBoundingPolyAnnotation(let l) = lhs, case .imageBoundingPolyAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imagePolylineAnnotation, .imagePolylineAnnotation): return {
        guard case .imagePolylineAnnotation(let l) = lhs, case .imagePolylineAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.imageSegmentationAnnotation, .imageSegmentationAnnotation): return {
        guard case .imageSegmentationAnnotation(let l) = lhs, case .imageSegmentationAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textClassificationAnnotation, .textClassificationAnnotation): return {
        guard case .textClassificationAnnotation(let l) = lhs, case .textClassificationAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.textEntityExtractionAnnotation, .textEntityExtractionAnnotation): return {
        guard case .textEntityExtractionAnnotation(let l) = lhs, case .textEntityExtractionAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoClassificationAnnotation, .videoClassificationAnnotation): return {
        guard case .videoClassificationAnnotation(let l) = lhs, case .videoClassificationAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoObjectTrackingAnnotation, .videoObjectTrackingAnnotation): return {
        guard case .videoObjectTrackingAnnotation(let l) = lhs, case .videoObjectTrackingAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.videoEventAnnotation, .videoEventAnnotation): return {
        guard case .videoEventAnnotation(let l) = lhs, case .videoEventAnnotation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Image classification annotation definition.
public struct Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Label of image.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
}

/// A vertex represents a 2D point in the image.
/// NOTE: the vertex coordinates are in the same scale as the original image.
public struct Google_Cloud_Datalabeling_V1beta1_Vertex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// X coordinate.
  public var x: Int32 = 0

  /// Y coordinate.
  public var y: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A vertex represents a 2D point in the image.
/// NOTE: the normalized vertex coordinates are relative to the original image
/// and range from 0 to 1.
public struct Google_Cloud_Datalabeling_V1beta1_NormalizedVertex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// X coordinate.
  public var x: Float = 0

  /// Y coordinate.
  public var y: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A bounding polygon in the image.
public struct Google_Cloud_Datalabeling_V1beta1_BoundingPoly {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bounding polygon vertices.
  public var vertices: [Google_Cloud_Datalabeling_V1beta1_Vertex] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Normalized bounding polygon.
public struct Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bounding polygon normalized vertices.
  public var normalizedVertices: [Google_Cloud_Datalabeling_V1beta1_NormalizedVertex] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Image bounding poly annotation. It represents a polygon including
/// bounding box in the image.
public struct Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The region of the polygon. If it is a bounding box, it is guaranteed to be
  /// four points.
  public var boundedArea: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation.OneOf_BoundedArea? = nil

  public var boundingPoly: Google_Cloud_Datalabeling_V1beta1_BoundingPoly {
    get {
      if case .boundingPoly(let v)? = boundedArea {return v}
      return Google_Cloud_Datalabeling_V1beta1_BoundingPoly()
    }
    set {boundedArea = .boundingPoly(newValue)}
  }

  public var normalizedBoundingPoly: Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly {
    get {
      if case .normalizedBoundingPoly(let v)? = boundedArea {return v}
      return Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly()
    }
    set {boundedArea = .normalizedBoundingPoly(newValue)}
  }

  /// Label of object in this bounding polygon.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The region of the polygon. If it is a bounding box, it is guaranteed to be
  /// four points.
  public enum OneOf_BoundedArea: Equatable {
    case boundingPoly(Google_Cloud_Datalabeling_V1beta1_BoundingPoly)
    case normalizedBoundingPoly(Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation.OneOf_BoundedArea, rhs: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation.OneOf_BoundedArea) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boundingPoly, .boundingPoly): return {
        guard case .boundingPoly(let l) = lhs, case .boundingPoly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.normalizedBoundingPoly, .normalizedBoundingPoly): return {
        guard case .normalizedBoundingPoly(let l) = lhs, case .normalizedBoundingPoly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
}

/// A line with multiple line segments.
public struct Google_Cloud_Datalabeling_V1beta1_Polyline {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The polyline vertices.
  public var vertices: [Google_Cloud_Datalabeling_V1beta1_Vertex] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Normalized polyline.
public struct Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The normalized polyline vertices.
  public var normalizedVertices: [Google_Cloud_Datalabeling_V1beta1_NormalizedVertex] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A polyline for the image annotation.
public struct Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var poly: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation.OneOf_Poly? = nil

  public var polyline: Google_Cloud_Datalabeling_V1beta1_Polyline {
    get {
      if case .polyline(let v)? = poly {return v}
      return Google_Cloud_Datalabeling_V1beta1_Polyline()
    }
    set {poly = .polyline(newValue)}
  }

  public var normalizedPolyline: Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline {
    get {
      if case .normalizedPolyline(let v)? = poly {return v}
      return Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline()
    }
    set {poly = .normalizedPolyline(newValue)}
  }

  /// Label of this polyline.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Poly: Equatable {
    case polyline(Google_Cloud_Datalabeling_V1beta1_Polyline)
    case normalizedPolyline(Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation.OneOf_Poly, rhs: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation.OneOf_Poly) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.polyline, .polyline): return {
        guard case .polyline(let l) = lhs, case .polyline(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.normalizedPolyline, .normalizedPolyline): return {
        guard case .normalizedPolyline(let l) = lhs, case .normalizedPolyline(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
}

/// Image segmentation annotation.
public struct Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mapping between rgb color and annotation spec. The key is the rgb
  /// color represented in format of rgb(0, 0, 0). The value is the
  /// AnnotationSpec.
  public var annotationColors: Dictionary<String,Google_Cloud_Datalabeling_V1beta1_AnnotationSpec> = [:]

  /// Image format.
  public var mimeType: String = String()

  /// A byte string of a full image's color map.
  public var imageBytes: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Text classification annotation.
public struct Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Label of the text.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
}

/// Text entity extraction annotation.
public struct Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Label of the text entities.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  /// Position of the entity.
  public var sequentialSegment: Google_Cloud_Datalabeling_V1beta1_SequentialSegment {
    get {return _sequentialSegment ?? Google_Cloud_Datalabeling_V1beta1_SequentialSegment()}
    set {_sequentialSegment = newValue}
  }
  /// Returns true if `sequentialSegment` has been explicitly set.
  public var hasSequentialSegment: Bool {return self._sequentialSegment != nil}
  /// Clears the value of `sequentialSegment`. Subsequent reads from it will return its default value.
  public mutating func clearSequentialSegment() {self._sequentialSegment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
  fileprivate var _sequentialSegment: Google_Cloud_Datalabeling_V1beta1_SequentialSegment? = nil
}

/// Start and end position in a sequence (e.g. text segment).
public struct Google_Cloud_Datalabeling_V1beta1_SequentialSegment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start position (inclusive).
  public var start: Int32 = 0

  /// End position (exclusive).
  public var end: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A time period inside of an example that has a time dimension (e.g. video).
public struct Google_Cloud_Datalabeling_V1beta1_TimeSegment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start of the time segment (inclusive), represented as the duration since
  /// the example start.
  public var startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startTimeOffset = newValue}
  }
  /// Returns true if `startTimeOffset` has been explicitly set.
  public var hasStartTimeOffset: Bool {return self._startTimeOffset != nil}
  /// Clears the value of `startTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeOffset() {self._startTimeOffset = nil}

  /// End of the time segment (exclusive), represented as the duration since the
  /// example start.
  public var endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _endTimeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_endTimeOffset = newValue}
  }
  /// Returns true if `endTimeOffset` has been explicitly set.
  public var hasEndTimeOffset: Bool {return self._endTimeOffset != nil}
  /// Clears the value of `endTimeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearEndTimeOffset() {self._endTimeOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _endTimeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Video classification annotation.
public struct Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time segment of the video to which the annotation applies.
  public var timeSegment: Google_Cloud_Datalabeling_V1beta1_TimeSegment {
    get {return _timeSegment ?? Google_Cloud_Datalabeling_V1beta1_TimeSegment()}
    set {_timeSegment = newValue}
  }
  /// Returns true if `timeSegment` has been explicitly set.
  public var hasTimeSegment: Bool {return self._timeSegment != nil}
  /// Clears the value of `timeSegment`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSegment() {self._timeSegment = nil}

  /// Label of the segment specified by time_segment.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timeSegment: Google_Cloud_Datalabeling_V1beta1_TimeSegment? = nil
  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
}

/// Video frame level annotation for object detection and tracking.
public struct Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The bounding box location of this object track for the frame.
  public var boundedArea: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame.OneOf_BoundedArea? = nil

  public var boundingPoly: Google_Cloud_Datalabeling_V1beta1_BoundingPoly {
    get {
      if case .boundingPoly(let v)? = boundedArea {return v}
      return Google_Cloud_Datalabeling_V1beta1_BoundingPoly()
    }
    set {boundedArea = .boundingPoly(newValue)}
  }

  public var normalizedBoundingPoly: Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly {
    get {
      if case .normalizedBoundingPoly(let v)? = boundedArea {return v}
      return Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly()
    }
    set {boundedArea = .normalizedBoundingPoly(newValue)}
  }

  /// The time offset of this frame relative to the beginning of the video.
  public var timeOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeOffset ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeOffset = newValue}
  }
  /// Returns true if `timeOffset` has been explicitly set.
  public var hasTimeOffset: Bool {return self._timeOffset != nil}
  /// Clears the value of `timeOffset`. Subsequent reads from it will return its default value.
  public mutating func clearTimeOffset() {self._timeOffset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The bounding box location of this object track for the frame.
  public enum OneOf_BoundedArea: Equatable {
    case boundingPoly(Google_Cloud_Datalabeling_V1beta1_BoundingPoly)
    case normalizedBoundingPoly(Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame.OneOf_BoundedArea, rhs: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame.OneOf_BoundedArea) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boundingPoly, .boundingPoly): return {
        guard case .boundingPoly(let l) = lhs, case .boundingPoly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.normalizedBoundingPoly, .normalizedBoundingPoly): return {
        guard case .normalizedBoundingPoly(let l) = lhs, case .normalizedBoundingPoly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _timeOffset: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Video object tracking annotation.
public struct Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Label of the object tracked in this annotation.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  /// The time segment of the video to which object tracking applies.
  public var timeSegment: Google_Cloud_Datalabeling_V1beta1_TimeSegment {
    get {return _timeSegment ?? Google_Cloud_Datalabeling_V1beta1_TimeSegment()}
    set {_timeSegment = newValue}
  }
  /// Returns true if `timeSegment` has been explicitly set.
  public var hasTimeSegment: Bool {return self._timeSegment != nil}
  /// Clears the value of `timeSegment`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSegment() {self._timeSegment = nil}

  /// The list of frames where this object track appears.
  public var objectTrackingFrames: [Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
  fileprivate var _timeSegment: Google_Cloud_Datalabeling_V1beta1_TimeSegment? = nil
}

/// Video event annotation.
public struct Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Label of the event in this annotation.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  /// The time segment of the video to which the annotation applies.
  public var timeSegment: Google_Cloud_Datalabeling_V1beta1_TimeSegment {
    get {return _timeSegment ?? Google_Cloud_Datalabeling_V1beta1_TimeSegment()}
    set {_timeSegment = newValue}
  }
  /// Returns true if `timeSegment` has been explicitly set.
  public var hasTimeSegment: Bool {return self._timeSegment != nil}
  /// Clears the value of `timeSegment`. Subsequent reads from it will return its default value.
  public mutating func clearTimeSegment() {self._timeSegment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
  fileprivate var _timeSegment: Google_Cloud_Datalabeling_V1beta1_TimeSegment? = nil
}

/// Additional information associated with the annotation.
public struct Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata related to human labeling.
  public var operatorMetadata: Google_Cloud_Datalabeling_V1beta1_OperatorMetadata {
    get {return _operatorMetadata ?? Google_Cloud_Datalabeling_V1beta1_OperatorMetadata()}
    set {_operatorMetadata = newValue}
  }
  /// Returns true if `operatorMetadata` has been explicitly set.
  public var hasOperatorMetadata: Bool {return self._operatorMetadata != nil}
  /// Clears the value of `operatorMetadata`. Subsequent reads from it will return its default value.
  public mutating func clearOperatorMetadata() {self._operatorMetadata = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _operatorMetadata: Google_Cloud_Datalabeling_V1beta1_OperatorMetadata? = nil
}

/// General information useful for labels coming from contributors.
public struct Google_Cloud_Datalabeling_V1beta1_OperatorMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Confidence score corresponding to a label. For examle, if 3 contributors
  /// have answered the question and 2 of them agree on the final label, the
  /// confidence score will be 0.67 (2/3).
  public var score: Float = 0

  /// The total number of contributors that answer this question.
  public var totalVotes: Int32 = 0

  /// The total number of contributors that choose this label.
  public var labelVotes: Int32 = 0

  /// Comments from contributors.
  public var comments: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datalabeling.v1beta1"

extension Google_Cloud_Datalabeling_V1beta1_AnnotationSource: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_SOURCE_UNSPECIFIED"),
    3: .same(proto: "OPERATOR"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_AnnotationSentiment: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_SENTIMENT_UNSPECIFIED"),
    1: .same(proto: "NEGATIVE"),
    2: .same(proto: "POSITIVE"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_AnnotationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "IMAGE_CLASSIFICATION_ANNOTATION"),
    2: .same(proto: "IMAGE_BOUNDING_BOX_ANNOTATION"),
    3: .same(proto: "VIDEO_SHOTS_CLASSIFICATION_ANNOTATION"),
    4: .same(proto: "VIDEO_OBJECT_TRACKING_ANNOTATION"),
    5: .same(proto: "VIDEO_OBJECT_DETECTION_ANNOTATION"),
    6: .same(proto: "VIDEO_EVENT_ANNOTATION"),
    8: .same(proto: "TEXT_CLASSIFICATION_ANNOTATION"),
    9: .same(proto: "TEXT_ENTITY_EXTRACTION_ANNOTATION"),
    10: .same(proto: "IMAGE_BOUNDING_POLY_ANNOTATION"),
    11: .same(proto: "IMAGE_POLYLINE_ANNOTATION"),
    12: .same(proto: "IMAGE_SEGMENTATION_ANNOTATION"),
    13: .same(proto: "IMAGE_ORIENTED_BOUNDING_BOX_ANNOTATION"),
    14: .same(proto: "GENERAL_CLASSIFICATION_ANNOTATION"),
  ]
}

extension Google_Cloud_Datalabeling_V1beta1_Annotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Annotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "annotation_source"),
    3: .standard(proto: "annotation_value"),
    4: .standard(proto: "annotation_metadata"),
    6: .standard(proto: "annotation_sentiment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.annotationSource) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._annotationValue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._annotationMetadata) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.annotationSentiment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.annotationSource != .unspecified {
      try visitor.visitSingularEnumField(value: self.annotationSource, fieldNumber: 2)
    }
    if let v = self._annotationValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._annotationMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.annotationSentiment != .unspecified {
      try visitor.visitSingularEnumField(value: self.annotationSentiment, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Annotation, rhs: Google_Cloud_Datalabeling_V1beta1_Annotation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.annotationSource != rhs.annotationSource {return false}
    if lhs._annotationValue != rhs._annotationValue {return false}
    if lhs._annotationMetadata != rhs._annotationMetadata {return false}
    if lhs.annotationSentiment != rhs.annotationSentiment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_AnnotationValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_classification_annotation"),
    2: .standard(proto: "image_bounding_poly_annotation"),
    8: .standard(proto: "image_polyline_annotation"),
    9: .standard(proto: "image_segmentation_annotation"),
    3: .standard(proto: "text_classification_annotation"),
    10: .standard(proto: "text_entity_extraction_annotation"),
    4: .standard(proto: "video_classification_annotation"),
    5: .standard(proto: "video_object_tracking_annotation"),
    6: .standard(proto: "video_event_annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .imageClassificationAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .imageClassificationAnnotation(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .imageBoundingPolyAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .imageBoundingPolyAnnotation(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .textClassificationAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .textClassificationAnnotation(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .videoClassificationAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .videoClassificationAnnotation(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .videoObjectTrackingAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .videoObjectTrackingAnnotation(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .videoEventAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .videoEventAnnotation(v)}
      }()
      case 8: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .imagePolylineAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .imagePolylineAnnotation(v)}
      }()
      case 9: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .imageSegmentationAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .imageSegmentationAnnotation(v)}
      }()
      case 10: try {
        var v: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation?
        if let current = self.valueType {
          try decoder.handleConflictingOneOf()
          if case .textEntityExtractionAnnotation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.valueType = .textEntityExtractionAnnotation(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.valueType {
    case .imageClassificationAnnotation?: try {
      guard case .imageClassificationAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .imageBoundingPolyAnnotation?: try {
      guard case .imageBoundingPolyAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .textClassificationAnnotation?: try {
      guard case .textClassificationAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .videoClassificationAnnotation?: try {
      guard case .videoClassificationAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .videoObjectTrackingAnnotation?: try {
      guard case .videoObjectTrackingAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .videoEventAnnotation?: try {
      guard case .videoEventAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .imagePolylineAnnotation?: try {
      guard case .imagePolylineAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .imageSegmentationAnnotation?: try {
      guard case .imageSegmentationAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .textEntityExtractionAnnotation?: try {
      guard case .textEntityExtractionAnnotation(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_AnnotationValue, rhs: Google_Cloud_Datalabeling_V1beta1_AnnotationValue) -> Bool {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageClassificationAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_ImageClassificationAnnotation) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_Vertex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vertex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.x) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularInt32Field(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularInt32Field(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Vertex, rhs: Google_Cloud_Datalabeling_V1beta1_Vertex) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_NormalizedVertex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NormalizedVertex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "x"),
    2: .same(proto: "y"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.x != 0 {
      try visitor.visitSingularFloatField(value: self.x, fieldNumber: 1)
    }
    if self.y != 0 {
      try visitor.visitSingularFloatField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_NormalizedVertex, rhs: Google_Cloud_Datalabeling_V1beta1_NormalizedVertex) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_BoundingPoly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingPoly"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vertices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vertices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vertices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vertices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_BoundingPoly, rhs: Google_Cloud_Datalabeling_V1beta1_BoundingPoly) -> Bool {
    if lhs.vertices != rhs.vertices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NormalizedBoundingPoly"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "normalized_vertices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.normalizedVertices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.normalizedVertices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.normalizedVertices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly, rhs: Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly) -> Bool {
    if lhs.normalizedVertices != rhs.normalizedVertices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageBoundingPolyAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "bounding_poly"),
    3: .standard(proto: "normalized_bounding_poly"),
    1: .standard(proto: "annotation_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_BoundingPoly?
        if let current = self.boundedArea {
          try decoder.handleConflictingOneOf()
          if case .boundingPoly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.boundedArea = .boundingPoly(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly?
        if let current = self.boundedArea {
          try decoder.handleConflictingOneOf()
          if case .normalizedBoundingPoly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.boundedArea = .normalizedBoundingPoly(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.boundedArea {
    case .boundingPoly?: try {
      guard case .boundingPoly(let v)? = self.boundedArea else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .normalizedBoundingPoly?: try {
      guard case .normalizedBoundingPoly(let v)? = self.boundedArea else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_ImageBoundingPolyAnnotation) -> Bool {
    if lhs.boundedArea != rhs.boundedArea {return false}
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_Polyline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Polyline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "vertices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.vertices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.vertices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.vertices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Polyline, rhs: Google_Cloud_Datalabeling_V1beta1_Polyline) -> Bool {
    if lhs.vertices != rhs.vertices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NormalizedPolyline"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "normalized_vertices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.normalizedVertices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.normalizedVertices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.normalizedVertices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline, rhs: Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline) -> Bool {
    if lhs.normalizedVertices != rhs.normalizedVertices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImagePolylineAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "polyline"),
    3: .standard(proto: "normalized_polyline"),
    1: .standard(proto: "annotation_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_Polyline?
        if let current = self.poly {
          try decoder.handleConflictingOneOf()
          if case .polyline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.poly = .polyline(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Datalabeling_V1beta1_NormalizedPolyline?
        if let current = self.poly {
          try decoder.handleConflictingOneOf()
          if case .normalizedPolyline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.poly = .normalizedPolyline(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.poly {
    case .polyline?: try {
      guard case .polyline(let v)? = self.poly else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .normalizedPolyline?: try {
      guard case .normalizedPolyline(let v)? = self.poly else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_ImagePolylineAnnotation) -> Bool {
    if lhs.poly != rhs.poly {return false}
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImageSegmentationAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_colors"),
    2: .standard(proto: "mime_type"),
    3: .standard(proto: "image_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Datalabeling_V1beta1_AnnotationSpec>.self, value: &self.annotationColors) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.imageBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.annotationColors.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Datalabeling_V1beta1_AnnotationSpec>.self, value: self.annotationColors, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if !self.imageBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageBytes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_ImageSegmentationAnnotation) -> Bool {
    if lhs.annotationColors != rhs.annotationColors {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.imageBytes != rhs.imageBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextClassificationAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_TextClassificationAnnotation) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextEntityExtractionAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
    2: .standard(proto: "sequential_segment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sequentialSegment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sequentialSegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_TextEntityExtractionAnnotation) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs._sequentialSegment != rhs._sequentialSegment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_SequentialSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SequentialSegment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.end) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_SequentialSegment, rhs: Google_Cloud_Datalabeling_V1beta1_SequentialSegment) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_TimeSegment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSegment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time_offset"),
    2: .standard(proto: "end_time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTimeOffset) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTimeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTimeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_TimeSegment, rhs: Google_Cloud_Datalabeling_V1beta1_TimeSegment) -> Bool {
    if lhs._startTimeOffset != rhs._startTimeOffset {return false}
    if lhs._endTimeOffset != rhs._endTimeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoClassificationAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_segment"),
    2: .standard(proto: "annotation_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeSegment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timeSegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_VideoClassificationAnnotation) -> Bool {
    if lhs._timeSegment != rhs._timeSegment {return false}
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectTrackingFrame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bounding_poly"),
    2: .standard(proto: "normalized_bounding_poly"),
    3: .standard(proto: "time_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Datalabeling_V1beta1_BoundingPoly?
        if let current = self.boundedArea {
          try decoder.handleConflictingOneOf()
          if case .boundingPoly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.boundedArea = .boundingPoly(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_NormalizedBoundingPoly?
        if let current = self.boundedArea {
          try decoder.handleConflictingOneOf()
          if case .normalizedBoundingPoly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.boundedArea = .normalizedBoundingPoly(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.boundedArea {
    case .boundingPoly?: try {
      guard case .boundingPoly(let v)? = self.boundedArea else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .normalizedBoundingPoly?: try {
      guard case .normalizedBoundingPoly(let v)? = self.boundedArea else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._timeOffset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame, rhs: Google_Cloud_Datalabeling_V1beta1_ObjectTrackingFrame) -> Bool {
    if lhs.boundedArea != rhs.boundedArea {return false}
    if lhs._timeOffset != rhs._timeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoObjectTrackingAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
    2: .standard(proto: "time_segment"),
    3: .standard(proto: "object_tracking_frames"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeSegment) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.objectTrackingFrames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeSegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.objectTrackingFrames.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.objectTrackingFrames, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_VideoObjectTrackingAnnotation) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs._timeSegment != rhs._timeSegment {return false}
    if lhs.objectTrackingFrames != rhs.objectTrackingFrames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VideoEventAnnotation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
    2: .standard(proto: "time_segment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeSegment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._timeSegment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation, rhs: Google_Cloud_Datalabeling_V1beta1_VideoEventAnnotation) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs._timeSegment != rhs._timeSegment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "operator_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._operatorMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._operatorMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata, rhs: Google_Cloud_Datalabeling_V1beta1_AnnotationMetadata) -> Bool {
    if lhs._operatorMetadata != rhs._operatorMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_OperatorMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperatorMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "score"),
    2: .standard(proto: "total_votes"),
    3: .standard(proto: "label_votes"),
    4: .same(proto: "comments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.totalVotes) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.labelVotes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.comments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 1)
    }
    if self.totalVotes != 0 {
      try visitor.visitSingularInt32Field(value: self.totalVotes, fieldNumber: 2)
    }
    if self.labelVotes != 0 {
      try visitor.visitSingularInt32Field(value: self.labelVotes, fieldNumber: 3)
    }
    if !self.comments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.comments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_OperatorMetadata, rhs: Google_Cloud_Datalabeling_V1beta1_OperatorMetadata) -> Bool {
    if lhs.score != rhs.score {return false}
    if lhs.totalVotes != rhs.totalVotes {return false}
    if lhs.labelVotes != rhs.labelVotes {return false}
    if lhs.comments != rhs.comments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datalabeling/v1beta1/evaluation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes an evaluation between a machine learning model's predictions and
/// ground truth labels. Created when an [EvaluationJob][google.cloud.datalabeling.v1beta1.EvaluationJob] runs successfully.
public struct Google_Cloud_Datalabeling_V1beta1_Evaluation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Resource name of an evaluation. The name has the following
  /// format:
  ///
  /// "projects/<var>{project_id}</var>/datasets/<var>{dataset_id}</var>/evaluations/<var>{evaluation_id</var>}'
  public var name: String = String()

  /// Output only. Options used in the evaluation job that created this
  /// evaluation.
  public var config: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig {
    get {return _config ?? Google_Cloud_Datalabeling_V1beta1_EvaluationConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {self._config = nil}

  /// Output only. Timestamp for when the evaluation job that created this
  /// evaluation ran.
  public var evaluationJobRunTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _evaluationJobRunTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_evaluationJobRunTime = newValue}
  }
  /// Returns true if `evaluationJobRunTime` has been explicitly set.
  public var hasEvaluationJobRunTime: Bool {return self._evaluationJobRunTime != nil}
  /// Clears the value of `evaluationJobRunTime`. Subsequent reads from it will return its default value.
  public mutating func clearEvaluationJobRunTime() {self._evaluationJobRunTime = nil}

  /// Output only. Timestamp for when this evaluation was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Metrics comparing predictions to ground truth labels.
  public var evaluationMetrics: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics {
    get {return _evaluationMetrics ?? Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics()}
    set {_evaluationMetrics = newValue}
  }
  /// Returns true if `evaluationMetrics` has been explicitly set.
  public var hasEvaluationMetrics: Bool {return self._evaluationMetrics != nil}
  /// Clears the value of `evaluationMetrics`. Subsequent reads from it will return its default value.
  public mutating func clearEvaluationMetrics() {self._evaluationMetrics = nil}

  /// Output only. Type of task that the model version being evaluated performs,
  /// as defined in the
  ///
  /// [evaluationJobConfig.inputConfig.annotationType][google.cloud.datalabeling.v1beta1.EvaluationJobConfig.input_config]
  /// field of the evaluation job that created this evaluation.
  public var annotationType: Google_Cloud_Datalabeling_V1beta1_AnnotationType = .unspecified

  /// Output only. The number of items in the ground truth dataset that were used
  /// for this evaluation. Only populated when the evaulation is for certain
  /// AnnotationTypes.
  public var evaluatedItemCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _config: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig? = nil
  fileprivate var _evaluationJobRunTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _evaluationMetrics: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics? = nil
}

/// Configuration details used for calculating evaluation metrics and creating an
/// [Evaluation][google.cloud.datalabeling.v1beta1.Evaluation].
public struct Google_Cloud_Datalabeling_V1beta1_EvaluationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Vertical specific options for general metrics.
  public var verticalOption: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig.OneOf_VerticalOption? = nil

  /// Only specify this field if the related model performs image object
  /// detection (`IMAGE_BOUNDING_BOX_ANNOTATION`). Describes how to evaluate
  /// bounding boxes.
  public var boundingBoxEvaluationOptions: Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions {
    get {
      if case .boundingBoxEvaluationOptions(let v)? = verticalOption {return v}
      return Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions()
    }
    set {verticalOption = .boundingBoxEvaluationOptions(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Vertical specific options for general metrics.
  public enum OneOf_VerticalOption: Equatable {
    /// Only specify this field if the related model performs image object
    /// detection (`IMAGE_BOUNDING_BOX_ANNOTATION`). Describes how to evaluate
    /// bounding boxes.
    case boundingBoxEvaluationOptions(Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig.OneOf_VerticalOption, rhs: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig.OneOf_VerticalOption) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boundingBoxEvaluationOptions, .boundingBoxEvaluationOptions): return {
        guard case .boundingBoxEvaluationOptions(let l) = lhs, case .boundingBoxEvaluationOptions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Options regarding evaluation between bounding boxes.
public struct Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum
  /// [intersection-over-union
  ///
  /// (IOU)](/vision/automl/object-detection/docs/evaluate#intersection-over-union)
  /// required for 2 bounding boxes to be considered a match. This must be a
  /// number between 0 and 1.
  public var iouThreshold: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Common metrics covering most general cases.
  public var metrics: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics.OneOf_Metrics? = nil

  public var classificationMetrics: Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics {
    get {
      if case .classificationMetrics(let v)? = metrics {return v}
      return Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics()
    }
    set {metrics = .classificationMetrics(newValue)}
  }

  public var objectDetectionMetrics: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics {
    get {
      if case .objectDetectionMetrics(let v)? = metrics {return v}
      return Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics()
    }
    set {metrics = .objectDetectionMetrics(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Common metrics covering most general cases.
  public enum OneOf_Metrics: Equatable {
    case classificationMetrics(Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics)
    case objectDetectionMetrics(Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics.OneOf_Metrics, rhs: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics.OneOf_Metrics) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.classificationMetrics, .classificationMetrics): return {
        guard case .classificationMetrics(let l) = lhs, case .classificationMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.objectDetectionMetrics, .objectDetectionMetrics): return {
        guard case .objectDetectionMetrics(let l) = lhs, case .objectDetectionMetrics(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Metrics calculated for a classification model.
public struct Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Precision-recall curve based on ground truth labels, predicted labels, and
  /// scores for the predicted labels.
  public var prCurve: Google_Cloud_Datalabeling_V1beta1_PrCurve {
    get {return _prCurve ?? Google_Cloud_Datalabeling_V1beta1_PrCurve()}
    set {_prCurve = newValue}
  }
  /// Returns true if `prCurve` has been explicitly set.
  public var hasPrCurve: Bool {return self._prCurve != nil}
  /// Clears the value of `prCurve`. Subsequent reads from it will return its default value.
  public mutating func clearPrCurve() {self._prCurve = nil}

  /// Confusion matrix of predicted labels vs. ground truth labels.
  public var confusionMatrix: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix {
    get {return _confusionMatrix ?? Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix()}
    set {_confusionMatrix = newValue}
  }
  /// Returns true if `confusionMatrix` has been explicitly set.
  public var hasConfusionMatrix: Bool {return self._confusionMatrix != nil}
  /// Clears the value of `confusionMatrix`. Subsequent reads from it will return its default value.
  public mutating func clearConfusionMatrix() {self._confusionMatrix = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prCurve: Google_Cloud_Datalabeling_V1beta1_PrCurve? = nil
  fileprivate var _confusionMatrix: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix? = nil
}

/// Metrics calculated for an image object detection (bounding box) model.
public struct Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Precision-recall curve.
  public var prCurve: Google_Cloud_Datalabeling_V1beta1_PrCurve {
    get {return _prCurve ?? Google_Cloud_Datalabeling_V1beta1_PrCurve()}
    set {_prCurve = newValue}
  }
  /// Returns true if `prCurve` has been explicitly set.
  public var hasPrCurve: Bool {return self._prCurve != nil}
  /// Clears the value of `prCurve`. Subsequent reads from it will return its default value.
  public mutating func clearPrCurve() {self._prCurve = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _prCurve: Google_Cloud_Datalabeling_V1beta1_PrCurve? = nil
}

public struct Google_Cloud_Datalabeling_V1beta1_PrCurve {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The annotation spec of the label for which the precision-recall curve
  /// calculated. If this field is empty, that means the precision-recall curve
  /// is an aggregate curve for all labels.
  public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
    get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
    set {_annotationSpec = newValue}
  }
  /// Returns true if `annotationSpec` has been explicitly set.
  public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
  /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
  public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

  /// Area under the precision-recall curve. Not to be confused with area under
  /// a receiver operating characteristic (ROC) curve.
  public var areaUnderCurve: Float = 0

  /// Entries that make up the precision-recall graph. Each entry is a "point" on
  /// the graph drawn for a different `confidence_threshold`.
  public var confidenceMetricsEntries: [Google_Cloud_Datalabeling_V1beta1_PrCurve.ConfidenceMetricsEntry] = []

  /// Mean average prcision of this curve.
  public var meanAveragePrecision: Float = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ConfidenceMetricsEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Threshold used for this entry.
    ///
    /// For classification tasks, this is a classification threshold: a
    /// predicted label is categorized as positive or negative (in the context of
    /// this point on the PR curve) based on whether the label's score meets this
    /// threshold.
    ///
    /// For image object detection (bounding box) tasks, this is the
    /// [intersection-over-union
    ///
    /// (IOU)](/vision/automl/object-detection/docs/evaluate#intersection-over-union)
    /// threshold for the context of this point on the PR curve.
    public var confidenceThreshold: Float = 0

    /// Recall value.
    public var recall: Float = 0

    /// Precision value.
    public var precision: Float = 0

    /// Harmonic mean of recall and precision.
    public var f1Score: Float = 0

    /// Recall value for entries with label that has highest score.
    public var recallAt1: Float = 0

    /// Precision value for entries with label that has highest score.
    public var precisionAt1: Float = 0

    /// The harmonic mean of [recall_at1][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.recall_at1] and [precision_at1][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.precision_at1].
    public var f1ScoreAt1: Float = 0

    /// Recall value for entries with label that has highest 5 scores.
    public var recallAt5: Float = 0

    /// Precision value for entries with label that has highest 5 scores.
    public var precisionAt5: Float = 0

    /// The harmonic mean of [recall_at5][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.recall_at5] and [precision_at5][google.cloud.datalabeling.v1beta1.PrCurve.ConfidenceMetricsEntry.precision_at5].
    public var f1ScoreAt5: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
}

/// Confusion matrix of the model running the classification. Only applicable
/// when the metrics entry aggregates multiple labels. Not applicable when the
/// entry is for a single label.
public struct Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var row: [Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.Row] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ConfusionMatrixEntry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The annotation spec of a predicted label.
    public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
      get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
      set {_annotationSpec = newValue}
    }
    /// Returns true if `annotationSpec` has been explicitly set.
    public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
    /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
    public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

    /// Number of items predicted to have this label. (The ground truth label for
    /// these items is the `Row.annotationSpec` of this entry's parent.)
    public var itemCount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
  }

  /// A row in the confusion matrix. Each entry in this row has the same
  /// ground truth label.
  public struct Row {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The annotation spec of the ground truth label for this row.
    public var annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec {
      get {return _annotationSpec ?? Google_Cloud_Datalabeling_V1beta1_AnnotationSpec()}
      set {_annotationSpec = newValue}
    }
    /// Returns true if `annotationSpec` has been explicitly set.
    public var hasAnnotationSpec: Bool {return self._annotationSpec != nil}
    /// Clears the value of `annotationSpec`. Subsequent reads from it will return its default value.
    public mutating func clearAnnotationSpec() {self._annotationSpec = nil}

    /// A list of the confusion matrix entries. One entry for each possible
    /// predicted label.
    public var entries: [Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.ConfusionMatrixEntry] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _annotationSpec: Google_Cloud_Datalabeling_V1beta1_AnnotationSpec? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datalabeling.v1beta1"

extension Google_Cloud_Datalabeling_V1beta1_Evaluation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Evaluation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "evaluation_job_run_time"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "evaluation_metrics"),
    6: .standard(proto: "annotation_type"),
    7: .standard(proto: "evaluated_item_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._evaluationJobRunTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._evaluationMetrics) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.annotationType) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.evaluatedItemCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._evaluationJobRunTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._evaluationMetrics {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.annotationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.annotationType, fieldNumber: 6)
    }
    if self.evaluatedItemCount != 0 {
      try visitor.visitSingularInt64Field(value: self.evaluatedItemCount, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_Evaluation, rhs: Google_Cloud_Datalabeling_V1beta1_Evaluation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._config != rhs._config {return false}
    if lhs._evaluationJobRunTime != rhs._evaluationJobRunTime {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._evaluationMetrics != rhs._evaluationMetrics {return false}
    if lhs.annotationType != rhs.annotationType {return false}
    if lhs.evaluatedItemCount != rhs.evaluatedItemCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_EvaluationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvaluationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bounding_box_evaluation_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions?
        if let current = self.verticalOption {
          try decoder.handleConflictingOneOf()
          if case .boundingBoxEvaluationOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.verticalOption = .boundingBoxEvaluationOptions(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .boundingBoxEvaluationOptions(let v)? = self.verticalOption {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig, rhs: Google_Cloud_Datalabeling_V1beta1_EvaluationConfig) -> Bool {
    if lhs.verticalOption != rhs.verticalOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BoundingBoxEvaluationOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "iou_threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.iouThreshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.iouThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.iouThreshold, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions, rhs: Google_Cloud_Datalabeling_V1beta1_BoundingBoxEvaluationOptions) -> Bool {
    if lhs.iouThreshold != rhs.iouThreshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EvaluationMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "classification_metrics"),
    2: .standard(proto: "object_detection_metrics"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics?
        if let current = self.metrics {
          try decoder.handleConflictingOneOf()
          if case .classificationMetrics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.metrics = .classificationMetrics(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics?
        if let current = self.metrics {
          try decoder.handleConflictingOneOf()
          if case .objectDetectionMetrics(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.metrics = .objectDetectionMetrics(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.metrics {
    case .classificationMetrics?: try {
      guard case .classificationMetrics(let v)? = self.metrics else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .objectDetectionMetrics?: try {
      guard case .objectDetectionMetrics(let v)? = self.metrics else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics, rhs: Google_Cloud_Datalabeling_V1beta1_EvaluationMetrics) -> Bool {
    if lhs.metrics != rhs.metrics {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClassificationMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pr_curve"),
    2: .standard(proto: "confusion_matrix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prCurve) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._confusionMatrix) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._prCurve {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._confusionMatrix {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics, rhs: Google_Cloud_Datalabeling_V1beta1_ClassificationMetrics) -> Bool {
    if lhs._prCurve != rhs._prCurve {return false}
    if lhs._confusionMatrix != rhs._confusionMatrix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectDetectionMetrics"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pr_curve"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._prCurve) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._prCurve {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics, rhs: Google_Cloud_Datalabeling_V1beta1_ObjectDetectionMetrics) -> Bool {
    if lhs._prCurve != rhs._prCurve {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_PrCurve: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrCurve"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
    2: .standard(proto: "area_under_curve"),
    3: .standard(proto: "confidence_metrics_entries"),
    4: .standard(proto: "mean_average_precision"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.areaUnderCurve) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.confidenceMetricsEntries) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.meanAveragePrecision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.areaUnderCurve != 0 {
      try visitor.visitSingularFloatField(value: self.areaUnderCurve, fieldNumber: 2)
    }
    if !self.confidenceMetricsEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.confidenceMetricsEntries, fieldNumber: 3)
    }
    if self.meanAveragePrecision != 0 {
      try visitor.visitSingularFloatField(value: self.meanAveragePrecision, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_PrCurve, rhs: Google_Cloud_Datalabeling_V1beta1_PrCurve) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.areaUnderCurve != rhs.areaUnderCurve {return false}
    if lhs.confidenceMetricsEntries != rhs.confidenceMetricsEntries {return false}
    if lhs.meanAveragePrecision != rhs.meanAveragePrecision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_PrCurve.ConfidenceMetricsEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datalabeling_V1beta1_PrCurve.protoMessageName + ".ConfidenceMetricsEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "confidence_threshold"),
    2: .same(proto: "recall"),
    3: .same(proto: "precision"),
    4: .standard(proto: "f1_score"),
    5: .standard(proto: "recall_at1"),
    6: .standard(proto: "precision_at1"),
    7: .standard(proto: "f1_score_at1"),
    8: .standard(proto: "recall_at5"),
    9: .standard(proto: "precision_at5"),
    10: .standard(proto: "f1_score_at5"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.confidenceThreshold) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.recall) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.precision) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.f1Score) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.recallAt1) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.precisionAt1) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.f1ScoreAt1) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.recallAt5) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.precisionAt5) }()
      case 10: try { try decoder.decodeSingularFloatField(value: &self.f1ScoreAt5) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confidenceThreshold != 0 {
      try visitor.visitSingularFloatField(value: self.confidenceThreshold, fieldNumber: 1)
    }
    if self.recall != 0 {
      try visitor.visitSingularFloatField(value: self.recall, fieldNumber: 2)
    }
    if self.precision != 0 {
      try visitor.visitSingularFloatField(value: self.precision, fieldNumber: 3)
    }
    if self.f1Score != 0 {
      try visitor.visitSingularFloatField(value: self.f1Score, fieldNumber: 4)
    }
    if self.recallAt1 != 0 {
      try visitor.visitSingularFloatField(value: self.recallAt1, fieldNumber: 5)
    }
    if self.precisionAt1 != 0 {
      try visitor.visitSingularFloatField(value: self.precisionAt1, fieldNumber: 6)
    }
    if self.f1ScoreAt1 != 0 {
      try visitor.visitSingularFloatField(value: self.f1ScoreAt1, fieldNumber: 7)
    }
    if self.recallAt5 != 0 {
      try visitor.visitSingularFloatField(value: self.recallAt5, fieldNumber: 8)
    }
    if self.precisionAt5 != 0 {
      try visitor.visitSingularFloatField(value: self.precisionAt5, fieldNumber: 9)
    }
    if self.f1ScoreAt5 != 0 {
      try visitor.visitSingularFloatField(value: self.f1ScoreAt5, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_PrCurve.ConfidenceMetricsEntry, rhs: Google_Cloud_Datalabeling_V1beta1_PrCurve.ConfidenceMetricsEntry) -> Bool {
    if lhs.confidenceThreshold != rhs.confidenceThreshold {return false}
    if lhs.recall != rhs.recall {return false}
    if lhs.precision != rhs.precision {return false}
    if lhs.f1Score != rhs.f1Score {return false}
    if lhs.recallAt1 != rhs.recallAt1 {return false}
    if lhs.precisionAt1 != rhs.precisionAt1 {return false}
    if lhs.f1ScoreAt1 != rhs.f1ScoreAt1 {return false}
    if lhs.recallAt5 != rhs.recallAt5 {return false}
    if lhs.precisionAt5 != rhs.precisionAt5 {return false}
    if lhs.f1ScoreAt5 != rhs.f1ScoreAt5 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfusionMatrix"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.row) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.row.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.row, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix, rhs: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix) -> Bool {
    if lhs.row != rhs.row {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.ConfusionMatrixEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.protoMessageName + ".ConfusionMatrixEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
    2: .standard(proto: "item_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.itemCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.itemCount != 0 {
      try visitor.visitSingularInt32Field(value: self.itemCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.ConfusionMatrixEntry, rhs: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.ConfusionMatrixEntry) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.itemCount != rhs.itemCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.protoMessageName + ".Row"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annotation_spec"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._annotationSpec) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._annotationSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.Row, rhs: Google_Cloud_Datalabeling_V1beta1_ConfusionMatrix.Row) -> Bool {
    if lhs._annotationSpec != rhs._annotationSpec {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

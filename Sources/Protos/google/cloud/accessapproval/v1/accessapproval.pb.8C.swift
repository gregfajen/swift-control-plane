// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/accessapproval/v1/accessapproval.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents the type of enrollment for a given service to Access Approval.
public enum Google_Cloud_Accessapproval_V1_EnrollmentLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default value for proto, shouldn't be used.
  case unspecified // = 0

  /// Service is enrolled in Access Approval for all requests
  case blockAll // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .blockAll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .blockAll: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Accessapproval_V1_EnrollmentLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Accessapproval_V1_EnrollmentLevel] = [
    .unspecified,
    .blockAll,
  ]
}

#endif  // swift(>=4.2)

/// Home office and physical location of the principal.
public struct Google_Cloud_Accessapproval_V1_AccessLocations {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The "home office" location of the principal. A two-letter country code
  /// (ISO 3166-1 alpha-2), such as "US", "DE" or "GB" or a region code. In some
  /// limited situations Google systems may refer refer to a region code instead
  /// of a country code.
  /// Possible Region Codes:
  ///
  /// - ASI: Asia
  /// - EUR: Europe
  /// - OCE: Oceania
  /// - AFR: Africa
  /// - NAM: North America
  /// - SAM: South America
  /// - ANT: Antarctica
  /// - ANY: Any location
  public var principalOfficeCountry: String = String()

  /// Physical location of the principal at the time of the access. A
  /// two-letter country code (ISO 3166-1 alpha-2), such as "US", "DE" or "GB" or
  /// a region code. In some limited situations Google systems may refer refer to
  /// a region code instead of a country code.
  /// Possible Region Codes:
  ///
  /// - ASI: Asia
  /// - EUR: Europe
  /// - OCE: Oceania
  /// - AFR: Africa
  /// - NAM: North America
  /// - SAM: South America
  /// - ANT: Antarctica
  /// - ANY: Any location
  public var principalPhysicalLocationCountry: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Accessapproval_V1_AccessReason {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of access justification.
  public var type: Google_Cloud_Accessapproval_V1_AccessReason.TypeEnum = .unspecified

  /// More detail about certain reason types. See comments for each type above.
  public var detail: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of access justification.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value for proto, shouldn't be used.
    case unspecified // = 0

    /// Customer made a request or raised an issue that required the principal to
    /// access customer data. `detail` is of the form ("#####" is the issue ID):
    ///
    /// - "Feedback Report: #####"
    /// - "Case Number: #####"
    /// - "Case ID: #####"
    /// - "E-PIN Reference: #####"
    /// - "Google-#####"
    /// - "T-#####"
    case customerInitiatedSupport // = 1

    /// The principal accessed customer data in order to diagnose or resolve a
    /// suspected issue in services or a known outage. Often this access is used
    /// to confirm that customers are not affected by a suspected service issue
    /// or to remediate a reversible system issue.
    case googleInitiatedService // = 2

    /// Google initiated service for security, fraud, abuse, or compliance
    /// purposes.
    case googleInitiatedReview // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .customerInitiatedSupport
      case 2: self = .googleInitiatedService
      case 3: self = .googleInitiatedReview
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .customerInitiatedSupport: return 1
      case .googleInitiatedService: return 2
      case .googleInitiatedReview: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Accessapproval_V1_AccessReason.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Accessapproval_V1_AccessReason.TypeEnum] = [
    .unspecified,
    .customerInitiatedSupport,
    .googleInitiatedService,
    .googleInitiatedReview,
  ]
}

#endif  // swift(>=4.2)

/// A decision that has been made to approve access to a resource.
public struct Google_Cloud_Accessapproval_V1_ApproveDecision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time at which approval was granted.
  public var approveTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _approveTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_approveTime = newValue}
  }
  /// Returns true if `approveTime` has been explicitly set.
  public var hasApproveTime: Bool {return self._approveTime != nil}
  /// Clears the value of `approveTime`. Subsequent reads from it will return its default value.
  public mutating func clearApproveTime() {self._approveTime = nil}

  /// The time at which the approval expires.
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _approveTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A decision that has been made to dismiss an approval request.
public struct Google_Cloud_Accessapproval_V1_DismissDecision {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time at which the approval request was dismissed.
  public var dismissTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _dismissTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_dismissTime = newValue}
  }
  /// Returns true if `dismissTime` has been explicitly set.
  public var hasDismissTime: Bool {return self._dismissTime != nil}
  /// Clears the value of `dismissTime`. Subsequent reads from it will return its default value.
  public mutating func clearDismissTime() {self._dismissTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dismissTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The properties associated with the resource of the request.
public struct Google_Cloud_Accessapproval_V1_ResourceProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether an approval will exclude the descendants of the resource being
  /// requested.
  public var excludesDescendants: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request for the customer to approve access to a resource.
public struct Google_Cloud_Accessapproval_V1_ApprovalRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the request. Format is
  /// "{projects|folders|organizations}/{id}/approvalRequests/{approval_request_id}".
  public var name: String = String()

  /// The resource for which approval is being requested. The format of the
  /// resource name is defined at
  /// https://cloud.google.com/apis/design/resource_names. The resource name here
  /// may either be a "full" resource name (e.g.
  /// "//library.googleapis.com/shelves/shelf1/books/book2") or a "relative"
  /// resource name (e.g. "shelves/shelf1/books/book2") as described in the
  /// resource name specification.
  public var requestedResourceName: String = String()

  /// Properties related to the resource represented by requested_resource_name.
  public var requestedResourceProperties: Google_Cloud_Accessapproval_V1_ResourceProperties {
    get {return _requestedResourceProperties ?? Google_Cloud_Accessapproval_V1_ResourceProperties()}
    set {_requestedResourceProperties = newValue}
  }
  /// Returns true if `requestedResourceProperties` has been explicitly set.
  public var hasRequestedResourceProperties: Bool {return self._requestedResourceProperties != nil}
  /// Clears the value of `requestedResourceProperties`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedResourceProperties() {self._requestedResourceProperties = nil}

  /// The justification for which approval is being requested.
  public var requestedReason: Google_Cloud_Accessapproval_V1_AccessReason {
    get {return _requestedReason ?? Google_Cloud_Accessapproval_V1_AccessReason()}
    set {_requestedReason = newValue}
  }
  /// Returns true if `requestedReason` has been explicitly set.
  public var hasRequestedReason: Bool {return self._requestedReason != nil}
  /// Clears the value of `requestedReason`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedReason() {self._requestedReason = nil}

  /// The locations for which approval is being requested.
  public var requestedLocations: Google_Cloud_Accessapproval_V1_AccessLocations {
    get {return _requestedLocations ?? Google_Cloud_Accessapproval_V1_AccessLocations()}
    set {_requestedLocations = newValue}
  }
  /// Returns true if `requestedLocations` has been explicitly set.
  public var hasRequestedLocations: Bool {return self._requestedLocations != nil}
  /// Clears the value of `requestedLocations`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedLocations() {self._requestedLocations = nil}

  /// The time at which approval was requested.
  public var requestTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _requestTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_requestTime = newValue}
  }
  /// Returns true if `requestTime` has been explicitly set.
  public var hasRequestTime: Bool {return self._requestTime != nil}
  /// Clears the value of `requestTime`. Subsequent reads from it will return its default value.
  public mutating func clearRequestTime() {self._requestTime = nil}

  /// The requested expiration for the approval. If the request is approved,
  /// access will be granted from the time of approval until the expiration time.
  public var requestedExpiration: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _requestedExpiration ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_requestedExpiration = newValue}
  }
  /// Returns true if `requestedExpiration` has been explicitly set.
  public var hasRequestedExpiration: Bool {return self._requestedExpiration != nil}
  /// Clears the value of `requestedExpiration`. Subsequent reads from it will return its default value.
  public mutating func clearRequestedExpiration() {self._requestedExpiration = nil}

  /// The current decision on the approval request.
  public var decision: Google_Cloud_Accessapproval_V1_ApprovalRequest.OneOf_Decision? = nil

  /// Access was approved.
  public var approve: Google_Cloud_Accessapproval_V1_ApproveDecision {
    get {
      if case .approve(let v)? = decision {return v}
      return Google_Cloud_Accessapproval_V1_ApproveDecision()
    }
    set {decision = .approve(newValue)}
  }

  /// The request was dismissed.
  public var dismiss: Google_Cloud_Accessapproval_V1_DismissDecision {
    get {
      if case .dismiss(let v)? = decision {return v}
      return Google_Cloud_Accessapproval_V1_DismissDecision()
    }
    set {decision = .dismiss(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current decision on the approval request.
  public enum OneOf_Decision: Equatable {
    /// Access was approved.
    case approve(Google_Cloud_Accessapproval_V1_ApproveDecision)
    /// The request was dismissed.
    case dismiss(Google_Cloud_Accessapproval_V1_DismissDecision)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Accessapproval_V1_ApprovalRequest.OneOf_Decision, rhs: Google_Cloud_Accessapproval_V1_ApprovalRequest.OneOf_Decision) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.approve, .approve): return {
        guard case .approve(let l) = lhs, case .approve(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.dismiss, .dismiss): return {
        guard case .dismiss(let l) = lhs, case .dismiss(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _requestedResourceProperties: Google_Cloud_Accessapproval_V1_ResourceProperties? = nil
  fileprivate var _requestedReason: Google_Cloud_Accessapproval_V1_AccessReason? = nil
  fileprivate var _requestedLocations: Google_Cloud_Accessapproval_V1_AccessLocations? = nil
  fileprivate var _requestTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _requestedExpiration: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Represents the enrollment of a cloud resource into a specific service.
public struct Google_Cloud_Accessapproval_V1_EnrolledService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The product for which Access Approval will be enrolled. Allowed values are
  /// listed below (case-sensitive):
  ///
  /// - all
  /// - appengine.googleapis.com
  /// - bigquery.googleapis.com
  /// - bigtable.googleapis.com
  /// - cloudkms.googleapis.com
  /// - compute.googleapis.com
  /// - dataflow.googleapis.com
  /// - iam.googleapis.com
  /// - pubsub.googleapis.com
  /// - storage.googleapis.com
  public var cloudProduct: String = String()

  /// The enrollment level of the service.
  public var enrollmentLevel: Google_Cloud_Accessapproval_V1_EnrollmentLevel = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Settings on a Project/Folder/Organization related to Access Approval.
public struct Google_Cloud_Accessapproval_V1_AccessApprovalSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the settings. Format is one of:
  ///
  /// - "projects/{project_id}/accessApprovalSettings"
  /// - "folders/{folder_id}/accessApprovalSettings"
  /// - "organizations/{organization_id}/accessApprovalSettings"
  public var name: String = String()

  /// A list of email addresses to which notifications relating to approval
  /// requests should be sent. Notifications relating to a resource will be sent
  /// to all emails in the settings of ancestor resources of that resource. A
  /// maximum of 50 email addresses are allowed.
  public var notificationEmails: [String] = []

  /// A list of Google Cloud Services for which the given resource has Access
  /// Approval enrolled. Access requests for the resource given by name against
  /// any of these services contained here will be required to have explicit
  /// approval. If name refers to an organization, enrollment can be done for
  /// individual services. If name refers to a folder or project, enrollment can
  /// only be done on an all or nothing basis.
  ///
  /// If a cloud_product is repeated in this list, the first entry will be
  /// honored and all following entries will be discarded. A maximum of 10
  /// enrolled services will be enforced, to be expanded as the set of supported
  /// services is expanded.
  public var enrolledServices: [Google_Cloud_Accessapproval_V1_EnrolledService] = []

  /// Output only. This field is read only (not settable via
  /// UpdateAccessAccessApprovalSettings method). If the field is true, that
  /// indicates that at least one service is enrolled for Access Approval in one
  /// or more ancestors of the Project or Folder (this field will always be
  /// unset for the organization since organizations do not have ancestors).
  public var enrolledAncestor: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list approval requests.
public struct Google_Cloud_Accessapproval_V1_ListApprovalRequestsMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource. This may be "projects/{project_id}",
  /// "folders/{folder_id}", or "organizations/{organization_id}".
  public var parent: String = String()

  /// A filter on the type of approval requests to retrieve. Must be one of the
  /// following values:
  ///
  /// - [not set]: Requests that are pending or have active approvals.
  /// - ALL: All requests.
  /// - PENDING: Only pending requests.
  /// - ACTIVE: Only active (i.e. currently approved) requests.
  /// - DISMISSED: Only dismissed (including expired) requests.
  public var filter: String = String()

  /// Requested page size.
  public var pageSize: Int32 = 0

  /// A token identifying the page of results to return.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to listing of ApprovalRequest objects.
public struct Google_Cloud_Accessapproval_V1_ListApprovalRequestsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Approval request details.
  public var approvalRequests: [Google_Cloud_Accessapproval_V1_ApprovalRequest] = []

  /// Token to retrieve the next page of results, or empty if there are no more.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get an approval request.
public struct Google_Cloud_Accessapproval_V1_GetApprovalRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the approval request to retrieve.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to approve an ApprovalRequest.
public struct Google_Cloud_Accessapproval_V1_ApproveApprovalRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the approval request to approve.
  public var name: String = String()

  /// The expiration time of this approval.
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request to dismiss an approval request.
public struct Google_Cloud_Accessapproval_V1_DismissApprovalRequestMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the ApprovalRequest to dismiss.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get access approval settings.
public struct Google_Cloud_Accessapproval_V1_GetAccessApprovalSettingsMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the AccessApprovalSettings to retrieve.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to update access approval settings.
public struct Google_Cloud_Accessapproval_V1_UpdateAccessApprovalSettingsMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The new AccessApprovalSettings.
  public var settings: Google_Cloud_Accessapproval_V1_AccessApprovalSettings {
    get {return _settings ?? Google_Cloud_Accessapproval_V1_AccessApprovalSettings()}
    set {_settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  public var hasSettings: Bool {return self._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  public mutating func clearSettings() {self._settings = nil}

  /// The update mask applies to the settings. Only the top level fields of
  /// AccessApprovalSettings (notification_emails & enrolled_services) are
  /// supported. For each field, if it is included, the currently stored value
  /// will be entirely overwritten with the value of the field passed in this
  /// request.
  ///
  /// For the `FieldMask` definition, see
  /// https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#fieldmask
  /// If this field is left unset, only the notification_emails field will be
  /// updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _settings: Google_Cloud_Accessapproval_V1_AccessApprovalSettings? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request to delete access approval settings.
public struct Google_Cloud_Accessapproval_V1_DeleteAccessApprovalSettingsMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the AccessApprovalSettings to delete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.accessapproval.v1"

extension Google_Cloud_Accessapproval_V1_EnrollmentLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENROLLMENT_LEVEL_UNSPECIFIED"),
    1: .same(proto: "BLOCK_ALL"),
  ]
}

extension Google_Cloud_Accessapproval_V1_AccessLocations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessLocations"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "principal_office_country"),
    2: .standard(proto: "principal_physical_location_country"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.principalOfficeCountry) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.principalPhysicalLocationCountry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.principalOfficeCountry.isEmpty {
      try visitor.visitSingularStringField(value: self.principalOfficeCountry, fieldNumber: 1)
    }
    if !self.principalPhysicalLocationCountry.isEmpty {
      try visitor.visitSingularStringField(value: self.principalPhysicalLocationCountry, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_AccessLocations, rhs: Google_Cloud_Accessapproval_V1_AccessLocations) -> Bool {
    if lhs.principalOfficeCountry != rhs.principalOfficeCountry {return false}
    if lhs.principalPhysicalLocationCountry != rhs.principalPhysicalLocationCountry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_AccessReason: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessReason"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "detail"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.detail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_AccessReason, rhs: Google_Cloud_Accessapproval_V1_AccessReason) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_AccessReason.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "CUSTOMER_INITIATED_SUPPORT"),
    2: .same(proto: "GOOGLE_INITIATED_SERVICE"),
    3: .same(proto: "GOOGLE_INITIATED_REVIEW"),
  ]
}

extension Google_Cloud_Accessapproval_V1_ApproveDecision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApproveDecision"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "approve_time"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._approveTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._approveTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_ApproveDecision, rhs: Google_Cloud_Accessapproval_V1_ApproveDecision) -> Bool {
    if lhs._approveTime != rhs._approveTime {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_DismissDecision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DismissDecision"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dismiss_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dismissTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._dismissTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_DismissDecision, rhs: Google_Cloud_Accessapproval_V1_DismissDecision) -> Bool {
    if lhs._dismissTime != rhs._dismissTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_ResourceProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "excludes_descendants"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.excludesDescendants) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.excludesDescendants != false {
      try visitor.visitSingularBoolField(value: self.excludesDescendants, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_ResourceProperties, rhs: Google_Cloud_Accessapproval_V1_ResourceProperties) -> Bool {
    if lhs.excludesDescendants != rhs.excludesDescendants {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_ApprovalRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApprovalRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "requested_resource_name"),
    9: .standard(proto: "requested_resource_properties"),
    3: .standard(proto: "requested_reason"),
    4: .standard(proto: "requested_locations"),
    5: .standard(proto: "request_time"),
    6: .standard(proto: "requested_expiration"),
    7: .same(proto: "approve"),
    8: .same(proto: "dismiss"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestedResourceName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._requestedReason) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._requestedLocations) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._requestTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._requestedExpiration) }()
      case 7: try {
        var v: Google_Cloud_Accessapproval_V1_ApproveDecision?
        if let current = self.decision {
          try decoder.handleConflictingOneOf()
          if case .approve(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.decision = .approve(v)}
      }()
      case 8: try {
        var v: Google_Cloud_Accessapproval_V1_DismissDecision?
        if let current = self.decision {
          try decoder.handleConflictingOneOf()
          if case .dismiss(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.decision = .dismiss(v)}
      }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._requestedResourceProperties) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.requestedResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.requestedResourceName, fieldNumber: 2)
    }
    if let v = self._requestedReason {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._requestedLocations {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._requestTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._requestedExpiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.decision {
    case .approve?: try {
      guard case .approve(let v)? = self.decision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .dismiss?: try {
      guard case .dismiss(let v)? = self.decision else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case nil: break
    }
    if let v = self._requestedResourceProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_ApprovalRequest, rhs: Google_Cloud_Accessapproval_V1_ApprovalRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.requestedResourceName != rhs.requestedResourceName {return false}
    if lhs._requestedResourceProperties != rhs._requestedResourceProperties {return false}
    if lhs._requestedReason != rhs._requestedReason {return false}
    if lhs._requestedLocations != rhs._requestedLocations {return false}
    if lhs._requestTime != rhs._requestTime {return false}
    if lhs._requestedExpiration != rhs._requestedExpiration {return false}
    if lhs.decision != rhs.decision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_EnrolledService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EnrolledService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_product"),
    2: .standard(proto: "enrollment_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cloudProduct) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.enrollmentLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cloudProduct.isEmpty {
      try visitor.visitSingularStringField(value: self.cloudProduct, fieldNumber: 1)
    }
    if self.enrollmentLevel != .unspecified {
      try visitor.visitSingularEnumField(value: self.enrollmentLevel, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_EnrolledService, rhs: Google_Cloud_Accessapproval_V1_EnrolledService) -> Bool {
    if lhs.cloudProduct != rhs.cloudProduct {return false}
    if lhs.enrollmentLevel != rhs.enrollmentLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_AccessApprovalSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessApprovalSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "notification_emails"),
    3: .standard(proto: "enrolled_services"),
    4: .standard(proto: "enrolled_ancestor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.notificationEmails) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.enrolledServices) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enrolledAncestor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.notificationEmails.isEmpty {
      try visitor.visitRepeatedStringField(value: self.notificationEmails, fieldNumber: 2)
    }
    if !self.enrolledServices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.enrolledServices, fieldNumber: 3)
    }
    if self.enrolledAncestor != false {
      try visitor.visitSingularBoolField(value: self.enrolledAncestor, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_AccessApprovalSettings, rhs: Google_Cloud_Accessapproval_V1_AccessApprovalSettings) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.notificationEmails != rhs.notificationEmails {return false}
    if lhs.enrolledServices != rhs.enrolledServices {return false}
    if lhs.enrolledAncestor != rhs.enrolledAncestor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_ListApprovalRequestsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListApprovalRequestsMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_ListApprovalRequestsMessage, rhs: Google_Cloud_Accessapproval_V1_ListApprovalRequestsMessage) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_ListApprovalRequestsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListApprovalRequestsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "approval_requests"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.approvalRequests) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.approvalRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.approvalRequests, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_ListApprovalRequestsResponse, rhs: Google_Cloud_Accessapproval_V1_ListApprovalRequestsResponse) -> Bool {
    if lhs.approvalRequests != rhs.approvalRequests {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_GetApprovalRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetApprovalRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_GetApprovalRequestMessage, rhs: Google_Cloud_Accessapproval_V1_GetApprovalRequestMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_ApproveApprovalRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApproveApprovalRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_ApproveApprovalRequestMessage, rhs: Google_Cloud_Accessapproval_V1_ApproveApprovalRequestMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_DismissApprovalRequestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DismissApprovalRequestMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_DismissApprovalRequestMessage, rhs: Google_Cloud_Accessapproval_V1_DismissApprovalRequestMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_GetAccessApprovalSettingsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccessApprovalSettingsMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_GetAccessApprovalSettingsMessage, rhs: Google_Cloud_Accessapproval_V1_GetAccessApprovalSettingsMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_UpdateAccessApprovalSettingsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAccessApprovalSettingsMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_UpdateAccessApprovalSettingsMessage, rhs: Google_Cloud_Accessapproval_V1_UpdateAccessApprovalSettingsMessage) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Accessapproval_V1_DeleteAccessApprovalSettingsMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteAccessApprovalSettingsMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Accessapproval_V1_DeleteAccessApprovalSettingsMessage, rhs: Google_Cloud_Accessapproval_V1_DeleteAccessApprovalSettingsMessage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

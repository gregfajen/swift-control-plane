// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/recaptchaenterprise/v1beta1/recaptchaenterprise.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The create assessment request message.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_CreateAssessmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which the assessment will be created,
  /// in the format "projects/{project_number}".
  public var parent: String = String()

  /// Required. The assessment details.
  public var assessment: Google_Cloud_Recaptchaenterprise_V1beta1_Assessment {
    get {return _assessment ?? Google_Cloud_Recaptchaenterprise_V1beta1_Assessment()}
    set {_assessment = newValue}
  }
  /// Returns true if `assessment` has been explicitly set.
  public var hasAssessment: Bool {return self._assessment != nil}
  /// Clears the value of `assessment`. Subsequent reads from it will return its default value.
  public mutating func clearAssessment() {self._assessment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _assessment: Google_Cloud_Recaptchaenterprise_V1beta1_Assessment? = nil
}

/// The request message to annotate an Assessment.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the Assessment, in the format
  /// "projects/{project_number}/assessments/{assessment_id}".
  public var name: String = String()

  /// Required. The annotation that will be assigned to the Event.
  public var annotation: Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest.Annotation = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enum that reprensents the types of annotations.
  public enum Annotation: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default unspecified type.
    case unspecified // = 0

    /// Provides information that the event turned out to be legitimate.
    case legitimate // = 1

    /// Provides information that the event turned out to be fraudulent.
    case fraudulent // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .legitimate
      case 2: self = .fraudulent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .legitimate: return 1
      case .fraudulent: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest.Annotation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest.Annotation] = [
    .unspecified,
    .legitimate,
    .fraudulent,
  ]
}

#endif  // swift(>=4.2)

/// Empty response for AnnotateAssessment.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A recaptcha assessment resource.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_Assessment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name for the Assessment in the format
  /// "projects/{project_number}/assessments/{assessment_id}".
  public var name: String = String()

  /// The event being assessed.
  public var event: Google_Cloud_Recaptchaenterprise_V1beta1_Event {
    get {return _event ?? Google_Cloud_Recaptchaenterprise_V1beta1_Event()}
    set {_event = newValue}
  }
  /// Returns true if `event` has been explicitly set.
  public var hasEvent: Bool {return self._event != nil}
  /// Clears the value of `event`. Subsequent reads from it will return its default value.
  public mutating func clearEvent() {self._event = nil}

  /// Output only. Legitimate event score from 0.0 to 1.0.
  /// (1.0 means very likely legitimate traffic while 0.0 means very likely
  /// non-legitimate traffic).
  public var score: Float = 0

  /// Output only. Properties of the provided event token.
  public var tokenProperties: Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties {
    get {return _tokenProperties ?? Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties()}
    set {_tokenProperties = newValue}
  }
  /// Returns true if `tokenProperties` has been explicitly set.
  public var hasTokenProperties: Bool {return self._tokenProperties != nil}
  /// Clears the value of `tokenProperties`. Subsequent reads from it will return its default value.
  public mutating func clearTokenProperties() {self._tokenProperties = nil}

  /// Output only. Reasons contributing to the risk analysis verdict.
  public var reasons: [Google_Cloud_Recaptchaenterprise_V1beta1_Assessment.ClassificationReason] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// LINT.IfChange(classification_reason)
  /// Reasons contributing to the risk analysis verdict.
  public enum ClassificationReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default unspecified type.
    case unspecified // = 0

    /// Interactions matched the behavior of an automated agent.
    case automation // = 1

    /// The event originated from an illegitimate environment.
    case unexpectedEnvironment // = 2

    /// Traffic volume from the event source is higher than normal.
    case tooMuchTraffic // = 3

    /// Interactions with the site were significantly different than expected
    /// patterns.
    case unexpectedUsagePatterns // = 4

    /// Too little traffic has been received from this site thus far to generate
    /// quality risk analysis.
    case lowConfidenceScore // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .automation
      case 2: self = .unexpectedEnvironment
      case 3: self = .tooMuchTraffic
      case 4: self = .unexpectedUsagePatterns
      case 5: self = .lowConfidenceScore
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .automation: return 1
      case .unexpectedEnvironment: return 2
      case .tooMuchTraffic: return 3
      case .unexpectedUsagePatterns: return 4
      case .lowConfidenceScore: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _event: Google_Cloud_Recaptchaenterprise_V1beta1_Event? = nil
  fileprivate var _tokenProperties: Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Recaptchaenterprise_V1beta1_Assessment.ClassificationReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recaptchaenterprise_V1beta1_Assessment.ClassificationReason] = [
    .unspecified,
    .automation,
    .unexpectedEnvironment,
    .tooMuchTraffic,
    .unexpectedUsagePatterns,
    .lowConfidenceScore,
  ]
}

#endif  // swift(>=4.2)

public struct Google_Cloud_Recaptchaenterprise_V1beta1_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. The user response token provided by the reCAPTCHA client-side integration
  /// on your site.
  public var token: String = String()

  /// Optional. The site key that was used to invoke reCAPTCHA on your site and generate
  /// the token.
  public var siteKey: String = String()

  /// Optional. The user agent present in the request from the user's device related to
  /// this event.
  public var userAgent: String = String()

  /// Optional. The IP address in the request from the user's device related to this event.
  public var userIpAddress: String = String()

  /// Optional. The expected action for this type of event. This should be the same action
  /// provided at token generation time on client-side platforms already
  /// integrated with recaptcha enterprise.
  public var expectedAction: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the provided user response token is valid.
  public var valid: Bool = false

  /// Reason associated with the response when valid = false.
  public var invalidReason: Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties.InvalidReason = .unspecified

  /// The timestamp corresponding to the generation of the token.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// The hostname of the page on which the token was generated.
  public var hostname: String = String()

  /// Action name provided at token generation.
  public var action: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// LINT.IfChange
  /// Enum that represents the types of invalid token reasons.
  public enum InvalidReason: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default unspecified type.
    case unspecified // = 0

    /// If the failure reason was not accounted for.
    case unknownInvalidReason // = 1

    /// The provided user verification token was malformed.
    case malformed // = 2

    /// The user verification token had expired.
    case expired // = 3

    /// The user verification had already been seen.
    case dupe // = 4

    /// The user verification token did not match the provided site key.
    /// This may be a configuration error (e.g. development keys used in
    /// production) or end users trying to use verification tokens from other
    /// sites.
    case siteMismatch // = 5

    /// The user verification token was not present.  It is a required input.
    case missing // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unknownInvalidReason
      case 2: self = .malformed
      case 3: self = .expired
      case 4: self = .dupe
      case 5: self = .siteMismatch
      case 6: self = .missing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unknownInvalidReason: return 1
      case .malformed: return 2
      case .expired: return 3
      case .dupe: return 4
      case .siteMismatch: return 5
      case .missing: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties.InvalidReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties.InvalidReason] = [
    .unspecified,
    .unknownInvalidReason,
    .malformed,
    .expired,
    .dupe,
    .siteMismatch,
    .missing,
  ]
}

#endif  // swift(>=4.2)

/// The create key request message.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_CreateKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which the key will be created, in the
  /// format "projects/{project_number}".
  public var parent: String = String()

  /// Required. Information to create a reCAPTCHA Enterprise key.
  public var key: Google_Cloud_Recaptchaenterprise_V1beta1_Key {
    get {return _key ?? Google_Cloud_Recaptchaenterprise_V1beta1_Key()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Google_Cloud_Recaptchaenterprise_V1beta1_Key? = nil
}

/// The list keys request message.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project that contains the keys that will be
  /// listed, in the format "projects/{project_number}".
  public var parent: String = String()

  /// Optional. The maximum number of keys to return. Default is 10. Max limit is
  /// 1000.
  public var pageSize: Int32 = 0

  /// Optional. The next_page_token value returned from a previous.
  /// ListKeysRequest, if any.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to request to list keys in a project.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key details.
  public var keys: [Google_Cloud_Recaptchaenterprise_V1beta1_Key] = []

  /// Token to retrieve the next page of results. It is set to empty if no keys
  /// remain in results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The get key request message.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_GetKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the requested key, in the format
  /// "projects/{project_number}/keys/{key_id}".
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The update key request message.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_UpdateKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The key to update.
  public var key: Google_Cloud_Recaptchaenterprise_V1beta1_Key {
    get {return _key ?? Google_Cloud_Recaptchaenterprise_V1beta1_Key()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  public var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  public mutating func clearKey() {self._key = nil}

  /// Optional. The mask to control which field of the key get updated. If the mask is not
  /// present, all fields will be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _key: Google_Cloud_Recaptchaenterprise_V1beta1_Key? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The delete key request message.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_DeleteKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the key to be deleted, in the format
  /// "projects/{project_number}/keys/{key_id}".
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A key used to identify and configure applications (web and/or mobile) that
/// use reCAPTCHA Enterprise.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name for the Key in the format
  /// "projects/{project_number}/keys/{key_id}".
  public var name: String = String()

  /// Human-readable display name of this key. Modifiable by user.
  public var displayName: String = String()

  /// Platform specific settings for this key. The key can only be used on one
  /// platform, the one it has settings for.
  public var platformSettings: Google_Cloud_Recaptchaenterprise_V1beta1_Key.OneOf_PlatformSettings? = nil

  /// Settings for keys that can be used by websites.
  public var webSettings: Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings {
    get {
      if case .webSettings(let v)? = platformSettings {return v}
      return Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings()
    }
    set {platformSettings = .webSettings(newValue)}
  }

  /// Settings for keys that can be used by Android apps.
  public var androidSettings: Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings {
    get {
      if case .androidSettings(let v)? = platformSettings {return v}
      return Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings()
    }
    set {platformSettings = .androidSettings(newValue)}
  }

  /// Settings for keys that can be used by iOS apps.
  public var iosSettings: Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings {
    get {
      if case .iosSettings(let v)? = platformSettings {return v}
      return Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings()
    }
    set {platformSettings = .iosSettings(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Platform specific settings for this key. The key can only be used on one
  /// platform, the one it has settings for.
  public enum OneOf_PlatformSettings: Equatable {
    /// Settings for keys that can be used by websites.
    case webSettings(Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings)
    /// Settings for keys that can be used by Android apps.
    case androidSettings(Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings)
    /// Settings for keys that can be used by iOS apps.
    case iosSettings(Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_Key.OneOf_PlatformSettings, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_Key.OneOf_PlatformSettings) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.webSettings, .webSettings): return {
        guard case .webSettings(let l) = lhs, case .webSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.androidSettings, .androidSettings): return {
        guard case .androidSettings(let l) = lhs, case .androidSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.iosSettings, .iosSettings): return {
        guard case .iosSettings(let l) = lhs, case .iosSettings(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Settings specific to keys that can be used by websites.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether allowed_domains is enforced or not.
  public var enforceAllowedDomains: Bool = false

  /// Domains or subdomains of websites allowed to use the key. All subdomains
  /// of an allowed domain are automatically allowed. A valid domain requires a
  /// host and must not include any path, port, query or fragment.
  /// Examples: 'example.com' or 'subdomain.example.com'
  public var allowedDomains: [String] = []

  /// Whether this key can be used on AMP (Accelerated Mobile Pages) websites.
  public var allowAmpTraffic: Bool = false

  /// Required. Describes how this key is integrated with the website.
  public var integrationType: Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.IntegrationType = .unspecified

  /// Settings for the frequency and difficulty at which this key triggers
  /// captcha challenges. This should only be specified for IntegrationTypes
  /// CHECKBOX_CHALLENGE and INVISIBLE_CHALLENGE.
  public var challengeSecurityPreference: Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.ChallengeSecurityPreference = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enum that represents the integration types for web keys.
  public enum IntegrationType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default type that indicates this enum hasn't been specified. This is not
    /// a valid IntegrationType, one of the other types must be specified
    /// instead.
    case unspecified // = 0

    /// Only used to produce scores. It doesn't display the "I'm not a robot"
    /// checkbox and never shows captcha challenges.
    case scoreOnly // = 1

    /// Displays the "I'm not a robot" checkbox and may show captcha challenges
    /// after it is checked.
    case checkboxChallenge // = 2

    /// Doesn't display the "I'm not a robot" checkbox, but may show captcha
    /// challenges after risk analysis.
    case invisibleChallenge // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .scoreOnly
      case 2: self = .checkboxChallenge
      case 3: self = .invisibleChallenge
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .scoreOnly: return 1
      case .checkboxChallenge: return 2
      case .invisibleChallenge: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Enum that represents the possible challenge frequency and difficulty
  /// configurations for a web key.
  public enum ChallengeSecurityPreference: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default type that indicates this enum hasn't been specified.
    case unspecified // = 0

    /// Key tends to show fewer and easier challenges.
    case usability // = 1

    /// Key tends to show balanced (in amount and difficulty) challenges.
    case balanced // = 2

    /// Key tends to show more and harder challenges.
    case security // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .usability
      case 2: self = .balanced
      case 3: self = .security
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .usability: return 1
      case .balanced: return 2
      case .security: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.IntegrationType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.IntegrationType] = [
    .unspecified,
    .scoreOnly,
    .checkboxChallenge,
    .invisibleChallenge,
  ]
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.ChallengeSecurityPreference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.ChallengeSecurityPreference] = [
    .unspecified,
    .usability,
    .balanced,
    .security,
  ]
}

#endif  // swift(>=4.2)

/// Settings specific to keys that can be used by Android apps.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Android package names of apps allowed to use the key.
  /// Example: 'com.companyname.appname'
  public var allowedPackageNames: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Settings specific to keys that can be used by iOS apps.
public struct Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// iOS bundle ids of apps allowed to use the key.
  /// Example: 'com.companyname.productname.appname'
  public var allowedBundleIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.recaptchaenterprise.v1beta1"

extension Google_Cloud_Recaptchaenterprise_V1beta1_CreateAssessmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateAssessmentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "assessment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._assessment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._assessment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_CreateAssessmentRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_CreateAssessmentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._assessment != rhs._assessment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotateAssessmentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "annotation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.annotation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.annotation != .unspecified {
      try visitor.visitSingularEnumField(value: self.annotation, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.annotation != rhs.annotation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentRequest.Annotation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ANNOTATION_UNSPECIFIED"),
    1: .same(proto: "LEGITIMATE"),
    2: .same(proto: "FRAUDULENT"),
  ]
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnnotateAssessmentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentResponse, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_AnnotateAssessmentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_Assessment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Assessment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "event"),
    3: .same(proto: "score"),
    4: .standard(proto: "token_properties"),
    5: .same(proto: "reasons"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._event) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.score) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenProperties) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.reasons) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._event {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.score != 0 {
      try visitor.visitSingularFloatField(value: self.score, fieldNumber: 3)
    }
    if let v = self._tokenProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.reasons.isEmpty {
      try visitor.visitPackedEnumField(value: self.reasons, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_Assessment, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_Assessment) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._event != rhs._event {return false}
    if lhs.score != rhs.score {return false}
    if lhs._tokenProperties != rhs._tokenProperties {return false}
    if lhs.reasons != rhs.reasons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_Assessment.ClassificationReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CLASSIFICATION_REASON_UNSPECIFIED"),
    1: .same(proto: "AUTOMATION"),
    2: .same(proto: "UNEXPECTED_ENVIRONMENT"),
    3: .same(proto: "TOO_MUCH_TRAFFIC"),
    4: .same(proto: "UNEXPECTED_USAGE_PATTERNS"),
    5: .same(proto: "LOW_CONFIDENCE_SCORE"),
  ]
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Event"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "token"),
    2: .standard(proto: "site_key"),
    3: .standard(proto: "user_agent"),
    4: .standard(proto: "user_ip_address"),
    5: .standard(proto: "expected_action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.siteKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userIpAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.expectedAction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 1)
    }
    if !self.siteKey.isEmpty {
      try visitor.visitSingularStringField(value: self.siteKey, fieldNumber: 2)
    }
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 3)
    }
    if !self.userIpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.userIpAddress, fieldNumber: 4)
    }
    if !self.expectedAction.isEmpty {
      try visitor.visitSingularStringField(value: self.expectedAction, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_Event, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_Event) -> Bool {
    if lhs.token != rhs.token {return false}
    if lhs.siteKey != rhs.siteKey {return false}
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.userIpAddress != rhs.userIpAddress {return false}
    if lhs.expectedAction != rhs.expectedAction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "valid"),
    2: .standard(proto: "invalid_reason"),
    3: .standard(proto: "create_time"),
    4: .same(proto: "hostname"),
    5: .same(proto: "action"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.valid) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.invalidReason) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.action) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.valid != false {
      try visitor.visitSingularBoolField(value: self.valid, fieldNumber: 1)
    }
    if self.invalidReason != .unspecified {
      try visitor.visitSingularEnumField(value: self.invalidReason, fieldNumber: 2)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 4)
    }
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties) -> Bool {
    if lhs.valid != rhs.valid {return false}
    if lhs.invalidReason != rhs.invalidReason {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_TokenProperties.InvalidReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID_REASON_UNSPECIFIED"),
    1: .same(proto: "UNKNOWN_INVALID_REASON"),
    2: .same(proto: "MALFORMED"),
    3: .same(proto: "EXPIRED"),
    4: .same(proto: "DUPE"),
    5: .same(proto: "SITE_MISMATCH"),
    6: .same(proto: "MISSING"),
  ]
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_CreateKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_CreateKeyRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_CreateKeyRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._key != rhs._key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysResponse, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_ListKeysResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_GetKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_GetKeyRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_GetKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_UpdateKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._key {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_UpdateKeyRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_UpdateKeyRequest) -> Bool {
    if lhs._key != rhs._key {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_DeleteKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_DeleteKeyRequest, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_DeleteKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "web_settings"),
    4: .standard(proto: "android_settings"),
    5: .standard(proto: "ios_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try {
        var v: Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings?
        if let current = self.platformSettings {
          try decoder.handleConflictingOneOf()
          if case .webSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.platformSettings = .webSettings(v)}
      }()
      case 4: try {
        var v: Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings?
        if let current = self.platformSettings {
          try decoder.handleConflictingOneOf()
          if case .androidSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.platformSettings = .androidSettings(v)}
      }()
      case 5: try {
        var v: Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings?
        if let current = self.platformSettings {
          try decoder.handleConflictingOneOf()
          if case .iosSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.platformSettings = .iosSettings(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.platformSettings {
    case .webSettings?: try {
      guard case .webSettings(let v)? = self.platformSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .androidSettings?: try {
      guard case .androidSettings(let v)? = self.platformSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .iosSettings?: try {
      guard case .iosSettings(let v)? = self.platformSettings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_Key, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_Key) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.platformSettings != rhs.platformSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebKeySettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "enforce_allowed_domains"),
    1: .standard(proto: "allowed_domains"),
    2: .standard(proto: "allow_amp_traffic"),
    4: .standard(proto: "integration_type"),
    5: .standard(proto: "challenge_security_preference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedDomains) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowAmpTraffic) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enforceAllowedDomains) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.integrationType) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.challengeSecurityPreference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedDomains.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedDomains, fieldNumber: 1)
    }
    if self.allowAmpTraffic != false {
      try visitor.visitSingularBoolField(value: self.allowAmpTraffic, fieldNumber: 2)
    }
    if self.enforceAllowedDomains != false {
      try visitor.visitSingularBoolField(value: self.enforceAllowedDomains, fieldNumber: 3)
    }
    if self.integrationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.integrationType, fieldNumber: 4)
    }
    if self.challengeSecurityPreference != .unspecified {
      try visitor.visitSingularEnumField(value: self.challengeSecurityPreference, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings) -> Bool {
    if lhs.enforceAllowedDomains != rhs.enforceAllowedDomains {return false}
    if lhs.allowedDomains != rhs.allowedDomains {return false}
    if lhs.allowAmpTraffic != rhs.allowAmpTraffic {return false}
    if lhs.integrationType != rhs.integrationType {return false}
    if lhs.challengeSecurityPreference != rhs.challengeSecurityPreference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.IntegrationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INTEGRATION_TYPE_UNSPECIFIED"),
    1: .same(proto: "SCORE_ONLY"),
    2: .same(proto: "CHECKBOX_CHALLENGE"),
    3: .same(proto: "INVISIBLE_CHALLENGE"),
  ]
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_WebKeySettings.ChallengeSecurityPreference: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED"),
    1: .same(proto: "USABILITY"),
    2: .same(proto: "BALANCED"),
    3: .same(proto: "SECURITY"),
  ]
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AndroidKeySettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_package_names"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedPackageNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedPackageNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedPackageNames, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_AndroidKeySettings) -> Bool {
    if lhs.allowedPackageNames != rhs.allowedPackageNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IOSKeySettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_bundle_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedBundleIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedBundleIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedBundleIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings, rhs: Google_Cloud_Recaptchaenterprise_V1beta1_IOSKeySettings) -> Bool {
    if lhs.allowedBundleIds != rhs.allowedBundleIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

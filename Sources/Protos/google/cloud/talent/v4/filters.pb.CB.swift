// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/talent/v4/filters.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The query required to perform a search query.
public struct Google_Cloud_Talent_V4_JobQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The query string that matches against the job title, description, and
  /// location fields.
  ///
  /// The maximum number of allowed characters is 255.
  public var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// The language code of [query][google.cloud.talent.v4.JobQuery.query]. For example, "en-US". This field helps to
  /// better interpret the query.
  ///
  /// If a value isn't specified, the query language code is automatically
  /// detected, which may not be accurate.
  ///
  /// Language code should be in BCP-47 format, such as "en-US" or "sr-Latn".
  /// For more information, see
  /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
  public var queryLanguageCode: String {
    get {return _storage._queryLanguageCode}
    set {_uniqueStorage()._queryLanguageCode = newValue}
  }

  /// This filter specifies the company entities to search against.
  ///
  /// If a value isn't specified, jobs are searched for against all
  /// companies.
  ///
  /// If multiple values are specified, jobs are searched against the
  /// companies specified.
  ///
  /// The format is
  /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
  /// example, "projects/foo/tenants/bar/companies/baz".
  ///
  /// At most 20 company filters are allowed.
  public var companies: [String] {
    get {return _storage._companies}
    set {_uniqueStorage()._companies = newValue}
  }

  /// The location filter specifies geo-regions containing the jobs to
  /// search against. See [LocationFilter][google.cloud.talent.v4.LocationFilter] for more information.
  ///
  /// If a location value isn't specified, jobs fitting the other search
  /// criteria are retrieved regardless of where they're located.
  ///
  /// If multiple values are specified, jobs are retrieved from any of the
  /// specified locations. If different values are specified for the
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4.LocationFilter.distance_in_miles] parameter, the maximum provided
  /// distance is used for all locations.
  ///
  /// At most 5 location filters are allowed.
  public var locationFilters: [Google_Cloud_Talent_V4_LocationFilter] {
    get {return _storage._locationFilters}
    set {_uniqueStorage()._locationFilters = newValue}
  }

  /// The category filter specifies the categories of jobs to search against.
  /// See [JobCategory][google.cloud.talent.v4.JobCategory] for more information.
  ///
  /// If a value isn't specified, jobs from any category are searched against.
  ///
  /// If multiple values are specified, jobs from any of the specified
  /// categories are searched against.
  public var jobCategories: [Google_Cloud_Talent_V4_JobCategory] {
    get {return _storage._jobCategories}
    set {_uniqueStorage()._jobCategories = newValue}
  }

  /// Allows filtering jobs by commute time with different travel methods (for
  ///  example, driving or public transit).
  ///
  /// Note: This only works when you specify a [CommuteMethod][google.cloud.talent.v4.CommuteMethod]. In this case,
  /// [location_filters][google.cloud.talent.v4.JobQuery.location_filters] is ignored.
  ///
  ///  Currently we don't support sorting by commute time.
  public var commuteFilter: Google_Cloud_Talent_V4_CommuteFilter {
    get {return _storage._commuteFilter ?? Google_Cloud_Talent_V4_CommuteFilter()}
    set {_uniqueStorage()._commuteFilter = newValue}
  }
  /// Returns true if `commuteFilter` has been explicitly set.
  public var hasCommuteFilter: Bool {return _storage._commuteFilter != nil}
  /// Clears the value of `commuteFilter`. Subsequent reads from it will return its default value.
  public mutating func clearCommuteFilter() {_uniqueStorage()._commuteFilter = nil}

  /// This filter specifies the exact company [Company.display_name][google.cloud.talent.v4.Company.display_name]
  /// of the jobs to search against.
  ///
  /// If a value isn't specified, jobs within the search results are
  /// associated with any company.
  ///
  /// If multiple values are specified, jobs within the search results may be
  /// associated with any of the specified companies.
  ///
  /// At most 20 company display name filters are allowed.
  public var companyDisplayNames: [String] {
    get {return _storage._companyDisplayNames}
    set {_uniqueStorage()._companyDisplayNames = newValue}
  }

  /// This search filter is applied only to
  /// [Job.compensation_info][google.cloud.talent.v4.Job.compensation_info]. For example, if the filter is specified
  /// as "Hourly job with per-hour compensation > $15", only jobs meeting
  /// these criteria are searched. If a filter isn't defined, all open jobs
  /// are searched.
  public var compensationFilter: Google_Cloud_Talent_V4_CompensationFilter {
    get {return _storage._compensationFilter ?? Google_Cloud_Talent_V4_CompensationFilter()}
    set {_uniqueStorage()._compensationFilter = newValue}
  }
  /// Returns true if `compensationFilter` has been explicitly set.
  public var hasCompensationFilter: Bool {return _storage._compensationFilter != nil}
  /// Clears the value of `compensationFilter`. Subsequent reads from it will return its default value.
  public mutating func clearCompensationFilter() {_uniqueStorage()._compensationFilter = nil}

  /// This filter specifies a structured syntax to match against the
  /// [Job.custom_attributes][google.cloud.talent.v4.Job.custom_attributes] marked as `filterable`.
  ///
  /// The syntax for this expression is a subset of SQL syntax.
  ///
  /// Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the
  /// left of the operator is a custom field key and the right of the operator
  /// is a number or a quoted string. You must escape backslash (\\) and
  /// quote (\") characters.
  ///
  /// Supported functions are `LOWER([field_name])` to
  /// perform a case insensitive match and `EMPTY([field_name])` to filter on the
  /// existence of a key.
  ///
  /// Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
  /// nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
  /// comparisons or functions are allowed in the expression. The expression
  /// must be < 6000 bytes in length.
  ///
  /// Sample Query:
  /// `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
  /// driving_years > 10`
  public var customAttributeFilter: String {
    get {return _storage._customAttributeFilter}
    set {_uniqueStorage()._customAttributeFilter = newValue}
  }

  /// This flag controls the spell-check feature. If false, the
  /// service attempts to correct a misspelled query,
  /// for example, "enginee" is corrected to "engineer".
  ///
  /// Defaults to false: a spell check is performed.
  public var disableSpellCheck: Bool {
    get {return _storage._disableSpellCheck}
    set {_uniqueStorage()._disableSpellCheck = newValue}
  }

  /// The employment type filter specifies the employment type of jobs to
  /// search against, such as [EmploymentType.FULL_TIME][google.cloud.talent.v4.EmploymentType.FULL_TIME].
  ///
  /// If a value isn't specified, jobs in the search results includes any
  /// employment type.
  ///
  /// If multiple values are specified, jobs in the search results include
  /// any of the specified employment types.
  public var employmentTypes: [Google_Cloud_Talent_V4_EmploymentType] {
    get {return _storage._employmentTypes}
    set {_uniqueStorage()._employmentTypes = newValue}
  }

  /// This filter specifies the locale of jobs to search against,
  /// for example, "en-US".
  ///
  /// If a value isn't specified, the search results can contain jobs in any
  /// locale.
  ///
  ///
  /// Language codes should be in BCP-47 format, such as "en-US" or "sr-Latn".
  /// For more information, see
  /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
  ///
  /// At most 10 language code filters are allowed.
  public var languageCodes: [String] {
    get {return _storage._languageCodes}
    set {_uniqueStorage()._languageCodes = newValue}
  }

  /// Jobs published within a range specified by this filter are searched
  /// against.
  public var publishTimeRange: Google_Cloud_Talent_V4_TimestampRange {
    get {return _storage._publishTimeRange ?? Google_Cloud_Talent_V4_TimestampRange()}
    set {_uniqueStorage()._publishTimeRange = newValue}
  }
  /// Returns true if `publishTimeRange` has been explicitly set.
  public var hasPublishTimeRange: Bool {return _storage._publishTimeRange != nil}
  /// Clears the value of `publishTimeRange`. Subsequent reads from it will return its default value.
  public mutating func clearPublishTimeRange() {_uniqueStorage()._publishTimeRange = nil}

  /// This filter specifies a list of job names to be excluded during search.
  ///
  /// At most 400 excluded job names are allowed.
  public var excludedJobs: [String] {
    get {return _storage._excludedJobs}
    set {_uniqueStorage()._excludedJobs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Geographic region of the search.
public struct Google_Cloud_Talent_V4_LocationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address name, such as "Mountain View" or "Bay Area".
  public var address: String = String()

  /// CLDR region code of the country/region of the address. This is used
  /// to address ambiguity of the user-input location, for example, "Liverpool"
  /// against "Liverpool, NY, US" or "Liverpool, UK".
  ///
  /// Set this field to bias location resolution toward a specific country
  /// or territory. If this field is not set, application behavior is biased
  /// toward the United States by default.
  ///
  /// See
  /// https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
  /// for details. Example: "CH" for Switzerland.
  public var regionCode: String = String()

  /// The latitude and longitude of the geographic center to search from. This
  /// field is ignored if `address` is provided.
  public var latLng: Google_Type_LatLng {
    get {return _latLng ?? Google_Type_LatLng()}
    set {_latLng = newValue}
  }
  /// Returns true if `latLng` has been explicitly set.
  public var hasLatLng: Bool {return self._latLng != nil}
  /// Clears the value of `latLng`. Subsequent reads from it will return its default value.
  public mutating func clearLatLng() {self._latLng = nil}

  /// The distance_in_miles is applied when the location being searched for is
  /// identified as a city or smaller. This field is ignored if the location
  /// being searched for is a state or larger.
  public var distanceInMiles: Double = 0

  /// Allows the client to return jobs without a
  /// set location, specifically, telecommuting jobs (telecommuting is considered
  /// by the service as a special location.
  /// [Job.posting_region][google.cloud.talent.v4.Job.posting_region] indicates if a job permits telecommuting.
  /// If this field is set to [TelecommutePreference.TELECOMMUTE_ALLOWED][google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED],
  /// telecommuting jobs are searched, and [address][google.cloud.talent.v4.LocationFilter.address] and [lat_lng][google.cloud.talent.v4.LocationFilter.lat_lng] are
  /// ignored. If not set or set to
  /// [TelecommutePreference.TELECOMMUTE_EXCLUDED][google.cloud.talent.v4.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED], telecommute job are not
  /// searched.
  ///
  /// This filter can be used by itself to search exclusively for telecommuting
  /// jobs, or it can be combined with another location
  /// filter to search for a combination of job locations,
  /// such as "Mountain View" or "telecommuting" jobs. However, when used in
  /// combination with other location filters, telecommuting jobs can be
  /// treated as less relevant than other jobs in the search response.
  ///
  /// This field is only used for job search requests.
  public var telecommutePreference: Google_Cloud_Talent_V4_LocationFilter.TelecommutePreference = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify whether to include telecommute jobs.
  public enum TelecommutePreference: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value if the telecommute preference isn't specified.
    case unspecified // = 0

    /// Exclude telecommute jobs.
    case telecommuteExcluded // = 1

    /// Allow telecommute jobs.
    case telecommuteAllowed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .telecommuteExcluded
      case 2: self = .telecommuteAllowed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .telecommuteExcluded: return 1
      case .telecommuteAllowed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _latLng: Google_Type_LatLng? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4_LocationFilter.TelecommutePreference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4_LocationFilter.TelecommutePreference] = [
    .unspecified,
    .telecommuteExcluded,
    .telecommuteAllowed,
  ]
}

#endif  // swift(>=4.2)

/// Filter on job compensation type and amount.
public struct Google_Cloud_Talent_V4_CompensationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Type of filter.
  public var type: Google_Cloud_Talent_V4_CompensationFilter.FilterType = .unspecified

  /// Required. Specify desired `base compensation entry's`
  /// [CompensationInfo.CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit].
  public var units: [Google_Cloud_Talent_V4_CompensationInfo.CompensationUnit] = []

  /// Compensation range.
  public var range: Google_Cloud_Talent_V4_CompensationInfo.CompensationRange {
    get {return _range ?? Google_Cloud_Talent_V4_CompensationInfo.CompensationRange()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  /// If set to true, jobs with unspecified compensation range fields are
  /// included.
  public var includeJobsWithUnspecifiedCompensationRange: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify the type of filtering.
  public enum FilterType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Filter type unspecified. Position holder, INVALID, should never be used.
    case unspecified // = 0

    /// Filter by `base compensation entry's` unit. A job is a match if and
    /// only if the job contains a base CompensationEntry and the base
    /// CompensationEntry's unit matches provided [units][google.cloud.talent.v4.CompensationFilter.units].
    /// Populate one or more [units][google.cloud.talent.v4.CompensationFilter.units].
    ///
    /// See [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry] for definition of
    /// base compensation entry.
    case unitOnly // = 1

    /// Filter by `base compensation entry's` unit and amount / range. A job
    /// is a match if and only if the job contains a base CompensationEntry, and
    /// the base entry's unit matches provided
    /// [CompensationUnit][google.cloud.talent.v4.CompensationInfo.CompensationUnit] and
    /// amount or range overlaps with provided
    /// [CompensationRange][google.cloud.talent.v4.CompensationInfo.CompensationRange].
    ///
    /// See [CompensationInfo.CompensationEntry][google.cloud.talent.v4.CompensationInfo.CompensationEntry] for definition of
    /// base compensation entry.
    ///
    /// Set exactly one [units][google.cloud.talent.v4.CompensationFilter.units] and populate [range][google.cloud.talent.v4.CompensationFilter.range].
    case unitAndAmount // = 2

    /// Filter by annualized base compensation amount and `base compensation
    /// entry's` unit. Populate [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4.CompensationFilter.units].
    case annualizedBaseAmount // = 3

    /// Filter by annualized total compensation amount and `base compensation
    /// entry's` unit . Populate [range][google.cloud.talent.v4.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4.CompensationFilter.units].
    case annualizedTotalAmount // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unitOnly
      case 2: self = .unitAndAmount
      case 3: self = .annualizedBaseAmount
      case 4: self = .annualizedTotalAmount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unitOnly: return 1
      case .unitAndAmount: return 2
      case .annualizedBaseAmount: return 3
      case .annualizedTotalAmount: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _range: Google_Cloud_Talent_V4_CompensationInfo.CompensationRange? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4_CompensationFilter.FilterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4_CompensationFilter.FilterType] = [
    .unspecified,
    .unitOnly,
    .unitAndAmount,
    .annualizedBaseAmount,
    .annualizedTotalAmount,
  ]
}

#endif  // swift(>=4.2)

/// Parameters needed for commute search.
public struct Google_Cloud_Talent_V4_CommuteFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The method of transportation to calculate the commute time for.
  public var commuteMethod: Google_Cloud_Talent_V4_CommuteMethod = .unspecified

  /// Required. The latitude and longitude of the location to calculate the
  /// commute time from.
  public var startCoordinates: Google_Type_LatLng {
    get {return _startCoordinates ?? Google_Type_LatLng()}
    set {_startCoordinates = newValue}
  }
  /// Returns true if `startCoordinates` has been explicitly set.
  public var hasStartCoordinates: Bool {return self._startCoordinates != nil}
  /// Clears the value of `startCoordinates`. Subsequent reads from it will return its default value.
  public mutating func clearStartCoordinates() {self._startCoordinates = nil}

  /// Required. The maximum travel time in seconds. The maximum allowed value is `3600s`
  /// (one hour). Format is `123s`.
  public var travelDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _travelDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_travelDuration = newValue}
  }
  /// Returns true if `travelDuration` has been explicitly set.
  public var hasTravelDuration: Bool {return self._travelDuration != nil}
  /// Clears the value of `travelDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTravelDuration() {self._travelDuration = nil}

  /// If `true`, jobs without street level addresses may also be returned.
  /// For city level addresses, the city center is used. For state and coarser
  /// level addresses, text matching is used.
  /// If this field is set to `false` or isn't specified, only jobs that include
  /// street level addresses will be returned by commute search.
  public var allowImpreciseAddresses: Bool = false

  /// Traffic factor to take into account while searching by commute.
  public var trafficOption: Google_Cloud_Talent_V4_CommuteFilter.OneOf_TrafficOption? = nil

  /// Specifies the traffic density to use when calculating commute time.
  public var roadTraffic: Google_Cloud_Talent_V4_CommuteFilter.RoadTraffic {
    get {
      if case .roadTraffic(let v)? = trafficOption {return v}
      return .unspecified
    }
    set {trafficOption = .roadTraffic(newValue)}
  }

  /// The departure time used to calculate traffic impact, represented as
  /// [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
  ///
  /// Currently traffic model is restricted to hour level resolution.
  public var departureTime: Google_Type_TimeOfDay {
    get {
      if case .departureTime(let v)? = trafficOption {return v}
      return Google_Type_TimeOfDay()
    }
    set {trafficOption = .departureTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Traffic factor to take into account while searching by commute.
  public enum OneOf_TrafficOption: Equatable {
    /// Specifies the traffic density to use when calculating commute time.
    case roadTraffic(Google_Cloud_Talent_V4_CommuteFilter.RoadTraffic)
    /// The departure time used to calculate traffic impact, represented as
    /// [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
    ///
    /// Currently traffic model is restricted to hour level resolution.
    case departureTime(Google_Type_TimeOfDay)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Talent_V4_CommuteFilter.OneOf_TrafficOption, rhs: Google_Cloud_Talent_V4_CommuteFilter.OneOf_TrafficOption) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.roadTraffic, .roadTraffic): return {
        guard case .roadTraffic(let l) = lhs, case .roadTraffic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.departureTime, .departureTime): return {
        guard case .departureTime(let l) = lhs, case .departureTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The traffic density to use when calculating commute time.
  public enum RoadTraffic: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Road traffic situation isn't specified.
    case unspecified // = 0

    /// Optimal commute time without considering any traffic impact.
    case trafficFree // = 1

    /// Commute time calculation takes in account the peak traffic impact.
    case busyHour // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .trafficFree
      case 2: self = .busyHour
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .trafficFree: return 1
      case .busyHour: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startCoordinates: Google_Type_LatLng? = nil
  fileprivate var _travelDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4_CommuteFilter.RoadTraffic: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4_CommuteFilter.RoadTraffic] = [
    .unspecified,
    .trafficFree,
    .busyHour,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.talent.v4"

extension Google_Cloud_Talent_V4_JobQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    14: .standard(proto: "query_language_code"),
    2: .same(proto: "companies"),
    3: .standard(proto: "location_filters"),
    4: .standard(proto: "job_categories"),
    5: .standard(proto: "commute_filter"),
    6: .standard(proto: "company_display_names"),
    7: .standard(proto: "compensation_filter"),
    8: .standard(proto: "custom_attribute_filter"),
    9: .standard(proto: "disable_spell_check"),
    10: .standard(proto: "employment_types"),
    11: .standard(proto: "language_codes"),
    12: .standard(proto: "publish_time_range"),
    13: .standard(proto: "excluded_jobs"),
  ]

  fileprivate class _StorageClass {
    var _query: String = String()
    var _queryLanguageCode: String = String()
    var _companies: [String] = []
    var _locationFilters: [Google_Cloud_Talent_V4_LocationFilter] = []
    var _jobCategories: [Google_Cloud_Talent_V4_JobCategory] = []
    var _commuteFilter: Google_Cloud_Talent_V4_CommuteFilter? = nil
    var _companyDisplayNames: [String] = []
    var _compensationFilter: Google_Cloud_Talent_V4_CompensationFilter? = nil
    var _customAttributeFilter: String = String()
    var _disableSpellCheck: Bool = false
    var _employmentTypes: [Google_Cloud_Talent_V4_EmploymentType] = []
    var _languageCodes: [String] = []
    var _publishTimeRange: Google_Cloud_Talent_V4_TimestampRange? = nil
    var _excludedJobs: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _query = source._query
      _queryLanguageCode = source._queryLanguageCode
      _companies = source._companies
      _locationFilters = source._locationFilters
      _jobCategories = source._jobCategories
      _commuteFilter = source._commuteFilter
      _companyDisplayNames = source._companyDisplayNames
      _compensationFilter = source._compensationFilter
      _customAttributeFilter = source._customAttributeFilter
      _disableSpellCheck = source._disableSpellCheck
      _employmentTypes = source._employmentTypes
      _languageCodes = source._languageCodes
      _publishTimeRange = source._publishTimeRange
      _excludedJobs = source._excludedJobs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._companies) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._locationFilters) }()
        case 4: try { try decoder.decodeRepeatedEnumField(value: &_storage._jobCategories) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._commuteFilter) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._companyDisplayNames) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._compensationFilter) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._customAttributeFilter) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._disableSpellCheck) }()
        case 10: try { try decoder.decodeRepeatedEnumField(value: &_storage._employmentTypes) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._languageCodes) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._publishTimeRange) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._excludedJobs) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._queryLanguageCode) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 1)
      }
      if !_storage._companies.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._companies, fieldNumber: 2)
      }
      if !_storage._locationFilters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._locationFilters, fieldNumber: 3)
      }
      if !_storage._jobCategories.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._jobCategories, fieldNumber: 4)
      }
      if let v = _storage._commuteFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._companyDisplayNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._companyDisplayNames, fieldNumber: 6)
      }
      if let v = _storage._compensationFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._customAttributeFilter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customAttributeFilter, fieldNumber: 8)
      }
      if _storage._disableSpellCheck != false {
        try visitor.visitSingularBoolField(value: _storage._disableSpellCheck, fieldNumber: 9)
      }
      if !_storage._employmentTypes.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._employmentTypes, fieldNumber: 10)
      }
      if !_storage._languageCodes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._languageCodes, fieldNumber: 11)
      }
      if let v = _storage._publishTimeRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._excludedJobs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._excludedJobs, fieldNumber: 13)
      }
      if !_storage._queryLanguageCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._queryLanguageCode, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4_JobQuery, rhs: Google_Cloud_Talent_V4_JobQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._query != rhs_storage._query {return false}
        if _storage._queryLanguageCode != rhs_storage._queryLanguageCode {return false}
        if _storage._companies != rhs_storage._companies {return false}
        if _storage._locationFilters != rhs_storage._locationFilters {return false}
        if _storage._jobCategories != rhs_storage._jobCategories {return false}
        if _storage._commuteFilter != rhs_storage._commuteFilter {return false}
        if _storage._companyDisplayNames != rhs_storage._companyDisplayNames {return false}
        if _storage._compensationFilter != rhs_storage._compensationFilter {return false}
        if _storage._customAttributeFilter != rhs_storage._customAttributeFilter {return false}
        if _storage._disableSpellCheck != rhs_storage._disableSpellCheck {return false}
        if _storage._employmentTypes != rhs_storage._employmentTypes {return false}
        if _storage._languageCodes != rhs_storage._languageCodes {return false}
        if _storage._publishTimeRange != rhs_storage._publishTimeRange {return false}
        if _storage._excludedJobs != rhs_storage._excludedJobs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4_LocationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "region_code"),
    3: .standard(proto: "lat_lng"),
    4: .standard(proto: "distance_in_miles"),
    5: .standard(proto: "telecommute_preference"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._latLng) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.distanceInMiles) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.telecommutePreference) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    if let v = self._latLng {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.distanceInMiles != 0 {
      try visitor.visitSingularDoubleField(value: self.distanceInMiles, fieldNumber: 4)
    }
    if self.telecommutePreference != .unspecified {
      try visitor.visitSingularEnumField(value: self.telecommutePreference, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4_LocationFilter, rhs: Google_Cloud_Talent_V4_LocationFilter) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs._latLng != rhs._latLng {return false}
    if lhs.distanceInMiles != rhs.distanceInMiles {return false}
    if lhs.telecommutePreference != rhs.telecommutePreference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4_LocationFilter.TelecommutePreference: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TELECOMMUTE_PREFERENCE_UNSPECIFIED"),
    1: .same(proto: "TELECOMMUTE_EXCLUDED"),
    2: .same(proto: "TELECOMMUTE_ALLOWED"),
  ]
}

extension Google_Cloud_Talent_V4_CompensationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompensationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "units"),
    3: .same(proto: "range"),
    4: .standard(proto: "include_jobs_with_unspecified_compensation_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.units) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeJobsWithUnspecifiedCompensationRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.units.isEmpty {
      try visitor.visitPackedEnumField(value: self.units, fieldNumber: 2)
    }
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.includeJobsWithUnspecifiedCompensationRange != false {
      try visitor.visitSingularBoolField(value: self.includeJobsWithUnspecifiedCompensationRange, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4_CompensationFilter, rhs: Google_Cloud_Talent_V4_CompensationFilter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.units != rhs.units {return false}
    if lhs._range != rhs._range {return false}
    if lhs.includeJobsWithUnspecifiedCompensationRange != rhs.includeJobsWithUnspecifiedCompensationRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4_CompensationFilter.FilterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILTER_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNIT_ONLY"),
    2: .same(proto: "UNIT_AND_AMOUNT"),
    3: .same(proto: "ANNUALIZED_BASE_AMOUNT"),
    4: .same(proto: "ANNUALIZED_TOTAL_AMOUNT"),
  ]
}

extension Google_Cloud_Talent_V4_CommuteFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommuteFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commute_method"),
    2: .standard(proto: "start_coordinates"),
    3: .standard(proto: "travel_duration"),
    4: .standard(proto: "allow_imprecise_addresses"),
    5: .standard(proto: "road_traffic"),
    6: .standard(proto: "departure_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.commuteMethod) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startCoordinates) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._travelDuration) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowImpreciseAddresses) }()
      case 5: try {
        if self.trafficOption != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Talent_V4_CommuteFilter.RoadTraffic?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.trafficOption = .roadTraffic(v)}
      }()
      case 6: try {
        var v: Google_Type_TimeOfDay?
        if let current = self.trafficOption {
          try decoder.handleConflictingOneOf()
          if case .departureTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trafficOption = .departureTime(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commuteMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.commuteMethod, fieldNumber: 1)
    }
    if let v = self._startCoordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._travelDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.allowImpreciseAddresses != false {
      try visitor.visitSingularBoolField(value: self.allowImpreciseAddresses, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.trafficOption {
    case .roadTraffic?: try {
      guard case .roadTraffic(let v)? = self.trafficOption else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }()
    case .departureTime?: try {
      guard case .departureTime(let v)? = self.trafficOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4_CommuteFilter, rhs: Google_Cloud_Talent_V4_CommuteFilter) -> Bool {
    if lhs.commuteMethod != rhs.commuteMethod {return false}
    if lhs._startCoordinates != rhs._startCoordinates {return false}
    if lhs._travelDuration != rhs._travelDuration {return false}
    if lhs.allowImpreciseAddresses != rhs.allowImpreciseAddresses {return false}
    if lhs.trafficOption != rhs.trafficOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4_CommuteFilter.RoadTraffic: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROAD_TRAFFIC_UNSPECIFIED"),
    1: .same(proto: "TRAFFIC_FREE"),
    2: .same(proto: "BUSY_HOUR"),
  ]
}

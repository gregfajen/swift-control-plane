// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/talent/v4beta1/filters.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The query required to perform a search query.
public struct Google_Cloud_Talent_V4beta1_JobQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The query string that matches against the job title, description, and
  /// location fields.
  ///
  /// The maximum number of allowed characters is 255.
  public var query: String {
    get {return _storage._query}
    set {_uniqueStorage()._query = newValue}
  }

  /// The language code of [query][google.cloud.talent.v4beta1.JobQuery.query]. For example, "en-US". This field helps to
  /// better interpret the query.
  ///
  /// If a value isn't specified, the query language code is automatically
  /// detected, which may not be accurate.
  ///
  /// Language code should be in BCP-47 format, such as "en-US" or "sr-Latn".
  /// For more information, see
  /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
  public var queryLanguageCode: String {
    get {return _storage._queryLanguageCode}
    set {_uniqueStorage()._queryLanguageCode = newValue}
  }

  /// This filter specifies the company entities to search against.
  ///
  /// If a value isn't specified, jobs are searched for against all
  /// companies.
  ///
  /// If multiple values are specified, jobs are searched against the
  /// companies specified.
  ///
  /// The format is
  /// "projects/{project_id}/tenants/{tenant_id}/companies/{company_id}". For
  /// example, "projects/foo/tenants/bar/companies/baz".
  ///
  /// If tenant id is unspecified, the default tenant is used. For
  /// example, "projects/foo/companies/bar".
  ///
  /// At most 20 company filters are allowed.
  public var companies: [String] {
    get {return _storage._companies}
    set {_uniqueStorage()._companies = newValue}
  }

  /// The location filter specifies geo-regions containing the jobs to
  /// search against. See [LocationFilter][google.cloud.talent.v4beta1.LocationFilter] for more information.
  ///
  /// If a location value isn't specified, jobs fitting the other search
  /// criteria are retrieved regardless of where they're located.
  ///
  /// If multiple values are specified, jobs are retrieved from any of the
  /// specified locations. If different values are specified for the
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] parameter, the maximum provided
  /// distance is used for all locations.
  ///
  /// At most 5 location filters are allowed.
  public var locationFilters: [Google_Cloud_Talent_V4beta1_LocationFilter] {
    get {return _storage._locationFilters}
    set {_uniqueStorage()._locationFilters = newValue}
  }

  /// The category filter specifies the categories of jobs to search against.
  /// See [JobCategory][google.cloud.talent.v4beta1.JobCategory] for more information.
  ///
  /// If a value isn't specified, jobs from any category are searched against.
  ///
  /// If multiple values are specified, jobs from any of the specified
  /// categories are searched against.
  public var jobCategories: [Google_Cloud_Talent_V4beta1_JobCategory] {
    get {return _storage._jobCategories}
    set {_uniqueStorage()._jobCategories = newValue}
  }

  /// Allows filtering jobs by commute time with different travel methods (for
  ///  example, driving or public transit).
  ///
  /// Note: This only works when you specify a [CommuteMethod][google.cloud.talent.v4beta1.CommuteMethod]. In this case,
  /// [location_filters][google.cloud.talent.v4beta1.JobQuery.location_filters] is ignored.
  ///
  ///  Currently we don't support sorting by commute time.
  public var commuteFilter: Google_Cloud_Talent_V4beta1_CommuteFilter {
    get {return _storage._commuteFilter ?? Google_Cloud_Talent_V4beta1_CommuteFilter()}
    set {_uniqueStorage()._commuteFilter = newValue}
  }
  /// Returns true if `commuteFilter` has been explicitly set.
  public var hasCommuteFilter: Bool {return _storage._commuteFilter != nil}
  /// Clears the value of `commuteFilter`. Subsequent reads from it will return its default value.
  public mutating func clearCommuteFilter() {_uniqueStorage()._commuteFilter = nil}

  /// This filter specifies the exact company [Company.display_name][google.cloud.talent.v4beta1.Company.display_name]
  /// of the jobs to search against.
  ///
  /// If a value isn't specified, jobs within the search results are
  /// associated with any company.
  ///
  /// If multiple values are specified, jobs within the search results may be
  /// associated with any of the specified companies.
  ///
  /// At most 20 company display name filters are allowed.
  public var companyDisplayNames: [String] {
    get {return _storage._companyDisplayNames}
    set {_uniqueStorage()._companyDisplayNames = newValue}
  }

  /// This search filter is applied only to
  /// [Job.compensation_info][google.cloud.talent.v4beta1.Job.compensation_info]. For example, if the filter is specified
  /// as "Hourly job with per-hour compensation > $15", only jobs meeting
  /// these criteria are searched. If a filter isn't defined, all open jobs
  /// are searched.
  public var compensationFilter: Google_Cloud_Talent_V4beta1_CompensationFilter {
    get {return _storage._compensationFilter ?? Google_Cloud_Talent_V4beta1_CompensationFilter()}
    set {_uniqueStorage()._compensationFilter = newValue}
  }
  /// Returns true if `compensationFilter` has been explicitly set.
  public var hasCompensationFilter: Bool {return _storage._compensationFilter != nil}
  /// Clears the value of `compensationFilter`. Subsequent reads from it will return its default value.
  public mutating func clearCompensationFilter() {_uniqueStorage()._compensationFilter = nil}

  /// This filter specifies a structured syntax to match against the
  /// [Job.custom_attributes][google.cloud.talent.v4beta1.Job.custom_attributes] marked as `filterable`.
  ///
  /// The syntax for this expression is a subset of SQL syntax.
  ///
  /// Supported operators are: `=`, `!=`, `<`, `<=`, `>`, and `>=` where the
  /// left of the operator is a custom field key and the right of the operator
  /// is a number or a quoted string. You must escape backslash (\\) and
  /// quote (\") characters.
  ///
  /// Supported functions are `LOWER([field_name])` to
  /// perform a case insensitive match and `EMPTY([field_name])` to filter on the
  /// existence of a key.
  ///
  /// Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
  /// nesting (for example, "((A AND B AND C) OR NOT D) AND E"), a maximum of 100
  /// comparisons or functions are allowed in the expression. The expression
  /// must be < 6000 bytes in length.
  ///
  /// Sample Query:
  /// `(LOWER(driving_license)="class \"a\"" OR EMPTY(driving_license)) AND
  /// driving_years > 10`
  public var customAttributeFilter: String {
    get {return _storage._customAttributeFilter}
    set {_uniqueStorage()._customAttributeFilter = newValue}
  }

  /// This flag controls the spell-check feature. If false, the
  /// service attempts to correct a misspelled query,
  /// for example, "enginee" is corrected to "engineer".
  ///
  /// Defaults to false: a spell check is performed.
  public var disableSpellCheck: Bool {
    get {return _storage._disableSpellCheck}
    set {_uniqueStorage()._disableSpellCheck = newValue}
  }

  /// The employment type filter specifies the employment type of jobs to
  /// search against, such as [EmploymentType.FULL_TIME][google.cloud.talent.v4beta1.EmploymentType.FULL_TIME].
  ///
  /// If a value isn't specified, jobs in the search results includes any
  /// employment type.
  ///
  /// If multiple values are specified, jobs in the search results include
  /// any of the specified employment types.
  public var employmentTypes: [Google_Cloud_Talent_V4beta1_EmploymentType] {
    get {return _storage._employmentTypes}
    set {_uniqueStorage()._employmentTypes = newValue}
  }

  /// This filter specifies the locale of jobs to search against,
  /// for example, "en-US".
  ///
  /// If a value isn't specified, the search results can contain jobs in any
  /// locale.
  ///
  ///
  /// Language codes should be in BCP-47 format, such as "en-US" or "sr-Latn".
  /// For more information, see
  /// [Tags for Identifying Languages](https://tools.ietf.org/html/bcp47).
  ///
  /// At most 10 language code filters are allowed.
  public var languageCodes: [String] {
    get {return _storage._languageCodes}
    set {_uniqueStorage()._languageCodes = newValue}
  }

  /// Jobs published within a range specified by this filter are searched
  /// against.
  public var publishTimeRange: Google_Cloud_Talent_V4beta1_TimestampRange {
    get {return _storage._publishTimeRange ?? Google_Cloud_Talent_V4beta1_TimestampRange()}
    set {_uniqueStorage()._publishTimeRange = newValue}
  }
  /// Returns true if `publishTimeRange` has been explicitly set.
  public var hasPublishTimeRange: Bool {return _storage._publishTimeRange != nil}
  /// Clears the value of `publishTimeRange`. Subsequent reads from it will return its default value.
  public mutating func clearPublishTimeRange() {_uniqueStorage()._publishTimeRange = nil}

  /// This filter specifies a list of job names to be excluded during search.
  ///
  /// At most 400 excluded job names are allowed.
  public var excludedJobs: [String] {
    get {return _storage._excludedJobs}
    set {_uniqueStorage()._excludedJobs = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Filters to apply when performing the search query.
public struct Google_Cloud_Talent_V4beta1_ProfileQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Keywords to match any text fields of profiles.
  ///
  /// For example, "software engineer in Palo Alto".
  public var query: String = String()

  /// The location filter specifies geo-regions containing the profiles to
  /// search against.
  ///
  /// One of [LocationFilter.address][google.cloud.talent.v4beta1.LocationFilter.address] or [LocationFilter.lat_lng][google.cloud.talent.v4beta1.LocationFilter.lat_lng] must be
  /// provided or an error is thrown. If both [LocationFilter.address][google.cloud.talent.v4beta1.LocationFilter.address] and
  /// [LocationFilter.lat_lng][google.cloud.talent.v4beta1.LocationFilter.lat_lng] are provided, an error is thrown.
  ///
  /// The following logic is used to determine which locations in
  /// the profile to filter against:
  ///
  /// 1. All of the profile's geocoded [Profile.addresses][google.cloud.talent.v4beta1.Profile.addresses] where
  /// [Address.usage][google.cloud.talent.v4beta1.Address.usage] is PERSONAL and [Address.current][google.cloud.talent.v4beta1.Address.current] is true.
  ///
  /// 2. If the above set of locations is empty, all of the profile's geocoded
  /// [Profile.addresses][google.cloud.talent.v4beta1.Profile.addresses] where [Address.usage][google.cloud.talent.v4beta1.Address.usage] is
  /// CONTACT_INFO_USAGE_UNSPECIFIED and [Address.current][google.cloud.talent.v4beta1.Address.current] is true.
  ///
  /// 3. If the above set of locations is empty, all of the profile's geocoded
  /// [Profile.addresses][google.cloud.talent.v4beta1.Profile.addresses] where [Address.usage][google.cloud.talent.v4beta1.Address.usage] is PERSONAL or
  /// CONTACT_INFO_USAGE_UNSPECIFIED and [Address.current][google.cloud.talent.v4beta1.Address.current] is not set.
  ///
  /// This means that any profiles without any [Profile.addresses][google.cloud.talent.v4beta1.Profile.addresses] that match
  /// any of the above criteria will not be included in a search with location
  /// filter. Furthermore, any [Profile.addresses][google.cloud.talent.v4beta1.Profile.addresses] where [Address.usage][google.cloud.talent.v4beta1.Address.usage] is
  /// WORK or SCHOOL or where [Address.current][google.cloud.talent.v4beta1.Address.current] is false are not considered for
  /// location filter.
  ///
  /// If a location filter isn't specified, profiles fitting the other search
  /// criteria are retrieved regardless of where they're located.
  ///
  /// If [LocationFilter.negated][google.cloud.talent.v4beta1.LocationFilter.negated] is specified, the result doesn't contain
  /// profiles from that location.
  ///
  /// If [LocationFilter.address][google.cloud.talent.v4beta1.LocationFilter.address] is provided, the
  /// [LocationType][google.cloud.talent.v4beta1.Location.LocationType], center
  /// point (latitude and longitude), and radius are automatically detected by
  /// the Google Maps Geocoding API and included as well. If
  /// [LocationFilter.address][google.cloud.talent.v4beta1.LocationFilter.address] cannot be geocoded, the filter
  /// falls back to keyword search.
  ///
  /// If the detected
  /// [LocationType][google.cloud.talent.v4beta1.Location.LocationType] is
  /// [LocationType.SUB_ADMINISTRATIVE_AREA][google.cloud.talent.v4beta1.Location.LocationType.SUB_ADMINISTRATIVE_AREA],
  /// [LocationType.ADMINISTRATIVE_AREA][google.cloud.talent.v4beta1.Location.LocationType.ADMINISTRATIVE_AREA],
  /// or
  /// [LocationType.COUNTRY][google.cloud.talent.v4beta1.Location.LocationType.COUNTRY],
  /// the filter is performed against the detected location name (using exact
  /// text matching). Otherwise, the filter is performed against the detected
  /// center point and a radius of detected location radius +
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles].
  ///
  /// If [LocationFilter.address][google.cloud.talent.v4beta1.LocationFilter.address] is provided,
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] is the additional radius on top of the
  /// radius of the location geocoded from [LocationFilter.address][google.cloud.talent.v4beta1.LocationFilter.address]. If
  /// [LocationFilter.lat_lng][google.cloud.talent.v4beta1.LocationFilter.lat_lng] is provided,
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] is the only radius that is used.
  ///
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] is 10 by default. Note that the value
  /// of [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] is 0 if it is unset, so the server
  /// does not differentiate [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] that is
  /// explicitly set to 0 and [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] that is not
  /// set. Which means that if [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] is explicitly
  /// set to 0, the server will use the default value of
  /// [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] which is 10. To work around this and
  /// effectively set [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] to 0, we recommend
  /// setting [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] to a very small decimal number
  /// (such as 0.00001).
  ///
  /// If [LocationFilter.distance_in_miles][google.cloud.talent.v4beta1.LocationFilter.distance_in_miles] is negative, an error is thrown.
  public var locationFilters: [Google_Cloud_Talent_V4beta1_LocationFilter] = []

  /// Job title filter specifies job titles of profiles to match on.
  ///
  /// If a job title isn't specified, profiles with any titles are retrieved.
  ///
  /// If multiple values are specified, profiles are retrieved with any of the
  /// specified job titles.
  ///
  /// If [JobTitleFilter.negated][google.cloud.talent.v4beta1.JobTitleFilter.negated] is specified, the result won't contain
  /// profiles with the job titles.
  ///
  /// For example, search for profiles with a job title "Product Manager".
  public var jobTitleFilters: [Google_Cloud_Talent_V4beta1_JobTitleFilter] = []

  /// Employer filter specifies employers of profiles to match on.
  ///
  /// If an employer filter isn't specified, profiles with any employers are
  /// retrieved.
  ///
  /// If multiple employer filters are specified, profiles with any matching
  /// employers are retrieved.
  ///
  /// If [EmployerFilter.negated][google.cloud.talent.v4beta1.EmployerFilter.negated] is specified, the result won't contain
  /// profiles that match the employers.
  ///
  /// For example, search for profiles that have working experience at "Google
  /// LLC".
  public var employerFilters: [Google_Cloud_Talent_V4beta1_EmployerFilter] = []

  /// Education filter specifies education of profiles to match on.
  ///
  /// If an education filter isn't specified, profiles with any education are
  /// retrieved.
  ///
  /// If multiple education filters are specified, profiles that match any
  /// education filters are retrieved.
  ///
  /// If [EducationFilter.negated][google.cloud.talent.v4beta1.EducationFilter.negated] is specified, the result won't contain
  /// profiles that match the educations.
  ///
  /// For example, search for profiles with a master degree.
  public var educationFilters: [Google_Cloud_Talent_V4beta1_EducationFilter] = []

  /// Skill filter specifies skill of profiles to match on.
  ///
  /// If a skill filter isn't specified, profiles with any skills are retrieved.
  ///
  /// If multiple skill filters are specified, profiles that match any skill
  /// filters are retrieved.
  ///
  /// If [SkillFilter.negated][google.cloud.talent.v4beta1.SkillFilter.negated] is specified, the result won't contain profiles
  /// that match the skills.
  ///
  /// For example, search for profiles that have "Java" and "Python" in skill
  /// list.
  public var skillFilters: [Google_Cloud_Talent_V4beta1_SkillFilter] = []

  /// Work experience filter specifies the total working experience of profiles
  /// to match on.
  ///
  /// If a work experience filter isn't specified, profiles with any
  /// professional experience are retrieved.
  ///
  /// If multiple work experience filters are specified, profiles that match any
  /// work experience filters are retrieved.
  ///
  /// For example, search for profiles with 10 years of work experience.
  public var workExperienceFilter: [Google_Cloud_Talent_V4beta1_WorkExperienceFilter] = []

  /// Time filter specifies the create/update timestamp of the profiles to match
  /// on.
  ///
  /// For example, search for profiles created since "2018-1-1".
  public var timeFilters: [Google_Cloud_Talent_V4beta1_TimeFilter] = []

  /// The hirable filter specifies the profile's hirable status to match on.
  public var hirableFilter: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _hirableFilter ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_hirableFilter = newValue}
  }
  /// Returns true if `hirableFilter` has been explicitly set.
  public var hasHirableFilter: Bool {return self._hirableFilter != nil}
  /// Clears the value of `hirableFilter`. Subsequent reads from it will return its default value.
  public mutating func clearHirableFilter() {self._hirableFilter = nil}

  /// The application date filters specify application date ranges to match on.
  public var applicationDateFilters: [Google_Cloud_Talent_V4beta1_ApplicationDateFilter] = []

  /// The application outcome notes filters specify the notes for the outcome of
  /// the job application.
  public var applicationOutcomeNotesFilters: [Google_Cloud_Talent_V4beta1_ApplicationOutcomeNotesFilter] = []

  /// The application job filters specify the job applied for in the application.
  public var applicationJobFilters: [Google_Cloud_Talent_V4beta1_ApplicationJobFilter] = []

  /// This filter specifies a structured syntax to match against the
  /// [Profile.custom_attributes][google.cloud.talent.v4beta1.Profile.custom_attributes] that are marked as `filterable`.
  ///
  /// The syntax for this expression is a subset of Google SQL syntax.
  ///
  /// String custom attributes: supported operators are =, != where the left of
  /// the operator is a custom field key and the right of the operator is a
  /// string (surrounded by quotes) value.
  ///
  /// Numeric custom attributes: Supported operators are '>', '<' or '='
  /// operators where the left of the operator is a custom field key and the
  /// right of the operator is a numeric value.
  ///
  /// Supported functions are LOWER(<field_name>) to
  /// perform case insensitive match and EMPTY(<field_name>) to filter on the
  /// existence of a key.
  ///
  /// Boolean expressions (AND/OR/NOT) are supported up to 3 levels of
  /// nesting (for example "((A AND B AND C) OR NOT D) AND E"), and there can be
  /// a maximum of 50 comparisons/functions in the expression. The expression
  /// must be < 2000 characters in length.
  ///
  /// Sample Query:
  /// (key1 = "TEST" OR LOWER(key1)="test" OR NOT EMPTY(key1))
  public var customAttributeFilter: String = String()

  /// Deprecated. Use availability_filters instead.
  ///
  /// The candidate availability filter which filters based on availability
  /// signals.
  ///
  /// Signal 1: Number of days since most recent job application.  See
  /// [Availability.JobApplicationAvailabilitySignal][google.cloud.talent.v4beta1.Availability.JobApplicationAvailabilitySignal] for the details of this
  /// signal.
  ///
  /// Signal 2: Number of days since last profile update. See
  /// [Availability.ProfileUpdateAvailabilitySignal][google.cloud.talent.v4beta1.Availability.ProfileUpdateAvailabilitySignal]
  /// for the details of this signal.
  ///
  /// The candidate availability filter helps a recruiter understand if a
  /// specific candidate is likely to be actively seeking new job opportunities
  /// based on an aggregated set of signals.  Specifically, the intent is NOT to
  /// indicate the candidate's potential qualification / interest / close ability
  /// for a specific job.
  public var candidateAvailabilityFilter: Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter {
    get {return _candidateAvailabilityFilter ?? Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter()}
    set {_candidateAvailabilityFilter = newValue}
  }
  /// Returns true if `candidateAvailabilityFilter` has been explicitly set.
  public var hasCandidateAvailabilityFilter: Bool {return self._candidateAvailabilityFilter != nil}
  /// Clears the value of `candidateAvailabilityFilter`. Subsequent reads from it will return its default value.
  public mutating func clearCandidateAvailabilityFilter() {self._candidateAvailabilityFilter = nil}

  /// The availability filter which filters based on
  /// [Profile.availability_signals][google.cloud.talent.v4beta1.Profile.availability_signals].
  ///
  /// The availability filter helps a recruiter understand if a
  /// specific candidate is likely to be actively seeking new job opportunities
  /// based on an aggregated set of signals.  Specifically, the intent is NOT to
  /// indicate the candidate's potential qualification / interest / close ability
  /// for a specific job.
  ///
  /// There can be at most one [AvailabilityFilter][google.cloud.talent.v4beta1.AvailabilityFilter] per
  /// [signal_type][google.cloud.talent.v4beta1.AvailabilityFilter.signal_type]. If there are multiple
  /// [AvailabilityFilter][google.cloud.talent.v4beta1.AvailabilityFilter] for a [signal_type][google.cloud.talent.v4beta1.AvailabilityFilter.signal_type],
  /// an error is thrown.
  public var availabilityFilters: [Google_Cloud_Talent_V4beta1_AvailabilityFilter] = []

  /// Person name filter specifies person name of profiles to match on.
  ///
  /// If multiple person name filters are specified, profiles that match any
  /// person name filters are retrieved.
  ///
  /// For example, search for profiles of candidates with name "John Smith".
  public var personNameFilters: [Google_Cloud_Talent_V4beta1_PersonNameFilter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _hirableFilter: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
  fileprivate var _candidateAvailabilityFilter: Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter? = nil
}

/// Geographic region of the search.
public struct Google_Cloud_Talent_V4beta1_LocationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address name, such as "Mountain View" or "Bay Area".
  public var address: String = String()

  /// CLDR region code of the country/region of the address. This is used
  /// to address ambiguity of the user-input location, for example, "Liverpool"
  /// against "Liverpool, NY, US" or "Liverpool, UK".
  ///
  /// Set this field to bias location resolution toward a specific country
  /// or territory. If this field is not set, application behavior is biased
  /// toward the United States by default.
  ///
  /// See
  /// https://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
  /// for details. Example: "CH" for Switzerland.
  /// Note that this filter is not applicable for Profile Search related queries.
  public var regionCode: String = String()

  /// The latitude and longitude of the geographic center to search from. This
  /// field is ignored if `address` is provided.
  public var latLng: Google_Type_LatLng {
    get {return _latLng ?? Google_Type_LatLng()}
    set {_latLng = newValue}
  }
  /// Returns true if `latLng` has been explicitly set.
  public var hasLatLng: Bool {return self._latLng != nil}
  /// Clears the value of `latLng`. Subsequent reads from it will return its default value.
  public mutating func clearLatLng() {self._latLng = nil}

  /// The distance_in_miles is applied when the location being searched for is
  /// identified as a city or smaller. This field is ignored if the location
  /// being searched for is a state or larger.
  public var distanceInMiles: Double = 0

  /// Allows the client to return jobs without a
  /// set location, specifically, telecommuting jobs (telecommuting is considered
  /// by the service as a special location.
  /// [Job.posting_region][google.cloud.talent.v4beta1.Job.posting_region] indicates if a job permits telecommuting.
  /// If this field is set to [TelecommutePreference.TELECOMMUTE_ALLOWED][google.cloud.talent.v4beta1.LocationFilter.TelecommutePreference.TELECOMMUTE_ALLOWED],
  /// telecommuting jobs are searched, and [address][google.cloud.talent.v4beta1.LocationFilter.address] and [lat_lng][google.cloud.talent.v4beta1.LocationFilter.lat_lng] are
  /// ignored. If not set or set to
  /// [TelecommutePreference.TELECOMMUTE_EXCLUDED][google.cloud.talent.v4beta1.LocationFilter.TelecommutePreference.TELECOMMUTE_EXCLUDED], telecommute job are not
  /// searched.
  ///
  /// This filter can be used by itself to search exclusively for telecommuting
  /// jobs, or it can be combined with another location
  /// filter to search for a combination of job locations,
  /// such as "Mountain View" or "telecommuting" jobs. However, when used in
  /// combination with other location filters, telecommuting jobs can be
  /// treated as less relevant than other jobs in the search response.
  ///
  /// This field is only used for job search requests.
  public var telecommutePreference: Google_Cloud_Talent_V4beta1_LocationFilter.TelecommutePreference = .unspecified

  /// Whether to apply negation to the filter so profiles matching the filter
  /// are excluded.
  ///
  /// Currently only supported in profile search.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify whether to include telecommute jobs.
  public enum TelecommutePreference: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value if the telecommute preference isn't specified.
    case unspecified // = 0

    /// Exclude telecommute jobs.
    case telecommuteExcluded // = 1

    /// Allow telecommute jobs.
    case telecommuteAllowed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .telecommuteExcluded
      case 2: self = .telecommuteAllowed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .telecommuteExcluded: return 1
      case .telecommuteAllowed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _latLng: Google_Type_LatLng? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4beta1_LocationFilter.TelecommutePreference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4beta1_LocationFilter.TelecommutePreference] = [
    .unspecified,
    .telecommuteExcluded,
    .telecommuteAllowed,
  ]
}

#endif  // swift(>=4.2)

/// Filter on job compensation type and amount.
public struct Google_Cloud_Talent_V4beta1_CompensationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Type of filter.
  public var type: Google_Cloud_Talent_V4beta1_CompensationFilter.FilterType = .unspecified

  /// Required. Specify desired `base compensation entry's`
  /// [CompensationInfo.CompensationUnit][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit].
  public var units: [Google_Cloud_Talent_V4beta1_CompensationInfo.CompensationUnit] = []

  /// Compensation range.
  public var range: Google_Cloud_Talent_V4beta1_CompensationInfo.CompensationRange {
    get {return _range ?? Google_Cloud_Talent_V4beta1_CompensationInfo.CompensationRange()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  /// If set to true, jobs with unspecified compensation range fields are
  /// included.
  public var includeJobsWithUnspecifiedCompensationRange: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specify the type of filtering.
  public enum FilterType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Filter type unspecified. Position holder, INVALID, should never be used.
    case unspecified // = 0

    /// Filter by `base compensation entry's` unit. A job is a match if and
    /// only if the job contains a base CompensationEntry and the base
    /// CompensationEntry's unit matches provided [units][google.cloud.talent.v4beta1.CompensationFilter.units].
    /// Populate one or more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
    ///
    /// See [CompensationInfo.CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry] for definition of
    /// base compensation entry.
    case unitOnly // = 1

    /// Filter by `base compensation entry's` unit and amount / range. A job
    /// is a match if and only if the job contains a base CompensationEntry, and
    /// the base entry's unit matches provided
    /// [CompensationUnit][google.cloud.talent.v4beta1.CompensationInfo.CompensationUnit] and
    /// amount or range overlaps with provided
    /// [CompensationRange][google.cloud.talent.v4beta1.CompensationInfo.CompensationRange].
    ///
    /// See [CompensationInfo.CompensationEntry][google.cloud.talent.v4beta1.CompensationInfo.CompensationEntry] for definition of
    /// base compensation entry.
    ///
    /// Set exactly one [units][google.cloud.talent.v4beta1.CompensationFilter.units] and populate [range][google.cloud.talent.v4beta1.CompensationFilter.range].
    case unitAndAmount // = 2

    /// Filter by annualized base compensation amount and `base compensation
    /// entry's` unit. Populate [range][google.cloud.talent.v4beta1.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
    case annualizedBaseAmount // = 3

    /// Filter by annualized total compensation amount and `base compensation
    /// entry's` unit . Populate [range][google.cloud.talent.v4beta1.CompensationFilter.range] and zero or more [units][google.cloud.talent.v4beta1.CompensationFilter.units].
    case annualizedTotalAmount // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unitOnly
      case 2: self = .unitAndAmount
      case 3: self = .annualizedBaseAmount
      case 4: self = .annualizedTotalAmount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unitOnly: return 1
      case .unitAndAmount: return 2
      case .annualizedBaseAmount: return 3
      case .annualizedTotalAmount: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _range: Google_Cloud_Talent_V4beta1_CompensationInfo.CompensationRange? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4beta1_CompensationFilter.FilterType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4beta1_CompensationFilter.FilterType] = [
    .unspecified,
    .unitOnly,
    .unitAndAmount,
    .annualizedBaseAmount,
    .annualizedTotalAmount,
  ]
}

#endif  // swift(>=4.2)

/// Parameters needed for commute search.
public struct Google_Cloud_Talent_V4beta1_CommuteFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The method of transportation to calculate the commute time for.
  public var commuteMethod: Google_Cloud_Talent_V4beta1_CommuteMethod = .unspecified

  /// Required. The latitude and longitude of the location to calculate the
  /// commute time from.
  public var startCoordinates: Google_Type_LatLng {
    get {return _startCoordinates ?? Google_Type_LatLng()}
    set {_startCoordinates = newValue}
  }
  /// Returns true if `startCoordinates` has been explicitly set.
  public var hasStartCoordinates: Bool {return self._startCoordinates != nil}
  /// Clears the value of `startCoordinates`. Subsequent reads from it will return its default value.
  public mutating func clearStartCoordinates() {self._startCoordinates = nil}

  /// Required. The maximum travel time in seconds. The maximum allowed value is `3600s`
  /// (one hour). Format is `123s`.
  public var travelDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _travelDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_travelDuration = newValue}
  }
  /// Returns true if `travelDuration` has been explicitly set.
  public var hasTravelDuration: Bool {return self._travelDuration != nil}
  /// Clears the value of `travelDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTravelDuration() {self._travelDuration = nil}

  /// If `true`, jobs without street level addresses may also be returned.
  /// For city level addresses, the city center is used. For state and coarser
  /// level addresses, text matching is used.
  /// If this field is set to `false` or isn't specified, only jobs that include
  /// street level addresses will be returned by commute search.
  public var allowImpreciseAddresses: Bool = false

  /// Traffic factor to take into account while searching by commute.
  public var trafficOption: Google_Cloud_Talent_V4beta1_CommuteFilter.OneOf_TrafficOption? = nil

  /// Specifies the traffic density to use when calculating commute time.
  public var roadTraffic: Google_Cloud_Talent_V4beta1_CommuteFilter.RoadTraffic {
    get {
      if case .roadTraffic(let v)? = trafficOption {return v}
      return .unspecified
    }
    set {trafficOption = .roadTraffic(newValue)}
  }

  /// The departure time used to calculate traffic impact, represented as
  /// [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
  ///
  /// Currently traffic model is restricted to hour level resolution.
  public var departureTime: Google_Type_TimeOfDay {
    get {
      if case .departureTime(let v)? = trafficOption {return v}
      return Google_Type_TimeOfDay()
    }
    set {trafficOption = .departureTime(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Traffic factor to take into account while searching by commute.
  public enum OneOf_TrafficOption: Equatable {
    /// Specifies the traffic density to use when calculating commute time.
    case roadTraffic(Google_Cloud_Talent_V4beta1_CommuteFilter.RoadTraffic)
    /// The departure time used to calculate traffic impact, represented as
    /// [google.type.TimeOfDay][google.type.TimeOfDay] in local time zone.
    ///
    /// Currently traffic model is restricted to hour level resolution.
    case departureTime(Google_Type_TimeOfDay)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Talent_V4beta1_CommuteFilter.OneOf_TrafficOption, rhs: Google_Cloud_Talent_V4beta1_CommuteFilter.OneOf_TrafficOption) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.roadTraffic, .roadTraffic): return {
        guard case .roadTraffic(let l) = lhs, case .roadTraffic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.departureTime, .departureTime): return {
        guard case .departureTime(let l) = lhs, case .departureTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The traffic density to use when calculating commute time.
  public enum RoadTraffic: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Road traffic situation isn't specified.
    case unspecified // = 0

    /// Optimal commute time without considering any traffic impact.
    case trafficFree // = 1

    /// Commute time calculation takes in account the peak traffic impact.
    case busyHour // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .trafficFree
      case 2: self = .busyHour
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .trafficFree: return 1
      case .busyHour: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startCoordinates: Google_Type_LatLng? = nil
  fileprivate var _travelDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4beta1_CommuteFilter.RoadTraffic: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4beta1_CommuteFilter.RoadTraffic] = [
    .unspecified,
    .trafficFree,
    .busyHour,
  ]
}

#endif  // swift(>=4.2)

/// Job title of the search.
public struct Google_Cloud_Talent_V4beta1_JobTitleFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The job title. For example, "Software engineer", or "Product manager".
  public var jobTitle: String = String()

  /// Whether to apply negation to the filter so profiles matching the filter
  /// are excluded.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Skill filter of the search.
public struct Google_Cloud_Talent_V4beta1_SkillFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The skill name. For example, "java", "j2ee", and so on.
  public var skill: String = String()

  /// Whether to apply negation to the filter so profiles matching the filter
  /// are excluded.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Employer filter of the search.
public struct Google_Cloud_Talent_V4beta1_EmployerFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the employer, for example "Google", "Alphabet".
  public var employer: String = String()

  /// Define set of [EmploymentRecord][google.cloud.talent.v4beta1.EmploymentRecord]s to search against.
  ///
  /// Defaults to [EmployerFilterMode.ALL_EMPLOYMENT_RECORDS][google.cloud.talent.v4beta1.EmployerFilter.EmployerFilterMode.ALL_EMPLOYMENT_RECORDS].
  public var mode: Google_Cloud_Talent_V4beta1_EmployerFilter.EmployerFilterMode = .unspecified

  /// Whether to apply negation to the filter so profiles matching the filter
  /// is excluded.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enum indicating which set of [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records] to search
  /// against.
  public enum EmployerFilterMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value.
    case unspecified // = 0

    /// Apply to all employers in [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records].
    case allEmploymentRecords // = 1

    /// Apply only to current employer in [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records].
    case currentEmploymentRecordsOnly // = 2

    /// Apply only to past (not current) employers in
    /// [Profile.employment_records][google.cloud.talent.v4beta1.Profile.employment_records].
    case pastEmploymentRecordsOnly // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .allEmploymentRecords
      case 2: self = .currentEmploymentRecordsOnly
      case 3: self = .pastEmploymentRecordsOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .allEmploymentRecords: return 1
      case .currentEmploymentRecordsOnly: return 2
      case .pastEmploymentRecordsOnly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4beta1_EmployerFilter.EmployerFilterMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4beta1_EmployerFilter.EmployerFilterMode] = [
    .unspecified,
    .allEmploymentRecords,
    .currentEmploymentRecordsOnly,
    .pastEmploymentRecordsOnly,
  ]
}

#endif  // swift(>=4.2)

/// Education filter of the search.
public struct Google_Cloud_Talent_V4beta1_EducationFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The school name. For example "MIT", "University of California, Berkeley".
  public var school: String = String()

  /// The field of study. This is to search against value provided in
  /// [Degree.fields_of_study][google.cloud.talent.v4beta1.Degree.fields_of_study].
  /// For example "Computer Science", "Mathematics".
  public var fieldOfStudy: String = String()

  /// Education degree in ISCED code. Each value in degree covers a specific
  /// level of education, without any expansion to upper nor lower levels of
  /// education degree.
  public var degreeType: Google_Cloud_Talent_V4beta1_DegreeType = .unspecified

  /// Whether to apply negation to the filter so profiles matching the filter
  /// is excluded.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Work experience filter.
///
/// This filter is used to search for profiles with working experience length
/// between [min_experience][google.cloud.talent.v4beta1.WorkExperienceFilter.min_experience] and [max_experience][google.cloud.talent.v4beta1.WorkExperienceFilter.max_experience].
public struct Google_Cloud_Talent_V4beta1_WorkExperienceFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum duration of the work experience (inclusive).
  public var minExperience: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minExperience ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minExperience = newValue}
  }
  /// Returns true if `minExperience` has been explicitly set.
  public var hasMinExperience: Bool {return self._minExperience != nil}
  /// Clears the value of `minExperience`. Subsequent reads from it will return its default value.
  public mutating func clearMinExperience() {self._minExperience = nil}

  /// The maximum duration of the work experience (exclusive).
  public var maxExperience: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxExperience ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxExperience = newValue}
  }
  /// Returns true if `maxExperience` has been explicitly set.
  public var hasMaxExperience: Bool {return self._maxExperience != nil}
  /// Clears the value of `maxExperience`. Subsequent reads from it will return its default value.
  public mutating func clearMaxExperience() {self._maxExperience = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _minExperience: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxExperience: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Application Date Range Filter.
///
/// The API matches profiles with [Application.application_date][google.cloud.talent.v4beta1.Application.application_date] between
/// start date and end date (both boundaries are inclusive). The filter is
/// ignored if both [start_date][google.cloud.talent.v4beta1.ApplicationDateFilter.start_date] and [end_date][google.cloud.talent.v4beta1.ApplicationDateFilter.end_date] are missing.
public struct Google_Cloud_Talent_V4beta1_ApplicationDateFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start date. If it's missing, The API matches profiles with application date
  /// not after the end date.
  public var startDate: Google_Type_Date {
    get {return _startDate ?? Google_Type_Date()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {self._startDate = nil}

  /// End date. If it's missing, The API matches profiles with application date
  /// not before the start date.
  public var endDate: Google_Type_Date {
    get {return _endDate ?? Google_Type_Date()}
    set {_endDate = newValue}
  }
  /// Returns true if `endDate` has been explicitly set.
  public var hasEndDate: Bool {return self._endDate != nil}
  /// Clears the value of `endDate`. Subsequent reads from it will return its default value.
  public mutating func clearEndDate() {self._endDate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startDate: Google_Type_Date? = nil
  fileprivate var _endDate: Google_Type_Date? = nil
}

/// Outcome Notes Filter.
public struct Google_Cloud_Talent_V4beta1_ApplicationOutcomeNotesFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. User entered or selected outcome reason. The API does an exact match on the
  /// [Application.outcome_notes][google.cloud.talent.v4beta1.Application.outcome_notes] in profiles.
  public var outcomeNotes: String = String()

  /// If true, The API excludes all candidates with any
  /// [Application.outcome_notes][google.cloud.talent.v4beta1.Application.outcome_notes] matching the outcome reason specified in
  /// the filter.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filter on the job information of Application.
public struct Google_Cloud_Talent_V4beta1_ApplicationJobFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The job requisition id in the application. The API does an exact match on
  /// the [Job.requisition_id][google.cloud.talent.v4beta1.Job.requisition_id] of [Application.job][google.cloud.talent.v4beta1.Application.job] in profiles.
  public var jobRequisitionID: String = String()

  /// The job title in the application. The API does an exact match on the
  /// [Job.title][google.cloud.talent.v4beta1.Job.title] of [Application.job][google.cloud.talent.v4beta1.Application.job] in profiles.
  public var jobTitle: String = String()

  /// If true, the API excludes all profiles with any [Application.job][google.cloud.talent.v4beta1.Application.job]
  /// matching the filters.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filter on create timestamp or update timestamp of profiles.
public struct Google_Cloud_Talent_V4beta1_TimeFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start timestamp, matching profiles with the start time. If this field
  /// missing, The API matches profiles with create / update timestamp before the
  /// end timestamp.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// End timestamp, matching profiles with the end time. If this field
  /// missing, The API matches profiles with create / update timestamp after the
  /// start timestamp.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Specifies which time field to filter profiles.
  ///
  /// Defaults to [TimeField.CREATE_TIME][google.cloud.talent.v4beta1.TimeFilter.TimeField.CREATE_TIME].
  public var timeField: Google_Cloud_Talent_V4beta1_TimeFilter.TimeField = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Time fields can be used in TimeFilter.
  public enum TimeField: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value.
    case unspecified // = 0

    /// Earliest profile create time.
    case createTime // = 1

    /// Latest profile update time.
    case updateTime // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .createTime
      case 2: self = .updateTime
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .createTime: return 1
      case .updateTime: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Talent_V4beta1_TimeFilter.TimeField: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Talent_V4beta1_TimeFilter.TimeField] = [
    .unspecified,
    .createTime,
    .updateTime,
  ]
}

#endif  // swift(>=4.2)

/// Deprecated. Use AvailabilityFilter instead.
///
/// Filter on availability signals.
public struct Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// It is false by default. If true, API excludes all the potential available
  /// profiles.
  public var negated: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filter on availability signals.
public struct Google_Cloud_Talent_V4beta1_AvailabilityFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Type of signal to apply filter on.
  public var signalType: Google_Cloud_Talent_V4beta1_AvailabilitySignalType = .unspecified

  /// Required. Range of times to filter candidate signals by.
  public var range: Google_Cloud_Talent_V4beta1_TimestampRange {
    get {return _range ?? Google_Cloud_Talent_V4beta1_TimestampRange()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  /// If multiple [AvailabilityFilter][google.cloud.talent.v4beta1.AvailabilityFilter] are provided, the default
  /// behavior is to OR all filters, but if this field is set to true, this
  /// particular [AvailabilityFilter][google.cloud.talent.v4beta1.AvailabilityFilter] will be AND'ed against other
  /// [AvailabilityFilter][google.cloud.talent.v4beta1.AvailabilityFilter].
  public var required: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _range: Google_Cloud_Talent_V4beta1_TimestampRange? = nil
}

/// Filter on person name.
public struct Google_Cloud_Talent_V4beta1_PersonNameFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The person name. For example, "John Smith".
  ///
  /// Can be any combination of [PersonName.structured_name.given_name][],
  /// [PersonName.structured_name.middle_initial][],
  /// [PersonName.structured_name.family_name][], and
  /// [PersonName.formatted_name][google.cloud.talent.v4beta1.PersonName.formatted_name].
  public var personName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.talent.v4beta1"

extension Google_Cloud_Talent_V4beta1_JobQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    14: .standard(proto: "query_language_code"),
    2: .same(proto: "companies"),
    3: .standard(proto: "location_filters"),
    4: .standard(proto: "job_categories"),
    5: .standard(proto: "commute_filter"),
    6: .standard(proto: "company_display_names"),
    7: .standard(proto: "compensation_filter"),
    8: .standard(proto: "custom_attribute_filter"),
    9: .standard(proto: "disable_spell_check"),
    10: .standard(proto: "employment_types"),
    11: .standard(proto: "language_codes"),
    12: .standard(proto: "publish_time_range"),
    13: .standard(proto: "excluded_jobs"),
  ]

  fileprivate class _StorageClass {
    var _query: String = String()
    var _queryLanguageCode: String = String()
    var _companies: [String] = []
    var _locationFilters: [Google_Cloud_Talent_V4beta1_LocationFilter] = []
    var _jobCategories: [Google_Cloud_Talent_V4beta1_JobCategory] = []
    var _commuteFilter: Google_Cloud_Talent_V4beta1_CommuteFilter? = nil
    var _companyDisplayNames: [String] = []
    var _compensationFilter: Google_Cloud_Talent_V4beta1_CompensationFilter? = nil
    var _customAttributeFilter: String = String()
    var _disableSpellCheck: Bool = false
    var _employmentTypes: [Google_Cloud_Talent_V4beta1_EmploymentType] = []
    var _languageCodes: [String] = []
    var _publishTimeRange: Google_Cloud_Talent_V4beta1_TimestampRange? = nil
    var _excludedJobs: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _query = source._query
      _queryLanguageCode = source._queryLanguageCode
      _companies = source._companies
      _locationFilters = source._locationFilters
      _jobCategories = source._jobCategories
      _commuteFilter = source._commuteFilter
      _companyDisplayNames = source._companyDisplayNames
      _compensationFilter = source._compensationFilter
      _customAttributeFilter = source._customAttributeFilter
      _disableSpellCheck = source._disableSpellCheck
      _employmentTypes = source._employmentTypes
      _languageCodes = source._languageCodes
      _publishTimeRange = source._publishTimeRange
      _excludedJobs = source._excludedJobs
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._companies) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._locationFilters) }()
        case 4: try { try decoder.decodeRepeatedEnumField(value: &_storage._jobCategories) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._commuteFilter) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._companyDisplayNames) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._compensationFilter) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._customAttributeFilter) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._disableSpellCheck) }()
        case 10: try { try decoder.decodeRepeatedEnumField(value: &_storage._employmentTypes) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._languageCodes) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._publishTimeRange) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._excludedJobs) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._queryLanguageCode) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 1)
      }
      if !_storage._companies.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._companies, fieldNumber: 2)
      }
      if !_storage._locationFilters.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._locationFilters, fieldNumber: 3)
      }
      if !_storage._jobCategories.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._jobCategories, fieldNumber: 4)
      }
      if let v = _storage._commuteFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._companyDisplayNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._companyDisplayNames, fieldNumber: 6)
      }
      if let v = _storage._compensationFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._customAttributeFilter.isEmpty {
        try visitor.visitSingularStringField(value: _storage._customAttributeFilter, fieldNumber: 8)
      }
      if _storage._disableSpellCheck != false {
        try visitor.visitSingularBoolField(value: _storage._disableSpellCheck, fieldNumber: 9)
      }
      if !_storage._employmentTypes.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._employmentTypes, fieldNumber: 10)
      }
      if !_storage._languageCodes.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._languageCodes, fieldNumber: 11)
      }
      if let v = _storage._publishTimeRange {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._excludedJobs.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._excludedJobs, fieldNumber: 13)
      }
      if !_storage._queryLanguageCode.isEmpty {
        try visitor.visitSingularStringField(value: _storage._queryLanguageCode, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_JobQuery, rhs: Google_Cloud_Talent_V4beta1_JobQuery) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._query != rhs_storage._query {return false}
        if _storage._queryLanguageCode != rhs_storage._queryLanguageCode {return false}
        if _storage._companies != rhs_storage._companies {return false}
        if _storage._locationFilters != rhs_storage._locationFilters {return false}
        if _storage._jobCategories != rhs_storage._jobCategories {return false}
        if _storage._commuteFilter != rhs_storage._commuteFilter {return false}
        if _storage._companyDisplayNames != rhs_storage._companyDisplayNames {return false}
        if _storage._compensationFilter != rhs_storage._compensationFilter {return false}
        if _storage._customAttributeFilter != rhs_storage._customAttributeFilter {return false}
        if _storage._disableSpellCheck != rhs_storage._disableSpellCheck {return false}
        if _storage._employmentTypes != rhs_storage._employmentTypes {return false}
        if _storage._languageCodes != rhs_storage._languageCodes {return false}
        if _storage._publishTimeRange != rhs_storage._publishTimeRange {return false}
        if _storage._excludedJobs != rhs_storage._excludedJobs {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_ProfileQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ProfileQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "query"),
    2: .standard(proto: "location_filters"),
    3: .standard(proto: "job_title_filters"),
    4: .standard(proto: "employer_filters"),
    5: .standard(proto: "education_filters"),
    6: .standard(proto: "skill_filters"),
    7: .standard(proto: "work_experience_filter"),
    8: .standard(proto: "time_filters"),
    9: .standard(proto: "hirable_filter"),
    10: .standard(proto: "application_date_filters"),
    11: .standard(proto: "application_outcome_notes_filters"),
    13: .standard(proto: "application_job_filters"),
    15: .standard(proto: "custom_attribute_filter"),
    16: .standard(proto: "candidate_availability_filter"),
    18: .standard(proto: "availability_filters"),
    17: .standard(proto: "person_name_filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.locationFilters) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.jobTitleFilters) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.employerFilters) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.educationFilters) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.skillFilters) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.workExperienceFilter) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.timeFilters) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._hirableFilter) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.applicationDateFilters) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.applicationOutcomeNotesFilters) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.applicationJobFilters) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.customAttributeFilter) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._candidateAvailabilityFilter) }()
      case 17: try { try decoder.decodeRepeatedMessageField(value: &self.personNameFilters) }()
      case 18: try { try decoder.decodeRepeatedMessageField(value: &self.availabilityFilters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    if !self.locationFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locationFilters, fieldNumber: 2)
    }
    if !self.jobTitleFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jobTitleFilters, fieldNumber: 3)
    }
    if !self.employerFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.employerFilters, fieldNumber: 4)
    }
    if !self.educationFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.educationFilters, fieldNumber: 5)
    }
    if !self.skillFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.skillFilters, fieldNumber: 6)
    }
    if !self.workExperienceFilter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workExperienceFilter, fieldNumber: 7)
    }
    if !self.timeFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.timeFilters, fieldNumber: 8)
    }
    if let v = self._hirableFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.applicationDateFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.applicationDateFilters, fieldNumber: 10)
    }
    if !self.applicationOutcomeNotesFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.applicationOutcomeNotesFilters, fieldNumber: 11)
    }
    if !self.applicationJobFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.applicationJobFilters, fieldNumber: 13)
    }
    if !self.customAttributeFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.customAttributeFilter, fieldNumber: 15)
    }
    if let v = self._candidateAvailabilityFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }
    if !self.personNameFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.personNameFilters, fieldNumber: 17)
    }
    if !self.availabilityFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.availabilityFilters, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_ProfileQuery, rhs: Google_Cloud_Talent_V4beta1_ProfileQuery) -> Bool {
    if lhs.query != rhs.query {return false}
    if lhs.locationFilters != rhs.locationFilters {return false}
    if lhs.jobTitleFilters != rhs.jobTitleFilters {return false}
    if lhs.employerFilters != rhs.employerFilters {return false}
    if lhs.educationFilters != rhs.educationFilters {return false}
    if lhs.skillFilters != rhs.skillFilters {return false}
    if lhs.workExperienceFilter != rhs.workExperienceFilter {return false}
    if lhs.timeFilters != rhs.timeFilters {return false}
    if lhs._hirableFilter != rhs._hirableFilter {return false}
    if lhs.applicationDateFilters != rhs.applicationDateFilters {return false}
    if lhs.applicationOutcomeNotesFilters != rhs.applicationOutcomeNotesFilters {return false}
    if lhs.applicationJobFilters != rhs.applicationJobFilters {return false}
    if lhs.customAttributeFilter != rhs.customAttributeFilter {return false}
    if lhs._candidateAvailabilityFilter != rhs._candidateAvailabilityFilter {return false}
    if lhs.availabilityFilters != rhs.availabilityFilters {return false}
    if lhs.personNameFilters != rhs.personNameFilters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_LocationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "region_code"),
    3: .standard(proto: "lat_lng"),
    4: .standard(proto: "distance_in_miles"),
    5: .standard(proto: "telecommute_preference"),
    6: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._latLng) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.distanceInMiles) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.telecommutePreference) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 2)
    }
    if let v = self._latLng {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.distanceInMiles != 0 {
      try visitor.visitSingularDoubleField(value: self.distanceInMiles, fieldNumber: 4)
    }
    if self.telecommutePreference != .unspecified {
      try visitor.visitSingularEnumField(value: self.telecommutePreference, fieldNumber: 5)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_LocationFilter, rhs: Google_Cloud_Talent_V4beta1_LocationFilter) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs._latLng != rhs._latLng {return false}
    if lhs.distanceInMiles != rhs.distanceInMiles {return false}
    if lhs.telecommutePreference != rhs.telecommutePreference {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_LocationFilter.TelecommutePreference: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TELECOMMUTE_PREFERENCE_UNSPECIFIED"),
    1: .same(proto: "TELECOMMUTE_EXCLUDED"),
    2: .same(proto: "TELECOMMUTE_ALLOWED"),
  ]
}

extension Google_Cloud_Talent_V4beta1_CompensationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompensationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "units"),
    3: .same(proto: "range"),
    4: .standard(proto: "include_jobs_with_unspecified_compensation_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.units) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeJobsWithUnspecifiedCompensationRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.units.isEmpty {
      try visitor.visitPackedEnumField(value: self.units, fieldNumber: 2)
    }
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.includeJobsWithUnspecifiedCompensationRange != false {
      try visitor.visitSingularBoolField(value: self.includeJobsWithUnspecifiedCompensationRange, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_CompensationFilter, rhs: Google_Cloud_Talent_V4beta1_CompensationFilter) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.units != rhs.units {return false}
    if lhs._range != rhs._range {return false}
    if lhs.includeJobsWithUnspecifiedCompensationRange != rhs.includeJobsWithUnspecifiedCompensationRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_CompensationFilter.FilterType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILTER_TYPE_UNSPECIFIED"),
    1: .same(proto: "UNIT_ONLY"),
    2: .same(proto: "UNIT_AND_AMOUNT"),
    3: .same(proto: "ANNUALIZED_BASE_AMOUNT"),
    4: .same(proto: "ANNUALIZED_TOTAL_AMOUNT"),
  ]
}

extension Google_Cloud_Talent_V4beta1_CommuteFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommuteFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commute_method"),
    2: .standard(proto: "start_coordinates"),
    3: .standard(proto: "travel_duration"),
    4: .standard(proto: "allow_imprecise_addresses"),
    5: .standard(proto: "road_traffic"),
    6: .standard(proto: "departure_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.commuteMethod) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startCoordinates) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._travelDuration) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.allowImpreciseAddresses) }()
      case 5: try {
        if self.trafficOption != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Talent_V4beta1_CommuteFilter.RoadTraffic?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.trafficOption = .roadTraffic(v)}
      }()
      case 6: try {
        var v: Google_Type_TimeOfDay?
        if let current = self.trafficOption {
          try decoder.handleConflictingOneOf()
          if case .departureTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.trafficOption = .departureTime(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.commuteMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.commuteMethod, fieldNumber: 1)
    }
    if let v = self._startCoordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._travelDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.allowImpreciseAddresses != false {
      try visitor.visitSingularBoolField(value: self.allowImpreciseAddresses, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.trafficOption {
    case .roadTraffic?: try {
      guard case .roadTraffic(let v)? = self.trafficOption else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }()
    case .departureTime?: try {
      guard case .departureTime(let v)? = self.trafficOption else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_CommuteFilter, rhs: Google_Cloud_Talent_V4beta1_CommuteFilter) -> Bool {
    if lhs.commuteMethod != rhs.commuteMethod {return false}
    if lhs._startCoordinates != rhs._startCoordinates {return false}
    if lhs._travelDuration != rhs._travelDuration {return false}
    if lhs.allowImpreciseAddresses != rhs.allowImpreciseAddresses {return false}
    if lhs.trafficOption != rhs.trafficOption {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_CommuteFilter.RoadTraffic: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ROAD_TRAFFIC_UNSPECIFIED"),
    1: .same(proto: "TRAFFIC_FREE"),
    2: .same(proto: "BUSY_HOUR"),
  ]
}

extension Google_Cloud_Talent_V4beta1_JobTitleFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".JobTitleFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_title"),
    2: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobTitle) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.jobTitle, fieldNumber: 1)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_JobTitleFilter, rhs: Google_Cloud_Talent_V4beta1_JobTitleFilter) -> Bool {
    if lhs.jobTitle != rhs.jobTitle {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_SkillFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SkillFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "skill"),
    2: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.skill) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.skill.isEmpty {
      try visitor.visitSingularStringField(value: self.skill, fieldNumber: 1)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_SkillFilter, rhs: Google_Cloud_Talent_V4beta1_SkillFilter) -> Bool {
    if lhs.skill != rhs.skill {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_EmployerFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmployerFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "employer"),
    2: .same(proto: "mode"),
    3: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.employer) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.employer.isEmpty {
      try visitor.visitSingularStringField(value: self.employer, fieldNumber: 1)
    }
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 2)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_EmployerFilter, rhs: Google_Cloud_Talent_V4beta1_EmployerFilter) -> Bool {
    if lhs.employer != rhs.employer {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_EmployerFilter.EmployerFilterMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPLOYER_FILTER_MODE_UNSPECIFIED"),
    1: .same(proto: "ALL_EMPLOYMENT_RECORDS"),
    2: .same(proto: "CURRENT_EMPLOYMENT_RECORDS_ONLY"),
    3: .same(proto: "PAST_EMPLOYMENT_RECORDS_ONLY"),
  ]
}

extension Google_Cloud_Talent_V4beta1_EducationFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EducationFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "school"),
    2: .standard(proto: "field_of_study"),
    3: .standard(proto: "degree_type"),
    6: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.school) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fieldOfStudy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.degreeType) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.school.isEmpty {
      try visitor.visitSingularStringField(value: self.school, fieldNumber: 1)
    }
    if !self.fieldOfStudy.isEmpty {
      try visitor.visitSingularStringField(value: self.fieldOfStudy, fieldNumber: 2)
    }
    if self.degreeType != .unspecified {
      try visitor.visitSingularEnumField(value: self.degreeType, fieldNumber: 3)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_EducationFilter, rhs: Google_Cloud_Talent_V4beta1_EducationFilter) -> Bool {
    if lhs.school != rhs.school {return false}
    if lhs.fieldOfStudy != rhs.fieldOfStudy {return false}
    if lhs.degreeType != rhs.degreeType {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_WorkExperienceFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkExperienceFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_experience"),
    2: .standard(proto: "max_experience"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minExperience) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxExperience) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._minExperience {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxExperience {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_WorkExperienceFilter, rhs: Google_Cloud_Talent_V4beta1_WorkExperienceFilter) -> Bool {
    if lhs._minExperience != rhs._minExperience {return false}
    if lhs._maxExperience != rhs._maxExperience {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_ApplicationDateFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplicationDateFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_date"),
    2: .standard(proto: "end_date"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startDate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endDate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_ApplicationDateFilter, rhs: Google_Cloud_Talent_V4beta1_ApplicationDateFilter) -> Bool {
    if lhs._startDate != rhs._startDate {return false}
    if lhs._endDate != rhs._endDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_ApplicationOutcomeNotesFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplicationOutcomeNotesFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "outcome_notes"),
    2: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.outcomeNotes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outcomeNotes.isEmpty {
      try visitor.visitSingularStringField(value: self.outcomeNotes, fieldNumber: 1)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_ApplicationOutcomeNotesFilter, rhs: Google_Cloud_Talent_V4beta1_ApplicationOutcomeNotesFilter) -> Bool {
    if lhs.outcomeNotes != rhs.outcomeNotes {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_ApplicationJobFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplicationJobFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "job_requisition_id"),
    3: .standard(proto: "job_title"),
    4: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobRequisitionID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.jobTitle) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobRequisitionID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobRequisitionID, fieldNumber: 2)
    }
    if !self.jobTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.jobTitle, fieldNumber: 3)
    }
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_ApplicationJobFilter, rhs: Google_Cloud_Talent_V4beta1_ApplicationJobFilter) -> Bool {
    if lhs.jobRequisitionID != rhs.jobRequisitionID {return false}
    if lhs.jobTitle != rhs.jobTitle {return false}
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_TimeFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "time_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.timeField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.timeField != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeField, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_TimeFilter, rhs: Google_Cloud_Talent_V4beta1_TimeFilter) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.timeField != rhs.timeField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_TimeFilter.TimeField: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIME_FIELD_UNSPECIFIED"),
    1: .same(proto: "CREATE_TIME"),
    2: .same(proto: "UPDATE_TIME"),
  ]
}

extension Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CandidateAvailabilityFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "negated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.negated) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.negated != false {
      try visitor.visitSingularBoolField(value: self.negated, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter, rhs: Google_Cloud_Talent_V4beta1_CandidateAvailabilityFilter) -> Bool {
    if lhs.negated != rhs.negated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_AvailabilityFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AvailabilityFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signal_type"),
    2: .same(proto: "range"),
    3: .same(proto: "required"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.signalType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.required) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.signalType != .unspecified {
      try visitor.visitSingularEnumField(value: self.signalType, fieldNumber: 1)
    }
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.required != false {
      try visitor.visitSingularBoolField(value: self.required, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_AvailabilityFilter, rhs: Google_Cloud_Talent_V4beta1_AvailabilityFilter) -> Bool {
    if lhs.signalType != rhs.signalType {return false}
    if lhs._range != rhs._range {return false}
    if lhs.required != rhs.required {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Talent_V4beta1_PersonNameFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PersonNameFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "person_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.personName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.personName.isEmpty {
      try visitor.visitSingularStringField(value: self.personName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Talent_V4beta1_PersonNameFilter, rhs: Google_Cloud_Talent_V4beta1_PersonNameFilter) -> Bool {
    if lhs.personName != rhs.personName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

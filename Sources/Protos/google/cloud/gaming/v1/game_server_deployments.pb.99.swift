// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/gaming/v1/game_server_deployments.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for GameServerDeploymentsService.ListGameServerDeployments.
public struct Google_Cloud_Gaming_V1_ListGameServerDeploymentsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource name. Uses the form:
  /// `projects/{project}/locations/{location}`.
  public var parent: String = String()

  /// Optional. The maximum number of items to return.  If unspecified, the server
  /// will pick an appropriate default. The server may return fewer items than
  /// requested. A caller should only rely on response's
  /// [next_page_token][google.cloud.gaming.v1.ListGameServerDeploymentsResponse.next_page_token] to
  /// determine if there are more GameServerDeployments left to be queried.
  public var pageSize: Int32 = 0

  /// Optional. The next_page_token value returned from a previous List request,
  /// if any.
  public var pageToken: String = String()

  /// Optional. The filter to apply to list results.
  public var filter: String = String()

  /// Optional. Specifies the ordering of results following syntax at
  /// https://cloud.google.com/apis/design/design_patterns#sorting_order.
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for GameServerDeploymentsService.ListGameServerDeployments.
public struct Google_Cloud_Gaming_V1_ListGameServerDeploymentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of game server deployments.
  public var gameServerDeployments: [Google_Cloud_Gaming_V1_GameServerDeployment] = []

  /// Token to retrieve the next page of results, or empty if there are no more
  /// results in the list.
  public var nextPageToken: String = String()

  /// List of locations that could not be reached.
  public var unreachable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GameServerDeploymentsService.GetGameServerDeployment.
public struct Google_Cloud_Gaming_V1_GetGameServerDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the game server delpoyment to retrieve. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// GameServerDeploymentsService.GetGameServerDeploymentRollout.
public struct Google_Cloud_Gaming_V1_GetGameServerDeploymentRolloutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the game server delpoyment to retrieve. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment}/rollout`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GameServerDeploymentsService.CreateGameServerDeployment.
public struct Google_Cloud_Gaming_V1_CreateGameServerDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource name. Uses the form:
  /// `projects/{project}/locations/{location}`.
  public var parent: String = String()

  /// Required. The ID of the game server delpoyment resource to be created.
  public var deploymentID: String = String()

  /// Required. The game server delpoyment resource to be created.
  public var gameServerDeployment: Google_Cloud_Gaming_V1_GameServerDeployment {
    get {return _gameServerDeployment ?? Google_Cloud_Gaming_V1_GameServerDeployment()}
    set {_gameServerDeployment = newValue}
  }
  /// Returns true if `gameServerDeployment` has been explicitly set.
  public var hasGameServerDeployment: Bool {return self._gameServerDeployment != nil}
  /// Clears the value of `gameServerDeployment`. Subsequent reads from it will return its default value.
  public mutating func clearGameServerDeployment() {self._gameServerDeployment = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gameServerDeployment: Google_Cloud_Gaming_V1_GameServerDeployment? = nil
}

/// Request message for GameServerDeploymentsService.DeleteGameServerDeployment.
public struct Google_Cloud_Gaming_V1_DeleteGameServerDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the game server delpoyment to delete. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GameServerDeploymentsService.UpdateGameServerDeployment.
/// Only allows updates for labels.
public struct Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The game server delpoyment to be updated.
  /// Only fields specified in update_mask are updated.
  public var gameServerDeployment: Google_Cloud_Gaming_V1_GameServerDeployment {
    get {return _gameServerDeployment ?? Google_Cloud_Gaming_V1_GameServerDeployment()}
    set {_gameServerDeployment = newValue}
  }
  /// Returns true if `gameServerDeployment` has been explicitly set.
  public var hasGameServerDeployment: Bool {return self._gameServerDeployment != nil}
  /// Clears the value of `gameServerDeployment`. Subsequent reads from it will return its default value.
  public mutating func clearGameServerDeployment() {self._gameServerDeployment = nil}

  /// Required. Mask of fields to update. At least one path must be supplied in
  /// this field. For the `FieldMask` definition, see
  ///
  /// https:
  /// //developers.google.com/protocol-buffers
  /// // /docs/reference/google.protobuf#fieldmask
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gameServerDeployment: Google_Cloud_Gaming_V1_GameServerDeployment? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// GameServerDeploymentsService.UpdateGameServerRolloutDeployment.
public struct Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRolloutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The game server delpoyment rollout to be updated.
  /// Only fields specified in update_mask are updated.
  public var rollout: Google_Cloud_Gaming_V1_GameServerDeploymentRollout {
    get {return _rollout ?? Google_Cloud_Gaming_V1_GameServerDeploymentRollout()}
    set {_rollout = newValue}
  }
  /// Returns true if `rollout` has been explicitly set.
  public var hasRollout: Bool {return self._rollout != nil}
  /// Clears the value of `rollout`. Subsequent reads from it will return its default value.
  public mutating func clearRollout() {self._rollout = nil}

  /// Required. Mask of fields to update. At least one path must be supplied in
  /// this field. For the `FieldMask` definition, see
  ///
  /// https:
  /// //developers.google.com/protocol-buffers
  /// // /docs/reference/google.protobuf#fieldmask
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rollout: Google_Cloud_Gaming_V1_GameServerDeploymentRollout? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for GameServerDeploymentsService.FetchDeploymentState.
public struct Google_Cloud_Gaming_V1_FetchDeploymentStateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the game server delpoyment. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for GameServerDeploymentsService.FetchDeploymentState.
public struct Google_Cloud_Gaming_V1_FetchDeploymentStateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state of the game server deployment in each game server cluster.
  public var clusterState: [Google_Cloud_Gaming_V1_FetchDeploymentStateResponse.DeployedClusterState] = []

  /// List of locations that could not be reached.
  public var unavailable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The game server cluster changes made by the game server deployment.
  public struct DeployedClusterState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the cluster.
    public var cluster: String = String()

    /// The details about the Agones fleets and autoscalers created in the
    /// game server cluster.
    public var fleetDetails: [Google_Cloud_Gaming_V1_DeployedFleetDetails] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A game server deployment resource.
public struct Google_Cloud_Gaming_V1_GameServerDeployment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the game server deployment. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment}`.
  /// For example,
  /// `projects/my-project/locations/global/gameServerDeployments/my-deployment`.
  public var name: String = String()

  /// Output only. The creation time.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last-modified time.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// The labels associated with this game server deployment. Each label is a
  /// key-value pair.
  public var labels: Dictionary<String,String> = [:]

  /// ETag of the resource.
  public var etag: String = String()

  /// Human readable description of the game server delpoyment.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A game server config override.
public struct Google_Cloud_Gaming_V1_GameServerConfigOverride {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Selector chooses the game server config targets.
  public var selector: Google_Cloud_Gaming_V1_GameServerConfigOverride.OneOf_Selector? = nil

  /// Selector for choosing applicable realms.
  public var realmsSelector: Google_Cloud_Gaming_V1_RealmSelector {
    get {
      if case .realmsSelector(let v)? = selector {return v}
      return Google_Cloud_Gaming_V1_RealmSelector()
    }
    set {selector = .realmsSelector(newValue)}
  }

  /// Selects the game server config and how it should be applied.
  public var change: Google_Cloud_Gaming_V1_GameServerConfigOverride.OneOf_Change? = nil

  /// The game server config for this override.
  public var configVersion: String {
    get {
      if case .configVersion(let v)? = change {return v}
      return String()
    }
    set {change = .configVersion(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Selector chooses the game server config targets.
  public enum OneOf_Selector: Equatable {
    /// Selector for choosing applicable realms.
    case realmsSelector(Google_Cloud_Gaming_V1_RealmSelector)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Gaming_V1_GameServerConfigOverride.OneOf_Selector, rhs: Google_Cloud_Gaming_V1_GameServerConfigOverride.OneOf_Selector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.realmsSelector, .realmsSelector): return {
        guard case .realmsSelector(let l) = lhs, case .realmsSelector(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Selects the game server config and how it should be applied.
  public enum OneOf_Change: Equatable {
    /// The game server config for this override.
    case configVersion(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Gaming_V1_GameServerConfigOverride.OneOf_Change, rhs: Google_Cloud_Gaming_V1_GameServerConfigOverride.OneOf_Change) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.configVersion, .configVersion): return {
        guard case .configVersion(let l) = lhs, case .configVersion(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// The game server deployment rollout which represents the desired rollout
/// state.
public struct Google_Cloud_Gaming_V1_GameServerDeploymentRollout {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the game server deployment rollout. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment}/rollout`.
  /// For example,
  ///
  /// `projects/my-project/locations/global/gameServerDeployments/my-deployment/rollout`.
  public var name: String = String()

  /// Output only. The creation time.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The last-modified time.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// The default game server config is applied to all realms unless overridden
  /// in the rollout. For example,
  ///
  /// `projects/my-project/locations/global/gameServerDeployments/my-game/configs/my-config`.
  public var defaultGameServerConfig: String = String()

  /// Contains the game server config rollout overrides. Overrides are processed
  /// in the order they are listed. Once a match is found for a realm, the rest
  /// of the list is not processed.
  public var gameServerConfigOverrides: [Google_Cloud_Gaming_V1_GameServerConfigOverride] = []

  /// ETag of the resource.
  public var etag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request message for PreviewGameServerDeploymentRollout.
public struct Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The game server deployment rollout to be updated.
  /// Only fields specified in update_mask are updated.
  public var rollout: Google_Cloud_Gaming_V1_GameServerDeploymentRollout {
    get {return _rollout ?? Google_Cloud_Gaming_V1_GameServerDeploymentRollout()}
    set {_rollout = newValue}
  }
  /// Returns true if `rollout` has been explicitly set.
  public var hasRollout: Bool {return self._rollout != nil}
  /// Clears the value of `rollout`. Subsequent reads from it will return its default value.
  public mutating func clearRollout() {self._rollout = nil}

  /// Optional. Mask of fields to update. At least one path must be supplied in
  /// this field. For the `FieldMask` definition, see
  ///
  /// https:
  /// //developers.google.com/protocol-buffers
  /// // /docs/reference/google.protobuf#fieldmask
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// Optional. The target timestamp to compute the preview. Defaults to the immediately
  /// after the proposed rollout completes.
  public var previewTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _previewTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_previewTime = newValue}
  }
  /// Returns true if `previewTime` has been explicitly set.
  public var hasPreviewTime: Bool {return self._previewTime != nil}
  /// Clears the value of `previewTime`. Subsequent reads from it will return its default value.
  public mutating func clearPreviewTime() {self._previewTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rollout: Google_Cloud_Gaming_V1_GameServerDeploymentRollout? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _previewTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Response message for PreviewGameServerDeploymentRollout.
/// This has details about the Agones fleet and autoscaler to be actuated.
public struct Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Locations that could not be reached on this request.
  public var unavailable: [String] = []

  /// ETag of the game server deployment.
  public var etag: String = String()

  /// The target state.
  public var targetState: Google_Cloud_Gaming_V1_TargetState {
    get {return _targetState ?? Google_Cloud_Gaming_V1_TargetState()}
    set {_targetState = newValue}
  }
  /// Returns true if `targetState` has been explicitly set.
  public var hasTargetState: Bool {return self._targetState != nil}
  /// Clears the value of `targetState`. Subsequent reads from it will return its default value.
  public mutating func clearTargetState() {self._targetState = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _targetState: Google_Cloud_Gaming_V1_TargetState? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.gaming.v1"

extension Google_Cloud_Gaming_V1_ListGameServerDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGameServerDeploymentsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_ListGameServerDeploymentsRequest, rhs: Google_Cloud_Gaming_V1_ListGameServerDeploymentsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_ListGameServerDeploymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGameServerDeploymentsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_server_deployments"),
    2: .standard(proto: "next_page_token"),
    4: .same(proto: "unreachable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.gameServerDeployments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameServerDeployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameServerDeployments, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_ListGameServerDeploymentsResponse, rhs: Google_Cloud_Gaming_V1_ListGameServerDeploymentsResponse) -> Bool {
    if lhs.gameServerDeployments != rhs.gameServerDeployments {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_GetGameServerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameServerDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_GetGameServerDeploymentRequest, rhs: Google_Cloud_Gaming_V1_GetGameServerDeploymentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_GetGameServerDeploymentRolloutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGameServerDeploymentRolloutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_GetGameServerDeploymentRolloutRequest, rhs: Google_Cloud_Gaming_V1_GetGameServerDeploymentRolloutRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_CreateGameServerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGameServerDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "deployment_id"),
    3: .standard(proto: "game_server_deployment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gameServerDeployment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.deploymentID.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentID, fieldNumber: 2)
    }
    if let v = self._gameServerDeployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_CreateGameServerDeploymentRequest, rhs: Google_Cloud_Gaming_V1_CreateGameServerDeploymentRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.deploymentID != rhs.deploymentID {return false}
    if lhs._gameServerDeployment != rhs._gameServerDeployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_DeleteGameServerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGameServerDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_DeleteGameServerDeploymentRequest, rhs: Google_Cloud_Gaming_V1_DeleteGameServerDeploymentRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGameServerDeploymentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_server_deployment"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._gameServerDeployment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._gameServerDeployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRequest, rhs: Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRequest) -> Bool {
    if lhs._gameServerDeployment != rhs._gameServerDeployment {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRolloutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGameServerDeploymentRolloutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rollout"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rollout) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rollout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRolloutRequest, rhs: Google_Cloud_Gaming_V1_UpdateGameServerDeploymentRolloutRequest) -> Bool {
    if lhs._rollout != rhs._rollout {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_FetchDeploymentStateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchDeploymentStateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_FetchDeploymentStateRequest, rhs: Google_Cloud_Gaming_V1_FetchDeploymentStateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_FetchDeploymentStateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchDeploymentStateResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_state"),
    2: .same(proto: "unavailable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusterState) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.unavailable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterState.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusterState, fieldNumber: 1)
    }
    if !self.unavailable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unavailable, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_FetchDeploymentStateResponse, rhs: Google_Cloud_Gaming_V1_FetchDeploymentStateResponse) -> Bool {
    if lhs.clusterState != rhs.clusterState {return false}
    if lhs.unavailable != rhs.unavailable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_FetchDeploymentStateResponse.DeployedClusterState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_FetchDeploymentStateResponse.protoMessageName + ".DeployedClusterState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cluster"),
    2: .standard(proto: "fleet_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fleetDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 1)
    }
    if !self.fleetDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fleetDetails, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_FetchDeploymentStateResponse.DeployedClusterState, rhs: Google_Cloud_Gaming_V1_FetchDeploymentStateResponse.DeployedClusterState) -> Bool {
    if lhs.cluster != rhs.cluster {return false}
    if lhs.fleetDetails != rhs.fleetDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_GameServerDeployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameServerDeployment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "update_time"),
    4: .same(proto: "labels"),
    7: .same(proto: "etag"),
    8: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 7)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_GameServerDeployment, rhs: Google_Cloud_Gaming_V1_GameServerDeployment) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_GameServerConfigOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameServerConfigOverride"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "realms_selector"),
    100: .standard(proto: "config_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Gaming_V1_RealmSelector?
        if let current = self.selector {
          try decoder.handleConflictingOneOf()
          if case .realmsSelector(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.selector = .realmsSelector(v)}
      }()
      case 100: try {
        if self.change != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.change = .configVersion(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .realmsSelector(let v)? = self.selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if case .configVersion(let v)? = self.change {
      try visitor.visitSingularStringField(value: v, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_GameServerConfigOverride, rhs: Google_Cloud_Gaming_V1_GameServerConfigOverride) -> Bool {
    if lhs.selector != rhs.selector {return false}
    if lhs.change != rhs.change {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_GameServerDeploymentRollout: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GameServerDeploymentRollout"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "update_time"),
    4: .standard(proto: "default_game_server_config"),
    5: .standard(proto: "game_server_config_overrides"),
    6: .same(proto: "etag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultGameServerConfig) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.gameServerConfigOverrides) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.defaultGameServerConfig.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultGameServerConfig, fieldNumber: 4)
    }
    if !self.gameServerConfigOverrides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.gameServerConfigOverrides, fieldNumber: 5)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_GameServerDeploymentRollout, rhs: Google_Cloud_Gaming_V1_GameServerDeploymentRollout) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.defaultGameServerConfig != rhs.defaultGameServerConfig {return false}
    if lhs.gameServerConfigOverrides != rhs.gameServerConfigOverrides {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreviewGameServerDeploymentRolloutRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rollout"),
    2: .standard(proto: "update_mask"),
    3: .standard(proto: "preview_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rollout) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._previewTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rollout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._previewTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutRequest, rhs: Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutRequest) -> Bool {
    if lhs._rollout != rhs._rollout {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._previewTime != rhs._previewTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PreviewGameServerDeploymentRolloutResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "unavailable"),
    3: .same(proto: "etag"),
    4: .standard(proto: "target_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.unavailable) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._targetState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unavailable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unavailable, fieldNumber: 2)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 3)
    }
    if let v = self._targetState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutResponse, rhs: Google_Cloud_Gaming_V1_PreviewGameServerDeploymentRolloutResponse) -> Bool {
    if lhs.unavailable != rhs.unavailable {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs._targetState != rhs._targetState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

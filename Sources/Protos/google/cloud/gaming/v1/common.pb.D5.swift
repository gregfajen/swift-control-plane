// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/gaming/v1/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents the metadata of the long-running operation.
public struct Google_Cloud_Gaming_V1_OperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The time the operation was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time the operation finished running.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Output only. Server-defined resource path for the target of the operation.
  public var target: String = String()

  /// Output only. Name of the verb executed by the operation.
  public var verb: String = String()

  /// Output only. Human-readable status of the operation, if any.
  public var statusMessage: String = String()

  /// Output only. Identifies whether the user has requested cancellation
  /// of the operation. Operations that have successfully been cancelled
  /// have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
  /// corresponding to `Code.CANCELLED`.
  public var requestedCancellation: Bool = false

  /// Output only. API version used to start the operation.
  public var apiVersion: String = String()

  /// Output only. List of Locations that could not be reached.
  public var unreachable: [String] = []

  /// Output only. Operation status for Game Services API operations. Operation status is in
  /// the form of key-value pairs where keys are resource IDs and the values show
  /// the status of the operation. In case of failures, the value includes an
  /// error code and error message.
  public var operationStatus: Dictionary<String,Google_Cloud_Gaming_V1_OperationStatus> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

public struct Google_Cloud_Gaming_V1_OperationStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Whether the operation is done or still in progress.
  public var done: Bool = false

  /// The error code in case of failures.
  public var errorCode: Google_Cloud_Gaming_V1_OperationStatus.ErrorCode = .unspecified

  /// The human-readable error message.
  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ErrorCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unspecified // = 0
    case internalError // = 1
    case permissionDenied // = 2
    case clusterConnection // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .internalError
      case 2: self = .permissionDenied
      case 3: self = .clusterConnection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .internalError: return 1
      case .permissionDenied: return 2
      case .clusterConnection: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Gaming_V1_OperationStatus.ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Gaming_V1_OperationStatus.ErrorCode] = [
    .unspecified,
    .internalError,
    .permissionDenied,
    .clusterConnection,
  ]
}

#endif  // swift(>=4.2)

/// The label selector, used to group labels on the resources.
public struct Google_Cloud_Gaming_V1_LabelSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource labels for this selector.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The realm selector, used to match realm resources.
public struct Google_Cloud_Gaming_V1_RealmSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of realms to match.
  public var realms: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The schedule of a recurring or one time event. The event's time span is
/// specified by start_time and end_time. If the scheduled event's timespan is
/// larger than the cron_spec + cron_job_duration, the event will be recurring.
/// If only cron_spec + cron_job_duration are specified, the event is effective
/// starting at the local time specified by cron_spec, and is recurring.
///
///   start_time|-------[cron job]-------[cron job]-------[cron job]---|end_time
///   cron job: cron spec start time + duration
public struct Google_Cloud_Gaming_V1_Schedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The start time of the event.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The end time of the event.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// The duration for the cron job event. The duration of the event is effective
  /// after the cron job's start time.
  public var cronJobDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _cronJobDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_cronJobDuration = newValue}
  }
  /// Returns true if `cronJobDuration` has been explicitly set.
  public var hasCronJobDuration: Bool {return self._cronJobDuration != nil}
  /// Clears the value of `cronJobDuration`. Subsequent reads from it will return its default value.
  public mutating func clearCronJobDuration() {self._cronJobDuration = nil}

  /// The cron definition of the scheduled event. See
  /// https://en.wikipedia.org/wiki/Cron. Cron spec specifies the local time as
  /// defined by the realm.
  public var cronSpec: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cronJobDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Encapsulates Agones fleet spec and Agones autoscaler spec sources.
public struct Google_Cloud_Gaming_V1_SpecSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The game server config resource. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment_id}/configs/{config_id}`.
  public var gameServerConfigName: String = String()

  /// The name of the Agones leet config or Agones scaling config used to derive
  /// the Agones fleet or Agones autoscaler spec.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Details about the Agones resources.
public struct Google_Cloud_Gaming_V1_TargetDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The game server cluster name. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/realms/{realm}/gameServerClusters/{cluster}`.
  public var gameServerClusterName: String = String()

  /// The game server deployment name. Uses the form:
  ///
  /// `projects/{project}/locations/{location}/gameServerDeployments/{deployment_id}`.
  public var gameServerDeploymentName: String = String()

  /// Agones fleet details for game server clusters and game server deployments.
  public var fleetDetails: [Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Details of the target Agones fleet.
  public struct TargetFleetDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reference to target Agones fleet.
    public var fleet: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleet {
      get {return _fleet ?? Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleet()}
      set {_fleet = newValue}
    }
    /// Returns true if `fleet` has been explicitly set.
    public var hasFleet: Bool {return self._fleet != nil}
    /// Clears the value of `fleet`. Subsequent reads from it will return its default value.
    public mutating func clearFleet() {self._fleet = nil}

    /// Reference to target Agones fleet autoscaling policy.
    public var autoscaler: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleetAutoscaler {
      get {return _autoscaler ?? Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleetAutoscaler()}
      set {_autoscaler = newValue}
    }
    /// Returns true if `autoscaler` has been explicitly set.
    public var hasAutoscaler: Bool {return self._autoscaler != nil}
    /// Clears the value of `autoscaler`. Subsequent reads from it will return its default value.
    public mutating func clearAutoscaler() {self._autoscaler = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Target Agones fleet specification.
    public struct TargetFleet {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the Agones fleet.
      public var name: String = String()

      /// Encapsulates the source of the Agones fleet spec.
      /// The Agones fleet spec source.
      public var specSource: Google_Cloud_Gaming_V1_SpecSource {
        get {return _specSource ?? Google_Cloud_Gaming_V1_SpecSource()}
        set {_specSource = newValue}
      }
      /// Returns true if `specSource` has been explicitly set.
      public var hasSpecSource: Bool {return self._specSource != nil}
      /// Clears the value of `specSource`. Subsequent reads from it will return its default value.
      public mutating func clearSpecSource() {self._specSource = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _specSource: Google_Cloud_Gaming_V1_SpecSource? = nil
    }

    /// Target Agones autoscaler policy reference.
    public struct TargetFleetAutoscaler {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The name of the Agones autoscaler.
      public var name: String = String()

      /// Encapsulates the source of the Agones fleet spec.
      /// Details about the Agones autoscaler spec.
      public var specSource: Google_Cloud_Gaming_V1_SpecSource {
        get {return _specSource ?? Google_Cloud_Gaming_V1_SpecSource()}
        set {_specSource = newValue}
      }
      /// Returns true if `specSource` has been explicitly set.
      public var hasSpecSource: Bool {return self._specSource != nil}
      /// Clears the value of `specSource`. Subsequent reads from it will return its default value.
      public mutating func clearSpecSource() {self._specSource = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _specSource: Google_Cloud_Gaming_V1_SpecSource? = nil
    }

    public init() {}

    fileprivate var _fleet: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleet? = nil
    fileprivate var _autoscaler: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleetAutoscaler? = nil
  }

  public init() {}
}

/// Encapsulates the Target state.
public struct Google_Cloud_Gaming_V1_TargetState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Details about Agones fleets.
  public var details: [Google_Cloud_Gaming_V1_TargetDetails] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Details of the deployed Agones fleet.
public struct Google_Cloud_Gaming_V1_DeployedFleetDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information about the Agones fleet.
  public var deployedFleet: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet {
    get {return _deployedFleet ?? Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet()}
    set {_deployedFleet = newValue}
  }
  /// Returns true if `deployedFleet` has been explicitly set.
  public var hasDeployedFleet: Bool {return self._deployedFleet != nil}
  /// Clears the value of `deployedFleet`. Subsequent reads from it will return its default value.
  public mutating func clearDeployedFleet() {self._deployedFleet = nil}

  /// Information about the Agones autoscaler for that fleet.
  public var deployedAutoscaler: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleetAutoscaler {
    get {return _deployedAutoscaler ?? Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleetAutoscaler()}
    set {_deployedAutoscaler = newValue}
  }
  /// Returns true if `deployedAutoscaler` has been explicitly set.
  public var hasDeployedAutoscaler: Bool {return self._deployedAutoscaler != nil}
  /// Clears the value of `deployedAutoscaler`. Subsequent reads from it will return its default value.
  public mutating func clearDeployedAutoscaler() {self._deployedAutoscaler = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Agones fleet specification and details.
  public struct DeployedFleet {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the Agones fleet.
    public var fleet: String = String()

    /// The fleet spec retrieved from the Agones fleet.
    public var fleetSpec: String = String()

    /// The source spec that is used to create the Agones fleet.
    /// The GameServerConfig resource may no longer exist in the system.
    public var specSource: Google_Cloud_Gaming_V1_SpecSource {
      get {return _specSource ?? Google_Cloud_Gaming_V1_SpecSource()}
      set {_specSource = newValue}
    }
    /// Returns true if `specSource` has been explicitly set.
    public var hasSpecSource: Bool {return self._specSource != nil}
    /// Clears the value of `specSource`. Subsequent reads from it will return its default value.
    public mutating func clearSpecSource() {self._specSource = nil}

    /// The current status of the Agones fleet.
    /// Includes count of game servers in various states.
    public var status: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.DeployedFleetStatus {
      get {return _status ?? Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.DeployedFleetStatus()}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// DeployedFleetStatus has details about the Agones fleets such as how many
    /// are running, how many allocated, and so on.
    public struct DeployedFleetStatus {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The number of GameServer replicas in the READY state in this fleet.
      public var readyReplicas: Int64 = 0

      /// The number of GameServer replicas in the ALLOCATED state in this fleet.
      public var allocatedReplicas: Int64 = 0

      /// The number of GameServer replicas in the RESERVED state in this fleet.
      /// Reserved instances won't be deleted on scale down, but won't cause
      /// an autoscaler to scale up.
      public var reservedReplicas: Int64 = 0

      /// The total number of current GameServer replicas in this fleet.
      public var replicas: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _specSource: Google_Cloud_Gaming_V1_SpecSource? = nil
    fileprivate var _status: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.DeployedFleetStatus? = nil
  }

  /// Details about the Agones autoscaler.
  public struct DeployedFleetAutoscaler {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the Agones autoscaler.
    public var autoscaler: String = String()

    /// The source spec that is used to create the autoscaler.
    /// The GameServerConfig resource may no longer exist in the system.
    public var specSource: Google_Cloud_Gaming_V1_SpecSource {
      get {return _specSource ?? Google_Cloud_Gaming_V1_SpecSource()}
      set {_specSource = newValue}
    }
    /// Returns true if `specSource` has been explicitly set.
    public var hasSpecSource: Bool {return self._specSource != nil}
    /// Clears the value of `specSource`. Subsequent reads from it will return its default value.
    public mutating func clearSpecSource() {self._specSource = nil}

    /// The autoscaler spec retrieved from Agones.
    public var fleetAutoscalerSpec: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _specSource: Google_Cloud_Gaming_V1_SpecSource? = nil
  }

  public init() {}

  fileprivate var _deployedFleet: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet? = nil
  fileprivate var _deployedAutoscaler: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleetAutoscaler? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.gaming.v1"

extension Google_Cloud_Gaming_V1_OperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_time"),
    2: .standard(proto: "end_time"),
    3: .same(proto: "target"),
    4: .same(proto: "verb"),
    5: .standard(proto: "status_message"),
    6: .standard(proto: "requested_cancellation"),
    7: .standard(proto: "api_version"),
    8: .same(proto: "unreachable"),
    9: .standard(proto: "operation_status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.target) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.verb) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusMessage) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.requestedCancellation) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.apiVersion) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Gaming_V1_OperationStatus>.self, value: &self.operationStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.target.isEmpty {
      try visitor.visitSingularStringField(value: self.target, fieldNumber: 3)
    }
    if !self.verb.isEmpty {
      try visitor.visitSingularStringField(value: self.verb, fieldNumber: 4)
    }
    if !self.statusMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMessage, fieldNumber: 5)
    }
    if self.requestedCancellation != false {
      try visitor.visitSingularBoolField(value: self.requestedCancellation, fieldNumber: 6)
    }
    if !self.apiVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.apiVersion, fieldNumber: 7)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 8)
    }
    if !self.operationStatus.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Gaming_V1_OperationStatus>.self, value: self.operationStatus, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_OperationMetadata, rhs: Google_Cloud_Gaming_V1_OperationMetadata) -> Bool {
    if lhs._createTime != rhs._createTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.target != rhs.target {return false}
    if lhs.verb != rhs.verb {return false}
    if lhs.statusMessage != rhs.statusMessage {return false}
    if lhs.requestedCancellation != rhs.requestedCancellation {return false}
    if lhs.apiVersion != rhs.apiVersion {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.operationStatus != rhs.operationStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_OperationStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "done"),
    2: .standard(proto: "error_code"),
    3: .standard(proto: "error_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 1)
    }
    if self.errorCode != .unspecified {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_OperationStatus, rhs: Google_Cloud_Gaming_V1_OperationStatus) -> Bool {
    if lhs.done != rhs.done {return false}
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_OperationStatus.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERROR_CODE_UNSPECIFIED"),
    1: .same(proto: "INTERNAL_ERROR"),
    2: .same(proto: "PERMISSION_DENIED"),
    3: .same(proto: "CLUSTER_CONNECTION"),
  ]
}

extension Google_Cloud_Gaming_V1_LabelSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_LabelSelector, rhs: Google_Cloud_Gaming_V1_LabelSelector) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_RealmSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RealmSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "realms"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.realms) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.realms.isEmpty {
      try visitor.visitRepeatedStringField(value: self.realms, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_RealmSelector, rhs: Google_Cloud_Gaming_V1_RealmSelector) -> Bool {
    if lhs.realms != rhs.realms {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
    3: .standard(proto: "cron_job_duration"),
    4: .standard(proto: "cron_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cronJobDuration) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.cronSpec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._cronJobDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.cronSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.cronSpec, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_Schedule, rhs: Google_Cloud_Gaming_V1_Schedule) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._cronJobDuration != rhs._cronJobDuration {return false}
    if lhs.cronSpec != rhs.cronSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_SpecSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SpecSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_server_config_name"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gameServerConfigName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameServerConfigName.isEmpty {
      try visitor.visitSingularStringField(value: self.gameServerConfigName, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_SpecSource, rhs: Google_Cloud_Gaming_V1_SpecSource) -> Bool {
    if lhs.gameServerConfigName != rhs.gameServerConfigName {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_TargetDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "game_server_cluster_name"),
    2: .standard(proto: "game_server_deployment_name"),
    3: .standard(proto: "fleet_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.gameServerClusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gameServerDeploymentName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.fleetDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.gameServerClusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.gameServerClusterName, fieldNumber: 1)
    }
    if !self.gameServerDeploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.gameServerDeploymentName, fieldNumber: 2)
    }
    if !self.fleetDetails.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fleetDetails, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_TargetDetails, rhs: Google_Cloud_Gaming_V1_TargetDetails) -> Bool {
    if lhs.gameServerClusterName != rhs.gameServerClusterName {return false}
    if lhs.gameServerDeploymentName != rhs.gameServerDeploymentName {return false}
    if lhs.fleetDetails != rhs.fleetDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_TargetDetails.protoMessageName + ".TargetFleetDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fleet"),
    2: .same(proto: "autoscaler"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fleet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._autoscaler) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fleet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._autoscaler {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails, rhs: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails) -> Bool {
    if lhs._fleet != rhs._fleet {return false}
    if lhs._autoscaler != rhs._autoscaler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.protoMessageName + ".TargetFleet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "spec_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._specSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._specSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleet, rhs: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleet) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._specSource != rhs._specSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleetAutoscaler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.protoMessageName + ".TargetFleetAutoscaler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "spec_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._specSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._specSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleetAutoscaler, rhs: Google_Cloud_Gaming_V1_TargetDetails.TargetFleetDetails.TargetFleetAutoscaler) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._specSource != rhs._specSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_TargetState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TargetState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.details.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.details, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_TargetState, rhs: Google_Cloud_Gaming_V1_TargetState) -> Bool {
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_DeployedFleetDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeployedFleetDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "deployed_fleet"),
    2: .standard(proto: "deployed_autoscaler"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deployedFleet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployedAutoscaler) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deployedFleet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._deployedAutoscaler {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_DeployedFleetDetails, rhs: Google_Cloud_Gaming_V1_DeployedFleetDetails) -> Bool {
    if lhs._deployedFleet != rhs._deployedFleet {return false}
    if lhs._deployedAutoscaler != rhs._deployedAutoscaler {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_DeployedFleetDetails.protoMessageName + ".DeployedFleet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fleet"),
    2: .standard(proto: "fleet_spec"),
    3: .standard(proto: "spec_source"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fleet) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fleetSpec) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._specSource) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fleet.isEmpty {
      try visitor.visitSingularStringField(value: self.fleet, fieldNumber: 1)
    }
    if !self.fleetSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.fleetSpec, fieldNumber: 2)
    }
    if let v = self._specSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet, rhs: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet) -> Bool {
    if lhs.fleet != rhs.fleet {return false}
    if lhs.fleetSpec != rhs.fleetSpec {return false}
    if lhs._specSource != rhs._specSource {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.DeployedFleetStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.protoMessageName + ".DeployedFleetStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ready_replicas"),
    2: .standard(proto: "allocated_replicas"),
    3: .standard(proto: "reserved_replicas"),
    4: .same(proto: "replicas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.readyReplicas) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.allocatedReplicas) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.reservedReplicas) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.replicas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.readyReplicas != 0 {
      try visitor.visitSingularInt64Field(value: self.readyReplicas, fieldNumber: 1)
    }
    if self.allocatedReplicas != 0 {
      try visitor.visitSingularInt64Field(value: self.allocatedReplicas, fieldNumber: 2)
    }
    if self.reservedReplicas != 0 {
      try visitor.visitSingularInt64Field(value: self.reservedReplicas, fieldNumber: 3)
    }
    if self.replicas != 0 {
      try visitor.visitSingularInt64Field(value: self.replicas, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.DeployedFleetStatus, rhs: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleet.DeployedFleetStatus) -> Bool {
    if lhs.readyReplicas != rhs.readyReplicas {return false}
    if lhs.allocatedReplicas != rhs.allocatedReplicas {return false}
    if lhs.reservedReplicas != rhs.reservedReplicas {return false}
    if lhs.replicas != rhs.replicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleetAutoscaler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Gaming_V1_DeployedFleetDetails.protoMessageName + ".DeployedFleetAutoscaler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "autoscaler"),
    4: .standard(proto: "spec_source"),
    3: .standard(proto: "fleet_autoscaler_spec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.autoscaler) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fleetAutoscalerSpec) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._specSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.autoscaler.isEmpty {
      try visitor.visitSingularStringField(value: self.autoscaler, fieldNumber: 1)
    }
    if !self.fleetAutoscalerSpec.isEmpty {
      try visitor.visitSingularStringField(value: self.fleetAutoscalerSpec, fieldNumber: 3)
    }
    if let v = self._specSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleetAutoscaler, rhs: Google_Cloud_Gaming_V1_DeployedFleetDetails.DeployedFleetAutoscaler) -> Bool {
    if lhs.autoscaler != rhs.autoscaler {return false}
    if lhs._specSource != rhs._specSource {return false}
    if lhs.fleetAutoscalerSpec != rhs.fleetAutoscalerSpec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

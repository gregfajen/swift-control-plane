// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/webrisk/v1/webrisk.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The type of threat. This maps dirrectly to the threat list a threat may
/// belong to.
public enum Google_Cloud_Webrisk_V1_ThreatType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown.
  case unspecified // = 0

  /// Malware targeting any platform.
  case malware // = 1

  /// Social engineering targeting any platform.
  case socialEngineering // = 2

  /// Unwanted software targeting any platform.
  case unwantedSoftware // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .malware
    case 2: self = .socialEngineering
    case 3: self = .unwantedSoftware
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .malware: return 1
    case .socialEngineering: return 2
    case .unwantedSoftware: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Webrisk_V1_ThreatType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Webrisk_V1_ThreatType] = [
    .unspecified,
    .malware,
    .socialEngineering,
    .unwantedSoftware,
  ]
}

#endif  // swift(>=4.2)

/// The ways in which threat entry sets can be compressed.
public enum Google_Cloud_Webrisk_V1_CompressionType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown.
  case unspecified // = 0

  /// Raw, uncompressed data.
  case raw // = 1

  /// Rice-Golomb encoded data.
  case rice // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .raw
    case 2: self = .rice
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .raw: return 1
    case .rice: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Webrisk_V1_CompressionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Webrisk_V1_CompressionType] = [
    .unspecified,
    .raw,
    .rice,
  ]
}

#endif  // swift(>=4.2)

/// Describes an API diff request.
public struct Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The threat list to update. Only a single ThreatType should be specified.
  public var threatType: Google_Cloud_Webrisk_V1_ThreatType = .unspecified

  /// The current version token of the client for the requested list (the
  /// client version that was received from the last successful diff).
  /// If the client does not have a version token (this is the first time calling
  /// ComputeThreatListDiff), this may be left empty and a full database
  /// snapshot will be returned.
  public var versionToken: Data = Data()

  /// Required. The constraints associated with this request.
  public var constraints: Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.Constraints {
    get {return _constraints ?? Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.Constraints()}
    set {_constraints = newValue}
  }
  /// Returns true if `constraints` has been explicitly set.
  public var hasConstraints: Bool {return self._constraints != nil}
  /// Clears the value of `constraints`. Subsequent reads from it will return its default value.
  public mutating func clearConstraints() {self._constraints = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The constraints for this diff.
  public struct Constraints {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The maximum size in number of entries. The diff will not contain more
    /// entries than this value.  This should be a power of 2 between 2**10 and
    /// 2**20.  If zero, no diff size limit is set.
    public var maxDiffEntries: Int32 = 0

    /// Sets the maximum number of entries that the client is willing to have
    /// in the local database. This should be a power of 2 between 2**10 and
    /// 2**20. If zero, no database size limit is set.
    public var maxDatabaseEntries: Int32 = 0

    /// The compression types supported by the client.
    public var supportedCompressions: [Google_Cloud_Webrisk_V1_CompressionType] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _constraints: Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.Constraints? = nil
}

public struct Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of response. This may indicate that an action must be taken by the
  /// client when the response is received.
  public var responseType: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.ResponseType = .unspecified

  /// A set of entries to add to a local threat type's list.
  public var additions: Google_Cloud_Webrisk_V1_ThreatEntryAdditions {
    get {return _additions ?? Google_Cloud_Webrisk_V1_ThreatEntryAdditions()}
    set {_additions = newValue}
  }
  /// Returns true if `additions` has been explicitly set.
  public var hasAdditions: Bool {return self._additions != nil}
  /// Clears the value of `additions`. Subsequent reads from it will return its default value.
  public mutating func clearAdditions() {self._additions = nil}

  /// A set of entries to remove from a local threat type's list.
  /// This field may be empty.
  public var removals: Google_Cloud_Webrisk_V1_ThreatEntryRemovals {
    get {return _removals ?? Google_Cloud_Webrisk_V1_ThreatEntryRemovals()}
    set {_removals = newValue}
  }
  /// Returns true if `removals` has been explicitly set.
  public var hasRemovals: Bool {return self._removals != nil}
  /// Clears the value of `removals`. Subsequent reads from it will return its default value.
  public mutating func clearRemovals() {self._removals = nil}

  /// The new opaque client version token. This should be retained by the client
  /// and passed into the next call of ComputeThreatListDiff as 'version_token'.
  /// A separate version token should be stored and used for each threatList.
  public var newVersionToken: Data = Data()

  /// The expected SHA256 hash of the client state; that is, of the sorted list
  /// of all hashes present in the database after applying the provided diff.
  /// If the client state doesn't match the expected state, the client must
  /// discard this diff and retry later.
  public var checksum: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.Checksum {
    get {return _checksum ?? Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.Checksum()}
    set {_checksum = newValue}
  }
  /// Returns true if `checksum` has been explicitly set.
  public var hasChecksum: Bool {return self._checksum != nil}
  /// Clears the value of `checksum`. Subsequent reads from it will return its default value.
  public mutating func clearChecksum() {self._checksum = nil}

  /// The soonest the client should wait before issuing any diff
  /// request. Querying sooner is unlikely to produce a meaningful diff.
  /// Waiting longer is acceptable considering the use case.
  /// If this field is not set clients may update as soon as they want.
  public var recommendedNextDiff: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _recommendedNextDiff ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_recommendedNextDiff = newValue}
  }
  /// Returns true if `recommendedNextDiff` has been explicitly set.
  public var hasRecommendedNextDiff: Bool {return self._recommendedNextDiff != nil}
  /// Clears the value of `recommendedNextDiff`. Subsequent reads from it will return its default value.
  public mutating func clearRecommendedNextDiff() {self._recommendedNextDiff = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of response sent to the client.
  public enum ResponseType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unknown.
    case unspecified // = 0

    /// Partial updates are applied to the client's existing local database.
    case diff // = 1

    /// Full updates resets the client's entire local database. This means
    /// that either the client had no state, was seriously out-of-date,
    /// or the client is believed to be corrupt.
    case reset // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .diff
      case 2: self = .reset
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .diff: return 1
      case .reset: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The expected state of a client's local database.
  public struct Checksum {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The SHA256 hash of the client state; that is, of the sorted list of all
    /// hashes present in the database.
    public var sha256: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _additions: Google_Cloud_Webrisk_V1_ThreatEntryAdditions? = nil
  fileprivate var _removals: Google_Cloud_Webrisk_V1_ThreatEntryRemovals? = nil
  fileprivate var _checksum: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.Checksum? = nil
  fileprivate var _recommendedNextDiff: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.ResponseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.ResponseType] = [
    .unspecified,
    .diff,
    .reset,
  ]
}

#endif  // swift(>=4.2)

/// Request to check URI entries against threatLists.
public struct Google_Cloud_Webrisk_V1_SearchUrisRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The URI to be checked for matches.
  public var uri: String = String()

  /// Required. The ThreatLists to search in. Multiple ThreatLists may be specified.
  public var threatTypes: [Google_Cloud_Webrisk_V1_ThreatType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Webrisk_V1_SearchUrisResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The threat list matches. This may be empty if the URI is on no list.
  public var threat: Google_Cloud_Webrisk_V1_SearchUrisResponse.ThreatUri {
    get {return _threat ?? Google_Cloud_Webrisk_V1_SearchUrisResponse.ThreatUri()}
    set {_threat = newValue}
  }
  /// Returns true if `threat` has been explicitly set.
  public var hasThreat: Bool {return self._threat != nil}
  /// Clears the value of `threat`. Subsequent reads from it will return its default value.
  public mutating func clearThreat() {self._threat = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contains threat information on a matching uri.
  public struct ThreatUri {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ThreatList this threat belongs to.
    public var threatTypes: [Google_Cloud_Webrisk_V1_ThreatType] = []

    /// The cache lifetime for the returned match. Clients must not cache this
    /// response past this timestamp to avoid false positives.
    public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expireTime = newValue}
    }
    /// Returns true if `expireTime` has been explicitly set.
    public var hasExpireTime: Bool {return self._expireTime != nil}
    /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpireTime() {self._expireTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _threat: Google_Cloud_Webrisk_V1_SearchUrisResponse.ThreatUri? = nil
}

/// Request to return full hashes matched by the provided hash prefixes.
public struct Google_Cloud_Webrisk_V1_SearchHashesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
  /// hash. For JSON requests, this field is base64-encoded.
  public var hashPrefix: Data = Data()

  /// Required. The ThreatLists to search in. Multiple ThreatLists may be specified.
  public var threatTypes: [Google_Cloud_Webrisk_V1_ThreatType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Webrisk_V1_SearchHashesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full hashes that matched the requested prefixes.
  /// The hash will be populated in the key.
  public var threats: [Google_Cloud_Webrisk_V1_SearchHashesResponse.ThreatHash] = []

  /// For requested entities that did not match the threat list, how long to
  /// cache the response until.
  public var negativeExpireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _negativeExpireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_negativeExpireTime = newValue}
  }
  /// Returns true if `negativeExpireTime` has been explicitly set.
  public var hasNegativeExpireTime: Bool {return self._negativeExpireTime != nil}
  /// Clears the value of `negativeExpireTime`. Subsequent reads from it will return its default value.
  public mutating func clearNegativeExpireTime() {self._negativeExpireTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contains threat information on a matching hash.
  public struct ThreatHash {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ThreatList this threat belongs to.
    /// This must contain at least one entry.
    public var threatTypes: [Google_Cloud_Webrisk_V1_ThreatType] = []

    /// A 32 byte SHA256 hash. This field is in binary format. For JSON
    /// requests, hashes are base64-encoded.
    public var hash: Data = Data()

    /// The cache lifetime for the returned match. Clients must not cache this
    /// response past this timestamp to avoid false positives.
    public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expireTime = newValue}
    }
    /// Returns true if `expireTime` has been explicitly set.
    public var hasExpireTime: Bool {return self._expireTime != nil}
    /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpireTime() {self._expireTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _negativeExpireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Contains the set of entries to add to a local database.
/// May contain a combination of compressed and raw data in a single response.
public struct Google_Cloud_Webrisk_V1_ThreatEntryAdditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The raw SHA256-formatted entries.
  /// Repeated to allow returning sets of hashes with different prefix sizes.
  public var rawHashes: [Google_Cloud_Webrisk_V1_RawHashes] = []

  /// The encoded 4-byte prefixes of SHA256-formatted entries, using a
  /// Golomb-Rice encoding. The hashes are converted to uint32, sorted in
  /// ascending order, then delta encoded and stored as encoded_data.
  public var riceHashes: Google_Cloud_Webrisk_V1_RiceDeltaEncoding {
    get {return _riceHashes ?? Google_Cloud_Webrisk_V1_RiceDeltaEncoding()}
    set {_riceHashes = newValue}
  }
  /// Returns true if `riceHashes` has been explicitly set.
  public var hasRiceHashes: Bool {return self._riceHashes != nil}
  /// Clears the value of `riceHashes`. Subsequent reads from it will return its default value.
  public mutating func clearRiceHashes() {self._riceHashes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _riceHashes: Google_Cloud_Webrisk_V1_RiceDeltaEncoding? = nil
}

/// Contains the set of entries to remove from a local database.
public struct Google_Cloud_Webrisk_V1_ThreatEntryRemovals {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The raw removal indices for a local list.
  public var rawIndices: Google_Cloud_Webrisk_V1_RawIndices {
    get {return _rawIndices ?? Google_Cloud_Webrisk_V1_RawIndices()}
    set {_rawIndices = newValue}
  }
  /// Returns true if `rawIndices` has been explicitly set.
  public var hasRawIndices: Bool {return self._rawIndices != nil}
  /// Clears the value of `rawIndices`. Subsequent reads from it will return its default value.
  public mutating func clearRawIndices() {self._rawIndices = nil}

  /// The encoded local, lexicographically-sorted list indices, using a
  /// Golomb-Rice encoding. Used for sending compressed removal indices. The
  /// removal indices (uint32) are sorted in ascending order, then delta encoded
  /// and stored as encoded_data.
  public var riceIndices: Google_Cloud_Webrisk_V1_RiceDeltaEncoding {
    get {return _riceIndices ?? Google_Cloud_Webrisk_V1_RiceDeltaEncoding()}
    set {_riceIndices = newValue}
  }
  /// Returns true if `riceIndices` has been explicitly set.
  public var hasRiceIndices: Bool {return self._riceIndices != nil}
  /// Clears the value of `riceIndices`. Subsequent reads from it will return its default value.
  public mutating func clearRiceIndices() {self._riceIndices = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rawIndices: Google_Cloud_Webrisk_V1_RawIndices? = nil
  fileprivate var _riceIndices: Google_Cloud_Webrisk_V1_RiceDeltaEncoding? = nil
}

/// A set of raw indices to remove from a local list.
public struct Google_Cloud_Webrisk_V1_RawIndices {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The indices to remove from a lexicographically-sorted local list.
  public var indices: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The uncompressed threat entries in hash format.
/// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
/// bytes, but some hashes are lengthened if they collide with the hash of a
/// popular URI.
///
/// Used for sending ThreatEntryAdditons to clients that do not support
/// compression, or when sending non-4-byte hashes to clients that do support
/// compression.
public struct Google_Cloud_Webrisk_V1_RawHashes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of bytes for each prefix encoded below.  This field can be
  /// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
  /// In practice this is almost always 4, except in exceptional circumstances.
  public var prefixSize: Int32 = 0

  /// The hashes, in binary format, concatenated into one long string. Hashes are
  /// sorted in lexicographic order. For JSON API users, hashes are
  /// base64-encoded.
  public var rawHashes: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
/// compressed removal indices.
public struct Google_Cloud_Webrisk_V1_RiceDeltaEncoding {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The offset of the first entry in the encoded data, or, if only a single
  /// integer was encoded, that single integer's value. If the field is empty or
  /// missing, assume zero.
  public var firstValue: Int64 = 0

  /// The Golomb-Rice parameter, which is a number between 2 and 28. This field
  /// is missing (that is, zero) if `num_entries` is zero.
  public var riceParameter: Int32 = 0

  /// The number of entries that are delta encoded in the encoded data. If only a
  /// single integer was encoded, this will be zero and the single value will be
  /// stored in `first_value`.
  public var entryCount: Int32 = 0

  /// The encoded deltas that are encoded using the Golomb-Rice coder.
  public var encodedData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Wraps a URI that might be displaying phishing content.
public struct Google_Cloud_Webrisk_V1_Submission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The URI that is being reported for phishing content to be analyzed.
  public var uri: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to send a potentially phishy URI to WebRisk.
public struct Google_Cloud_Webrisk_V1_CreateSubmissionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project that is making the submission. This string is in
  /// the format "projects/{project_number}".
  public var parent: String = String()

  /// Required. The submission that contains the content of the phishing report.
  public var submission: Google_Cloud_Webrisk_V1_Submission {
    get {return _submission ?? Google_Cloud_Webrisk_V1_Submission()}
    set {_submission = newValue}
  }
  /// Returns true if `submission` has been explicitly set.
  public var hasSubmission: Bool {return self._submission != nil}
  /// Clears the value of `submission`. Subsequent reads from it will return its default value.
  public mutating func clearSubmission() {self._submission = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _submission: Google_Cloud_Webrisk_V1_Submission? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.webrisk.v1"

extension Google_Cloud_Webrisk_V1_ThreatType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "THREAT_TYPE_UNSPECIFIED"),
    1: .same(proto: "MALWARE"),
    2: .same(proto: "SOCIAL_ENGINEERING"),
    3: .same(proto: "UNWANTED_SOFTWARE"),
  ]
}

extension Google_Cloud_Webrisk_V1_CompressionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPRESSION_TYPE_UNSPECIFIED"),
    1: .same(proto: "RAW"),
    2: .same(proto: "RICE"),
  ]
}

extension Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeThreatListDiffRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "threat_type"),
    2: .standard(proto: "version_token"),
    3: .same(proto: "constraints"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.threatType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.versionToken) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._constraints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threatType != .unspecified {
      try visitor.visitSingularEnumField(value: self.threatType, fieldNumber: 1)
    }
    if !self.versionToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.versionToken, fieldNumber: 2)
    }
    if let v = self._constraints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest, rhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest) -> Bool {
    if lhs.threatType != rhs.threatType {return false}
    if lhs.versionToken != rhs.versionToken {return false}
    if lhs._constraints != rhs._constraints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.Constraints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.protoMessageName + ".Constraints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_diff_entries"),
    2: .standard(proto: "max_database_entries"),
    3: .standard(proto: "supported_compressions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxDiffEntries) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxDatabaseEntries) }()
      case 3: try { try decoder.decodeRepeatedEnumField(value: &self.supportedCompressions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxDiffEntries != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDiffEntries, fieldNumber: 1)
    }
    if self.maxDatabaseEntries != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDatabaseEntries, fieldNumber: 2)
    }
    if !self.supportedCompressions.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedCompressions, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.Constraints, rhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffRequest.Constraints) -> Bool {
    if lhs.maxDiffEntries != rhs.maxDiffEntries {return false}
    if lhs.maxDatabaseEntries != rhs.maxDatabaseEntries {return false}
    if lhs.supportedCompressions != rhs.supportedCompressions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ComputeThreatListDiffResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "response_type"),
    5: .same(proto: "additions"),
    6: .same(proto: "removals"),
    7: .standard(proto: "new_version_token"),
    8: .same(proto: "checksum"),
    2: .standard(proto: "recommended_next_diff"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._recommendedNextDiff) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.responseType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._additions) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._removals) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.newVersionToken) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._checksum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._recommendedNextDiff {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.responseType != .unspecified {
      try visitor.visitSingularEnumField(value: self.responseType, fieldNumber: 4)
    }
    if let v = self._additions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._removals {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.newVersionToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.newVersionToken, fieldNumber: 7)
    }
    if let v = self._checksum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse, rhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs._additions != rhs._additions {return false}
    if lhs._removals != rhs._removals {return false}
    if lhs.newVersionToken != rhs.newVersionToken {return false}
    if lhs._checksum != rhs._checksum {return false}
    if lhs._recommendedNextDiff != rhs._recommendedNextDiff {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.ResponseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESPONSE_TYPE_UNSPECIFIED"),
    1: .same(proto: "DIFF"),
    2: .same(proto: "RESET"),
  ]
}

extension Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.Checksum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.protoMessageName + ".Checksum"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sha256"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sha256) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sha256.isEmpty {
      try visitor.visitSingularBytesField(value: self.sha256, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.Checksum, rhs: Google_Cloud_Webrisk_V1_ComputeThreatListDiffResponse.Checksum) -> Bool {
    if lhs.sha256 != rhs.sha256 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_SearchUrisRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUrisRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .standard(proto: "threat_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.threatTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if !self.threatTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.threatTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_SearchUrisRequest, rhs: Google_Cloud_Webrisk_V1_SearchUrisRequest) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.threatTypes != rhs.threatTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_SearchUrisResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchUrisResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threat"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._threat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._threat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_SearchUrisResponse, rhs: Google_Cloud_Webrisk_V1_SearchUrisResponse) -> Bool {
    if lhs._threat != rhs._threat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_SearchUrisResponse.ThreatUri: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Webrisk_V1_SearchUrisResponse.protoMessageName + ".ThreatUri"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "threat_types"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.threatTypes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threatTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.threatTypes, fieldNumber: 1)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_SearchUrisResponse.ThreatUri, rhs: Google_Cloud_Webrisk_V1_SearchUrisResponse.ThreatUri) -> Bool {
    if lhs.threatTypes != rhs.threatTypes {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_SearchHashesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchHashesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hash_prefix"),
    2: .standard(proto: "threat_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hashPrefix) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.threatTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hashPrefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.hashPrefix, fieldNumber: 1)
    }
    if !self.threatTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.threatTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_SearchHashesRequest, rhs: Google_Cloud_Webrisk_V1_SearchHashesRequest) -> Bool {
    if lhs.hashPrefix != rhs.hashPrefix {return false}
    if lhs.threatTypes != rhs.threatTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_SearchHashesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchHashesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threats"),
    2: .standard(proto: "negative_expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.threats) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._negativeExpireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threats.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.threats, fieldNumber: 1)
    }
    if let v = self._negativeExpireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_SearchHashesResponse, rhs: Google_Cloud_Webrisk_V1_SearchHashesResponse) -> Bool {
    if lhs.threats != rhs.threats {return false}
    if lhs._negativeExpireTime != rhs._negativeExpireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_SearchHashesResponse.ThreatHash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Webrisk_V1_SearchHashesResponse.protoMessageName + ".ThreatHash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "threat_types"),
    2: .same(proto: "hash"),
    3: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.threatTypes) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.threatTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.threatTypes, fieldNumber: 1)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 2)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_SearchHashesResponse.ThreatHash, rhs: Google_Cloud_Webrisk_V1_SearchHashesResponse.ThreatHash) -> Bool {
    if lhs.threatTypes != rhs.threatTypes {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_ThreatEntryAdditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThreatEntryAdditions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_hashes"),
    2: .standard(proto: "rice_hashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rawHashes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._riceHashes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawHashes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawHashes, fieldNumber: 1)
    }
    if let v = self._riceHashes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_ThreatEntryAdditions, rhs: Google_Cloud_Webrisk_V1_ThreatEntryAdditions) -> Bool {
    if lhs.rawHashes != rhs.rawHashes {return false}
    if lhs._riceHashes != rhs._riceHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_ThreatEntryRemovals: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThreatEntryRemovals"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_indices"),
    2: .standard(proto: "rice_indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rawIndices) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._riceIndices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rawIndices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._riceIndices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_ThreatEntryRemovals, rhs: Google_Cloud_Webrisk_V1_ThreatEntryRemovals) -> Bool {
    if lhs._rawIndices != rhs._rawIndices {return false}
    if lhs._riceIndices != rhs._riceIndices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_RawIndices: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RawIndices"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "indices"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.indices) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indices.isEmpty {
      try visitor.visitPackedInt32Field(value: self.indices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_RawIndices, rhs: Google_Cloud_Webrisk_V1_RawIndices) -> Bool {
    if lhs.indices != rhs.indices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_RawHashes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RawHashes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "prefix_size"),
    2: .standard(proto: "raw_hashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.prefixSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawHashes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.prefixSize != 0 {
      try visitor.visitSingularInt32Field(value: self.prefixSize, fieldNumber: 1)
    }
    if !self.rawHashes.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawHashes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_RawHashes, rhs: Google_Cloud_Webrisk_V1_RawHashes) -> Bool {
    if lhs.prefixSize != rhs.prefixSize {return false}
    if lhs.rawHashes != rhs.rawHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_RiceDeltaEncoding: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RiceDeltaEncoding"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "first_value"),
    2: .standard(proto: "rice_parameter"),
    3: .standard(proto: "entry_count"),
    4: .standard(proto: "encoded_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.firstValue) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.riceParameter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.entryCount) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.encodedData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.firstValue != 0 {
      try visitor.visitSingularInt64Field(value: self.firstValue, fieldNumber: 1)
    }
    if self.riceParameter != 0 {
      try visitor.visitSingularInt32Field(value: self.riceParameter, fieldNumber: 2)
    }
    if self.entryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.entryCount, fieldNumber: 3)
    }
    if !self.encodedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encodedData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_RiceDeltaEncoding, rhs: Google_Cloud_Webrisk_V1_RiceDeltaEncoding) -> Bool {
    if lhs.firstValue != rhs.firstValue {return false}
    if lhs.riceParameter != rhs.riceParameter {return false}
    if lhs.entryCount != rhs.entryCount {return false}
    if lhs.encodedData != rhs.encodedData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_Submission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Submission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_Submission, rhs: Google_Cloud_Webrisk_V1_Submission) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Webrisk_V1_CreateSubmissionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateSubmissionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "submission"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._submission) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._submission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Webrisk_V1_CreateSubmissionRequest, rhs: Google_Cloud_Webrisk_V1_CreateSubmissionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._submission != rhs._submission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/security/privateca/v1beta1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A [RevocationReason][google.cloud.security.privateca.v1beta1.RevocationReason] indicates whether a [Certificate][google.cloud.security.privateca.v1beta1.Certificate] has been revoked,
/// and the reason for revocation. These correspond to standard revocation
/// reasons from RFC 5280. Note that the enum labels and values in this
/// definition are not the same ASN.1 values defined in RFC 5280. These values
/// will be translated to the correct ASN.1 values when a CRL is created.
public enum Google_Cloud_Security_Privateca_V1beta1_RevocationReason: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default unspecified value. This value does indicate that a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]
  /// has been revoked, but that a reason has not been recorded.
  case unspecified // = 0

  /// Key material for this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] may have leaked.
  case keyCompromise // = 1

  /// The key material for a certificate authority in the issuing path may have
  /// leaked.
  case certificateAuthorityCompromise // = 2

  /// The subject or other attributes in this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] have changed.
  case affiliationChanged // = 3

  /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] has been superseded.
  case superseded // = 4

  /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] or entities in the issuing path have ceased to
  /// operate.
  case cessationOfOperation // = 5

  /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] should not be considered valid, it is expected that it
  /// may become valid in the future.
  case certificateHold // = 6

  /// This [Certificate][google.cloud.security.privateca.v1beta1.Certificate] no longer has permission to assert the listed
  /// attributes.
  case privilegeWithdrawn // = 7

  /// The authority which determines appropriate attributes for a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]
  /// may have been compromised.
  case attributeAuthorityCompromise // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .keyCompromise
    case 2: self = .certificateAuthorityCompromise
    case 3: self = .affiliationChanged
    case 4: self = .superseded
    case 5: self = .cessationOfOperation
    case 6: self = .certificateHold
    case 7: self = .privilegeWithdrawn
    case 8: self = .attributeAuthorityCompromise
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .keyCompromise: return 1
    case .certificateAuthorityCompromise: return 2
    case .affiliationChanged: return 3
    case .superseded: return 4
    case .cessationOfOperation: return 5
    case .certificateHold: return 6
    case .privilegeWithdrawn: return 7
    case .attributeAuthorityCompromise: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Security_Privateca_V1beta1_RevocationReason: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_RevocationReason] = [
    .unspecified,
    .keyCompromise,
    .certificateAuthorityCompromise,
    .affiliationChanged,
    .superseded,
    .cessationOfOperation,
    .certificateHold,
    .privilegeWithdrawn,
    .attributeAuthorityCompromise,
  ]
}

#endif  // swift(>=4.2)

/// A [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] represents an individual Certificate Authority.
/// A [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] can be used to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
public struct Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the
  /// format `projects/*/locations/*/certificateAuthorities/*`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. Immutable. The [Type][google.cloud.security.privateca.v1beta1.CertificateAuthority.Type] of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  public var type: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.TypeEnum {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// Required. Immutable. The [Tier][google.cloud.security.privateca.v1beta1.CertificateAuthority.Tier] of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  public var tier: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.Tier {
    get {return _storage._tier}
    set {_uniqueStorage()._tier = newValue}
  }

  /// Required. Immutable. The config used to create a self-signed X.509 certificate or CSR.
  public var config: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig {
    get {return _storage._config ?? Google_Cloud_Security_Privateca_V1beta1_CertificateConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {_uniqueStorage()._config = nil}

  /// Required. The desired lifetime of the CA certificate. Used to create the
  /// "not_before_time" and "not_after_time" fields inside an X.509
  /// certificate.
  public var lifetime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._lifetime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._lifetime = newValue}
  }
  /// Returns true if `lifetime` has been explicitly set.
  public var hasLifetime: Bool {return _storage._lifetime != nil}
  /// Clears the value of `lifetime`. Subsequent reads from it will return its default value.
  public mutating func clearLifetime() {_uniqueStorage()._lifetime = nil}

  /// Required. Immutable. Used when issuing certificates for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. If this
  /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] is a self-signed CertificateAuthority, this key
  /// is also used to sign the self-signed CA certificate. Otherwise, it
  /// is used to sign a CSR.
  public var keySpec: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec {
    get {return _storage._keySpec ?? Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec()}
    set {_uniqueStorage()._keySpec = newValue}
  }
  /// Returns true if `keySpec` has been explicitly set.
  public var hasKeySpec: Bool {return _storage._keySpec != nil}
  /// Clears the value of `keySpec`. Subsequent reads from it will return its default value.
  public mutating func clearKeySpec() {_uniqueStorage()._keySpec = nil}

  /// Optional. The [CertificateAuthorityPolicy][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy] to enforce when issuing
  /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] from this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  public var certificatePolicy: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy {
    get {return _storage._certificatePolicy ?? Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy()}
    set {_uniqueStorage()._certificatePolicy = newValue}
  }
  /// Returns true if `certificatePolicy` has been explicitly set.
  public var hasCertificatePolicy: Bool {return _storage._certificatePolicy != nil}
  /// Clears the value of `certificatePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearCertificatePolicy() {_uniqueStorage()._certificatePolicy = nil}

  /// Optional. The [IssuingOptions][google.cloud.security.privateca.v1beta1.CertificateAuthority.IssuingOptions] to follow when issuing [Certificates][google.cloud.security.privateca.v1beta1.Certificate]
  /// from this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  public var issuingOptions: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.IssuingOptions {
    get {return _storage._issuingOptions ?? Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.IssuingOptions()}
    set {_uniqueStorage()._issuingOptions = newValue}
  }
  /// Returns true if `issuingOptions` has been explicitly set.
  public var hasIssuingOptions: Bool {return _storage._issuingOptions != nil}
  /// Clears the value of `issuingOptions`. Subsequent reads from it will return its default value.
  public mutating func clearIssuingOptions() {_uniqueStorage()._issuingOptions = nil}

  /// Optional. If this is a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], this field will be set
  /// with the subordinate configuration, which describes its issuers. This may
  /// be updated, but this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must continue to validate.
  public var subordinateConfig: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig {
    get {return _storage._subordinateConfig ?? Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig()}
    set {_uniqueStorage()._subordinateConfig = newValue}
  }
  /// Returns true if `subordinateConfig` has been explicitly set.
  public var hasSubordinateConfig: Bool {return _storage._subordinateConfig != nil}
  /// Clears the value of `subordinateConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSubordinateConfig() {_uniqueStorage()._subordinateConfig = nil}

  /// Output only. The [State][google.cloud.security.privateca.v1beta1.CertificateAuthority.State] for this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  public var state: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. This [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate chain, including the current
  /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate. Ordered such that the root issuer
  /// is the final element (consistent with RFC 5246). For a self-signed CA, this
  /// will only list the current [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s certificate.
  public var pemCaCertificates: [String] {
    get {return _storage._pemCaCertificates}
    set {_uniqueStorage()._pemCaCertificates = newValue}
  }

  /// Output only. A structured description of this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CA certificate
  /// and its issuers. Ordered as self-to-root.
  public var caCertificateDescriptions: [Google_Cloud_Security_Privateca_V1beta1_CertificateDescription] {
    get {return _storage._caCertificateDescriptions}
    set {_uniqueStorage()._caCertificateDescriptions = newValue}
  }

  /// Immutable. The name of a Cloud Storage bucket where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will
  /// publish content, such as the CA certificate and CRLs. This must be a bucket
  /// name, without any prefixes (such as `gs://`) or suffixes (such as
  /// `.googleapis.com`). For example, to use a bucket named `my-bucket`, you
  /// would simply specify `my-bucket`. If not specified, a managed bucket will
  /// be created.
  public var gcsBucket: String {
    get {return _storage._gcsBucket}
    set {_uniqueStorage()._gcsBucket = newValue}
  }

  /// Output only. URLs for accessing content published by this CA, such as the CA certificate
  /// and CRLs.
  public var accessUrls: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.AccessUrls {
    get {return _storage._accessUrls ?? Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.AccessUrls()}
    set {_uniqueStorage()._accessUrls = newValue}
  }
  /// Returns true if `accessUrls` has been explicitly set.
  public var hasAccessUrls: Bool {return _storage._accessUrls != nil}
  /// Clears the value of `accessUrls`. Subsequent reads from it will return its default value.
  public mutating func clearAccessUrls() {_uniqueStorage()._accessUrls = nil}

  /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. The time at which this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will be deleted, if
  /// scheduled for deletion.
  public var deleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deleteTime = newValue}
  }
  /// Returns true if `deleteTime` has been explicitly set.
  public var hasDeleteTime: Bool {return _storage._deleteTime != nil}
  /// Clears the value of `deleteTime`. Subsequent reads from it will return its default value.
  public mutating func clearDeleteTime() {_uniqueStorage()._deleteTime = nil}

  /// Optional. Labels with user-defined metadata.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating its issuing chain.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// Self-signed CA.
    case selfSigned // = 1

    /// Subordinate CA. Could be issued by a Private CA [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
    /// or an unmanaged CA.
    case subordinate // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .selfSigned
      case 2: self = .subordinate
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .selfSigned: return 1
      case .subordinate: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The tier of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating its supported
  /// functionality and/or billing SKU.
  public enum Tier: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// Enterprise tier.
    case enterprise // = 1

    /// DevOps tier.
    case devops // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enterprise
      case 2: self = .devops
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enterprise: return 1
      case .devops: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The state of a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], indicating if it can be used.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// Certificates can be issued from this CA. CRLs will be generated for this
    /// CA.
    case enabled // = 1

    /// Certificates cannot be issued from this CA. CRLs will still be generated.
    case disabled // = 2

    /// Certificates cannot be issued from this CA. CRLs will not be generated.
    case pendingActivation // = 3

    /// Certificates cannot be issued from this CA. CRLs will not be generated.
    case pendingDeletion // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enabled
      case 2: self = .disabled
      case 3: self = .pendingActivation
      case 4: self = .pendingDeletion
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enabled: return 1
      case .disabled: return 2
      case .pendingActivation: return 3
      case .pendingDeletion: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The algorithm of a Cloud KMS CryptoKeyVersion of a
  /// [CryptoKey][google.cloud.kms.v1.CryptoKey] with the
  /// [CryptoKeyPurpose][google.cloud.kms.v1.CryptoKey.CryptoKeyPurpose] value
  /// `ASYMMETRIC_SIGN`. These values correspond to the
  /// [CryptoKeyVersionAlgorithm][google.cloud.kms.v1.CryptoKeyVersion.CryptoKeyVersionAlgorithm]
  /// values. For RSA signing algorithms, the PSS algorithms should be preferred,
  /// use PKCS1 algorithms if required for compatibility. For further
  /// recommandations, see
  /// https://cloud.google.com/kms/docs/algorithms#algorithm_recommendations.
  public enum SignHashAlgorithm: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_2048_SHA256
    case rsaPss2048Sha256 // = 1

    /// maps to CryptoKeyVersionAlgorithm. RSA_SIGN_PSS_3072_SHA256
    case rsaPss3072Sha256 // = 2

    /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PSS_4096_SHA256
    case rsaPss4096Sha256 // = 3

    /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_2048_SHA256
    case rsaPkcs12048Sha256 // = 6

    /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_3072_SHA256
    case rsaPkcs13072Sha256 // = 7

    /// maps to CryptoKeyVersionAlgorithm.RSA_SIGN_PKCS1_4096_SHA256
    case rsaPkcs14096Sha256 // = 8

    /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P256_SHA256
    case ecP256Sha256 // = 4

    /// maps to CryptoKeyVersionAlgorithm.EC_SIGN_P384_SHA384
    case ecP384Sha384 // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .rsaPss2048Sha256
      case 2: self = .rsaPss3072Sha256
      case 3: self = .rsaPss4096Sha256
      case 4: self = .ecP256Sha256
      case 5: self = .ecP384Sha384
      case 6: self = .rsaPkcs12048Sha256
      case 7: self = .rsaPkcs13072Sha256
      case 8: self = .rsaPkcs14096Sha256
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .rsaPss2048Sha256: return 1
      case .rsaPss3072Sha256: return 2
      case .rsaPss4096Sha256: return 3
      case .ecP256Sha256: return 4
      case .ecP384Sha384: return 5
      case .rsaPkcs12048Sha256: return 6
      case .rsaPkcs13072Sha256: return 7
      case .rsaPkcs14096Sha256: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Options that affect all certificates issued by a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  public struct IssuingOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. When true, includes a URL to the issuing CA certificate in the
    /// "authority information access" X.509 extension.
    public var includeCaCertURL: Bool = false

    /// Required. When true, includes a URL to the CRL corresponding to certificates
    /// issued from a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    /// CRLs will expire 7 days from their creation. However, we will rebuild
    /// daily. CRLs are also rebuilt shortly after a certificate is revoked.
    public var includeCrlAccessURL: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The issuing policy for a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
  /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] will not be successfully issued from this
  /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] if they violate the policy.
  public struct CertificateAuthorityPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Allowed configurations or a single configuration for all issued
    /// certificates.
    public var configPolicy: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.OneOf_ConfigPolicy? = nil

    /// Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
    /// must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] in the list.
    public var allowedConfigList: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList {
      get {
        if case .allowedConfigList(let v)? = configPolicy {return v}
        return Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList()
      }
      set {configPolicy = .allowedConfigList(newValue)}
    }

    /// Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
    /// will use the provided configuration values, overwriting any requested
    /// configuration values.
    public var overwriteConfigValues: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper {
      get {
        if case .overwriteConfigValues(let v)? = configPolicy {return v}
        return Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper()
      }
      set {configPolicy = .overwriteConfigValues(newValue)}
    }

    /// Optional. If any [Subject][google.cloud.security.privateca.v1beta1.Subject] is specified here, then all
    /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
    /// match at least one listed [Subject][google.cloud.security.privateca.v1beta1.Subject]. If a [Subject][google.cloud.security.privateca.v1beta1.Subject] has an empty
    /// field, any value will be allowed for that field.
    public var allowedLocationsAndOrganizations: [Google_Cloud_Security_Privateca_V1beta1_Subject] = []

    /// Optional. If any value is specified here, then all
    /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
    /// match at least one listed value. If no value is specified, all values
    /// will be allowed for this fied. Glob patterns are also supported.
    public var allowedCommonNames: [String] = []

    /// Optional. If a [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames] is specified here, then all
    /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] must
    /// match [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames]. If no value or an empty value
    /// is specified, any value will be allowed for the [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames]
    /// field.
    public var allowedSans: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames {
      get {return _allowedSans ?? Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames()}
      set {_allowedSans = newValue}
    }
    /// Returns true if `allowedSans` has been explicitly set.
    public var hasAllowedSans: Bool {return self._allowedSans != nil}
    /// Clears the value of `allowedSans`. Subsequent reads from it will return its default value.
    public mutating func clearAllowedSans() {self._allowedSans = nil}

    /// Optional. The maximum lifetime allowed by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. Note that
    /// if the any part if the issuing chain expires before a [Certificate][google.cloud.security.privateca.v1beta1.Certificate]'s
    /// requested maximum_lifetime, the effective lifetime will be explicitly
    /// truncated.
    public var maximumLifetime: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _maximumLifetime ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_maximumLifetime = newValue}
    }
    /// Returns true if `maximumLifetime` has been explicitly set.
    public var hasMaximumLifetime: Bool {return self._maximumLifetime != nil}
    /// Clears the value of `maximumLifetime`. Subsequent reads from it will return its default value.
    public mutating func clearMaximumLifetime() {self._maximumLifetime = nil}

    /// Optional. If specified, then only methods allowed in the [IssuanceModes][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes] may be
    /// used to issue [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
    public var allowedIssuanceModes: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes {
      get {return _allowedIssuanceModes ?? Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes()}
      set {_allowedIssuanceModes = newValue}
    }
    /// Returns true if `allowedIssuanceModes` has been explicitly set.
    public var hasAllowedIssuanceModes: Bool {return self._allowedIssuanceModes != nil}
    /// Clears the value of `allowedIssuanceModes`. Subsequent reads from it will return its default value.
    public mutating func clearAllowedIssuanceModes() {self._allowedIssuanceModes = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Allowed configurations or a single configuration for all issued
    /// certificates.
    public enum OneOf_ConfigPolicy: Equatable {
      /// Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
      /// must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] in the list.
      case allowedConfigList(Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList)
      /// Optional. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
      /// will use the provided configuration values, overwriting any requested
      /// configuration values.
      case overwriteConfigValues(Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.OneOf_ConfigPolicy, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.OneOf_ConfigPolicy) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.allowedConfigList, .allowedConfigList): return {
          guard case .allowedConfigList(let l) = lhs, case .allowedConfigList(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.overwriteConfigValues, .overwriteConfigValues): return {
          guard case .overwriteConfigValues(let l) = lhs, case .overwriteConfigValues(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public struct AllowedConfigList {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. All [Certificates][google.cloud.security.privateca.v1beta1.Certificate] issued by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]
      /// must match at least one listed [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper]. If a
      /// [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] has an empty field, any value will be
      /// allowed for that field.
      public var allowedConfigValues: [Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// [AllowedSubjectAltNames][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames] specifies the allowed values for
    /// [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames] by the [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] when issuing
    /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate].
    public struct AllowedSubjectAltNames {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Optional. Contains valid, fully-qualified host names. Glob patterns are also
      /// supported. To allow an explicit wildcard certificate, escape with
      /// backlash (i.e. "\*").
      /// E.g. for globbed entries: '*bar.com' will allow foo.bar.com, but not
      /// *.bar.com, unless the [allow_globbing_dns_wildcards][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames.allow_globbing_dns_wildcards] field is set.
      /// E.g. for wildcard entries: '\*.bar.com' will allow '*.bar.com', but not
      /// 'foo.bar.com'.
      public var allowedDnsNames: [String] = []

      /// Optional. Contains valid RFC 3986 URIs. Glob patterns are also supported. To
      /// match across path seperators (i.e. '/') use the double star glob
      /// pattern (i.e. '**').
      public var allowedUris: [String] = []

      /// Optional. Contains valid RFC 2822 E-mail addresses. Glob patterns are also
      /// supported.
      public var allowedEmailAddresses: [String] = []

      /// Optional. Contains valid 32-bit IPv4 addresses and subnet ranges or RFC 4291 IPv6
      /// addresses and subnet ranges. Subnet ranges are specified using the
      /// '/' notation (e.g. 10.0.0.0/8, 2001:700:300:1800::/64). Glob patterns
      /// are supported only for ip address entries (i.e. not for subnet ranges).
      public var allowedIps: [String] = []

      /// Optional. Specifies if glob patterns used for [allowed_dns_names][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames.allowed_dns_names] allows
      /// wildcard certificates.
      public var allowGlobbingDnsWildcards: Bool = false

      /// Optional. Specifies if to allow custom X509Extension values.
      public var allowCustomSans: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// [IssuanceModes][google.cloud.security.privateca.v1beta1.CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes] specifies the allowed ways in which
    /// [Certificates][google.cloud.security.privateca.v1beta1.Certificate] may be requested from this
    /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
    public struct IssuanceModes {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate] by
      /// specifying a CSR.
      public var allowCsrBasedIssuance: Bool = false

      /// Required. When true, allows callers to create [Certificates][google.cloud.security.privateca.v1beta1.Certificate] by
      /// specifying a [CertificateConfig][google.cloud.security.privateca.v1beta1.CertificateConfig].
      public var allowConfigBasedIssuance: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _allowedSans: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames? = nil
    fileprivate var _maximumLifetime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _allowedIssuanceModes: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes? = nil
  }

  /// URLs where a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will publish content.
  public struct AccessUrls {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The URL where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CA certificate is
    /// published. This will only be set for CAs that have been activated.
    public var caCertificateAccessURL: String = String()

    /// The URL where this [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]'s CRLs are published. This
    /// will only be set for CAs that have been activated.
    public var crlAccessURL: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A Cloud KMS key configuration that a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] will use.
  public struct KeyVersionSpec {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keyVersion: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec.OneOf_KeyVersion? = nil

    /// Required. The resource name for an existing Cloud KMS CryptoKeyVersion in the
    /// format
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
    /// This option enables full flexibility in the key's capabilities and
    /// properties.
    public var cloudKmsKeyVersion: String {
      get {
        if case .cloudKmsKeyVersion(let v)? = keyVersion {return v}
        return String()
      }
      set {keyVersion = .cloudKmsKeyVersion(newValue)}
    }

    /// Required. The algorithm to use for creating a managed Cloud KMS key for a for a
    /// simplified experience. All managed keys will be have their
    /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
    public var algorithm: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.SignHashAlgorithm {
      get {
        if case .algorithm(let v)? = keyVersion {return v}
        return .unspecified
      }
      set {keyVersion = .algorithm(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_KeyVersion: Equatable {
      /// Required. The resource name for an existing Cloud KMS CryptoKeyVersion in the
      /// format
      /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/cryptoKeyVersions/*`.
      /// This option enables full flexibility in the key's capabilities and
      /// properties.
      case cloudKmsKeyVersion(String)
      /// Required. The algorithm to use for creating a managed Cloud KMS key for a for a
      /// simplified experience. All managed keys will be have their
      /// [ProtectionLevel][google.cloud.kms.v1.ProtectionLevel] as `HSM`.
      case algorithm(Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.SignHashAlgorithm)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec.OneOf_KeyVersion, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec.OneOf_KeyVersion) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.cloudKmsKeyVersion, .cloudKmsKeyVersion): return {
          guard case .cloudKmsKeyVersion(let l) = lhs, case .cloudKmsKeyVersion(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.algorithm, .algorithm): return {
          guard case .algorithm(let l) = lhs, case .algorithm(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.TypeEnum] = [
    .unspecified,
    .selfSigned,
    .subordinate,
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.Tier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.Tier] = [
    .unspecified,
    .enterprise,
    .devops,
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.State] = [
    .unspecified,
    .enabled,
    .disabled,
    .pendingActivation,
    .pendingDeletion,
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.SignHashAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.SignHashAlgorithm] = [
    .unspecified,
    .rsaPss2048Sha256,
    .rsaPss3072Sha256,
    .rsaPss4096Sha256,
    .rsaPkcs12048Sha256,
    .rsaPkcs13072Sha256,
    .rsaPkcs14096Sha256,
    .ecP256Sha256,
    .ecP384Sha384,
  ]
}

#endif  // swift(>=4.2)

/// A [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] corresponds to a signed X.509 certificate
/// Revocation List (CRL). A CRL contains the serial numbers of certificates that
/// should no longer be trusted.
public struct Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource path for this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] in
  /// the format
  /// `projects/*/locations/*/certificateAuthorities/*/
  ///    certificateRevocationLists/*`.
  public var name: String = String()

  /// Output only. The CRL sequence number that appears in pem_crl.
  public var sequenceNumber: Int64 = 0

  /// Output only. The revoked serial numbers that appear in pem_crl.
  public var revokedCertificates: [Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.RevokedCertificate] = []

  /// Output only. The PEM-encoded X.509 CRL.
  public var pemCrl: String = String()

  /// Output only. The location where 'pem_crl' can be accessed.
  public var accessURL: String = String()

  /// Output only. The [State][google.cloud.security.privateca.v1beta1.CertificateRevocationList.State] for this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList].
  public var state: Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.State = .unspecified

  /// Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time at which this [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Optional. Labels with user-defined metadata.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The state of a [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList], indicating if it is current.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// The [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] is up to date.
    case active // = 1

    /// The [CertificateRevocationList][google.cloud.security.privateca.v1beta1.CertificateRevocationList] is no longer current.
    case superseded // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .superseded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .superseded: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Describes a revoked [Certificate][google.cloud.security.privateca.v1beta1.Certificate].
  public struct RevokedCertificate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The resource path for the [Certificate][google.cloud.security.privateca.v1beta1.Certificate] in the format
    /// `projects/*/locations/*/certificateAuthorities/*/certificates/*`.
    public var certificate: String = String()

    /// The serial number of the [Certificate][google.cloud.security.privateca.v1beta1.Certificate].
    public var hexSerialNumber: String = String()

    /// The reason the [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked.
    public var revocationReason: Google_Cloud_Security_Privateca_V1beta1_RevocationReason = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.State] = [
    .unspecified,
    .active,
    .superseded,
  ]
}

#endif  // swift(>=4.2)

/// A [Certificate][google.cloud.security.privateca.v1beta1.Certificate] corresponds to a signed X.509 certificate issued by a
/// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority].
public struct Google_Cloud_Security_Privateca_V1beta1_Certificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource path for this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] in the format
  /// `projects/*/locations/*/certificateAuthorities/*/certificates/*`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The config used to create a signed X.509 certificate.
  public var certificateConfig: OneOf_CertificateConfig? {
    get {return _storage._certificateConfig}
    set {_uniqueStorage()._certificateConfig = newValue}
  }

  /// Immutable. A pem-encoded X.509 certificate signing request (CSR).
  public var pemCsr: String {
    get {
      if case .pemCsr(let v)? = _storage._certificateConfig {return v}
      return String()
    }
    set {_uniqueStorage()._certificateConfig = .pemCsr(newValue)}
  }

  /// Immutable. A description of the certificate and key that does not require X.509 or
  /// ASN.1.
  public var config: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig {
    get {
      if case .config(let v)? = _storage._certificateConfig {return v}
      return Google_Cloud_Security_Privateca_V1beta1_CertificateConfig()
    }
    set {_uniqueStorage()._certificateConfig = .config(newValue)}
  }

  /// Required. Immutable. The desired lifetime of a certificate. Used to create the
  /// "not_before_time" and "not_after_time" fields inside an X.509
  /// certificate. Note that the lifetime may be truncated if it would extend
  /// past the life of any certificate authority in the issuing chain.
  public var lifetime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._lifetime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._lifetime = newValue}
  }
  /// Returns true if `lifetime` has been explicitly set.
  public var hasLifetime: Bool {return _storage._lifetime != nil}
  /// Clears the value of `lifetime`. Subsequent reads from it will return its default value.
  public mutating func clearLifetime() {_uniqueStorage()._lifetime = nil}

  /// Output only. Details regarding the revocation of this [Certificate][google.cloud.security.privateca.v1beta1.Certificate]. This
  /// [Certificate][google.cloud.security.privateca.v1beta1.Certificate] is considered revoked if and only if this field is present.
  public var revocationDetails: Google_Cloud_Security_Privateca_V1beta1_Certificate.RevocationDetails {
    get {return _storage._revocationDetails ?? Google_Cloud_Security_Privateca_V1beta1_Certificate.RevocationDetails()}
    set {_uniqueStorage()._revocationDetails = newValue}
  }
  /// Returns true if `revocationDetails` has been explicitly set.
  public var hasRevocationDetails: Bool {return _storage._revocationDetails != nil}
  /// Clears the value of `revocationDetails`. Subsequent reads from it will return its default value.
  public mutating func clearRevocationDetails() {_uniqueStorage()._revocationDetails = nil}

  /// Output only. The pem-encoded, signed X.509 certificate.
  public var pemCertificate: String {
    get {return _storage._pemCertificate}
    set {_uniqueStorage()._pemCertificate = newValue}
  }

  /// Output only. A structured description of the issued X.509 certificate.
  public var certificateDescription: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription {
    get {return _storage._certificateDescription ?? Google_Cloud_Security_Privateca_V1beta1_CertificateDescription()}
    set {_uniqueStorage()._certificateDescription = newValue}
  }
  /// Returns true if `certificateDescription` has been explicitly set.
  public var hasCertificateDescription: Bool {return _storage._certificateDescription != nil}
  /// Clears the value of `certificateDescription`. Subsequent reads from it will return its default value.
  public mutating func clearCertificateDescription() {_uniqueStorage()._certificateDescription = nil}

  /// Output only. The chain that may be used to verify the X.509 certificate. Expected to be
  /// in issuer-to-root order according to RFC 5246.
  public var pemCertificateChain: [String] {
    get {return _storage._pemCertificateChain}
    set {_uniqueStorage()._pemCertificateChain = newValue}
  }

  /// Output only. The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Optional. Labels with user-defined metadata.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The config used to create a signed X.509 certificate.
  public enum OneOf_CertificateConfig: Equatable {
    /// Immutable. A pem-encoded X.509 certificate signing request (CSR).
    case pemCsr(String)
    /// Immutable. A description of the certificate and key that does not require X.509 or
    /// ASN.1.
    case config(Google_Cloud_Security_Privateca_V1beta1_CertificateConfig)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_Certificate.OneOf_CertificateConfig, rhs: Google_Cloud_Security_Privateca_V1beta1_Certificate.OneOf_CertificateConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pemCsr, .pemCsr): return {
        guard case .pemCsr(let l) = lhs, case .pemCsr(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.config, .config): return {
        guard case .config(let l) = lhs, case .config(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Describes fields that are relavent to the revocation of a [Certificate][google.cloud.security.privateca.v1beta1.Certificate].
  public struct RevocationDetails {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates why a [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked.
    public var revocationState: Google_Cloud_Security_Privateca_V1beta1_RevocationReason = .unspecified

    /// The time at which this [Certificate][google.cloud.security.privateca.v1beta1.Certificate] was revoked.
    public var revocationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _revocationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_revocationTime = newValue}
    }
    /// Returns true if `revocationTime` has been explicitly set.
    public var hasRevocationTime: Bool {return self._revocationTime != nil}
    /// Clears the value of `revocationTime`. Subsequent reads from it will return its default value.
    public mutating func clearRevocationTime() {self._revocationTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _revocationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] refers to a managed [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues]. Those, in
/// turn, are used to describe certain fields of an X.509 certificate, such as
/// the key usage fields, fields specific to CA certificates, certificate policy
/// extensions and custom extensions.
public struct Google_Cloud_Security_Privateca_V1beta1_ReusableConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource path for this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
  /// `projects/*/locations/*/reusableConfigs/*`.
  public var name: String = String()

  /// Required. The config values.
  public var values: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues {
    get {return _values ?? Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues()}
    set {_values = newValue}
  }
  /// Returns true if `values` has been explicitly set.
  public var hasValues: Bool {return self._values != nil}
  /// Clears the value of `values`. Subsequent reads from it will return its default value.
  public mutating func clearValues() {self._values = nil}

  /// Optional. A human-readable description of scenarios these ReusableConfigValues may be
  /// compatible with.
  public var description_p: String = String()

  /// Output only. The time at which this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time at which this [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] was updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// Optional. Labels with user-defined metadata.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _values: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues] is used to describe certain fields of an
/// X.509 certificate, such as the key usage fields, fields specific to CA
/// certificates, certificate policy extensions and custom extensions.
public struct Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Indicates the intended use for keys that correspond to a certificate.
  public var keyUsage: Google_Cloud_Security_Privateca_V1beta1_KeyUsage {
    get {return _storage._keyUsage ?? Google_Cloud_Security_Privateca_V1beta1_KeyUsage()}
    set {_uniqueStorage()._keyUsage = newValue}
  }
  /// Returns true if `keyUsage` has been explicitly set.
  public var hasKeyUsage: Bool {return _storage._keyUsage != nil}
  /// Clears the value of `keyUsage`. Subsequent reads from it will return its default value.
  public mutating func clearKeyUsage() {_uniqueStorage()._keyUsage = nil}

  /// Optional. Describes options in this [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues] that are
  /// relevant in a CA certificate.
  public var caOptions: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.CaOptions {
    get {return _storage._caOptions ?? Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.CaOptions()}
    set {_uniqueStorage()._caOptions = newValue}
  }
  /// Returns true if `caOptions` has been explicitly set.
  public var hasCaOptions: Bool {return _storage._caOptions != nil}
  /// Clears the value of `caOptions`. Subsequent reads from it will return its default value.
  public mutating func clearCaOptions() {_uniqueStorage()._caOptions = nil}

  /// Optional. Describes the X.509 certificate policy object identifiers, per
  /// https://tools.ietf.org/html/rfc5280#section-4.2.1.4.
  public var policyIds: [Google_Cloud_Security_Privateca_V1beta1_ObjectId] {
    get {return _storage._policyIds}
    set {_uniqueStorage()._policyIds = newValue}
  }

  /// Optional. Describes Online Certificate Status Protocol (OCSP) endpoint addresses
  /// that appear in the "Authority Information Access" extension in the
  /// certificate.
  public var aiaOcspServers: [String] {
    get {return _storage._aiaOcspServers}
    set {_uniqueStorage()._aiaOcspServers = newValue}
  }

  /// Optional. Describes custom X.509 extensions.
  public var additionalExtensions: [Google_Cloud_Security_Privateca_V1beta1_X509Extension] {
    get {return _storage._additionalExtensions}
    set {_uniqueStorage()._additionalExtensions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes values that are relevant in a CA certificate.
  public struct CaOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. Refers to the "CA" X.509 extension, which is a boolean value. When this
    /// value is missing, the extension will be omitted from the CA certificate.
    public var isCa: SwiftProtobuf.Google_Protobuf_BoolValue {
      get {return _isCa ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
      set {_isCa = newValue}
    }
    /// Returns true if `isCa` has been explicitly set.
    public var hasIsCa: Bool {return self._isCa != nil}
    /// Clears the value of `isCa`. Subsequent reads from it will return its default value.
    public mutating func clearIsCa() {self._isCa = nil}

    /// Optional. Refers to the path length restriction X.509 extension. For a CA
    /// certificate, this value describes the depth of subordinate CA
    /// certificates that are allowed.
    /// If this value is less than 0, the request will fail.
    /// If this value is missing, the max path length will be omitted from the
    /// CA certificate.
    public var maxIssuerPathLength: SwiftProtobuf.Google_Protobuf_Int32Value {
      get {return _maxIssuerPathLength ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
      set {_maxIssuerPathLength = newValue}
    }
    /// Returns true if `maxIssuerPathLength` has been explicitly set.
    public var hasMaxIssuerPathLength: Bool {return self._maxIssuerPathLength != nil}
    /// Clears the value of `maxIssuerPathLength`. Subsequent reads from it will return its default value.
    public mutating func clearMaxIssuerPathLength() {self._maxIssuerPathLength = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _isCa: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    fileprivate var _maxIssuerPathLength: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A [ReusableConfigWrapper][google.cloud.security.privateca.v1beta1.ReusableConfigWrapper] describes values that may assist in creating an
/// X.509 certificate, or a reference to a pre-defined set of values.
public struct Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reusable or inline config values.
  public var configValues: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper.OneOf_ConfigValues? = nil

  /// Required. A resource path to a [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
  /// `projects/*/locations/*/reusableConfigs/*`.
  public var reusableConfig: String {
    get {
      if case .reusableConfig(let v)? = configValues {return v}
      return String()
    }
    set {configValues = .reusableConfig(newValue)}
  }

  /// Required. A user-specified inline [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues].
  public var reusableConfigValues: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues {
    get {
      if case .reusableConfigValues(let v)? = configValues {return v}
      return Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues()
    }
    set {configValues = .reusableConfigValues(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Reusable or inline config values.
  public enum OneOf_ConfigValues: Equatable {
    /// Required. A resource path to a [ReusableConfig][google.cloud.security.privateca.v1beta1.ReusableConfig] in the format
    /// `projects/*/locations/*/reusableConfigs/*`.
    case reusableConfig(String)
    /// Required. A user-specified inline [ReusableConfigValues][google.cloud.security.privateca.v1beta1.ReusableConfigValues].
    case reusableConfigValues(Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper.OneOf_ConfigValues, rhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper.OneOf_ConfigValues) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.reusableConfig, .reusableConfig): return {
        guard case .reusableConfig(let l) = lhs, case .reusableConfig(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reusableConfigValues, .reusableConfigValues): return {
        guard case .reusableConfigValues(let l) = lhs, case .reusableConfigValues(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Describes a subordinate CA's issuers. This is either a resource path to a
/// known issuing [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], or a PEM issuer certificate chain.
public struct Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var subordinateConfig: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.OneOf_SubordinateConfig? = nil

  /// Required. This can refer to a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the same project that
  /// was used to create a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. This field
  /// is used for information and usability purposes only. The resource name
  /// is in the format `projects/*/locations/*/certificateAuthorities/*`.
  public var certificateAuthority: String {
    get {
      if case .certificateAuthority(let v)? = subordinateConfig {return v}
      return String()
    }
    set {subordinateConfig = .certificateAuthority(newValue)}
  }

  /// Required. Contains the PEM certificate chain for the issuers of this
  /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], but not pem certificate for this CA itself.
  public var pemIssuerChain: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain {
    get {
      if case .pemIssuerChain(let v)? = subordinateConfig {return v}
      return Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain()
    }
    set {subordinateConfig = .pemIssuerChain(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_SubordinateConfig: Equatable {
    /// Required. This can refer to a [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] in the same project that
    /// was used to create a subordinate [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority]. This field
    /// is used for information and usability purposes only. The resource name
    /// is in the format `projects/*/locations/*/certificateAuthorities/*`.
    case certificateAuthority(String)
    /// Required. Contains the PEM certificate chain for the issuers of this
    /// [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority], but not pem certificate for this CA itself.
    case pemIssuerChain(Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.OneOf_SubordinateConfig, rhs: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.OneOf_SubordinateConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.certificateAuthority, .certificateAuthority): return {
        guard case .certificateAuthority(let l) = lhs, case .certificateAuthority(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pemIssuerChain, .pemIssuerChain): return {
        guard case .pemIssuerChain(let l) = lhs, case .pemIssuerChain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// This message describes a subordinate CA's issuer certificate chain. This
  /// wrapper exists for compatibility reasons.
  public struct SubordinateConfigChain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Expected to be in leaf-to-root order according to RFC 5246.
    public var pemCertificates: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A [PublicKey][google.cloud.security.privateca.v1beta1.PublicKey] describes a public key.
public struct Google_Cloud_Security_Privateca_V1beta1_PublicKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The type of public key.
  public var type: Google_Cloud_Security_Privateca_V1beta1_PublicKey.KeyType = .unspecified

  /// Required. A public key. Padding and encoding varies by 'KeyType' and is described
  /// along with the KeyType values.
  public var key: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Types of public keys that are supported.
  /// At a minimum, we support RSA and ECDSA, for the key sizes or curves listed:
  /// https://cloud.google.com/kms/docs/algorithms#asymmetric_signing_algorithms
  public enum KeyType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default unspecified value.
    case unspecified // = 0

    /// A PEM-encoded PKCS#1/RFC 3447 RSAPrivateKey structure.
    case pemRsaKey // = 1

    /// A PEM-encoded compressed NIST P-256/secp256r1/prime256v1 or P-384 key.
    case pemEcKey // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pemRsaKey
      case 2: self = .pemEcKey
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pemRsaKey: return 1
      case .pemEcKey: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Security_Privateca_V1beta1_PublicKey.KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Security_Privateca_V1beta1_PublicKey.KeyType] = [
    .unspecified,
    .pemRsaKey,
    .pemEcKey,
  ]
}

#endif  // swift(>=4.2)

/// A [CertificateConfig][google.cloud.security.privateca.v1beta1.CertificateConfig] describes an X.509 certificate or CSR that is to be
/// created, as an alternative to using ASN.1.
public struct Google_Cloud_Security_Privateca_V1beta1_CertificateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Specifies some of the values in a certificate that are related to the
  /// subject.
  public var subjectConfig: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.SubjectConfig {
    get {return _subjectConfig ?? Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.SubjectConfig()}
    set {_subjectConfig = newValue}
  }
  /// Returns true if `subjectConfig` has been explicitly set.
  public var hasSubjectConfig: Bool {return self._subjectConfig != nil}
  /// Clears the value of `subjectConfig`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectConfig() {self._subjectConfig = nil}

  /// Required. Describes how some of the technical fields in a certificate should be
  /// populated.
  public var reusableConfig: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper {
    get {return _reusableConfig ?? Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper()}
    set {_reusableConfig = newValue}
  }
  /// Returns true if `reusableConfig` has been explicitly set.
  public var hasReusableConfig: Bool {return self._reusableConfig != nil}
  /// Clears the value of `reusableConfig`. Subsequent reads from it will return its default value.
  public mutating func clearReusableConfig() {self._reusableConfig = nil}

  /// Optional. The public key that corresponds to this config. This is, for example, used
  /// when issuing [Certificates][google.cloud.security.privateca.v1beta1.Certificate], but not when creating a
  /// self-signed [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] or [CertificateAuthority][google.cloud.security.privateca.v1beta1.CertificateAuthority] CSR.
  public var publicKey: Google_Cloud_Security_Privateca_V1beta1_PublicKey {
    get {return _publicKey ?? Google_Cloud_Security_Privateca_V1beta1_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// These values are used to create the distinguished name and subject
  /// alternative name fields in an X.509 certificate.
  public struct SubjectConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. Contains distinguished name fields such as the location and organization.
    public var subject: Google_Cloud_Security_Privateca_V1beta1_Subject {
      get {return _subject ?? Google_Cloud_Security_Privateca_V1beta1_Subject()}
      set {_subject = newValue}
    }
    /// Returns true if `subject` has been explicitly set.
    public var hasSubject: Bool {return self._subject != nil}
    /// Clears the value of `subject`. Subsequent reads from it will return its default value.
    public mutating func clearSubject() {self._subject = nil}

    /// Optional. The "common name" of the distinguished name.
    public var commonName: String = String()

    /// Optional. The subject alternative name fields.
    public var subjectAltName: Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames {
      get {return _subjectAltName ?? Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames()}
      set {_subjectAltName = newValue}
    }
    /// Returns true if `subjectAltName` has been explicitly set.
    public var hasSubjectAltName: Bool {return self._subjectAltName != nil}
    /// Clears the value of `subjectAltName`. Subsequent reads from it will return its default value.
    public mutating func clearSubjectAltName() {self._subjectAltName = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _subject: Google_Cloud_Security_Privateca_V1beta1_Subject? = nil
    fileprivate var _subjectAltName: Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames? = nil
  }

  public init() {}

  fileprivate var _subjectConfig: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.SubjectConfig? = nil
  fileprivate var _reusableConfig: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper? = nil
  fileprivate var _publicKey: Google_Cloud_Security_Privateca_V1beta1_PublicKey? = nil
}

/// A [CertificateDescription][google.cloud.security.privateca.v1beta1.CertificateDescription] describes an X.509 certificate or CSR that has
/// been issued, as an alternative to using ASN.1 / X.509.
public struct Google_Cloud_Security_Privateca_V1beta1_CertificateDescription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes some of the values in a certificate that are related to the
  /// subject and lifetime.
  public var subjectDescription: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.SubjectDescription {
    get {return _subjectDescription ?? Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.SubjectDescription()}
    set {_subjectDescription = newValue}
  }
  /// Returns true if `subjectDescription` has been explicitly set.
  public var hasSubjectDescription: Bool {return self._subjectDescription != nil}
  /// Clears the value of `subjectDescription`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectDescription() {self._subjectDescription = nil}

  /// Describes some of the technical fields in a certificate.
  public var configValues: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues {
    get {return _configValues ?? Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues()}
    set {_configValues = newValue}
  }
  /// Returns true if `configValues` has been explicitly set.
  public var hasConfigValues: Bool {return self._configValues != nil}
  /// Clears the value of `configValues`. Subsequent reads from it will return its default value.
  public mutating func clearConfigValues() {self._configValues = nil}

  /// The public key that corresponds to an issued certificate.
  public var publicKey: Google_Cloud_Security_Privateca_V1beta1_PublicKey {
    get {return _publicKey ?? Google_Cloud_Security_Privateca_V1beta1_PublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  /// Provides a means of identifiying certificates that contain a particular
  /// public key, per https://tools.ietf.org/html/rfc5280#section-4.2.1.2.
  public var subjectKeyID: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId {
    get {return _subjectKeyID ?? Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId()}
    set {_subjectKeyID = newValue}
  }
  /// Returns true if `subjectKeyID` has been explicitly set.
  public var hasSubjectKeyID: Bool {return self._subjectKeyID != nil}
  /// Clears the value of `subjectKeyID`. Subsequent reads from it will return its default value.
  public mutating func clearSubjectKeyID() {self._subjectKeyID = nil}

  /// Identifies the subject_key_id of the parent certificate, per
  /// https://tools.ietf.org/html/rfc5280#section-4.2.1.1
  public var authorityKeyID: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId {
    get {return _authorityKeyID ?? Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId()}
    set {_authorityKeyID = newValue}
  }
  /// Returns true if `authorityKeyID` has been explicitly set.
  public var hasAuthorityKeyID: Bool {return self._authorityKeyID != nil}
  /// Clears the value of `authorityKeyID`. Subsequent reads from it will return its default value.
  public mutating func clearAuthorityKeyID() {self._authorityKeyID = nil}

  /// Describes a list of locations to obtain CRL information, i.e.
  /// the DistributionPoint.fullName described by
  /// https://tools.ietf.org/html/rfc5280#section-4.2.1.13
  public var crlDistributionPoints: [String] = []

  /// Describes lists of issuer CA certificate URLs that appear in the
  /// "Authority Information Access" extension in the certificate.
  public var aiaIssuingCertificateUrls: [String] = []

  /// The hash of the x.509 certificate.
  public var certFingerprint: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.CertificateFingerprint {
    get {return _certFingerprint ?? Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.CertificateFingerprint()}
    set {_certFingerprint = newValue}
  }
  /// Returns true if `certFingerprint` has been explicitly set.
  public var hasCertFingerprint: Bool {return self._certFingerprint != nil}
  /// Clears the value of `certFingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearCertFingerprint() {self._certFingerprint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// These values describe fields in an issued X.509 certificate such as the
  /// distinguished name, subject alternative names, serial number, and lifetime.
  public struct SubjectDescription {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Contains distinguished name fields such as the location and organization.
    public var subject: Google_Cloud_Security_Privateca_V1beta1_Subject {
      get {return _storage._subject ?? Google_Cloud_Security_Privateca_V1beta1_Subject()}
      set {_uniqueStorage()._subject = newValue}
    }
    /// Returns true if `subject` has been explicitly set.
    public var hasSubject: Bool {return _storage._subject != nil}
    /// Clears the value of `subject`. Subsequent reads from it will return its default value.
    public mutating func clearSubject() {_uniqueStorage()._subject = nil}

    /// The "common name" of the distinguished name.
    public var commonName: String {
      get {return _storage._commonName}
      set {_uniqueStorage()._commonName = newValue}
    }

    /// The subject alternative name fields.
    public var subjectAltName: Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames {
      get {return _storage._subjectAltName ?? Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames()}
      set {_uniqueStorage()._subjectAltName = newValue}
    }
    /// Returns true if `subjectAltName` has been explicitly set.
    public var hasSubjectAltName: Bool {return _storage._subjectAltName != nil}
    /// Clears the value of `subjectAltName`. Subsequent reads from it will return its default value.
    public mutating func clearSubjectAltName() {_uniqueStorage()._subjectAltName = nil}

    /// The serial number encoded in lowercase hexadecimal.
    public var hexSerialNumber: String {
      get {return _storage._hexSerialNumber}
      set {_uniqueStorage()._hexSerialNumber = newValue}
    }

    /// For convenience, the actual lifetime of an issued certificate.
    /// Corresponds to 'not_after_time' - 'not_before_time'.
    public var lifetime: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _storage._lifetime ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._lifetime = newValue}
    }
    /// Returns true if `lifetime` has been explicitly set.
    public var hasLifetime: Bool {return _storage._lifetime != nil}
    /// Clears the value of `lifetime`. Subsequent reads from it will return its default value.
    public mutating func clearLifetime() {_uniqueStorage()._lifetime = nil}

    /// The time at which the certificate becomes valid.
    public var notBeforeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._notBeforeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._notBeforeTime = newValue}
    }
    /// Returns true if `notBeforeTime` has been explicitly set.
    public var hasNotBeforeTime: Bool {return _storage._notBeforeTime != nil}
    /// Clears the value of `notBeforeTime`. Subsequent reads from it will return its default value.
    public mutating func clearNotBeforeTime() {_uniqueStorage()._notBeforeTime = nil}

    /// The time at which the certificate expires.
    public var notAfterTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._notAfterTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._notAfterTime = newValue}
    }
    /// Returns true if `notAfterTime` has been explicitly set.
    public var hasNotAfterTime: Bool {return _storage._notAfterTime != nil}
    /// Clears the value of `notAfterTime`. Subsequent reads from it will return its default value.
    public mutating func clearNotAfterTime() {_uniqueStorage()._notAfterTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// A KeyId identifies a specific public key, usually by hashing the public
  /// key.
  public struct KeyId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. The value of this KeyId encoded in lowercase hexadecimal. This is most
    /// likely the 160 bit SHA-1 hash of the public key.
    public var keyID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A group of fingerprints for the x509 certificate.
  public struct CertificateFingerprint {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The SHA 256 hash, encoded in hexadecimal, of the DER x509 certificate.
    public var sha256Hash: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _subjectDescription: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.SubjectDescription? = nil
  fileprivate var _configValues: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues? = nil
  fileprivate var _publicKey: Google_Cloud_Security_Privateca_V1beta1_PublicKey? = nil
  fileprivate var _subjectKeyID: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId? = nil
  fileprivate var _authorityKeyID: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId? = nil
  fileprivate var _certFingerprint: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.CertificateFingerprint? = nil
}

/// An [ObjectId][google.cloud.security.privateca.v1beta1.ObjectId] specifies an object identifier (OID). These provide context
/// and describe types in ASN.1 messages.
public struct Google_Cloud_Security_Privateca_V1beta1_ObjectId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parts of an OID path. The most significant parts of the path come
  /// first.
  public var objectIDPath: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An [X509Extension][google.cloud.security.privateca.v1beta1.X509Extension] specifies an X.509 extension, which may be used in
/// different parts of X.509 objects like certificates, CSRs, and CRLs.
public struct Google_Cloud_Security_Privateca_V1beta1_X509Extension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The OID for this X.509 extension.
  public var objectID: Google_Cloud_Security_Privateca_V1beta1_ObjectId {
    get {return _objectID ?? Google_Cloud_Security_Privateca_V1beta1_ObjectId()}
    set {_objectID = newValue}
  }
  /// Returns true if `objectID` has been explicitly set.
  public var hasObjectID: Bool {return self._objectID != nil}
  /// Clears the value of `objectID`. Subsequent reads from it will return its default value.
  public mutating func clearObjectID() {self._objectID = nil}

  /// Required. Indicates whether or not this extension is critical (i.e., if the client
  /// does not know how to handle this extension, the client should consider this
  /// to be an error).
  public var critical: Bool = false

  /// Required. The value of this X.509 extension.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _objectID: Google_Cloud_Security_Privateca_V1beta1_ObjectId? = nil
}

/// A [KeyUsage][google.cloud.security.privateca.v1beta1.KeyUsage] describes key usage values that may appear in an X.509
/// certificate.
public struct Google_Cloud_Security_Privateca_V1beta1_KeyUsage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Describes high-level ways in which a key may be used.
  public var baseKeyUsage: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.KeyUsageOptions {
    get {return _baseKeyUsage ?? Google_Cloud_Security_Privateca_V1beta1_KeyUsage.KeyUsageOptions()}
    set {_baseKeyUsage = newValue}
  }
  /// Returns true if `baseKeyUsage` has been explicitly set.
  public var hasBaseKeyUsage: Bool {return self._baseKeyUsage != nil}
  /// Clears the value of `baseKeyUsage`. Subsequent reads from it will return its default value.
  public mutating func clearBaseKeyUsage() {self._baseKeyUsage = nil}

  /// Detailed scenarios in which a key may be used.
  public var extendedKeyUsage: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.ExtendedKeyUsageOptions {
    get {return _extendedKeyUsage ?? Google_Cloud_Security_Privateca_V1beta1_KeyUsage.ExtendedKeyUsageOptions()}
    set {_extendedKeyUsage = newValue}
  }
  /// Returns true if `extendedKeyUsage` has been explicitly set.
  public var hasExtendedKeyUsage: Bool {return self._extendedKeyUsage != nil}
  /// Clears the value of `extendedKeyUsage`. Subsequent reads from it will return its default value.
  public mutating func clearExtendedKeyUsage() {self._extendedKeyUsage = nil}

  /// Used to describe extended key usages that are not listed in the
  /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.ExtendedKeyUsageOptions] message.
  public var unknownExtendedKeyUsages: [Google_Cloud_Security_Privateca_V1beta1_ObjectId] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// [KeyUsage.KeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.KeyUsageOptions] corresponds to the key usage values
  /// described in https://tools.ietf.org/html/rfc5280#section-4.2.1.3.
  public struct KeyUsageOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key may be used for digital signatures.
    public var digitalSignature: Bool = false

    /// The key may be used for cryptographic commitments. Note that this may
    /// also be referred to as "non-repudiation".
    public var contentCommitment: Bool = false

    /// The key may be used to encipher other keys.
    public var keyEncipherment: Bool = false

    /// The key may be used to encipher data.
    public var dataEncipherment: Bool = false

    /// The key may be used in a key agreement protocol.
    public var keyAgreement: Bool = false

    /// The key may be used to sign certificates.
    public var certSign: Bool = false

    /// The key may be used sign certificate revocation lists.
    public var crlSign: Bool = false

    /// The key may be used to encipher only.
    public var encipherOnly: Bool = false

    /// The key may be used to decipher only.
    public var decipherOnly: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// [KeyUsage.ExtendedKeyUsageOptions][google.cloud.security.privateca.v1beta1.KeyUsage.ExtendedKeyUsageOptions] has fields that correspond to
  /// certain common OIDs that could be specified as an extended key usage value.
  public struct ExtendedKeyUsageOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Corresponds to OID 1.3.6.1.5.5.7.3.1. Officially described as "TLS WWW
    /// server authentication", though regularly used for non-WWW TLS.
    public var serverAuth: Bool = false

    /// Corresponds to OID 1.3.6.1.5.5.7.3.2. Officially described as "TLS WWW
    /// client authentication", though regularly used for non-WWW TLS.
    public var clientAuth: Bool = false

    /// Corresponds to OID 1.3.6.1.5.5.7.3.3. Officially described as "Signing of
    /// downloadable executable code client authentication".
    public var codeSigning: Bool = false

    /// Corresponds to OID 1.3.6.1.5.5.7.3.4. Officially described as "Email
    /// protection".
    public var emailProtection: Bool = false

    /// Corresponds to OID 1.3.6.1.5.5.7.3.8. Officially described as "Binding
    /// the hash of an object to a time".
    public var timeStamping: Bool = false

    /// Corresponds to OID 1.3.6.1.5.5.7.3.9. Officially described as "Signing
    /// OCSP responses".
    public var ocspSigning: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _baseKeyUsage: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.KeyUsageOptions? = nil
  fileprivate var _extendedKeyUsage: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.ExtendedKeyUsageOptions? = nil
}

/// [Subject][google.cloud.security.privateca.v1beta1.Subject] describes parts of a distinguished name that, in turn,
/// describes the subject of the certificate.
public struct Google_Cloud_Security_Privateca_V1beta1_Subject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The country code of the subject.
  public var countryCode: String = String()

  /// The organization of the subject.
  public var organization: String = String()

  /// The organizational_unit of the subject.
  public var organizationalUnit: String = String()

  /// The locality or city of the subject.
  public var locality: String = String()

  /// The province, territory, or regional state of the subject.
  public var province: String = String()

  /// The street address of the subject.
  public var streetAddress: String = String()

  /// The postal code of the subject.
  public var postalCode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// [SubjectAltNames][google.cloud.security.privateca.v1beta1.SubjectAltNames] corresponds to a more modern way of listing what
/// the asserted identity is in a certificate (i.e., compared to the "common
/// name" in the distinguished name).
public struct Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains only valid, fully-qualified host names.
  public var dnsNames: [String] = []

  /// Contains only valid RFC 3986 URIs.
  public var uris: [String] = []

  /// Contains only valid RFC 2822 E-mail addresses.
  public var emailAddresses: [String] = []

  /// Contains only valid 32-bit IPv4 addresses or RFC 4291 IPv6 addresses.
  public var ipAddresses: [String] = []

  /// Contains additional subject alternative name values.
  public var customSans: [Google_Cloud_Security_Privateca_V1beta1_X509Extension] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.security.privateca.v1beta1"

extension Google_Cloud_Security_Privateca_V1beta1_RevocationReason: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REVOCATION_REASON_UNSPECIFIED"),
    1: .same(proto: "KEY_COMPROMISE"),
    2: .same(proto: "CERTIFICATE_AUTHORITY_COMPROMISE"),
    3: .same(proto: "AFFILIATION_CHANGED"),
    4: .same(proto: "SUPERSEDED"),
    5: .same(proto: "CESSATION_OF_OPERATION"),
    6: .same(proto: "CERTIFICATE_HOLD"),
    7: .same(proto: "PRIVILEGE_WITHDRAWN"),
    8: .same(proto: "ATTRIBUTE_AUTHORITY_COMPROMISE"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateAuthority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "type"),
    3: .same(proto: "tier"),
    4: .same(proto: "config"),
    5: .same(proto: "lifetime"),
    6: .standard(proto: "key_spec"),
    7: .standard(proto: "certificate_policy"),
    8: .standard(proto: "issuing_options"),
    19: .standard(proto: "subordinate_config"),
    10: .same(proto: "state"),
    9: .standard(proto: "pem_ca_certificates"),
    12: .standard(proto: "ca_certificate_descriptions"),
    13: .standard(proto: "gcs_bucket"),
    14: .standard(proto: "access_urls"),
    15: .standard(proto: "create_time"),
    16: .standard(proto: "update_time"),
    17: .standard(proto: "delete_time"),
    18: .same(proto: "labels"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _type: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.TypeEnum = .unspecified
    var _tier: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.Tier = .unspecified
    var _config: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig? = nil
    var _lifetime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _keySpec: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec? = nil
    var _certificatePolicy: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy? = nil
    var _issuingOptions: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.IssuingOptions? = nil
    var _subordinateConfig: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig? = nil
    var _state: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.State = .unspecified
    var _pemCaCertificates: [String] = []
    var _caCertificateDescriptions: [Google_Cloud_Security_Privateca_V1beta1_CertificateDescription] = []
    var _gcsBucket: String = String()
    var _accessUrls: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.AccessUrls? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _labels: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _type = source._type
      _tier = source._tier
      _config = source._config
      _lifetime = source._lifetime
      _keySpec = source._keySpec
      _certificatePolicy = source._certificatePolicy
      _issuingOptions = source._issuingOptions
      _subordinateConfig = source._subordinateConfig
      _state = source._state
      _pemCaCertificates = source._pemCaCertificates
      _caCertificateDescriptions = source._caCertificateDescriptions
      _gcsBucket = source._gcsBucket
      _accessUrls = source._accessUrls
      _createTime = source._createTime
      _updateTime = source._updateTime
      _deleteTime = source._deleteTime
      _labels = source._labels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._tier) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lifetime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._keySpec) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._certificatePolicy) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._issuingOptions) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._pemCaCertificates) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._caCertificateDescriptions) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._gcsBucket) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._accessUrls) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._deleteTime) }()
        case 18: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._subordinateConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if _storage._tier != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._tier, fieldNumber: 3)
      }
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._lifetime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._keySpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._certificatePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._issuingOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._pemCaCertificates.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._pemCaCertificates, fieldNumber: 9)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 10)
      }
      if !_storage._caCertificateDescriptions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._caCertificateDescriptions, fieldNumber: 12)
      }
      if !_storage._gcsBucket.isEmpty {
        try visitor.visitSingularStringField(value: _storage._gcsBucket, fieldNumber: 13)
      }
      if let v = _storage._accessUrls {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._deleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 18)
      }
      if let v = _storage._subordinateConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._tier != rhs_storage._tier {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._lifetime != rhs_storage._lifetime {return false}
        if _storage._keySpec != rhs_storage._keySpec {return false}
        if _storage._certificatePolicy != rhs_storage._certificatePolicy {return false}
        if _storage._issuingOptions != rhs_storage._issuingOptions {return false}
        if _storage._subordinateConfig != rhs_storage._subordinateConfig {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._pemCaCertificates != rhs_storage._pemCaCertificates {return false}
        if _storage._caCertificateDescriptions != rhs_storage._caCertificateDescriptions {return false}
        if _storage._gcsBucket != rhs_storage._gcsBucket {return false}
        if _storage._accessUrls != rhs_storage._accessUrls {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._deleteTime != rhs_storage._deleteTime {return false}
        if _storage._labels != rhs_storage._labels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "SELF_SIGNED"),
    2: .same(proto: "SUBORDINATE"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.Tier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIER_UNSPECIFIED"),
    1: .same(proto: "ENTERPRISE"),
    2: .same(proto: "DEVOPS"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ENABLED"),
    2: .same(proto: "DISABLED"),
    3: .same(proto: "PENDING_ACTIVATION"),
    4: .same(proto: "PENDING_DELETION"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.SignHashAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SIGN_HASH_ALGORITHM_UNSPECIFIED"),
    1: .same(proto: "RSA_PSS_2048_SHA256"),
    2: .same(proto: "RSA_PSS_3072_SHA256"),
    3: .same(proto: "RSA_PSS_4096_SHA256"),
    4: .same(proto: "EC_P256_SHA256"),
    5: .same(proto: "EC_P384_SHA384"),
    6: .same(proto: "RSA_PKCS1_2048_SHA256"),
    7: .same(proto: "RSA_PKCS1_3072_SHA256"),
    8: .same(proto: "RSA_PKCS1_4096_SHA256"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.IssuingOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.protoMessageName + ".IssuingOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_ca_cert_url"),
    2: .standard(proto: "include_crl_access_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeCaCertURL) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeCrlAccessURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeCaCertURL != false {
      try visitor.visitSingularBoolField(value: self.includeCaCertURL, fieldNumber: 1)
    }
    if self.includeCrlAccessURL != false {
      try visitor.visitSingularBoolField(value: self.includeCrlAccessURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.IssuingOptions, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.IssuingOptions) -> Bool {
    if lhs.includeCaCertURL != rhs.includeCaCertURL {return false}
    if lhs.includeCrlAccessURL != rhs.includeCrlAccessURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.protoMessageName + ".CertificateAuthorityPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_config_list"),
    2: .standard(proto: "overwrite_config_values"),
    3: .standard(proto: "allowed_locations_and_organizations"),
    4: .standard(proto: "allowed_common_names"),
    5: .standard(proto: "allowed_sans"),
    6: .standard(proto: "maximum_lifetime"),
    8: .standard(proto: "allowed_issuance_modes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList?
        if let current = self.configPolicy {
          try decoder.handleConflictingOneOf()
          if case .allowedConfigList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configPolicy = .allowedConfigList(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper?
        if let current = self.configPolicy {
          try decoder.handleConflictingOneOf()
          if case .overwriteConfigValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configPolicy = .overwriteConfigValues(v)}
      }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.allowedLocationsAndOrganizations) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.allowedCommonNames) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._allowedSans) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._maximumLifetime) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._allowedIssuanceModes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.configPolicy {
    case .allowedConfigList?: try {
      guard case .allowedConfigList(let v)? = self.configPolicy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .overwriteConfigValues?: try {
      guard case .overwriteConfigValues(let v)? = self.configPolicy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.allowedLocationsAndOrganizations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowedLocationsAndOrganizations, fieldNumber: 3)
    }
    if !self.allowedCommonNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedCommonNames, fieldNumber: 4)
    }
    if let v = self._allowedSans {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._maximumLifetime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._allowedIssuanceModes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy) -> Bool {
    if lhs.configPolicy != rhs.configPolicy {return false}
    if lhs.allowedLocationsAndOrganizations != rhs.allowedLocationsAndOrganizations {return false}
    if lhs.allowedCommonNames != rhs.allowedCommonNames {return false}
    if lhs._allowedSans != rhs._allowedSans {return false}
    if lhs._maximumLifetime != rhs._maximumLifetime {return false}
    if lhs._allowedIssuanceModes != rhs._allowedIssuanceModes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.protoMessageName + ".AllowedConfigList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_config_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allowedConfigValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedConfigValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowedConfigValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedConfigList) -> Bool {
    if lhs.allowedConfigValues != rhs.allowedConfigValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.protoMessageName + ".AllowedSubjectAltNames"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_dns_names"),
    2: .standard(proto: "allowed_uris"),
    3: .standard(proto: "allowed_email_addresses"),
    4: .standard(proto: "allowed_ips"),
    5: .standard(proto: "allow_globbing_dns_wildcards"),
    6: .standard(proto: "allow_custom_sans"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedDnsNames) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedUris) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.allowedEmailAddresses) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.allowedIps) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.allowGlobbingDnsWildcards) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.allowCustomSans) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedDnsNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedDnsNames, fieldNumber: 1)
    }
    if !self.allowedUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedUris, fieldNumber: 2)
    }
    if !self.allowedEmailAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedEmailAddresses, fieldNumber: 3)
    }
    if !self.allowedIps.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedIps, fieldNumber: 4)
    }
    if self.allowGlobbingDnsWildcards != false {
      try visitor.visitSingularBoolField(value: self.allowGlobbingDnsWildcards, fieldNumber: 5)
    }
    if self.allowCustomSans != false {
      try visitor.visitSingularBoolField(value: self.allowCustomSans, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.AllowedSubjectAltNames) -> Bool {
    if lhs.allowedDnsNames != rhs.allowedDnsNames {return false}
    if lhs.allowedUris != rhs.allowedUris {return false}
    if lhs.allowedEmailAddresses != rhs.allowedEmailAddresses {return false}
    if lhs.allowedIps != rhs.allowedIps {return false}
    if lhs.allowGlobbingDnsWildcards != rhs.allowGlobbingDnsWildcards {return false}
    if lhs.allowCustomSans != rhs.allowCustomSans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.protoMessageName + ".IssuanceModes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allow_csr_based_issuance"),
    2: .standard(proto: "allow_config_based_issuance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.allowCsrBasedIssuance) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowConfigBasedIssuance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.allowCsrBasedIssuance != false {
      try visitor.visitSingularBoolField(value: self.allowCsrBasedIssuance, fieldNumber: 1)
    }
    if self.allowConfigBasedIssuance != false {
      try visitor.visitSingularBoolField(value: self.allowConfigBasedIssuance, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.CertificateAuthorityPolicy.IssuanceModes) -> Bool {
    if lhs.allowCsrBasedIssuance != rhs.allowCsrBasedIssuance {return false}
    if lhs.allowConfigBasedIssuance != rhs.allowConfigBasedIssuance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.AccessUrls: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.protoMessageName + ".AccessUrls"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ca_certificate_access_url"),
    2: .standard(proto: "crl_access_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.caCertificateAccessURL) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.crlAccessURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.caCertificateAccessURL.isEmpty {
      try visitor.visitSingularStringField(value: self.caCertificateAccessURL, fieldNumber: 1)
    }
    if !self.crlAccessURL.isEmpty {
      try visitor.visitSingularStringField(value: self.crlAccessURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.AccessUrls, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.AccessUrls) -> Bool {
    if lhs.caCertificateAccessURL != rhs.caCertificateAccessURL {return false}
    if lhs.crlAccessURL != rhs.crlAccessURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.protoMessageName + ".KeyVersionSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_kms_key_version"),
    2: .same(proto: "algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.keyVersion != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.keyVersion = .cloudKmsKeyVersion(v)}
      }()
      case 2: try {
        if self.keyVersion != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.SignHashAlgorithm?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.keyVersion = .algorithm(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.keyVersion {
    case .cloudKmsKeyVersion?: try {
      guard case .cloudKmsKeyVersion(let v)? = self.keyVersion else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .algorithm?: try {
      guard case .algorithm(let v)? = self.keyVersion else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateAuthority.KeyVersionSpec) -> Bool {
    if lhs.keyVersion != rhs.keyVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateRevocationList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "sequence_number"),
    3: .standard(proto: "revoked_certificates"),
    4: .standard(proto: "pem_crl"),
    5: .standard(proto: "access_url"),
    6: .same(proto: "state"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "update_time"),
    9: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sequenceNumber) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.revokedCertificates) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pemCrl) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.accessURL) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.sequenceNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.sequenceNumber, fieldNumber: 2)
    }
    if !self.revokedCertificates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.revokedCertificates, fieldNumber: 3)
    }
    if !self.pemCrl.isEmpty {
      try visitor.visitSingularStringField(value: self.pemCrl, fieldNumber: 4)
    }
    if !self.accessURL.isEmpty {
      try visitor.visitSingularStringField(value: self.accessURL, fieldNumber: 5)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sequenceNumber != rhs.sequenceNumber {return false}
    if lhs.revokedCertificates != rhs.revokedCertificates {return false}
    if lhs.pemCrl != rhs.pemCrl {return false}
    if lhs.accessURL != rhs.accessURL {return false}
    if lhs.state != rhs.state {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "SUPERSEDED"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.RevokedCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.protoMessageName + ".RevokedCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "certificate"),
    2: .standard(proto: "hex_serial_number"),
    3: .standard(proto: "revocation_reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.certificate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.hexSerialNumber) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.revocationReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.certificate.isEmpty {
      try visitor.visitSingularStringField(value: self.certificate, fieldNumber: 1)
    }
    if !self.hexSerialNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.hexSerialNumber, fieldNumber: 2)
    }
    if self.revocationReason != .unspecified {
      try visitor.visitSingularEnumField(value: self.revocationReason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.RevokedCertificate, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateRevocationList.RevokedCertificate) -> Bool {
    if lhs.certificate != rhs.certificate {return false}
    if lhs.hexSerialNumber != rhs.hexSerialNumber {return false}
    if lhs.revocationReason != rhs.revocationReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_Certificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Certificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "pem_csr"),
    3: .same(proto: "config"),
    4: .same(proto: "lifetime"),
    5: .standard(proto: "revocation_details"),
    6: .standard(proto: "pem_certificate"),
    7: .standard(proto: "certificate_description"),
    8: .standard(proto: "pem_certificate_chain"),
    9: .standard(proto: "create_time"),
    10: .standard(proto: "update_time"),
    11: .same(proto: "labels"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _certificateConfig: Google_Cloud_Security_Privateca_V1beta1_Certificate.OneOf_CertificateConfig?
    var _lifetime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _revocationDetails: Google_Cloud_Security_Privateca_V1beta1_Certificate.RevocationDetails? = nil
    var _pemCertificate: String = String()
    var _certificateDescription: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription? = nil
    var _pemCertificateChain: [String] = []
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _labels: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _certificateConfig = source._certificateConfig
      _lifetime = source._lifetime
      _revocationDetails = source._revocationDetails
      _pemCertificate = source._pemCertificate
      _certificateDescription = source._certificateDescription
      _pemCertificateChain = source._pemCertificateChain
      _createTime = source._createTime
      _updateTime = source._updateTime
      _labels = source._labels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try {
          if _storage._certificateConfig != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._certificateConfig = .pemCsr(v)}
        }()
        case 3: try {
          var v: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig?
          if let current = _storage._certificateConfig {
            try decoder.handleConflictingOneOf()
            if case .config(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._certificateConfig = .config(v)}
        }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lifetime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._revocationDetails) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._pemCertificate) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._certificateDescription) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._pemCertificateChain) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._certificateConfig {
      case .pemCsr?: try {
        guard case .pemCsr(let v)? = _storage._certificateConfig else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }()
      case .config?: try {
        guard case .config(let v)? = _storage._certificateConfig else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case nil: break
      }
      if let v = _storage._lifetime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._revocationDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._pemCertificate.isEmpty {
        try visitor.visitSingularStringField(value: _storage._pemCertificate, fieldNumber: 6)
      }
      if let v = _storage._certificateDescription {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._pemCertificateChain.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._pemCertificateChain, fieldNumber: 8)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_Certificate, rhs: Google_Cloud_Security_Privateca_V1beta1_Certificate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._certificateConfig != rhs_storage._certificateConfig {return false}
        if _storage._lifetime != rhs_storage._lifetime {return false}
        if _storage._revocationDetails != rhs_storage._revocationDetails {return false}
        if _storage._pemCertificate != rhs_storage._pemCertificate {return false}
        if _storage._certificateDescription != rhs_storage._certificateDescription {return false}
        if _storage._pemCertificateChain != rhs_storage._pemCertificateChain {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._labels != rhs_storage._labels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_Certificate.RevocationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_Certificate.protoMessageName + ".RevocationDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "revocation_state"),
    2: .standard(proto: "revocation_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.revocationState) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._revocationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.revocationState != .unspecified {
      try visitor.visitSingularEnumField(value: self.revocationState, fieldNumber: 1)
    }
    if let v = self._revocationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_Certificate.RevocationDetails, rhs: Google_Cloud_Security_Privateca_V1beta1_Certificate.RevocationDetails) -> Bool {
    if lhs.revocationState != rhs.revocationState {return false}
    if lhs._revocationTime != rhs._revocationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_ReusableConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReusableConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "values"),
    3: .same(proto: "description"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "update_time"),
    6: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._values) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._values {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfig, rhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._values != rhs._values {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReusableConfigValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_usage"),
    2: .standard(proto: "ca_options"),
    3: .standard(proto: "policy_ids"),
    4: .standard(proto: "aia_ocsp_servers"),
    5: .standard(proto: "additional_extensions"),
  ]

  fileprivate class _StorageClass {
    var _keyUsage: Google_Cloud_Security_Privateca_V1beta1_KeyUsage? = nil
    var _caOptions: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.CaOptions? = nil
    var _policyIds: [Google_Cloud_Security_Privateca_V1beta1_ObjectId] = []
    var _aiaOcspServers: [String] = []
    var _additionalExtensions: [Google_Cloud_Security_Privateca_V1beta1_X509Extension] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _keyUsage = source._keyUsage
      _caOptions = source._caOptions
      _policyIds = source._policyIds
      _aiaOcspServers = source._aiaOcspServers
      _additionalExtensions = source._additionalExtensions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._keyUsage) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._caOptions) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._policyIds) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._aiaOcspServers) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._additionalExtensions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._keyUsage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._caOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._policyIds.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._policyIds, fieldNumber: 3)
      }
      if !_storage._aiaOcspServers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._aiaOcspServers, fieldNumber: 4)
      }
      if !_storage._additionalExtensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalExtensions, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues, rhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._keyUsage != rhs_storage._keyUsage {return false}
        if _storage._caOptions != rhs_storage._caOptions {return false}
        if _storage._policyIds != rhs_storage._policyIds {return false}
        if _storage._aiaOcspServers != rhs_storage._aiaOcspServers {return false}
        if _storage._additionalExtensions != rhs_storage._additionalExtensions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.CaOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.protoMessageName + ".CaOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_ca"),
    2: .standard(proto: "max_issuer_path_length"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._isCa) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxIssuerPathLength) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._isCa {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxIssuerPathLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.CaOptions, rhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues.CaOptions) -> Bool {
    if lhs._isCa != rhs._isCa {return false}
    if lhs._maxIssuerPathLength != rhs._maxIssuerPathLength {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReusableConfigWrapper"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "reusable_config"),
    2: .standard(proto: "reusable_config_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.configValues != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.configValues = .reusableConfig(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigValues?
        if let current = self.configValues {
          try decoder.handleConflictingOneOf()
          if case .reusableConfigValues(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.configValues = .reusableConfigValues(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.configValues {
    case .reusableConfig?: try {
      guard case .reusableConfig(let v)? = self.configValues else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .reusableConfigValues?: try {
      guard case .reusableConfigValues(let v)? = self.configValues else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper, rhs: Google_Cloud_Security_Privateca_V1beta1_ReusableConfigWrapper) -> Bool {
    if lhs.configValues != rhs.configValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubordinateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "certificate_authority"),
    2: .standard(proto: "pem_issuer_chain"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.subordinateConfig != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.subordinateConfig = .certificateAuthority(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain?
        if let current = self.subordinateConfig {
          try decoder.handleConflictingOneOf()
          if case .pemIssuerChain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.subordinateConfig = .pemIssuerChain(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.subordinateConfig {
    case .certificateAuthority?: try {
      guard case .certificateAuthority(let v)? = self.subordinateConfig else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .pemIssuerChain?: try {
      guard case .pemIssuerChain(let v)? = self.subordinateConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig, rhs: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig) -> Bool {
    if lhs.subordinateConfig != rhs.subordinateConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.protoMessageName + ".SubordinateConfigChain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pem_certificates"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pemCertificates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pemCertificates.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pemCertificates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain, rhs: Google_Cloud_Security_Privateca_V1beta1_SubordinateConfig.SubordinateConfigChain) -> Bool {
    if lhs.pemCertificates != rhs.pemCertificates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_PublicKey, rhs: Google_Cloud_Security_Privateca_V1beta1_PublicKey) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_PublicKey.KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_TYPE_UNSPECIFIED"),
    1: .same(proto: "PEM_RSA_KEY"),
    2: .same(proto: "PEM_EC_KEY"),
  ]
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subject_config"),
    2: .standard(proto: "reusable_config"),
    3: .standard(proto: "public_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subjectConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._reusableConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subjectConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._reusableConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig) -> Bool {
    if lhs._subjectConfig != rhs._subjectConfig {return false}
    if lhs._reusableConfig != rhs._reusableConfig {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.SubjectConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.protoMessageName + ".SubjectConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .standard(proto: "common_name"),
    3: .standard(proto: "subject_alt_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subject) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.commonName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._subjectAltName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.commonName.isEmpty {
      try visitor.visitSingularStringField(value: self.commonName, fieldNumber: 2)
    }
    if let v = self._subjectAltName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.SubjectConfig, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateConfig.SubjectConfig) -> Bool {
    if lhs._subject != rhs._subject {return false}
    if lhs.commonName != rhs.commonName {return false}
    if lhs._subjectAltName != rhs._subjectAltName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subject_description"),
    2: .standard(proto: "config_values"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "subject_key_id"),
    5: .standard(proto: "authority_key_id"),
    6: .standard(proto: "crl_distribution_points"),
    7: .standard(proto: "aia_issuing_certificate_urls"),
    8: .standard(proto: "cert_fingerprint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subjectDescription) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._configValues) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._subjectKeyID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._authorityKeyID) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.crlDistributionPoints) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.aiaIssuingCertificateUrls) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._certFingerprint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subjectDescription {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._configValues {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._subjectKeyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._authorityKeyID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.crlDistributionPoints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.crlDistributionPoints, fieldNumber: 6)
    }
    if !self.aiaIssuingCertificateUrls.isEmpty {
      try visitor.visitRepeatedStringField(value: self.aiaIssuingCertificateUrls, fieldNumber: 7)
    }
    if let v = self._certFingerprint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription) -> Bool {
    if lhs._subjectDescription != rhs._subjectDescription {return false}
    if lhs._configValues != rhs._configValues {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._subjectKeyID != rhs._subjectKeyID {return false}
    if lhs._authorityKeyID != rhs._authorityKeyID {return false}
    if lhs.crlDistributionPoints != rhs.crlDistributionPoints {return false}
    if lhs.aiaIssuingCertificateUrls != rhs.aiaIssuingCertificateUrls {return false}
    if lhs._certFingerprint != rhs._certFingerprint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.SubjectDescription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.protoMessageName + ".SubjectDescription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .standard(proto: "common_name"),
    3: .standard(proto: "subject_alt_name"),
    4: .standard(proto: "hex_serial_number"),
    5: .same(proto: "lifetime"),
    6: .standard(proto: "not_before_time"),
    7: .standard(proto: "not_after_time"),
  ]

  fileprivate class _StorageClass {
    var _subject: Google_Cloud_Security_Privateca_V1beta1_Subject? = nil
    var _commonName: String = String()
    var _subjectAltName: Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames? = nil
    var _hexSerialNumber: String = String()
    var _lifetime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _notBeforeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _notAfterTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _subject = source._subject
      _commonName = source._commonName
      _subjectAltName = source._subjectAltName
      _hexSerialNumber = source._hexSerialNumber
      _lifetime = source._lifetime
      _notBeforeTime = source._notBeforeTime
      _notAfterTime = source._notAfterTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._subject) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._commonName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._subjectAltName) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._hexSerialNumber) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lifetime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._notBeforeTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._notAfterTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._subject {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if !_storage._commonName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._commonName, fieldNumber: 2)
      }
      if let v = _storage._subjectAltName {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if !_storage._hexSerialNumber.isEmpty {
        try visitor.visitSingularStringField(value: _storage._hexSerialNumber, fieldNumber: 4)
      }
      if let v = _storage._lifetime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._notBeforeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._notAfterTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.SubjectDescription, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.SubjectDescription) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._commonName != rhs_storage._commonName {return false}
        if _storage._subjectAltName != rhs_storage._subjectAltName {return false}
        if _storage._hexSerialNumber != rhs_storage._hexSerialNumber {return false}
        if _storage._lifetime != rhs_storage._lifetime {return false}
        if _storage._notBeforeTime != rhs_storage._notBeforeTime {return false}
        if _storage._notAfterTime != rhs_storage._notAfterTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.protoMessageName + ".KeyId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.KeyId) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.CertificateFingerprint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.protoMessageName + ".CertificateFingerprint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sha256_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sha256Hash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sha256Hash.isEmpty {
      try visitor.visitSingularStringField(value: self.sha256Hash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.CertificateFingerprint, rhs: Google_Cloud_Security_Privateca_V1beta1_CertificateDescription.CertificateFingerprint) -> Bool {
    if lhs.sha256Hash != rhs.sha256Hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_ObjectId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.objectIDPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.objectIDPath.isEmpty {
      try visitor.visitPackedInt32Field(value: self.objectIDPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_ObjectId, rhs: Google_Cloud_Security_Privateca_V1beta1_ObjectId) -> Bool {
    if lhs.objectIDPath != rhs.objectIDPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_X509Extension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".X509Extension"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "object_id"),
    2: .same(proto: "critical"),
    3: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._objectID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.critical) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._objectID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.critical != false {
      try visitor.visitSingularBoolField(value: self.critical, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_X509Extension, rhs: Google_Cloud_Security_Privateca_V1beta1_X509Extension) -> Bool {
    if lhs._objectID != rhs._objectID {return false}
    if lhs.critical != rhs.critical {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_KeyUsage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyUsage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "base_key_usage"),
    2: .standard(proto: "extended_key_usage"),
    3: .standard(proto: "unknown_extended_key_usages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._baseKeyUsage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._extendedKeyUsage) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.unknownExtendedKeyUsages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._baseKeyUsage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._extendedKeyUsage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.unknownExtendedKeyUsages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unknownExtendedKeyUsages, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_KeyUsage, rhs: Google_Cloud_Security_Privateca_V1beta1_KeyUsage) -> Bool {
    if lhs._baseKeyUsage != rhs._baseKeyUsage {return false}
    if lhs._extendedKeyUsage != rhs._extendedKeyUsage {return false}
    if lhs.unknownExtendedKeyUsages != rhs.unknownExtendedKeyUsages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_KeyUsage.KeyUsageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_KeyUsage.protoMessageName + ".KeyUsageOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "digital_signature"),
    2: .standard(proto: "content_commitment"),
    3: .standard(proto: "key_encipherment"),
    4: .standard(proto: "data_encipherment"),
    5: .standard(proto: "key_agreement"),
    6: .standard(proto: "cert_sign"),
    7: .standard(proto: "crl_sign"),
    8: .standard(proto: "encipher_only"),
    9: .standard(proto: "decipher_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.digitalSignature) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.contentCommitment) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.keyEncipherment) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.dataEncipherment) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.keyAgreement) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.certSign) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.crlSign) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.encipherOnly) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.decipherOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.digitalSignature != false {
      try visitor.visitSingularBoolField(value: self.digitalSignature, fieldNumber: 1)
    }
    if self.contentCommitment != false {
      try visitor.visitSingularBoolField(value: self.contentCommitment, fieldNumber: 2)
    }
    if self.keyEncipherment != false {
      try visitor.visitSingularBoolField(value: self.keyEncipherment, fieldNumber: 3)
    }
    if self.dataEncipherment != false {
      try visitor.visitSingularBoolField(value: self.dataEncipherment, fieldNumber: 4)
    }
    if self.keyAgreement != false {
      try visitor.visitSingularBoolField(value: self.keyAgreement, fieldNumber: 5)
    }
    if self.certSign != false {
      try visitor.visitSingularBoolField(value: self.certSign, fieldNumber: 6)
    }
    if self.crlSign != false {
      try visitor.visitSingularBoolField(value: self.crlSign, fieldNumber: 7)
    }
    if self.encipherOnly != false {
      try visitor.visitSingularBoolField(value: self.encipherOnly, fieldNumber: 8)
    }
    if self.decipherOnly != false {
      try visitor.visitSingularBoolField(value: self.decipherOnly, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.KeyUsageOptions, rhs: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.KeyUsageOptions) -> Bool {
    if lhs.digitalSignature != rhs.digitalSignature {return false}
    if lhs.contentCommitment != rhs.contentCommitment {return false}
    if lhs.keyEncipherment != rhs.keyEncipherment {return false}
    if lhs.dataEncipherment != rhs.dataEncipherment {return false}
    if lhs.keyAgreement != rhs.keyAgreement {return false}
    if lhs.certSign != rhs.certSign {return false}
    if lhs.crlSign != rhs.crlSign {return false}
    if lhs.encipherOnly != rhs.encipherOnly {return false}
    if lhs.decipherOnly != rhs.decipherOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_KeyUsage.ExtendedKeyUsageOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Security_Privateca_V1beta1_KeyUsage.protoMessageName + ".ExtendedKeyUsageOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "server_auth"),
    2: .standard(proto: "client_auth"),
    3: .standard(proto: "code_signing"),
    4: .standard(proto: "email_protection"),
    5: .standard(proto: "time_stamping"),
    6: .standard(proto: "ocsp_signing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.serverAuth) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.clientAuth) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.codeSigning) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.emailProtection) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.timeStamping) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ocspSigning) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.serverAuth != false {
      try visitor.visitSingularBoolField(value: self.serverAuth, fieldNumber: 1)
    }
    if self.clientAuth != false {
      try visitor.visitSingularBoolField(value: self.clientAuth, fieldNumber: 2)
    }
    if self.codeSigning != false {
      try visitor.visitSingularBoolField(value: self.codeSigning, fieldNumber: 3)
    }
    if self.emailProtection != false {
      try visitor.visitSingularBoolField(value: self.emailProtection, fieldNumber: 4)
    }
    if self.timeStamping != false {
      try visitor.visitSingularBoolField(value: self.timeStamping, fieldNumber: 5)
    }
    if self.ocspSigning != false {
      try visitor.visitSingularBoolField(value: self.ocspSigning, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.ExtendedKeyUsageOptions, rhs: Google_Cloud_Security_Privateca_V1beta1_KeyUsage.ExtendedKeyUsageOptions) -> Bool {
    if lhs.serverAuth != rhs.serverAuth {return false}
    if lhs.clientAuth != rhs.clientAuth {return false}
    if lhs.codeSigning != rhs.codeSigning {return false}
    if lhs.emailProtection != rhs.emailProtection {return false}
    if lhs.timeStamping != rhs.timeStamping {return false}
    if lhs.ocspSigning != rhs.ocspSigning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_Subject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "country_code"),
    2: .same(proto: "organization"),
    3: .standard(proto: "organizational_unit"),
    4: .same(proto: "locality"),
    5: .same(proto: "province"),
    6: .standard(proto: "street_address"),
    7: .standard(proto: "postal_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.countryCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.organization) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.organizationalUnit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.locality) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.province) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.streetAddress) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.postalCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.countryCode.isEmpty {
      try visitor.visitSingularStringField(value: self.countryCode, fieldNumber: 1)
    }
    if !self.organization.isEmpty {
      try visitor.visitSingularStringField(value: self.organization, fieldNumber: 2)
    }
    if !self.organizationalUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.organizationalUnit, fieldNumber: 3)
    }
    if !self.locality.isEmpty {
      try visitor.visitSingularStringField(value: self.locality, fieldNumber: 4)
    }
    if !self.province.isEmpty {
      try visitor.visitSingularStringField(value: self.province, fieldNumber: 5)
    }
    if !self.streetAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.streetAddress, fieldNumber: 6)
    }
    if !self.postalCode.isEmpty {
      try visitor.visitSingularStringField(value: self.postalCode, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_Subject, rhs: Google_Cloud_Security_Privateca_V1beta1_Subject) -> Bool {
    if lhs.countryCode != rhs.countryCode {return false}
    if lhs.organization != rhs.organization {return false}
    if lhs.organizationalUnit != rhs.organizationalUnit {return false}
    if lhs.locality != rhs.locality {return false}
    if lhs.province != rhs.province {return false}
    if lhs.streetAddress != rhs.streetAddress {return false}
    if lhs.postalCode != rhs.postalCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubjectAltNames"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dns_names"),
    2: .same(proto: "uris"),
    3: .standard(proto: "email_addresses"),
    4: .standard(proto: "ip_addresses"),
    5: .standard(proto: "custom_sans"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.dnsNames) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.uris) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.emailAddresses) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.ipAddresses) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.customSans) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dnsNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.dnsNames, fieldNumber: 1)
    }
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 2)
    }
    if !self.emailAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.emailAddresses, fieldNumber: 3)
    }
    if !self.ipAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipAddresses, fieldNumber: 4)
    }
    if !self.customSans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customSans, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames, rhs: Google_Cloud_Security_Privateca_V1beta1_SubjectAltNames) -> Bool {
    if lhs.dnsNames != rhs.dnsNames {return false}
    if lhs.uris != rhs.uris {return false}
    if lhs.emailAddresses != rhs.emailAddresses {return false}
    if lhs.ipAddresses != rhs.ipAddresses {return false}
    if lhs.customSans != rhs.customSans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

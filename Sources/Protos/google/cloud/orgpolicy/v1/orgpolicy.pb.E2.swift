// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/orgpolicy/v1/orgpolicy.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines a Cloud Organization `Policy` which is used to specify `Constraints`
/// for configurations of Cloud Platform resources.
public struct Google_Cloud_Orgpolicy_V1_Policy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the `Policy`. Default version is 0;
  public var version: Int32 = 0

  /// The name of the `Constraint` the `Policy` is configuring, for example,
  /// `constraints/serviceuser.services`.
  ///
  /// Immutable after creation.
  public var constraint: String = String()

  /// An opaque tag indicating the current version of the `Policy`, used for
  /// concurrency control.
  ///
  /// When the `Policy` is returned from either a `GetPolicy` or a
  /// `ListOrgPolicy` request, this `etag` indicates the version of the current
  /// `Policy` to use when executing a read-modify-write loop.
  ///
  /// When the `Policy` is returned from a `GetEffectivePolicy` request, the
  /// `etag` will be unset.
  ///
  /// When the `Policy` is used in a `SetOrgPolicy` method, use the `etag` value
  /// that was returned from a `GetOrgPolicy` request as part of a
  /// read-modify-write loop for concurrency control. Not setting the `etag`in a
  /// `SetOrgPolicy` request will result in an unconditional write of the
  /// `Policy`.
  public var etag: Data = Data()

  /// The time stamp the `Policy` was previously updated. This is set by the
  /// server, not specified by the caller, and represents the last time a call to
  /// `SetOrgPolicy` was made for that `Policy`. Any value set by the client will
  /// be ignored.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// The field to populate is based on the `constraint_type` value in the
  /// `Constraint`.
  ///   `list_constraint` => `list_policy`
  ///   `boolean_constraint` => `boolean_policy`
  ///
  ///  A `restore_default` message may be used with any `Constraint` type.
  ///
  /// Providing a *_policy that is incompatible with the `constraint_type` will
  /// result in an `invalid_argument` error.
  ///
  /// Attempting to set a `Policy` with a `policy_type` not set will result in an
  /// `invalid_argument` error.
  public var policyType: Google_Cloud_Orgpolicy_V1_Policy.OneOf_PolicyType? = nil

  /// List of values either allowed or disallowed.
  public var listPolicy: Google_Cloud_Orgpolicy_V1_Policy.ListPolicy {
    get {
      if case .listPolicy(let v)? = policyType {return v}
      return Google_Cloud_Orgpolicy_V1_Policy.ListPolicy()
    }
    set {policyType = .listPolicy(newValue)}
  }

  /// For boolean `Constraints`, whether to enforce the `Constraint` or not.
  public var booleanPolicy: Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy {
    get {
      if case .booleanPolicy(let v)? = policyType {return v}
      return Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy()
    }
    set {policyType = .booleanPolicy(newValue)}
  }

  /// Restores the default behavior of the constraint; independent of
  /// `Constraint` type.
  public var restoreDefault: Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault {
    get {
      if case .restoreDefault(let v)? = policyType {return v}
      return Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault()
    }
    set {policyType = .restoreDefault(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The field to populate is based on the `constraint_type` value in the
  /// `Constraint`.
  ///   `list_constraint` => `list_policy`
  ///   `boolean_constraint` => `boolean_policy`
  ///
  ///  A `restore_default` message may be used with any `Constraint` type.
  ///
  /// Providing a *_policy that is incompatible with the `constraint_type` will
  /// result in an `invalid_argument` error.
  ///
  /// Attempting to set a `Policy` with a `policy_type` not set will result in an
  /// `invalid_argument` error.
  public enum OneOf_PolicyType: Equatable {
    /// List of values either allowed or disallowed.
    case listPolicy(Google_Cloud_Orgpolicy_V1_Policy.ListPolicy)
    /// For boolean `Constraints`, whether to enforce the `Constraint` or not.
    case booleanPolicy(Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy)
    /// Restores the default behavior of the constraint; independent of
    /// `Constraint` type.
    case restoreDefault(Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Orgpolicy_V1_Policy.OneOf_PolicyType, rhs: Google_Cloud_Orgpolicy_V1_Policy.OneOf_PolicyType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.listPolicy, .listPolicy): return {
        guard case .listPolicy(let l) = lhs, case .listPolicy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.booleanPolicy, .booleanPolicy): return {
        guard case .booleanPolicy(let l) = lhs, case .booleanPolicy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.restoreDefault, .restoreDefault): return {
        guard case .restoreDefault(let l) = lhs, case .restoreDefault(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Used in `policy_type` to specify how `list_policy` behaves at this
  /// resource.
  ///
  /// `ListPolicy` can define specific values and subtrees of Cloud Resource
  /// Manager resource hierarchy (`Organizations`, `Folders`, `Projects`) that
  /// are allowed or denied by setting the `allowed_values` and `denied_values`
  /// fields. This is achieved by using the `under:` and optional `is:` prefixes.
  /// The `under:` prefix is used to denote resource subtree values.
  /// The `is:` prefix is used to denote specific values, and is required only
  /// if the value contains a ":". Values prefixed with "is:" are treated the
  /// same as values with no prefix.
  /// Ancestry subtrees must be in one of the following formats:
  ///     - "projects/<project-id>", e.g. "projects/tokyo-rain-123"
  ///     - "folders/<folder-id>", e.g. "folders/1234"
  ///     - "organizations/<organization-id>", e.g. "organizations/1234"
  /// The `supports_under` field of the associated `Constraint`  defines whether
  /// ancestry prefixes can be used. You can set `allowed_values` and
  /// `denied_values` in the same `Policy` if `all_values` is
  /// `ALL_VALUES_UNSPECIFIED`. `ALLOW` or `DENY` are used to allow or deny all
  /// values. If `all_values` is set to either `ALLOW` or `DENY`,
  /// `allowed_values` and `denied_values` must be unset.
  public struct ListPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of values allowed  at this resource. Can only be set if `all_values`
    /// is set to `ALL_VALUES_UNSPECIFIED`.
    public var allowedValues: [String] = []

    /// List of values denied at this resource. Can only be set if `all_values`
    /// is set to `ALL_VALUES_UNSPECIFIED`.
    public var deniedValues: [String] = []

    /// The policy all_values state.
    public var allValues: Google_Cloud_Orgpolicy_V1_Policy.ListPolicy.AllValues = .unspecified

    /// Optional. The Google Cloud Console will try to default to a configuration
    /// that matches the value specified in this `Policy`. If `suggested_value`
    /// is not set, it will inherit the value specified higher in the hierarchy,
    /// unless `inherit_from_parent` is `false`.
    public var suggestedValue: String = String()

    /// Determines the inheritance behavior for this `Policy`.
    ///
    /// By default, a `ListPolicy` set at a resource supercedes any `Policy` set
    /// anywhere up the resource hierarchy. However, if `inherit_from_parent` is
    /// set to `true`, then the values from the effective `Policy` of the parent
    /// resource are inherited, meaning the values set in this `Policy` are
    /// added to the values inherited up the hierarchy.
    ///
    /// Setting `Policy` hierarchies that inherit both allowed values and denied
    /// values isn't recommended in most circumstances to keep the configuration
    /// simple and understandable. However, it is possible to set a `Policy` with
    /// `allowed_values` set that inherits a `Policy` with `denied_values` set.
    /// In this case, the values that are allowed must be in `allowed_values` and
    /// not present in `denied_values`.
    ///
    /// For example, suppose you have a `Constraint`
    /// `constraints/serviceuser.services`, which has a `constraint_type` of
    /// `list_constraint`, and with `constraint_default` set to `ALLOW`.
    /// Suppose that at the Organization level, a `Policy` is applied that
    /// restricts the allowed API activations to {`E1`, `E2`}. Then, if a
    /// `Policy` is applied to a project below the Organization that has
    /// `inherit_from_parent` set to `false` and field all_values set to DENY,
    /// then an attempt to activate any API will be denied.
    ///
    /// The following examples demonstrate different possible layerings for
    /// `projects/bar` parented by `organizations/foo`:
    ///
    /// Example 1 (no inherited values):
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "E1" allowed_values:"E2"}
    ///   `projects/bar` has `inherit_from_parent` `false` and values:
    ///     {allowed_values: "E3" allowed_values: "E4"}
    /// The accepted values at `organizations/foo` are `E1`, `E2`.
    /// The accepted values at `projects/bar` are `E3`, and `E4`.
    ///
    /// Example 2 (inherited values):
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "E1" allowed_values:"E2"}
    ///   `projects/bar` has a `Policy` with values:
    ///     {value: "E3" value: "E4" inherit_from_parent: true}
    /// The accepted values at `organizations/foo` are `E1`, `E2`.
    /// The accepted values at `projects/bar` are `E1`, `E2`, `E3`, and `E4`.
    ///
    /// Example 3 (inheriting both allowed and denied values):
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "E1" allowed_values: "E2"}
    ///   `projects/bar` has a `Policy` with:
    ///     {denied_values: "E1"}
    /// The accepted values at `organizations/foo` are `E1`, `E2`.
    /// The value accepted at `projects/bar` is `E2`.
    ///
    /// Example 4 (RestoreDefault):
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "E1" allowed_values:"E2"}
    ///   `projects/bar` has a `Policy` with values:
    ///     {RestoreDefault: {}}
    /// The accepted values at `organizations/foo` are `E1`, `E2`.
    /// The accepted values at `projects/bar` are either all or none depending on
    /// the value of `constraint_default` (if `ALLOW`, all; if
    /// `DENY`, none).
    ///
    /// Example 5 (no policy inherits parent policy):
    ///   `organizations/foo` has no `Policy` set.
    ///   `projects/bar` has no `Policy` set.
    /// The accepted values at both levels are either all or none depending on
    /// the value of `constraint_default` (if `ALLOW`, all; if
    /// `DENY`, none).
    ///
    /// Example 6 (ListConstraint allowing all):
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "E1" allowed_values: "E2"}
    ///   `projects/bar` has a `Policy` with:
    ///     {all: ALLOW}
    /// The accepted values at `organizations/foo` are `E1`, E2`.
    /// Any value is accepted at `projects/bar`.
    ///
    /// Example 7 (ListConstraint allowing none):
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "E1" allowed_values: "E2"}
    ///   `projects/bar` has a `Policy` with:
    ///     {all: DENY}
    /// The accepted values at `organizations/foo` are `E1`, E2`.
    /// No value is accepted at `projects/bar`.
    ///
    /// Example 10 (allowed and denied subtrees of Resource Manager hierarchy):
    /// Given the following resource hierarchy
    ///   O1->{F1, F2}; F1->{P1}; F2->{P2, P3},
    ///   `organizations/foo` has a `Policy` with values:
    ///     {allowed_values: "under:organizations/O1"}
    ///   `projects/bar` has a `Policy` with:
    ///     {allowed_values: "under:projects/P3"}
    ///     {denied_values: "under:folders/F2"}
    /// The accepted values at `organizations/foo` are `organizations/O1`,
    ///   `folders/F1`, `folders/F2`, `projects/P1`, `projects/P2`,
    ///   `projects/P3`.
    /// The accepted values at `projects/bar` are `organizations/O1`,
    ///   `folders/F1`, `projects/P1`.
    public var inheritFromParent: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// This enum can be used to set `Policies` that apply to all possible
    /// configuration values rather than specific values in `allowed_values` or
    /// `denied_values`.
    ///
    /// Settting this to `ALLOW` will mean this `Policy` allows all values.
    /// Similarly, setting it to `DENY` will mean no values are allowed. If
    /// set to either `ALLOW` or `DENY,  `allowed_values` and `denied_values`
    /// must be unset. Setting this to `ALL_VALUES_UNSPECIFIED` allows for
    /// setting `allowed_values` and `denied_values`.
    public enum AllValues: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Indicates that allowed_values or denied_values must be set.
      case unspecified // = 0

      /// A policy with this set allows all values.
      case allow // = 1

      /// A policy with this set denies all values.
      case deny // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .allow
        case 2: self = .deny
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .allow: return 1
        case .deny: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  /// Used in `policy_type` to specify how `boolean_policy` will behave at this
  /// resource.
  public struct BooleanPolicy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If `true`, then the `Policy` is enforced. If `false`, then any
    /// configuration is acceptable.
    ///
    /// Suppose you have a `Constraint`
    /// `constraints/compute.disableSerialPortAccess` with `constraint_default`
    /// set to `ALLOW`. A `Policy` for that `Constraint` exhibits the following
    /// behavior:
    ///   - If the `Policy` at this resource has enforced set to `false`, serial
    ///     port connection attempts will be allowed.
    ///   - If the `Policy` at this resource has enforced set to `true`, serial
    ///     port connection attempts will be refused.
    ///   - If the `Policy` at this resource is `RestoreDefault`, serial port
    ///     connection attempts will be allowed.
    ///   - If no `Policy` is set at this resource or anywhere higher in the
    ///     resource hierarchy, serial port connection attempts will be allowed.
    ///   - If no `Policy` is set at this resource, but one exists higher in the
    ///     resource hierarchy, the behavior is as if the`Policy` were set at
    ///     this resource.
    ///
    /// The following examples demonstrate the different possible layerings:
    ///
    /// Example 1 (nearest `Constraint` wins):
    ///   `organizations/foo` has a `Policy` with:
    ///     {enforced: false}
    ///   `projects/bar` has no `Policy` set.
    /// The constraint at `projects/bar` and `organizations/foo` will not be
    /// enforced.
    ///
    /// Example 2 (enforcement gets replaced):
    ///   `organizations/foo` has a `Policy` with:
    ///     {enforced: false}
    ///   `projects/bar` has a `Policy` with:
    ///     {enforced: true}
    /// The constraint at `organizations/foo` is not enforced.
    /// The constraint at `projects/bar` is enforced.
    ///
    /// Example 3 (RestoreDefault):
    ///   `organizations/foo` has a `Policy` with:
    ///     {enforced: true}
    ///   `projects/bar` has a `Policy` with:
    ///     {RestoreDefault: {}}
    /// The constraint at `organizations/foo` is enforced.
    /// The constraint at `projects/bar` is not enforced, because
    /// `constraint_default` for the `Constraint` is `ALLOW`.
    public var enforced: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Ignores policies set above this resource and restores the
  /// `constraint_default` enforcement behavior of the specific `Constraint` at
  /// this resource.
  ///
  /// Suppose that `constraint_default` is set to `ALLOW` for the
  /// `Constraint` `constraints/serviceuser.services`. Suppose that organization
  /// foo.com sets a `Policy` at their Organization resource node that restricts
  /// the allowed service activations to deny all service activations. They
  /// could then set a `Policy` with the `policy_type` `restore_default` on
  /// several experimental projects, restoring the `constraint_default`
  /// enforcement of the `Constraint` for only those projects, allowing those
  /// projects to have all services activated.
  public struct RestoreDefault {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Orgpolicy_V1_Policy.ListPolicy.AllValues: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Orgpolicy_V1_Policy.ListPolicy.AllValues] = [
    .unspecified,
    .allow,
    .deny,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.orgpolicy.v1"

extension Google_Cloud_Orgpolicy_V1_Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Policy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "constraint"),
    3: .same(proto: "etag"),
    4: .standard(proto: "update_time"),
    5: .standard(proto: "list_policy"),
    6: .standard(proto: "boolean_policy"),
    7: .standard(proto: "restore_default"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.constraint) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.etag) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 5: try {
        var v: Google_Cloud_Orgpolicy_V1_Policy.ListPolicy?
        if let current = self.policyType {
          try decoder.handleConflictingOneOf()
          if case .listPolicy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policyType = .listPolicy(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy?
        if let current = self.policyType {
          try decoder.handleConflictingOneOf()
          if case .booleanPolicy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policyType = .booleanPolicy(v)}
      }()
      case 7: try {
        var v: Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault?
        if let current = self.policyType {
          try decoder.handleConflictingOneOf()
          if case .restoreDefault(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policyType = .restoreDefault(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.constraint.isEmpty {
      try visitor.visitSingularStringField(value: self.constraint, fieldNumber: 2)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularBytesField(value: self.etag, fieldNumber: 3)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.policyType {
    case .listPolicy?: try {
      guard case .listPolicy(let v)? = self.policyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .booleanPolicy?: try {
      guard case .booleanPolicy(let v)? = self.policyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .restoreDefault?: try {
      guard case .restoreDefault(let v)? = self.policyType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Orgpolicy_V1_Policy, rhs: Google_Cloud_Orgpolicy_V1_Policy) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.constraint != rhs.constraint {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.policyType != rhs.policyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Orgpolicy_V1_Policy.ListPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Orgpolicy_V1_Policy.protoMessageName + ".ListPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_values"),
    2: .standard(proto: "denied_values"),
    3: .standard(proto: "all_values"),
    4: .standard(proto: "suggested_value"),
    5: .standard(proto: "inherit_from_parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedValues) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.deniedValues) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.allValues) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.suggestedValue) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.inheritFromParent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedValues, fieldNumber: 1)
    }
    if !self.deniedValues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deniedValues, fieldNumber: 2)
    }
    if self.allValues != .unspecified {
      try visitor.visitSingularEnumField(value: self.allValues, fieldNumber: 3)
    }
    if !self.suggestedValue.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestedValue, fieldNumber: 4)
    }
    if self.inheritFromParent != false {
      try visitor.visitSingularBoolField(value: self.inheritFromParent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Orgpolicy_V1_Policy.ListPolicy, rhs: Google_Cloud_Orgpolicy_V1_Policy.ListPolicy) -> Bool {
    if lhs.allowedValues != rhs.allowedValues {return false}
    if lhs.deniedValues != rhs.deniedValues {return false}
    if lhs.allValues != rhs.allValues {return false}
    if lhs.suggestedValue != rhs.suggestedValue {return false}
    if lhs.inheritFromParent != rhs.inheritFromParent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Orgpolicy_V1_Policy.ListPolicy.AllValues: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALL_VALUES_UNSPECIFIED"),
    1: .same(proto: "ALLOW"),
    2: .same(proto: "DENY"),
  ]
}

extension Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Orgpolicy_V1_Policy.protoMessageName + ".BooleanPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enforced"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enforced) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enforced != false {
      try visitor.visitSingularBoolField(value: self.enforced, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy, rhs: Google_Cloud_Orgpolicy_V1_Policy.BooleanPolicy) -> Bool {
    if lhs.enforced != rhs.enforced {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Orgpolicy_V1_Policy.protoMessageName + ".RestoreDefault"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault, rhs: Google_Cloud_Orgpolicy_V1_Policy.RestoreDefault) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

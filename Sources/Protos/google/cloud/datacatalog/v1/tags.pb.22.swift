// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datacatalog/v1/tags.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tags are used to attach custom metadata to Data Catalog resources. Tags
/// conform to the specifications within their tag template.
///
/// See [Data Catalog
/// IAM](https://cloud.google.com/data-catalog/docs/concepts/iam) for information
/// on the permissions needed to create or view tags.
public struct Google_Cloud_Datacatalog_V1_Tag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the tag in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entrygroups/{entry_group_id}/entries/{entry_id}/tags/{tag_id}
  ///
  /// where `tag_id` is a system-generated identifier.
  /// Note that this Tag may not actually be stored in the location in this name.
  public var name: String = String()

  /// Required. The resource name of the tag template that this tag uses. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}
  ///
  /// This field cannot be modified after creation.
  public var template: String = String()

  /// Output only. The display name of the tag template.
  public var templateDisplayName: String = String()

  /// The scope within the parent resource that this tag is attached to. If not
  /// provided, the tag is attached to the parent resource itself.
  /// Deleting the scope from the parent resource will delete all tags attached
  /// to that scope. These fields cannot be updated after creation.
  public var scope: Google_Cloud_Datacatalog_V1_Tag.OneOf_Scope? = nil

  /// Resources like Entry can have schemas associated with them. This scope
  /// allows users to attach tags to an individual column based on that schema.
  ///
  /// For attaching a tag to a nested column, use `.` to separate the column
  /// names. Example:
  ///
  /// * `outer_column.inner_column`
  public var column: String {
    get {
      if case .column(let v)? = scope {return v}
      return String()
    }
    set {scope = .column(newValue)}
  }

  /// Required. This maps the ID of a tag field to the value of and additional information
  /// about that field. Valid field IDs are defined by the tag's template. A tag
  /// must have at least 1 field and at most 500 fields.
  public var fields: Dictionary<String,Google_Cloud_Datacatalog_V1_TagField> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The scope within the parent resource that this tag is attached to. If not
  /// provided, the tag is attached to the parent resource itself.
  /// Deleting the scope from the parent resource will delete all tags attached
  /// to that scope. These fields cannot be updated after creation.
  public enum OneOf_Scope: Equatable {
    /// Resources like Entry can have schemas associated with them. This scope
    /// allows users to attach tags to an individual column based on that schema.
    ///
    /// For attaching a tag to a nested column, use `.` to separate the column
    /// names. Example:
    ///
    /// * `outer_column.inner_column`
    case column(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_Tag.OneOf_Scope, rhs: Google_Cloud_Datacatalog_V1_Tag.OneOf_Scope) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.column, .column): return {
        guard case .column(let l) = lhs, case .column(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Contains the value and supporting information for a field within
/// a [Tag][google.cloud.datacatalog.v1.Tag].
public struct Google_Cloud_Datacatalog_V1_TagField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The display name of this field.
  public var displayName: String = String()

  /// Required. The value of this field.
  public var kind: Google_Cloud_Datacatalog_V1_TagField.OneOf_Kind? = nil

  /// Holds the value for a tag field with double type.
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = kind {return v}
      return 0
    }
    set {kind = .doubleValue(newValue)}
  }

  /// Holds the value for a tag field with string type.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = kind {return v}
      return String()
    }
    set {kind = .stringValue(newValue)}
  }

  /// Holds the value for a tag field with boolean type.
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = kind {return v}
      return false
    }
    set {kind = .boolValue(newValue)}
  }

  /// Holds the value for a tag field with timestamp type.
  public var timestampValue: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestampValue(let v)? = kind {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {kind = .timestampValue(newValue)}
  }

  /// Holds the value for a tag field with enum type. This value must be
  /// one of the allowed values in the definition of this enum.
  public var enumValue: Google_Cloud_Datacatalog_V1_TagField.EnumValue {
    get {
      if case .enumValue(let v)? = kind {return v}
      return Google_Cloud_Datacatalog_V1_TagField.EnumValue()
    }
    set {kind = .enumValue(newValue)}
  }

  /// Output only. The order of this field with respect to other fields in this tag. It can be
  /// set in [Tag][google.cloud.datacatalog.v1.TagTemplateField.order]. For
  /// example, a higher value can indicate a more important field. The value can
  /// be negative. Multiple fields can have the same order, and field orders
  /// within a tag do not have to be sequential.
  public var order: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The value of this field.
  public enum OneOf_Kind: Equatable {
    /// Holds the value for a tag field with double type.
    case doubleValue(Double)
    /// Holds the value for a tag field with string type.
    case stringValue(String)
    /// Holds the value for a tag field with boolean type.
    case boolValue(Bool)
    /// Holds the value for a tag field with timestamp type.
    case timestampValue(SwiftProtobuf.Google_Protobuf_Timestamp)
    /// Holds the value for a tag field with enum type. This value must be
    /// one of the allowed values in the definition of this enum.
    case enumValue(Google_Cloud_Datacatalog_V1_TagField.EnumValue)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_TagField.OneOf_Kind, rhs: Google_Cloud_Datacatalog_V1_TagField.OneOf_Kind) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestampValue, .timestampValue): return {
        guard case .timestampValue(let l) = lhs, case .timestampValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.enumValue, .enumValue): return {
        guard case .enumValue(let l) = lhs, case .enumValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Holds an enum value.
  public struct EnumValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The display name of the enum value.
    public var displayName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A tag template defines a tag, which can have one or more typed fields.
/// The template is used to create and attach the tag to GCP resources.
/// [Tag template
/// roles](https://cloud.google.com/iam/docs/understanding-roles#data-catalog-roles)
/// provide permissions to create, edit, and use the template. See, for example,
/// the [TagTemplate
/// User](https://cloud.google.com/data-catalog/docs/how-to/template-user) role,
/// which includes permission to use the tag template to tag resources.
public struct Google_Cloud_Datacatalog_V1_TagTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the tag template in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}
  ///
  /// Note that this TagTemplate and its child resources may not actually be
  /// stored in the location in this name.
  public var name: String = String()

  /// The display name for this template. Defaults to an empty string.
  public var displayName: String = String()

  /// Required. Map of tag template field IDs to the settings for the field.
  /// This map is an exhaustive list of the allowed fields. This map must contain
  /// at least one field and at most 500 fields.
  ///
  /// The keys to this map are tag template field IDs. Field IDs can contain
  /// letters (both uppercase and lowercase), numbers (0-9) and underscores (_).
  /// Field IDs must be at least 1 character long and at most
  /// 64 characters long. Field IDs must start with a letter or underscore.
  public var fields: Dictionary<String,Google_Cloud_Datacatalog_V1_TagTemplateField> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The template for an individual field within a tag template.
public struct Google_Cloud_Datacatalog_V1_TagTemplateField {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the tag template field in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template}/fields/{field}
  ///
  /// Note that this TagTemplateField may not actually be stored in the location
  /// in this name.
  public var name: String = String()

  /// The display name for this field. Defaults to an empty string.
  public var displayName: String = String()

  /// Required. The type of value this tag field can contain.
  public var type: Google_Cloud_Datacatalog_V1_FieldType {
    get {return _type ?? Google_Cloud_Datacatalog_V1_FieldType()}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  public var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  public mutating func clearType() {self._type = nil}

  /// Whether this is a required field. Defaults to false.
  public var isRequired: Bool = false

  /// The order of this field with respect to other fields in this tag
  /// template. For example, a higher value can indicate a more important field.
  /// The value can be negative. Multiple fields can have the same order, and
  /// field orders within a tag do not have to be sequential.
  public var order: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _type: Google_Cloud_Datacatalog_V1_FieldType? = nil
}

public struct Google_Cloud_Datacatalog_V1_FieldType {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  public var typeDecl: Google_Cloud_Datacatalog_V1_FieldType.OneOf_TypeDecl? = nil

  /// Represents primitive types - string, bool etc.
  public var primitiveType: Google_Cloud_Datacatalog_V1_FieldType.PrimitiveType {
    get {
      if case .primitiveType(let v)? = typeDecl {return v}
      return .unspecified
    }
    set {typeDecl = .primitiveType(newValue)}
  }

  /// Represents an enum type.
  public var enumType: Google_Cloud_Datacatalog_V1_FieldType.EnumType {
    get {
      if case .enumType(let v)? = typeDecl {return v}
      return Google_Cloud_Datacatalog_V1_FieldType.EnumType()
    }
    set {typeDecl = .enumType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required.
  public enum OneOf_TypeDecl: Equatable {
    /// Represents primitive types - string, bool etc.
    case primitiveType(Google_Cloud_Datacatalog_V1_FieldType.PrimitiveType)
    /// Represents an enum type.
    case enumType(Google_Cloud_Datacatalog_V1_FieldType.EnumType)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_FieldType.OneOf_TypeDecl, rhs: Google_Cloud_Datacatalog_V1_FieldType.OneOf_TypeDecl) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.primitiveType, .primitiveType): return {
        guard case .primitiveType(let l) = lhs, case .primitiveType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.enumType, .enumType): return {
        guard case .enumType(let l) = lhs, case .enumType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum PrimitiveType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// This is the default invalid value for a type.
    case unspecified // = 0

    /// A double precision number.
    case double // = 1

    /// An UTF-8 string.
    case string // = 2

    /// A boolean value.
    case bool // = 3

    /// A timestamp.
    case timestamp // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .double
      case 2: self = .string
      case 3: self = .bool
      case 4: self = .timestamp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .double: return 1
      case .string: return 2
      case .bool: return 3
      case .timestamp: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct EnumType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required on create; optional on update. The set of allowed values for
    /// this enum. This set must not be empty, the display names of the values in
    /// this set must not be empty and the display names of the values must be
    /// case-insensitively unique within this set. Currently, enum values can
    /// only be added to the list of allowed values. Deletion and renaming of
    /// enum values are not supported. Can have up to 500 allowed values.
    public var allowedValues: [Google_Cloud_Datacatalog_V1_FieldType.EnumType.EnumValue] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct EnumValue {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Required. The display name of the enum value. Must not be an empty string.
      public var displayName: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Datacatalog_V1_FieldType.PrimitiveType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datacatalog_V1_FieldType.PrimitiveType] = [
    .unspecified,
    .double,
    .string,
    .bool,
    .timestamp,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datacatalog.v1"

extension Google_Cloud_Datacatalog_V1_Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Tag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "template"),
    5: .standard(proto: "template_display_name"),
    4: .same(proto: "column"),
    3: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.template) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Datacatalog_V1_TagField>.self, value: &self.fields) }()
      case 4: try {
        if self.scope != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.scope = .column(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.templateDisplayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.template.isEmpty {
      try visitor.visitSingularStringField(value: self.template, fieldNumber: 2)
    }
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Datacatalog_V1_TagField>.self, value: self.fields, fieldNumber: 3)
    }
    if case .column(let v)? = self.scope {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if !self.templateDisplayName.isEmpty {
      try visitor.visitSingularStringField(value: self.templateDisplayName, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_Tag, rhs: Google_Cloud_Datacatalog_V1_Tag) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.template != rhs.template {return false}
    if lhs.templateDisplayName != rhs.templateDisplayName {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_TagField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .standard(proto: "double_value"),
    3: .standard(proto: "string_value"),
    4: .standard(proto: "bool_value"),
    5: .standard(proto: "timestamp_value"),
    6: .standard(proto: "enum_value"),
    7: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try {
        if self.kind != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.kind = .doubleValue(v)}
      }()
      case 3: try {
        if self.kind != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.kind = .stringValue(v)}
      }()
      case 4: try {
        if self.kind != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.kind = .boolValue(v)}
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.kind {
          try decoder.handleConflictingOneOf()
          if case .timestampValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.kind = .timestampValue(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Datacatalog_V1_TagField.EnumValue?
        if let current = self.kind {
          try decoder.handleConflictingOneOf()
          if case .enumValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.kind = .enumValue(v)}
      }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.kind {
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .timestampValue?: try {
      guard case .timestampValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .enumValue?: try {
      guard case .enumValue(let v)? = self.kind else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_TagField, rhs: Google_Cloud_Datacatalog_V1_TagField) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_TagField.EnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datacatalog_V1_TagField.protoMessageName + ".EnumValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_TagField.EnumValue, rhs: Google_Cloud_Datacatalog_V1_TagField.EnumValue) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_TagTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagTemplate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Datacatalog_V1_TagTemplateField>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Datacatalog_V1_TagTemplateField>.self, value: self.fields, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_TagTemplate, rhs: Google_Cloud_Datacatalog_V1_TagTemplate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_TagTemplateField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TagTemplateField"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "name"),
    1: .standard(proto: "display_name"),
    2: .same(proto: "type"),
    3: .standard(proto: "is_required"),
    5: .same(proto: "order"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isRequired) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.order) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.isRequired != false {
      try visitor.visitSingularBoolField(value: self.isRequired, fieldNumber: 3)
    }
    if self.order != 0 {
      try visitor.visitSingularInt32Field(value: self.order, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_TagTemplateField, rhs: Google_Cloud_Datacatalog_V1_TagTemplateField) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._type != rhs._type {return false}
    if lhs.isRequired != rhs.isRequired {return false}
    if lhs.order != rhs.order {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_FieldType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FieldType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "primitive_type"),
    2: .standard(proto: "enum_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.typeDecl != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Datacatalog_V1_FieldType.PrimitiveType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.typeDecl = .primitiveType(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Datacatalog_V1_FieldType.EnumType?
        if let current = self.typeDecl {
          try decoder.handleConflictingOneOf()
          if case .enumType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.typeDecl = .enumType(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.typeDecl {
    case .primitiveType?: try {
      guard case .primitiveType(let v)? = self.typeDecl else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .enumType?: try {
      guard case .enumType(let v)? = self.typeDecl else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_FieldType, rhs: Google_Cloud_Datacatalog_V1_FieldType) -> Bool {
    if lhs.typeDecl != rhs.typeDecl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_FieldType.PrimitiveType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIMITIVE_TYPE_UNSPECIFIED"),
    1: .same(proto: "DOUBLE"),
    2: .same(proto: "STRING"),
    3: .same(proto: "BOOL"),
    4: .same(proto: "TIMESTAMP"),
  ]
}

extension Google_Cloud_Datacatalog_V1_FieldType.EnumType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datacatalog_V1_FieldType.protoMessageName + ".EnumType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.allowedValues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allowedValues, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_FieldType.EnumType, rhs: Google_Cloud_Datacatalog_V1_FieldType.EnumType) -> Bool {
    if lhs.allowedValues != rhs.allowedValues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_FieldType.EnumType.EnumValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datacatalog_V1_FieldType.EnumType.protoMessageName + ".EnumValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_FieldType.EnumType.EnumValue, rhs: Google_Cloud_Datacatalog_V1_FieldType.EnumType.EnumValue) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datacatalog/v1/datacatalog.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Entry resources in Data Catalog can be of different types e.g. a BigQuery
/// Table entry is of type `TABLE`. This enum describes all the possible types
/// Data Catalog contains.
public enum Google_Cloud_Datacatalog_V1_EntryType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default unknown type.
  case unspecified // = 0

  /// Output only. The type of entry that has a GoogleSQL schema, including
  /// logical views.
  case table // = 2

  /// Output only. The type of models, examples include
  /// https://cloud.google.com/bigquery-ml/docs/bigqueryml-intro
  case model // = 5

  /// Output only. An entry type which is used for streaming entries. Example:
  /// Pub/Sub topic.
  case dataStream // = 3

  /// An entry type which is a set of files or objects. Example:
  /// Cloud Storage fileset.
  case fileset // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 2: self = .table
    case 3: self = .dataStream
    case 4: self = .fileset
    case 5: self = .model
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .table: return 2
    case .dataStream: return 3
    case .fileset: return 4
    case .model: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Datacatalog_V1_EntryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Datacatalog_V1_EntryType] = [
    .unspecified,
    .table,
    .model,
    .dataStream,
    .fileset,
  ]
}

#endif  // swift(>=4.2)

/// Request message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
public struct Google_Cloud_Datacatalog_V1_SearchCatalogRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The scope of this search request. A `scope` that has empty
  /// `include_org_ids`, `include_project_ids` AND false
  /// `include_gcp_public_datasets` is considered invalid. Data Catalog will
  /// return an error in such a case.
  public var scope: Google_Cloud_Datacatalog_V1_SearchCatalogRequest.Scope {
    get {return _scope ?? Google_Cloud_Datacatalog_V1_SearchCatalogRequest.Scope()}
    set {_scope = newValue}
  }
  /// Returns true if `scope` has been explicitly set.
  public var hasScope: Bool {return self._scope != nil}
  /// Clears the value of `scope`. Subsequent reads from it will return its default value.
  public mutating func clearScope() {self._scope = nil}

  /// Required. The query string in search query syntax. The query must be
  /// non-empty.
  ///
  /// Query strings can be simple as "x" or more qualified as:
  ///
  /// * name:x
  /// * column:x
  /// * description:y
  ///
  /// Note: Query tokens need to have a minimum of 3 characters for substring
  /// matching to work correctly. See [Data Catalog Search
  /// Syntax](https://cloud.google.com/data-catalog/docs/how-to/search-reference)
  /// for more information.
  public var query: String = String()

  /// Number of results in the search page. If <=0 then defaults to 10. Max limit
  /// for page_size is 1000. Throws an invalid argument for page_size > 1000.
  public var pageSize: Int32 = 0

  /// Optional. Pagination token returned in an earlier
  /// [SearchCatalogResponse.next_page_token][google.cloud.datacatalog.v1.SearchCatalogResponse.next_page_token],
  /// which indicates that this is a continuation of a prior
  /// [SearchCatalogRequest][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog]
  /// call, and that the system should return the next page of data. If empty,
  /// the first page is returned.
  public var pageToken: String = String()

  /// Specifies the ordering of results, currently supported case-sensitive
  /// choices are:
  ///
  ///   * `relevance`, only supports descending
  ///   * `last_modified_timestamp [asc|desc]`, defaults to descending if not
  ///     specified
  ///
  /// If not specified, defaults to `relevance` descending.
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The criteria that select the subspace used for query matching.
  public struct Scope {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of organization IDs to search within. To find your organization
    /// ID, follow instructions in
    /// https://cloud.google.com/resource-manager/docs/creating-managing-organization.
    public var includeOrgIds: [String] = []

    /// The list of project IDs to search within. To learn more about the
    /// distinction between project names/IDs/numbers, go to
    /// https://cloud.google.com/docs/overview/#projects.
    public var includeProjectIds: [String] = []

    /// If `true`, include Google Cloud Platform (GCP) public datasets in the
    /// search results. Info on GCP public datasets is available at
    /// https://cloud.google.com/public-datasets/. By default, GCP public
    /// datasets are excluded.
    public var includeGcpPublicDatasets: Bool = false

    /// Optional. The list of locations to search within.
    /// 1. If empty, search will be performed in all locations;
    /// 2. If any of the locations are NOT in the valid locations list, error
    /// will be returned;
    /// 3. Otherwise, search only the given locations for matching results.
    /// Typical usage is to leave this field empty. When a location is
    /// unreachable as returned in the `SearchCatalogResponse.unreachable` field,
    /// users can repeat the search request with this parameter set to get
    /// additional information on the error.
    ///
    /// Valid locations:
    ///  * asia-east1
    ///  * asia-east2
    ///  * asia-northeast1
    ///  * asia-northeast2
    ///  * asia-northeast3
    ///  * asia-south1
    ///  * asia-southeast1
    ///  * australia-southeast1
    ///  * eu
    ///  * europe-north1
    ///  * europe-west1
    ///  * europe-west2
    ///  * europe-west3
    ///  * europe-west4
    ///  * europe-west6
    ///  * global
    ///  * northamerica-northeast1
    ///  * southamerica-east1
    ///  * us
    ///  * us-central1
    ///  * us-east1
    ///  * us-east4
    ///  * us-west1
    ///  * us-west2
    public var restrictedLocations: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _scope: Google_Cloud_Datacatalog_V1_SearchCatalogRequest.Scope? = nil
}

/// Response message for
/// [SearchCatalog][google.cloud.datacatalog.v1.DataCatalog.SearchCatalog].
public struct Google_Cloud_Datacatalog_V1_SearchCatalogResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Search results.
  public var results: [Google_Cloud_Datacatalog_V1_SearchCatalogResult] = []

  /// The token that can be used to retrieve the next page of results.
  public var nextPageToken: String = String()

  /// Unreachable locations. Search result does not include data from those
  /// locations. Users can get additional information on the error by repeating
  /// the search request with a more restrictive parameter -- setting the value
  /// for `SearchDataCatalogRequest.scope.include_locations`.
  public var unreachable: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [CreateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.CreateEntryGroup].
public struct Google_Cloud_Datacatalog_V1_CreateEntryGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project this entry group is in. Example:
  ///
  /// * projects/{project_id}/locations/{location}
  ///
  /// Note that this EntryGroup and its child resources may not actually be
  /// stored in the location in this name.
  public var parent: String = String()

  /// Required. The id of the entry group to create.
  /// The id must begin with a letter or underscore, contain only English
  /// letters, numbers and underscores, and be at most 64 characters.
  public var entryGroupID: String = String()

  /// The entry group to create. Defaults to an empty entry group.
  public var entryGroup: Google_Cloud_Datacatalog_V1_EntryGroup {
    get {return _entryGroup ?? Google_Cloud_Datacatalog_V1_EntryGroup()}
    set {_entryGroup = newValue}
  }
  /// Returns true if `entryGroup` has been explicitly set.
  public var hasEntryGroup: Bool {return self._entryGroup != nil}
  /// Clears the value of `entryGroup`. Subsequent reads from it will return its default value.
  public mutating func clearEntryGroup() {self._entryGroup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entryGroup: Google_Cloud_Datacatalog_V1_EntryGroup? = nil
}

/// Request message for
/// [UpdateEntryGroup][google.cloud.datacatalog.v1.DataCatalog.UpdateEntryGroup].
public struct Google_Cloud_Datacatalog_V1_UpdateEntryGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated entry group. "name" field must be set.
  public var entryGroup: Google_Cloud_Datacatalog_V1_EntryGroup {
    get {return _entryGroup ?? Google_Cloud_Datacatalog_V1_EntryGroup()}
    set {_entryGroup = newValue}
  }
  /// Returns true if `entryGroup` has been explicitly set.
  public var hasEntryGroup: Bool {return self._entryGroup != nil}
  /// Clears the value of `entryGroup`. Subsequent reads from it will return its default value.
  public mutating func clearEntryGroup() {self._entryGroup = nil}

  /// The fields to update on the entry group. If absent or empty, all modifiable
  /// fields are updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _entryGroup: Google_Cloud_Datacatalog_V1_EntryGroup? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// [GetEntryGroup][google.cloud.datacatalog.v1.DataCatalog.GetEntryGroup].
public struct Google_Cloud_Datacatalog_V1_GetEntryGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the entry group. For example,
  /// `projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}`.
  public var name: String = String()

  /// The fields to return. If not set or empty, all fields are returned.
  public var readMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _readMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_readMask = newValue}
  }
  /// Returns true if `readMask` has been explicitly set.
  public var hasReadMask: Bool {return self._readMask != nil}
  /// Clears the value of `readMask`. Subsequent reads from it will return its default value.
  public mutating func clearReadMask() {self._readMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// [DeleteEntryGroup][google.cloud.datacatalog.v1.DataCatalog.DeleteEntryGroup].
public struct Google_Cloud_Datacatalog_V1_DeleteEntryGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the entry group. For example,
  /// `projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}`.
  public var name: String = String()

  /// Optional. If true, deletes all entries in the entry group.
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
public struct Google_Cloud_Datacatalog_V1_ListEntryGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the location that contains the entry groups, which
  /// can be provided in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}
  public var parent: String = String()

  /// Optional. The maximum number of items to return. Default is 10. Max limit
  /// is 1000. Throws an invalid argument for `page_size > 1000`.
  public var pageSize: Int32 = 0

  /// Optional. Token that specifies which page is requested. If empty, the first
  /// page is returned.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [ListEntryGroups][google.cloud.datacatalog.v1.DataCatalog.ListEntryGroups].
public struct Google_Cloud_Datacatalog_V1_ListEntryGroupsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// EntryGroup details.
  public var entryGroups: [Google_Cloud_Datacatalog_V1_EntryGroup] = []

  /// Token to retrieve the next page of results. It is set to empty if no items
  /// remain in results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [CreateEntry][google.cloud.datacatalog.v1.DataCatalog.CreateEntry].
public struct Google_Cloud_Datacatalog_V1_CreateEntryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the entry group this entry is in. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}
  ///
  /// Note that this Entry and its child resources may not actually be stored in
  /// the location in this name.
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// Required. The id of the entry to create.
  public var entryID: String {
    get {return _storage._entryID}
    set {_uniqueStorage()._entryID = newValue}
  }

  /// Required. The entry to create.
  public var entry: Google_Cloud_Datacatalog_V1_Entry {
    get {return _storage._entry ?? Google_Cloud_Datacatalog_V1_Entry()}
    set {_uniqueStorage()._entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  public var hasEntry: Bool {return _storage._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  public mutating func clearEntry() {_uniqueStorage()._entry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request message for
/// [UpdateEntry][google.cloud.datacatalog.v1.DataCatalog.UpdateEntry].
public struct Google_Cloud_Datacatalog_V1_UpdateEntryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated entry. The "name" field must be set.
  public var entry: Google_Cloud_Datacatalog_V1_Entry {
    get {return _storage._entry ?? Google_Cloud_Datacatalog_V1_Entry()}
    set {_uniqueStorage()._entry = newValue}
  }
  /// Returns true if `entry` has been explicitly set.
  public var hasEntry: Bool {return _storage._entry != nil}
  /// Clears the value of `entry`. Subsequent reads from it will return its default value.
  public mutating func clearEntry() {_uniqueStorage()._entry = nil}

  /// The fields to update on the entry. If absent or empty, all modifiable
  /// fields are updated.
  ///
  /// The following fields are modifiable:
  /// * For entries with type `DATA_STREAM`:
  ///    * `schema`
  /// * For entries with type `FILESET`
  ///    * `schema`
  ///    * `display_name`
  ///    * `description`
  ///    * `gcs_fileset_spec`
  ///    * `gcs_fileset_spec.file_patterns`
  /// * For entries with `user_specified_type`
  ///    * `schema`
  ///    * `display_name`
  ///    * `description`
  ///    * user_specified_type
  ///    * user_specified_system
  ///    * linked_resource
  ///    * source_system_timestamps
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request message for
/// [DeleteEntry][google.cloud.datacatalog.v1.DataCatalog.DeleteEntry].
public struct Google_Cloud_Datacatalog_V1_DeleteEntryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the entry. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}/entries/{entry_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [GetEntry][google.cloud.datacatalog.v1.DataCatalog.GetEntry].
public struct Google_Cloud_Datacatalog_V1_GetEntryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the entry. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}/entries/{entry_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [LookupEntry][google.cloud.datacatalog.v1.DataCatalog.LookupEntry].
public struct Google_Cloud_Datacatalog_V1_LookupEntryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Represents either the Google Cloud Platform resource or SQL name
  /// for a Google Cloud Platform resource.
  public var targetName: Google_Cloud_Datacatalog_V1_LookupEntryRequest.OneOf_TargetName? = nil

  /// The full name of the Google Cloud Platform resource the Data Catalog
  /// entry represents. See:
  /// https://cloud.google.com/apis/design/resource_names#full_resource_name.
  /// Full names are case-sensitive.
  ///
  /// Examples:
  ///
  ///  * //bigquery.googleapis.com/projects/projectId/datasets/datasetId/tables/tableId
  ///  * //pubsub.googleapis.com/projects/projectId/topics/topicId
  public var linkedResource: String {
    get {
      if case .linkedResource(let v)? = targetName {return v}
      return String()
    }
    set {targetName = .linkedResource(newValue)}
  }

  /// The SQL name of the entry. SQL names are case-sensitive.
  ///
  /// Examples:
  ///
  ///   * `pubsub.project_id.topic_id`
  ///   * ``pubsub.project_id.`topic.id.with.dots` ``
  ///   * `bigquery.table.project_id.dataset_id.table_id`
  ///   * `bigquery.dataset.project_id.dataset_id`
  ///   * `datacatalog.entry.project_id.location_id.entry_group_id.entry_id`
  ///
  /// `*_id`s shoud satisfy the standard SQL rules for identifiers.
  /// https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical.
  public var sqlResource: String {
    get {
      if case .sqlResource(let v)? = targetName {return v}
      return String()
    }
    set {targetName = .sqlResource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Represents either the Google Cloud Platform resource or SQL name
  /// for a Google Cloud Platform resource.
  public enum OneOf_TargetName: Equatable {
    /// The full name of the Google Cloud Platform resource the Data Catalog
    /// entry represents. See:
    /// https://cloud.google.com/apis/design/resource_names#full_resource_name.
    /// Full names are case-sensitive.
    ///
    /// Examples:
    ///
    ///  * //bigquery.googleapis.com/projects/projectId/datasets/datasetId/tables/tableId
    ///  * //pubsub.googleapis.com/projects/projectId/topics/topicId
    case linkedResource(String)
    /// The SQL name of the entry. SQL names are case-sensitive.
    ///
    /// Examples:
    ///
    ///   * `pubsub.project_id.topic_id`
    ///   * ``pubsub.project_id.`topic.id.with.dots` ``
    ///   * `bigquery.table.project_id.dataset_id.table_id`
    ///   * `bigquery.dataset.project_id.dataset_id`
    ///   * `datacatalog.entry.project_id.location_id.entry_group_id.entry_id`
    ///
    /// `*_id`s shoud satisfy the standard SQL rules for identifiers.
    /// https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical.
    case sqlResource(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_LookupEntryRequest.OneOf_TargetName, rhs: Google_Cloud_Datacatalog_V1_LookupEntryRequest.OneOf_TargetName) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.linkedResource, .linkedResource): return {
        guard case .linkedResource(let l) = lhs, case .linkedResource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sqlResource, .sqlResource): return {
        guard case .sqlResource(let l) = lhs, case .sqlResource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Entry Metadata.
/// A Data Catalog Entry resource represents another resource in Google
/// Cloud Platform (such as a BigQuery dataset or a Pub/Sub topic) or
/// outside of Google Cloud Platform. Clients can use the `linked_resource` field
/// in the Entry resource to refer to the original resource ID of the source
/// system.
///
/// An Entry resource contains resource details, such as its schema. An Entry can
/// also be used to attach flexible metadata, such as a
/// [Tag][google.cloud.datacatalog.v1.Tag].
public struct Google_Cloud_Datacatalog_V1_Entry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Data Catalog resource name of the entry in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}/entries/{entry_id}
  ///
  /// Note that this Entry and its child resources may not actually be stored in
  /// the location in this name.
  public var name: String = String()

  /// The resource this metadata entry refers to.
  ///
  /// For Google Cloud Platform resources, `linked_resource` is the [full name of
  /// the
  /// resource](https://cloud.google.com/apis/design/resource_names#full_resource_name).
  /// For example, the `linked_resource` for a table resource from BigQuery is:
  ///
  /// * //bigquery.googleapis.com/projects/projectId/datasets/datasetId/tables/tableId
  ///
  /// Output only when Entry is of type in the EntryType enum. For entries with
  /// user_specified_type, this field is optional and defaults to an empty
  /// string.
  public var linkedResource: String = String()

  /// Required. Entry type.
  public var entryType: Google_Cloud_Datacatalog_V1_Entry.OneOf_EntryType? = nil

  /// The type of the entry.
  /// Only used for Entries with types in the EntryType enum.
  public var type: Google_Cloud_Datacatalog_V1_EntryType {
    get {
      if case .type(let v)? = entryType {return v}
      return .unspecified
    }
    set {entryType = .type(newValue)}
  }

  /// Entry type if it does not fit any of the input-allowed values listed in
  /// `EntryType` enum above. When creating an entry, users should check the
  /// enum values first, if nothing matches the entry to be created, then
  /// provide a custom value, for example "my_special_type".
  /// `user_specified_type` strings must begin with a letter or underscore and
  /// can only contain letters, numbers, and underscores; are case insensitive;
  /// must be at least 1 character and at most 64 characters long.
  ///
  /// Currently, only FILESET enum value is allowed. All other entries created
  /// through Data Catalog must use `user_specified_type`.
  public var userSpecifiedType: String {
    get {
      if case .userSpecifiedType(let v)? = entryType {return v}
      return String()
    }
    set {entryType = .userSpecifiedType(newValue)}
  }

  /// The source system of the entry.
  public var system: Google_Cloud_Datacatalog_V1_Entry.OneOf_System? = nil

  /// Output only. This field indicates the entry's source system that Data
  /// Catalog integrates with, such as BigQuery or Pub/Sub.
  public var integratedSystem: Google_Cloud_Datacatalog_V1_IntegratedSystem {
    get {
      if case .integratedSystem(let v)? = system {return v}
      return .unspecified
    }
    set {system = .integratedSystem(newValue)}
  }

  /// This field indicates the entry's source system that Data Catalog does not
  /// integrate with. `user_specified_system` strings must begin with a letter
  /// or underscore and can only contain letters, numbers, and underscores; are
  /// case insensitive; must be at least 1 character and at most 64 characters
  /// long.
  public var userSpecifiedSystem: String {
    get {
      if case .userSpecifiedSystem(let v)? = system {return v}
      return String()
    }
    set {system = .userSpecifiedSystem(newValue)}
  }

  /// Type specification information.
  public var typeSpec: Google_Cloud_Datacatalog_V1_Entry.OneOf_TypeSpec? = nil

  /// Specification that applies to a Cloud Storage fileset. This is only valid
  /// on entries of type FILESET.
  public var gcsFilesetSpec: Google_Cloud_Datacatalog_V1_GcsFilesetSpec {
    get {
      if case .gcsFilesetSpec(let v)? = typeSpec {return v}
      return Google_Cloud_Datacatalog_V1_GcsFilesetSpec()
    }
    set {typeSpec = .gcsFilesetSpec(newValue)}
  }

  /// Specification that applies to a BigQuery table. This is only valid on
  /// entries of type `TABLE`.
  public var bigqueryTableSpec: Google_Cloud_Datacatalog_V1_BigQueryTableSpec {
    get {
      if case .bigqueryTableSpec(let v)? = typeSpec {return v}
      return Google_Cloud_Datacatalog_V1_BigQueryTableSpec()
    }
    set {typeSpec = .bigqueryTableSpec(newValue)}
  }

  /// Specification for a group of BigQuery tables with name pattern
  /// `[prefix]YYYYMMDD`. Context:
  /// https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding.
  public var bigqueryDateShardedSpec: Google_Cloud_Datacatalog_V1_BigQueryDateShardedSpec {
    get {
      if case .bigqueryDateShardedSpec(let v)? = typeSpec {return v}
      return Google_Cloud_Datacatalog_V1_BigQueryDateShardedSpec()
    }
    set {typeSpec = .bigqueryDateShardedSpec(newValue)}
  }

  /// Display information such as title and description. A short name to identify
  /// the entry, for example, "Analytics Data - Jan 2011". Default value is an
  /// empty string.
  public var displayName: String = String()

  /// Entry description, which can consist of several sentences or paragraphs
  /// that describe entry contents. Default value is an empty string.
  public var description_p: String = String()

  /// Schema of the entry. An entry might not have any schema attached to it.
  public var schema: Google_Cloud_Datacatalog_V1_Schema {
    get {return _schema ?? Google_Cloud_Datacatalog_V1_Schema()}
    set {_schema = newValue}
  }
  /// Returns true if `schema` has been explicitly set.
  public var hasSchema: Bool {return self._schema != nil}
  /// Clears the value of `schema`. Subsequent reads from it will return its default value.
  public mutating func clearSchema() {self._schema = nil}

  /// Timestamps about the underlying resource, not about this Data Catalog
  /// entry. Output only when Entry is of type in the EntryType enum. For entries
  /// with user_specified_type, this field is optional and defaults to an empty
  /// timestamp.
  public var sourceSystemTimestamps: Google_Cloud_Datacatalog_V1_SystemTimestamps {
    get {return _sourceSystemTimestamps ?? Google_Cloud_Datacatalog_V1_SystemTimestamps()}
    set {_sourceSystemTimestamps = newValue}
  }
  /// Returns true if `sourceSystemTimestamps` has been explicitly set.
  public var hasSourceSystemTimestamps: Bool {return self._sourceSystemTimestamps != nil}
  /// Clears the value of `sourceSystemTimestamps`. Subsequent reads from it will return its default value.
  public mutating func clearSourceSystemTimestamps() {self._sourceSystemTimestamps = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Entry type.
  public enum OneOf_EntryType: Equatable {
    /// The type of the entry.
    /// Only used for Entries with types in the EntryType enum.
    case type(Google_Cloud_Datacatalog_V1_EntryType)
    /// Entry type if it does not fit any of the input-allowed values listed in
    /// `EntryType` enum above. When creating an entry, users should check the
    /// enum values first, if nothing matches the entry to be created, then
    /// provide a custom value, for example "my_special_type".
    /// `user_specified_type` strings must begin with a letter or underscore and
    /// can only contain letters, numbers, and underscores; are case insensitive;
    /// must be at least 1 character and at most 64 characters long.
    ///
    /// Currently, only FILESET enum value is allowed. All other entries created
    /// through Data Catalog must use `user_specified_type`.
    case userSpecifiedType(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_Entry.OneOf_EntryType, rhs: Google_Cloud_Datacatalog_V1_Entry.OneOf_EntryType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.type, .type): return {
        guard case .type(let l) = lhs, case .type(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userSpecifiedType, .userSpecifiedType): return {
        guard case .userSpecifiedType(let l) = lhs, case .userSpecifiedType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The source system of the entry.
  public enum OneOf_System: Equatable {
    /// Output only. This field indicates the entry's source system that Data
    /// Catalog integrates with, such as BigQuery or Pub/Sub.
    case integratedSystem(Google_Cloud_Datacatalog_V1_IntegratedSystem)
    /// This field indicates the entry's source system that Data Catalog does not
    /// integrate with. `user_specified_system` strings must begin with a letter
    /// or underscore and can only contain letters, numbers, and underscores; are
    /// case insensitive; must be at least 1 character and at most 64 characters
    /// long.
    case userSpecifiedSystem(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_Entry.OneOf_System, rhs: Google_Cloud_Datacatalog_V1_Entry.OneOf_System) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.integratedSystem, .integratedSystem): return {
        guard case .integratedSystem(let l) = lhs, case .integratedSystem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userSpecifiedSystem, .userSpecifiedSystem): return {
        guard case .userSpecifiedSystem(let l) = lhs, case .userSpecifiedSystem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Type specification information.
  public enum OneOf_TypeSpec: Equatable {
    /// Specification that applies to a Cloud Storage fileset. This is only valid
    /// on entries of type FILESET.
    case gcsFilesetSpec(Google_Cloud_Datacatalog_V1_GcsFilesetSpec)
    /// Specification that applies to a BigQuery table. This is only valid on
    /// entries of type `TABLE`.
    case bigqueryTableSpec(Google_Cloud_Datacatalog_V1_BigQueryTableSpec)
    /// Specification for a group of BigQuery tables with name pattern
    /// `[prefix]YYYYMMDD`. Context:
    /// https://cloud.google.com/bigquery/docs/partitioned-tables#partitioning_versus_sharding.
    case bigqueryDateShardedSpec(Google_Cloud_Datacatalog_V1_BigQueryDateShardedSpec)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1_Entry.OneOf_TypeSpec, rhs: Google_Cloud_Datacatalog_V1_Entry.OneOf_TypeSpec) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsFilesetSpec, .gcsFilesetSpec): return {
        guard case .gcsFilesetSpec(let l) = lhs, case .gcsFilesetSpec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigqueryTableSpec, .bigqueryTableSpec): return {
        guard case .bigqueryTableSpec(let l) = lhs, case .bigqueryTableSpec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigqueryDateShardedSpec, .bigqueryDateShardedSpec): return {
        guard case .bigqueryDateShardedSpec(let l) = lhs, case .bigqueryDateShardedSpec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _schema: Google_Cloud_Datacatalog_V1_Schema? = nil
  fileprivate var _sourceSystemTimestamps: Google_Cloud_Datacatalog_V1_SystemTimestamps? = nil
}

/// EntryGroup Metadata.
/// An EntryGroup resource represents a logical grouping of zero or more
/// Data Catalog [Entry][google.cloud.datacatalog.v1.Entry] resources.
public struct Google_Cloud_Datacatalog_V1_EntryGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the entry group in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}
  ///
  /// Note that this EntryGroup and its child resources may not actually be
  /// stored in the location in this name.
  public var name: String = String()

  /// A short name to identify the entry group, for example,
  /// "analytics data - jan 2011". Default value is an empty string.
  public var displayName: String = String()

  /// Entry group description, which can consist of several sentences or
  /// paragraphs that describe entry group contents. Default value is an empty
  /// string.
  public var description_p: String = String()

  /// Output only. Timestamps about this EntryGroup. Default value is empty
  /// timestamps.
  public var dataCatalogTimestamps: Google_Cloud_Datacatalog_V1_SystemTimestamps {
    get {return _dataCatalogTimestamps ?? Google_Cloud_Datacatalog_V1_SystemTimestamps()}
    set {_dataCatalogTimestamps = newValue}
  }
  /// Returns true if `dataCatalogTimestamps` has been explicitly set.
  public var hasDataCatalogTimestamps: Bool {return self._dataCatalogTimestamps != nil}
  /// Clears the value of `dataCatalogTimestamps`. Subsequent reads from it will return its default value.
  public mutating func clearDataCatalogTimestamps() {self._dataCatalogTimestamps = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dataCatalogTimestamps: Google_Cloud_Datacatalog_V1_SystemTimestamps? = nil
}

/// Request message for
/// [CreateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplate].
public struct Google_Cloud_Datacatalog_V1_CreateTagTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project and the template location
  /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
  ///
  /// Example:
  ///
  /// * projects/{project_id}/locations/us-central1
  public var parent: String = String()

  /// Required. The id of the tag template to create.
  public var tagTemplateID: String = String()

  /// Required. The tag template to create.
  public var tagTemplate: Google_Cloud_Datacatalog_V1_TagTemplate {
    get {return _tagTemplate ?? Google_Cloud_Datacatalog_V1_TagTemplate()}
    set {_tagTemplate = newValue}
  }
  /// Returns true if `tagTemplate` has been explicitly set.
  public var hasTagTemplate: Bool {return self._tagTemplate != nil}
  /// Clears the value of `tagTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearTagTemplate() {self._tagTemplate = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tagTemplate: Google_Cloud_Datacatalog_V1_TagTemplate? = nil
}

/// Request message for
/// [GetTagTemplate][google.cloud.datacatalog.v1.DataCatalog.GetTagTemplate].
public struct Google_Cloud_Datacatalog_V1_GetTagTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the tag template. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [UpdateTagTemplate][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplate].
public struct Google_Cloud_Datacatalog_V1_UpdateTagTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The template to update. The "name" field must be set.
  public var tagTemplate: Google_Cloud_Datacatalog_V1_TagTemplate {
    get {return _tagTemplate ?? Google_Cloud_Datacatalog_V1_TagTemplate()}
    set {_tagTemplate = newValue}
  }
  /// Returns true if `tagTemplate` has been explicitly set.
  public var hasTagTemplate: Bool {return self._tagTemplate != nil}
  /// Clears the value of `tagTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearTagTemplate() {self._tagTemplate = nil}

  /// The field mask specifies the parts of the template to overwrite.
  ///
  /// Allowed fields:
  ///
  ///   * `display_name`
  ///
  /// If absent or empty, all of the allowed fields above will be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tagTemplate: Google_Cloud_Datacatalog_V1_TagTemplate? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// [DeleteTagTemplate][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplate].
public struct Google_Cloud_Datacatalog_V1_DeleteTagTemplateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the tag template to delete. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}
  public var name: String = String()

  /// Required. Currently, this field must always be set to `true`.
  /// This confirms the deletion of any possible tags using this template.
  /// `force = false` will be supported in the future.
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [CreateTag][google.cloud.datacatalog.v1.DataCatalog.CreateTag].
public struct Google_Cloud_Datacatalog_V1_CreateTagRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the resource to attach this tag to. Tags can be
  /// attached to Entries. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}/entries/{entry_id}
  ///
  /// Note that this Tag and its child resources may not actually be stored in
  /// the location in this name.
  public var parent: String = String()

  /// Required. The tag to create.
  public var tag: Google_Cloud_Datacatalog_V1_Tag {
    get {return _tag ?? Google_Cloud_Datacatalog_V1_Tag()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {self._tag = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tag: Google_Cloud_Datacatalog_V1_Tag? = nil
}

/// Request message for
/// [UpdateTag][google.cloud.datacatalog.v1.DataCatalog.UpdateTag].
public struct Google_Cloud_Datacatalog_V1_UpdateTagRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The updated tag. The "name" field must be set.
  public var tag: Google_Cloud_Datacatalog_V1_Tag {
    get {return _tag ?? Google_Cloud_Datacatalog_V1_Tag()}
    set {_tag = newValue}
  }
  /// Returns true if `tag` has been explicitly set.
  public var hasTag: Bool {return self._tag != nil}
  /// Clears the value of `tag`. Subsequent reads from it will return its default value.
  public mutating func clearTag() {self._tag = nil}

  /// The fields to update on the Tag. If absent or empty, all modifiable fields
  /// are updated. Currently the only modifiable field is the field `fields`.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tag: Google_Cloud_Datacatalog_V1_Tag? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// [DeleteTag][google.cloud.datacatalog.v1.DataCatalog.DeleteTag].
public struct Google_Cloud_Datacatalog_V1_DeleteTagRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the tag to delete. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}/entries/{entry_id}/tags/{tag_id}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [CreateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.CreateTagTemplateField].
public struct Google_Cloud_Datacatalog_V1_CreateTagTemplateFieldRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project and the template location
  /// [region](https://cloud.google.com/data-catalog/docs/concepts/regions).
  ///
  /// Example:
  ///
  /// * projects/{project_id}/locations/us-central1/tagTemplates/{tag_template_id}
  public var parent: String = String()

  /// Required. The ID of the tag template field to create.
  /// Field ids can contain letters (both uppercase and lowercase), numbers
  /// (0-9), underscores (_) and dashes (-). Field IDs must be at least 1
  /// character long and at most 128 characters long. Field IDs must also be
  /// unique within their template.
  public var tagTemplateFieldID: String = String()

  /// Required. The tag template field to create.
  public var tagTemplateField: Google_Cloud_Datacatalog_V1_TagTemplateField {
    get {return _tagTemplateField ?? Google_Cloud_Datacatalog_V1_TagTemplateField()}
    set {_tagTemplateField = newValue}
  }
  /// Returns true if `tagTemplateField` has been explicitly set.
  public var hasTagTemplateField: Bool {return self._tagTemplateField != nil}
  /// Clears the value of `tagTemplateField`. Subsequent reads from it will return its default value.
  public mutating func clearTagTemplateField() {self._tagTemplateField = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tagTemplateField: Google_Cloud_Datacatalog_V1_TagTemplateField? = nil
}

/// Request message for
/// [UpdateTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.UpdateTagTemplateField].
public struct Google_Cloud_Datacatalog_V1_UpdateTagTemplateFieldRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the tag template field. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}/fields/{tag_template_field_id}
  public var name: String = String()

  /// Required. The template to update.
  public var tagTemplateField: Google_Cloud_Datacatalog_V1_TagTemplateField {
    get {return _tagTemplateField ?? Google_Cloud_Datacatalog_V1_TagTemplateField()}
    set {_tagTemplateField = newValue}
  }
  /// Returns true if `tagTemplateField` has been explicitly set.
  public var hasTagTemplateField: Bool {return self._tagTemplateField != nil}
  /// Clears the value of `tagTemplateField`. Subsequent reads from it will return its default value.
  public mutating func clearTagTemplateField() {self._tagTemplateField = nil}

  /// Optional. The field mask specifies the parts of the template to be updated.
  /// Allowed fields:
  ///
  ///   * `display_name`
  ///   * `type.enum_type`
  ///   * `is_required`
  ///
  /// If `update_mask` is not set or empty, all of the allowed fields above will
  /// be updated.
  ///
  /// When updating an enum type, the provided values will be merged with the
  /// existing values. Therefore, enum values can only be added, existing enum
  /// values cannot be deleted nor renamed. Updating a template field from
  /// optional to required is NOT allowed.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tagTemplateField: Google_Cloud_Datacatalog_V1_TagTemplateField? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for
/// [RenameTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.RenameTagTemplateField].
public struct Google_Cloud_Datacatalog_V1_RenameTagTemplateFieldRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the tag template. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}/fields/{tag_template_field_id}
  public var name: String = String()

  /// Required. The new ID of this tag template field. For example,
  /// `my_new_field`.
  public var newTagTemplateFieldID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [DeleteTagTemplateField][google.cloud.datacatalog.v1.DataCatalog.DeleteTagTemplateField].
public struct Google_Cloud_Datacatalog_V1_DeleteTagTemplateFieldRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the tag template field to delete. Example:
  ///
  /// * projects/{project_id}/locations/{location}/tagTemplates/{tag_template_id}/fields/{tag_template_field_id}
  public var name: String = String()

  /// Required. Currently, this field must always be set to `true`.
  /// This confirms the deletion of this field from any tags using this field.
  /// `force = false` will be supported in the future.
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
public struct Google_Cloud_Datacatalog_V1_ListTagsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Data Catalog resource to list the tags of. The
  /// resource could be an [Entry][google.cloud.datacatalog.v1.Entry] or an
  /// [EntryGroup][google.cloud.datacatalog.v1.EntryGroup].
  ///
  /// Examples:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}/entries/{entry_id}
  public var parent: String = String()

  /// The maximum number of tags to return. Default is 10. Max limit is 1000.
  public var pageSize: Int32 = 0

  /// Token that specifies which page is requested. If empty, the first page is
  /// returned.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [ListTags][google.cloud.datacatalog.v1.DataCatalog.ListTags].
public struct Google_Cloud_Datacatalog_V1_ListTagsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Tag][google.cloud.datacatalog.v1.Tag] details.
  public var tags: [Google_Cloud_Datacatalog_V1_Tag] = []

  /// Token to retrieve the next page of results. It is set to empty if no items
  /// remain in results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
public struct Google_Cloud_Datacatalog_V1_ListEntriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the entry group that contains the entries, which can
  /// be provided in URL format. Example:
  ///
  /// * projects/{project_id}/locations/{location}/entryGroups/{entry_group_id}
  public var parent: String = String()

  /// The maximum number of items to return. Default is 10. Max limit is 1000.
  /// Throws an invalid argument for `page_size > 1000`.
  public var pageSize: Int32 = 0

  /// Token that specifies which page is requested. If empty, the first page is
  /// returned.
  public var pageToken: String = String()

  /// The fields to return for each Entry. If not set or empty, all
  /// fields are returned.
  /// For example, setting read_mask to contain only one path "name" will cause
  /// ListEntries to return a list of Entries with only "name" field.
  public var readMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _readMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_readMask = newValue}
  }
  /// Returns true if `readMask` has been explicitly set.
  public var hasReadMask: Bool {return self._readMask != nil}
  /// Clears the value of `readMask`. Subsequent reads from it will return its default value.
  public mutating func clearReadMask() {self._readMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Response message for
/// [ListEntries][google.cloud.datacatalog.v1.DataCatalog.ListEntries].
public struct Google_Cloud_Datacatalog_V1_ListEntriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Entry details.
  public var entries: [Google_Cloud_Datacatalog_V1_Entry] = []

  /// Token to retrieve the next page of results. It is set to empty if no items
  /// remain in results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datacatalog.v1"

extension Google_Cloud_Datacatalog_V1_EntryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENTRY_TYPE_UNSPECIFIED"),
    2: .same(proto: "TABLE"),
    3: .same(proto: "DATA_STREAM"),
    4: .same(proto: "FILESET"),
    5: .same(proto: "MODEL"),
  ]
}

extension Google_Cloud_Datacatalog_V1_SearchCatalogRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchCatalogRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "scope"),
    1: .same(proto: "query"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    5: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._scope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 5)
    }
    if let v = self._scope {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_SearchCatalogRequest, rhs: Google_Cloud_Datacatalog_V1_SearchCatalogRequest) -> Bool {
    if lhs._scope != rhs._scope {return false}
    if lhs.query != rhs.query {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_SearchCatalogRequest.Scope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Datacatalog_V1_SearchCatalogRequest.protoMessageName + ".Scope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "include_org_ids"),
    3: .standard(proto: "include_project_ids"),
    7: .standard(proto: "include_gcp_public_datasets"),
    16: .standard(proto: "restricted_locations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.includeOrgIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.includeProjectIds) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.includeGcpPublicDatasets) }()
      case 16: try { try decoder.decodeRepeatedStringField(value: &self.restrictedLocations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.includeOrgIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includeOrgIds, fieldNumber: 2)
    }
    if !self.includeProjectIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includeProjectIds, fieldNumber: 3)
    }
    if self.includeGcpPublicDatasets != false {
      try visitor.visitSingularBoolField(value: self.includeGcpPublicDatasets, fieldNumber: 7)
    }
    if !self.restrictedLocations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.restrictedLocations, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_SearchCatalogRequest.Scope, rhs: Google_Cloud_Datacatalog_V1_SearchCatalogRequest.Scope) -> Bool {
    if lhs.includeOrgIds != rhs.includeOrgIds {return false}
    if lhs.includeProjectIds != rhs.includeProjectIds {return false}
    if lhs.includeGcpPublicDatasets != rhs.includeGcpPublicDatasets {return false}
    if lhs.restrictedLocations != rhs.restrictedLocations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_SearchCatalogResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchCatalogResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    3: .standard(proto: "next_page_token"),
    6: .same(proto: "unreachable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.unreachable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.unreachable.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unreachable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_SearchCatalogResponse, rhs: Google_Cloud_Datacatalog_V1_SearchCatalogResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unreachable != rhs.unreachable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_CreateEntryGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEntryGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    3: .standard(proto: "entry_group_id"),
    2: .standard(proto: "entry_group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._entryGroup) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.entryGroupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._entryGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.entryGroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.entryGroupID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_CreateEntryGroupRequest, rhs: Google_Cloud_Datacatalog_V1_CreateEntryGroupRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.entryGroupID != rhs.entryGroupID {return false}
    if lhs._entryGroup != rhs._entryGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_UpdateEntryGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEntryGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_group"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._entryGroup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._entryGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_UpdateEntryGroupRequest, rhs: Google_Cloud_Datacatalog_V1_UpdateEntryGroupRequest) -> Bool {
    if lhs._entryGroup != rhs._entryGroup {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_GetEntryGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEntryGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "read_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._readMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._readMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_GetEntryGroupRequest, rhs: Google_Cloud_Datacatalog_V1_GetEntryGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._readMask != rhs._readMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_DeleteEntryGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteEntryGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_DeleteEntryGroupRequest, rhs: Google_Cloud_Datacatalog_V1_DeleteEntryGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_ListEntryGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEntryGroupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_ListEntryGroupsRequest, rhs: Google_Cloud_Datacatalog_V1_ListEntryGroupsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_ListEntryGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEntryGroupsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "entry_groups"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entryGroups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entryGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entryGroups, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_ListEntryGroupsResponse, rhs: Google_Cloud_Datacatalog_V1_ListEntryGroupsResponse) -> Bool {
    if lhs.entryGroups != rhs.entryGroups {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_CreateEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateEntryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    3: .standard(proto: "entry_id"),
    2: .same(proto: "entry"),
  ]

  fileprivate class _StorageClass {
    var _parent: String = String()
    var _entryID: String = String()
    var _entry: Google_Cloud_Datacatalog_V1_Entry? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _parent = source._parent
      _entryID = source._entryID
      _entry = source._entry
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._entry) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._entryID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 1)
      }
      if let v = _storage._entry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._entryID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entryID, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_CreateEntryRequest, rhs: Google_Cloud_Datacatalog_V1_CreateEntryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._entryID != rhs_storage._entryID {return false}
        if _storage._entry != rhs_storage._entry {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_UpdateEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEntryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entry"),
    2: .standard(proto: "update_mask"),
  ]

  fileprivate class _StorageClass {
    var _entry: Google_Cloud_Datacatalog_V1_Entry? = nil
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _entry = source._entry
      _updateMask = source._updateMask
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._entry) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._entry {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_UpdateEntryRequest, rhs: Google_Cloud_Datacatalog_V1_UpdateEntryRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._entry != rhs_storage._entry {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_DeleteEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteEntryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_DeleteEntryRequest, rhs: Google_Cloud_Datacatalog_V1_DeleteEntryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_GetEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetEntryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_GetEntryRequest, rhs: Google_Cloud_Datacatalog_V1_GetEntryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_LookupEntryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LookupEntryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "linked_resource"),
    3: .standard(proto: "sql_resource"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.targetName != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.targetName = .linkedResource(v)}
      }()
      case 3: try {
        if self.targetName != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.targetName = .sqlResource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.targetName {
    case .linkedResource?: try {
      guard case .linkedResource(let v)? = self.targetName else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .sqlResource?: try {
      guard case .sqlResource(let v)? = self.targetName else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_LookupEntryRequest, rhs: Google_Cloud_Datacatalog_V1_LookupEntryRequest) -> Bool {
    if lhs.targetName != rhs.targetName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    9: .standard(proto: "linked_resource"),
    2: .same(proto: "type"),
    16: .standard(proto: "user_specified_type"),
    17: .standard(proto: "integrated_system"),
    18: .standard(proto: "user_specified_system"),
    6: .standard(proto: "gcs_fileset_spec"),
    12: .standard(proto: "bigquery_table_spec"),
    15: .standard(proto: "bigquery_date_sharded_spec"),
    3: .standard(proto: "display_name"),
    4: .same(proto: "description"),
    5: .same(proto: "schema"),
    7: .standard(proto: "source_system_timestamps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        if self.entryType != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Datacatalog_V1_EntryType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.entryType = .type(v)}
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._schema) }()
      case 6: try {
        var v: Google_Cloud_Datacatalog_V1_GcsFilesetSpec?
        if let current = self.typeSpec {
          try decoder.handleConflictingOneOf()
          if case .gcsFilesetSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.typeSpec = .gcsFilesetSpec(v)}
      }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._sourceSystemTimestamps) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.linkedResource) }()
      case 12: try {
        var v: Google_Cloud_Datacatalog_V1_BigQueryTableSpec?
        if let current = self.typeSpec {
          try decoder.handleConflictingOneOf()
          if case .bigqueryTableSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.typeSpec = .bigqueryTableSpec(v)}
      }()
      case 15: try {
        var v: Google_Cloud_Datacatalog_V1_BigQueryDateShardedSpec?
        if let current = self.typeSpec {
          try decoder.handleConflictingOneOf()
          if case .bigqueryDateShardedSpec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.typeSpec = .bigqueryDateShardedSpec(v)}
      }()
      case 16: try {
        if self.entryType != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.entryType = .userSpecifiedType(v)}
      }()
      case 17: try {
        if self.system != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Datacatalog_V1_IntegratedSystem?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.system = .integratedSystem(v)}
      }()
      case 18: try {
        if self.system != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.system = .userSpecifiedSystem(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if case .type(let v)? = self.entryType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if let v = self._schema {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if case .gcsFilesetSpec(let v)? = self.typeSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._sourceSystemTimestamps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.linkedResource.isEmpty {
      try visitor.visitSingularStringField(value: self.linkedResource, fieldNumber: 9)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.typeSpec {
    case .bigqueryTableSpec?: try {
      guard case .bigqueryTableSpec(let v)? = self.typeSpec else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .bigqueryDateShardedSpec?: try {
      guard case .bigqueryDateShardedSpec(let v)? = self.typeSpec else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    default: break
    }
    if case .userSpecifiedType(let v)? = self.entryType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 16)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.system {
    case .integratedSystem?: try {
      guard case .integratedSystem(let v)? = self.system else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 17)
    }()
    case .userSpecifiedSystem?: try {
      guard case .userSpecifiedSystem(let v)? = self.system else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_Entry, rhs: Google_Cloud_Datacatalog_V1_Entry) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.linkedResource != rhs.linkedResource {return false}
    if lhs.entryType != rhs.entryType {return false}
    if lhs.system != rhs.system {return false}
    if lhs.typeSpec != rhs.typeSpec {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._schema != rhs._schema {return false}
    if lhs._sourceSystemTimestamps != rhs._sourceSystemTimestamps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_EntryGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntryGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "data_catalog_timestamps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._dataCatalogTimestamps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if let v = self._dataCatalogTimestamps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_EntryGroup, rhs: Google_Cloud_Datacatalog_V1_EntryGroup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._dataCatalogTimestamps != rhs._dataCatalogTimestamps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_CreateTagTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTagTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    3: .standard(proto: "tag_template_id"),
    2: .standard(proto: "tag_template"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tagTemplate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.tagTemplateID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._tagTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.tagTemplateID.isEmpty {
      try visitor.visitSingularStringField(value: self.tagTemplateID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_CreateTagTemplateRequest, rhs: Google_Cloud_Datacatalog_V1_CreateTagTemplateRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.tagTemplateID != rhs.tagTemplateID {return false}
    if lhs._tagTemplate != rhs._tagTemplate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_GetTagTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTagTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_GetTagTemplateRequest, rhs: Google_Cloud_Datacatalog_V1_GetTagTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_UpdateTagTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTagTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tag_template"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tagTemplate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tagTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_UpdateTagTemplateRequest, rhs: Google_Cloud_Datacatalog_V1_UpdateTagTemplateRequest) -> Bool {
    if lhs._tagTemplate != rhs._tagTemplate {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_DeleteTagTemplateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTagTemplateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_DeleteTagTemplateRequest, rhs: Google_Cloud_Datacatalog_V1_DeleteTagTemplateRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_CreateTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._tag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_CreateTagRequest, rhs: Google_Cloud_Datacatalog_V1_CreateTagRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._tag != rhs._tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_UpdateTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tag"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tag) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tag {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_UpdateTagRequest, rhs: Google_Cloud_Datacatalog_V1_UpdateTagRequest) -> Bool {
    if lhs._tag != rhs._tag {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_DeleteTagRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTagRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_DeleteTagRequest, rhs: Google_Cloud_Datacatalog_V1_DeleteTagRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_CreateTagTemplateFieldRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTagTemplateFieldRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "tag_template_field_id"),
    3: .standard(proto: "tag_template_field"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tagTemplateFieldID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tagTemplateField) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.tagTemplateFieldID.isEmpty {
      try visitor.visitSingularStringField(value: self.tagTemplateFieldID, fieldNumber: 2)
    }
    if let v = self._tagTemplateField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_CreateTagTemplateFieldRequest, rhs: Google_Cloud_Datacatalog_V1_CreateTagTemplateFieldRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.tagTemplateFieldID != rhs.tagTemplateFieldID {return false}
    if lhs._tagTemplateField != rhs._tagTemplateField {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_UpdateTagTemplateFieldRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTagTemplateFieldRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "tag_template_field"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tagTemplateField) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._tagTemplateField {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_UpdateTagTemplateFieldRequest, rhs: Google_Cloud_Datacatalog_V1_UpdateTagTemplateFieldRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._tagTemplateField != rhs._tagTemplateField {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_RenameTagTemplateFieldRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameTagTemplateFieldRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "new_tag_template_field_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newTagTemplateFieldID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.newTagTemplateFieldID.isEmpty {
      try visitor.visitSingularStringField(value: self.newTagTemplateFieldID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_RenameTagTemplateFieldRequest, rhs: Google_Cloud_Datacatalog_V1_RenameTagTemplateFieldRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.newTagTemplateFieldID != rhs.newTagTemplateFieldID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_DeleteTagTemplateFieldRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTagTemplateFieldRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_DeleteTagTemplateFieldRequest, rhs: Google_Cloud_Datacatalog_V1_DeleteTagTemplateFieldRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_ListTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTagsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_ListTagsRequest, rhs: Google_Cloud_Datacatalog_V1_ListTagsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_ListTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTagsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tags"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tags) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tags, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_ListTagsResponse, rhs: Google_Cloud_Datacatalog_V1_ListTagsResponse) -> Bool {
    if lhs.tags != rhs.tags {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_ListEntriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEntriesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "read_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if let v = self._readMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_ListEntriesRequest, rhs: Google_Cloud_Datacatalog_V1_ListEntriesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs._readMask != rhs._readMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1_ListEntriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListEntriesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1_ListEntriesResponse, rhs: Google_Cloud_Datacatalog_V1_ListEntriesResponse) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

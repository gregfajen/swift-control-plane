// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datacatalog/v1beta1/gcs_fileset_spec.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes a Cloud Storage fileset entry.
public struct Google_Cloud_Datacatalog_V1beta1_GcsFilesetSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Patterns to identify a set of files in Google Cloud Storage.
  /// See [Cloud Storage
  /// documentation](https://cloud.google.com/storage/docs/gsutil/addlhelp/WildcardNames)
  /// for more information. Note that bucket wildcards are currently not
  /// supported.
  ///
  /// Examples of valid file_patterns:
  ///
  ///  * `gs://bucket_name/dir/*`: matches all files within `bucket_name/dir`
  ///                              directory.
  ///  * `gs://bucket_name/dir/**`: matches all files in `bucket_name/dir`
  ///                               spanning all subdirectories.
  ///  * `gs://bucket_name/file*`: matches files prefixed by `file` in
  ///                              `bucket_name`
  ///  * `gs://bucket_name/??.txt`: matches files with two characters followed by
  ///                               `.txt` in `bucket_name`
  ///  * `gs://bucket_name/[aeiou].txt`: matches files that contain a single
  ///                                    vowel character followed by `.txt` in
  ///                                    `bucket_name`
  ///  * `gs://bucket_name/[a-m].txt`: matches files that contain `a`, `b`, ...
  ///                                  or `m` followed by `.txt` in `bucket_name`
  ///  * `gs://bucket_name/a/*/b`: matches all files in `bucket_name` that match
  ///                              `a/*/b` pattern, such as `a/c/b`, `a/d/b`
  ///  * `gs://another_bucket/a.txt`: matches `gs://another_bucket/a.txt`
  ///
  /// You can combine wildcards to provide more powerful matches, for example:
  ///
  ///  * `gs://bucket_name/[a-m]??.j*g`
  public var filePatterns: [String] = []

  /// Output only. Sample files contained in this fileset, not all files contained in this
  /// fileset are represented here.
  public var sampleGcsFileSpecs: [Google_Cloud_Datacatalog_V1beta1_GcsFileSpec] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifications of a single file in Cloud Storage.
public struct Google_Cloud_Datacatalog_V1beta1_GcsFileSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full file path. Example: `gs://bucket_name/a/b.txt`.
  public var filePath: String = String()

  /// Output only. Timestamps about the Cloud Storage file.
  public var gcsTimestamps: Google_Cloud_Datacatalog_V1beta1_SystemTimestamps {
    get {return _gcsTimestamps ?? Google_Cloud_Datacatalog_V1beta1_SystemTimestamps()}
    set {_gcsTimestamps = newValue}
  }
  /// Returns true if `gcsTimestamps` has been explicitly set.
  public var hasGcsTimestamps: Bool {return self._gcsTimestamps != nil}
  /// Clears the value of `gcsTimestamps`. Subsequent reads from it will return its default value.
  public mutating func clearGcsTimestamps() {self._gcsTimestamps = nil}

  /// Output only. The size of the file, in bytes.
  public var sizeBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gcsTimestamps: Google_Cloud_Datacatalog_V1beta1_SystemTimestamps? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datacatalog.v1beta1"

extension Google_Cloud_Datacatalog_V1beta1_GcsFilesetSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsFilesetSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_patterns"),
    2: .standard(proto: "sample_gcs_file_specs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.filePatterns) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sampleGcsFileSpecs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filePatterns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.filePatterns, fieldNumber: 1)
    }
    if !self.sampleGcsFileSpecs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sampleGcsFileSpecs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_GcsFilesetSpec, rhs: Google_Cloud_Datacatalog_V1beta1_GcsFilesetSpec) -> Bool {
    if lhs.filePatterns != rhs.filePatterns {return false}
    if lhs.sampleGcsFileSpecs != rhs.sampleGcsFileSpecs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_GcsFileSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsFileSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_path"),
    2: .standard(proto: "gcs_timestamps"),
    4: .standard(proto: "size_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filePath) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gcsTimestamps) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filePath.isEmpty {
      try visitor.visitSingularStringField(value: self.filePath, fieldNumber: 1)
    }
    if let v = self._gcsTimestamps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_GcsFileSpec, rhs: Google_Cloud_Datacatalog_V1beta1_GcsFileSpec) -> Bool {
    if lhs.filePath != rhs.filePath {return false}
    if lhs._gcsTimestamps != rhs._gcsTimestamps {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

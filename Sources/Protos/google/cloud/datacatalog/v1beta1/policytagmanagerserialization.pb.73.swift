// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/datacatalog/v1beta1/policytagmanagerserialization.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Message capturing a taxonomy and its policy tag hierarchy as a nested proto.
/// Used for taxonomy import/export and mutation.
public struct Google_Cloud_Datacatalog_V1beta1_SerializedTaxonomy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Display name of the taxonomy. Max 200 bytes when encoded in UTF-8.
  public var displayName: String = String()

  /// Description of the serialized taxonomy. The length of the
  /// description is limited to 2000 bytes when encoded in UTF-8. If not set,
  /// defaults to an empty description.
  public var description_p: String = String()

  /// Top level policy tags associated with the taxonomy if any.
  public var policyTags: [Google_Cloud_Datacatalog_V1beta1_SerializedPolicyTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Message representing one policy tag when exported as a nested proto.
public struct Google_Cloud_Datacatalog_V1beta1_SerializedPolicyTag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Display name of the policy tag. Max 200 bytes when encoded in UTF-8.
  public var displayName: String = String()

  /// Description of the serialized policy tag. The length of the
  /// description is limited to 2000 bytes when encoded in UTF-8. If not set,
  /// defaults to an empty description.
  public var description_p: String = String()

  /// Children of the policy tag if any.
  public var childPolicyTags: [Google_Cloud_Datacatalog_V1beta1_SerializedPolicyTag] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1beta1.PolicyTagManagerSerialization.ImportTaxonomies].
public struct Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of project that the newly created taxonomies will
  /// belong to.
  public var parent: String = String()

  /// Required. Source taxonomies to be imported in a tree structure.
  public var source: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest.OneOf_Source? = nil

  /// Inline source used for taxonomies import
  public var inlineSource: Google_Cloud_Datacatalog_V1beta1_InlineSource {
    get {
      if case .inlineSource(let v)? = source {return v}
      return Google_Cloud_Datacatalog_V1beta1_InlineSource()
    }
    set {source = .inlineSource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Source taxonomies to be imported in a tree structure.
  public enum OneOf_Source: Equatable {
    /// Inline source used for taxonomies import
    case inlineSource(Google_Cloud_Datacatalog_V1beta1_InlineSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest.OneOf_Source, rhs: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.inlineSource, .inlineSource): return {
        guard case .inlineSource(let l) = lhs, case .inlineSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Inline source used for taxonomies import.
public struct Google_Cloud_Datacatalog_V1beta1_InlineSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Taxonomies to be imported.
  public var taxonomies: [Google_Cloud_Datacatalog_V1beta1_SerializedTaxonomy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [ImportTaxonomies][google.cloud.datacatalog.v1beta1.PolicyTagManagerSerialization.ImportTaxonomies].
public struct Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Taxonomies that were imported.
  public var taxonomies: [Google_Cloud_Datacatalog_V1beta1_Taxonomy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1beta1.PolicyTagManagerSerialization.ExportTaxonomies].
public struct Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name of the project that taxonomies to be exported
  /// will share.
  public var parent: String = String()

  /// Required. Resource names of the taxonomies to be exported.
  public var taxonomies: [String] = []

  /// Required. Taxonomies export destination.
  public var destination: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest.OneOf_Destination? = nil

  /// Export taxonomies as serialized taxonomies.
  public var serializedTaxonomies: Bool {
    get {
      if case .serializedTaxonomies(let v)? = destination {return v}
      return false
    }
    set {destination = .serializedTaxonomies(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Taxonomies export destination.
  public enum OneOf_Destination: Equatable {
    /// Export taxonomies as serialized taxonomies.
    case serializedTaxonomies(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest.OneOf_Destination, rhs: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.serializedTaxonomies, .serializedTaxonomies): return {
        guard case .serializedTaxonomies(let l) = lhs, case .serializedTaxonomies(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Response message for
/// [ExportTaxonomies][google.cloud.datacatalog.v1beta1.PolicyTagManagerSerialization.ExportTaxonomies].
public struct Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of taxonomies and policy tags in a tree structure.
  public var taxonomies: [Google_Cloud_Datacatalog_V1beta1_SerializedTaxonomy] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.datacatalog.v1beta1"

extension Google_Cloud_Datacatalog_V1beta1_SerializedTaxonomy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SerializedTaxonomy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "description"),
    3: .standard(proto: "policy_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.policyTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.policyTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.policyTags, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_SerializedTaxonomy, rhs: Google_Cloud_Datacatalog_V1beta1_SerializedTaxonomy) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.policyTags != rhs.policyTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_SerializedPolicyTag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SerializedPolicyTag"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "child_policy_tags"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.childPolicyTags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.childPolicyTags.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.childPolicyTags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_SerializedPolicyTag, rhs: Google_Cloud_Datacatalog_V1beta1_SerializedPolicyTag) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.childPolicyTags != rhs.childPolicyTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportTaxonomiesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "inline_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try {
        var v: Google_Cloud_Datacatalog_V1beta1_InlineSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .inlineSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .inlineSource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if case .inlineSource(let v)? = self.source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest, rhs: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_InlineSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InlineSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "taxonomies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taxonomies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taxonomies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taxonomies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_InlineSource, rhs: Google_Cloud_Datacatalog_V1beta1_InlineSource) -> Bool {
    if lhs.taxonomies != rhs.taxonomies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImportTaxonomiesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "taxonomies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taxonomies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taxonomies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taxonomies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesResponse, rhs: Google_Cloud_Datacatalog_V1beta1_ImportTaxonomiesResponse) -> Bool {
    if lhs.taxonomies != rhs.taxonomies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportTaxonomiesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "taxonomies"),
    3: .standard(proto: "serialized_taxonomies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.taxonomies) }()
      case 3: try {
        if self.destination != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.destination = .serializedTaxonomies(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.taxonomies.isEmpty {
      try visitor.visitRepeatedStringField(value: self.taxonomies, fieldNumber: 2)
    }
    if case .serializedTaxonomies(let v)? = self.destination {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest, rhs: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.taxonomies != rhs.taxonomies {return false}
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportTaxonomiesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "taxonomies"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.taxonomies) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taxonomies.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taxonomies, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesResponse, rhs: Google_Cloud_Datacatalog_V1beta1_ExportTaxonomiesResponse) -> Bool {
    if lhs.taxonomies != rhs.taxonomies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

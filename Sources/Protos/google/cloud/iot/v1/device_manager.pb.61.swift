// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/iot/v1/device_manager.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request for `CreateDeviceRegistry`.
public struct Google_Cloud_Iot_V1_CreateDeviceRegistryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project and cloud region where this device registry must be created.
  /// For example, `projects/example-project/locations/us-central1`.
  public var parent: String = String()

  /// Required. The device registry. The field `name` must be empty. The server will
  /// generate that field from the device registry `id` provided and the
  /// `parent` field.
  public var deviceRegistry: Google_Cloud_Iot_V1_DeviceRegistry {
    get {return _deviceRegistry ?? Google_Cloud_Iot_V1_DeviceRegistry()}
    set {_deviceRegistry = newValue}
  }
  /// Returns true if `deviceRegistry` has been explicitly set.
  public var hasDeviceRegistry: Bool {return self._deviceRegistry != nil}
  /// Clears the value of `deviceRegistry`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceRegistry() {self._deviceRegistry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceRegistry: Google_Cloud_Iot_V1_DeviceRegistry? = nil
}

/// Request for `GetDeviceRegistry`.
public struct Google_Cloud_Iot_V1_GetDeviceRegistryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device registry. For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `DeleteDeviceRegistry`.
public struct Google_Cloud_Iot_V1_DeleteDeviceRegistryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device registry. For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `UpdateDeviceRegistry`.
public struct Google_Cloud_Iot_V1_UpdateDeviceRegistryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The new values for the device registry. The `id` field must be empty, and
  /// the `name` field must indicate the path of the resource. For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var deviceRegistry: Google_Cloud_Iot_V1_DeviceRegistry {
    get {return _deviceRegistry ?? Google_Cloud_Iot_V1_DeviceRegistry()}
    set {_deviceRegistry = newValue}
  }
  /// Returns true if `deviceRegistry` has been explicitly set.
  public var hasDeviceRegistry: Bool {return self._deviceRegistry != nil}
  /// Clears the value of `deviceRegistry`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceRegistry() {self._deviceRegistry = nil}

  /// Required. Only updates the `device_registry` fields indicated by this mask.
  /// The field mask must not be empty, and it must not contain fields that
  /// are immutable or only set by the server.
  /// Mutable top-level fields: `event_notification_config`, `http_config`,
  /// `mqtt_config`, and `state_notification_config`.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _deviceRegistry: Google_Cloud_Iot_V1_DeviceRegistry? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for `ListDeviceRegistries`.
public struct Google_Cloud_Iot_V1_ListDeviceRegistriesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project and cloud region path. For example,
  /// `projects/example-project/locations/us-central1`.
  public var parent: String = String()

  /// The maximum number of registries to return in the response. If this value
  /// is zero, the service will select a default size. A call may return fewer
  /// objects than requested. A non-empty `next_page_token` in the response
  /// indicates that more data is available.
  public var pageSize: Int32 = 0

  /// The value returned by the last `ListDeviceRegistriesResponse`; indicates
  /// that this is a continuation of a prior `ListDeviceRegistries` call and
  /// the system should return the next page of data.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for `ListDeviceRegistries`.
public struct Google_Cloud_Iot_V1_ListDeviceRegistriesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The registries that matched the query.
  public var deviceRegistries: [Google_Cloud_Iot_V1_DeviceRegistry] = []

  /// If not empty, indicates that there may be more registries that match the
  /// request; this value should be passed in a new
  /// `ListDeviceRegistriesRequest`.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `CreateDevice`.
public struct Google_Cloud_Iot_V1_CreateDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device registry where this device should be created.
  /// For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var parent: String = String()

  /// Required. The device registration details. The field `name` must be empty. The server
  /// generates `name` from the device registry `id` and the
  /// `parent` field.
  public var device: Google_Cloud_Iot_V1_Device {
    get {return _device ?? Google_Cloud_Iot_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {self._device = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _device: Google_Cloud_Iot_V1_Device? = nil
}

/// Request for `GetDevice`.
public struct Google_Cloud_Iot_V1_GetDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var name: String = String()

  /// The fields of the `Device` resource to be returned in the response. If the
  /// field mask is unset or empty, all fields are returned.
  public var fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldMask = newValue}
  }
  /// Returns true if `fieldMask` has been explicitly set.
  public var hasFieldMask: Bool {return self._fieldMask != nil}
  /// Clears the value of `fieldMask`. Subsequent reads from it will return its default value.
  public mutating func clearFieldMask() {self._fieldMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for `UpdateDevice`.
public struct Google_Cloud_Iot_V1_UpdateDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The new values for the device. The `id` and `num_id` fields must
  /// be empty, and the field `name` must specify the name path. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0`or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var device: Google_Cloud_Iot_V1_Device {
    get {return _device ?? Google_Cloud_Iot_V1_Device()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  public var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  public mutating func clearDevice() {self._device = nil}

  /// Required. Only updates the `device` fields indicated by this mask.
  /// The field mask must not be empty, and it must not contain fields that
  /// are immutable or only set by the server.
  /// Mutable top-level fields: `credentials`, `blocked`, and `metadata`
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _device: Google_Cloud_Iot_V1_Device? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request for `DeleteDevice`.
public struct Google_Cloud_Iot_V1_DeleteDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `ListDevices`.
public struct Google_Cloud_Iot_V1_ListDevicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The device registry path. Required. For example,
  /// `projects/my-project/locations/us-central1/registries/my-registry`.
  public var parent: String = String()

  /// A list of device numeric IDs. If empty, this field is ignored. Maximum
  /// IDs: 10,000.
  public var deviceNumIds: [UInt64] = []

  /// A list of device string IDs. For example, `['device0', 'device12']`.
  /// If empty, this field is ignored. Maximum IDs: 10,000
  public var deviceIds: [String] = []

  /// The fields of the `Device` resource to be returned in the response. The
  /// fields `id` and `num_id` are always returned, along with any
  /// other fields specified.
  public var fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldMask = newValue}
  }
  /// Returns true if `fieldMask` has been explicitly set.
  public var hasFieldMask: Bool {return self._fieldMask != nil}
  /// Clears the value of `fieldMask`. Subsequent reads from it will return its default value.
  public mutating func clearFieldMask() {self._fieldMask = nil}

  /// Options related to gateways.
  public var gatewayListOptions: Google_Cloud_Iot_V1_GatewayListOptions {
    get {return _gatewayListOptions ?? Google_Cloud_Iot_V1_GatewayListOptions()}
    set {_gatewayListOptions = newValue}
  }
  /// Returns true if `gatewayListOptions` has been explicitly set.
  public var hasGatewayListOptions: Bool {return self._gatewayListOptions != nil}
  /// Clears the value of `gatewayListOptions`. Subsequent reads from it will return its default value.
  public mutating func clearGatewayListOptions() {self._gatewayListOptions = nil}

  /// The maximum number of devices to return in the response. If this value
  /// is zero, the service will select a default size. A call may return fewer
  /// objects than requested. A non-empty `next_page_token` in the response
  /// indicates that more data is available.
  public var pageSize: Int32 = 0

  /// The value returned by the last `ListDevicesResponse`; indicates
  /// that this is a continuation of a prior `ListDevices` call and
  /// the system should return the next page of data.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _gatewayListOptions: Google_Cloud_Iot_V1_GatewayListOptions? = nil
}

/// Options for limiting the list based on gateway type and associations.
public struct Google_Cloud_Iot_V1_GatewayListOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If not set, all devices and gateways are returned. If set, the list is
  /// filtered based on gateway type and associations.
  public var filter: Google_Cloud_Iot_V1_GatewayListOptions.OneOf_Filter? = nil

  /// If `GATEWAY` is specified, only gateways are returned. If `NON_GATEWAY`
  /// is specified, only non-gateway devices are returned. If
  /// `GATEWAY_TYPE_UNSPECIFIED` is specified, all devices are returned.
  public var gatewayType: Google_Cloud_Iot_V1_GatewayType {
    get {
      if case .gatewayType(let v)? = filter {return v}
      return .unspecified
    }
    set {filter = .gatewayType(newValue)}
  }

  /// If set, only devices associated with the specified gateway are returned.
  /// The gateway ID can be numeric (`num_id`) or the user-defined string
  /// (`id`). For example, if `123` is specified, only devices bound to the
  /// gateway with `num_id` 123 are returned.
  public var associationsGatewayID: String {
    get {
      if case .associationsGatewayID(let v)? = filter {return v}
      return String()
    }
    set {filter = .associationsGatewayID(newValue)}
  }

  /// If set, returns only the gateways with which the specified device is
  /// associated. The device ID can be numeric (`num_id`) or the user-defined
  /// string (`id`). For example, if `456` is specified, returns only the
  /// gateways to which the device with `num_id` 456 is bound.
  public var associationsDeviceID: String {
    get {
      if case .associationsDeviceID(let v)? = filter {return v}
      return String()
    }
    set {filter = .associationsDeviceID(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If not set, all devices and gateways are returned. If set, the list is
  /// filtered based on gateway type and associations.
  public enum OneOf_Filter: Equatable {
    /// If `GATEWAY` is specified, only gateways are returned. If `NON_GATEWAY`
    /// is specified, only non-gateway devices are returned. If
    /// `GATEWAY_TYPE_UNSPECIFIED` is specified, all devices are returned.
    case gatewayType(Google_Cloud_Iot_V1_GatewayType)
    /// If set, only devices associated with the specified gateway are returned.
    /// The gateway ID can be numeric (`num_id`) or the user-defined string
    /// (`id`). For example, if `123` is specified, only devices bound to the
    /// gateway with `num_id` 123 are returned.
    case associationsGatewayID(String)
    /// If set, returns only the gateways with which the specified device is
    /// associated. The device ID can be numeric (`num_id`) or the user-defined
    /// string (`id`). For example, if `456` is specified, returns only the
    /// gateways to which the device with `num_id` 456 is bound.
    case associationsDeviceID(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Iot_V1_GatewayListOptions.OneOf_Filter, rhs: Google_Cloud_Iot_V1_GatewayListOptions.OneOf_Filter) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gatewayType, .gatewayType): return {
        guard case .gatewayType(let l) = lhs, case .gatewayType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.associationsGatewayID, .associationsGatewayID): return {
        guard case .associationsGatewayID(let l) = lhs, case .associationsGatewayID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.associationsDeviceID, .associationsDeviceID): return {
        guard case .associationsDeviceID(let l) = lhs, case .associationsDeviceID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response for `ListDevices`.
public struct Google_Cloud_Iot_V1_ListDevicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The devices that match the request.
  public var devices: [Google_Cloud_Iot_V1_Device] = []

  /// If not empty, indicates that there may be more devices that match the
  /// request; this value should be passed in a new `ListDevicesRequest`.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `ModifyCloudToDeviceConfig`.
public struct Google_Cloud_Iot_V1_ModifyCloudToDeviceConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var name: String = String()

  /// The version number to update. If this value is zero, it will not check the
  /// version number of the server and will always update the current version;
  /// otherwise, this update will fail if the version number found on the server
  /// does not match this version number. This is used to support multiple
  /// simultaneous updates without losing data.
  public var versionToUpdate: Int64 = 0

  /// Required. The configuration data for the device.
  public var binaryData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `ListDeviceConfigVersions`.
public struct Google_Cloud_Iot_V1_ListDeviceConfigVersionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var name: String = String()

  /// The number of versions to list. Versions are listed in decreasing order of
  /// the version number. The maximum number of versions retained is 10. If this
  /// value is zero, it will return all the versions available.
  public var numVersions: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for `ListDeviceConfigVersions`.
public struct Google_Cloud_Iot_V1_ListDeviceConfigVersionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device configuration for the last few versions. Versions are listed
  /// in decreasing order, starting from the most recent one.
  public var deviceConfigs: [Google_Cloud_Iot_V1_DeviceConfig] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `ListDeviceStates`.
public struct Google_Cloud_Iot_V1_ListDeviceStatesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var name: String = String()

  /// The number of states to list. States are listed in descending order of
  /// update time. The maximum number of states retained is 10. If this
  /// value is zero, it will return all the states available.
  public var numStates: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for `ListDeviceStates`.
public struct Google_Cloud_Iot_V1_ListDeviceStatesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The last few device states. States are listed in descending order of server
  /// update time, starting from the most recent one.
  public var deviceStates: [Google_Cloud_Iot_V1_DeviceState] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `SendCommandToDevice`.
public struct Google_Cloud_Iot_V1_SendCommandToDeviceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the device. For example,
  /// `projects/p0/locations/us-central1/registries/registry0/devices/device0` or
  /// `projects/p0/locations/us-central1/registries/registry0/devices/{num_id}`.
  public var name: String = String()

  /// Required. The command data to send to the device.
  public var binaryData: Data = Data()

  /// Optional subfolder for the command. If empty, the command will be delivered
  /// to the /devices/{device-id}/commands topic, otherwise it will be delivered
  /// to the /devices/{device-id}/commands/{subfolder} topic. Multi-level
  /// subfolders are allowed. This field must not have more than 256 characters,
  /// and must not contain any MQTT wildcards ("+" or "#") or null characters.
  public var subfolder: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for `SendCommandToDevice`.
public struct Google_Cloud_Iot_V1_SendCommandToDeviceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `BindDeviceToGateway`.
public struct Google_Cloud_Iot_V1_BindDeviceToGatewayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the registry. For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var parent: String = String()

  /// Required. The value of `gateway_id` can be either the device numeric ID or the
  /// user-defined device identifier.
  public var gatewayID: String = String()

  /// Required. The device to associate with the specified gateway. The value of
  /// `device_id` can be either the device numeric ID or the user-defined device
  /// identifier.
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for `BindDeviceToGateway`.
public struct Google_Cloud_Iot_V1_BindDeviceToGatewayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request for `UnbindDeviceFromGateway`.
public struct Google_Cloud_Iot_V1_UnbindDeviceFromGatewayRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the registry. For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var parent: String = String()

  /// Required. The value of `gateway_id` can be either the device numeric ID or the
  /// user-defined device identifier.
  public var gatewayID: String = String()

  /// Required. The device to disassociate from the specified gateway. The value of
  /// `device_id` can be either the device numeric ID or the user-defined device
  /// identifier.
  public var deviceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for `UnbindDeviceFromGateway`.
public struct Google_Cloud_Iot_V1_UnbindDeviceFromGatewayResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.iot.v1"

extension Google_Cloud_Iot_V1_CreateDeviceRegistryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDeviceRegistryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "device_registry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deviceRegistry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._deviceRegistry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_CreateDeviceRegistryRequest, rhs: Google_Cloud_Iot_V1_CreateDeviceRegistryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._deviceRegistry != rhs._deviceRegistry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_GetDeviceRegistryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeviceRegistryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_GetDeviceRegistryRequest, rhs: Google_Cloud_Iot_V1_GetDeviceRegistryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_DeleteDeviceRegistryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDeviceRegistryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_DeleteDeviceRegistryRequest, rhs: Google_Cloud_Iot_V1_DeleteDeviceRegistryRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_UpdateDeviceRegistryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeviceRegistryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_registry"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceRegistry) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._deviceRegistry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_UpdateDeviceRegistryRequest, rhs: Google_Cloud_Iot_V1_UpdateDeviceRegistryRequest) -> Bool {
    if lhs._deviceRegistry != rhs._deviceRegistry {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDeviceRegistriesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceRegistriesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDeviceRegistriesRequest, rhs: Google_Cloud_Iot_V1_ListDeviceRegistriesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDeviceRegistriesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceRegistriesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_registries"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deviceRegistries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceRegistries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceRegistries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDeviceRegistriesResponse, rhs: Google_Cloud_Iot_V1_ListDeviceRegistriesResponse) -> Bool {
    if lhs.deviceRegistries != rhs.deviceRegistries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_CreateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "device"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_CreateDeviceRequest, rhs: Google_Cloud_Iot_V1_CreateDeviceRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_GetDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "field_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fieldMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._fieldMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_GetDeviceRequest, rhs: Google_Cloud_Iot_V1_GetDeviceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._fieldMask != rhs._fieldMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_UpdateDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "device"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_UpdateDeviceRequest, rhs: Google_Cloud_Iot_V1_UpdateDeviceRequest) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_DeleteDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_DeleteDeviceRequest, rhs: Google_Cloud_Iot_V1_DeleteDeviceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDevicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDevicesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "device_num_ids"),
    3: .standard(proto: "device_ids"),
    4: .standard(proto: "field_mask"),
    6: .standard(proto: "gateway_list_options"),
    100: .standard(proto: "page_size"),
    101: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.deviceNumIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.deviceIds) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fieldMask) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._gatewayListOptions) }()
      case 100: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.deviceNumIds.isEmpty {
      try visitor.visitPackedUInt64Field(value: self.deviceNumIds, fieldNumber: 2)
    }
    if !self.deviceIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deviceIds, fieldNumber: 3)
    }
    if let v = self._fieldMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._gatewayListOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 100)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDevicesRequest, rhs: Google_Cloud_Iot_V1_ListDevicesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.deviceNumIds != rhs.deviceNumIds {return false}
    if lhs.deviceIds != rhs.deviceIds {return false}
    if lhs._fieldMask != rhs._fieldMask {return false}
    if lhs._gatewayListOptions != rhs._gatewayListOptions {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_GatewayListOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatewayListOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_type"),
    2: .standard(proto: "associations_gateway_id"),
    3: .standard(proto: "associations_device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Iot_V1_GatewayType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.filter = .gatewayType(v)}
      }()
      case 2: try {
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.filter = .associationsGatewayID(v)}
      }()
      case 3: try {
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.filter = .associationsDeviceID(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.filter {
    case .gatewayType?: try {
      guard case .gatewayType(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .associationsGatewayID?: try {
      guard case .associationsGatewayID(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .associationsDeviceID?: try {
      guard case .associationsDeviceID(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_GatewayListOptions, rhs: Google_Cloud_Iot_V1_GatewayListOptions) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDevicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDevicesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "devices"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.devices) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.devices, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDevicesResponse, rhs: Google_Cloud_Iot_V1_ListDevicesResponse) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ModifyCloudToDeviceConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifyCloudToDeviceConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "version_to_update"),
    3: .standard(proto: "binary_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.versionToUpdate) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.binaryData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.versionToUpdate != 0 {
      try visitor.visitSingularInt64Field(value: self.versionToUpdate, fieldNumber: 2)
    }
    if !self.binaryData.isEmpty {
      try visitor.visitSingularBytesField(value: self.binaryData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ModifyCloudToDeviceConfigRequest, rhs: Google_Cloud_Iot_V1_ModifyCloudToDeviceConfigRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.versionToUpdate != rhs.versionToUpdate {return false}
    if lhs.binaryData != rhs.binaryData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDeviceConfigVersionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceConfigVersionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "num_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.numVersions != 0 {
      try visitor.visitSingularInt32Field(value: self.numVersions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDeviceConfigVersionsRequest, rhs: Google_Cloud_Iot_V1_ListDeviceConfigVersionsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.numVersions != rhs.numVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDeviceConfigVersionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceConfigVersionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_configs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deviceConfigs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceConfigs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDeviceConfigVersionsResponse, rhs: Google_Cloud_Iot_V1_ListDeviceConfigVersionsResponse) -> Bool {
    if lhs.deviceConfigs != rhs.deviceConfigs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDeviceStatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceStatesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "num_states"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.numStates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.numStates != 0 {
      try visitor.visitSingularInt32Field(value: self.numStates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDeviceStatesRequest, rhs: Google_Cloud_Iot_V1_ListDeviceStatesRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.numStates != rhs.numStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_ListDeviceStatesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeviceStatesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_states"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.deviceStates) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceStates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deviceStates, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_ListDeviceStatesResponse, rhs: Google_Cloud_Iot_V1_ListDeviceStatesResponse) -> Bool {
    if lhs.deviceStates != rhs.deviceStates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_SendCommandToDeviceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendCommandToDeviceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "binary_data"),
    3: .same(proto: "subfolder"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.binaryData) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subfolder) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.binaryData.isEmpty {
      try visitor.visitSingularBytesField(value: self.binaryData, fieldNumber: 2)
    }
    if !self.subfolder.isEmpty {
      try visitor.visitSingularStringField(value: self.subfolder, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_SendCommandToDeviceRequest, rhs: Google_Cloud_Iot_V1_SendCommandToDeviceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.binaryData != rhs.binaryData {return false}
    if lhs.subfolder != rhs.subfolder {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_SendCommandToDeviceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendCommandToDeviceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_SendCommandToDeviceResponse, rhs: Google_Cloud_Iot_V1_SendCommandToDeviceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_BindDeviceToGatewayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindDeviceToGatewayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "gateway_id"),
    3: .standard(proto: "device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gatewayID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.gatewayID.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayID, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_BindDeviceToGatewayRequest, rhs: Google_Cloud_Iot_V1_BindDeviceToGatewayRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.gatewayID != rhs.gatewayID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_BindDeviceToGatewayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BindDeviceToGatewayResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_BindDeviceToGatewayResponse, rhs: Google_Cloud_Iot_V1_BindDeviceToGatewayResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_UnbindDeviceFromGatewayRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnbindDeviceFromGatewayRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "gateway_id"),
    3: .standard(proto: "device_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gatewayID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.gatewayID.isEmpty {
      try visitor.visitSingularStringField(value: self.gatewayID, fieldNumber: 2)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_UnbindDeviceFromGatewayRequest, rhs: Google_Cloud_Iot_V1_UnbindDeviceFromGatewayRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.gatewayID != rhs.gatewayID {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_UnbindDeviceFromGatewayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnbindDeviceFromGatewayResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_UnbindDeviceFromGatewayResponse, rhs: Google_Cloud_Iot_V1_UnbindDeviceFromGatewayResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

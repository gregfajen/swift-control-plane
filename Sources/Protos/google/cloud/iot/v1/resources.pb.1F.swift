// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/iot/v1/resources.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicates whether an MQTT connection is enabled or disabled. See the field
/// description for details.
public enum Google_Cloud_Iot_V1_MqttState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No MQTT state specified. If not specified, MQTT will be enabled by default.
  case unspecified // = 0

  /// Enables a MQTT connection.
  case mqttEnabled // = 1

  /// Disables a MQTT connection.
  case mqttDisabled // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .mqttEnabled
    case 2: self = .mqttDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .mqttEnabled: return 1
    case .mqttDisabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_MqttState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_MqttState] = [
    .unspecified,
    .mqttEnabled,
    .mqttDisabled,
  ]
}

#endif  // swift(>=4.2)

/// Indicates whether DeviceService (HTTP) is enabled or disabled for the
/// registry. See the field description for details.
public enum Google_Cloud_Iot_V1_HttpState: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No HTTP state specified. If not specified, DeviceService will be
  /// enabled by default.
  case unspecified // = 0

  /// Enables DeviceService (HTTP) service for the registry.
  case httpEnabled // = 1

  /// Disables DeviceService (HTTP) service for the registry.
  case httpDisabled // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .httpEnabled
    case 2: self = .httpDisabled
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .httpEnabled: return 1
    case .httpDisabled: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_HttpState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_HttpState] = [
    .unspecified,
    .httpEnabled,
    .httpDisabled,
  ]
}

#endif  // swift(>=4.2)

/// **Beta Feature**
///
/// The logging verbosity for device activity. Specifies which events should be
/// written to logs. For example, if the LogLevel is ERROR, only events that
/// terminate in errors will be logged. LogLevel is inclusive; enabling INFO
/// logging will also enable ERROR logging.
public enum Google_Cloud_Iot_V1_LogLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No logging specified. If not specified, logging will be disabled.
  case unspecified // = 0

  /// Disables logging.
  case none // = 10

  /// Error events will be logged.
  case error // = 20

  /// Informational events will be logged, such as connections and
  /// disconnections.
  case info // = 30

  /// All events will be logged.
  case debug // = 40
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 10: self = .none
    case 20: self = .error
    case 30: self = .info
    case 40: self = .debug
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .none: return 10
    case .error: return 20
    case .info: return 30
    case .debug: return 40
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_LogLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_LogLevel] = [
    .unspecified,
    .none,
    .error,
    .info,
    .debug,
  ]
}

#endif  // swift(>=4.2)

/// Gateway type.
public enum Google_Cloud_Iot_V1_GatewayType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// If unspecified, the device is considered a non-gateway device.
  case unspecified // = 0

  /// The device is a gateway.
  case gateway // = 1

  /// The device is not a gateway.
  case nonGateway // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .gateway
    case 2: self = .nonGateway
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .gateway: return 1
    case .nonGateway: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_GatewayType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_GatewayType] = [
    .unspecified,
    .gateway,
    .nonGateway,
  ]
}

#endif  // swift(>=4.2)

/// The gateway authorization/authentication method. This setting determines how
/// Cloud IoT Core authorizes/authenticate devices to access the gateway.
public enum Google_Cloud_Iot_V1_GatewayAuthMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No authentication/authorization method specified. No devices are allowed to
  /// access the gateway.
  case unspecified // = 0

  /// The device is authenticated through the gateway association only. Device
  /// credentials are ignored even if provided.
  case associationOnly // = 1

  /// The device is authenticated through its own credentials. Gateway
  /// association is not checked.
  case deviceAuthTokenOnly // = 2

  /// The device is authenticated through both device credentials and gateway
  /// association. The device must be bound to the gateway and must provide its
  /// own credentials.
  case associationAndDeviceAuthToken // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .associationOnly
    case 2: self = .deviceAuthTokenOnly
    case 3: self = .associationAndDeviceAuthToken
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .associationOnly: return 1
    case .deviceAuthTokenOnly: return 2
    case .associationAndDeviceAuthToken: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_GatewayAuthMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_GatewayAuthMethod] = [
    .unspecified,
    .associationOnly,
    .deviceAuthTokenOnly,
    .associationAndDeviceAuthToken,
  ]
}

#endif  // swift(>=4.2)

/// The supported formats for the public key.
public enum Google_Cloud_Iot_V1_PublicKeyCertificateFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The format has not been specified. This is an invalid default value and
  /// must not be used.
  case unspecifiedPublicKeyCertificateFormat // = 0

  /// An X.509v3 certificate ([RFC5280](https://www.ietf.org/rfc/rfc5280.txt)),
  /// encoded in base64, and wrapped by `-----BEGIN CERTIFICATE-----` and
  /// `-----END CERTIFICATE-----`.
  case x509CertificatePem // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedPublicKeyCertificateFormat
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedPublicKeyCertificateFormat
    case 1: self = .x509CertificatePem
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedPublicKeyCertificateFormat: return 0
    case .x509CertificatePem: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_PublicKeyCertificateFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_PublicKeyCertificateFormat] = [
    .unspecifiedPublicKeyCertificateFormat,
    .x509CertificatePem,
  ]
}

#endif  // swift(>=4.2)

/// The supported formats for the public key.
public enum Google_Cloud_Iot_V1_PublicKeyFormat: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The format has not been specified. This is an invalid default value and
  /// must not be used.
  case unspecifiedPublicKeyFormat // = 0

  /// An RSA public key encoded in base64, and wrapped by
  /// `-----BEGIN PUBLIC KEY-----` and `-----END PUBLIC KEY-----`. This can be
  /// used to verify `RS256` signatures in JWT tokens ([RFC7518](
  /// https://www.ietf.org/rfc/rfc7518.txt)).
  case rsaPem // = 3

  /// As RSA_PEM, but wrapped in an X.509v3 certificate ([RFC5280](
  /// https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by
  /// `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
  case rsaX509Pem // = 1

  /// Public key for the ECDSA algorithm using P-256 and SHA-256, encoded in
  /// base64, and wrapped by `-----BEGIN PUBLIC KEY-----` and `-----END
  /// PUBLIC KEY-----`. This can be used to verify JWT tokens with the `ES256`
  /// algorithm ([RFC7518](https://www.ietf.org/rfc/rfc7518.txt)). This curve is
  /// defined in [OpenSSL](https://www.openssl.org/) as the `prime256v1` curve.
  case es256Pem // = 2

  /// As ES256_PEM, but wrapped in an X.509v3 certificate ([RFC5280](
  /// https://www.ietf.org/rfc/rfc5280.txt)), encoded in base64, and wrapped by
  /// `-----BEGIN CERTIFICATE-----` and `-----END CERTIFICATE-----`.
  case es256X509Pem // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedPublicKeyFormat
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedPublicKeyFormat
    case 1: self = .rsaX509Pem
    case 2: self = .es256Pem
    case 3: self = .rsaPem
    case 4: self = .es256X509Pem
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedPublicKeyFormat: return 0
    case .rsaX509Pem: return 1
    case .es256Pem: return 2
    case .rsaPem: return 3
    case .es256X509Pem: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Iot_V1_PublicKeyFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Iot_V1_PublicKeyFormat] = [
    .unspecifiedPublicKeyFormat,
    .rsaPem,
    .rsaX509Pem,
    .es256Pem,
    .es256X509Pem,
  ]
}

#endif  // swift(>=4.2)

/// The device resource.
public struct Google_Cloud_Iot_V1_Device {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user-defined device identifier. The device ID must be unique
  /// within a device registry.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The resource path name. For example,
  /// `projects/p1/locations/us-central1/registries/registry0/devices/dev0` or
  /// `projects/p1/locations/us-central1/registries/registry0/devices/{num_id}`.
  /// When `name` is populated as a response from the service, it always ends
  /// in the device numeric ID.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// [Output only] A server-defined unique numeric ID for the device. This is a
  /// more compact way to identify devices, and it is globally unique.
  public var numID: UInt64 {
    get {return _storage._numID}
    set {_uniqueStorage()._numID = newValue}
  }

  /// The credentials used to authenticate this device. To allow credential
  /// rotation without interruption, multiple device credentials can be bound to
  /// this device. No more than 3 credentials can be bound to a single device at
  /// a time. When new credentials are added to a device, they are verified
  /// against the registry credentials. For details, see the description of the
  /// `DeviceRegistry.credentials` field.
  public var credentials: [Google_Cloud_Iot_V1_DeviceCredential] {
    get {return _storage._credentials}
    set {_uniqueStorage()._credentials = newValue}
  }

  /// [Output only] The last time an MQTT `PINGREQ` was received. This field
  /// applies only to devices connecting through MQTT. MQTT clients usually only
  /// send `PINGREQ` messages if the connection is idle, and no other messages
  /// have been sent. Timestamps are periodically collected and written to
  /// storage; they may be stale by a few minutes.
  public var lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastHeartbeatTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastHeartbeatTime = newValue}
  }
  /// Returns true if `lastHeartbeatTime` has been explicitly set.
  public var hasLastHeartbeatTime: Bool {return _storage._lastHeartbeatTime != nil}
  /// Clears the value of `lastHeartbeatTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastHeartbeatTime() {_uniqueStorage()._lastHeartbeatTime = nil}

  /// [Output only] The last time a telemetry event was received. Timestamps are
  /// periodically collected and written to storage; they may be stale by a few
  /// minutes.
  public var lastEventTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastEventTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastEventTime = newValue}
  }
  /// Returns true if `lastEventTime` has been explicitly set.
  public var hasLastEventTime: Bool {return _storage._lastEventTime != nil}
  /// Clears the value of `lastEventTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastEventTime() {_uniqueStorage()._lastEventTime = nil}

  /// [Output only] The last time a state event was received. Timestamps are
  /// periodically collected and written to storage; they may be stale by a few
  /// minutes.
  public var lastStateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastStateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastStateTime = newValue}
  }
  /// Returns true if `lastStateTime` has been explicitly set.
  public var hasLastStateTime: Bool {return _storage._lastStateTime != nil}
  /// Clears the value of `lastStateTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastStateTime() {_uniqueStorage()._lastStateTime = nil}

  /// [Output only] The last time a cloud-to-device config version acknowledgment
  /// was received from the device. This field is only for configurations
  /// sent through MQTT.
  public var lastConfigAckTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastConfigAckTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastConfigAckTime = newValue}
  }
  /// Returns true if `lastConfigAckTime` has been explicitly set.
  public var hasLastConfigAckTime: Bool {return _storage._lastConfigAckTime != nil}
  /// Clears the value of `lastConfigAckTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastConfigAckTime() {_uniqueStorage()._lastConfigAckTime = nil}

  /// [Output only] The last time a cloud-to-device config version was sent to
  /// the device.
  public var lastConfigSendTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastConfigSendTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastConfigSendTime = newValue}
  }
  /// Returns true if `lastConfigSendTime` has been explicitly set.
  public var hasLastConfigSendTime: Bool {return _storage._lastConfigSendTime != nil}
  /// Clears the value of `lastConfigSendTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastConfigSendTime() {_uniqueStorage()._lastConfigSendTime = nil}

  /// If a device is blocked, connections or requests from this device will fail.
  /// Can be used to temporarily prevent the device from connecting if, for
  /// example, the sensor is generating bad data and needs maintenance.
  public var blocked: Bool {
    get {return _storage._blocked}
    set {_uniqueStorage()._blocked = newValue}
  }

  /// [Output only] The time the most recent error occurred, such as a failure to
  /// publish to Cloud Pub/Sub. This field is the timestamp of
  /// 'last_error_status'.
  public var lastErrorTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastErrorTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastErrorTime = newValue}
  }
  /// Returns true if `lastErrorTime` has been explicitly set.
  public var hasLastErrorTime: Bool {return _storage._lastErrorTime != nil}
  /// Clears the value of `lastErrorTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastErrorTime() {_uniqueStorage()._lastErrorTime = nil}

  /// [Output only] The error message of the most recent error, such as a failure
  /// to publish to Cloud Pub/Sub. 'last_error_time' is the timestamp of this
  /// field. If no errors have occurred, this field has an empty message
  /// and the status code 0 == OK. Otherwise, this field is expected to have a
  /// status code other than OK.
  public var lastErrorStatus: Google_Rpc_Status {
    get {return _storage._lastErrorStatus ?? Google_Rpc_Status()}
    set {_uniqueStorage()._lastErrorStatus = newValue}
  }
  /// Returns true if `lastErrorStatus` has been explicitly set.
  public var hasLastErrorStatus: Bool {return _storage._lastErrorStatus != nil}
  /// Clears the value of `lastErrorStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLastErrorStatus() {_uniqueStorage()._lastErrorStatus = nil}

  /// The most recent device configuration, which is eventually sent from
  /// Cloud IoT Core to the device. If not present on creation, the
  /// configuration will be initialized with an empty payload and version value
  /// of `1`. To update this field after creation, use the
  /// `DeviceManager.ModifyCloudToDeviceConfig` method.
  public var config: Google_Cloud_Iot_V1_DeviceConfig {
    get {return _storage._config ?? Google_Cloud_Iot_V1_DeviceConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {_uniqueStorage()._config = nil}

  /// [Output only] The state most recently received from the device. If no state
  /// has been reported, this field is not present.
  public var state: Google_Cloud_Iot_V1_DeviceState {
    get {return _storage._state ?? Google_Cloud_Iot_V1_DeviceState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {_uniqueStorage()._state = nil}

  /// **Beta Feature**
  ///
  /// The logging verbosity for device activity. If unspecified,
  /// DeviceRegistry.log_level will be used.
  public var logLevel: Google_Cloud_Iot_V1_LogLevel {
    get {return _storage._logLevel}
    set {_uniqueStorage()._logLevel = newValue}
  }

  /// The metadata key-value pairs assigned to the device. This metadata is not
  /// interpreted or indexed by Cloud IoT Core. It can be used to add contextual
  /// information for the device.
  ///
  /// Keys must conform to the regular expression [a-zA-Z][a-zA-Z0-9-_.+~%]+ and
  /// be less than 128 bytes in length.
  ///
  /// Values are free-form strings. Each value must be less than or equal to 32
  /// KB in size.
  ///
  /// The total size of all keys and values must be less than 256 KB, and the
  /// maximum number of key-value pairs is 500.
  public var metadata: Dictionary<String,String> {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// Gateway-related configuration and state.
  public var gatewayConfig: Google_Cloud_Iot_V1_GatewayConfig {
    get {return _storage._gatewayConfig ?? Google_Cloud_Iot_V1_GatewayConfig()}
    set {_uniqueStorage()._gatewayConfig = newValue}
  }
  /// Returns true if `gatewayConfig` has been explicitly set.
  public var hasGatewayConfig: Bool {return _storage._gatewayConfig != nil}
  /// Clears the value of `gatewayConfig`. Subsequent reads from it will return its default value.
  public mutating func clearGatewayConfig() {_uniqueStorage()._gatewayConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Gateway-related configuration and state.
public struct Google_Cloud_Iot_V1_GatewayConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether the device is a gateway.
  public var gatewayType: Google_Cloud_Iot_V1_GatewayType = .unspecified

  /// Indicates how to authorize and/or authenticate devices to access the
  /// gateway.
  public var gatewayAuthMethod: Google_Cloud_Iot_V1_GatewayAuthMethod = .unspecified

  /// [Output only] The ID of the gateway the device accessed most recently.
  public var lastAccessedGatewayID: String = String()

  /// [Output only] The most recent time at which the device accessed the gateway
  /// specified in `last_accessed_gateway`.
  public var lastAccessedGatewayTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastAccessedGatewayTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastAccessedGatewayTime = newValue}
  }
  /// Returns true if `lastAccessedGatewayTime` has been explicitly set.
  public var hasLastAccessedGatewayTime: Bool {return self._lastAccessedGatewayTime != nil}
  /// Clears the value of `lastAccessedGatewayTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastAccessedGatewayTime() {self._lastAccessedGatewayTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastAccessedGatewayTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A container for a group of devices.
public struct Google_Cloud_Iot_V1_DeviceRegistry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier of this device registry. For example, `myRegistry`.
  public var id: String = String()

  /// The resource path name. For example,
  /// `projects/example-project/locations/us-central1/registries/my-registry`.
  public var name: String = String()

  /// The configuration for notification of telemetry events received from the
  /// device. All telemetry events that were successfully published by the
  /// device and acknowledged by Cloud IoT Core are guaranteed to be
  /// delivered to Cloud Pub/Sub. If multiple configurations match a message,
  /// only the first matching configuration is used. If you try to publish a
  /// device telemetry event using MQTT without specifying a Cloud Pub/Sub topic
  /// for the device's registry, the connection closes automatically. If you try
  /// to do so using an HTTP connection, an error is returned. Up to 10
  /// configurations may be provided.
  public var eventNotificationConfigs: [Google_Cloud_Iot_V1_EventNotificationConfig] = []

  /// The configuration for notification of new states received from the device.
  /// State updates are guaranteed to be stored in the state history, but
  /// notifications to Cloud Pub/Sub are not guaranteed. For example, if
  /// permissions are misconfigured or the specified topic doesn't exist, no
  /// notification will be published but the state will still be stored in Cloud
  /// IoT Core.
  public var stateNotificationConfig: Google_Cloud_Iot_V1_StateNotificationConfig {
    get {return _stateNotificationConfig ?? Google_Cloud_Iot_V1_StateNotificationConfig()}
    set {_stateNotificationConfig = newValue}
  }
  /// Returns true if `stateNotificationConfig` has been explicitly set.
  public var hasStateNotificationConfig: Bool {return self._stateNotificationConfig != nil}
  /// Clears the value of `stateNotificationConfig`. Subsequent reads from it will return its default value.
  public mutating func clearStateNotificationConfig() {self._stateNotificationConfig = nil}

  /// The MQTT configuration for this device registry.
  public var mqttConfig: Google_Cloud_Iot_V1_MqttConfig {
    get {return _mqttConfig ?? Google_Cloud_Iot_V1_MqttConfig()}
    set {_mqttConfig = newValue}
  }
  /// Returns true if `mqttConfig` has been explicitly set.
  public var hasMqttConfig: Bool {return self._mqttConfig != nil}
  /// Clears the value of `mqttConfig`. Subsequent reads from it will return its default value.
  public mutating func clearMqttConfig() {self._mqttConfig = nil}

  /// The DeviceService (HTTP) configuration for this device registry.
  public var httpConfig: Google_Cloud_Iot_V1_HttpConfig {
    get {return _httpConfig ?? Google_Cloud_Iot_V1_HttpConfig()}
    set {_httpConfig = newValue}
  }
  /// Returns true if `httpConfig` has been explicitly set.
  public var hasHTTPConfig: Bool {return self._httpConfig != nil}
  /// Clears the value of `httpConfig`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPConfig() {self._httpConfig = nil}

  /// **Beta Feature**
  ///
  /// The default logging verbosity for activity from devices in this registry.
  /// The verbosity level can be overridden by Device.log_level.
  public var logLevel: Google_Cloud_Iot_V1_LogLevel = .unspecified

  /// The credentials used to verify the device credentials. No more than 10
  /// credentials can be bound to a single registry at a time. The verification
  /// process occurs at the time of device creation or update. If this field is
  /// empty, no verification is performed. Otherwise, the credentials of a newly
  /// created device or added credentials of an updated device should be signed
  /// with one of these registry credentials.
  ///
  /// Note, however, that existing devices will never be affected by
  /// modifications to this list of credentials: after a device has been
  /// successfully created in a registry, it should be able to connect even if
  /// its registry credentials are revoked, deleted, or modified.
  public var credentials: [Google_Cloud_Iot_V1_RegistryCredential] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _stateNotificationConfig: Google_Cloud_Iot_V1_StateNotificationConfig? = nil
  fileprivate var _mqttConfig: Google_Cloud_Iot_V1_MqttConfig? = nil
  fileprivate var _httpConfig: Google_Cloud_Iot_V1_HttpConfig? = nil
}

/// The configuration of MQTT for a device registry.
public struct Google_Cloud_Iot_V1_MqttConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If enabled, allows connections using the MQTT protocol. Otherwise, MQTT
  /// connections to this registry will fail.
  public var mqttEnabledState: Google_Cloud_Iot_V1_MqttState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The configuration of the HTTP bridge for a device registry.
public struct Google_Cloud_Iot_V1_HttpConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If enabled, allows devices to use DeviceService via the HTTP protocol.
  /// Otherwise, any requests to DeviceService will fail for this registry.
  public var httpEnabledState: Google_Cloud_Iot_V1_HttpState = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The configuration for forwarding telemetry events.
public struct Google_Cloud_Iot_V1_EventNotificationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If the subfolder name matches this string exactly, this configuration will
  /// be used. The string must not include the leading '/' character. If empty,
  /// all strings are matched. This field is used only for telemetry events;
  /// subfolders are not supported for state changes.
  public var subfolderMatches: String = String()

  /// A Cloud Pub/Sub topic name. For example,
  /// `projects/myProject/topics/deviceEvents`.
  public var pubsubTopicName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The configuration for notification of new states received from the device.
public struct Google_Cloud_Iot_V1_StateNotificationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A Cloud Pub/Sub topic name. For example,
  /// `projects/myProject/topics/deviceEvents`.
  public var pubsubTopicName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A server-stored registry credential used to validate device credentials.
public struct Google_Cloud_Iot_V1_RegistryCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The credential data. Reserved for expansion in the future.
  public var credential: Google_Cloud_Iot_V1_RegistryCredential.OneOf_Credential? = nil

  /// A public key certificate used to verify the device credentials.
  public var publicKeyCertificate: Google_Cloud_Iot_V1_PublicKeyCertificate {
    get {
      if case .publicKeyCertificate(let v)? = credential {return v}
      return Google_Cloud_Iot_V1_PublicKeyCertificate()
    }
    set {credential = .publicKeyCertificate(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The credential data. Reserved for expansion in the future.
  public enum OneOf_Credential: Equatable {
    /// A public key certificate used to verify the device credentials.
    case publicKeyCertificate(Google_Cloud_Iot_V1_PublicKeyCertificate)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Iot_V1_RegistryCredential.OneOf_Credential, rhs: Google_Cloud_Iot_V1_RegistryCredential.OneOf_Credential) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.publicKeyCertificate, .publicKeyCertificate): return {
        guard case .publicKeyCertificate(let l) = lhs, case .publicKeyCertificate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Details of an X.509 certificate. For informational purposes only.
public struct Google_Cloud_Iot_V1_X509CertificateDetails {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The entity that signed the certificate.
  public var issuer: String = String()

  /// The entity the certificate and public key belong to.
  public var subject: String = String()

  /// The time the certificate becomes valid.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time the certificate becomes invalid.
  public var expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiryTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  public var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpiryTime() {self._expiryTime = nil}

  /// The algorithm used to sign the certificate.
  public var signatureAlgorithm: String = String()

  /// The type of public key in the certificate.
  public var publicKeyType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A public key certificate format and data.
public struct Google_Cloud_Iot_V1_PublicKeyCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The certificate format.
  public var format: Google_Cloud_Iot_V1_PublicKeyCertificateFormat = .unspecifiedPublicKeyCertificateFormat

  /// The certificate data.
  public var certificate: String = String()

  /// [Output only] The certificate details. Used only for X.509 certificates.
  public var x509Details: Google_Cloud_Iot_V1_X509CertificateDetails {
    get {return _x509Details ?? Google_Cloud_Iot_V1_X509CertificateDetails()}
    set {_x509Details = newValue}
  }
  /// Returns true if `x509Details` has been explicitly set.
  public var hasX509Details: Bool {return self._x509Details != nil}
  /// Clears the value of `x509Details`. Subsequent reads from it will return its default value.
  public mutating func clearX509Details() {self._x509Details = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _x509Details: Google_Cloud_Iot_V1_X509CertificateDetails? = nil
}

/// A server-stored device credential used for authentication.
public struct Google_Cloud_Iot_V1_DeviceCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The credential data. Reserved for expansion in the future.
  public var credential: Google_Cloud_Iot_V1_DeviceCredential.OneOf_Credential? = nil

  /// A public key used to verify the signature of JSON Web Tokens (JWTs).
  /// When adding a new device credential, either via device creation or via
  /// modifications, this public key credential may be required to be signed by
  /// one of the registry level certificates. More specifically, if the
  /// registry contains at least one certificate, any new device credential
  /// must be signed by one of the registry certificates. As a result,
  /// when the registry contains certificates, only X.509 certificates are
  /// accepted as device credentials. However, if the registry does
  /// not contain a certificate, self-signed certificates and public keys will
  /// be accepted. New device credentials must be different from every
  /// registry-level certificate.
  public var publicKey: Google_Cloud_Iot_V1_PublicKeyCredential {
    get {
      if case .publicKey(let v)? = credential {return v}
      return Google_Cloud_Iot_V1_PublicKeyCredential()
    }
    set {credential = .publicKey(newValue)}
  }

  /// [Optional] The time at which this credential becomes invalid. This
  /// credential will be ignored for new client authentication requests after
  /// this timestamp; however, it will not be automatically deleted.
  public var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  public var hasExpirationTime: Bool {return self._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTime() {self._expirationTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The credential data. Reserved for expansion in the future.
  public enum OneOf_Credential: Equatable {
    /// A public key used to verify the signature of JSON Web Tokens (JWTs).
    /// When adding a new device credential, either via device creation or via
    /// modifications, this public key credential may be required to be signed by
    /// one of the registry level certificates. More specifically, if the
    /// registry contains at least one certificate, any new device credential
    /// must be signed by one of the registry certificates. As a result,
    /// when the registry contains certificates, only X.509 certificates are
    /// accepted as device credentials. However, if the registry does
    /// not contain a certificate, self-signed certificates and public keys will
    /// be accepted. New device credentials must be different from every
    /// registry-level certificate.
    case publicKey(Google_Cloud_Iot_V1_PublicKeyCredential)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Iot_V1_DeviceCredential.OneOf_Credential, rhs: Google_Cloud_Iot_V1_DeviceCredential.OneOf_Credential) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.publicKey, .publicKey): return {
        guard case .publicKey(let l) = lhs, case .publicKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A public key format and data.
public struct Google_Cloud_Iot_V1_PublicKeyCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The format of the key.
  public var format: Google_Cloud_Iot_V1_PublicKeyFormat = .unspecifiedPublicKeyFormat

  /// The key data.
  public var key: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The device configuration. Eventually delivered to devices.
public struct Google_Cloud_Iot_V1_DeviceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Output only] The version of this update. The version number is assigned by
  /// the server, and is always greater than 0 after device creation. The
  /// version must be 0 on the `CreateDevice` request if a `config` is
  /// specified; the response of `CreateDevice` will always have a value of 1.
  public var version: Int64 = 0

  /// [Output only] The time at which this configuration version was updated in
  /// Cloud IoT Core. This timestamp is set by the server.
  public var cloudUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _cloudUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_cloudUpdateTime = newValue}
  }
  /// Returns true if `cloudUpdateTime` has been explicitly set.
  public var hasCloudUpdateTime: Bool {return self._cloudUpdateTime != nil}
  /// Clears the value of `cloudUpdateTime`. Subsequent reads from it will return its default value.
  public mutating func clearCloudUpdateTime() {self._cloudUpdateTime = nil}

  /// [Output only] The time at which Cloud IoT Core received the
  /// acknowledgment from the device, indicating that the device has received
  /// this configuration version. If this field is not present, the device has
  /// not yet acknowledged that it received this version. Note that when
  /// the config was sent to the device, many config versions may have been
  /// available in Cloud IoT Core while the device was disconnected, and on
  /// connection, only the latest version is sent to the device. Some
  /// versions may never be sent to the device, and therefore are never
  /// acknowledged. This timestamp is set by Cloud IoT Core.
  public var deviceAckTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _deviceAckTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_deviceAckTime = newValue}
  }
  /// Returns true if `deviceAckTime` has been explicitly set.
  public var hasDeviceAckTime: Bool {return self._deviceAckTime != nil}
  /// Clears the value of `deviceAckTime`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceAckTime() {self._deviceAckTime = nil}

  /// The device configuration data.
  public var binaryData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cloudUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deviceAckTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The device state, as reported by the device.
public struct Google_Cloud_Iot_V1_DeviceState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Output only] The time at which this state version was updated in Cloud
  /// IoT Core.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  /// The device state data.
  public var binaryData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.iot.v1"

extension Google_Cloud_Iot_V1_MqttState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MQTT_STATE_UNSPECIFIED"),
    1: .same(proto: "MQTT_ENABLED"),
    2: .same(proto: "MQTT_DISABLED"),
  ]
}

extension Google_Cloud_Iot_V1_HttpState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HTTP_STATE_UNSPECIFIED"),
    1: .same(proto: "HTTP_ENABLED"),
    2: .same(proto: "HTTP_DISABLED"),
  ]
}

extension Google_Cloud_Iot_V1_LogLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOG_LEVEL_UNSPECIFIED"),
    10: .same(proto: "NONE"),
    20: .same(proto: "ERROR"),
    30: .same(proto: "INFO"),
    40: .same(proto: "DEBUG"),
  ]
}

extension Google_Cloud_Iot_V1_GatewayType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GATEWAY_TYPE_UNSPECIFIED"),
    1: .same(proto: "GATEWAY"),
    2: .same(proto: "NON_GATEWAY"),
  ]
}

extension Google_Cloud_Iot_V1_GatewayAuthMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GATEWAY_AUTH_METHOD_UNSPECIFIED"),
    1: .same(proto: "ASSOCIATION_ONLY"),
    2: .same(proto: "DEVICE_AUTH_TOKEN_ONLY"),
    3: .same(proto: "ASSOCIATION_AND_DEVICE_AUTH_TOKEN"),
  ]
}

extension Google_Cloud_Iot_V1_PublicKeyCertificateFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_PUBLIC_KEY_CERTIFICATE_FORMAT"),
    1: .same(proto: "X509_CERTIFICATE_PEM"),
  ]
}

extension Google_Cloud_Iot_V1_PublicKeyFormat: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_PUBLIC_KEY_FORMAT"),
    1: .same(proto: "RSA_X509_PEM"),
    2: .same(proto: "ES256_PEM"),
    3: .same(proto: "RSA_PEM"),
    4: .same(proto: "ES256_X509_PEM"),
  ]
}

extension Google_Cloud_Iot_V1_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    3: .standard(proto: "num_id"),
    12: .same(proto: "credentials"),
    7: .standard(proto: "last_heartbeat_time"),
    8: .standard(proto: "last_event_time"),
    20: .standard(proto: "last_state_time"),
    14: .standard(proto: "last_config_ack_time"),
    18: .standard(proto: "last_config_send_time"),
    19: .same(proto: "blocked"),
    10: .standard(proto: "last_error_time"),
    11: .standard(proto: "last_error_status"),
    13: .same(proto: "config"),
    16: .same(proto: "state"),
    21: .standard(proto: "log_level"),
    17: .same(proto: "metadata"),
    24: .standard(proto: "gateway_config"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _name: String = String()
    var _numID: UInt64 = 0
    var _credentials: [Google_Cloud_Iot_V1_DeviceCredential] = []
    var _lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastEventTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastStateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastConfigAckTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastConfigSendTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _blocked: Bool = false
    var _lastErrorTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastErrorStatus: Google_Rpc_Status? = nil
    var _config: Google_Cloud_Iot_V1_DeviceConfig? = nil
    var _state: Google_Cloud_Iot_V1_DeviceState? = nil
    var _logLevel: Google_Cloud_Iot_V1_LogLevel = .unspecified
    var _metadata: Dictionary<String,String> = [:]
    var _gatewayConfig: Google_Cloud_Iot_V1_GatewayConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _name = source._name
      _numID = source._numID
      _credentials = source._credentials
      _lastHeartbeatTime = source._lastHeartbeatTime
      _lastEventTime = source._lastEventTime
      _lastStateTime = source._lastStateTime
      _lastConfigAckTime = source._lastConfigAckTime
      _lastConfigSendTime = source._lastConfigSendTime
      _blocked = source._blocked
      _lastErrorTime = source._lastErrorTime
      _lastErrorStatus = source._lastErrorStatus
      _config = source._config
      _state = source._state
      _logLevel = source._logLevel
      _metadata = source._metadata
      _gatewayConfig = source._gatewayConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._numID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastHeartbeatTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastEventTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastErrorTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastErrorStatus) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._credentials) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lastConfigAckTime) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._state) }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._metadata) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._lastConfigSendTime) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._blocked) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._lastStateTime) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._logLevel) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._gatewayConfig) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      if _storage._numID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._numID, fieldNumber: 3)
      }
      if let v = _storage._lastHeartbeatTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._lastEventTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._lastErrorTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._lastErrorStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._credentials.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._credentials, fieldNumber: 12)
      }
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if let v = _storage._lastConfigAckTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._metadata, fieldNumber: 17)
      }
      if let v = _storage._lastConfigSendTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if _storage._blocked != false {
        try visitor.visitSingularBoolField(value: _storage._blocked, fieldNumber: 19)
      }
      if let v = _storage._lastStateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if _storage._logLevel != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._logLevel, fieldNumber: 21)
      }
      if let v = _storage._gatewayConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_Device, rhs: Google_Cloud_Iot_V1_Device) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._numID != rhs_storage._numID {return false}
        if _storage._credentials != rhs_storage._credentials {return false}
        if _storage._lastHeartbeatTime != rhs_storage._lastHeartbeatTime {return false}
        if _storage._lastEventTime != rhs_storage._lastEventTime {return false}
        if _storage._lastStateTime != rhs_storage._lastStateTime {return false}
        if _storage._lastConfigAckTime != rhs_storage._lastConfigAckTime {return false}
        if _storage._lastConfigSendTime != rhs_storage._lastConfigSendTime {return false}
        if _storage._blocked != rhs_storage._blocked {return false}
        if _storage._lastErrorTime != rhs_storage._lastErrorTime {return false}
        if _storage._lastErrorStatus != rhs_storage._lastErrorStatus {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._logLevel != rhs_storage._logLevel {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._gatewayConfig != rhs_storage._gatewayConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_GatewayConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GatewayConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gateway_type"),
    2: .standard(proto: "gateway_auth_method"),
    3: .standard(proto: "last_accessed_gateway_id"),
    4: .standard(proto: "last_accessed_gateway_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.gatewayType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.gatewayAuthMethod) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.lastAccessedGatewayID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastAccessedGatewayTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.gatewayType != .unspecified {
      try visitor.visitSingularEnumField(value: self.gatewayType, fieldNumber: 1)
    }
    if self.gatewayAuthMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.gatewayAuthMethod, fieldNumber: 2)
    }
    if !self.lastAccessedGatewayID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastAccessedGatewayID, fieldNumber: 3)
    }
    if let v = self._lastAccessedGatewayTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_GatewayConfig, rhs: Google_Cloud_Iot_V1_GatewayConfig) -> Bool {
    if lhs.gatewayType != rhs.gatewayType {return false}
    if lhs.gatewayAuthMethod != rhs.gatewayAuthMethod {return false}
    if lhs.lastAccessedGatewayID != rhs.lastAccessedGatewayID {return false}
    if lhs._lastAccessedGatewayTime != rhs._lastAccessedGatewayTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_DeviceRegistry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceRegistry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    10: .standard(proto: "event_notification_configs"),
    7: .standard(proto: "state_notification_config"),
    4: .standard(proto: "mqtt_config"),
    9: .standard(proto: "http_config"),
    11: .standard(proto: "log_level"),
    8: .same(proto: "credentials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._mqttConfig) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._stateNotificationConfig) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.credentials) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._httpConfig) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.eventNotificationConfigs) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.logLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._mqttConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._stateNotificationConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.credentials.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.credentials, fieldNumber: 8)
    }
    if let v = self._httpConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if !self.eventNotificationConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.eventNotificationConfigs, fieldNumber: 10)
    }
    if self.logLevel != .unspecified {
      try visitor.visitSingularEnumField(value: self.logLevel, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_DeviceRegistry, rhs: Google_Cloud_Iot_V1_DeviceRegistry) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.eventNotificationConfigs != rhs.eventNotificationConfigs {return false}
    if lhs._stateNotificationConfig != rhs._stateNotificationConfig {return false}
    if lhs._mqttConfig != rhs._mqttConfig {return false}
    if lhs._httpConfig != rhs._httpConfig {return false}
    if lhs.logLevel != rhs.logLevel {return false}
    if lhs.credentials != rhs.credentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_MqttConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MqttConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mqtt_enabled_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mqttEnabledState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mqttEnabledState != .unspecified {
      try visitor.visitSingularEnumField(value: self.mqttEnabledState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_MqttConfig, rhs: Google_Cloud_Iot_V1_MqttConfig) -> Bool {
    if lhs.mqttEnabledState != rhs.mqttEnabledState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_HttpConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http_enabled_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.httpEnabledState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.httpEnabledState != .unspecified {
      try visitor.visitSingularEnumField(value: self.httpEnabledState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_HttpConfig, rhs: Google_Cloud_Iot_V1_HttpConfig) -> Bool {
    if lhs.httpEnabledState != rhs.httpEnabledState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_EventNotificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EventNotificationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "subfolder_matches"),
    1: .standard(proto: "pubsub_topic_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubsubTopicName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subfolderMatches) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubsubTopicName.isEmpty {
      try visitor.visitSingularStringField(value: self.pubsubTopicName, fieldNumber: 1)
    }
    if !self.subfolderMatches.isEmpty {
      try visitor.visitSingularStringField(value: self.subfolderMatches, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_EventNotificationConfig, rhs: Google_Cloud_Iot_V1_EventNotificationConfig) -> Bool {
    if lhs.subfolderMatches != rhs.subfolderMatches {return false}
    if lhs.pubsubTopicName != rhs.pubsubTopicName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_StateNotificationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StateNotificationConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pubsub_topic_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pubsubTopicName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubsubTopicName.isEmpty {
      try visitor.visitSingularStringField(value: self.pubsubTopicName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_StateNotificationConfig, rhs: Google_Cloud_Iot_V1_StateNotificationConfig) -> Bool {
    if lhs.pubsubTopicName != rhs.pubsubTopicName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_RegistryCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegistryCredential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Iot_V1_PublicKeyCertificate?
        if let current = self.credential {
          try decoder.handleConflictingOneOf()
          if case .publicKeyCertificate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credential = .publicKeyCertificate(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .publicKeyCertificate(let v)? = self.credential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_RegistryCredential, rhs: Google_Cloud_Iot_V1_RegistryCredential) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_X509CertificateDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".X509CertificateDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "issuer"),
    2: .same(proto: "subject"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "expiry_time"),
    5: .standard(proto: "signature_algorithm"),
    6: .standard(proto: "public_key_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subject) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expiryTime) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.signatureAlgorithm) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.publicKeyType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 1)
    }
    if !self.subject.isEmpty {
      try visitor.visitSingularStringField(value: self.subject, fieldNumber: 2)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._expiryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.signatureAlgorithm.isEmpty {
      try visitor.visitSingularStringField(value: self.signatureAlgorithm, fieldNumber: 5)
    }
    if !self.publicKeyType.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKeyType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_X509CertificateDetails, rhs: Google_Cloud_Iot_V1_X509CertificateDetails) -> Bool {
    if lhs.issuer != rhs.issuer {return false}
    if lhs.subject != rhs.subject {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.signatureAlgorithm != rhs.signatureAlgorithm {return false}
    if lhs.publicKeyType != rhs.publicKeyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_PublicKeyCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "certificate"),
    3: .standard(proto: "x509_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.certificate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._x509Details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .unspecifiedPublicKeyCertificateFormat {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    if !self.certificate.isEmpty {
      try visitor.visitSingularStringField(value: self.certificate, fieldNumber: 2)
    }
    if let v = self._x509Details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_PublicKeyCertificate, rhs: Google_Cloud_Iot_V1_PublicKeyCertificate) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.certificate != rhs.certificate {return false}
    if lhs._x509Details != rhs._x509Details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_DeviceCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceCredential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "public_key"),
    6: .standard(proto: "expiration_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Cloud_Iot_V1_PublicKeyCredential?
        if let current = self.credential {
          try decoder.handleConflictingOneOf()
          if case .publicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credential = .publicKey(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._expirationTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .publicKey(let v)? = self.credential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._expirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_DeviceCredential, rhs: Google_Cloud_Iot_V1_DeviceCredential) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs._expirationTime != rhs._expirationTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_PublicKeyCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublicKeyCredential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.format != .unspecifiedPublicKeyFormat {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_PublicKeyCredential, rhs: Google_Cloud_Iot_V1_PublicKeyCredential) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_DeviceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "cloud_update_time"),
    3: .standard(proto: "device_ack_time"),
    4: .standard(proto: "binary_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cloudUpdateTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deviceAckTime) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.binaryData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 1)
    }
    if let v = self._cloudUpdateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._deviceAckTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.binaryData.isEmpty {
      try visitor.visitSingularBytesField(value: self.binaryData, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_DeviceConfig, rhs: Google_Cloud_Iot_V1_DeviceConfig) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._cloudUpdateTime != rhs._cloudUpdateTime {return false}
    if lhs._deviceAckTime != rhs._deviceAckTime {return false}
    if lhs.binaryData != rhs.binaryData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Iot_V1_DeviceState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeviceState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_time"),
    2: .standard(proto: "binary_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.binaryData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.binaryData.isEmpty {
      try visitor.visitSingularBytesField(value: self.binaryData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Iot_V1_DeviceState, rhs: Google_Cloud_Iot_V1_DeviceState) -> Bool {
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.binaryData != rhs.binaryData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

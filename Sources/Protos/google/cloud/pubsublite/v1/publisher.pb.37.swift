// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/pubsublite/v1/publisher.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The first request that must be sent on a newly-opened stream.
public struct Google_Cloud_Pubsublite_V1_InitialPublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The topic to which messages will be written.
  public var topic: String = String()

  /// The partition within the topic to which messages will be written.
  /// Partitions are zero indexed, so `partition` must be in the range [0,
  /// topic.num_partitions).
  public var partition: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to an InitialPublishRequest.
public struct Google_Cloud_Pubsublite_V1_InitialPublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to publish messages to the topic.
public struct Google_Cloud_Pubsublite_V1_MessagePublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The messages to publish.
  public var messages: [Google_Cloud_Pubsublite_V1_PubSubMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to a MessagePublishRequest.
public struct Google_Cloud_Pubsublite_V1_MessagePublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cursor of the first published message in the batch. The cursors for any
  /// remaining messages in the batch are guaranteed to be sequential.
  public var startCursor: Google_Cloud_Pubsublite_V1_Cursor {
    get {return _startCursor ?? Google_Cloud_Pubsublite_V1_Cursor()}
    set {_startCursor = newValue}
  }
  /// Returns true if `startCursor` has been explicitly set.
  public var hasStartCursor: Bool {return self._startCursor != nil}
  /// Clears the value of `startCursor`. Subsequent reads from it will return its default value.
  public mutating func clearStartCursor() {self._startCursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startCursor: Google_Cloud_Pubsublite_V1_Cursor? = nil
}

/// Request sent from the client to the server on a stream.
public struct Google_Cloud_Pubsublite_V1_PublishRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of request this is.
  public var requestType: Google_Cloud_Pubsublite_V1_PublishRequest.OneOf_RequestType? = nil

  /// Initial request on the stream.
  public var initialRequest: Google_Cloud_Pubsublite_V1_InitialPublishRequest {
    get {
      if case .initialRequest(let v)? = requestType {return v}
      return Google_Cloud_Pubsublite_V1_InitialPublishRequest()
    }
    set {requestType = .initialRequest(newValue)}
  }

  /// Request to publish messages.
  public var messagePublishRequest: Google_Cloud_Pubsublite_V1_MessagePublishRequest {
    get {
      if case .messagePublishRequest(let v)? = requestType {return v}
      return Google_Cloud_Pubsublite_V1_MessagePublishRequest()
    }
    set {requestType = .messagePublishRequest(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of request this is.
  public enum OneOf_RequestType: Equatable {
    /// Initial request on the stream.
    case initialRequest(Google_Cloud_Pubsublite_V1_InitialPublishRequest)
    /// Request to publish messages.
    case messagePublishRequest(Google_Cloud_Pubsublite_V1_MessagePublishRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Pubsublite_V1_PublishRequest.OneOf_RequestType, rhs: Google_Cloud_Pubsublite_V1_PublishRequest.OneOf_RequestType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initialRequest, .initialRequest): return {
        guard case .initialRequest(let l) = lhs, case .initialRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messagePublishRequest, .messagePublishRequest): return {
        guard case .messagePublishRequest(let l) = lhs, case .messagePublishRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response to a PublishRequest.
public struct Google_Cloud_Pubsublite_V1_PublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of response this is.
  public var responseType: Google_Cloud_Pubsublite_V1_PublishResponse.OneOf_ResponseType? = nil

  /// Initial response on the stream.
  public var initialResponse: Google_Cloud_Pubsublite_V1_InitialPublishResponse {
    get {
      if case .initialResponse(let v)? = responseType {return v}
      return Google_Cloud_Pubsublite_V1_InitialPublishResponse()
    }
    set {responseType = .initialResponse(newValue)}
  }

  /// Response to publishing messages.
  public var messageResponse: Google_Cloud_Pubsublite_V1_MessagePublishResponse {
    get {
      if case .messageResponse(let v)? = responseType {return v}
      return Google_Cloud_Pubsublite_V1_MessagePublishResponse()
    }
    set {responseType = .messageResponse(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of response this is.
  public enum OneOf_ResponseType: Equatable {
    /// Initial response on the stream.
    case initialResponse(Google_Cloud_Pubsublite_V1_InitialPublishResponse)
    /// Response to publishing messages.
    case messageResponse(Google_Cloud_Pubsublite_V1_MessagePublishResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Pubsublite_V1_PublishResponse.OneOf_ResponseType, rhs: Google_Cloud_Pubsublite_V1_PublishResponse.OneOf_ResponseType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initialResponse, .initialResponse): return {
        guard case .initialResponse(let l) = lhs, case .initialResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messageResponse, .messageResponse): return {
        guard case .messageResponse(let l) = lhs, case .messageResponse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.pubsublite.v1"

extension Google_Cloud_Pubsublite_V1_InitialPublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitialPublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
    2: .same(proto: "partition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.partition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    if self.partition != 0 {
      try visitor.visitSingularInt64Field(value: self.partition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_InitialPublishRequest, rhs: Google_Cloud_Pubsublite_V1_InitialPublishRequest) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.partition != rhs.partition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_InitialPublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitialPublishResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_InitialPublishResponse, rhs: Google_Cloud_Pubsublite_V1_InitialPublishResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_MessagePublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessagePublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_MessagePublishRequest, rhs: Google_Cloud_Pubsublite_V1_MessagePublishRequest) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_MessagePublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessagePublishResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startCursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startCursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_MessagePublishResponse, rhs: Google_Cloud_Pubsublite_V1_MessagePublishResponse) -> Bool {
    if lhs._startCursor != rhs._startCursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_PublishRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_request"),
    2: .standard(proto: "message_publish_request"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Pubsublite_V1_InitialPublishRequest?
        if let current = self.requestType {
          try decoder.handleConflictingOneOf()
          if case .initialRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestType = .initialRequest(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Pubsublite_V1_MessagePublishRequest?
        if let current = self.requestType {
          try decoder.handleConflictingOneOf()
          if case .messagePublishRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.requestType = .messagePublishRequest(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.requestType {
    case .initialRequest?: try {
      guard case .initialRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .messagePublishRequest?: try {
      guard case .messagePublishRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_PublishRequest, rhs: Google_Cloud_Pubsublite_V1_PublishRequest) -> Bool {
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "initial_response"),
    2: .standard(proto: "message_response"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Pubsublite_V1_InitialPublishResponse?
        if let current = self.responseType {
          try decoder.handleConflictingOneOf()
          if case .initialResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.responseType = .initialResponse(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Pubsublite_V1_MessagePublishResponse?
        if let current = self.responseType {
          try decoder.handleConflictingOneOf()
          if case .messageResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.responseType = .messageResponse(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.responseType {
    case .initialResponse?: try {
      guard case .initialResponse(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .messageResponse?: try {
      guard case .messageResponse(let v)? = self.responseType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_PublishResponse, rhs: Google_Cloud_Pubsublite_V1_PublishResponse) -> Bool {
    if lhs.responseType != rhs.responseType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/pubsublite/v1/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The values associated with a key of an attribute.
public struct Google_Cloud_Pubsublite_V1_AttributeValues {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of values associated with a key.
  public var values: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message that is published by publishers and delivered to subscribers.
public struct Google_Cloud_Pubsublite_V1_PubSubMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key used for routing messages to partitions or for compaction (e.g.,
  /// keep the last N messages per key). If the key is empty, the message is
  /// routed to an arbitrary partition.
  public var key: Data = Data()

  /// The payload of the message.
  public var data: Data = Data()

  /// Optional attributes that can be used for message metadata/headers.
  public var attributes: Dictionary<String,Google_Cloud_Pubsublite_V1_AttributeValues> = [:]

  /// An optional, user-specified event time.
  public var eventTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _eventTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_eventTime = newValue}
  }
  /// Returns true if `eventTime` has been explicitly set.
  public var hasEventTime: Bool {return self._eventTime != nil}
  /// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
  public mutating func clearEventTime() {self._eventTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _eventTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A cursor that describes the position of a message within a topic partition.
public struct Google_Cloud_Pubsublite_V1_Cursor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The offset of a message within a topic partition. Must be greater than or
  /// equal 0.
  public var offset: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A message that has been stored and sequenced by the Pub/Sub Lite system.
public struct Google_Cloud_Pubsublite_V1_SequencedMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The position of a message within the partition where it is stored.
  public var cursor: Google_Cloud_Pubsublite_V1_Cursor {
    get {return _cursor ?? Google_Cloud_Pubsublite_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  /// The time when the message was received by the server when it was first
  /// published.
  public var publishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _publishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_publishTime = newValue}
  }
  /// Returns true if `publishTime` has been explicitly set.
  public var hasPublishTime: Bool {return self._publishTime != nil}
  /// Clears the value of `publishTime`. Subsequent reads from it will return its default value.
  public mutating func clearPublishTime() {self._publishTime = nil}

  /// The user message.
  public var message: Google_Cloud_Pubsublite_V1_PubSubMessage {
    get {return _message ?? Google_Cloud_Pubsublite_V1_PubSubMessage()}
    set {_message = newValue}
  }
  /// Returns true if `message` has been explicitly set.
  public var hasMessage: Bool {return self._message != nil}
  /// Clears the value of `message`. Subsequent reads from it will return its default value.
  public mutating func clearMessage() {self._message = nil}

  /// The size in bytes of this message for flow control and quota purposes.
  public var sizeBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cursor: Google_Cloud_Pubsublite_V1_Cursor? = nil
  fileprivate var _publishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _message: Google_Cloud_Pubsublite_V1_PubSubMessage? = nil
}

/// Metadata about a topic resource.
public struct Google_Cloud_Pubsublite_V1_Topic {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the topic.
  /// Structured like:
  /// projects/{project_number}/locations/{location}/topics/{topic_id}
  public var name: String = String()

  /// The settings for this topic's partitions.
  public var partitionConfig: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig {
    get {return _partitionConfig ?? Google_Cloud_Pubsublite_V1_Topic.PartitionConfig()}
    set {_partitionConfig = newValue}
  }
  /// Returns true if `partitionConfig` has been explicitly set.
  public var hasPartitionConfig: Bool {return self._partitionConfig != nil}
  /// Clears the value of `partitionConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionConfig() {self._partitionConfig = nil}

  /// The settings for this topic's message retention.
  public var retentionConfig: Google_Cloud_Pubsublite_V1_Topic.RetentionConfig {
    get {return _retentionConfig ?? Google_Cloud_Pubsublite_V1_Topic.RetentionConfig()}
    set {_retentionConfig = newValue}
  }
  /// Returns true if `retentionConfig` has been explicitly set.
  public var hasRetentionConfig: Bool {return self._retentionConfig != nil}
  /// Clears the value of `retentionConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetentionConfig() {self._retentionConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The settings for a topic's partitions.
  public struct PartitionConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of partitions in the topic. Must be at least 1.
    public var count: Int64 = 0

    /// The throughput dimension of this topic.
    public var dimension: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.OneOf_Dimension? = nil

    /// DEPRECATED: Use capacity instead which can express a superset of
    /// configurations.
    ///
    /// Every partition in the topic is allocated throughput equivalent to
    /// `scale` times the standard partition throughput (4 MiB/s). This is also
    /// reflected in the cost of this topic; a topic with `scale` of 2 and
    /// count of 10 is charged for 20 partitions. This value must be in the
    /// range [1,4].
    public var scale: Int32 {
      get {
        if case .scale(let v)? = dimension {return v}
        return 0
      }
      set {dimension = .scale(newValue)}
    }

    /// The capacity configuration.
    public var capacity: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity {
      get {
        if case .capacity(let v)? = dimension {return v}
        return Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity()
      }
      set {dimension = .capacity(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The throughput dimension of this topic.
    public enum OneOf_Dimension: Equatable {
      /// DEPRECATED: Use capacity instead which can express a superset of
      /// configurations.
      ///
      /// Every partition in the topic is allocated throughput equivalent to
      /// `scale` times the standard partition throughput (4 MiB/s). This is also
      /// reflected in the cost of this topic; a topic with `scale` of 2 and
      /// count of 10 is charged for 20 partitions. This value must be in the
      /// range [1,4].
      case scale(Int32)
      /// The capacity configuration.
      case capacity(Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.OneOf_Dimension, rhs: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.OneOf_Dimension) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.scale, .scale): return {
          guard case .scale(let l) = lhs, case .scale(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.capacity, .capacity): return {
          guard case .capacity(let l) = lhs, case .capacity(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// The throughput capacity configuration for each partition.
    public struct Capacity {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Publish throughput capacity per partition in MiB/s.
      /// Must be >= 4 and <= 16.
      public var publishMibPerSec: Int32 = 0

      /// Subscribe throughput capacity per partition in MiB/s.
      /// Must be >= 4 and <= 32.
      public var subscribeMibPerSec: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// The settings for a topic's message retention.
  public struct RetentionConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The provisioned storage, in bytes, per partition. If the number of bytes
    /// stored in any of the topic's partitions grows beyond this value, older
    /// messages will be dropped to make room for newer ones, regardless of the
    /// value of `period`.
    public var perPartitionBytes: Int64 = 0

    /// How long a published message is retained. If unset, messages will be
    /// retained as long as the bytes retained for each partition is below
    /// `per_partition_bytes`.
    public var period: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _period ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_period = newValue}
    }
    /// Returns true if `period` has been explicitly set.
    public var hasPeriod: Bool {return self._period != nil}
    /// Clears the value of `period`. Subsequent reads from it will return its default value.
    public mutating func clearPeriod() {self._period = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _period: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _partitionConfig: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig? = nil
  fileprivate var _retentionConfig: Google_Cloud_Pubsublite_V1_Topic.RetentionConfig? = nil
}

/// Metadata about a subscription resource.
public struct Google_Cloud_Pubsublite_V1_Subscription {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the subscription.
  /// Structured like:
  /// projects/{project_number}/locations/{location}/subscriptions/{subscription_id}
  public var name: String = String()

  /// The name of the topic this subscription is attached to.
  /// Structured like:
  /// projects/{project_number}/locations/{location}/topics/{topic_id}
  public var topic: String = String()

  /// The settings for this subscription's message delivery.
  public var deliveryConfig: Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig {
    get {return _deliveryConfig ?? Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig()}
    set {_deliveryConfig = newValue}
  }
  /// Returns true if `deliveryConfig` has been explicitly set.
  public var hasDeliveryConfig: Bool {return self._deliveryConfig != nil}
  /// Clears the value of `deliveryConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDeliveryConfig() {self._deliveryConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The settings for a subscription's message delivery.
  public struct DeliveryConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The DeliveryRequirement for this subscription.
    public var deliveryRequirement: Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig.DeliveryRequirement = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// When this subscription should send messages to subscribers relative to
    /// messages persistence in storage. For details, see [Creating Lite
    /// subscriptions](https://cloud.google.com/pubsub/lite/docs/subscriptions#creating_lite_subscriptions).
    public enum DeliveryRequirement: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Default value. This value is unused.
      case unspecified // = 0

      /// The server does not wait for a published message to be successfully
      /// written to storage before delivering it to subscribers.
      case deliverImmediately // = 1

      /// The server will not deliver a published message to subscribers until
      /// the message has been successfully written to storage. This will result
      /// in higher end-to-end latency, but consistent delivery.
      case deliverAfterStored // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .deliverImmediately
        case 2: self = .deliverAfterStored
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .deliverImmediately: return 1
        case .deliverAfterStored: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _deliveryConfig: Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig.DeliveryRequirement: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig.DeliveryRequirement] = [
    .unspecified,
    .deliverImmediately,
    .deliverAfterStored,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.pubsublite.v1"

extension Google_Cloud_Pubsublite_V1_AttributeValues: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeValues"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.values) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_AttributeValues, rhs: Google_Cloud_Pubsublite_V1_AttributeValues) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_PubSubMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubSubMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "data"),
    3: .same(proto: "attributes"),
    4: .standard(proto: "event_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Pubsublite_V1_AttributeValues>.self, value: &self.attributes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._eventTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Pubsublite_V1_AttributeValues>.self, value: self.attributes, fieldNumber: 3)
    }
    if let v = self._eventTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_PubSubMessage, rhs: Google_Cloud_Pubsublite_V1_PubSubMessage) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.data != rhs.data {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs._eventTime != rhs._eventTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.offset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.offset != 0 {
      try visitor.visitSingularInt64Field(value: self.offset, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Cursor, rhs: Google_Cloud_Pubsublite_V1_Cursor) -> Bool {
    if lhs.offset != rhs.offset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_SequencedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SequencedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
    2: .standard(proto: "publish_time"),
    3: .same(proto: "message"),
    4: .standard(proto: "size_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publishTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._message) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._publishTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._message {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_SequencedMessage, rhs: Google_Cloud_Pubsublite_V1_SequencedMessage) -> Bool {
    if lhs._cursor != rhs._cursor {return false}
    if lhs._publishTime != rhs._publishTime {return false}
    if lhs._message != rhs._message {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Topic: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Topic"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "partition_config"),
    3: .standard(proto: "retention_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._partitionConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._retentionConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._partitionConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._retentionConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Topic, rhs: Google_Cloud_Pubsublite_V1_Topic) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._partitionConfig != rhs._partitionConfig {return false}
    if lhs._retentionConfig != rhs._retentionConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Topic.PartitionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Pubsublite_V1_Topic.protoMessageName + ".PartitionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "scale"),
    3: .same(proto: "capacity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try {
        if self.dimension != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.dimension = .scale(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity?
        if let current = self.dimension {
          try decoder.handleConflictingOneOf()
          if case .capacity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dimension = .capacity(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.dimension {
    case .scale?: try {
      guard case .scale(let v)? = self.dimension else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    }()
    case .capacity?: try {
      guard case .capacity(let v)? = self.dimension else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig, rhs: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.dimension != rhs.dimension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.protoMessageName + ".Capacity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_mib_per_sec"),
    2: .standard(proto: "subscribe_mib_per_sec"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.publishMibPerSec) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.subscribeMibPerSec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.publishMibPerSec != 0 {
      try visitor.visitSingularInt32Field(value: self.publishMibPerSec, fieldNumber: 1)
    }
    if self.subscribeMibPerSec != 0 {
      try visitor.visitSingularInt32Field(value: self.subscribeMibPerSec, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity, rhs: Google_Cloud_Pubsublite_V1_Topic.PartitionConfig.Capacity) -> Bool {
    if lhs.publishMibPerSec != rhs.publishMibPerSec {return false}
    if lhs.subscribeMibPerSec != rhs.subscribeMibPerSec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Topic.RetentionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Pubsublite_V1_Topic.protoMessageName + ".RetentionConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "per_partition_bytes"),
    2: .same(proto: "period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.perPartitionBytes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._period) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.perPartitionBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.perPartitionBytes, fieldNumber: 1)
    }
    if let v = self._period {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Topic.RetentionConfig, rhs: Google_Cloud_Pubsublite_V1_Topic.RetentionConfig) -> Bool {
    if lhs.perPartitionBytes != rhs.perPartitionBytes {return false}
    if lhs._period != rhs._period {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Subscription: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Subscription"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "topic"),
    3: .standard(proto: "delivery_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deliveryConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 2)
    }
    if let v = self._deliveryConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Subscription, rhs: Google_Cloud_Pubsublite_V1_Subscription) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.topic != rhs.topic {return false}
    if lhs._deliveryConfig != rhs._deliveryConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Pubsublite_V1_Subscription.protoMessageName + ".DeliveryConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "delivery_requirement"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deliveryRequirement) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deliveryRequirement != .unspecified {
      try visitor.visitSingularEnumField(value: self.deliveryRequirement, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig, rhs: Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig) -> Bool {
    if lhs.deliveryRequirement != rhs.deliveryRequirement {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_Subscription.DeliveryConfig.DeliveryRequirement: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERY_REQUIREMENT_UNSPECIFIED"),
    1: .same(proto: "DELIVER_IMMEDIATELY"),
    2: .same(proto: "DELIVER_AFTER_STORED"),
  ]
}

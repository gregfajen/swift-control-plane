// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/pubsublite/v1/subscriber.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The first request that must be sent on a newly-opened stream. The client must
/// wait for the response before sending subsequent requests on the stream.
public struct Google_Cloud_Pubsublite_V1_InitialSubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The subscription from which to receive messages.
  public var subscription: String = String()

  /// The partition from which to receive messages. Partitions are zero indexed,
  /// so `partition` must be in the range [0, topic.num_partitions).
  public var partition: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to an InitialSubscribeRequest.
public struct Google_Cloud_Pubsublite_V1_InitialSubscribeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cursor from which the subscriber will start receiving messages once
  /// flow control tokens become available.
  public var cursor: Google_Cloud_Pubsublite_V1_Cursor {
    get {return _cursor ?? Google_Cloud_Pubsublite_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cursor: Google_Cloud_Pubsublite_V1_Cursor? = nil
}

/// Request to update the stream's delivery cursor based on the given target.
/// Resets the server available tokens to 0. SeekRequests may not be sent while
/// another SeekRequest is outstanding (i.e., has not received a SeekResponse) on
/// the same stream. SeekRequests past head result in stream breakage.
public struct Google_Cloud_Pubsublite_V1_SeekRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The target to seek to. Must be set.
  public var target: Google_Cloud_Pubsublite_V1_SeekRequest.OneOf_Target? = nil

  /// A named target.
  public var namedTarget: Google_Cloud_Pubsublite_V1_SeekRequest.NamedTarget {
    get {
      if case .namedTarget(let v)? = target {return v}
      return .unspecified
    }
    set {target = .namedTarget(newValue)}
  }

  /// A target corresponding to the cursor, pointing to anywhere in the
  /// topic partition.
  public var cursor: Google_Cloud_Pubsublite_V1_Cursor {
    get {
      if case .cursor(let v)? = target {return v}
      return Google_Cloud_Pubsublite_V1_Cursor()
    }
    set {target = .cursor(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The target to seek to. Must be set.
  public enum OneOf_Target: Equatable {
    /// A named target.
    case namedTarget(Google_Cloud_Pubsublite_V1_SeekRequest.NamedTarget)
    /// A target corresponding to the cursor, pointing to anywhere in the
    /// topic partition.
    case cursor(Google_Cloud_Pubsublite_V1_Cursor)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Pubsublite_V1_SeekRequest.OneOf_Target, rhs: Google_Cloud_Pubsublite_V1_SeekRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.namedTarget, .namedTarget): return {
        guard case .namedTarget(let l) = lhs, case .namedTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cursor, .cursor): return {
        guard case .cursor(let l) = lhs, case .cursor(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A special target in the partition that takes no other parameters.
  public enum NamedTarget: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value. This value is unused.
    case unspecified // = 0

    /// A target corresponding to the most recently published message in the
    /// partition.
    case head // = 1

    /// A target corresponding to the committed cursor for the given subscription
    /// and topic partition.
    case committedCursor // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .head
      case 2: self = .committedCursor
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .head: return 1
      case .committedCursor: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Pubsublite_V1_SeekRequest.NamedTarget: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Pubsublite_V1_SeekRequest.NamedTarget] = [
    .unspecified,
    .head,
    .committedCursor,
  ]
}

#endif  // swift(>=4.2)

/// Response to a SeekRequest.
public struct Google_Cloud_Pubsublite_V1_SeekResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The new delivery cursor for the current stream.
  public var cursor: Google_Cloud_Pubsublite_V1_Cursor {
    get {return _cursor ?? Google_Cloud_Pubsublite_V1_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cursor: Google_Cloud_Pubsublite_V1_Cursor? = nil
}

/// Request to grant tokens to the server, requesting delivery of messages when
/// they become available.
public struct Google_Cloud_Pubsublite_V1_FlowControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of message tokens to grant. Must be greater than or equal to 0.
  public var allowedMessages: Int64 = 0

  /// The number of byte tokens to grant. Must be greater than or equal to 0.
  public var allowedBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request sent from the client to the server on a stream.
public struct Google_Cloud_Pubsublite_V1_SubscribeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of request this is.
  public var request: Google_Cloud_Pubsublite_V1_SubscribeRequest.OneOf_Request? = nil

  /// Initial request on the stream.
  public var initial: Google_Cloud_Pubsublite_V1_InitialSubscribeRequest {
    get {
      if case .initial(let v)? = request {return v}
      return Google_Cloud_Pubsublite_V1_InitialSubscribeRequest()
    }
    set {request = .initial(newValue)}
  }

  /// Request to update the stream's delivery cursor.
  public var seek: Google_Cloud_Pubsublite_V1_SeekRequest {
    get {
      if case .seek(let v)? = request {return v}
      return Google_Cloud_Pubsublite_V1_SeekRequest()
    }
    set {request = .seek(newValue)}
  }

  /// Request to grant tokens to the server,
  public var flowControl: Google_Cloud_Pubsublite_V1_FlowControlRequest {
    get {
      if case .flowControl(let v)? = request {return v}
      return Google_Cloud_Pubsublite_V1_FlowControlRequest()
    }
    set {request = .flowControl(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of request this is.
  public enum OneOf_Request: Equatable {
    /// Initial request on the stream.
    case initial(Google_Cloud_Pubsublite_V1_InitialSubscribeRequest)
    /// Request to update the stream's delivery cursor.
    case seek(Google_Cloud_Pubsublite_V1_SeekRequest)
    /// Request to grant tokens to the server,
    case flowControl(Google_Cloud_Pubsublite_V1_FlowControlRequest)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Pubsublite_V1_SubscribeRequest.OneOf_Request, rhs: Google_Cloud_Pubsublite_V1_SubscribeRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initial, .initial): return {
        guard case .initial(let l) = lhs, case .initial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seek, .seek): return {
        guard case .seek(let l) = lhs, case .seek(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flowControl, .flowControl): return {
        guard case .flowControl(let l) = lhs, case .flowControl(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response containing a list of messages. Upon delivering a MessageResponse to
/// the client, the server:
/// *  Updates the stream's delivery cursor to one greater than the cursor of the
///    last message in the list.
/// *  Subtracts the total number of bytes and messages from the tokens available
///    to the server.
public struct Google_Cloud_Pubsublite_V1_MessageResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Messages from the topic partition.
  public var messages: [Google_Cloud_Pubsublite_V1_SequencedMessage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response to SubscribeRequest.
public struct Google_Cloud_Pubsublite_V1_SubscribeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of response this is.
  public var response: Google_Cloud_Pubsublite_V1_SubscribeResponse.OneOf_Response? = nil

  /// Initial response on the stream.
  public var initial: Google_Cloud_Pubsublite_V1_InitialSubscribeResponse {
    get {
      if case .initial(let v)? = response {return v}
      return Google_Cloud_Pubsublite_V1_InitialSubscribeResponse()
    }
    set {response = .initial(newValue)}
  }

  /// Response to a Seek operation.
  public var seek: Google_Cloud_Pubsublite_V1_SeekResponse {
    get {
      if case .seek(let v)? = response {return v}
      return Google_Cloud_Pubsublite_V1_SeekResponse()
    }
    set {response = .seek(newValue)}
  }

  /// Response containing messages from the topic partition.
  public var messages: Google_Cloud_Pubsublite_V1_MessageResponse {
    get {
      if case .messages(let v)? = response {return v}
      return Google_Cloud_Pubsublite_V1_MessageResponse()
    }
    set {response = .messages(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of response this is.
  public enum OneOf_Response: Equatable {
    /// Initial response on the stream.
    case initial(Google_Cloud_Pubsublite_V1_InitialSubscribeResponse)
    /// Response to a Seek operation.
    case seek(Google_Cloud_Pubsublite_V1_SeekResponse)
    /// Response containing messages from the topic partition.
    case messages(Google_Cloud_Pubsublite_V1_MessageResponse)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Pubsublite_V1_SubscribeResponse.OneOf_Response, rhs: Google_Cloud_Pubsublite_V1_SubscribeResponse.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initial, .initial): return {
        guard case .initial(let l) = lhs, case .initial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.seek, .seek): return {
        guard case .seek(let l) = lhs, case .seek(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.messages, .messages): return {
        guard case .messages(let l) = lhs, case .messages(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The first request that must be sent on a newly-opened stream. The client must
/// wait for the response before sending subsequent requests on the stream.
public struct Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The subscription name. Structured like:
  /// projects/<project number>/locations/<zone name>/subscriptions/<subscription
  /// id>
  public var subscription: String = String()

  /// An opaque, unique client identifier. This field must be exactly 16 bytes
  /// long and is interpreted as an unsigned 128 bit integer. Other size values
  /// will be rejected and the stream will be failed with a non-retryable error.
  ///
  /// This field is large enough to fit a uuid from standard uuid algorithms like
  /// uuid1 or uuid4, which should be used to generate this number. The same
  /// identifier should be reused following disconnections with retryable stream
  /// errors.
  public var clientID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// PartitionAssignments should not race with acknowledgements. There
/// should be exactly one unacknowledged PartitionAssignment at a time. If not,
/// the client must break the stream.
public struct Google_Cloud_Pubsublite_V1_PartitionAssignment {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of partition numbers this subscriber is assigned to.
  public var partitions: [Int64] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Acknowledge receipt and handling of the previous assignment.
/// If not sent within a short period after receiving the assignment,
/// partitions may remain unassigned for a period of time until the
/// client is known to be inactive, after which time the server will break the
/// stream.
public struct Google_Cloud_Pubsublite_V1_PartitionAssignmentAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A request on the PartitionAssignment stream.
public struct Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of request this is.
  public var request: Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest.OneOf_Request? = nil

  /// Initial request on the stream.
  public var initial: Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest {
    get {
      if case .initial(let v)? = request {return v}
      return Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest()
    }
    set {request = .initial(newValue)}
  }

  /// Acknowledgement of a partition assignment.
  public var ack: Google_Cloud_Pubsublite_V1_PartitionAssignmentAck {
    get {
      if case .ack(let v)? = request {return v}
      return Google_Cloud_Pubsublite_V1_PartitionAssignmentAck()
    }
    set {request = .ack(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of request this is.
  public enum OneOf_Request: Equatable {
    /// Initial request on the stream.
    case initial(Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest)
    /// Acknowledgement of a partition assignment.
    case ack(Google_Cloud_Pubsublite_V1_PartitionAssignmentAck)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest.OneOf_Request, rhs: Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.initial, .initial): return {
        guard case .initial(let l) = lhs, case .initial(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ack, .ack): return {
        guard case .ack(let l) = lhs, case .ack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.pubsublite.v1"

extension Google_Cloud_Pubsublite_V1_InitialSubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitialSubscribeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .same(proto: "partition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.partition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if self.partition != 0 {
      try visitor.visitSingularInt64Field(value: self.partition, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_InitialSubscribeRequest, rhs: Google_Cloud_Pubsublite_V1_InitialSubscribeRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.partition != rhs.partition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_InitialSubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitialSubscribeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_InitialSubscribeResponse, rhs: Google_Cloud_Pubsublite_V1_InitialSubscribeResponse) -> Bool {
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_SeekRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeekRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "named_target"),
    2: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Cloud_Pubsublite_V1_SeekRequest.NamedTarget?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.target = .namedTarget(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Pubsublite_V1_Cursor?
        if let current = self.target {
          try decoder.handleConflictingOneOf()
          if case .cursor(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.target = .cursor(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .namedTarget?: try {
      guard case .namedTarget(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .cursor?: try {
      guard case .cursor(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_SeekRequest, rhs: Google_Cloud_Pubsublite_V1_SeekRequest) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_SeekRequest.NamedTarget: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NAMED_TARGET_UNSPECIFIED"),
    1: .same(proto: "HEAD"),
    2: .same(proto: "COMMITTED_CURSOR"),
  ]
}

extension Google_Cloud_Pubsublite_V1_SeekResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SeekResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cursor"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_SeekResponse, rhs: Google_Cloud_Pubsublite_V1_SeekResponse) -> Bool {
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_FlowControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FlowControlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "allowed_messages"),
    2: .standard(proto: "allowed_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.allowedMessages) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.allowedBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.allowedMessages != 0 {
      try visitor.visitSingularInt64Field(value: self.allowedMessages, fieldNumber: 1)
    }
    if self.allowedBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.allowedBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_FlowControlRequest, rhs: Google_Cloud_Pubsublite_V1_FlowControlRequest) -> Bool {
    if lhs.allowedMessages != rhs.allowedMessages {return false}
    if lhs.allowedBytes != rhs.allowedBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_SubscribeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initial"),
    2: .same(proto: "seek"),
    3: .standard(proto: "flow_control"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Pubsublite_V1_InitialSubscribeRequest?
        if let current = self.request {
          try decoder.handleConflictingOneOf()
          if case .initial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.request = .initial(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Pubsublite_V1_SeekRequest?
        if let current = self.request {
          try decoder.handleConflictingOneOf()
          if case .seek(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.request = .seek(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Pubsublite_V1_FlowControlRequest?
        if let current = self.request {
          try decoder.handleConflictingOneOf()
          if case .flowControl(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.request = .flowControl(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .initial?: try {
      guard case .initial(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .seek?: try {
      guard case .seek(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .flowControl?: try {
      guard case .flowControl(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_SubscribeRequest, rhs: Google_Cloud_Pubsublite_V1_SubscribeRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_MessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_MessageResponse, rhs: Google_Cloud_Pubsublite_V1_MessageResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_SubscribeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SubscribeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initial"),
    2: .same(proto: "seek"),
    3: .same(proto: "messages"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Pubsublite_V1_InitialSubscribeResponse?
        if let current = self.response {
          try decoder.handleConflictingOneOf()
          if case .initial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.response = .initial(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Pubsublite_V1_SeekResponse?
        if let current = self.response {
          try decoder.handleConflictingOneOf()
          if case .seek(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.response = .seek(v)}
      }()
      case 3: try {
        var v: Google_Cloud_Pubsublite_V1_MessageResponse?
        if let current = self.response {
          try decoder.handleConflictingOneOf()
          if case .messages(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.response = .messages(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.response {
    case .initial?: try {
      guard case .initial(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .seek?: try {
      guard case .seek(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .messages?: try {
      guard case .messages(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_SubscribeResponse, rhs: Google_Cloud_Pubsublite_V1_SubscribeResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitialPartitionAssignmentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subscription"),
    2: .standard(proto: "client_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subscription) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.clientID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subscription.isEmpty {
      try visitor.visitSingularStringField(value: self.subscription, fieldNumber: 1)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularBytesField(value: self.clientID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest, rhs: Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest) -> Bool {
    if lhs.subscription != rhs.subscription {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_PartitionAssignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionAssignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partitions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.partitions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partitions.isEmpty {
      try visitor.visitPackedInt64Field(value: self.partitions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_PartitionAssignment, rhs: Google_Cloud_Pubsublite_V1_PartitionAssignment) -> Bool {
    if lhs.partitions != rhs.partitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_PartitionAssignmentAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionAssignmentAck"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_PartitionAssignmentAck, rhs: Google_Cloud_Pubsublite_V1_PartitionAssignmentAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionAssignmentRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "initial"),
    2: .same(proto: "ack"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Pubsublite_V1_InitialPartitionAssignmentRequest?
        if let current = self.request {
          try decoder.handleConflictingOneOf()
          if case .initial(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.request = .initial(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Pubsublite_V1_PartitionAssignmentAck?
        if let current = self.request {
          try decoder.handleConflictingOneOf()
          if case .ack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.request = .ack(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.request {
    case .initial?: try {
      guard case .initial(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .ack?: try {
      guard case .ack(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest, rhs: Google_Cloud_Pubsublite_V1_PartitionAssignmentRequest) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

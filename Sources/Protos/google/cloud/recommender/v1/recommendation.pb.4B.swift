// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/recommender/v1/recommendation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A recommendation along with a suggested action. E.g., a rightsizing
/// recommendation for an underutilized VM, IAM role recommendations, etc
public struct Google_Cloud_Recommender_V1_Recommendation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of recommendation.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Free-form human readable summary in English. The maximum length is 500
  /// characters.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Contains an identifier for a subtype of recommendations produced for the
  /// same recommender. Subtype is a function of content and impact, meaning a
  /// new subtype might be added when significant changes to `content` or
  /// `primary_impact.category` are introduced. See the Recommenders section
  /// to see a list of subtypes for a given Recommender.
  ///
  /// Examples:
  ///   For recommender = "google.iam.policy.Recommender",
  ///   recommender_subtype can be one of "REMOVE_ROLE"/"REPLACE_ROLE"
  public var recommenderSubtype: String {
    get {return _storage._recommenderSubtype}
    set {_uniqueStorage()._recommenderSubtype = newValue}
  }

  /// Last time this recommendation was refreshed by the system that created it
  /// in the first place.
  public var lastRefreshTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastRefreshTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastRefreshTime = newValue}
  }
  /// Returns true if `lastRefreshTime` has been explicitly set.
  public var hasLastRefreshTime: Bool {return _storage._lastRefreshTime != nil}
  /// Clears the value of `lastRefreshTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastRefreshTime() {_uniqueStorage()._lastRefreshTime = nil}

  /// The primary impact that this recommendation can have while trying to
  /// optimize for one category.
  public var primaryImpact: Google_Cloud_Recommender_V1_Impact {
    get {return _storage._primaryImpact ?? Google_Cloud_Recommender_V1_Impact()}
    set {_uniqueStorage()._primaryImpact = newValue}
  }
  /// Returns true if `primaryImpact` has been explicitly set.
  public var hasPrimaryImpact: Bool {return _storage._primaryImpact != nil}
  /// Clears the value of `primaryImpact`. Subsequent reads from it will return its default value.
  public mutating func clearPrimaryImpact() {_uniqueStorage()._primaryImpact = nil}

  /// Optional set of additional impact that this recommendation may have when
  /// trying to optimize for the primary category. These may be positive
  /// or negative.
  public var additionalImpact: [Google_Cloud_Recommender_V1_Impact] {
    get {return _storage._additionalImpact}
    set {_uniqueStorage()._additionalImpact = newValue}
  }

  /// Content of the recommendation describing recommended changes to resources.
  public var content: Google_Cloud_Recommender_V1_RecommendationContent {
    get {return _storage._content ?? Google_Cloud_Recommender_V1_RecommendationContent()}
    set {_uniqueStorage()._content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  public var hasContent: Bool {return _storage._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  public mutating func clearContent() {_uniqueStorage()._content = nil}

  /// Information for state. Contains state and metadata.
  public var stateInfo: Google_Cloud_Recommender_V1_RecommendationStateInfo {
    get {return _storage._stateInfo ?? Google_Cloud_Recommender_V1_RecommendationStateInfo()}
    set {_uniqueStorage()._stateInfo = newValue}
  }
  /// Returns true if `stateInfo` has been explicitly set.
  public var hasStateInfo: Bool {return _storage._stateInfo != nil}
  /// Clears the value of `stateInfo`. Subsequent reads from it will return its default value.
  public mutating func clearStateInfo() {_uniqueStorage()._stateInfo = nil}

  /// Fingerprint of the Recommendation. Provides optimistic locking when
  /// updating states.
  public var etag: String {
    get {return _storage._etag}
    set {_uniqueStorage()._etag = newValue}
  }

  /// Insights that led to this recommendation.
  public var associatedInsights: [Google_Cloud_Recommender_V1_Recommendation.InsightReference] {
    get {return _storage._associatedInsights}
    set {_uniqueStorage()._associatedInsights = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Reference to an associated insight.
  public struct InsightReference {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Insight resource name, e.g.
    /// projects/[PROJECT_NUMBER]/locations/[LOCATION]/insightTypes/[INSIGHT_TYPE_ID]/insights/[INSIGHT_ID]
    public var insight: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Contains what resources are changing and how they are changing.
public struct Google_Cloud_Recommender_V1_RecommendationContent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Operations to one or more Google Cloud resources grouped in such a way
  /// that, all operations within one group are expected to be performed
  /// atomically and in an order.
  public var operationGroups: [Google_Cloud_Recommender_V1_OperationGroup] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Group of operations that need to be performed atomically.
public struct Google_Cloud_Recommender_V1_OperationGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of operations across one or more resources that belong to this group.
  /// Loosely based on RFC6902 and should be performed in the order they appear.
  public var operations: [Google_Cloud_Recommender_V1_Operation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains an operation for a resource loosely based on the JSON-PATCH format
/// with support for:
///
/// * Custom filters for describing partial array patch.
/// * Extended path values for describing nested arrays.
/// * Custom fields for describing the resource for which the operation is being
///   described.
/// * Allows extension to custom operations not natively supported by RFC6902.
/// See https://tools.ietf.org/html/rfc6902 for details on the original RFC.
public struct Google_Cloud_Recommender_V1_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Type of this operation. Contains one of 'and', 'remove', 'replace', 'move',
  /// 'copy', 'test' and custom operations. This field is case-insensitive and
  /// always populated.
  public var action: String = String()

  /// Type of GCP resource being modified/tested. This field is always populated.
  /// Example: cloudresourcemanager.googleapis.com/Project,
  /// compute.googleapis.com/Instance
  public var resourceType: String = String()

  /// Contains the fully qualified resource name. This field is always populated.
  /// ex: //cloudresourcemanager.googleapis.com/projects/foo.
  public var resource: String = String()

  /// Path to the target field being operated on. If the operation is at the
  /// resource level, then path should be "/". This field is always populated.
  public var path: String = String()

  /// Can be set with action 'copy' to copy resource configuration across
  /// different resources of the same type. Example: A resource clone can be
  /// done via action = 'copy', path = "/", from = "/",
  /// source_resource = <source> and resource_name = <target>.
  /// This field is empty for all other values of `action`.
  public var sourceResource: String = String()

  /// Can be set with action 'copy' or 'move' to indicate the source field within
  /// resource or source_resource, ignored if provided for other operation types.
  public var sourcePath: String = String()

  /// One of the fields in the following block will be set and intend to
  /// describe a value for 'path' field.
  public var pathValue: Google_Cloud_Recommender_V1_Operation.OneOf_PathValue? = nil

  /// Value for the `path` field. Will be set for actions:'add'/'replace'.
  /// Maybe set for action: 'test'. Either this or `value_matcher` will be set
  /// for 'test' operation. An exact match must be performed.
  public var value: SwiftProtobuf.Google_Protobuf_Value {
    get {
      if case .value(let v)? = pathValue {return v}
      return SwiftProtobuf.Google_Protobuf_Value()
    }
    set {pathValue = .value(newValue)}
  }

  /// Can be set for action 'test' for advanced matching for the value of
  /// 'path' field. Either this or `value` will be set for 'test' operation.
  public var valueMatcher: Google_Cloud_Recommender_V1_ValueMatcher {
    get {
      if case .valueMatcher(let v)? = pathValue {return v}
      return Google_Cloud_Recommender_V1_ValueMatcher()
    }
    set {pathValue = .valueMatcher(newValue)}
  }

  /// Set of filters to apply if `path` refers to array elements or nested array
  /// elements in order to narrow down to a single unique element that is being
  /// tested/modified.
  /// This is intended to be an exact match per filter. To perform advanced
  /// matching, use path_value_matchers.
  ///
  /// * Example: {
  ///   "/versions/*/name" : "it-123"
  ///   "/versions/*/targetSize/percent": 20
  ///  }
  /// * Example: {
  ///   "/bindings/*/role": "roles/admin"
  ///   "/bindings/*/condition" : null
  ///  }
  /// * Example: {
  ///   "/bindings/*/role": "roles/admin"
  ///   "/bindings/*/members/*" : ["x@google.com", "y@google.com"]
  ///  }
  /// When both path_filters and path_value_matchers are set, an implicit AND
  /// must be performed.
  public var pathFilters: Dictionary<String,SwiftProtobuf.Google_Protobuf_Value> = [:]

  /// Similar to path_filters, this contains set of filters to apply if `path`
  /// field referes to array elements. This is meant to support value matching
  /// beyond exact match. To perform exact match, use path_filters.
  /// When both path_filters and path_value_matchers are set, an implicit AND
  /// must be performed.
  public var pathValueMatchers: Dictionary<String,Google_Cloud_Recommender_V1_ValueMatcher> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One of the fields in the following block will be set and intend to
  /// describe a value for 'path' field.
  public enum OneOf_PathValue: Equatable {
    /// Value for the `path` field. Will be set for actions:'add'/'replace'.
    /// Maybe set for action: 'test'. Either this or `value_matcher` will be set
    /// for 'test' operation. An exact match must be performed.
    case value(SwiftProtobuf.Google_Protobuf_Value)
    /// Can be set for action 'test' for advanced matching for the value of
    /// 'path' field. Either this or `value` will be set for 'test' operation.
    case valueMatcher(Google_Cloud_Recommender_V1_ValueMatcher)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Recommender_V1_Operation.OneOf_PathValue, rhs: Google_Cloud_Recommender_V1_Operation.OneOf_PathValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.value, .value): return {
        guard case .value(let l) = lhs, case .value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.valueMatcher, .valueMatcher): return {
        guard case .valueMatcher(let l) = lhs, case .valueMatcher(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Contains various matching options for values for a GCP resource field.
public struct Google_Cloud_Recommender_V1_ValueMatcher {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var matchVariant: Google_Cloud_Recommender_V1_ValueMatcher.OneOf_MatchVariant? = nil

  /// To be used for full regex matching. The regular expression is using the
  /// Google RE2 syntax (https://github.com/google/re2/wiki/Syntax), so to be
  /// used with RE2::FullMatch
  public var matchesPattern: String {
    get {
      if case .matchesPattern(let v)? = matchVariant {return v}
      return String()
    }
    set {matchVariant = .matchesPattern(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_MatchVariant: Equatable {
    /// To be used for full regex matching. The regular expression is using the
    /// Google RE2 syntax (https://github.com/google/re2/wiki/Syntax), so to be
    /// used with RE2::FullMatch
    case matchesPattern(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Recommender_V1_ValueMatcher.OneOf_MatchVariant, rhs: Google_Cloud_Recommender_V1_ValueMatcher.OneOf_MatchVariant) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.matchesPattern, .matchesPattern): return {
        guard case .matchesPattern(let l) = lhs, case .matchesPattern(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Contains metadata about how much money a recommendation can save or incur.
public struct Google_Cloud_Recommender_V1_CostProjection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An approximate projection on amount saved or amount incurred. Negative cost
  /// units indicate cost savings and positive cost units indicate increase.
  /// See google.type.Money documentation for positive/negative units.
  public var cost: Google_Type_Money {
    get {return _cost ?? Google_Type_Money()}
    set {_cost = newValue}
  }
  /// Returns true if `cost` has been explicitly set.
  public var hasCost: Bool {return self._cost != nil}
  /// Clears the value of `cost`. Subsequent reads from it will return its default value.
  public mutating func clearCost() {self._cost = nil}

  /// Duration for which this cost applies.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cost: Google_Type_Money? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Contains the impact a recommendation can have for a given category.
public struct Google_Cloud_Recommender_V1_Impact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Category that is being targeted.
  public var category: Google_Cloud_Recommender_V1_Impact.Category = .unspecified

  /// Contains projections (if any) for this category.
  public var projection: Google_Cloud_Recommender_V1_Impact.OneOf_Projection? = nil

  /// Use with CategoryType.COST
  public var costProjection: Google_Cloud_Recommender_V1_CostProjection {
    get {
      if case .costProjection(let v)? = projection {return v}
      return Google_Cloud_Recommender_V1_CostProjection()
    }
    set {projection = .costProjection(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contains projections (if any) for this category.
  public enum OneOf_Projection: Equatable {
    /// Use with CategoryType.COST
    case costProjection(Google_Cloud_Recommender_V1_CostProjection)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Recommender_V1_Impact.OneOf_Projection, rhs: Google_Cloud_Recommender_V1_Impact.OneOf_Projection) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.costProjection, .costProjection): return {
        guard case .costProjection(let l) = lhs, case .costProjection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// The category of the impact.
  public enum Category: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default unspecified category. Don't use directly.
    case unspecified // = 0

    /// Indicates a potential increase or decrease in cost.
    case cost // = 1

    /// Indicates a potential increase or decrease in security.
    case security // = 2

    /// Indicates a potential increase or decrease in performance.
    case performance // = 3

    /// Indicates a potential increase or decrease in manageability.
    case manageability // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .cost
      case 2: self = .security
      case 3: self = .performance
      case 4: self = .manageability
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .cost: return 1
      case .security: return 2
      case .performance: return 3
      case .manageability: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Recommender_V1_Impact.Category: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recommender_V1_Impact.Category] = [
    .unspecified,
    .cost,
    .security,
    .performance,
    .manageability,
  ]
}

#endif  // swift(>=4.2)

/// Information for state. Contains state and metadata.
public struct Google_Cloud_Recommender_V1_RecommendationStateInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The state of the recommendation, Eg ACTIVE, SUCCEEDED, FAILED.
  public var state: Google_Cloud_Recommender_V1_RecommendationStateInfo.State = .unspecified

  /// A map of metadata for the state, provided by user or automations systems.
  public var stateMetadata: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents Recommendation State.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default state. Don't use directly.
    case unspecified // = 0

    /// Recommendation is active and can be applied. Recommendations content can
    /// be updated by Google.
    ///
    /// ACTIVE recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
    case active // = 1

    /// Recommendation is in claimed state. Recommendations content is
    /// immutable and cannot be updated by Google.
    ///
    /// CLAIMED recommendations can be marked as CLAIMED, SUCCEEDED, or FAILED.
    case claimed // = 6

    /// Recommendation is in succeeded state. Recommendations content is
    /// immutable and cannot be updated by Google.
    ///
    /// SUCCEEDED recommendations can be marked as SUCCEEDED, or FAILED.
    case succeeded // = 3

    /// Recommendation is in failed state. Recommendations content is immutable
    /// and cannot be updated by Google.
    ///
    /// FAILED recommendations can be marked as SUCCEEDED, or FAILED.
    case failed // = 4

    /// Recommendation is in dismissed state. Recommendation content can be
    /// updated by Google.
    ///
    /// DISMISSED recommendations can be marked as ACTIVE.
    case dismissed // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 3: self = .succeeded
      case 4: self = .failed
      case 5: self = .dismissed
      case 6: self = .claimed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .succeeded: return 3
      case .failed: return 4
      case .dismissed: return 5
      case .claimed: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Recommender_V1_RecommendationStateInfo.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Recommender_V1_RecommendationStateInfo.State] = [
    .unspecified,
    .active,
    .claimed,
    .succeeded,
    .failed,
    .dismissed,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.recommender.v1"

extension Google_Cloud_Recommender_V1_Recommendation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Recommendation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    12: .standard(proto: "recommender_subtype"),
    4: .standard(proto: "last_refresh_time"),
    5: .standard(proto: "primary_impact"),
    6: .standard(proto: "additional_impact"),
    7: .same(proto: "content"),
    10: .standard(proto: "state_info"),
    11: .same(proto: "etag"),
    14: .standard(proto: "associated_insights"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _recommenderSubtype: String = String()
    var _lastRefreshTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _primaryImpact: Google_Cloud_Recommender_V1_Impact? = nil
    var _additionalImpact: [Google_Cloud_Recommender_V1_Impact] = []
    var _content: Google_Cloud_Recommender_V1_RecommendationContent? = nil
    var _stateInfo: Google_Cloud_Recommender_V1_RecommendationStateInfo? = nil
    var _etag: String = String()
    var _associatedInsights: [Google_Cloud_Recommender_V1_Recommendation.InsightReference] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _recommenderSubtype = source._recommenderSubtype
      _lastRefreshTime = source._lastRefreshTime
      _primaryImpact = source._primaryImpact
      _additionalImpact = source._additionalImpact
      _content = source._content
      _stateInfo = source._stateInfo
      _etag = source._etag
      _associatedInsights = source._associatedInsights
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastRefreshTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._primaryImpact) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._additionalImpact) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._content) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._stateInfo) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._etag) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._recommenderSubtype) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._associatedInsights) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if let v = _storage._lastRefreshTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._primaryImpact {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._additionalImpact.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._additionalImpact, fieldNumber: 6)
      }
      if let v = _storage._content {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._stateInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._etag.isEmpty {
        try visitor.visitSingularStringField(value: _storage._etag, fieldNumber: 11)
      }
      if !_storage._recommenderSubtype.isEmpty {
        try visitor.visitSingularStringField(value: _storage._recommenderSubtype, fieldNumber: 12)
      }
      if !_storage._associatedInsights.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._associatedInsights, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_Recommendation, rhs: Google_Cloud_Recommender_V1_Recommendation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._recommenderSubtype != rhs_storage._recommenderSubtype {return false}
        if _storage._lastRefreshTime != rhs_storage._lastRefreshTime {return false}
        if _storage._primaryImpact != rhs_storage._primaryImpact {return false}
        if _storage._additionalImpact != rhs_storage._additionalImpact {return false}
        if _storage._content != rhs_storage._content {return false}
        if _storage._stateInfo != rhs_storage._stateInfo {return false}
        if _storage._etag != rhs_storage._etag {return false}
        if _storage._associatedInsights != rhs_storage._associatedInsights {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_Recommendation.InsightReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Recommender_V1_Recommendation.protoMessageName + ".InsightReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "insight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.insight) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.insight.isEmpty {
      try visitor.visitSingularStringField(value: self.insight, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_Recommendation.InsightReference, rhs: Google_Cloud_Recommender_V1_Recommendation.InsightReference) -> Bool {
    if lhs.insight != rhs.insight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_RecommendationContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendationContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "operation_groups"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.operationGroups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operationGroups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_RecommendationContent, rhs: Google_Cloud_Recommender_V1_RecommendationContent) -> Bool {
    if lhs.operationGroups != rhs.operationGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_OperationGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OperationGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_OperationGroup, rhs: Google_Cloud_Recommender_V1_OperationGroup) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .standard(proto: "resource_type"),
    3: .same(proto: "resource"),
    4: .same(proto: "path"),
    5: .standard(proto: "source_resource"),
    6: .standard(proto: "source_path"),
    7: .same(proto: "value"),
    10: .standard(proto: "value_matcher"),
    8: .standard(proto: "path_filters"),
    11: .standard(proto: "path_value_matchers"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourceResource) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sourcePath) }()
      case 7: try {
        var v: SwiftProtobuf.Google_Protobuf_Value?
        if let current = self.pathValue {
          try decoder.handleConflictingOneOf()
          if case .value(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pathValue = .value(v)}
      }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: &self.pathFilters) }()
      case 10: try {
        var v: Google_Cloud_Recommender_V1_ValueMatcher?
        if let current = self.pathValue {
          try decoder.handleConflictingOneOf()
          if case .valueMatcher(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.pathValue = .valueMatcher(v)}
      }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Recommender_V1_ValueMatcher>.self, value: &self.pathValueMatchers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 1)
    }
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 2)
    }
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 4)
    }
    if !self.sourceResource.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceResource, fieldNumber: 5)
    }
    if !self.sourcePath.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePath, fieldNumber: 6)
    }
    if case .value(let v)? = self.pathValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.pathFilters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Value>.self, value: self.pathFilters, fieldNumber: 8)
    }
    if case .valueMatcher(let v)? = self.pathValue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.pathValueMatchers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Recommender_V1_ValueMatcher>.self, value: self.pathValueMatchers, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_Operation, rhs: Google_Cloud_Recommender_V1_Operation) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.resource != rhs.resource {return false}
    if lhs.path != rhs.path {return false}
    if lhs.sourceResource != rhs.sourceResource {return false}
    if lhs.sourcePath != rhs.sourcePath {return false}
    if lhs.pathValue != rhs.pathValue {return false}
    if lhs.pathFilters != rhs.pathFilters {return false}
    if lhs.pathValueMatchers != rhs.pathValueMatchers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_ValueMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "matches_pattern"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.matchVariant != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.matchVariant = .matchesPattern(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .matchesPattern(let v)? = self.matchVariant {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_ValueMatcher, rhs: Google_Cloud_Recommender_V1_ValueMatcher) -> Bool {
    if lhs.matchVariant != rhs.matchVariant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_CostProjection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CostProjection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cost"),
    2: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._cost) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._cost {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_CostProjection, rhs: Google_Cloud_Recommender_V1_CostProjection) -> Bool {
    if lhs._cost != rhs._cost {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_Impact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Impact"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
    100: .standard(proto: "cost_projection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      case 100: try {
        var v: Google_Cloud_Recommender_V1_CostProjection?
        if let current = self.projection {
          try decoder.handleConflictingOneOf()
          if case .costProjection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.projection = .costProjection(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.category != .unspecified {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 1)
    }
    if case .costProjection(let v)? = self.projection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_Impact, rhs: Google_Cloud_Recommender_V1_Impact) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.projection != rhs.projection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_Impact.Category: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CATEGORY_UNSPECIFIED"),
    1: .same(proto: "COST"),
    2: .same(proto: "SECURITY"),
    3: .same(proto: "PERFORMANCE"),
    4: .same(proto: "MANAGEABILITY"),
  ]
}

extension Google_Cloud_Recommender_V1_RecommendationStateInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecommendationStateInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "state_metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.stateMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if !self.stateMetadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.stateMetadata, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Recommender_V1_RecommendationStateInfo, rhs: Google_Cloud_Recommender_V1_RecommendationStateInfo) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.stateMetadata != rhs.stateMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Recommender_V1_RecommendationStateInfo.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    3: .same(proto: "SUCCEEDED"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "DISMISSED"),
    6: .same(proto: "CLAIMED"),
  ]
}

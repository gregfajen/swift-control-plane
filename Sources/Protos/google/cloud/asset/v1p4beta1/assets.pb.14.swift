// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/asset/v1p4beta1/assets.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// IAM Policy analysis result, consisting of one IAM policy binding and derived
/// access control lists.
public struct Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full name of the resource to which the [iam_binding][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.iam_binding] policy attaches.
  public var attachedResourceFullName: String = String()

  /// The Cloud IAM policy binding under analysis.
  public var iamBinding: Google_Iam_V1_Binding {
    get {return _iamBinding ?? Google_Iam_V1_Binding()}
    set {_iamBinding = newValue}
  }
  /// Returns true if `iamBinding` has been explicitly set.
  public var hasIamBinding: Bool {return self._iamBinding != nil}
  /// Clears the value of `iamBinding`. Subsequent reads from it will return its default value.
  public mutating func clearIamBinding() {self._iamBinding = nil}

  /// The access control lists derived from the [iam_binding][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.iam_binding] that match or
  /// potentially match resource and access selectors specified in the request.
  public var accessControlLists: [Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AccessControlList] = []

  /// The identity list derived from members of the [iam_binding][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.iam_binding] that match or
  /// potentially match identity selector specified in the request.
  public var identityList: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.IdentityList {
    get {return _identityList ?? Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.IdentityList()}
    set {_identityList = newValue}
  }
  /// Returns true if `identityList` has been explicitly set.
  public var hasIdentityList: Bool {return self._identityList != nil}
  /// Clears the value of `identityList`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityList() {self._identityList = nil}

  /// Represents whether all nodes in the transitive closure of the
  /// [iam_binding][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.iam_binding] node have been explored.
  public var fullyExplored: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Represents analysis state of each node in the result graph or non-critical
  /// errors in the response.
  public struct AnalysisState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The Google standard error code that best describes the state.
    /// For example:
    /// - OK means the node has been successfully explored;
    /// - PERMISSION_DENIED means an access denied error is encountered;
    /// - DEADLINE_EXCEEDED means the node hasn't been explored in time;
    public var code: Google_Rpc_Code = .ok

    /// The human-readable description of the cause of failure.
    public var cause: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A GCP resource that appears in an access control list.
  public struct Resource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The [full resource name](https://aip.dev/122#full-resource-names).
    public var fullResourceName: String = String()

    /// The analysis state of this resource node.
    public var analysisState: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState {
      get {return _analysisState ?? Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState()}
      set {_analysisState = newValue}
    }
    /// Returns true if `analysisState` has been explicitly set.
    public var hasAnalysisState: Bool {return self._analysisState != nil}
    /// Clears the value of `analysisState`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisState() {self._analysisState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _analysisState: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState? = nil
  }

  /// A role or permission that appears in an access control list.
  public struct Access {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var oneofAccess: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access.OneOf_OneofAccess? = nil

    /// The role.
    public var role: String {
      get {
        if case .role(let v)? = oneofAccess {return v}
        return String()
      }
      set {oneofAccess = .role(newValue)}
    }

    /// The permission.
    public var permission: String {
      get {
        if case .permission(let v)? = oneofAccess {return v}
        return String()
      }
      set {oneofAccess = .permission(newValue)}
    }

    /// The analysis state of this access node.
    public var analysisState: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState {
      get {return _analysisState ?? Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState()}
      set {_analysisState = newValue}
    }
    /// Returns true if `analysisState` has been explicitly set.
    public var hasAnalysisState: Bool {return self._analysisState != nil}
    /// Clears the value of `analysisState`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisState() {self._analysisState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_OneofAccess: Equatable {
      /// The role.
      case role(String)
      /// The permission.
      case permission(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access.OneOf_OneofAccess, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access.OneOf_OneofAccess) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.role, .role): return {
          guard case .role(let l) = lhs, case .role(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.permission, .permission): return {
          guard case .permission(let l) = lhs, case .permission(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _analysisState: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState? = nil
  }

  /// A directional edge.
  public struct Edge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The source node of the edge.
    public var sourceNode: String = String()

    /// The target node of the edge.
    public var targetNode: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// An identity that appears in an access control list.
  public struct Identity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity name in any form of members appear in
    /// [IAM policy
    /// binding](https://cloud.google.com/iam/reference/rest/v1/Binding), such
    /// as:
    /// - user:foo@google.com
    /// - group:group1@google.com
    /// - serviceAccount:s1@prj1.iam.gserviceaccount.com
    /// - projectOwner:some_project_id
    /// - domain:google.com
    /// - allUsers
    /// - etc.
    public var name: String = String()

    /// The analysis state of this identity node.
    public var analysisState: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState {
      get {return _analysisState ?? Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState()}
      set {_analysisState = newValue}
    }
    /// Returns true if `analysisState` has been explicitly set.
    public var hasAnalysisState: Bool {return self._analysisState != nil}
    /// Clears the value of `analysisState`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisState() {self._analysisState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _analysisState: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState? = nil
  }

  /// An access control list, derived from the above IAM policy binding, which
  /// contains a set of resources and accesses. May include one
  /// item from each set to compose an access control entry.
  ///
  /// NOTICE that there could be multiple access control lists for one IAM policy
  /// binding. The access control lists are created based on resource and access
  /// combinations.
  ///
  /// For example, assume we have the following cases in one IAM policy binding:
  /// - Permission P1 and P2 apply to resource R1 and R2;
  /// - Permission P3 applies to resource R2 and R3;
  ///
  /// This will result in the following access control lists:
  /// - AccessControlList 1: [R1, R2], [P1, P2]
  /// - AccessControlList 2: [R2, R3], [P3]
  public struct AccessControlList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The resources that match one of the following conditions:
    /// - The resource_selector, if it is specified in request;
    /// - Otherwise, resources reachable from the policy attached resource.
    public var resources: [Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Resource] = []

    /// The accesses that match one of the following conditions:
    /// - The access_selector, if it is specified in request;
    /// - Otherwise, access specifiers reachable from the policy binding's role.
    public var accesses: [Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access] = []

    /// Resource edges of the graph starting from the policy attached
    /// resource to any descendant resources. The [Edge.source_node][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.Edge.source_node] contains
    /// the full resource name of a parent resource and [Edge.target_node][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.Edge.target_node]
    /// contains the full resource name of a child resource. This field is
    /// present only if the output_resource_edges option is enabled in request.
    public var resourceEdges: [Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Edge] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct IdentityList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only the identities that match one of the following conditions will be
    /// presented:
    /// - The identity_selector, if it is specified in request;
    /// - Otherwise, identities reachable from the policy binding's members.
    public var identities: [Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Identity] = []

    /// Group identity edges of the graph starting from the binding's
    /// group members to any node of the [identities][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.IdentityList.identities]. The [Edge.source_node][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.Edge.source_node]
    /// contains a group, such as "group:parent@google.com". The
    /// [Edge.target_node][google.cloud.asset.v1p4beta1.IamPolicyAnalysisResult.Edge.target_node] contains a member of the group,
    /// such as "group:child@google.com" or "user:foo@google.com".
    /// This field is present only if the output_group_edges option is enabled in
    /// request.
    public var groupEdges: [Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Edge] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _iamBinding: Google_Iam_V1_Binding? = nil
  fileprivate var _identityList: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.IdentityList? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.asset.v1p4beta1"

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IamPolicyAnalysisResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attached_resource_full_name"),
    2: .standard(proto: "iam_binding"),
    3: .standard(proto: "access_control_lists"),
    4: .standard(proto: "identity_list"),
    5: .standard(proto: "fully_explored"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.attachedResourceFullName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._iamBinding) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accessControlLists) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._identityList) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fullyExplored) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachedResourceFullName.isEmpty {
      try visitor.visitSingularStringField(value: self.attachedResourceFullName, fieldNumber: 1)
    }
    if let v = self._iamBinding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.accessControlLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessControlLists, fieldNumber: 3)
    }
    if let v = self._identityList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.fullyExplored != false {
      try visitor.visitSingularBoolField(value: self.fullyExplored, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult) -> Bool {
    if lhs.attachedResourceFullName != rhs.attachedResourceFullName {return false}
    if lhs._iamBinding != rhs._iamBinding {return false}
    if lhs.accessControlLists != rhs.accessControlLists {return false}
    if lhs._identityList != rhs._identityList {return false}
    if lhs.fullyExplored != rhs.fullyExplored {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".AnalysisState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "cause"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cause) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.cause.isEmpty {
      try visitor.visitSingularStringField(value: self.cause, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AnalysisState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_resource_name"),
    2: .standard(proto: "analysis_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._analysisState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 1)
    }
    if let v = self._analysisState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Resource, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Resource) -> Bool {
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs._analysisState != rhs._analysisState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".Access"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "permission"),
    3: .standard(proto: "analysis_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.oneofAccess != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.oneofAccess = .role(v)}
      }()
      case 2: try {
        if self.oneofAccess != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.oneofAccess = .permission(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._analysisState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneofAccess {
    case .role?: try {
      guard case .role(let v)? = self.oneofAccess else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .permission?: try {
      guard case .permission(let v)? = self.oneofAccess else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._analysisState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Access) -> Bool {
    if lhs.oneofAccess != rhs.oneofAccess {return false}
    if lhs._analysisState != rhs._analysisState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".Edge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_node"),
    2: .standard(proto: "target_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceNode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetNode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceNode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceNode, fieldNumber: 1)
    }
    if !self.targetNode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Edge, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Edge) -> Bool {
    if lhs.sourceNode != rhs.sourceNode {return false}
    if lhs.targetNode != rhs.targetNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".Identity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "analysis_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._analysisState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._analysisState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Identity, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.Identity) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._analysisState != rhs._analysisState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AccessControlList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".AccessControlList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
    2: .same(proto: "accesses"),
    3: .standard(proto: "resource_edges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.accesses) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.resourceEdges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    if !self.accesses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accesses, fieldNumber: 2)
    }
    if !self.resourceEdges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceEdges, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AccessControlList, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.AccessControlList) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.accesses != rhs.accesses {return false}
    if lhs.resourceEdges != rhs.resourceEdges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.IdentityList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.protoMessageName + ".IdentityList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identities"),
    2: .standard(proto: "group_edges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.identities) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupEdges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identities, fieldNumber: 1)
    }
    if !self.groupEdges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupEdges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.IdentityList, rhs: Google_Cloud_Asset_V1p4beta1_IamPolicyAnalysisResult.IdentityList) -> Bool {
    if lhs.identities != rhs.identities {return false}
    if lhs.groupEdges != rhs.groupEdges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/asset/v1/assets.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An asset in Google Cloud and its temporal metadata, including the time window
/// when it was observed and its status during that window.
public struct Google_Cloud_Asset_V1_TemporalAsset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time window when the asset data and state was observed.
  public var window: Google_Cloud_Asset_V1_TimeWindow {
    get {return _window ?? Google_Cloud_Asset_V1_TimeWindow()}
    set {_window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return self._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {self._window = nil}

  /// Whether the asset has been deleted or not.
  public var deleted: Bool = false

  /// An asset in Google Cloud.
  public var asset: Google_Cloud_Asset_V1_Asset {
    get {return _asset ?? Google_Cloud_Asset_V1_Asset()}
    set {_asset = newValue}
  }
  /// Returns true if `asset` has been explicitly set.
  public var hasAsset: Bool {return self._asset != nil}
  /// Clears the value of `asset`. Subsequent reads from it will return its default value.
  public mutating func clearAsset() {self._asset = nil}

  /// State of prior_asset.
  public var priorAssetState: Google_Cloud_Asset_V1_TemporalAsset.PriorAssetState = .unspecified

  /// Prior copy of the asset. Populated if prior_asset_state is PRESENT.
  /// Currently this is only set for responses in Real-Time Feed.
  public var priorAsset: Google_Cloud_Asset_V1_Asset {
    get {return _priorAsset ?? Google_Cloud_Asset_V1_Asset()}
    set {_priorAsset = newValue}
  }
  /// Returns true if `priorAsset` has been explicitly set.
  public var hasPriorAsset: Bool {return self._priorAsset != nil}
  /// Clears the value of `priorAsset`. Subsequent reads from it will return its default value.
  public mutating func clearPriorAsset() {self._priorAsset = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// State of prior asset.
  public enum PriorAssetState: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// prior_asset is not applicable for the current asset.
    case unspecified // = 0

    /// prior_asset is populated correctly.
    case present // = 1

    /// Failed to set prior_asset.
    case invalid // = 2

    /// Current asset is the first known state.
    case doesNotExist // = 3

    /// prior_asset is a deletion.
    case deleted // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .present
      case 2: self = .invalid
      case 3: self = .doesNotExist
      case 4: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .present: return 1
      case .invalid: return 2
      case .doesNotExist: return 3
      case .deleted: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _window: Google_Cloud_Asset_V1_TimeWindow? = nil
  fileprivate var _asset: Google_Cloud_Asset_V1_Asset? = nil
  fileprivate var _priorAsset: Google_Cloud_Asset_V1_Asset? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Asset_V1_TemporalAsset.PriorAssetState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Asset_V1_TemporalAsset.PriorAssetState] = [
    .unspecified,
    .present,
    .invalid,
    .doesNotExist,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

/// A time window specified by its `start_time` and `end_time`.
public struct Google_Cloud_Asset_V1_TimeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start time of the time window (exclusive).
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// End time of the time window (inclusive). If not specified, the current
  /// timestamp is used instead.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// An asset in Google Cloud. An asset can be any resource in the Google Cloud
/// [resource
/// hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
/// a resource outside the Google Cloud resource hierarchy (such as Google
/// Kubernetes Engine clusters and objects), or a policy (e.g. Cloud IAM policy).
/// See [Supported asset
/// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
/// for more information.
public struct Google_Cloud_Asset_V1_Asset {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The last update timestamp of an asset. update_time is updated when
  /// create/update/delete operation is performed.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// The full name of the asset. Example:
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`
  ///
  /// See [Resource
  /// names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
  /// for more information.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The type of the asset. Example: `compute.googleapis.com/Disk`
  ///
  /// See [Supported asset
  /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
  /// for more information.
  public var assetType: String {
    get {return _storage._assetType}
    set {_uniqueStorage()._assetType = newValue}
  }

  /// A representation of the resource.
  public var resource: Google_Cloud_Asset_V1_Resource {
    get {return _storage._resource ?? Google_Cloud_Asset_V1_Resource()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// A representation of the Cloud IAM policy set on a Google Cloud resource.
  /// There can be a maximum of one Cloud IAM policy set on any given resource.
  /// In addition, Cloud IAM policies inherit their granted access scope from any
  /// policies set on parent resources in the resource hierarchy. Therefore, the
  /// effectively policy is the union of both the policy set on this resource
  /// and each policy set on all of the resource's ancestry resource levels in
  /// the hierarchy. See
  /// [this topic](https://cloud.google.com/iam/docs/policies#inheritance) for
  /// more information.
  public var iamPolicy: Google_Iam_V1_Policy {
    get {return _storage._iamPolicy ?? Google_Iam_V1_Policy()}
    set {_uniqueStorage()._iamPolicy = newValue}
  }
  /// Returns true if `iamPolicy` has been explicitly set.
  public var hasIamPolicy: Bool {return _storage._iamPolicy != nil}
  /// Clears the value of `iamPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearIamPolicy() {_uniqueStorage()._iamPolicy = nil}

  /// A representation of an [organization
  /// policy](https://cloud.google.com/resource-manager/docs/organization-policy/overview#organization_policy).
  /// There can be more than one organization policy with different constraints
  /// set on a given resource.
  public var orgPolicy: [Google_Cloud_Orgpolicy_V1_Policy] {
    get {return _storage._orgPolicy}
    set {_uniqueStorage()._orgPolicy = newValue}
  }

  /// A representation of an [access
  /// policy](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
  public var accessContextPolicy: OneOf_AccessContextPolicy? {
    get {return _storage._accessContextPolicy}
    set {_uniqueStorage()._accessContextPolicy = newValue}
  }

  /// Please also refer to the [access policy user
  /// guide](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
  public var accessPolicy: Google_Identity_Accesscontextmanager_V1_AccessPolicy {
    get {
      if case .accessPolicy(let v)? = _storage._accessContextPolicy {return v}
      return Google_Identity_Accesscontextmanager_V1_AccessPolicy()
    }
    set {_uniqueStorage()._accessContextPolicy = .accessPolicy(newValue)}
  }

  /// Please also refer to the [access level user
  /// guide](https://cloud.google.com/access-context-manager/docs/overview#access-levels).
  public var accessLevel: Google_Identity_Accesscontextmanager_V1_AccessLevel {
    get {
      if case .accessLevel(let v)? = _storage._accessContextPolicy {return v}
      return Google_Identity_Accesscontextmanager_V1_AccessLevel()
    }
    set {_uniqueStorage()._accessContextPolicy = .accessLevel(newValue)}
  }

  /// Please also refer to the [service perimeter user
  /// guide](https://cloud.google.com/vpc-service-controls/docs/overview).
  public var servicePerimeter: Google_Identity_Accesscontextmanager_V1_ServicePerimeter {
    get {
      if case .servicePerimeter(let v)? = _storage._accessContextPolicy {return v}
      return Google_Identity_Accesscontextmanager_V1_ServicePerimeter()
    }
    set {_uniqueStorage()._accessContextPolicy = .servicePerimeter(newValue)}
  }

  /// The ancestry path of an asset in Google Cloud [resource
  /// hierarchy](https://cloud.google.com/resource-manager/docs/cloud-platform-resource-hierarchy),
  /// represented as a list of relative resource names. An ancestry path starts
  /// with the closest ancestor in the hierarchy and ends at root. If the asset
  /// is a project, folder, or organization, the ancestry path starts from the
  /// asset itself.
  ///
  /// Example: `["projects/123456789", "folders/5432", "organizations/1234"]`
  public var ancestors: [String] {
    get {return _storage._ancestors}
    set {_uniqueStorage()._ancestors = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A representation of an [access
  /// policy](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
  public enum OneOf_AccessContextPolicy: Equatable {
    /// Please also refer to the [access policy user
    /// guide](https://cloud.google.com/access-context-manager/docs/overview#access-policies).
    case accessPolicy(Google_Identity_Accesscontextmanager_V1_AccessPolicy)
    /// Please also refer to the [access level user
    /// guide](https://cloud.google.com/access-context-manager/docs/overview#access-levels).
    case accessLevel(Google_Identity_Accesscontextmanager_V1_AccessLevel)
    /// Please also refer to the [service perimeter user
    /// guide](https://cloud.google.com/vpc-service-controls/docs/overview).
    case servicePerimeter(Google_Identity_Accesscontextmanager_V1_ServicePerimeter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1_Asset.OneOf_AccessContextPolicy, rhs: Google_Cloud_Asset_V1_Asset.OneOf_AccessContextPolicy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.accessPolicy, .accessPolicy): return {
        guard case .accessPolicy(let l) = lhs, case .accessPolicy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accessLevel, .accessLevel): return {
        guard case .accessLevel(let l) = lhs, case .accessLevel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.servicePerimeter, .servicePerimeter): return {
        guard case .servicePerimeter(let l) = lhs, case .servicePerimeter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A representation of a Google Cloud resource.
public struct Google_Cloud_Asset_V1_Resource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The API version. Example: `v1`
  public var version: String = String()

  /// The URL of the discovery document containing the resource's JSON schema.
  /// Example:
  /// `https://www.googleapis.com/discovery/v1/apis/compute/v1/rest`
  ///
  /// This value is unspecified for resources that do not have an API based on a
  /// discovery document, such as Cloud Bigtable.
  public var discoveryDocumentUri: String = String()

  /// The JSON schema name listed in the discovery document. Example:
  /// `Project`
  ///
  /// This value is unspecified for resources that do not have an API based on a
  /// discovery document, such as Cloud Bigtable.
  public var discoveryName: String = String()

  /// The REST URL for accessing the resource. An HTTP `GET` request using this
  /// URL returns the resource itself. Example:
  /// `https://cloudresourcemanager.googleapis.com/v1/projects/my-project-123`
  ///
  /// This value is unspecified for resources without a REST API.
  public var resourceURL: String = String()

  /// The full name of the immediate parent of this resource. See
  /// [Resource
  /// Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
  /// for more information.
  ///
  /// For Google Cloud assets, this value is the parent resource defined in the
  /// [Cloud IAM policy
  /// hierarchy](https://cloud.google.com/iam/docs/overview#policy_hierarchy).
  /// Example:
  /// `//cloudresourcemanager.googleapis.com/projects/my_project_123`
  ///
  /// For third-party assets, this field may be set differently.
  public var parent: String = String()

  /// The content of the resource, in which some sensitive fields are removed
  /// and may not be present.
  public var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  /// The location of the resource in Google Cloud, such as its zone and region.
  /// For more information, see https://cloud.google.com/about/locations/.
  public var location: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// A result of Resource Search, containing information of a cloud resource.
public struct Google_Cloud_Asset_V1_ResourceSearchResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full resource name of this resource. Example:
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
  /// See [Cloud Asset Inventory Resource Name
  /// Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
  /// for more information.
  ///
  /// To search against the `name`:
  ///
  /// * use a field query. Example: `name:instance1`
  /// * use a free text query. Example: `instance1`
  public var name: String = String()

  /// The type of this resource. Example: `compute.googleapis.com/Disk`.
  ///
  /// To search against the `asset_type`:
  ///
  /// * specify the `asset_type` field in your search request.
  public var assetType: String = String()

  /// The project that this resource belongs to, in the form of
  /// projects/{PROJECT_NUMBER}.
  ///
  /// To search against the `project`:
  ///
  /// * specify the `scope` field as this project in your search request.
  public var project: String = String()

  /// The display name of this resource.
  ///
  /// To search against the `display_name`:
  ///
  /// * use a field query. Example: `displayName:"My Instance"`
  /// * use a free text query. Example: `"My Instance"`
  public var displayName: String = String()

  /// One or more paragraphs of text description of this resource. Maximum length
  /// could be up to 1M bytes.
  ///
  /// To search against the `description`:
  ///
  /// * use a field query. Example: `description:"*important instance*"`
  /// * use a free text query. Example: `"*important instance*"`
  public var description_p: String = String()

  /// Location can be `global`, regional like `us-east1`, or zonal like
  /// `us-west1-b`.
  ///
  /// To search against the `location`:
  ///
  /// * use a field query. Example: `location:us-west*`
  /// * use a free text query. Example: `us-west*`
  public var location: String = String()

  /// Labels associated with this resource. See [Labelling and grouping GCP
  /// resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
  /// for more information.
  ///
  /// To search against the `labels`:
  ///
  /// * use a field query:
  ///     - query on any label's key or value. Example: `labels:prod`
  ///     - query by a given label. Example: `labels.env:prod`
  ///     - query by a given label's existence. Example: `labels.env:*`
  /// * use a free text query. Example: `prod`
  public var labels: Dictionary<String,String> = [:]

  /// Network tags associated with this resource. Like labels, network tags are a
  /// type of annotations used to group GCP resources. See [Labelling GCP
  /// resources](https://cloud.google.com/blog/products/gcp/labelling-and-grouping-your-google-cloud-platform-resources)
  /// for more information.
  ///
  /// To search against the `network_tags`:
  ///
  /// * use a field query. Example: `networkTags:internal`
  /// * use a free text query. Example: `internal`
  public var networkTags: [String] = []

  /// The additional searchable attributes of this resource. The attributes may
  /// vary from one resource type to another. Examples: `projectId` for Project,
  /// `dnsName` for DNS ManagedZone. This field contains a subset of the resource
  /// metadata fields that are returned by the List or Get APIs provided by the
  /// corresponding GCP service (e.g., Compute Engine). see [API references and
  /// supported searchable
  /// attributes](https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types)
  /// for more information.
  ///
  /// You can search values of these fields through free text search. However,
  /// you should not consume the field programically as the field names and
  /// values may change as the GCP service updates to a new incompatible API
  /// version.
  ///
  /// To search against the `additional_attributes`:
  ///
  /// * use a free text query to match the attributes values. Example: to search
  ///   `additional_attributes = { dnsName: "foobar" }`, you can issue a query
  ///   `foobar`.
  public var additionalAttributes: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _additionalAttributes ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_additionalAttributes = newValue}
  }
  /// Returns true if `additionalAttributes` has been explicitly set.
  public var hasAdditionalAttributes: Bool {return self._additionalAttributes != nil}
  /// Clears the value of `additionalAttributes`. Subsequent reads from it will return its default value.
  public mutating func clearAdditionalAttributes() {self._additionalAttributes = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _additionalAttributes: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

/// A result of IAM Policy search, containing information of an IAM policy.
public struct Google_Cloud_Asset_V1_IamPolicySearchResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full resource name of the resource associated with this IAM policy.
  /// Example:
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
  /// See [Cloud Asset Inventory Resource Name
  /// Format](https://cloud.google.com/asset-inventory/docs/resource-name-format)
  /// for more information.
  ///
  /// To search against the `resource`:
  ///
  /// * use a field query. Example: `resource:organizations/123`
  public var resource: String = String()

  /// The project that the associated GCP resource belongs to, in the form of
  /// projects/{PROJECT_NUMBER}. If an IAM policy is set on a resource (like VM
  /// instance, Cloud Storage bucket), the project field will indicate the
  /// project that contains the resource. If an IAM policy is set on a folder or
  /// orgnization, the project field will be empty.
  ///
  /// To search against the `project`:
  ///
  /// * specify the `scope` field as this project in your search request.
  public var project: String = String()

  /// The IAM policy directly set on the given resource. Note that the original
  /// IAM policy can contain multiple bindings. This only contains the bindings
  /// that match the given query. For queries that don't contain a constrain on
  /// policies (e.g., an empty query), this contains all the bindings.
  ///
  /// To search against the `policy` bindings:
  ///
  /// * use a field query:
  ///     - query by the policy contained members. Example:
  ///       `policy:amy@gmail.com`
  ///     - query by the policy contained roles. Example:
  ///       `policy:roles/compute.admin`
  ///     - query by the policy contained roles' included permissions. Example:
  ///       `policy.role.permissions:compute.instances.create`
  public var policy: Google_Iam_V1_Policy {
    get {return _policy ?? Google_Iam_V1_Policy()}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  public var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  public mutating func clearPolicy() {self._policy = nil}

  /// Explanation about the IAM policy search result. It contains additional
  /// information to explain why the search result matches the query.
  public var explanation: Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation {
    get {return _explanation ?? Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation()}
    set {_explanation = newValue}
  }
  /// Returns true if `explanation` has been explicitly set.
  public var hasExplanation: Bool {return self._explanation != nil}
  /// Clears the value of `explanation`. Subsequent reads from it will return its default value.
  public mutating func clearExplanation() {self._explanation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Explanation about the IAM policy search result.
  public struct Explanation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The map from roles to their included permissions that match the
    /// permission query (i.e., a query containing `policy.role.permissions:`).
    /// Example: if query `policy.role.permissions:compute.disk.get`
    /// matches a policy binding that contains owner role, the
    /// matched_permissions will be `{"roles/owner": ["compute.disk.get"]}`. The
    /// roles can also be found in the returned `policy` bindings. Note that the
    /// map is populated only for requests with permission queries.
    public var matchedPermissions: Dictionary<String,Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.Permissions> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// IAM permissions
    public struct Permissions {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A list of permissions. A sample permission string: `compute.disk.get`.
      public var permissions: [String] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _policy: Google_Iam_V1_Policy? = nil
  fileprivate var _explanation: Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation? = nil
}

/// Represents the detailed state of an entity under analysis, such as a
/// resource, an identity or an access.
public struct Google_Cloud_Asset_V1_IamPolicyAnalysisState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Google standard error code that best describes the state.
  /// For example:
  /// - OK means the analysis on this entity has been successfully finished;
  /// - PERMISSION_DENIED means an access denied error is encountered;
  /// - DEADLINE_EXCEEDED means the analysis on this entity hasn't been started
  /// in time;
  public var code: Google_Rpc_Code = .ok

  /// The human-readable description of the cause of failure.
  public var cause: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IAM Policy analysis result, consisting of one IAM policy binding and derived
/// access control lists.
public struct Google_Cloud_Asset_V1_IamPolicyAnalysisResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The [full resource
  /// name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
  /// of the resource to which the [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding] policy attaches.
  public var attachedResourceFullName: String = String()

  /// The Cloud IAM policy binding under analysis.
  public var iamBinding: Google_Iam_V1_Binding {
    get {return _iamBinding ?? Google_Iam_V1_Binding()}
    set {_iamBinding = newValue}
  }
  /// Returns true if `iamBinding` has been explicitly set.
  public var hasIamBinding: Bool {return self._iamBinding != nil}
  /// Clears the value of `iamBinding`. Subsequent reads from it will return its default value.
  public mutating func clearIamBinding() {self._iamBinding = nil}

  /// The access control lists derived from the [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding] that match or
  /// potentially match resource and access selectors specified in the request.
  public var accessControlLists: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult.AccessControlList] = []

  /// The identity list derived from members of the [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding] that match or
  /// potentially match identity selector specified in the request.
  public var identityList: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.IdentityList {
    get {return _identityList ?? Google_Cloud_Asset_V1_IamPolicyAnalysisResult.IdentityList()}
    set {_identityList = newValue}
  }
  /// Returns true if `identityList` has been explicitly set.
  public var hasIdentityList: Bool {return self._identityList != nil}
  /// Clears the value of `identityList`. Subsequent reads from it will return its default value.
  public mutating func clearIdentityList() {self._identityList = nil}

  /// Represents whether all analyses on the [iam_binding][google.cloud.asset.v1.IamPolicyAnalysisResult.iam_binding] have successfully
  /// finished.
  public var fullyExplored: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A Google Cloud resource under analysis.
  public struct Resource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The [full resource
    /// name](https://cloud.google.com/asset-inventory/docs/resource-name-format)
    public var fullResourceName: String = String()

    /// The analysis state of this resource.
    public var analysisState: Google_Cloud_Asset_V1_IamPolicyAnalysisState {
      get {return _analysisState ?? Google_Cloud_Asset_V1_IamPolicyAnalysisState()}
      set {_analysisState = newValue}
    }
    /// Returns true if `analysisState` has been explicitly set.
    public var hasAnalysisState: Bool {return self._analysisState != nil}
    /// Clears the value of `analysisState`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisState() {self._analysisState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _analysisState: Google_Cloud_Asset_V1_IamPolicyAnalysisState? = nil
  }

  /// An IAM role or permission under analysis.
  public struct Access {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var oneofAccess: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access.OneOf_OneofAccess? = nil

    /// The role.
    public var role: String {
      get {
        if case .role(let v)? = oneofAccess {return v}
        return String()
      }
      set {oneofAccess = .role(newValue)}
    }

    /// The permission.
    public var permission: String {
      get {
        if case .permission(let v)? = oneofAccess {return v}
        return String()
      }
      set {oneofAccess = .permission(newValue)}
    }

    /// The analysis state of this access.
    public var analysisState: Google_Cloud_Asset_V1_IamPolicyAnalysisState {
      get {return _analysisState ?? Google_Cloud_Asset_V1_IamPolicyAnalysisState()}
      set {_analysisState = newValue}
    }
    /// Returns true if `analysisState` has been explicitly set.
    public var hasAnalysisState: Bool {return self._analysisState != nil}
    /// Clears the value of `analysisState`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisState() {self._analysisState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_OneofAccess: Equatable {
      /// The role.
      case role(String)
      /// The permission.
      case permission(String)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access.OneOf_OneofAccess, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access.OneOf_OneofAccess) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.role, .role): return {
          guard case .role(let l) = lhs, case .role(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.permission, .permission): return {
          guard case .permission(let l) = lhs, case .permission(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _analysisState: Google_Cloud_Asset_V1_IamPolicyAnalysisState? = nil
  }

  /// An identity under analysis.
  public struct Identity {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity name in any form of members appear in
    /// [IAM policy
    /// binding](https://cloud.google.com/iam/reference/rest/v1/Binding), such
    /// as:
    /// - user:foo@google.com
    /// - group:group1@google.com
    /// - serviceAccount:s1@prj1.iam.gserviceaccount.com
    /// - projectOwner:some_project_id
    /// - domain:google.com
    /// - allUsers
    /// - etc.
    public var name: String = String()

    /// The analysis state of this identity.
    public var analysisState: Google_Cloud_Asset_V1_IamPolicyAnalysisState {
      get {return _analysisState ?? Google_Cloud_Asset_V1_IamPolicyAnalysisState()}
      set {_analysisState = newValue}
    }
    /// Returns true if `analysisState` has been explicitly set.
    public var hasAnalysisState: Bool {return self._analysisState != nil}
    /// Clears the value of `analysisState`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisState() {self._analysisState = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _analysisState: Google_Cloud_Asset_V1_IamPolicyAnalysisState? = nil
  }

  /// A directional edge.
  public struct Edge {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The source node of the edge. For example, it could be a full resource
    /// name for a resource node or an email of an identity.
    public var sourceNode: String = String()

    /// The target node of the edge. For example, it could be a full resource
    /// name for a resource node or an email of an identity.
    public var targetNode: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// An access control list, derived from the above IAM policy binding, which
  /// contains a set of resources and accesses. May include one
  /// item from each set to compose an access control entry.
  ///
  /// NOTICE that there could be multiple access control lists for one IAM policy
  /// binding. The access control lists are created based on resource and access
  /// combinations.
  ///
  /// For example, assume we have the following cases in one IAM policy binding:
  /// - Permission P1 and P2 apply to resource R1 and R2;
  /// - Permission P3 applies to resource R2 and R3;
  ///
  /// This will result in the following access control lists:
  /// - AccessControlList 1: [R1, R2], [P1, P2]
  /// - AccessControlList 2: [R2, R3], [P3]
  public struct AccessControlList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The resources that match one of the following conditions:
    /// - The resource_selector, if it is specified in request;
    /// - Otherwise, resources reachable from the policy attached resource.
    public var resources: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Resource] = []

    /// The accesses that match one of the following conditions:
    /// - The access_selector, if it is specified in request;
    /// - Otherwise, access specifiers reachable from the policy binding's role.
    public var accesses: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access] = []

    /// Resource edges of the graph starting from the policy attached
    /// resource to any descendant resources. The [Edge.source_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node] contains
    /// the full resource name of a parent resource and [Edge.target_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node]
    /// contains the full resource name of a child resource. This field is
    /// present only if the output_resource_edges option is enabled in request.
    public var resourceEdges: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Edge] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// The identities and group edges.
  public struct IdentityList {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only the identities that match one of the following conditions will be
    /// presented:
    /// - The identity_selector, if it is specified in request;
    /// - Otherwise, identities reachable from the policy binding's members.
    public var identities: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Identity] = []

    /// Group identity edges of the graph starting from the binding's
    /// group members to any node of the [identities][google.cloud.asset.v1.IamPolicyAnalysisResult.IdentityList.identities]. The [Edge.source_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.source_node]
    /// contains a group, such as `group:parent@google.com`. The
    /// [Edge.target_node][google.cloud.asset.v1.IamPolicyAnalysisResult.Edge.target_node] contains a member of the group,
    /// such as `group:child@google.com` or `user:foo@google.com`.
    /// This field is present only if the output_group_edges option is enabled in
    /// request.
    public var groupEdges: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Edge] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _iamBinding: Google_Iam_V1_Binding? = nil
  fileprivate var _identityList: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.IdentityList? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.asset.v1"

extension Google_Cloud_Asset_V1_TemporalAsset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TemporalAsset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "window"),
    2: .same(proto: "deleted"),
    3: .same(proto: "asset"),
    4: .standard(proto: "prior_asset_state"),
    5: .standard(proto: "prior_asset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._window) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._asset) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.priorAssetState) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._priorAsset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._window {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 2)
    }
    if let v = self._asset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.priorAssetState != .unspecified {
      try visitor.visitSingularEnumField(value: self.priorAssetState, fieldNumber: 4)
    }
    if let v = self._priorAsset {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_TemporalAsset, rhs: Google_Cloud_Asset_V1_TemporalAsset) -> Bool {
    if lhs._window != rhs._window {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs._asset != rhs._asset {return false}
    if lhs.priorAssetState != rhs.priorAssetState {return false}
    if lhs._priorAsset != rhs._priorAsset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_TemporalAsset.PriorAssetState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIOR_ASSET_STATE_UNSPECIFIED"),
    1: .same(proto: "PRESENT"),
    2: .same(proto: "INVALID"),
    3: .same(proto: "DOES_NOT_EXIST"),
    4: .same(proto: "DELETED"),
  ]
}

extension Google_Cloud_Asset_V1_TimeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_TimeWindow, rhs: Google_Cloud_Asset_V1_TimeWindow) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_Asset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Asset"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "update_time"),
    1: .same(proto: "name"),
    2: .standard(proto: "asset_type"),
    3: .same(proto: "resource"),
    4: .standard(proto: "iam_policy"),
    6: .standard(proto: "org_policy"),
    7: .standard(proto: "access_policy"),
    8: .standard(proto: "access_level"),
    9: .standard(proto: "service_perimeter"),
    10: .same(proto: "ancestors"),
  ]

  fileprivate class _StorageClass {
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _name: String = String()
    var _assetType: String = String()
    var _resource: Google_Cloud_Asset_V1_Resource? = nil
    var _iamPolicy: Google_Iam_V1_Policy? = nil
    var _orgPolicy: [Google_Cloud_Orgpolicy_V1_Policy] = []
    var _accessContextPolicy: Google_Cloud_Asset_V1_Asset.OneOf_AccessContextPolicy?
    var _ancestors: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _updateTime = source._updateTime
      _name = source._name
      _assetType = source._assetType
      _resource = source._resource
      _iamPolicy = source._iamPolicy
      _orgPolicy = source._orgPolicy
      _accessContextPolicy = source._accessContextPolicy
      _ancestors = source._ancestors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._assetType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._iamPolicy) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._orgPolicy) }()
        case 7: try {
          var v: Google_Identity_Accesscontextmanager_V1_AccessPolicy?
          if let current = _storage._accessContextPolicy {
            try decoder.handleConflictingOneOf()
            if case .accessPolicy(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._accessContextPolicy = .accessPolicy(v)}
        }()
        case 8: try {
          var v: Google_Identity_Accesscontextmanager_V1_AccessLevel?
          if let current = _storage._accessContextPolicy {
            try decoder.handleConflictingOneOf()
            if case .accessLevel(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._accessContextPolicy = .accessLevel(v)}
        }()
        case 9: try {
          var v: Google_Identity_Accesscontextmanager_V1_ServicePerimeter?
          if let current = _storage._accessContextPolicy {
            try decoder.handleConflictingOneOf()
            if case .servicePerimeter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._accessContextPolicy = .servicePerimeter(v)}
        }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._ancestors) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._assetType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetType, fieldNumber: 2)
      }
      if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._iamPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._orgPolicy.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._orgPolicy, fieldNumber: 6)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._accessContextPolicy {
      case .accessPolicy?: try {
        guard case .accessPolicy(let v)? = _storage._accessContextPolicy else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .accessLevel?: try {
        guard case .accessLevel(let v)? = _storage._accessContextPolicy else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .servicePerimeter?: try {
        guard case .servicePerimeter(let v)? = _storage._accessContextPolicy else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      if !_storage._ancestors.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ancestors, fieldNumber: 10)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_Asset, rhs: Google_Cloud_Asset_V1_Asset) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._assetType != rhs_storage._assetType {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._iamPolicy != rhs_storage._iamPolicy {return false}
        if _storage._orgPolicy != rhs_storage._orgPolicy {return false}
        if _storage._accessContextPolicy != rhs_storage._accessContextPolicy {return false}
        if _storage._ancestors != rhs_storage._ancestors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "discovery_document_uri"),
    3: .standard(proto: "discovery_name"),
    4: .standard(proto: "resource_url"),
    5: .same(proto: "parent"),
    6: .same(proto: "data"),
    8: .same(proto: "location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.discoveryDocumentUri) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.discoveryName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.location) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if !self.discoveryDocumentUri.isEmpty {
      try visitor.visitSingularStringField(value: self.discoveryDocumentUri, fieldNumber: 2)
    }
    if !self.discoveryName.isEmpty {
      try visitor.visitSingularStringField(value: self.discoveryName, fieldNumber: 3)
    }
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 4)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_Resource, rhs: Google_Cloud_Asset_V1_Resource) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.discoveryDocumentUri != rhs.discoveryDocumentUri {return false}
    if lhs.discoveryName != rhs.discoveryName {return false}
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs._data != rhs._data {return false}
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_ResourceSearchResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceSearchResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "asset_type"),
    3: .same(proto: "project"),
    4: .standard(proto: "display_name"),
    5: .same(proto: "description"),
    6: .same(proto: "location"),
    7: .same(proto: "labels"),
    8: .standard(proto: "network_tags"),
    9: .standard(proto: "additional_attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.assetType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.networkTags) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._additionalAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.assetType.isEmpty {
      try visitor.visitSingularStringField(value: self.assetType, fieldNumber: 2)
    }
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 3)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 6)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 7)
    }
    if !self.networkTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.networkTags, fieldNumber: 8)
    }
    if let v = self._additionalAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_ResourceSearchResult, rhs: Google_Cloud_Asset_V1_ResourceSearchResult) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.assetType != rhs.assetType {return false}
    if lhs.project != rhs.project {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.location != rhs.location {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.networkTags != rhs.networkTags {return false}
    if lhs._additionalAttributes != rhs._additionalAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicySearchResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IamPolicySearchResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .same(proto: "project"),
    3: .same(proto: "policy"),
    4: .same(proto: "explanation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resource) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._policy) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._explanation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resource.isEmpty {
      try visitor.visitSingularStringField(value: self.resource, fieldNumber: 1)
    }
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 2)
    }
    if let v = self._policy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._explanation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicySearchResult, rhs: Google_Cloud_Asset_V1_IamPolicySearchResult) -> Bool {
    if lhs.resource != rhs.resource {return false}
    if lhs.project != rhs.project {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs._explanation != rhs._explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicySearchResult.protoMessageName + ".Explanation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "matched_permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.Permissions>.self, value: &self.matchedPermissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.matchedPermissions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.Permissions>.self, value: self.matchedPermissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation, rhs: Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation) -> Bool {
    if lhs.matchedPermissions != rhs.matchedPermissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.protoMessageName + ".Permissions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.Permissions, rhs: Google_Cloud_Asset_V1_IamPolicySearchResult.Explanation.Permissions) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IamPolicyAnalysisState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "cause"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cause) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .ok {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.cause.isEmpty {
      try visitor.visitSingularStringField(value: self.cause, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisState, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisState) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IamPolicyAnalysisResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "attached_resource_full_name"),
    2: .standard(proto: "iam_binding"),
    3: .standard(proto: "access_control_lists"),
    4: .standard(proto: "identity_list"),
    5: .standard(proto: "fully_explored"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.attachedResourceFullName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._iamBinding) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.accessControlLists) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._identityList) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.fullyExplored) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachedResourceFullName.isEmpty {
      try visitor.visitSingularStringField(value: self.attachedResourceFullName, fieldNumber: 1)
    }
    if let v = self._iamBinding {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.accessControlLists.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accessControlLists, fieldNumber: 3)
    }
    if let v = self._identityList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.fullyExplored != false {
      try visitor.visitSingularBoolField(value: self.fullyExplored, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult) -> Bool {
    if lhs.attachedResourceFullName != rhs.attachedResourceFullName {return false}
    if lhs._iamBinding != rhs._iamBinding {return false}
    if lhs.accessControlLists != rhs.accessControlLists {return false}
    if lhs._identityList != rhs._identityList {return false}
    if lhs.fullyExplored != rhs.fullyExplored {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisResult.protoMessageName + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_resource_name"),
    2: .standard(proto: "analysis_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._analysisState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 1)
    }
    if let v = self._analysisState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Resource, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Resource) -> Bool {
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs._analysisState != rhs._analysisState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisResult.protoMessageName + ".Access"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "role"),
    2: .same(proto: "permission"),
    3: .standard(proto: "analysis_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.oneofAccess != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.oneofAccess = .role(v)}
      }()
      case 2: try {
        if self.oneofAccess != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.oneofAccess = .permission(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._analysisState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.oneofAccess {
    case .role?: try {
      guard case .role(let v)? = self.oneofAccess else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .permission?: try {
      guard case .permission(let v)? = self.oneofAccess else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._analysisState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Access) -> Bool {
    if lhs.oneofAccess != rhs.oneofAccess {return false}
    if lhs._analysisState != rhs._analysisState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Identity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisResult.protoMessageName + ".Identity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "analysis_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._analysisState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._analysisState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Identity, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Identity) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._analysisState != rhs._analysisState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Edge: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisResult.protoMessageName + ".Edge"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_node"),
    2: .standard(proto: "target_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceNode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetNode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceNode.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceNode, fieldNumber: 1)
    }
    if !self.targetNode.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNode, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Edge, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.Edge) -> Bool {
    if lhs.sourceNode != rhs.sourceNode {return false}
    if lhs.targetNode != rhs.targetNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult.AccessControlList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisResult.protoMessageName + ".AccessControlList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resources"),
    2: .same(proto: "accesses"),
    3: .standard(proto: "resource_edges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.accesses) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.resourceEdges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 1)
    }
    if !self.accesses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accesses, fieldNumber: 2)
    }
    if !self.resourceEdges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceEdges, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.AccessControlList, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.AccessControlList) -> Bool {
    if lhs.resources != rhs.resources {return false}
    if lhs.accesses != rhs.accesses {return false}
    if lhs.resourceEdges != rhs.resourceEdges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisResult.IdentityList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisResult.protoMessageName + ".IdentityList"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identities"),
    2: .standard(proto: "group_edges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.identities) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groupEdges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identities.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identities, fieldNumber: 1)
    }
    if !self.groupEdges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupEdges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.IdentityList, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisResult.IdentityList) -> Bool {
    if lhs.identities != rhs.identities {return false}
    if lhs.groupEdges != rhs.groupEdges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/asset/v1/asset_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Asset content type.
public enum Google_Cloud_Asset_V1_ContentType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified content type.
  case unspecified // = 0

  /// Resource metadata.
  case resource // = 1

  /// The actual IAM policy set on a resource.
  case iamPolicy // = 2

  /// The Cloud Organization Policy set on an asset.
  case orgPolicy // = 4

  /// The Cloud Access context manager Policy set on an asset.
  case accessPolicy // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .resource
    case 2: self = .iamPolicy
    case 4: self = .orgPolicy
    case 5: self = .accessPolicy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .resource: return 1
    case .iamPolicy: return 2
    case .orgPolicy: return 4
    case .accessPolicy: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Asset_V1_ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Asset_V1_ContentType] = [
    .unspecified,
    .resource,
    .iamPolicy,
    .orgPolicy,
    .accessPolicy,
  ]
}

#endif  // swift(>=4.2)

/// Export asset request.
public struct Google_Cloud_Asset_V1_ExportAssetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative name of the root asset. This can only be an
  /// organization number (such as "organizations/123"), a project ID (such as
  /// "projects/my-project-id"), or a project number (such as "projects/12345"),
  /// or a folder number (such as "folders/123").
  public var parent: String = String()

  /// Timestamp to take an asset snapshot. This can only be set to a timestamp
  /// between the current time and the current time minus 35 days (inclusive).
  /// If not specified, the current time will be used. Due to delays in resource
  /// data collection and indexing, there is a volatile window during which
  /// running the same query may get different results.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  /// A list of asset types to take a snapshot for. For example:
  /// "compute.googleapis.com/Disk".
  ///
  /// Regular expressions are also supported. For example:
  ///
  /// * "compute.googleapis.com.*" snapshots resources whose asset type starts
  /// with "compute.googleapis.com".
  /// * ".*Instance" snapshots resources whose asset type ends with "Instance".
  /// * ".*Instance.*" snapshots resources whose asset type contains "Instance".
  ///
  /// See [RE2](https://github.com/google/re2/wiki/Syntax) for all supported
  /// regular expression syntax. If the regular expression does not match any
  /// supported asset type, an INVALID_ARGUMENT error will be returned.
  ///
  /// If specified, only matching assets will be returned, otherwise, it will
  /// snapshot all asset types. See [Introduction to Cloud Asset
  /// Inventory](https://cloud.google.com/asset-inventory/docs/overview)
  /// for all supported asset types.
  public var assetTypes: [String] = []

  /// Asset content type. If not specified, no content but the asset name will be
  /// returned.
  public var contentType: Google_Cloud_Asset_V1_ContentType = .unspecified

  /// Required. Output configuration indicating where the results will be output to.
  public var outputConfig: Google_Cloud_Asset_V1_OutputConfig {
    get {return _outputConfig ?? Google_Cloud_Asset_V1_OutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {self._outputConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outputConfig: Google_Cloud_Asset_V1_OutputConfig? = nil
}

/// The export asset response. This message is returned by the
/// [google.longrunning.Operations.GetOperation][google.longrunning.Operations.GetOperation] method in the returned
/// [google.longrunning.Operation.response][google.longrunning.Operation.response] field.
public struct Google_Cloud_Asset_V1_ExportAssetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time the snapshot was taken.
  public var readTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTime = newValue}
  }
  /// Returns true if `readTime` has been explicitly set.
  public var hasReadTime: Bool {return self._readTime != nil}
  /// Clears the value of `readTime`. Subsequent reads from it will return its default value.
  public mutating func clearReadTime() {self._readTime = nil}

  /// Output configuration indicating where the results were output to.
  public var outputConfig: Google_Cloud_Asset_V1_OutputConfig {
    get {return _outputConfig ?? Google_Cloud_Asset_V1_OutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {self._outputConfig = nil}

  /// Output result indicating where the assets were exported to. For example, a
  /// set of actual Google Cloud Storage object uris where the assets are
  /// exported to. The uris can be different from what [output_config] has
  /// specified, as the service will split the output object into multiple ones
  /// once it exceeds a single Google Cloud Storage object limit.
  public var outputResult: Google_Cloud_Asset_V1_OutputResult {
    get {return _outputResult ?? Google_Cloud_Asset_V1_OutputResult()}
    set {_outputResult = newValue}
  }
  /// Returns true if `outputResult` has been explicitly set.
  public var hasOutputResult: Bool {return self._outputResult != nil}
  /// Clears the value of `outputResult`. Subsequent reads from it will return its default value.
  public mutating func clearOutputResult() {self._outputResult = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _outputConfig: Google_Cloud_Asset_V1_OutputConfig? = nil
  fileprivate var _outputResult: Google_Cloud_Asset_V1_OutputResult? = nil
}

/// Batch get assets history request.
public struct Google_Cloud_Asset_V1_BatchGetAssetsHistoryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative name of the root asset. It can only be an
  /// organization number (such as "organizations/123"), a project ID (such as
  /// "projects/my-project-id")", or a project number (such as "projects/12345").
  public var parent: String = String()

  /// A list of the full names of the assets.
  /// See: https://cloud.google.com/asset-inventory/docs/resource-name-format
  /// Example:
  ///
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
  ///
  /// The request becomes a no-op if the asset name list is empty, and the max
  /// size of the asset name list is 100 in one request.
  public var assetNames: [String] = []

  /// Optional. The content type.
  public var contentType: Google_Cloud_Asset_V1_ContentType = .unspecified

  /// Optional. The time window for the asset history. Both start_time and
  /// end_time are optional and if set, it must be after the current time minus
  /// 35 days. If end_time is not set, it is default to current timestamp.
  /// If start_time is not set, the snapshot of the assets at end_time will be
  /// returned. The returned results contain all temporal assets whose time
  /// window overlap with read_time_window.
  public var readTimeWindow: Google_Cloud_Asset_V1_TimeWindow {
    get {return _readTimeWindow ?? Google_Cloud_Asset_V1_TimeWindow()}
    set {_readTimeWindow = newValue}
  }
  /// Returns true if `readTimeWindow` has been explicitly set.
  public var hasReadTimeWindow: Bool {return self._readTimeWindow != nil}
  /// Clears the value of `readTimeWindow`. Subsequent reads from it will return its default value.
  public mutating func clearReadTimeWindow() {self._readTimeWindow = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTimeWindow: Google_Cloud_Asset_V1_TimeWindow? = nil
}

/// Batch get assets history response.
public struct Google_Cloud_Asset_V1_BatchGetAssetsHistoryResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of assets with valid time windows.
  public var assets: [Google_Cloud_Asset_V1_TemporalAsset] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Create asset feed request.
public struct Google_Cloud_Asset_V1_CreateFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project/folder/organization where this feed
  /// should be created in. It can only be an organization number (such as
  /// "organizations/123"), a folder number (such as "folders/123"), a project ID
  /// (such as "projects/my-project-id")", or a project number (such as
  /// "projects/12345").
  public var parent: String = String()

  /// Required. This is the client-assigned asset feed identifier and it needs to
  /// be unique under a specific parent project/folder/organization.
  public var feedID: String = String()

  /// Required. The feed details. The field `name` must be empty and it will be generated
  /// in the format of:
  /// projects/project_number/feeds/feed_id
  /// folders/folder_number/feeds/feed_id
  /// organizations/organization_number/feeds/feed_id
  public var feed: Google_Cloud_Asset_V1_Feed {
    get {return _feed ?? Google_Cloud_Asset_V1_Feed()}
    set {_feed = newValue}
  }
  /// Returns true if `feed` has been explicitly set.
  public var hasFeed: Bool {return self._feed != nil}
  /// Clears the value of `feed`. Subsequent reads from it will return its default value.
  public mutating func clearFeed() {self._feed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feed: Google_Cloud_Asset_V1_Feed? = nil
}

/// Get asset feed request.
public struct Google_Cloud_Asset_V1_GetFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Feed and it must be in the format of:
  /// projects/project_number/feeds/feed_id
  /// folders/folder_number/feeds/feed_id
  /// organizations/organization_number/feeds/feed_id
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// List asset feeds request.
public struct Google_Cloud_Asset_V1_ListFeedsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent project/folder/organization whose feeds are to be
  /// listed. It can only be using project/folder/organization number (such as
  /// "folders/12345")", or a project ID (such as "projects/my-project-id").
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Asset_V1_ListFeedsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of feeds.
  public var feeds: [Google_Cloud_Asset_V1_Feed] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update asset feed request.
public struct Google_Cloud_Asset_V1_UpdateFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The new values of feed details. It must match an existing feed and the
  /// field `name` must be in the format of:
  /// projects/project_number/feeds/feed_id or
  /// folders/folder_number/feeds/feed_id or
  /// organizations/organization_number/feeds/feed_id.
  public var feed: Google_Cloud_Asset_V1_Feed {
    get {return _feed ?? Google_Cloud_Asset_V1_Feed()}
    set {_feed = newValue}
  }
  /// Returns true if `feed` has been explicitly set.
  public var hasFeed: Bool {return self._feed != nil}
  /// Clears the value of `feed`. Subsequent reads from it will return its default value.
  public mutating func clearFeed() {self._feed = nil}

  /// Required. Only updates the `feed` fields indicated by this mask.
  /// The field mask must not be empty, and it must not contain fields that
  /// are immutable or only set by the server.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feed: Google_Cloud_Asset_V1_Feed? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Cloud_Asset_V1_DeleteFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the feed and it must be in the format of:
  /// projects/project_number/feeds/feed_id
  /// folders/folder_number/feeds/feed_id
  /// organizations/organization_number/feeds/feed_id
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Output configuration for export assets destination.
public struct Google_Cloud_Asset_V1_OutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asset export destination.
  public var destination: Google_Cloud_Asset_V1_OutputConfig.OneOf_Destination? = nil

  /// Destination on Cloud Storage.
  public var gcsDestination: Google_Cloud_Asset_V1_GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1_GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  /// Destination on BigQuery. The output table stores the fields in asset
  /// proto as columns in BigQuery.
  public var bigqueryDestination: Google_Cloud_Asset_V1_BigQueryDestination {
    get {
      if case .bigqueryDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1_BigQueryDestination()
    }
    set {destination = .bigqueryDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Asset export destination.
  public enum OneOf_Destination: Equatable {
    /// Destination on Cloud Storage.
    case gcsDestination(Google_Cloud_Asset_V1_GcsDestination)
    /// Destination on BigQuery. The output table stores the fields in asset
    /// proto as columns in BigQuery.
    case bigqueryDestination(Google_Cloud_Asset_V1_BigQueryDestination)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1_OutputConfig.OneOf_Destination, rhs: Google_Cloud_Asset_V1_OutputConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsDestination, .gcsDestination): return {
        guard case .gcsDestination(let l) = lhs, case .gcsDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigqueryDestination, .bigqueryDestination): return {
        guard case .bigqueryDestination(let l) = lhs, case .bigqueryDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Output result of export assets.
public struct Google_Cloud_Asset_V1_OutputResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asset export result.
  public var result: Google_Cloud_Asset_V1_OutputResult.OneOf_Result? = nil

  /// Export result on Cloud Storage.
  public var gcsResult: Google_Cloud_Asset_V1_GcsOutputResult {
    get {
      if case .gcsResult(let v)? = result {return v}
      return Google_Cloud_Asset_V1_GcsOutputResult()
    }
    set {result = .gcsResult(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Asset export result.
  public enum OneOf_Result: Equatable {
    /// Export result on Cloud Storage.
    case gcsResult(Google_Cloud_Asset_V1_GcsOutputResult)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1_OutputResult.OneOf_Result, rhs: Google_Cloud_Asset_V1_OutputResult.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsResult, .gcsResult): return {
        guard case .gcsResult(let l) = lhs, case .gcsResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A Cloud Storage output result.
public struct Google_Cloud_Asset_V1_GcsOutputResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of uris of the Cloud Storage objects. Example:
  /// "gs://bucket_name/object_name".
  public var uris: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Cloud Storage location.
public struct Google_Cloud_Asset_V1_GcsDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  public var objectUri: Google_Cloud_Asset_V1_GcsDestination.OneOf_ObjectUri? = nil

  /// The uri of the Cloud Storage object. It's the same uri that is used by
  /// gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
  /// Editing Object
  /// Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
  /// for more information.
  public var uri: String {
    get {
      if case .uri(let v)? = objectUri {return v}
      return String()
    }
    set {objectUri = .uri(newValue)}
  }

  /// The uri prefix of all generated Cloud Storage objects. Example:
  /// "gs://bucket_name/object_name_prefix". Each object uri is in format:
  /// "gs://bucket_name/object_name_prefix/<asset type>/<shard number> and only
  /// contains assets for that type. <shard number> starts from 0. Example:
  /// "gs://bucket_name/object_name_prefix/compute.googleapis.com/Disk/0" is
  /// the first shard of output objects containing all
  /// compute.googleapis.com/Disk assets. An INVALID_ARGUMENT error will be
  /// returned if file with the same name "gs://bucket_name/object_name_prefix"
  /// already exists.
  public var uriPrefix: String {
    get {
      if case .uriPrefix(let v)? = objectUri {return v}
      return String()
    }
    set {objectUri = .uriPrefix(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required.
  public enum OneOf_ObjectUri: Equatable {
    /// The uri of the Cloud Storage object. It's the same uri that is used by
    /// gsutil. Example: "gs://bucket_name/object_name". See [Viewing and
    /// Editing Object
    /// Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
    /// for more information.
    case uri(String)
    /// The uri prefix of all generated Cloud Storage objects. Example:
    /// "gs://bucket_name/object_name_prefix". Each object uri is in format:
    /// "gs://bucket_name/object_name_prefix/<asset type>/<shard number> and only
    /// contains assets for that type. <shard number> starts from 0. Example:
    /// "gs://bucket_name/object_name_prefix/compute.googleapis.com/Disk/0" is
    /// the first shard of output objects containing all
    /// compute.googleapis.com/Disk assets. An INVALID_ARGUMENT error will be
    /// returned if file with the same name "gs://bucket_name/object_name_prefix"
    /// already exists.
    case uriPrefix(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1_GcsDestination.OneOf_ObjectUri, rhs: Google_Cloud_Asset_V1_GcsDestination.OneOf_ObjectUri) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uri, .uri): return {
        guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.uriPrefix, .uriPrefix): return {
        guard case .uriPrefix(let l) = lhs, case .uriPrefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A BigQuery destination for exporting assets to.
public struct Google_Cloud_Asset_V1_BigQueryDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The BigQuery dataset in format
  /// "projects/projectId/datasets/datasetId", to which the snapshot result
  /// should be exported. If this dataset does not exist, the export call returns
  /// an INVALID_ARGUMENT error.
  public var dataset: String = String()

  /// Required. The BigQuery table to which the snapshot result should be
  /// written. If this table does not exist, a new table with the given name
  /// will be created.
  public var table: String = String()

  /// If the destination table already exists and this flag is `TRUE`, the
  /// table will be overwritten by the contents of assets snapshot. If the flag
  /// is `FALSE` or unset and the destination table already exists, the export
  /// call returns an INVALID_ARGUMEMT error.
  public var force: Bool = false

  /// [partition_spec] determines whether to export to partitioned table(s) and
  /// how to partition the data.
  ///
  /// If [partition_spec] is unset or [partition_spec.partion_key] is unset or
  /// `PARTITION_KEY_UNSPECIFIED`, the snapshot results will be exported to
  /// non-partitioned table(s). [force] will decide whether to overwrite existing
  /// table(s).
  ///
  /// If [partition_spec] is specified. First, the snapshot results will be
  /// written to partitioned table(s) with two additional timestamp columns,
  /// readTime and requestTime, one of which will be the partition key. Secondly,
  /// in the case when any destination table already exists, it will first try to
  /// update existing table's schema as necessary by appending additional
  /// columns. Then, if [force] is `TRUE`, the corresponding partition will be
  /// overwritten by the snapshot results (data in different partitions will
  /// remain intact); if [force] is unset or `FALSE`, it will append the data. An
  /// error will be returned if the schema update or data appension fails.
  public var partitionSpec: Google_Cloud_Asset_V1_PartitionSpec {
    get {return _partitionSpec ?? Google_Cloud_Asset_V1_PartitionSpec()}
    set {_partitionSpec = newValue}
  }
  /// Returns true if `partitionSpec` has been explicitly set.
  public var hasPartitionSpec: Bool {return self._partitionSpec != nil}
  /// Clears the value of `partitionSpec`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionSpec() {self._partitionSpec = nil}

  /// If this flag is `TRUE`, the snapshot results will be written to one or
  /// multiple tables, each of which contains results of one asset type. The
  /// [force] and [partition_spec] fields will apply to each of them.
  ///
  /// Field [table] will be concatenated with "_" and the asset type names (see
  /// https://cloud.google.com/asset-inventory/docs/supported-asset-types for
  /// supported asset types) to construct per-asset-type table names, in which
  /// all non-alphanumeric characters like "." and "/" will be substituted by
  /// "_". Example: if field [table] is "mytable" and snapshot results
  /// contain "storage.googleapis.com/Bucket" assets, the corresponding table
  /// name will be "mytable_storage_googleapis_com_Bucket". If any of these
  /// tables does not exist, a new table with the concatenated name will be
  /// created.
  ///
  /// When [content_type] in the ExportAssetsRequest is `RESOURCE`, the schema of
  /// each table will include RECORD-type columns mapped to the nested fields in
  /// the Asset.resource.data field of that asset type (up to the 15 nested level
  /// BigQuery supports
  /// (https://cloud.google.com/bigquery/docs/nested-repeated#limitations)). The
  /// fields in >15 nested levels will be stored in JSON format string as a child
  /// column of its parent RECORD column.
  ///
  /// If error occurs when exporting to any table, the whole export call will
  /// return an error but the export results that already succeed will persist.
  /// Example: if exporting to table_type_A succeeds when exporting to
  /// table_type_B fails during one export call, the results in table_type_A will
  /// persist and there will not be partial results persisting in a table.
  public var separateTablesPerAssetType: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _partitionSpec: Google_Cloud_Asset_V1_PartitionSpec? = nil
}

/// Specifications of BigQuery partitioned table as export destination.
public struct Google_Cloud_Asset_V1_PartitionSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The partition key for BigQuery partitioned table.
  public var partitionKey: Google_Cloud_Asset_V1_PartitionSpec.PartitionKey = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This enum is used to determine the partition key column when exporting
  /// assets to BigQuery partitioned table(s). Note that, if the partition key is
  /// a timestamp column, the actual partition is based on its date value
  /// (expressed in UTC. see details in
  /// https://cloud.google.com/bigquery/docs/partitioned-tables#date_timestamp_partitioned_tables).
  public enum PartitionKey: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified partition key. If used, it means using non-partitioned table.
    case unspecified // = 0

    /// The time when the snapshot is taken. If specified as partition key, the
    /// result table(s) is partitoned by the additional timestamp column,
    /// readTime. If [read_time] in ExportAssetsRequest is specified, the
    /// readTime column's value will be the same as it. Otherwise, its value will
    /// be the current time that is used to take the snapshot.
    case readTime // = 1

    /// The time when the request is received and started to be processed. If
    /// specified as partition key, the result table(s) is partitoned by the
    /// requestTime column, an additional timestamp column representing when the
    /// request was received.
    case requestTime // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .readTime
      case 2: self = .requestTime
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .readTime: return 1
      case .requestTime: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Asset_V1_PartitionSpec.PartitionKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Asset_V1_PartitionSpec.PartitionKey] = [
    .unspecified,
    .readTime,
    .requestTime,
  ]
}

#endif  // swift(>=4.2)

/// A Pub/Sub destination.
public struct Google_Cloud_Asset_V1_PubsubDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the Pub/Sub topic to publish to.
  /// Example: `projects/PROJECT_ID/topics/TOPIC_ID`.
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Output configuration for asset feed destination.
public struct Google_Cloud_Asset_V1_FeedOutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asset feed destination.
  public var destination: Google_Cloud_Asset_V1_FeedOutputConfig.OneOf_Destination? = nil

  /// Destination on Pub/Sub.
  public var pubsubDestination: Google_Cloud_Asset_V1_PubsubDestination {
    get {
      if case .pubsubDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1_PubsubDestination()
    }
    set {destination = .pubsubDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Asset feed destination.
  public enum OneOf_Destination: Equatable {
    /// Destination on Pub/Sub.
    case pubsubDestination(Google_Cloud_Asset_V1_PubsubDestination)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1_FeedOutputConfig.OneOf_Destination, rhs: Google_Cloud_Asset_V1_FeedOutputConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pubsubDestination, .pubsubDestination): return {
        guard case .pubsubDestination(let l) = lhs, case .pubsubDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// An asset feed used to export asset updates to a destinations.
/// An asset feed filter controls what updates are exported.
/// The asset feed must be created within a project, organization, or
/// folder. Supported destinations are:
/// Pub/Sub topics.
public struct Google_Cloud_Asset_V1_Feed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The format will be
  /// projects/{project_number}/feeds/{client-assigned_feed_identifier} or
  /// folders/{folder_number}/feeds/{client-assigned_feed_identifier} or
  /// organizations/{organization_number}/feeds/{client-assigned_feed_identifier}
  ///
  /// The client-assigned feed identifier must be unique within the parent
  /// project/folder/organization.
  public var name: String = String()

  /// A list of the full names of the assets to receive updates. You must specify
  /// either or both of asset_names and asset_types. Only asset updates matching
  /// specified asset_names or asset_types are exported to the feed.
  /// Example:
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
  /// See [Resource
  /// Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
  /// for more info.
  public var assetNames: [String] = []

  /// A list of types of the assets to receive updates. You must specify either
  /// or both of asset_names and asset_types. Only asset updates matching
  /// specified asset_names or asset_types are exported to the feed.
  /// Example: `"compute.googleapis.com/Disk"`
  ///
  /// See [this
  /// topic](https://cloud.google.com/asset-inventory/docs/supported-asset-types)
  /// for a list of all supported asset types.
  public var assetTypes: [String] = []

  /// Asset content type. If not specified, no content but the asset name and
  /// type will be returned.
  public var contentType: Google_Cloud_Asset_V1_ContentType = .unspecified

  /// Required. Feed output configuration defining where the asset updates are
  /// published to.
  public var feedOutputConfig: Google_Cloud_Asset_V1_FeedOutputConfig {
    get {return _feedOutputConfig ?? Google_Cloud_Asset_V1_FeedOutputConfig()}
    set {_feedOutputConfig = newValue}
  }
  /// Returns true if `feedOutputConfig` has been explicitly set.
  public var hasFeedOutputConfig: Bool {return self._feedOutputConfig != nil}
  /// Clears the value of `feedOutputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearFeedOutputConfig() {self._feedOutputConfig = nil}

  /// A condition which determines whether an asset update should be published.
  /// If specified, an asset will be returned only when the expression evaluates
  /// to true.
  /// When set, `expression` field in the `Expr` must be a valid [CEL expression]
  /// (https://github.com/google/cel-spec) on a TemporalAsset with name
  /// `temporal_asset`. Example: a Feed with expression ("temporal_asset.deleted
  /// == true") will only publish Asset deletions. Other fields of `Expr` are
  /// optional.
  ///
  /// See our [user
  /// guide](https://cloud.google.com/asset-inventory/docs/monitoring-asset-changes#feed_with_condition)
  /// for detailed instructions.
  public var condition: Google_Type_Expr {
    get {return _condition ?? Google_Type_Expr()}
    set {_condition = newValue}
  }
  /// Returns true if `condition` has been explicitly set.
  public var hasCondition: Bool {return self._condition != nil}
  /// Clears the value of `condition`. Subsequent reads from it will return its default value.
  public mutating func clearCondition() {self._condition = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feedOutputConfig: Google_Cloud_Asset_V1_FeedOutputConfig? = nil
  fileprivate var _condition: Google_Type_Expr? = nil
}

/// Search all resources request.
public struct Google_Cloud_Asset_V1_SearchAllResourcesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A scope can be a project, a folder, or an organization. The search is
  /// limited to the resources within the `scope`. The caller must be granted the
  /// [`cloudasset.assets.searchAllResources`](http://cloud.google.com/asset-inventory/docs/access-control#required_permissions)
  /// permission on the desired scope.
  ///
  /// The allowed values are:
  ///
  /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
  /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
  /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
  /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
  public var scope: String = String()

  /// Optional. The query statement. See [how to construct a
  /// query](http://cloud.google.com/asset-inventory/docs/searching-resources#how_to_construct_a_query)
  /// for more information. If not specified or empty, it will search all the
  /// resources within the specified `scope`. Note that the query string is
  /// compared against each Cloud IAM policy binding, including its members,
  /// roles, and Cloud IAM conditions. The returned Cloud IAM policies will only
  /// contain the bindings that match your query. To learn more about the IAM
  /// policy structure, see [IAM policy
  /// doc](https://cloud.google.com/iam/docs/policies#structure).
  ///
  /// Examples:
  ///
  /// * `name:Important` to find Cloud resources whose name contains
  ///   "Important" as a word.
  /// * `displayName:Impor*` to find Cloud resources whose display name
  ///   contains "Impor" as a prefix.
  /// * `description:*por*` to find Cloud resources whose description
  ///   contains "por" as a substring.
  /// * `location:us-west*` to find Cloud resources whose location is
  ///   prefixed with "us-west".
  /// * `labels:prod` to find Cloud resources whose labels contain "prod" as
  ///   a key or value.
  /// * `labels.env:prod` to find Cloud resources that have a label "env"
  ///   and its value is "prod".
  /// * `labels.env:*` to find Cloud resources that have a label "env".
  /// * `Important` to find Cloud resources that contain "Important" as a word
  ///   in any of the searchable fields.
  /// * `Impor*` to find Cloud resources that contain "Impor" as a prefix
  ///   in any of the searchable fields.
  /// * `*por*` to find Cloud resources that contain "por" as a substring in
  ///   any of the searchable fields.
  /// * `Important location:(us-west1 OR global)` to find Cloud
  ///   resources that contain "Important" as a word in any of the searchable
  ///   fields and are also located in the "us-west1" region or the "global"
  ///   location.
  public var query: String = String()

  /// Optional. A list of asset types that this request searches for. If empty, it will
  /// search all the [searchable asset
  /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#searchable_asset_types).
  public var assetTypes: [String] = []

  /// Optional. The page size for search result pagination. Page size is capped at 500 even
  /// if a larger value is given. If set to zero, server will pick an appropriate
  /// default. Returned results may be fewer than requested. When this happens,
  /// there could be more results as long as `next_page_token` is returned.
  public var pageSize: Int32 = 0

  /// Optional. If present, then retrieve the next batch of results from the preceding call
  /// to this method. `page_token` must be the value of `next_page_token` from
  /// the previous response. The values of all other method parameters, must be
  /// identical to those in the previous call.
  public var pageToken: String = String()

  /// Optional. A comma separated list of fields specifying the sorting order of the
  /// results. The default order is ascending. Add " DESC" after the field name
  /// to indicate descending order. Redundant space characters are ignored.
  /// Example: "location DESC, name". Only string fields in the response are
  /// sortable, including `name`, `displayName`, `description`, `location`. All
  /// the other fields such as repeated fields (e.g., `networkTags`), map
  /// fields (e.g., `labels`) and struct fields (e.g., `additionalAttributes`)
  /// are not supported.
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Search all resources response.
public struct Google_Cloud_Asset_V1_SearchAllResourcesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of Resources that match the search query. It contains the resource
  /// standard metadata information.
  public var results: [Google_Cloud_Asset_V1_ResourceSearchResult] = []

  /// If there are more results than those appearing in this response, then
  /// `next_page_token` is included. To get the next set of results, call this
  /// method again using the value of `next_page_token` as `page_token`.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Search all IAM policies request.
public struct Google_Cloud_Asset_V1_SearchAllIamPoliciesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A scope can be a project, a folder, or an organization. The search is
  /// limited to the IAM policies within the `scope`. The caller must be granted
  /// the
  /// [`cloudasset.assets.searchAllIamPolicies`](http://cloud.google.com/asset-inventory/docs/access-control#required_permissions)
  /// permission on the desired scope.
  ///
  /// The allowed values are:
  ///
  /// * projects/{PROJECT_ID} (e.g., "projects/foo-bar")
  /// * projects/{PROJECT_NUMBER} (e.g., "projects/12345678")
  /// * folders/{FOLDER_NUMBER} (e.g., "folders/1234567")
  /// * organizations/{ORGANIZATION_NUMBER} (e.g., "organizations/123456")
  public var scope: String = String()

  /// Optional. The query statement. See [how to construct a
  /// query](https://cloud.google.com/asset-inventory/docs/searching-iam-policies#how_to_construct_a_query)
  /// for more information. If not specified or empty, it will search all the
  /// IAM policies within the specified `scope`.
  ///
  /// Examples:
  ///
  /// * `policy:amy@gmail.com` to find IAM policy bindings that specify user
  ///   "amy@gmail.com".
  /// * `policy:roles/compute.admin` to find IAM policy bindings that specify
  ///   the Compute Admin role.
  /// * `policy.role.permissions:storage.buckets.update` to find IAM policy
  ///   bindings that specify a role containing "storage.buckets.update"
  ///   permission. Note that if callers don't have `iam.roles.get` access to a
  ///   role's included permissions, policy bindings that specify this role will
  ///   be dropped from the search results.
  /// * `resource:organizations/123456` to find IAM policy bindings
  ///   that are set on "organizations/123456".
  /// * `Important` to find IAM policy bindings that contain "Important" as a
  ///   word in any of the searchable fields (except for the included
  ///   permissions).
  /// * `*por*` to find IAM policy bindings that contain "por" as a substring
  ///   in any of the searchable fields (except for the included permissions).
  /// * `resource:(instance1 OR instance2) policy:amy` to find
  ///   IAM policy bindings that are set on resources "instance1" or
  ///   "instance2" and also specify user "amy".
  public var query: String = String()

  /// Optional. The page size for search result pagination. Page size is capped at 500 even
  /// if a larger value is given. If set to zero, server will pick an appropriate
  /// default. Returned results may be fewer than requested. When this happens,
  /// there could be more results as long as `next_page_token` is returned.
  public var pageSize: Int32 = 0

  /// Optional. If present, retrieve the next batch of results from the preceding call to
  /// this method. `page_token` must be the value of `next_page_token` from the
  /// previous response. The values of all other method parameters must be
  /// identical to those in the previous call.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Search all IAM policies response.
public struct Google_Cloud_Asset_V1_SearchAllIamPoliciesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of IamPolicy that match the search query. Related information such
  /// as the associated resource is returned along with the policy.
  public var results: [Google_Cloud_Asset_V1_IamPolicySearchResult] = []

  /// Set if there are more results than those appearing in this response; to get
  /// the next set of results, call this method again, using this value as the
  /// `page_token`.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IAM policy analysis query message.
public struct Google_Cloud_Asset_V1_IamPolicyAnalysisQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The relative name of the root asset. Only resources and IAM policies within
  /// the scope will be analyzed.
  ///
  /// This can only be an organization number (such as "organizations/123"), a
  /// folder number (such as "folders/123"), a project ID (such as
  /// "projects/my-project-id"), or a project number (such as "projects/12345").
  ///
  /// To know how to get organization id, visit [here
  /// ](https://cloud.google.com/resource-manager/docs/creating-managing-organization#retrieving_your_organization_id).
  ///
  /// To know how to get folder or project id, visit [here
  /// ](https://cloud.google.com/resource-manager/docs/creating-managing-folders#viewing_or_listing_folders_and_projects).
  public var scope: String = String()

  /// Optional. Specifies a resource for analysis.
  public var resourceSelector: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.ResourceSelector {
    get {return _resourceSelector ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.ResourceSelector()}
    set {_resourceSelector = newValue}
  }
  /// Returns true if `resourceSelector` has been explicitly set.
  public var hasResourceSelector: Bool {return self._resourceSelector != nil}
  /// Clears the value of `resourceSelector`. Subsequent reads from it will return its default value.
  public mutating func clearResourceSelector() {self._resourceSelector = nil}

  /// Optional. Specifies an identity for analysis.
  public var identitySelector: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.IdentitySelector {
    get {return _identitySelector ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.IdentitySelector()}
    set {_identitySelector = newValue}
  }
  /// Returns true if `identitySelector` has been explicitly set.
  public var hasIdentitySelector: Bool {return self._identitySelector != nil}
  /// Clears the value of `identitySelector`. Subsequent reads from it will return its default value.
  public mutating func clearIdentitySelector() {self._identitySelector = nil}

  /// Optional. Specifies roles or permissions for analysis. This is optional.
  public var accessSelector: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.AccessSelector {
    get {return _accessSelector ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.AccessSelector()}
    set {_accessSelector = newValue}
  }
  /// Returns true if `accessSelector` has been explicitly set.
  public var hasAccessSelector: Bool {return self._accessSelector != nil}
  /// Clears the value of `accessSelector`. Subsequent reads from it will return its default value.
  public mutating func clearAccessSelector() {self._accessSelector = nil}

  /// Optional. The query options.
  public var options: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.Options {
    get {return _options ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.Options()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the resource to analyze for access policies, which may be set
  /// directly on the resource, or on ancestors such as organizations, folders or
  /// projects.
  public struct ResourceSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The [full resource name]
    /// (https://cloud.google.com/asset-inventory/docs/resource-name-format)
    /// of a resource of [supported resource
    /// types](https://cloud.google.com/asset-inventory/docs/supported-asset-types#analyzable_asset_types).
    public var fullResourceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Specifies an identity for which to determine resource access, based on
  /// roles assigned either directly to them or to the groups they belong to,
  /// directly or indirectly.
  public struct IdentitySelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The identity appear in the form of members in
    /// [IAM policy
    /// binding](https://cloud.google.com/iam/reference/rest/v1/Binding).
    ///
    /// The examples of supported forms are:
    /// "user:mike@example.com",
    /// "group:admins@example.com",
    /// "domain:google.com",
    /// "serviceAccount:my-project-id@appspot.gserviceaccount.com".
    ///
    /// Notice that wildcard characters (such as * and ?) are not supported.
    /// You must give a specific identity.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Specifies roles and/or permissions to analyze, to determine both the
  /// identities possessing them and the resources they control. If multiple
  /// values are specified, results will include roles or permissions matching
  /// any of them. The total number of roles and permissions should be equal or
  /// less than 10.
  public struct AccessSelector {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. The roles to appear in result.
    public var roles: [String] = []

    /// Optional. The permissions to appear in result.
    public var permissions: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Contains query options.
  public struct Options {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Optional. If true, the identities section of the result will expand any
    /// Google groups appearing in an IAM policy binding.
    ///
    /// If [IamPolicyAnalysisQuery.identity_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.identity_selector] is specified, the
    /// identity in the result will be determined by the selector, and this flag
    /// is not allowed to set.
    ///
    /// Default is false.
    public var expandGroups: Bool = false

    /// Optional. If true, the access section of result will expand any roles
    /// appearing in IAM policy bindings to include their permissions.
    ///
    /// If [IamPolicyAnalysisQuery.access_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.access_selector] is specified, the access
    /// section of the result will be determined by the selector, and this flag
    /// is not allowed to set.
    ///
    /// Default is false.
    public var expandRoles: Bool = false

    /// Optional. If true and [IamPolicyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector] is not
    /// specified, the resource section of the result will expand any resource
    /// attached to an IAM policy to include resources lower in the resource
    /// hierarchy.
    ///
    /// For example, if the request analyzes for which resources user A has
    /// permission P, and the results include an IAM policy with P on a GCP
    /// folder, the results will also include resources in that folder with
    /// permission P.
    ///
    /// If true and [IamPolicyAnalysisQuery.resource_selector][google.cloud.asset.v1.IamPolicyAnalysisQuery.resource_selector] is specified,
    /// the resource section of the result will expand the specified resource to
    /// include resources lower in the resource hierarchy. Only project or
    /// lower resources are supported. Folder and organization resource cannot be
    /// used together with this option.
    ///
    /// For example, if the request analyzes for which users have permission P on
    /// a GCP project with this option enabled, the results will include all
    /// users who have permission P on that project or any lower resource.
    ///
    /// Default is false.
    public var expandResources: Bool = false

    /// Optional. If true, the result will output resource edges, starting
    /// from the policy attached resource, to any expanded resources.
    /// Default is false.
    public var outputResourceEdges: Bool = false

    /// Optional. If true, the result will output group identity edges, starting
    /// from the binding's group members, to any expanded identities.
    /// Default is false.
    public var outputGroupEdges: Bool = false

    /// Optional. If true, the response will include access analysis from identities to
    /// resources via service account impersonation. This is a very expensive
    /// operation, because many derived queries will be executed. We highly
    /// recommend you use [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning] rpc
    /// instead.
    ///
    /// For example, if the request analyzes for which resources user A has
    /// permission P, and there's an IAM policy states user A has
    /// iam.serviceAccounts.getAccessToken permission to a service account SA,
    /// and there's another IAM policy states service account SA has permission P
    /// to a GCP folder F, then user A potentially has access to the GCP folder
    /// F. And those advanced analysis results will be included in
    /// [AnalyzeIamPolicyResponse.service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis].
    ///
    /// Another example, if the request analyzes for who has
    /// permission P to a GCP folder F, and there's an IAM policy states user A
    /// has iam.serviceAccounts.actAs permission to a service account SA, and
    /// there's another IAM policy states service account SA has permission P to
    /// the GCP folder F, then user A potentially has access to the GCP folder
    /// F. And those advanced analysis results will be included in
    /// [AnalyzeIamPolicyResponse.service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis].
    ///
    /// Default is false.
    public var analyzeServiceAccountImpersonation: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _resourceSelector: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.ResourceSelector? = nil
  fileprivate var _identitySelector: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.IdentitySelector? = nil
  fileprivate var _accessSelector: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.AccessSelector? = nil
  fileprivate var _options: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.Options? = nil
}

/// A request message for [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy].
public struct Google_Cloud_Asset_V1_AnalyzeIamPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The request query.
  public var analysisQuery: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery {
    get {return _analysisQuery ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery()}
    set {_analysisQuery = newValue}
  }
  /// Returns true if `analysisQuery` has been explicitly set.
  public var hasAnalysisQuery: Bool {return self._analysisQuery != nil}
  /// Clears the value of `analysisQuery`. Subsequent reads from it will return its default value.
  public mutating func clearAnalysisQuery() {self._analysisQuery = nil}

  /// Optional. Amount of time executable has to complete.  See JSON representation of
  /// [Duration](https://developers.google.com/protocol-buffers/docs/proto3#json).
  ///
  /// If this field is set with a value less than the RPC deadline, and the
  /// execution of your query hasn't finished in the specified
  /// execution timeout,  you will get a response with partial result.
  /// Otherwise, your query's execution will continue until the RPC deadline.
  /// If it's not finished until then, you will get a  DEADLINE_EXCEEDED error.
  ///
  /// Default is empty.
  public var executionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _executionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_executionTimeout = newValue}
  }
  /// Returns true if `executionTimeout` has been explicitly set.
  public var hasExecutionTimeout: Bool {return self._executionTimeout != nil}
  /// Clears the value of `executionTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearExecutionTimeout() {self._executionTimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _analysisQuery: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery? = nil
  fileprivate var _executionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A response message for [AssetService.AnalyzeIamPolicy][google.cloud.asset.v1.AssetService.AnalyzeIamPolicy].
public struct Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The main analysis that matches the original request.
  public var mainAnalysis: Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis {
    get {return _mainAnalysis ?? Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis()}
    set {_mainAnalysis = newValue}
  }
  /// Returns true if `mainAnalysis` has been explicitly set.
  public var hasMainAnalysis: Bool {return self._mainAnalysis != nil}
  /// Clears the value of `mainAnalysis`. Subsequent reads from it will return its default value.
  public mutating func clearMainAnalysis() {self._mainAnalysis = nil}

  /// The service account impersonation analysis if
  /// [AnalyzeIamPolicyRequest.analyze_service_account_impersonation][] is
  /// enabled.
  public var serviceAccountImpersonationAnalysis: [Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis] = []

  /// Represents whether all entries in the [main_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.main_analysis] and
  /// [service_account_impersonation_analysis][google.cloud.asset.v1.AnalyzeIamPolicyResponse.service_account_impersonation_analysis] have been fully explored to
  /// answer the query in the request.
  public var fullyExplored: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An analysis message to group the query and results.
  public struct IamPolicyAnalysis {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The analysis query.
    public var analysisQuery: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery {
      get {return _analysisQuery ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery()}
      set {_analysisQuery = newValue}
    }
    /// Returns true if `analysisQuery` has been explicitly set.
    public var hasAnalysisQuery: Bool {return self._analysisQuery != nil}
    /// Clears the value of `analysisQuery`. Subsequent reads from it will return its default value.
    public mutating func clearAnalysisQuery() {self._analysisQuery = nil}

    /// A list of [IamPolicyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult] that matches the analysis query, or
    /// empty if no result is found.
    public var analysisResults: [Google_Cloud_Asset_V1_IamPolicyAnalysisResult] = []

    /// Represents whether all entries in the [analysis_results][google.cloud.asset.v1.AnalyzeIamPolicyResponse.IamPolicyAnalysis.analysis_results] have been
    /// fully explored to answer the query.
    public var fullyExplored: Bool = false

    /// A list of non-critical errors happened during the query handling.
    public var nonCriticalErrors: [Google_Cloud_Asset_V1_IamPolicyAnalysisState] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _analysisQuery: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery? = nil
  }

  public init() {}

  fileprivate var _mainAnalysis: Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis? = nil
}

/// Output configuration for export IAM policy analysis destination.
public struct Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IAM policy analysis export destination.
  public var destination: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.OneOf_Destination? = nil

  /// Destination on Cloud Storage.
  public var gcsDestination: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  /// Destination on BigQuery.
  public var bigqueryDestination: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination {
    get {
      if case .bigqueryDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination()
    }
    set {destination = .bigqueryDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// IAM policy analysis export destination.
  public enum OneOf_Destination: Equatable {
    /// Destination on Cloud Storage.
    case gcsDestination(Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination)
    /// Destination on BigQuery.
    case bigqueryDestination(Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.OneOf_Destination, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsDestination, .gcsDestination): return {
        guard case .gcsDestination(let l) = lhs, case .gcsDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bigqueryDestination, .bigqueryDestination): return {
        guard case .bigqueryDestination(let l) = lhs, case .bigqueryDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A Cloud Storage location.
  public struct GcsDestination {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The uri of the Cloud Storage object. It's the same uri that is used by
    /// gsutil. For example: "gs://bucket_name/object_name". See
    /// [Quickstart: Using the gsutil tool]
    /// (https://cloud.google.com/storage/docs/quickstart-gsutil) for examples.
    public var uri: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A BigQuery destination.
  public struct BigQueryDestination {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The BigQuery dataset in format "projects/projectId/datasets/datasetId",
    /// to which the analysis results should be exported. If this dataset does
    /// not exist, the export call will return an INVALID_ARGUMENT error.
    public var dataset: String = String()

    /// Required. The prefix of the BigQuery tables to which the analysis results will be
    /// written. Tables will be created based on this table_prefix if not exist:
    /// * <table_prefix>_analysis table will contain export operation's metadata.
    /// * <table_prefix>_analysis_result will contain all the
    ///   [IamPolicyAnalysisResult][google.cloud.asset.v1.IamPolicyAnalysisResult].
    /// When [partition_key] is specified, both tables will be partitioned based
    /// on the [partition_key].
    public var tablePrefix: String = String()

    /// The partition key for BigQuery partitioned table.
    public var partitionKey: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey = .unspecified

    /// Optional. Specifies the action that occurs if the destination table or partition
    /// already exists. The following values are supported:
    ///
    /// * WRITE_TRUNCATE: If the table or partition already exists, BigQuery
    /// overwrites the entire table or all the partitions data.
    /// * WRITE_APPEND: If the table or partition already exists, BigQuery
    /// appends the data to the table or the latest partition.
    /// * WRITE_EMPTY: If the table already exists and contains data, an error is
    /// returned.
    ///
    /// The default value is WRITE_APPEND. Each action is atomic and only occurs
    /// if BigQuery is able to complete the job successfully. Details are at
    /// https://cloud.google.com/bigquery/docs/loading-data-local#appending_to_or_overwriting_a_table_using_a_local_file.
    public var writeDisposition: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// This enum determines the partition key column for the bigquery tables.
    /// Partitioning can improve query performance and reduce query cost by
    /// filtering partitions. Refer to
    /// https://cloud.google.com/bigquery/docs/partitioned-tables for details.
    public enum PartitionKey: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// Unspecified partition key. Tables won't be partitioned using this
      /// option.
      case unspecified // = 0

      /// The time when the request is received. If specified as partition key,
      /// the result table(s) is partitoned by the RequestTime column, an
      /// additional timestamp column representing when the request was received.
      case requestTime // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .requestTime
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .requestTime: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey] = [
    .unspecified,
    .requestTime,
  ]
}

#endif  // swift(>=4.2)

/// A request message for [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning].
public struct Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The request query.
  public var analysisQuery: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery {
    get {return _analysisQuery ?? Google_Cloud_Asset_V1_IamPolicyAnalysisQuery()}
    set {_analysisQuery = newValue}
  }
  /// Returns true if `analysisQuery` has been explicitly set.
  public var hasAnalysisQuery: Bool {return self._analysisQuery != nil}
  /// Clears the value of `analysisQuery`. Subsequent reads from it will return its default value.
  public mutating func clearAnalysisQuery() {self._analysisQuery = nil}

  /// Required. Output configuration indicating where the results will be output to.
  public var outputConfig: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig {
    get {return _outputConfig ?? Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig()}
    set {_outputConfig = newValue}
  }
  /// Returns true if `outputConfig` has been explicitly set.
  public var hasOutputConfig: Bool {return self._outputConfig != nil}
  /// Clears the value of `outputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearOutputConfig() {self._outputConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _analysisQuery: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery? = nil
  fileprivate var _outputConfig: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig? = nil
}

/// A response message for [AssetService.AnalyzeIamPolicyLongrunning][google.cloud.asset.v1.AssetService.AnalyzeIamPolicyLongrunning].
public struct Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.asset.v1"

extension Google_Cloud_Asset_V1_ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "RESOURCE"),
    2: .same(proto: "IAM_POLICY"),
    4: .same(proto: "ORG_POLICY"),
    5: .same(proto: "ACCESS_POLICY"),
  ]
}

extension Google_Cloud_Asset_V1_ExportAssetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportAssetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "read_time"),
    3: .standard(proto: "asset_types"),
    4: .standard(proto: "content_type"),
    5: .standard(proto: "output_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetTypes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.assetTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetTypes, fieldNumber: 3)
    }
    if self.contentType != .unspecified {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_ExportAssetsRequest, rhs: Google_Cloud_Asset_V1_ExportAssetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._readTime != rhs._readTime {return false}
    if lhs.assetTypes != rhs.assetTypes {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_ExportAssetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportAssetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_time"),
    2: .standard(proto: "output_config"),
    3: .standard(proto: "output_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._readTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._outputResult) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._readTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._outputResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_ExportAssetsResponse, rhs: Google_Cloud_Asset_V1_ExportAssetsResponse) -> Bool {
    if lhs._readTime != rhs._readTime {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs._outputResult != rhs._outputResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_BatchGetAssetsHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchGetAssetsHistoryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "asset_names"),
    3: .standard(proto: "content_type"),
    4: .standard(proto: "read_time_window"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.assetNames) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._readTimeWindow) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.assetNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetNames, fieldNumber: 2)
    }
    if self.contentType != .unspecified {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 3)
    }
    if let v = self._readTimeWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_BatchGetAssetsHistoryRequest, rhs: Google_Cloud_Asset_V1_BatchGetAssetsHistoryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.assetNames != rhs.assetNames {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs._readTimeWindow != rhs._readTimeWindow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_BatchGetAssetsHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchGetAssetsHistoryResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "assets"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_BatchGetAssetsHistoryResponse, rhs: Google_Cloud_Asset_V1_BatchGetAssetsHistoryResponse) -> Bool {
    if lhs.assets != rhs.assets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_CreateFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "feed_id"),
    3: .same(proto: "feed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feedID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._feed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.feedID.isEmpty {
      try visitor.visitSingularStringField(value: self.feedID, fieldNumber: 2)
    }
    if let v = self._feed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_CreateFeedRequest, rhs: Google_Cloud_Asset_V1_CreateFeedRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.feedID != rhs.feedID {return false}
    if lhs._feed != rhs._feed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_GetFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_GetFeedRequest, rhs: Google_Cloud_Asset_V1_GetFeedRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_ListFeedsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeedsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_ListFeedsRequest, rhs: Google_Cloud_Asset_V1_ListFeedsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_ListFeedsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeedsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feeds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.feeds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feeds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_ListFeedsResponse, rhs: Google_Cloud_Asset_V1_ListFeedsResponse) -> Bool {
    if lhs.feeds != rhs.feeds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_UpdateFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feed"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._feed) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._feed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_UpdateFeedRequest, rhs: Google_Cloud_Asset_V1_UpdateFeedRequest) -> Bool {
    if lhs._feed != rhs._feed {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_DeleteFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_DeleteFeedRequest, rhs: Google_Cloud_Asset_V1_DeleteFeedRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
    2: .standard(proto: "bigquery_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Asset_V1_GcsDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .gcsDestination(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Asset_V1_BigQueryDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .bigqueryDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .bigqueryDestination(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.destination {
    case .gcsDestination?: try {
      guard case .gcsDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bigqueryDestination?: try {
      guard case .bigqueryDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_OutputConfig, rhs: Google_Cloud_Asset_V1_OutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_OutputResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Asset_V1_GcsOutputResult?
        if let current = self.result {
          try decoder.handleConflictingOneOf()
          if case .gcsResult(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.result = .gcsResult(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .gcsResult(let v)? = self.result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_OutputResult, rhs: Google_Cloud_Asset_V1_OutputResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_GcsOutputResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsOutputResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uris"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.uris) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.uris, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_GcsOutputResult, rhs: Google_Cloud_Asset_V1_GcsOutputResult) -> Bool {
    if lhs.uris != rhs.uris {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_GcsDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .standard(proto: "uri_prefix"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.objectUri != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.objectUri = .uri(v)}
      }()
      case 2: try {
        if self.objectUri != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.objectUri = .uriPrefix(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.objectUri {
    case .uri?: try {
      guard case .uri(let v)? = self.objectUri else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .uriPrefix?: try {
      guard case .uriPrefix(let v)? = self.objectUri else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_GcsDestination, rhs: Google_Cloud_Asset_V1_GcsDestination) -> Bool {
    if lhs.objectUri != rhs.objectUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_BigQueryDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BigQueryDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
    2: .same(proto: "table"),
    3: .same(proto: "force"),
    4: .standard(proto: "partition_spec"),
    5: .standard(proto: "separate_tables_per_asset_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dataset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.table) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._partitionSpec) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.separateTablesPerAssetType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataset.isEmpty {
      try visitor.visitSingularStringField(value: self.dataset, fieldNumber: 1)
    }
    if !self.table.isEmpty {
      try visitor.visitSingularStringField(value: self.table, fieldNumber: 2)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 3)
    }
    if let v = self._partitionSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.separateTablesPerAssetType != false {
      try visitor.visitSingularBoolField(value: self.separateTablesPerAssetType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_BigQueryDestination, rhs: Google_Cloud_Asset_V1_BigQueryDestination) -> Bool {
    if lhs.dataset != rhs.dataset {return false}
    if lhs.table != rhs.table {return false}
    if lhs.force != rhs.force {return false}
    if lhs._partitionSpec != rhs._partitionSpec {return false}
    if lhs.separateTablesPerAssetType != rhs.separateTablesPerAssetType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_PartitionSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "partition_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.partitionKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.partitionKey != .unspecified {
      try visitor.visitSingularEnumField(value: self.partitionKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_PartitionSpec, rhs: Google_Cloud_Asset_V1_PartitionSpec) -> Bool {
    if lhs.partitionKey != rhs.partitionKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_PartitionSpec.PartitionKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARTITION_KEY_UNSPECIFIED"),
    1: .same(proto: "READ_TIME"),
    2: .same(proto: "REQUEST_TIME"),
  ]
}

extension Google_Cloud_Asset_V1_PubsubDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubsubDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_PubsubDestination, rhs: Google_Cloud_Asset_V1_PubsubDestination) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_FeedOutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedOutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pubsub_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Asset_V1_PubsubDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .pubsubDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .pubsubDestination(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .pubsubDestination(let v)? = self.destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_FeedOutputConfig, rhs: Google_Cloud_Asset_V1_FeedOutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_Feed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Feed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "asset_names"),
    3: .standard(proto: "asset_types"),
    4: .standard(proto: "content_type"),
    5: .standard(proto: "feed_output_config"),
    6: .same(proto: "condition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.assetNames) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetTypes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._feedOutputConfig) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._condition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.assetNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetNames, fieldNumber: 2)
    }
    if !self.assetTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetTypes, fieldNumber: 3)
    }
    if self.contentType != .unspecified {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    if let v = self._feedOutputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._condition {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_Feed, rhs: Google_Cloud_Asset_V1_Feed) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.assetNames != rhs.assetNames {return false}
    if lhs.assetTypes != rhs.assetTypes {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs._feedOutputConfig != rhs._feedOutputConfig {return false}
    if lhs._condition != rhs._condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_SearchAllResourcesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAllResourcesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "query"),
    3: .standard(proto: "asset_types"),
    4: .standard(proto: "page_size"),
    5: .standard(proto: "page_token"),
    6: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetTypes) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    if !self.assetTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetTypes, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_SearchAllResourcesRequest, rhs: Google_Cloud_Asset_V1_SearchAllResourcesRequest) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.query != rhs.query {return false}
    if lhs.assetTypes != rhs.assetTypes {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_SearchAllResourcesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAllResourcesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_SearchAllResourcesResponse, rhs: Google_Cloud_Asset_V1_SearchAllResourcesResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_SearchAllIamPoliciesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAllIamPoliciesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .same(proto: "query"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_SearchAllIamPoliciesRequest, rhs: Google_Cloud_Asset_V1_SearchAllIamPoliciesRequest) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.query != rhs.query {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_SearchAllIamPoliciesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchAllIamPoliciesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "results"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.results) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.results.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.results, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_SearchAllIamPoliciesResponse, rhs: Google_Cloud_Asset_V1_SearchAllIamPoliciesResponse) -> Bool {
    if lhs.results != rhs.results {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IamPolicyAnalysisQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
    2: .standard(proto: "resource_selector"),
    3: .standard(proto: "identity_selector"),
    4: .standard(proto: "access_selector"),
    5: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resourceSelector) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._identitySelector) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._accessSelector) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 1)
    }
    if let v = self._resourceSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._identitySelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._accessSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs._resourceSelector != rhs._resourceSelector {return false}
    if lhs._identitySelector != rhs._identitySelector {return false}
    if lhs._accessSelector != rhs._accessSelector {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.ResourceSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.protoMessageName + ".ResourceSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_resource_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.ResourceSelector, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.ResourceSelector) -> Bool {
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.IdentitySelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.protoMessageName + ".IdentitySelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.IdentitySelector, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.IdentitySelector) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.AccessSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.protoMessageName + ".AccessSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .same(proto: "permissions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.roles) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.permissions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedStringField(value: self.roles, fieldNumber: 1)
    }
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.permissions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.AccessSelector, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.AccessSelector) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.Options: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.protoMessageName + ".Options"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "expand_groups"),
    2: .standard(proto: "expand_roles"),
    3: .standard(proto: "expand_resources"),
    4: .standard(proto: "output_resource_edges"),
    5: .standard(proto: "output_group_edges"),
    6: .standard(proto: "analyze_service_account_impersonation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.expandGroups) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.expandRoles) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.expandResources) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.outputResourceEdges) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.outputGroupEdges) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.analyzeServiceAccountImpersonation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expandGroups != false {
      try visitor.visitSingularBoolField(value: self.expandGroups, fieldNumber: 1)
    }
    if self.expandRoles != false {
      try visitor.visitSingularBoolField(value: self.expandRoles, fieldNumber: 2)
    }
    if self.expandResources != false {
      try visitor.visitSingularBoolField(value: self.expandResources, fieldNumber: 3)
    }
    if self.outputResourceEdges != false {
      try visitor.visitSingularBoolField(value: self.outputResourceEdges, fieldNumber: 4)
    }
    if self.outputGroupEdges != false {
      try visitor.visitSingularBoolField(value: self.outputGroupEdges, fieldNumber: 5)
    }
    if self.analyzeServiceAccountImpersonation != false {
      try visitor.visitSingularBoolField(value: self.analyzeServiceAccountImpersonation, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.Options, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisQuery.Options) -> Bool {
    if lhs.expandGroups != rhs.expandGroups {return false}
    if lhs.expandRoles != rhs.expandRoles {return false}
    if lhs.expandResources != rhs.expandResources {return false}
    if lhs.outputResourceEdges != rhs.outputResourceEdges {return false}
    if lhs.outputGroupEdges != rhs.outputGroupEdges {return false}
    if lhs.analyzeServiceAccountImpersonation != rhs.analyzeServiceAccountImpersonation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_AnalyzeIamPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnalyzeIamPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "analysis_query"),
    2: .standard(proto: "execution_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._analysisQuery) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._executionTimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._analysisQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._executionTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyRequest, rhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyRequest) -> Bool {
    if lhs._analysisQuery != rhs._analysisQuery {return false}
    if lhs._executionTimeout != rhs._executionTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnalyzeIamPolicyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "main_analysis"),
    2: .standard(proto: "service_account_impersonation_analysis"),
    3: .standard(proto: "fully_explored"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mainAnalysis) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.serviceAccountImpersonationAnalysis) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fullyExplored) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mainAnalysis {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.serviceAccountImpersonationAnalysis.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceAccountImpersonationAnalysis, fieldNumber: 2)
    }
    if self.fullyExplored != false {
      try visitor.visitSingularBoolField(value: self.fullyExplored, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse, rhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse) -> Bool {
    if lhs._mainAnalysis != rhs._mainAnalysis {return false}
    if lhs.serviceAccountImpersonationAnalysis != rhs.serviceAccountImpersonationAnalysis {return false}
    if lhs.fullyExplored != rhs.fullyExplored {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.protoMessageName + ".IamPolicyAnalysis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "analysis_query"),
    2: .standard(proto: "analysis_results"),
    3: .standard(proto: "fully_explored"),
    5: .standard(proto: "non_critical_errors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._analysisQuery) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.analysisResults) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.fullyExplored) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.nonCriticalErrors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._analysisQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.analysisResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.analysisResults, fieldNumber: 2)
    }
    if self.fullyExplored != false {
      try visitor.visitSingularBoolField(value: self.fullyExplored, fieldNumber: 3)
    }
    if !self.nonCriticalErrors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonCriticalErrors, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis, rhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyResponse.IamPolicyAnalysis) -> Bool {
    if lhs._analysisQuery != rhs._analysisQuery {return false}
    if lhs.analysisResults != rhs.analysisResults {return false}
    if lhs.fullyExplored != rhs.fullyExplored {return false}
    if lhs.nonCriticalErrors != rhs.nonCriticalErrors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IamPolicyAnalysisOutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
    2: .standard(proto: "bigquery_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .gcsDestination(v)}
      }()
      case 2: try {
        var v: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .bigqueryDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .bigqueryDestination(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.destination {
    case .gcsDestination?: try {
      guard case .gcsDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .bigqueryDestination?: try {
      guard case .bigqueryDestination(let v)? = self.destination else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.protoMessageName + ".GcsDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.GcsDestination) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.protoMessageName + ".BigQueryDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataset"),
    2: .standard(proto: "table_prefix"),
    3: .standard(proto: "partition_key"),
    4: .standard(proto: "write_disposition"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.dataset) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tablePrefix) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.partitionKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.writeDisposition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dataset.isEmpty {
      try visitor.visitSingularStringField(value: self.dataset, fieldNumber: 1)
    }
    if !self.tablePrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.tablePrefix, fieldNumber: 2)
    }
    if self.partitionKey != .unspecified {
      try visitor.visitSingularEnumField(value: self.partitionKey, fieldNumber: 3)
    }
    if !self.writeDisposition.isEmpty {
      try visitor.visitSingularStringField(value: self.writeDisposition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination, rhs: Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination) -> Bool {
    if lhs.dataset != rhs.dataset {return false}
    if lhs.tablePrefix != rhs.tablePrefix {return false}
    if lhs.partitionKey != rhs.partitionKey {return false}
    if lhs.writeDisposition != rhs.writeDisposition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_IamPolicyAnalysisOutputConfig.BigQueryDestination.PartitionKey: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PARTITION_KEY_UNSPECIFIED"),
    1: .same(proto: "REQUEST_TIME"),
  ]
}

extension Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnalyzeIamPolicyLongrunningRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "analysis_query"),
    2: .standard(proto: "output_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._analysisQuery) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outputConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._analysisQuery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._outputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningRequest, rhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningRequest) -> Bool {
    if lhs._analysisQuery != rhs._analysisQuery {return false}
    if lhs._outputConfig != rhs._outputConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnalyzeIamPolicyLongrunningResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningResponse, rhs: Google_Cloud_Asset_V1_AnalyzeIamPolicyLongrunningResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

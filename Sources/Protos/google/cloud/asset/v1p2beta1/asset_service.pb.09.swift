// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/asset/v1p2beta1/asset_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Asset content type.
public enum Google_Cloud_Asset_V1p2beta1_ContentType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified content type.
  case unspecified // = 0

  /// Resource metadata.
  case resource // = 1

  /// The actual IAM policy set on a resource.
  case iamPolicy // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .resource
    case 2: self = .iamPolicy
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .resource: return 1
    case .iamPolicy: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Asset_V1p2beta1_ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Asset_V1p2beta1_ContentType] = [
    .unspecified,
    .resource,
    .iamPolicy,
  ]
}

#endif  // swift(>=4.2)

/// Create asset feed request.
public struct Google_Cloud_Asset_V1p2beta1_CreateFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project/folder/organization where this feed
  /// should be created in. It can only be an organization number (such as
  /// "organizations/123"), a folder number (such as "folders/123"), a project ID
  /// (such as "projects/my-project-id")", or a project number (such as
  /// "projects/12345").
  public var parent: String = String()

  /// Required. This is the client-assigned asset feed identifier and it needs to
  /// be unique under a specific parent project/folder/organization.
  public var feedID: String = String()

  /// Required. The feed details. The field `name` must be empty and it will be generated
  /// in the format of:
  /// projects/project_number/feeds/feed_id
  /// folders/folder_number/feeds/feed_id
  /// organizations/organization_number/feeds/feed_id
  public var feed: Google_Cloud_Asset_V1p2beta1_Feed {
    get {return _feed ?? Google_Cloud_Asset_V1p2beta1_Feed()}
    set {_feed = newValue}
  }
  /// Returns true if `feed` has been explicitly set.
  public var hasFeed: Bool {return self._feed != nil}
  /// Clears the value of `feed`. Subsequent reads from it will return its default value.
  public mutating func clearFeed() {self._feed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feed: Google_Cloud_Asset_V1p2beta1_Feed? = nil
}

/// Get asset feed request.
public struct Google_Cloud_Asset_V1p2beta1_GetFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Feed and it must be in the format of:
  /// projects/project_number/feeds/feed_id
  /// folders/folder_number/feeds/feed_id
  /// organizations/organization_number/feeds/feed_id
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// List asset feeds request.
public struct Google_Cloud_Asset_V1p2beta1_ListFeedsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent project/folder/organization whose feeds are to be
  /// listed. It can only be using project/folder/organization number (such as
  /// "folders/12345")", or a project ID (such as "projects/my-project-id").
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Cloud_Asset_V1p2beta1_ListFeedsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of feeds.
  public var feeds: [Google_Cloud_Asset_V1p2beta1_Feed] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Update asset feed request.
public struct Google_Cloud_Asset_V1p2beta1_UpdateFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The new values of feed details. It must match an existing feed and the
  /// field `name` must be in the format of:
  /// projects/project_number/feeds/feed_id or
  /// folders/folder_number/feeds/feed_id or
  /// organizations/organization_number/feeds/feed_id.
  public var feed: Google_Cloud_Asset_V1p2beta1_Feed {
    get {return _feed ?? Google_Cloud_Asset_V1p2beta1_Feed()}
    set {_feed = newValue}
  }
  /// Returns true if `feed` has been explicitly set.
  public var hasFeed: Bool {return self._feed != nil}
  /// Clears the value of `feed`. Subsequent reads from it will return its default value.
  public mutating func clearFeed() {self._feed = nil}

  /// Required. Only updates the `feed` fields indicated by this mask.
  /// The field mask must not be empty, and it must not contain fields that
  /// are immutable or only set by the server.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feed: Google_Cloud_Asset_V1p2beta1_Feed? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

public struct Google_Cloud_Asset_V1p2beta1_DeleteFeedRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the feed and it must be in the format of:
  /// projects/project_number/feeds/feed_id
  /// folders/folder_number/feeds/feed_id
  /// organizations/organization_number/feeds/feed_id
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Output configuration for export assets destination.
public struct Google_Cloud_Asset_V1p2beta1_OutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asset export destination.
  public var destination: Google_Cloud_Asset_V1p2beta1_OutputConfig.OneOf_Destination? = nil

  /// Destination on Cloud Storage.
  public var gcsDestination: Google_Cloud_Asset_V1p2beta1_GcsDestination {
    get {
      if case .gcsDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1p2beta1_GcsDestination()
    }
    set {destination = .gcsDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Asset export destination.
  public enum OneOf_Destination: Equatable {
    /// Destination on Cloud Storage.
    case gcsDestination(Google_Cloud_Asset_V1p2beta1_GcsDestination)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_OutputConfig.OneOf_Destination, rhs: Google_Cloud_Asset_V1p2beta1_OutputConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsDestination, .gcsDestination): return {
        guard case .gcsDestination(let l) = lhs, case .gcsDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A Cloud Storage location.
public struct Google_Cloud_Asset_V1p2beta1_GcsDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  public var objectUri: Google_Cloud_Asset_V1p2beta1_GcsDestination.OneOf_ObjectUri? = nil

  /// The uri of the Cloud Storage object. It's the same uri that is used by
  /// gsutil. For example: "gs://bucket_name/object_name". See [Viewing and
  /// Editing Object
  /// Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
  /// for more information.
  public var uri: String {
    get {
      if case .uri(let v)? = objectUri {return v}
      return String()
    }
    set {objectUri = .uri(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required.
  public enum OneOf_ObjectUri: Equatable {
    /// The uri of the Cloud Storage object. It's the same uri that is used by
    /// gsutil. For example: "gs://bucket_name/object_name". See [Viewing and
    /// Editing Object
    /// Metadata](https://cloud.google.com/storage/docs/viewing-editing-metadata)
    /// for more information.
    case uri(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_GcsDestination.OneOf_ObjectUri, rhs: Google_Cloud_Asset_V1p2beta1_GcsDestination.OneOf_ObjectUri) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.uri, .uri): return {
        guard case .uri(let l) = lhs, case .uri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A Cloud Pubsub destination.
public struct Google_Cloud_Asset_V1p2beta1_PubsubDestination {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the Cloud Pub/Sub topic to publish to.
  /// For example: `projects/PROJECT_ID/topics/TOPIC_ID`.
  public var topic: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Output configuration for asset feed destination.
public struct Google_Cloud_Asset_V1p2beta1_FeedOutputConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Asset feed destination.
  public var destination: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig.OneOf_Destination? = nil

  /// Destination on Cloud Pubsub.
  public var pubsubDestination: Google_Cloud_Asset_V1p2beta1_PubsubDestination {
    get {
      if case .pubsubDestination(let v)? = destination {return v}
      return Google_Cloud_Asset_V1p2beta1_PubsubDestination()
    }
    set {destination = .pubsubDestination(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Asset feed destination.
  public enum OneOf_Destination: Equatable {
    /// Destination on Cloud Pubsub.
    case pubsubDestination(Google_Cloud_Asset_V1p2beta1_PubsubDestination)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig.OneOf_Destination, rhs: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig.OneOf_Destination) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pubsubDestination, .pubsubDestination): return {
        guard case .pubsubDestination(let l) = lhs, case .pubsubDestination(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// An asset feed used to export asset updates to a destinations.
/// An asset feed filter controls what updates are exported.
/// The asset feed must be created within a project, organization, or
/// folder. Supported destinations are:
/// Cloud Pub/Sub topics.
public struct Google_Cloud_Asset_V1p2beta1_Feed {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The format will be
  /// projects/{project_number}/feeds/{client-assigned_feed_identifier} or
  /// folders/{folder_number}/feeds/{client-assigned_feed_identifier} or
  /// organizations/{organization_number}/feeds/{client-assigned_feed_identifier}
  ///
  /// The client-assigned feed identifier must be unique within the parent
  /// project/folder/organization.
  public var name: String = String()

  /// A list of the full names of the assets to receive updates. You must specify
  /// either or both of asset_names and asset_types. Only asset updates matching
  /// specified asset_names and asset_types are exported to the feed. For
  /// example:
  /// `//compute.googleapis.com/projects/my_project_123/zones/zone1/instances/instance1`.
  /// See [Resource
  /// Names](https://cloud.google.com/apis/design/resource_names#full_resource_name)
  /// for more info.
  public var assetNames: [String] = []

  /// A list of types of the assets to receive updates. You must specify either
  /// or both of asset_names and asset_types. Only asset updates matching
  /// specified asset_names and asset_types are exported to the feed.
  /// For example:
  /// "compute.googleapis.com/Disk" See [Introduction to Cloud Asset
  /// Inventory](https://cloud.google.com/resource-manager/docs/cloud-asset-inventory/overview)
  /// for all supported asset types.
  public var assetTypes: [String] = []

  /// Asset content type. If not specified, no content but the asset name and
  /// type will be returned.
  public var contentType: Google_Cloud_Asset_V1p2beta1_ContentType = .unspecified

  /// Required. Feed output configuration defining where the asset updates are
  /// published to.
  public var feedOutputConfig: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig {
    get {return _feedOutputConfig ?? Google_Cloud_Asset_V1p2beta1_FeedOutputConfig()}
    set {_feedOutputConfig = newValue}
  }
  /// Returns true if `feedOutputConfig` has been explicitly set.
  public var hasFeedOutputConfig: Bool {return self._feedOutputConfig != nil}
  /// Clears the value of `feedOutputConfig`. Subsequent reads from it will return its default value.
  public mutating func clearFeedOutputConfig() {self._feedOutputConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _feedOutputConfig: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.asset.v1p2beta1"

extension Google_Cloud_Asset_V1p2beta1_ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_TYPE_UNSPECIFIED"),
    1: .same(proto: "RESOURCE"),
    2: .same(proto: "IAM_POLICY"),
  ]
}

extension Google_Cloud_Asset_V1p2beta1_CreateFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "feed_id"),
    3: .same(proto: "feed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.feedID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._feed) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.feedID.isEmpty {
      try visitor.visitSingularStringField(value: self.feedID, fieldNumber: 2)
    }
    if let v = self._feed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_CreateFeedRequest, rhs: Google_Cloud_Asset_V1p2beta1_CreateFeedRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.feedID != rhs.feedID {return false}
    if lhs._feed != rhs._feed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_GetFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_GetFeedRequest, rhs: Google_Cloud_Asset_V1p2beta1_GetFeedRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_ListFeedsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeedsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_ListFeedsRequest, rhs: Google_Cloud_Asset_V1p2beta1_ListFeedsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_ListFeedsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFeedsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feeds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.feeds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feeds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_ListFeedsResponse, rhs: Google_Cloud_Asset_V1p2beta1_ListFeedsResponse) -> Bool {
    if lhs.feeds != rhs.feeds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_UpdateFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "feed"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._feed) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._feed {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_UpdateFeedRequest, rhs: Google_Cloud_Asset_V1p2beta1_UpdateFeedRequest) -> Bool {
    if lhs._feed != rhs._feed {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_DeleteFeedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteFeedRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_DeleteFeedRequest, rhs: Google_Cloud_Asset_V1p2beta1_DeleteFeedRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_OutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Asset_V1p2beta1_GcsDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .gcsDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .gcsDestination(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .gcsDestination(let v)? = self.destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_OutputConfig, rhs: Google_Cloud_Asset_V1p2beta1_OutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_GcsDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.objectUri != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.objectUri = .uri(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .uri(let v)? = self.objectUri {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_GcsDestination, rhs: Google_Cloud_Asset_V1p2beta1_GcsDestination) -> Bool {
    if lhs.objectUri != rhs.objectUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_PubsubDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubsubDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "topic"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topic) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topic.isEmpty {
      try visitor.visitSingularStringField(value: self.topic, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_PubsubDestination, rhs: Google_Cloud_Asset_V1p2beta1_PubsubDestination) -> Bool {
    if lhs.topic != rhs.topic {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_FeedOutputConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedOutputConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pubsub_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Asset_V1p2beta1_PubsubDestination?
        if let current = self.destination {
          try decoder.handleConflictingOneOf()
          if case .pubsubDestination(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.destination = .pubsubDestination(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .pubsubDestination(let v)? = self.destination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig, rhs: Google_Cloud_Asset_V1p2beta1_FeedOutputConfig) -> Bool {
    if lhs.destination != rhs.destination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Asset_V1p2beta1_Feed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Feed"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "asset_names"),
    3: .standard(proto: "asset_types"),
    4: .standard(proto: "content_type"),
    5: .standard(proto: "feed_output_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.assetNames) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.assetTypes) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._feedOutputConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.assetNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetNames, fieldNumber: 2)
    }
    if !self.assetTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.assetTypes, fieldNumber: 3)
    }
    if self.contentType != .unspecified {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 4)
    }
    if let v = self._feedOutputConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Asset_V1p2beta1_Feed, rhs: Google_Cloud_Asset_V1p2beta1_Feed) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.assetNames != rhs.assetNames {return false}
    if lhs.assetTypes != rhs.assetTypes {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs._feedOutputConfig != rhs._feedOutputConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

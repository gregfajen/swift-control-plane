// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/bigquery/connection/v1beta1/connection.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for [ConnectionService.CreateConnection][google.cloud.bigquery.connection.v1beta1.ConnectionService.CreateConnection].
public struct Google_Cloud_Bigquery_Connection_V1beta1_CreateConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  /// Must be in the format `projects/{project_id}/locations/{location_id}`
  public var parent: String = String()

  /// Optional. Connection id that should be assigned to the created connection.
  public var connectionID: String = String()

  /// Required. Connection to create.
  public var connection: Google_Cloud_Bigquery_Connection_V1beta1_Connection {
    get {return _connection ?? Google_Cloud_Bigquery_Connection_V1beta1_Connection()}
    set {_connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  public var hasConnection: Bool {return self._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  public mutating func clearConnection() {self._connection = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _connection: Google_Cloud_Bigquery_Connection_V1beta1_Connection? = nil
}

/// The request for [ConnectionService.GetConnection][google.cloud.bigquery.connection.v1beta1.ConnectionService.GetConnection].
public struct Google_Cloud_Bigquery_Connection_V1beta1_GetConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the requested connection, for example:
  /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1beta1.ConnectionService.ListConnections].
public struct Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Parent resource name.
  /// Must be in the form: `projects/{project_id}/locations/{location_id}`
  public var parent: String = String()

  /// Required. Maximum number of results per page.
  public var maxResults: SwiftProtobuf.Google_Protobuf_UInt32Value {
    get {return _maxResults ?? SwiftProtobuf.Google_Protobuf_UInt32Value()}
    set {_maxResults = newValue}
  }
  /// Returns true if `maxResults` has been explicitly set.
  public var hasMaxResults: Bool {return self._maxResults != nil}
  /// Clears the value of `maxResults`. Subsequent reads from it will return its default value.
  public mutating func clearMaxResults() {self._maxResults = nil}

  /// Page token.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxResults: SwiftProtobuf.Google_Protobuf_UInt32Value? = nil
}

/// The response for [ConnectionService.ListConnections][google.cloud.bigquery.connection.v1beta1.ConnectionService.ListConnections].
public struct Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Next page token.
  public var nextPageToken: String = String()

  /// List of connections.
  public var connections: [Google_Cloud_Bigquery_Connection_V1beta1_Connection] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [ConnectionService.UpdateConnection][google.cloud.bigquery.connection.v1beta1.ConnectionService.UpdateConnection].
public struct Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the connection to update, for example:
  /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
  public var name: String = String()

  /// Required. Connection containing the updated fields.
  public var connection: Google_Cloud_Bigquery_Connection_V1beta1_Connection {
    get {return _connection ?? Google_Cloud_Bigquery_Connection_V1beta1_Connection()}
    set {_connection = newValue}
  }
  /// Returns true if `connection` has been explicitly set.
  public var hasConnection: Bool {return self._connection != nil}
  /// Clears the value of `connection`. Subsequent reads from it will return its default value.
  public mutating func clearConnection() {self._connection = nil}

  /// Required. Update mask for the connection fields to be updated.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _connection: Google_Cloud_Bigquery_Connection_V1beta1_Connection? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request for [ConnectionService.UpdateConnectionCredential][google.cloud.bigquery.connection.v1beta1.ConnectionService.UpdateConnectionCredential].
public struct Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionCredentialRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the connection, for example:
  /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}/credential`
  public var name: String = String()

  /// Required. Credential to use with the connection.
  public var credential: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential {
    get {return _credential ?? Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential()}
    set {_credential = newValue}
  }
  /// Returns true if `credential` has been explicitly set.
  public var hasCredential: Bool {return self._credential != nil}
  /// Clears the value of `credential`. Subsequent reads from it will return its default value.
  public mutating func clearCredential() {self._credential = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _credential: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential? = nil
}

/// The request for [ConnectionService.DeleteConnectionRequest][].
public struct Google_Cloud_Bigquery_Connection_V1beta1_DeleteConnectionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the deleted connection, for example:
  /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration parameters to establish connection with an external data
/// source, except the credential attributes.
public struct Google_Cloud_Bigquery_Connection_V1beta1_Connection {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the connection in the form of:
  /// `projects/{project_id}/locations/{location_id}/connections/{connection_id}`
  public var name: String = String()

  /// User provided display name for the connection.
  public var friendlyName: String = String()

  /// User provided description.
  public var description_p: String = String()

  /// Properties specific to the underlying data source.
  public var properties: Google_Cloud_Bigquery_Connection_V1beta1_Connection.OneOf_Properties? = nil

  /// Cloud SQL properties.
  public var cloudSql: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties {
    get {
      if case .cloudSql(let v)? = properties {return v}
      return Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties()
    }
    set {properties = .cloudSql(newValue)}
  }

  /// Output only. The creation timestamp of the connection.
  public var creationTime: Int64 = 0

  /// Output only. The last update timestamp of the connection.
  public var lastModifiedTime: Int64 = 0

  /// Output only. True, if credential is configured for this connection.
  public var hasCredential_p: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Properties specific to the underlying data source.
  public enum OneOf_Properties: Equatable {
    /// Cloud SQL properties.
    case cloudSql(Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_Connection.OneOf_Properties, rhs: Google_Cloud_Bigquery_Connection_V1beta1_Connection.OneOf_Properties) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cloudSql, .cloudSql): return {
        guard case .cloudSql(let l) = lhs, case .cloudSql(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Credential to use with a connection.
public struct Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Credential specific to the underlying data source.
  public var credential: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential.OneOf_Credential? = nil

  /// Credential for Cloud SQL database.
  public var cloudSql: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential {
    get {
      if case .cloudSql(let v)? = credential {return v}
      return Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential()
    }
    set {credential = .cloudSql(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Credential specific to the underlying data source.
  public enum OneOf_Credential: Equatable {
    /// Credential for Cloud SQL database.
    case cloudSql(Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential.OneOf_Credential, rhs: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential.OneOf_Credential) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.cloudSql, .cloudSql): return {
        guard case .cloudSql(let l) = lhs, case .cloudSql(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Connection properties specific to the Cloud SQL.
public struct Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cloud SQL instance ID in the form `project:location:instance`.
  public var instanceID: String = String()

  /// Database name.
  public var database: String = String()

  /// Type of the Cloud SQL database.
  public var type: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties.DatabaseType = .unspecified

  /// Input only. Cloud SQL credential.
  public var credential: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential {
    get {return _credential ?? Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential()}
    set {_credential = newValue}
  }
  /// Returns true if `credential` has been explicitly set.
  public var hasCredential: Bool {return self._credential != nil}
  /// Clears the value of `credential`. Subsequent reads from it will return its default value.
  public mutating func clearCredential() {self._credential = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Supported Cloud SQL database types.
  public enum DatabaseType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified database type.
    case unspecified // = 0

    /// Cloud SQL for PostgreSQL.
    case postgres // = 1

    /// Cloud SQL for MySQL.
    case mysql // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .postgres
      case 2: self = .mysql
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .postgres: return 1
      case .mysql: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _credential: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential? = nil
}

#if swift(>=4.2)

extension Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties.DatabaseType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties.DatabaseType] = [
    .unspecified,
    .postgres,
    .mysql,
  ]
}

#endif  // swift(>=4.2)

/// Credential info for the Cloud SQL.
public struct Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The username for the credential.
  public var username: String = String()

  /// The password for the credential.
  public var password: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.bigquery.connection.v1beta1"

extension Google_Cloud_Bigquery_Connection_V1beta1_CreateConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "connection_id"),
    3: .same(proto: "connection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.connectionID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._connection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.connectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectionID, fieldNumber: 2)
    }
    if let v = self._connection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_CreateConnectionRequest, rhs: Google_Cloud_Bigquery_Connection_V1beta1_CreateConnectionRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.connectionID != rhs.connectionID {return false}
    if lhs._connection != rhs._connection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_GetConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_GetConnectionRequest, rhs: Google_Cloud_Bigquery_Connection_V1beta1_GetConnectionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConnectionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "max_results"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxResults) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._maxResults {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsRequest, rhs: Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._maxResults != rhs._maxResults {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConnectionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "next_page_token"),
    2: .same(proto: "connections"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.connections) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.connections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connections, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsResponse, rhs: Google_Cloud_Bigquery_Connection_V1beta1_ListConnectionsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.connections != rhs.connections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConnectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "connection"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._connection) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._connection {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionRequest, rhs: Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._connection != rhs._connection {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionCredentialRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConnectionCredentialRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._credential) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._credential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionCredentialRequest, rhs: Google_Cloud_Bigquery_Connection_V1beta1_UpdateConnectionCredentialRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._credential != rhs._credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_DeleteConnectionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConnectionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_DeleteConnectionRequest, rhs: Google_Cloud_Bigquery_Connection_V1beta1_DeleteConnectionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_Connection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Connection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "friendly_name"),
    3: .same(proto: "description"),
    4: .standard(proto: "cloud_sql"),
    5: .standard(proto: "creation_time"),
    6: .standard(proto: "last_modified_time"),
    7: .standard(proto: "has_credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.friendlyName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try {
        var v: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties?
        if let current = self.properties {
          try decoder.handleConflictingOneOf()
          if case .cloudSql(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.properties = .cloudSql(v)}
      }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.creationTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.lastModifiedTime) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hasCredential_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.friendlyName.isEmpty {
      try visitor.visitSingularStringField(value: self.friendlyName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if case .cloudSql(let v)? = self.properties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.creationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.creationTime, fieldNumber: 5)
    }
    if self.lastModifiedTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lastModifiedTime, fieldNumber: 6)
    }
    if self.hasCredential_p != false {
      try visitor.visitSingularBoolField(value: self.hasCredential_p, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_Connection, rhs: Google_Cloud_Bigquery_Connection_V1beta1_Connection) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.friendlyName != rhs.friendlyName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.creationTime != rhs.creationTime {return false}
    if lhs.lastModifiedTime != rhs.lastModifiedTime {return false}
    if lhs.hasCredential_p != rhs.hasCredential_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConnectionCredential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cloud_sql"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential?
        if let current = self.credential {
          try decoder.handleConflictingOneOf()
          if case .cloudSql(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.credential = .cloudSql(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .cloudSql(let v)? = self.credential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential, rhs: Google_Cloud_Bigquery_Connection_V1beta1_ConnectionCredential) -> Bool {
    if lhs.credential != rhs.credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudSqlProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_id"),
    2: .same(proto: "database"),
    3: .same(proto: "type"),
    4: .same(proto: "credential"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._credential) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 1)
    }
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 2)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    if let v = self._credential {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties, rhs: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties) -> Bool {
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs.database != rhs.database {return false}
    if lhs.type != rhs.type {return false}
    if lhs._credential != rhs._credential {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlProperties.DatabaseType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DATABASE_TYPE_UNSPECIFIED"),
    1: .same(proto: "POSTGRES"),
    2: .same(proto: "MYSQL"),
  ]
}

extension Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudSqlCredential"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential, rhs: Google_Cloud_Bigquery_Connection_V1beta1_CloudSqlCredential) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

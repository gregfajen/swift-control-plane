// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/scheduler/v1beta1/job.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Configuration for a job.
/// The maximum allowed size for a job is 100KB.
public struct Google_Cloud_Scheduler_V1beta1_Job {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optionally caller-specified in [CreateJob][google.cloud.scheduler.v1beta1.CloudScheduler.CreateJob], after
  /// which it becomes output only.
  ///
  /// The job name. For example:
  /// `projects/PROJECT_ID/locations/LOCATION_ID/jobs/JOB_ID`.
  ///
  /// * `PROJECT_ID` can contain letters ([A-Za-z]), numbers ([0-9]),
  ///    hyphens (-), colons (:), or periods (.).
  ///    For more information, see
  ///    [Identifying
  ///    projects](https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects)
  /// * `LOCATION_ID` is the canonical ID for the job's location.
  ///    The list of available locations can be obtained by calling
  ///    [ListLocations][google.cloud.location.Locations.ListLocations].
  ///    For more information, see https://cloud.google.com/about/locations/.
  /// * `JOB_ID` can contain only letters ([A-Za-z]), numbers ([0-9]),
  ///    hyphens (-), or underscores (_). The maximum length is 500 characters.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Optionally caller-specified in [CreateJob][google.cloud.scheduler.v1beta1.CloudScheduler.CreateJob] or
  /// [UpdateJob][google.cloud.scheduler.v1beta1.CloudScheduler.UpdateJob].
  ///
  /// A human-readable description for the job. This string must not contain
  /// more than 500 characters.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// Required.
  ///
  /// Delivery settings containing destination and parameters.
  public var target: OneOf_Target? {
    get {return _storage._target}
    set {_uniqueStorage()._target = newValue}
  }

  /// Pub/Sub target.
  public var pubsubTarget: Google_Cloud_Scheduler_V1beta1_PubsubTarget {
    get {
      if case .pubsubTarget(let v)? = _storage._target {return v}
      return Google_Cloud_Scheduler_V1beta1_PubsubTarget()
    }
    set {_uniqueStorage()._target = .pubsubTarget(newValue)}
  }

  /// App Engine HTTP target.
  public var appEngineHTTPTarget: Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget {
    get {
      if case .appEngineHTTPTarget(let v)? = _storage._target {return v}
      return Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget()
    }
    set {_uniqueStorage()._target = .appEngineHTTPTarget(newValue)}
  }

  /// HTTP target.
  public var httpTarget: Google_Cloud_Scheduler_V1beta1_HttpTarget {
    get {
      if case .httpTarget(let v)? = _storage._target {return v}
      return Google_Cloud_Scheduler_V1beta1_HttpTarget()
    }
    set {_uniqueStorage()._target = .httpTarget(newValue)}
  }

  /// Required, except when used with [UpdateJob][google.cloud.scheduler.v1beta1.CloudScheduler.UpdateJob].
  ///
  /// Describes the schedule on which the job will be executed.
  ///
  /// The schedule can be either of the following types:
  ///
  /// * [Crontab](http://en.wikipedia.org/wiki/Cron#Overview)
  /// * English-like
  /// [schedule](https://cloud.google.com/scheduler/docs/configuring/cron-job-schedules)
  ///
  /// As a general rule, execution `n + 1` of a job will not begin
  /// until execution `n` has finished. Cloud Scheduler will never
  /// allow two simultaneously outstanding executions. For example,
  /// this implies that if the `n+1`th execution is scheduled to run at
  /// 16:00 but the `n`th execution takes until 16:15, the `n+1`th
  /// execution will not start until `16:15`.
  /// A scheduled start time will be delayed if the previous
  /// execution has not ended when its scheduled time occurs.
  ///
  /// If [retry_count][google.cloud.scheduler.v1beta1.RetryConfig.retry_count] > 0 and a job attempt fails,
  /// the job will be tried a total of [retry_count][google.cloud.scheduler.v1beta1.RetryConfig.retry_count]
  /// times, with exponential backoff, until the next scheduled start
  /// time.
  public var schedule: String {
    get {return _storage._schedule}
    set {_uniqueStorage()._schedule = newValue}
  }

  /// Specifies the time zone to be used in interpreting
  /// [schedule][google.cloud.scheduler.v1beta1.Job.schedule]. The value of this field must be a time
  /// zone name from the [tz database](http://en.wikipedia.org/wiki/Tz_database).
  ///
  /// Note that some time zones include a provision for
  /// daylight savings time. The rules for daylight saving time are
  /// determined by the chosen tz. For UTC use the string "utc". If a
  /// time zone is not specified, the default will be in UTC (also known
  /// as GMT).
  public var timeZone: String {
    get {return _storage._timeZone}
    set {_uniqueStorage()._timeZone = newValue}
  }

  /// Output only. The creation time of the job.
  public var userUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._userUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._userUpdateTime = newValue}
  }
  /// Returns true if `userUpdateTime` has been explicitly set.
  public var hasUserUpdateTime: Bool {return _storage._userUpdateTime != nil}
  /// Clears the value of `userUpdateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUserUpdateTime() {_uniqueStorage()._userUpdateTime = nil}

  /// Output only. State of the job.
  public var state: Google_Cloud_Scheduler_V1beta1_Job.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. The response from the target for the last attempted execution.
  public var status: Google_Rpc_Status {
    get {return _storage._status ?? Google_Rpc_Status()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// Output only. The next time the job is scheduled. Note that this may be a
  /// retry of a previously failed attempt or the next execution time
  /// according to the schedule.
  public var scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduleTime = newValue}
  }
  /// Returns true if `scheduleTime` has been explicitly set.
  public var hasScheduleTime: Bool {return _storage._scheduleTime != nil}
  /// Clears the value of `scheduleTime`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleTime() {_uniqueStorage()._scheduleTime = nil}

  /// Output only. The time the last job attempt started.
  public var lastAttemptTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastAttemptTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastAttemptTime = newValue}
  }
  /// Returns true if `lastAttemptTime` has been explicitly set.
  public var hasLastAttemptTime: Bool {return _storage._lastAttemptTime != nil}
  /// Clears the value of `lastAttemptTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastAttemptTime() {_uniqueStorage()._lastAttemptTime = nil}

  /// Settings that determine the retry behavior.
  public var retryConfig: Google_Cloud_Scheduler_V1beta1_RetryConfig {
    get {return _storage._retryConfig ?? Google_Cloud_Scheduler_V1beta1_RetryConfig()}
    set {_uniqueStorage()._retryConfig = newValue}
  }
  /// Returns true if `retryConfig` has been explicitly set.
  public var hasRetryConfig: Bool {return _storage._retryConfig != nil}
  /// Clears the value of `retryConfig`. Subsequent reads from it will return its default value.
  public mutating func clearRetryConfig() {_uniqueStorage()._retryConfig = nil}

  /// The deadline for job attempts. If the request handler does not respond by
  /// this deadline then the request is cancelled and the attempt is marked as a
  /// `DEADLINE_EXCEEDED` failure. The failed attempt can be viewed in
  /// execution logs. Cloud Scheduler will retry the job according
  /// to the [RetryConfig][google.cloud.scheduler.v1beta1.RetryConfig].
  ///
  /// The allowed duration for this deadline is:
  ///
  /// * For [HTTP targets][google.cloud.scheduler.v1beta1.Job.http_target], between 15 seconds and 30 minutes.
  /// * For [App Engine HTTP targets][google.cloud.scheduler.v1beta1.Job.app_engine_http_target], between 15
  ///   seconds and 24 hours.
  /// * For [PubSub targets][google.cloud.scheduler.v1beta1.Job.pubsub_target], this field is ignored.
  public var attemptDeadline: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._attemptDeadline ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._attemptDeadline = newValue}
  }
  /// Returns true if `attemptDeadline` has been explicitly set.
  public var hasAttemptDeadline: Bool {return _storage._attemptDeadline != nil}
  /// Clears the value of `attemptDeadline`. Subsequent reads from it will return its default value.
  public mutating func clearAttemptDeadline() {_uniqueStorage()._attemptDeadline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required.
  ///
  /// Delivery settings containing destination and parameters.
  public enum OneOf_Target: Equatable {
    /// Pub/Sub target.
    case pubsubTarget(Google_Cloud_Scheduler_V1beta1_PubsubTarget)
    /// App Engine HTTP target.
    case appEngineHTTPTarget(Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget)
    /// HTTP target.
    case httpTarget(Google_Cloud_Scheduler_V1beta1_HttpTarget)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_Job.OneOf_Target, rhs: Google_Cloud_Scheduler_V1beta1_Job.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pubsubTarget, .pubsubTarget): return {
        guard case .pubsubTarget(let l) = lhs, case .pubsubTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appEngineHTTPTarget, .appEngineHTTPTarget): return {
        guard case .appEngineHTTPTarget(let l) = lhs, case .appEngineHTTPTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpTarget, .httpTarget): return {
        guard case .httpTarget(let l) = lhs, case .httpTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// State of the job.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified state.
    case unspecified // = 0

    /// The job is executing normally.
    case enabled // = 1

    /// The job is paused by the user. It will not execute. A user can
    /// intentionally pause the job using
    /// [PauseJobRequest][google.cloud.scheduler.v1beta1.PauseJobRequest].
    case paused // = 2

    /// The job is disabled by the system due to error. The user
    /// cannot directly set a job to be disabled.
    case disabled // = 3

    /// The job state resulting from a failed [CloudScheduler.UpdateJob][google.cloud.scheduler.v1beta1.CloudScheduler.UpdateJob]
    /// operation. To recover a job from this state, retry
    /// [CloudScheduler.UpdateJob][google.cloud.scheduler.v1beta1.CloudScheduler.UpdateJob] until a successful response is received.
    case updateFailed // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enabled
      case 2: self = .paused
      case 3: self = .disabled
      case 4: self = .updateFailed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enabled: return 1
      case .paused: return 2
      case .disabled: return 3
      case .updateFailed: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Cloud_Scheduler_V1beta1_Job.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Scheduler_V1beta1_Job.State] = [
    .unspecified,
    .enabled,
    .paused,
    .disabled,
    .updateFailed,
  ]
}

#endif  // swift(>=4.2)

/// Settings that determine the retry behavior.
///
/// By default, if a job does not complete successfully (meaning that
/// an acknowledgement is not received from the handler, then it will be retried
/// with exponential backoff according to the settings in [RetryConfig][google.cloud.scheduler.v1beta1.RetryConfig].
public struct Google_Cloud_Scheduler_V1beta1_RetryConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of attempts that the system will make to run a job using the
  /// exponential backoff procedure described by
  /// [max_doublings][google.cloud.scheduler.v1beta1.RetryConfig.max_doublings].
  ///
  /// The default value of retry_count is zero.
  ///
  /// If retry_count is zero, a job attempt will *not* be retried if
  /// it fails. Instead the Cloud Scheduler system will wait for the
  /// next scheduled execution time.
  ///
  /// If retry_count is set to a non-zero number then Cloud Scheduler
  /// will retry failed attempts, using exponential backoff,
  /// retry_count times, or until the next scheduled execution time,
  /// whichever comes first.
  ///
  /// Values greater than 5 and negative values are not allowed.
  public var retryCount: Int32 = 0

  /// The time limit for retrying a failed job, measured from time when an
  /// execution was first attempted. If specified with
  /// [retry_count][google.cloud.scheduler.v1beta1.RetryConfig.retry_count], the job will be retried until both
  /// limits are reached.
  ///
  /// The default value for max_retry_duration is zero, which means retry
  /// duration is unlimited.
  public var maxRetryDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxRetryDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxRetryDuration = newValue}
  }
  /// Returns true if `maxRetryDuration` has been explicitly set.
  public var hasMaxRetryDuration: Bool {return self._maxRetryDuration != nil}
  /// Clears the value of `maxRetryDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxRetryDuration() {self._maxRetryDuration = nil}

  /// The minimum amount of time to wait before retrying a job after
  /// it fails.
  ///
  /// The default value of this field is 5 seconds.
  public var minBackoffDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minBackoffDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minBackoffDuration = newValue}
  }
  /// Returns true if `minBackoffDuration` has been explicitly set.
  public var hasMinBackoffDuration: Bool {return self._minBackoffDuration != nil}
  /// Clears the value of `minBackoffDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMinBackoffDuration() {self._minBackoffDuration = nil}

  /// The maximum amount of time to wait before retrying a job after
  /// it fails.
  ///
  /// The default value of this field is 1 hour.
  public var maxBackoffDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxBackoffDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxBackoffDuration = newValue}
  }
  /// Returns true if `maxBackoffDuration` has been explicitly set.
  public var hasMaxBackoffDuration: Bool {return self._maxBackoffDuration != nil}
  /// Clears the value of `maxBackoffDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMaxBackoffDuration() {self._maxBackoffDuration = nil}

  /// The time between retries will double `max_doublings` times.
  ///
  /// A job's retry interval starts at
  /// [min_backoff_duration][google.cloud.scheduler.v1beta1.RetryConfig.min_backoff_duration], then doubles
  /// `max_doublings` times, then increases linearly, and finally
  /// retries retries at intervals of
  /// [max_backoff_duration][google.cloud.scheduler.v1beta1.RetryConfig.max_backoff_duration] up to
  /// [retry_count][google.cloud.scheduler.v1beta1.RetryConfig.retry_count] times.
  ///
  /// For example, if [min_backoff_duration][google.cloud.scheduler.v1beta1.RetryConfig.min_backoff_duration] is
  /// 10s, [max_backoff_duration][google.cloud.scheduler.v1beta1.RetryConfig.max_backoff_duration] is 300s, and
  /// `max_doublings` is 3, then the a job will first be retried in 10s. The
  /// retry interval will double three times, and then increase linearly by
  /// 2^3 * 10s.  Finally, the job will retry at intervals of
  /// [max_backoff_duration][google.cloud.scheduler.v1beta1.RetryConfig.max_backoff_duration] until the job has
  /// been attempted [retry_count][google.cloud.scheduler.v1beta1.RetryConfig.retry_count] times. Thus, the
  /// requests will retry at 10s, 20s, 40s, 80s, 160s, 240s, 300s, 300s, ....
  ///
  /// The default value of this field is 5.
  public var maxDoublings: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maxRetryDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _minBackoffDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxBackoffDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.scheduler.v1beta1"

extension Google_Cloud_Scheduler_V1beta1_Job: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Job"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    4: .standard(proto: "pubsub_target"),
    5: .standard(proto: "app_engine_http_target"),
    6: .standard(proto: "http_target"),
    20: .same(proto: "schedule"),
    21: .standard(proto: "time_zone"),
    9: .standard(proto: "user_update_time"),
    10: .same(proto: "state"),
    11: .same(proto: "status"),
    17: .standard(proto: "schedule_time"),
    18: .standard(proto: "last_attempt_time"),
    19: .standard(proto: "retry_config"),
    22: .standard(proto: "attempt_deadline"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _target: Google_Cloud_Scheduler_V1beta1_Job.OneOf_Target?
    var _schedule: String = String()
    var _timeZone: String = String()
    var _userUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Google_Cloud_Scheduler_V1beta1_Job.State = .unspecified
    var _status: Google_Rpc_Status? = nil
    var _scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastAttemptTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _retryConfig: Google_Cloud_Scheduler_V1beta1_RetryConfig? = nil
    var _attemptDeadline: SwiftProtobuf.Google_Protobuf_Duration? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _target = source._target
      _schedule = source._schedule
      _timeZone = source._timeZone
      _userUpdateTime = source._userUpdateTime
      _state = source._state
      _status = source._status
      _scheduleTime = source._scheduleTime
      _lastAttemptTime = source._lastAttemptTime
      _retryConfig = source._retryConfig
      _attemptDeadline = source._attemptDeadline
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 4: try {
          var v: Google_Cloud_Scheduler_V1beta1_PubsubTarget?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .pubsubTarget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .pubsubTarget(v)}
        }()
        case 5: try {
          var v: Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .appEngineHTTPTarget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .appEngineHTTPTarget(v)}
        }()
        case 6: try {
          var v: Google_Cloud_Scheduler_V1beta1_HttpTarget?
          if let current = _storage._target {
            try decoder.handleConflictingOneOf()
            if case .httpTarget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._target = .httpTarget(v)}
        }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._userUpdateTime) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleTime) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptTime) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._retryConfig) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._schedule) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._timeZone) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._attemptDeadline) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._target {
      case .pubsubTarget?: try {
        guard case .pubsubTarget(let v)? = _storage._target else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .appEngineHTTPTarget?: try {
        guard case .appEngineHTTPTarget(let v)? = _storage._target else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .httpTarget?: try {
        guard case .httpTarget(let v)? = _storage._target else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if let v = _storage._userUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 10)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._scheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._lastAttemptTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._retryConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if !_storage._schedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._schedule, fieldNumber: 20)
      }
      if !_storage._timeZone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._timeZone, fieldNumber: 21)
      }
      if let v = _storage._attemptDeadline {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_Job, rhs: Google_Cloud_Scheduler_V1beta1_Job) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._timeZone != rhs_storage._timeZone {return false}
        if _storage._userUpdateTime != rhs_storage._userUpdateTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._scheduleTime != rhs_storage._scheduleTime {return false}
        if _storage._lastAttemptTime != rhs_storage._lastAttemptTime {return false}
        if _storage._retryConfig != rhs_storage._retryConfig {return false}
        if _storage._attemptDeadline != rhs_storage._attemptDeadline {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Scheduler_V1beta1_Job.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ENABLED"),
    2: .same(proto: "PAUSED"),
    3: .same(proto: "DISABLED"),
    4: .same(proto: "UPDATE_FAILED"),
  ]
}

extension Google_Cloud_Scheduler_V1beta1_RetryConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "retry_count"),
    2: .standard(proto: "max_retry_duration"),
    3: .standard(proto: "min_backoff_duration"),
    4: .standard(proto: "max_backoff_duration"),
    5: .standard(proto: "max_doublings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.retryCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxRetryDuration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minBackoffDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maxBackoffDuration) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxDoublings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retryCount != 0 {
      try visitor.visitSingularInt32Field(value: self.retryCount, fieldNumber: 1)
    }
    if let v = self._maxRetryDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._minBackoffDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._maxBackoffDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.maxDoublings != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDoublings, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_RetryConfig, rhs: Google_Cloud_Scheduler_V1beta1_RetryConfig) -> Bool {
    if lhs.retryCount != rhs.retryCount {return false}
    if lhs._maxRetryDuration != rhs._maxRetryDuration {return false}
    if lhs._minBackoffDuration != rhs._minBackoffDuration {return false}
    if lhs._maxBackoffDuration != rhs._maxBackoffDuration {return false}
    if lhs.maxDoublings != rhs.maxDoublings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

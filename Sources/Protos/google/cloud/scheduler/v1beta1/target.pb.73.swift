// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/cloud/scheduler/v1beta1/target.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The HTTP method used to execute the job.
public enum Google_Cloud_Scheduler_V1beta1_HttpMethod: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// HTTP method unspecified. Defaults to POST.
  case unspecified // = 0

  /// HTTP POST
  case post // = 1

  /// HTTP GET
  case get // = 2

  /// HTTP HEAD
  case head // = 3

  /// HTTP PUT
  case put // = 4

  /// HTTP DELETE
  case delete // = 5

  /// HTTP PATCH
  case patch // = 6

  /// HTTP OPTIONS
  case options // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .post
    case 2: self = .get
    case 3: self = .head
    case 4: self = .put
    case 5: self = .delete
    case 6: self = .patch
    case 7: self = .options
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .post: return 1
    case .get: return 2
    case .head: return 3
    case .put: return 4
    case .delete: return 5
    case .patch: return 6
    case .options: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Cloud_Scheduler_V1beta1_HttpMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Cloud_Scheduler_V1beta1_HttpMethod] = [
    .unspecified,
    .post,
    .get,
    .head,
    .put,
    .delete,
    .patch,
    .options,
  ]
}

#endif  // swift(>=4.2)

/// Http target. The job will be pushed to the job handler by means of
/// an HTTP request via an [http_method][google.cloud.scheduler.v1beta1.HttpTarget.http_method] such as HTTP
/// POST, HTTP GET, etc. The job is acknowledged by means of an HTTP
/// response code in the range [200 - 299]. A failure to receive a response
/// constitutes a failed execution. For a redirected request, the response
/// returned by the redirected request is considered.
public struct Google_Cloud_Scheduler_V1beta1_HttpTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full URI path that the request will be sent to. This string
  /// must begin with either "http://" or "https://". Some examples of
  /// valid values for [uri][google.cloud.scheduler.v1beta1.HttpTarget.uri] are:
  /// `http://acme.com` and `https://acme.com/sales:8080`. Cloud Scheduler will
  /// encode some characters for safety and compatibility. The maximum allowed
  /// URL length is 2083 characters after encoding.
  public var uri: String = String()

  /// Which HTTP method to use for the request.
  public var httpMethod: Google_Cloud_Scheduler_V1beta1_HttpMethod = .unspecified

  /// The user can specify HTTP request headers to send with the job's
  /// HTTP request. This map contains the header field names and
  /// values. Repeated headers are not supported, but a header value can
  /// contain commas. These headers represent a subset of the headers
  /// that will accompany the job's HTTP request. Some HTTP request
  /// headers will be ignored or replaced. A partial list of headers that
  /// will be ignored or replaced is below:
  /// - Host: This will be computed by Cloud Scheduler and derived from
  /// [uri][google.cloud.scheduler.v1beta1.HttpTarget.uri].
  /// * `Content-Length`: This will be computed by Cloud Scheduler.
  /// * `User-Agent`: This will be set to `"Google-Cloud-Scheduler"`.
  /// * `X-Google-*`: Google internal use only.
  /// * `X-AppEngine-*`: Google internal use only.
  ///
  /// The total size of headers must be less than 80KB.
  public var headers: Dictionary<String,String> = [:]

  /// HTTP request body. A request body is allowed only if the HTTP
  /// method is POST, PUT, or PATCH. It is an error to set body on a job with an
  /// incompatible [HttpMethod][google.cloud.scheduler.v1beta1.HttpMethod].
  public var body: Data = Data()

  /// The mode for generating an `Authorization` header for HTTP requests.
  ///
  /// If specified, all `Authorization` headers in the [HttpTarget.headers][google.cloud.scheduler.v1beta1.HttpTarget.headers]
  /// field will be overridden.
  public var authorizationHeader: Google_Cloud_Scheduler_V1beta1_HttpTarget.OneOf_AuthorizationHeader? = nil

  /// If specified, an
  /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
  /// will be generated and attached as an `Authorization` header in the HTTP
  /// request.
  ///
  /// This type of authorization should generally only be used when calling
  /// Google APIs hosted on *.googleapis.com.
  public var oauthToken: Google_Cloud_Scheduler_V1beta1_OAuthToken {
    get {
      if case .oauthToken(let v)? = authorizationHeader {return v}
      return Google_Cloud_Scheduler_V1beta1_OAuthToken()
    }
    set {authorizationHeader = .oauthToken(newValue)}
  }

  /// If specified, an
  /// [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
  /// token will be generated and attached as an `Authorization` header in the
  /// HTTP request.
  ///
  /// This type of authorization can be used for many scenarios, including
  /// calling Cloud Run, or endpoints where you intend to validate the token
  /// yourself.
  public var oidcToken: Google_Cloud_Scheduler_V1beta1_OidcToken {
    get {
      if case .oidcToken(let v)? = authorizationHeader {return v}
      return Google_Cloud_Scheduler_V1beta1_OidcToken()
    }
    set {authorizationHeader = .oidcToken(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The mode for generating an `Authorization` header for HTTP requests.
  ///
  /// If specified, all `Authorization` headers in the [HttpTarget.headers][google.cloud.scheduler.v1beta1.HttpTarget.headers]
  /// field will be overridden.
  public enum OneOf_AuthorizationHeader: Equatable {
    /// If specified, an
    /// [OAuth token](https://developers.google.com/identity/protocols/OAuth2)
    /// will be generated and attached as an `Authorization` header in the HTTP
    /// request.
    ///
    /// This type of authorization should generally only be used when calling
    /// Google APIs hosted on *.googleapis.com.
    case oauthToken(Google_Cloud_Scheduler_V1beta1_OAuthToken)
    /// If specified, an
    /// [OIDC](https://developers.google.com/identity/protocols/OpenIDConnect)
    /// token will be generated and attached as an `Authorization` header in the
    /// HTTP request.
    ///
    /// This type of authorization can be used for many scenarios, including
    /// calling Cloud Run, or endpoints where you intend to validate the token
    /// yourself.
    case oidcToken(Google_Cloud_Scheduler_V1beta1_OidcToken)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_HttpTarget.OneOf_AuthorizationHeader, rhs: Google_Cloud_Scheduler_V1beta1_HttpTarget.OneOf_AuthorizationHeader) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.oauthToken, .oauthToken): return {
        guard case .oauthToken(let l) = lhs, case .oauthToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oidcToken, .oidcToken): return {
        guard case .oidcToken(let l) = lhs, case .oidcToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// App Engine target. The job will be pushed to a job handler by means
/// of an HTTP request via an [http_method][google.cloud.scheduler.v1beta1.AppEngineHttpTarget.http_method] such
/// as HTTP POST, HTTP GET, etc. The job is acknowledged by means of an
/// HTTP response code in the range [200 - 299]. Error 503 is
/// considered an App Engine system error instead of an application
/// error. Requests returning error 503 will be retried regardless of
/// retry configuration and not counted against retry counts. Any other
/// response code, or a failure to receive a response before the
/// deadline, constitutes a failed attempt.
public struct Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The HTTP method to use for the request. PATCH and OPTIONS are not
  /// permitted.
  public var httpMethod: Google_Cloud_Scheduler_V1beta1_HttpMethod = .unspecified

  /// App Engine Routing setting for the job.
  public var appEngineRouting: Google_Cloud_Scheduler_V1beta1_AppEngineRouting {
    get {return _appEngineRouting ?? Google_Cloud_Scheduler_V1beta1_AppEngineRouting()}
    set {_appEngineRouting = newValue}
  }
  /// Returns true if `appEngineRouting` has been explicitly set.
  public var hasAppEngineRouting: Bool {return self._appEngineRouting != nil}
  /// Clears the value of `appEngineRouting`. Subsequent reads from it will return its default value.
  public mutating func clearAppEngineRouting() {self._appEngineRouting = nil}

  /// The relative URI.
  ///
  /// The relative URL must begin with "/" and must be a valid HTTP relative URL.
  /// It can contain a path, query string arguments, and `#` fragments.
  /// If the relative URL is empty, then the root path "/" will be used.
  /// No spaces are allowed, and the maximum length allowed is 2083 characters.
  public var relativeUri: String = String()

  /// HTTP request headers.
  ///
  /// This map contains the header field names and values. Headers can be set
  /// when the job is created.
  ///
  /// Cloud Scheduler sets some headers to default values:
  ///
  /// * `User-Agent`: By default, this header is
  ///   `"AppEngine-Google; (+http://code.google.com/appengine)"`.
  ///   This header can be modified, but Cloud Scheduler will append
  ///   `"AppEngine-Google; (+http://code.google.com/appengine)"` to the
  ///   modified `User-Agent`.
  /// * `X-CloudScheduler`: This header will be set to true.
  ///
  /// If the job has an [body][google.cloud.scheduler.v1beta1.AppEngineHttpTarget.body], Cloud Scheduler sets
  /// the following headers:
  ///
  /// * `Content-Type`: By default, the `Content-Type` header is set to
  ///   `"application/octet-stream"`. The default can be overridden by explictly
  ///   setting `Content-Type` to a particular media type when the job is
  ///   created.
  ///   For example, `Content-Type` can be set to `"application/json"`.
  /// * `Content-Length`: This is computed by Cloud Scheduler. This value is
  ///   output only. It cannot be changed.
  ///
  /// The headers below are output only. They cannot be set or overridden:
  ///
  /// * `X-Google-*`: For Google internal use only.
  /// * `X-AppEngine-*`: For Google internal use only.
  ///
  /// In addition, some App Engine headers, which contain
  /// job-specific information, are also be sent to the job handler.
  public var headers: Dictionary<String,String> = [:]

  /// Body.
  ///
  /// HTTP request body. A request body is allowed only if the HTTP method is
  /// POST or PUT. It will result in invalid argument error to set a body on a
  /// job with an incompatible [HttpMethod][google.cloud.scheduler.v1beta1.HttpMethod].
  public var body: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _appEngineRouting: Google_Cloud_Scheduler_V1beta1_AppEngineRouting? = nil
}

/// Pub/Sub target. The job will be delivered by publishing a message to
/// the given Pub/Sub topic.
public struct Google_Cloud_Scheduler_V1beta1_PubsubTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the Cloud Pub/Sub topic to which messages will
  /// be published when a job is delivered. The topic name must be in the
  /// same format as required by PubSub's
  /// [PublishRequest.name](https://cloud.google.com/pubsub/docs/reference/rpc/google.pubsub.v1#publishrequest),
  /// for example `projects/PROJECT_ID/topics/TOPIC_ID`.
  ///
  /// The topic must be in the same project as the Cloud Scheduler job.
  public var topicName: String = String()

  /// The message payload for PubsubMessage.
  ///
  /// Pubsub message must contain either non-empty data, or at least one
  /// attribute.
  public var data: Data = Data()

  /// Attributes for PubsubMessage.
  ///
  /// Pubsub message must contain either non-empty data, or at least one
  /// attribute.
  public var attributes: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// App Engine Routing.
///
/// For more information about services, versions, and instances see
/// [An Overview of App
/// Engine](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine),
/// [Microservices Architecture on Google App
/// Engine](https://cloud.google.com/appengine/docs/python/microservices-on-app-engine),
/// [App Engine Standard request
/// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed),
/// and [App Engine Flex request
/// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
public struct Google_Cloud_Scheduler_V1beta1_AppEngineRouting {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// App service.
  ///
  /// By default, the job is sent to the service which is the default
  /// service when the job is attempted.
  public var service: String = String()

  /// App version.
  ///
  /// By default, the job is sent to the version which is the default
  /// version when the job is attempted.
  public var version: String = String()

  /// App instance.
  ///
  /// By default, the job is sent to an instance which is available when
  /// the job is attempted.
  ///
  /// Requests can only be sent to a specific instance if
  /// [manual scaling is used in App Engine
  /// Standard](https://cloud.google.com/appengine/docs/python/an-overview-of-app-engine?hl=en_US#scaling_types_and_instance_classes).
  /// App Engine Flex does not support instances. For more information, see
  /// [App Engine Standard request
  /// routing](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed)
  /// and [App Engine Flex request
  /// routing](https://cloud.google.com/appengine/docs/flexible/python/how-requests-are-routed).
  public var instance: String = String()

  /// Output only. The host that the job is sent to.
  ///
  /// For more information about how App Engine requests are routed, see
  /// [here](https://cloud.google.com/appengine/docs/standard/python/how-requests-are-routed).
  ///
  /// The host is constructed as:
  ///
  ///
  /// * `host = [application_domain_name]`</br>
  ///   `| [service] + '.' + [application_domain_name]`</br>
  ///   `| [version] + '.' + [application_domain_name]`</br>
  ///   `| [version_dot_service]+ '.' + [application_domain_name]`</br>
  ///   `| [instance] + '.' + [application_domain_name]`</br>
  ///   `| [instance_dot_service] + '.' + [application_domain_name]`</br>
  ///   `| [instance_dot_version] + '.' + [application_domain_name]`</br>
  ///   `| [instance_dot_version_dot_service] + '.' + [application_domain_name]`
  ///
  /// * `application_domain_name` = The domain name of the app, for
  ///   example <app-id>.appspot.com, which is associated with the
  ///   job's project ID.
  ///
  /// * `service =` [service][google.cloud.scheduler.v1beta1.AppEngineRouting.service]
  ///
  /// * `version =` [version][google.cloud.scheduler.v1beta1.AppEngineRouting.version]
  ///
  /// * `version_dot_service =`
  ///   [version][google.cloud.scheduler.v1beta1.AppEngineRouting.version] `+ '.' +`
  ///   [service][google.cloud.scheduler.v1beta1.AppEngineRouting.service]
  ///
  /// * `instance =` [instance][google.cloud.scheduler.v1beta1.AppEngineRouting.instance]
  ///
  /// * `instance_dot_service =`
  ///   [instance][google.cloud.scheduler.v1beta1.AppEngineRouting.instance] `+ '.' +`
  ///   [service][google.cloud.scheduler.v1beta1.AppEngineRouting.service]
  ///
  /// * `instance_dot_version =`
  ///   [instance][google.cloud.scheduler.v1beta1.AppEngineRouting.instance] `+ '.' +`
  ///   [version][google.cloud.scheduler.v1beta1.AppEngineRouting.version]
  ///
  /// * `instance_dot_version_dot_service =`
  ///   [instance][google.cloud.scheduler.v1beta1.AppEngineRouting.instance] `+ '.' +`
  ///   [version][google.cloud.scheduler.v1beta1.AppEngineRouting.version] `+ '.' +`
  ///   [service][google.cloud.scheduler.v1beta1.AppEngineRouting.service]
  ///
  ///
  /// If [service][google.cloud.scheduler.v1beta1.AppEngineRouting.service] is empty, then the job will be sent
  /// to the service which is the default service when the job is attempted.
  ///
  /// If [version][google.cloud.scheduler.v1beta1.AppEngineRouting.version] is empty, then the job will be sent
  /// to the version which is the default version when the job is attempted.
  ///
  /// If [instance][google.cloud.scheduler.v1beta1.AppEngineRouting.instance] is empty, then the job will be
  /// sent to an instance which is available when the job is attempted.
  ///
  /// If [service][google.cloud.scheduler.v1beta1.AppEngineRouting.service],
  /// [version][google.cloud.scheduler.v1beta1.AppEngineRouting.version], or
  /// [instance][google.cloud.scheduler.v1beta1.AppEngineRouting.instance] is invalid, then the job will be sent
  /// to the default version of the default service when the job is attempted.
  public var host: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains information needed for generating an
/// [OAuth token](https://developers.google.com/identity/protocols/OAuth2).
/// This type of authorization should generally only be used when calling Google
/// APIs hosted on *.googleapis.com.
public struct Google_Cloud_Scheduler_V1beta1_OAuthToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// to be used for generating OAuth token.
  /// The service account must be within the same project as the job. The caller
  /// must have iam.serviceAccounts.actAs permission for the service account.
  public var serviceAccountEmail: String = String()

  /// OAuth scope to be used for generating OAuth access token.
  /// If not specified, "https://www.googleapis.com/auth/cloud-platform"
  /// will be used.
  public var scope: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains information needed for generating an
/// [OpenID Connect
/// token](https://developers.google.com/identity/protocols/OpenIDConnect).
/// This type of authorization can be used for many scenarios, including
/// calling Cloud Run, or endpoints where you intend to validate the token
/// yourself.
public struct Google_Cloud_Scheduler_V1beta1_OidcToken {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Service account email](https://cloud.google.com/iam/docs/service-accounts)
  /// to be used for generating OIDC token.
  /// The service account must be within the same project as the job. The caller
  /// must have iam.serviceAccounts.actAs permission for the service account.
  public var serviceAccountEmail: String = String()

  /// Audience to be used when generating OIDC token. If not specified, the URI
  /// specified in target will be used.
  public var audience: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.cloud.scheduler.v1beta1"

extension Google_Cloud_Scheduler_V1beta1_HttpMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HTTP_METHOD_UNSPECIFIED"),
    1: .same(proto: "POST"),
    2: .same(proto: "GET"),
    3: .same(proto: "HEAD"),
    4: .same(proto: "PUT"),
    5: .same(proto: "DELETE"),
    6: .same(proto: "PATCH"),
    7: .same(proto: "OPTIONS"),
  ]
}

extension Google_Cloud_Scheduler_V1beta1_HttpTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uri"),
    2: .standard(proto: "http_method"),
    3: .same(proto: "headers"),
    4: .same(proto: "body"),
    5: .standard(proto: "oauth_token"),
    6: .standard(proto: "oidc_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.httpMethod) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      case 5: try {
        var v: Google_Cloud_Scheduler_V1beta1_OAuthToken?
        if let current = self.authorizationHeader {
          try decoder.handleConflictingOneOf()
          if case .oauthToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.authorizationHeader = .oauthToken(v)}
      }()
      case 6: try {
        var v: Google_Cloud_Scheduler_V1beta1_OidcToken?
        if let current = self.authorizationHeader {
          try decoder.handleConflictingOneOf()
          if case .oidcToken(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.authorizationHeader = .oidcToken(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 1)
    }
    if self.httpMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.httpMethod, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 3)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.authorizationHeader {
    case .oauthToken?: try {
      guard case .oauthToken(let v)? = self.authorizationHeader else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .oidcToken?: try {
      guard case .oidcToken(let v)? = self.authorizationHeader else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_HttpTarget, rhs: Google_Cloud_Scheduler_V1beta1_HttpTarget) -> Bool {
    if lhs.uri != rhs.uri {return false}
    if lhs.httpMethod != rhs.httpMethod {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.body != rhs.body {return false}
    if lhs.authorizationHeader != rhs.authorizationHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppEngineHttpTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http_method"),
    2: .standard(proto: "app_engine_routing"),
    3: .standard(proto: "relative_uri"),
    4: .same(proto: "headers"),
    5: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.httpMethod) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._appEngineRouting) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relativeUri) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.httpMethod != .unspecified {
      try visitor.visitSingularEnumField(value: self.httpMethod, fieldNumber: 1)
    }
    if let v = self._appEngineRouting {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.relativeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.relativeUri, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 4)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget, rhs: Google_Cloud_Scheduler_V1beta1_AppEngineHttpTarget) -> Bool {
    if lhs.httpMethod != rhs.httpMethod {return false}
    if lhs._appEngineRouting != rhs._appEngineRouting {return false}
    if lhs.relativeUri != rhs.relativeUri {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Scheduler_V1beta1_PubsubTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubsubTarget"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "topic_name"),
    3: .same(proto: "data"),
    4: .same(proto: "attributes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.topicName) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.topicName.isEmpty {
      try visitor.visitSingularStringField(value: self.topicName, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    if !self.attributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_PubsubTarget, rhs: Google_Cloud_Scheduler_V1beta1_PubsubTarget) -> Bool {
    if lhs.topicName != rhs.topicName {return false}
    if lhs.data != rhs.data {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Scheduler_V1beta1_AppEngineRouting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppEngineRouting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .same(proto: "version"),
    3: .same(proto: "instance"),
    4: .same(proto: "host"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.instance) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.host) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.instance.isEmpty {
      try visitor.visitSingularStringField(value: self.instance, fieldNumber: 3)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_AppEngineRouting, rhs: Google_Cloud_Scheduler_V1beta1_AppEngineRouting) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.version != rhs.version {return false}
    if lhs.instance != rhs.instance {return false}
    if lhs.host != rhs.host {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Scheduler_V1beta1_OAuthToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OAuthToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_account_email"),
    2: .same(proto: "scope"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scope) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 1)
    }
    if !self.scope.isEmpty {
      try visitor.visitSingularStringField(value: self.scope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_OAuthToken, rhs: Google_Cloud_Scheduler_V1beta1_OAuthToken) -> Bool {
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Cloud_Scheduler_V1beta1_OidcToken: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OidcToken"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_account_email"),
    2: .same(proto: "audience"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountEmail) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.audience) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountEmail, fieldNumber: 1)
    }
    if !self.audience.isEmpty {
      try visitor.visitSingularStringField(value: self.audience, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Cloud_Scheduler_V1beta1_OidcToken, rhs: Google_Cloud_Scheduler_V1beta1_OidcToken) -> Bool {
    if lhs.serviceAccountEmail != rhs.serviceAccountEmail {return false}
    if lhs.audience != rhs.audience {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

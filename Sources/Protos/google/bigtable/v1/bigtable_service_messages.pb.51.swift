// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/v1/bigtable_service_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for BigtableServer.ReadRows.
public struct Google_Bigtable_V1_ReadRowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table from which to read.
  public var tableName: String = String()

  /// If neither row_key nor row_range is set, reads from all rows.
  public var target: Google_Bigtable_V1_ReadRowsRequest.OneOf_Target? = nil

  /// The key of a single row from which to read.
  public var rowKey: Data {
    get {
      if case .rowKey(let v)? = target {return v}
      return Data()
    }
    set {target = .rowKey(newValue)}
  }

  /// A range of rows from which to read.
  public var rowRange: Google_Bigtable_V1_RowRange {
    get {
      if case .rowRange(let v)? = target {return v}
      return Google_Bigtable_V1_RowRange()
    }
    set {target = .rowRange(newValue)}
  }

  /// A set of rows from which to read. Entries need not be in order, and will
  /// be deduplicated before reading.
  /// The total serialized size of the set must not exceed 1MB.
  public var rowSet: Google_Bigtable_V1_RowSet {
    get {
      if case .rowSet(let v)? = target {return v}
      return Google_Bigtable_V1_RowSet()
    }
    set {target = .rowSet(newValue)}
  }

  /// The filter to apply to the contents of the specified row(s). If unset,
  /// reads the entire table.
  public var filter: Google_Bigtable_V1_RowFilter {
    get {return _filter ?? Google_Bigtable_V1_RowFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  /// By default, rows are read sequentially, producing results which are
  /// guaranteed to arrive in increasing row order. Setting
  /// "allow_row_interleaving" to true allows multiple rows to be interleaved in
  /// the response stream, which increases throughput but breaks this guarantee,
  /// and may force the client to use more memory to buffer partially-received
  /// rows. Cannot be set to true when specifying "num_rows_limit".
  public var allowRowInterleaving: Bool = false

  /// The read will terminate after committing to N rows' worth of results. The
  /// default (zero) is to return all results.
  /// Note that "allow_row_interleaving" cannot be set to true when this is set.
  public var numRowsLimit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If neither row_key nor row_range is set, reads from all rows.
  public enum OneOf_Target: Equatable {
    /// The key of a single row from which to read.
    case rowKey(Data)
    /// A range of rows from which to read.
    case rowRange(Google_Bigtable_V1_RowRange)
    /// A set of rows from which to read. Entries need not be in order, and will
    /// be deduplicated before reading.
    /// The total serialized size of the set must not exceed 1MB.
    case rowSet(Google_Bigtable_V1_RowSet)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V1_ReadRowsRequest.OneOf_Target, rhs: Google_Bigtable_V1_ReadRowsRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rowKey, .rowKey): return {
        guard case .rowKey(let l) = lhs, case .rowKey(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rowRange, .rowRange): return {
        guard case .rowRange(let l) = lhs, case .rowRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rowSet, .rowSet): return {
        guard case .rowSet(let l) = lhs, case .rowSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _filter: Google_Bigtable_V1_RowFilter? = nil
}

/// Response message for BigtableService.ReadRows.
public struct Google_Bigtable_V1_ReadRowsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key of the row for which we're receiving data.
  /// Results will be received in increasing row key order, unless
  /// "allow_row_interleaving" was specified in the request.
  public var rowKey: Data = Data()

  /// One or more chunks of the row specified by "row_key".
  public var chunks: [Google_Bigtable_V1_ReadRowsResponse.Chunk] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies a piece of a row's contents returned as part of the read
  /// response stream.
  public struct Chunk {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var chunk: Google_Bigtable_V1_ReadRowsResponse.Chunk.OneOf_Chunk? = nil

    /// A subset of the data from a particular row. As long as no "reset_row"
    /// is received in between, multiple "row_contents" from the same row are
    /// from the same atomic view of that row, and will be received in the
    /// expected family/column/timestamp order.
    public var rowContents: Google_Bigtable_V1_Family {
      get {
        if case .rowContents(let v)? = chunk {return v}
        return Google_Bigtable_V1_Family()
      }
      set {chunk = .rowContents(newValue)}
    }

    /// Indicates that the client should drop all previous chunks for
    /// "row_key", as it will be re-read from the beginning.
    public var resetRow: Bool {
      get {
        if case .resetRow(let v)? = chunk {return v}
        return false
      }
      set {chunk = .resetRow(newValue)}
    }

    /// Indicates that the client can safely process all previous chunks for
    /// "row_key", as its data has been fully read.
    public var commitRow: Bool {
      get {
        if case .commitRow(let v)? = chunk {return v}
        return false
      }
      set {chunk = .commitRow(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Chunk: Equatable {
      /// A subset of the data from a particular row. As long as no "reset_row"
      /// is received in between, multiple "row_contents" from the same row are
      /// from the same atomic view of that row, and will be received in the
      /// expected family/column/timestamp order.
      case rowContents(Google_Bigtable_V1_Family)
      /// Indicates that the client should drop all previous chunks for
      /// "row_key", as it will be re-read from the beginning.
      case resetRow(Bool)
      /// Indicates that the client can safely process all previous chunks for
      /// "row_key", as its data has been fully read.
      case commitRow(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Bigtable_V1_ReadRowsResponse.Chunk.OneOf_Chunk, rhs: Google_Bigtable_V1_ReadRowsResponse.Chunk.OneOf_Chunk) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.rowContents, .rowContents): return {
          guard case .rowContents(let l) = lhs, case .rowContents(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.resetRow, .resetRow): return {
          guard case .resetRow(let l) = lhs, case .resetRow(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.commitRow, .commitRow): return {
          guard case .commitRow(let l) = lhs, case .commitRow(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

/// Request message for BigtableService.SampleRowKeys.
public struct Google_Bigtable_V1_SampleRowKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table from which to sample row keys.
  public var tableName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for BigtableService.SampleRowKeys.
public struct Google_Bigtable_V1_SampleRowKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sorted streamed sequence of sample row keys in the table. The table might
  /// have contents before the first row key in the list and after the last one,
  /// but a key containing the empty string indicates "end of table" and will be
  /// the last response given, if present.
  /// Note that row keys in this list may not have ever been written to or read
  /// from, and users should therefore not make any assumptions about the row key
  /// structure that are specific to their use case.
  public var rowKey: Data = Data()

  /// Approximate total storage space used by all rows in the table which precede
  /// "row_key". Buffering the contents of all rows between two subsequent
  /// samples would require space roughly equal to the difference in their
  /// "offset_bytes" fields.
  public var offsetBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for BigtableService.MutateRow.
public struct Google_Bigtable_V1_MutateRowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table to which the mutation should be applied.
  public var tableName: String = String()

  /// The key of the row to which the mutation should be applied.
  public var rowKey: Data = Data()

  /// Changes to be atomically applied to the specified row. Entries are applied
  /// in order, meaning that earlier mutations can be masked by later ones.
  /// Must contain at least one entry and at most 100000.
  public var mutations: [Google_Bigtable_V1_Mutation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for BigtableService.MutateRows.
public struct Google_Bigtable_V1_MutateRowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table to which the mutations should be applied.
  public var tableName: String = String()

  /// The row keys/mutations to be applied in bulk.
  /// Each entry is applied as an atomic mutation, but the entries may be
  /// applied in arbitrary order (even between entries for the same row).
  /// At least one entry must be specified, and in total the entries may
  /// contain at most 100000 mutations.
  public var entries: [Google_Bigtable_V1_MutateRowsRequest.Entry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key of the row to which the `mutations` should be applied.
    public var rowKey: Data = Data()

    /// Changes to be atomically applied to the specified row. Mutations are
    /// applied in order, meaning that earlier mutations can be masked by
    /// later ones.
    /// At least one mutation must be specified.
    public var mutations: [Google_Bigtable_V1_Mutation] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response message for BigtableService.MutateRows.
public struct Google_Bigtable_V1_MutateRowsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The results for each Entry from the request, presented in the order
  /// in which the entries were originally given.
  /// Depending on how requests are batched during execution, it is possible
  /// for one Entry to fail due to an error with another Entry. In the event
  /// that this occurs, the same error will be reported for both entries.
  public var statuses: [Google_Rpc_Status] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for BigtableService.CheckAndMutateRowRequest
public struct Google_Bigtable_V1_CheckAndMutateRowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table to which the conditional mutation should be
  /// applied.
  public var tableName: String = String()

  /// The key of the row to which the conditional mutation should be applied.
  public var rowKey: Data = Data()

  /// The filter to be applied to the contents of the specified row. Depending
  /// on whether or not any results are yielded, either "true_mutations" or
  /// "false_mutations" will be executed. If unset, checks that the row contains
  /// any values at all.
  public var predicateFilter: Google_Bigtable_V1_RowFilter {
    get {return _predicateFilter ?? Google_Bigtable_V1_RowFilter()}
    set {_predicateFilter = newValue}
  }
  /// Returns true if `predicateFilter` has been explicitly set.
  public var hasPredicateFilter: Bool {return self._predicateFilter != nil}
  /// Clears the value of `predicateFilter`. Subsequent reads from it will return its default value.
  public mutating func clearPredicateFilter() {self._predicateFilter = nil}

  /// Changes to be atomically applied to the specified row if "predicate_filter"
  /// yields at least one cell when applied to "row_key". Entries are applied in
  /// order, meaning that earlier mutations can be masked by later ones.
  /// Must contain at least one entry if "false_mutations" is empty, and at most
  /// 100000.
  public var trueMutations: [Google_Bigtable_V1_Mutation] = []

  /// Changes to be atomically applied to the specified row if "predicate_filter"
  /// does not yield any cells when applied to "row_key". Entries are applied in
  /// order, meaning that earlier mutations can be masked by later ones.
  /// Must contain at least one entry if "true_mutations" is empty, and at most
  /// 100000.
  public var falseMutations: [Google_Bigtable_V1_Mutation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _predicateFilter: Google_Bigtable_V1_RowFilter? = nil
}

/// Response message for BigtableService.CheckAndMutateRowRequest.
public struct Google_Bigtable_V1_CheckAndMutateRowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not the request's "predicate_filter" yielded any results for
  /// the specified row.
  public var predicateMatched: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for BigtableService.ReadModifyWriteRowRequest.
public struct Google_Bigtable_V1_ReadModifyWriteRowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table to which the read/modify/write rules should be
  /// applied.
  public var tableName: String = String()

  /// The key of the row to which the read/modify/write rules should be applied.
  public var rowKey: Data = Data()

  /// Rules specifying how the specified row's contents are to be transformed
  /// into writes. Entries are applied in order, meaning that earlier rules will
  /// affect the results of later ones.
  public var rules: [Google_Bigtable_V1_ReadModifyWriteRule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.v1"

extension Google_Bigtable_V1_ReadRowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadRowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .standard(proto: "row_key"),
    3: .standard(proto: "row_range"),
    8: .standard(proto: "row_set"),
    5: .same(proto: "filter"),
    6: .standard(proto: "allow_row_interleaving"),
    7: .standard(proto: "num_rows_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.target = .rowKey(v)}
      }()
      case 3: try {
        var v: Google_Bigtable_V1_RowRange?
        if let current = self.target {
          try decoder.handleConflictingOneOf()
          if case .rowRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.target = .rowRange(v)}
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.allowRowInterleaving) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.numRowsLimit) }()
      case 8: try {
        var v: Google_Bigtable_V1_RowSet?
        if let current = self.target {
          try decoder.handleConflictingOneOf()
          if case .rowSet(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.target = .rowSet(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .rowKey?: try {
      guard case .rowKey(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .rowRange?: try {
      guard case .rowRange(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    default: break
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.allowRowInterleaving != false {
      try visitor.visitSingularBoolField(value: self.allowRowInterleaving, fieldNumber: 6)
    }
    if self.numRowsLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.numRowsLimit, fieldNumber: 7)
    }
    if case .rowSet(let v)? = self.target {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_ReadRowsRequest, rhs: Google_Bigtable_V1_ReadRowsRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.target != rhs.target {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.allowRowInterleaving != rhs.allowRowInterleaving {return false}
    if lhs.numRowsLimit != rhs.numRowsLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_ReadRowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadRowsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_key"),
    2: .same(proto: "chunks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.chunks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 1)
    }
    if !self.chunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_ReadRowsResponse, rhs: Google_Bigtable_V1_ReadRowsResponse) -> Bool {
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.chunks != rhs.chunks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_ReadRowsResponse.Chunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V1_ReadRowsResponse.protoMessageName + ".Chunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_contents"),
    2: .standard(proto: "reset_row"),
    3: .standard(proto: "commit_row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Bigtable_V1_Family?
        if let current = self.chunk {
          try decoder.handleConflictingOneOf()
          if case .rowContents(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.chunk = .rowContents(v)}
      }()
      case 2: try {
        if self.chunk != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.chunk = .resetRow(v)}
      }()
      case 3: try {
        if self.chunk != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.chunk = .commitRow(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.chunk {
    case .rowContents?: try {
      guard case .rowContents(let v)? = self.chunk else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .resetRow?: try {
      guard case .resetRow(let v)? = self.chunk else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .commitRow?: try {
      guard case .commitRow(let v)? = self.chunk else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_ReadRowsResponse.Chunk, rhs: Google_Bigtable_V1_ReadRowsResponse.Chunk) -> Bool {
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_SampleRowKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampleRowKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_SampleRowKeysRequest, rhs: Google_Bigtable_V1_SampleRowKeysRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_SampleRowKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampleRowKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_key"),
    2: .standard(proto: "offset_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offsetBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 1)
    }
    if self.offsetBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.offsetBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_SampleRowKeysResponse, rhs: Google_Bigtable_V1_SampleRowKeysResponse) -> Bool {
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.offsetBytes != rhs.offsetBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_MutateRowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .standard(proto: "row_key"),
    3: .same(proto: "mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 2)
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_MutateRowRequest, rhs: Google_Bigtable_V1_MutateRowRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_MutateRowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_MutateRowsRequest, rhs: Google_Bigtable_V1_MutateRowsRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_MutateRowsRequest.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V1_MutateRowsRequest.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_key"),
    2: .same(proto: "mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 1)
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_MutateRowsRequest.Entry, rhs: Google_Bigtable_V1_MutateRowsRequest.Entry) -> Bool {
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_MutateRowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statuses"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.statuses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statuses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statuses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_MutateRowsResponse, rhs: Google_Bigtable_V1_MutateRowsResponse) -> Bool {
    if lhs.statuses != rhs.statuses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_CheckAndMutateRowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckAndMutateRowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .standard(proto: "row_key"),
    6: .standard(proto: "predicate_filter"),
    4: .standard(proto: "true_mutations"),
    5: .standard(proto: "false_mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.trueMutations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.falseMutations) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._predicateFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 2)
    }
    if !self.trueMutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trueMutations, fieldNumber: 4)
    }
    if !self.falseMutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.falseMutations, fieldNumber: 5)
    }
    if let v = self._predicateFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_CheckAndMutateRowRequest, rhs: Google_Bigtable_V1_CheckAndMutateRowRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs._predicateFilter != rhs._predicateFilter {return false}
    if lhs.trueMutations != rhs.trueMutations {return false}
    if lhs.falseMutations != rhs.falseMutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_CheckAndMutateRowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckAndMutateRowResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "predicate_matched"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.predicateMatched) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.predicateMatched != false {
      try visitor.visitSingularBoolField(value: self.predicateMatched, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_CheckAndMutateRowResponse, rhs: Google_Bigtable_V1_CheckAndMutateRowResponse) -> Bool {
    if lhs.predicateMatched != rhs.predicateMatched {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V1_ReadModifyWriteRowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadModifyWriteRowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .standard(proto: "row_key"),
    3: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 2)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V1_ReadModifyWriteRowRequest, rhs: Google_Bigtable_V1_ReadModifyWriteRowRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

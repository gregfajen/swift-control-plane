// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/v2/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies the complete (requested) contents of a single row of a table.
/// Rows which exceed 256MiB in size cannot be read in full.
public struct Google_Bigtable_V2_Row {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique key which identifies this row within its table. This is the same
  /// key that's used to identify the row in, for example, a MutateRowRequest.
  /// May contain any non-empty byte string up to 4KiB in length.
  public var key: Data = Data()

  /// May be empty, but only if the entire row is empty.
  /// The mutual ordering of column families is not specified.
  public var families: [Google_Bigtable_V2_Family] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies (some of) the contents of a single row/column family intersection
/// of a table.
public struct Google_Bigtable_V2_Family {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique key which identifies this family within its row. This is the
  /// same key that's used to identify the family in, for example, a RowFilter
  /// which sets its "family_name_regex_filter" field.
  /// Must match `[-_.a-zA-Z0-9]+`, except that AggregatingRowProcessors may
  /// produce cells in a sentinel family with an empty name.
  /// Must be no greater than 64 characters in length.
  public var name: String = String()

  /// Must not be empty. Sorted in order of increasing "qualifier".
  public var columns: [Google_Bigtable_V2_Column] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies (some of) the contents of a single row/column intersection of a
/// table.
public struct Google_Bigtable_V2_Column {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique key which identifies this column within its family. This is the
  /// same key that's used to identify the column in, for example, a RowFilter
  /// which sets its `column_qualifier_regex_filter` field.
  /// May contain any byte string, including the empty string, up to 16kiB in
  /// length.
  public var qualifier: Data = Data()

  /// Must not be empty. Sorted in order of decreasing "timestamp_micros".
  public var cells: [Google_Bigtable_V2_Cell] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies (some of) the contents of a single row/column/timestamp of a table.
public struct Google_Bigtable_V2_Cell {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The cell's stored timestamp, which also uniquely identifies it within
  /// its column.
  /// Values are always expressed in microseconds, but individual tables may set
  /// a coarser granularity to further restrict the allowed values. For
  /// example, a table which specifies millisecond granularity will only allow
  /// values of `timestamp_micros` which are multiples of 1000.
  public var timestampMicros: Int64 = 0

  /// The value stored in the cell.
  /// May contain any byte string, including the empty string, up to 100MiB in
  /// length.
  public var value: Data = Data()

  /// Labels applied to the cell by a [RowFilter][google.bigtable.v2.RowFilter].
  public var labels: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a contiguous range of rows.
public struct Google_Bigtable_V2_RowRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The row key at which to start the range.
  /// If neither field is set, interpreted as the empty string, inclusive.
  public var startKey: Google_Bigtable_V2_RowRange.OneOf_StartKey? = nil

  /// Used when giving an inclusive lower bound for the range.
  public var startKeyClosed: Data {
    get {
      if case .startKeyClosed(let v)? = startKey {return v}
      return Data()
    }
    set {startKey = .startKeyClosed(newValue)}
  }

  /// Used when giving an exclusive lower bound for the range.
  public var startKeyOpen: Data {
    get {
      if case .startKeyOpen(let v)? = startKey {return v}
      return Data()
    }
    set {startKey = .startKeyOpen(newValue)}
  }

  /// The row key at which to end the range.
  /// If neither field is set, interpreted as the infinite row key, exclusive.
  public var endKey: Google_Bigtable_V2_RowRange.OneOf_EndKey? = nil

  /// Used when giving an exclusive upper bound for the range.
  public var endKeyOpen: Data {
    get {
      if case .endKeyOpen(let v)? = endKey {return v}
      return Data()
    }
    set {endKey = .endKeyOpen(newValue)}
  }

  /// Used when giving an inclusive upper bound for the range.
  public var endKeyClosed: Data {
    get {
      if case .endKeyClosed(let v)? = endKey {return v}
      return Data()
    }
    set {endKey = .endKeyClosed(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The row key at which to start the range.
  /// If neither field is set, interpreted as the empty string, inclusive.
  public enum OneOf_StartKey: Equatable {
    /// Used when giving an inclusive lower bound for the range.
    case startKeyClosed(Data)
    /// Used when giving an exclusive lower bound for the range.
    case startKeyOpen(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_RowRange.OneOf_StartKey, rhs: Google_Bigtable_V2_RowRange.OneOf_StartKey) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.startKeyClosed, .startKeyClosed): return {
        guard case .startKeyClosed(let l) = lhs, case .startKeyClosed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startKeyOpen, .startKeyOpen): return {
        guard case .startKeyOpen(let l) = lhs, case .startKeyOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The row key at which to end the range.
  /// If neither field is set, interpreted as the infinite row key, exclusive.
  public enum OneOf_EndKey: Equatable {
    /// Used when giving an exclusive upper bound for the range.
    case endKeyOpen(Data)
    /// Used when giving an inclusive upper bound for the range.
    case endKeyClosed(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_RowRange.OneOf_EndKey, rhs: Google_Bigtable_V2_RowRange.OneOf_EndKey) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.endKeyOpen, .endKeyOpen): return {
        guard case .endKeyOpen(let l) = lhs, case .endKeyOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endKeyClosed, .endKeyClosed): return {
        guard case .endKeyClosed(let l) = lhs, case .endKeyClosed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Specifies a non-contiguous set of rows.
public struct Google_Bigtable_V2_RowSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Single rows included in the set.
  public var rowKeys: [Data] = []

  /// Contiguous row ranges included in the set.
  public var rowRanges: [Google_Bigtable_V2_RowRange] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a contiguous range of columns within a single column family.
/// The range spans from &lt;column_family&gt;:&lt;start_qualifier&gt; to
/// &lt;column_family&gt;:&lt;end_qualifier&gt;, where both bounds can be either
/// inclusive or exclusive.
public struct Google_Bigtable_V2_ColumnRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the column family within which this range falls.
  public var familyName: String = String()

  /// The column qualifier at which to start the range (within `column_family`).
  /// If neither field is set, interpreted as the empty string, inclusive.
  public var startQualifier: Google_Bigtable_V2_ColumnRange.OneOf_StartQualifier? = nil

  /// Used when giving an inclusive lower bound for the range.
  public var startQualifierClosed: Data {
    get {
      if case .startQualifierClosed(let v)? = startQualifier {return v}
      return Data()
    }
    set {startQualifier = .startQualifierClosed(newValue)}
  }

  /// Used when giving an exclusive lower bound for the range.
  public var startQualifierOpen: Data {
    get {
      if case .startQualifierOpen(let v)? = startQualifier {return v}
      return Data()
    }
    set {startQualifier = .startQualifierOpen(newValue)}
  }

  /// The column qualifier at which to end the range (within `column_family`).
  /// If neither field is set, interpreted as the infinite string, exclusive.
  public var endQualifier: Google_Bigtable_V2_ColumnRange.OneOf_EndQualifier? = nil

  /// Used when giving an inclusive upper bound for the range.
  public var endQualifierClosed: Data {
    get {
      if case .endQualifierClosed(let v)? = endQualifier {return v}
      return Data()
    }
    set {endQualifier = .endQualifierClosed(newValue)}
  }

  /// Used when giving an exclusive upper bound for the range.
  public var endQualifierOpen: Data {
    get {
      if case .endQualifierOpen(let v)? = endQualifier {return v}
      return Data()
    }
    set {endQualifier = .endQualifierOpen(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The column qualifier at which to start the range (within `column_family`).
  /// If neither field is set, interpreted as the empty string, inclusive.
  public enum OneOf_StartQualifier: Equatable {
    /// Used when giving an inclusive lower bound for the range.
    case startQualifierClosed(Data)
    /// Used when giving an exclusive lower bound for the range.
    case startQualifierOpen(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_ColumnRange.OneOf_StartQualifier, rhs: Google_Bigtable_V2_ColumnRange.OneOf_StartQualifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.startQualifierClosed, .startQualifierClosed): return {
        guard case .startQualifierClosed(let l) = lhs, case .startQualifierClosed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startQualifierOpen, .startQualifierOpen): return {
        guard case .startQualifierOpen(let l) = lhs, case .startQualifierOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The column qualifier at which to end the range (within `column_family`).
  /// If neither field is set, interpreted as the infinite string, exclusive.
  public enum OneOf_EndQualifier: Equatable {
    /// Used when giving an inclusive upper bound for the range.
    case endQualifierClosed(Data)
    /// Used when giving an exclusive upper bound for the range.
    case endQualifierOpen(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_ColumnRange.OneOf_EndQualifier, rhs: Google_Bigtable_V2_ColumnRange.OneOf_EndQualifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.endQualifierClosed, .endQualifierClosed): return {
        guard case .endQualifierClosed(let l) = lhs, case .endQualifierClosed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endQualifierOpen, .endQualifierOpen): return {
        guard case .endQualifierOpen(let l) = lhs, case .endQualifierOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Specified a contiguous range of microsecond timestamps.
public struct Google_Bigtable_V2_TimestampRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Inclusive lower bound. If left empty, interpreted as 0.
  public var startTimestampMicros: Int64 = 0

  /// Exclusive upper bound. If left empty, interpreted as infinity.
  public var endTimestampMicros: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a contiguous range of raw byte values.
public struct Google_Bigtable_V2_ValueRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The value at which to start the range.
  /// If neither field is set, interpreted as the empty string, inclusive.
  public var startValue: Google_Bigtable_V2_ValueRange.OneOf_StartValue? = nil

  /// Used when giving an inclusive lower bound for the range.
  public var startValueClosed: Data {
    get {
      if case .startValueClosed(let v)? = startValue {return v}
      return Data()
    }
    set {startValue = .startValueClosed(newValue)}
  }

  /// Used when giving an exclusive lower bound for the range.
  public var startValueOpen: Data {
    get {
      if case .startValueOpen(let v)? = startValue {return v}
      return Data()
    }
    set {startValue = .startValueOpen(newValue)}
  }

  /// The value at which to end the range.
  /// If neither field is set, interpreted as the infinite string, exclusive.
  public var endValue: Google_Bigtable_V2_ValueRange.OneOf_EndValue? = nil

  /// Used when giving an inclusive upper bound for the range.
  public var endValueClosed: Data {
    get {
      if case .endValueClosed(let v)? = endValue {return v}
      return Data()
    }
    set {endValue = .endValueClosed(newValue)}
  }

  /// Used when giving an exclusive upper bound for the range.
  public var endValueOpen: Data {
    get {
      if case .endValueOpen(let v)? = endValue {return v}
      return Data()
    }
    set {endValue = .endValueOpen(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The value at which to start the range.
  /// If neither field is set, interpreted as the empty string, inclusive.
  public enum OneOf_StartValue: Equatable {
    /// Used when giving an inclusive lower bound for the range.
    case startValueClosed(Data)
    /// Used when giving an exclusive lower bound for the range.
    case startValueOpen(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_ValueRange.OneOf_StartValue, rhs: Google_Bigtable_V2_ValueRange.OneOf_StartValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.startValueClosed, .startValueClosed): return {
        guard case .startValueClosed(let l) = lhs, case .startValueClosed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startValueOpen, .startValueOpen): return {
        guard case .startValueOpen(let l) = lhs, case .startValueOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The value at which to end the range.
  /// If neither field is set, interpreted as the infinite string, exclusive.
  public enum OneOf_EndValue: Equatable {
    /// Used when giving an inclusive upper bound for the range.
    case endValueClosed(Data)
    /// Used when giving an exclusive upper bound for the range.
    case endValueOpen(Data)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_ValueRange.OneOf_EndValue, rhs: Google_Bigtable_V2_ValueRange.OneOf_EndValue) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.endValueClosed, .endValueClosed): return {
        guard case .endValueClosed(let l) = lhs, case .endValueClosed(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.endValueOpen, .endValueOpen): return {
        guard case .endValueOpen(let l) = lhs, case .endValueOpen(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Takes a row as input and produces an alternate view of the row based on
/// specified rules. For example, a RowFilter might trim down a row to include
/// just the cells from columns matching a given regular expression, or might
/// return all the cells of a row but not their values. More complicated filters
/// can be composed out of these components to express requests such as, "within
/// every column of a particular family, give just the two most recent cells
/// which are older than timestamp X."
///
/// There are two broad categories of RowFilters (true filters and transformers),
/// as well as two ways to compose simple filters into more complex ones
/// (chains and interleaves). They work as follows:
///
/// * True filters alter the input row by excluding some of its cells wholesale
/// from the output row. An example of a true filter is the `value_regex_filter`,
/// which excludes cells whose values don't match the specified pattern. All
/// regex true filters use RE2 syntax (https://github.com/google/re2/wiki/Syntax)
/// in raw byte mode (RE2::Latin1), and are evaluated as full matches. An
/// important point to keep in mind is that `RE2(.)` is equivalent by default to
/// `RE2([^\n])`, meaning that it does not match newlines. When attempting to
/// match an arbitrary byte, you should therefore use the escape sequence `\C`,
/// which may need to be further escaped as `\\C` in your client language.
///
/// * Transformers alter the input row by changing the values of some of its
/// cells in the output, without excluding them completely. Currently, the only
/// supported transformer is the `strip_value_transformer`, which replaces every
/// cell's value with the empty string.
///
/// * Chains and interleaves are described in more detail in the
/// RowFilter.Chain and RowFilter.Interleave documentation.
///
/// The total serialized size of a RowFilter message must not
/// exceed 4096 bytes, and RowFilters may not be nested within each other
/// (in Chains or Interleaves) to a depth of more than 20.
public struct Google_Bigtable_V2_RowFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which of the possible RowFilter types to apply. If none are set, this
  /// RowFilter returns all cells in the input row.
  public var filter: OneOf_Filter? {
    get {return _storage._filter}
    set {_uniqueStorage()._filter = newValue}
  }

  /// Applies several RowFilters to the data in sequence, progressively
  /// narrowing the results.
  public var chain: Google_Bigtable_V2_RowFilter.Chain {
    get {
      if case .chain(let v)? = _storage._filter {return v}
      return Google_Bigtable_V2_RowFilter.Chain()
    }
    set {_uniqueStorage()._filter = .chain(newValue)}
  }

  /// Applies several RowFilters to the data in parallel and combines the
  /// results.
  public var interleave: Google_Bigtable_V2_RowFilter.Interleave {
    get {
      if case .interleave(let v)? = _storage._filter {return v}
      return Google_Bigtable_V2_RowFilter.Interleave()
    }
    set {_uniqueStorage()._filter = .interleave(newValue)}
  }

  /// Applies one of two possible RowFilters to the data based on the output of
  /// a predicate RowFilter.
  public var condition: Google_Bigtable_V2_RowFilter.Condition {
    get {
      if case .condition(let v)? = _storage._filter {return v}
      return Google_Bigtable_V2_RowFilter.Condition()
    }
    set {_uniqueStorage()._filter = .condition(newValue)}
  }

  /// ADVANCED USE ONLY.
  /// Hook for introspection into the RowFilter. Outputs all cells directly to
  /// the output of the read rather than to any parent filter. Consider the
  /// following example:
  ///
  ///     Chain(
  ///       FamilyRegex("A"),
  ///       Interleave(
  ///         All(),
  ///         Chain(Label("foo"), Sink())
  ///       ),
  ///       QualifierRegex("B")
  ///     )
  ///
  ///                         A,A,1,w
  ///                         A,B,2,x
  ///                         B,B,4,z
  ///                            |
  ///                     FamilyRegex("A")
  ///                            |
  ///                         A,A,1,w
  ///                         A,B,2,x
  ///                            |
  ///               +------------+-------------+
  ///               |                          |
  ///             All()                    Label(foo)
  ///               |                          |
  ///            A,A,1,w              A,A,1,w,labels:[foo]
  ///            A,B,2,x              A,B,2,x,labels:[foo]
  ///               |                          |
  ///               |                        Sink() --------------+
  ///               |                          |                  |
  ///               +------------+      x------+          A,A,1,w,labels:[foo]
  ///                            |                        A,B,2,x,labels:[foo]
  ///                         A,A,1,w                             |
  ///                         A,B,2,x                             |
  ///                            |                                |
  ///                    QualifierRegex("B")                      |
  ///                            |                                |
  ///                         A,B,2,x                             |
  ///                            |                                |
  ///                            +--------------------------------+
  ///                            |
  ///                         A,A,1,w,labels:[foo]
  ///                         A,B,2,x,labels:[foo]  // could be switched
  ///                         A,B,2,x               // could be switched
  ///
  /// Despite being excluded by the qualifier filter, a copy of every cell
  /// that reaches the sink is present in the final result.
  ///
  /// As with an [Interleave][google.bigtable.v2.RowFilter.Interleave],
  /// duplicate cells are possible, and appear in an unspecified mutual order.
  /// In this case we have a duplicate with column "A:B" and timestamp 2,
  /// because one copy passed through the all filter while the other was
  /// passed through the label and sink. Note that one copy has label "foo",
  /// while the other does not.
  ///
  /// Cannot be used within the `predicate_filter`, `true_filter`, or
  /// `false_filter` of a [Condition][google.bigtable.v2.RowFilter.Condition].
  public var sink: Bool {
    get {
      if case .sink(let v)? = _storage._filter {return v}
      return false
    }
    set {_uniqueStorage()._filter = .sink(newValue)}
  }

  /// Matches all cells, regardless of input. Functionally equivalent to
  /// leaving `filter` unset, but included for completeness.
  public var passAllFilter: Bool {
    get {
      if case .passAllFilter(let v)? = _storage._filter {return v}
      return false
    }
    set {_uniqueStorage()._filter = .passAllFilter(newValue)}
  }

  /// Does not match any cells, regardless of input. Useful for temporarily
  /// disabling just part of a filter.
  public var blockAllFilter: Bool {
    get {
      if case .blockAllFilter(let v)? = _storage._filter {return v}
      return false
    }
    set {_uniqueStorage()._filter = .blockAllFilter(newValue)}
  }

  /// Matches only cells from rows whose keys satisfy the given RE2 regex. In
  /// other words, passes through the entire row when the key matches, and
  /// otherwise produces an empty row.
  /// Note that, since row keys can contain arbitrary bytes, the `\C` escape
  /// sequence must be used if a true wildcard is desired. The `.` character
  /// will not match the new line character `\n`, which may be present in a
  /// binary key.
  public var rowKeyRegexFilter: Data {
    get {
      if case .rowKeyRegexFilter(let v)? = _storage._filter {return v}
      return Data()
    }
    set {_uniqueStorage()._filter = .rowKeyRegexFilter(newValue)}
  }

  /// Matches all cells from a row with probability p, and matches no cells
  /// from the row with probability 1-p.
  public var rowSampleFilter: Double {
    get {
      if case .rowSampleFilter(let v)? = _storage._filter {return v}
      return 0
    }
    set {_uniqueStorage()._filter = .rowSampleFilter(newValue)}
  }

  /// Matches only cells from columns whose families satisfy the given RE2
  /// regex. For technical reasons, the regex must not contain the `:`
  /// character, even if it is not being used as a literal.
  /// Note that, since column families cannot contain the new line character
  /// `\n`, it is sufficient to use `.` as a full wildcard when matching
  /// column family names.
  public var familyNameRegexFilter: String {
    get {
      if case .familyNameRegexFilter(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .familyNameRegexFilter(newValue)}
  }

  /// Matches only cells from columns whose qualifiers satisfy the given RE2
  /// regex.
  /// Note that, since column qualifiers can contain arbitrary bytes, the `\C`
  /// escape sequence must be used if a true wildcard is desired. The `.`
  /// character will not match the new line character `\n`, which may be
  /// present in a binary qualifier.
  public var columnQualifierRegexFilter: Data {
    get {
      if case .columnQualifierRegexFilter(let v)? = _storage._filter {return v}
      return Data()
    }
    set {_uniqueStorage()._filter = .columnQualifierRegexFilter(newValue)}
  }

  /// Matches only cells from columns within the given range.
  public var columnRangeFilter: Google_Bigtable_V2_ColumnRange {
    get {
      if case .columnRangeFilter(let v)? = _storage._filter {return v}
      return Google_Bigtable_V2_ColumnRange()
    }
    set {_uniqueStorage()._filter = .columnRangeFilter(newValue)}
  }

  /// Matches only cells with timestamps within the given range.
  public var timestampRangeFilter: Google_Bigtable_V2_TimestampRange {
    get {
      if case .timestampRangeFilter(let v)? = _storage._filter {return v}
      return Google_Bigtable_V2_TimestampRange()
    }
    set {_uniqueStorage()._filter = .timestampRangeFilter(newValue)}
  }

  /// Matches only cells with values that satisfy the given regular expression.
  /// Note that, since cell values can contain arbitrary bytes, the `\C` escape
  /// sequence must be used if a true wildcard is desired. The `.` character
  /// will not match the new line character `\n`, which may be present in a
  /// binary value.
  public var valueRegexFilter: Data {
    get {
      if case .valueRegexFilter(let v)? = _storage._filter {return v}
      return Data()
    }
    set {_uniqueStorage()._filter = .valueRegexFilter(newValue)}
  }

  /// Matches only cells with values that fall within the given range.
  public var valueRangeFilter: Google_Bigtable_V2_ValueRange {
    get {
      if case .valueRangeFilter(let v)? = _storage._filter {return v}
      return Google_Bigtable_V2_ValueRange()
    }
    set {_uniqueStorage()._filter = .valueRangeFilter(newValue)}
  }

  /// Skips the first N cells of each row, matching all subsequent cells.
  /// If duplicate cells are present, as is possible when using an Interleave,
  /// each copy of the cell is counted separately.
  public var cellsPerRowOffsetFilter: Int32 {
    get {
      if case .cellsPerRowOffsetFilter(let v)? = _storage._filter {return v}
      return 0
    }
    set {_uniqueStorage()._filter = .cellsPerRowOffsetFilter(newValue)}
  }

  /// Matches only the first N cells of each row.
  /// If duplicate cells are present, as is possible when using an Interleave,
  /// each copy of the cell is counted separately.
  public var cellsPerRowLimitFilter: Int32 {
    get {
      if case .cellsPerRowLimitFilter(let v)? = _storage._filter {return v}
      return 0
    }
    set {_uniqueStorage()._filter = .cellsPerRowLimitFilter(newValue)}
  }

  /// Matches only the most recent N cells within each column. For example,
  /// if N=2, this filter would match column `foo:bar` at timestamps 10 and 9,
  /// skip all earlier cells in `foo:bar`, and then begin matching again in
  /// column `foo:bar2`.
  /// If duplicate cells are present, as is possible when using an Interleave,
  /// each copy of the cell is counted separately.
  public var cellsPerColumnLimitFilter: Int32 {
    get {
      if case .cellsPerColumnLimitFilter(let v)? = _storage._filter {return v}
      return 0
    }
    set {_uniqueStorage()._filter = .cellsPerColumnLimitFilter(newValue)}
  }

  /// Replaces each cell's value with the empty string.
  public var stripValueTransformer: Bool {
    get {
      if case .stripValueTransformer(let v)? = _storage._filter {return v}
      return false
    }
    set {_uniqueStorage()._filter = .stripValueTransformer(newValue)}
  }

  /// Applies the given label to all cells in the output row. This allows
  /// the client to determine which results were produced from which part of
  /// the filter.
  ///
  /// Values must be at most 15 characters in length, and match the RE2
  /// pattern `[a-z0-9\\-]+`
  ///
  /// Due to a technical limitation, it is not currently possible to apply
  /// multiple labels to a cell. As a result, a Chain may have no more than
  /// one sub-filter which contains a `apply_label_transformer`. It is okay for
  /// an Interleave to contain multiple `apply_label_transformers`, as they
  /// will be applied to separate copies of the input. This may be relaxed in
  /// the future.
  public var applyLabelTransformer: String {
    get {
      if case .applyLabelTransformer(let v)? = _storage._filter {return v}
      return String()
    }
    set {_uniqueStorage()._filter = .applyLabelTransformer(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Which of the possible RowFilter types to apply. If none are set, this
  /// RowFilter returns all cells in the input row.
  public enum OneOf_Filter: Equatable {
    /// Applies several RowFilters to the data in sequence, progressively
    /// narrowing the results.
    case chain(Google_Bigtable_V2_RowFilter.Chain)
    /// Applies several RowFilters to the data in parallel and combines the
    /// results.
    case interleave(Google_Bigtable_V2_RowFilter.Interleave)
    /// Applies one of two possible RowFilters to the data based on the output of
    /// a predicate RowFilter.
    case condition(Google_Bigtable_V2_RowFilter.Condition)
    /// ADVANCED USE ONLY.
    /// Hook for introspection into the RowFilter. Outputs all cells directly to
    /// the output of the read rather than to any parent filter. Consider the
    /// following example:
    ///
    ///     Chain(
    ///       FamilyRegex("A"),
    ///       Interleave(
    ///         All(),
    ///         Chain(Label("foo"), Sink())
    ///       ),
    ///       QualifierRegex("B")
    ///     )
    ///
    ///                         A,A,1,w
    ///                         A,B,2,x
    ///                         B,B,4,z
    ///                            |
    ///                     FamilyRegex("A")
    ///                            |
    ///                         A,A,1,w
    ///                         A,B,2,x
    ///                            |
    ///               +------------+-------------+
    ///               |                          |
    ///             All()                    Label(foo)
    ///               |                          |
    ///            A,A,1,w              A,A,1,w,labels:[foo]
    ///            A,B,2,x              A,B,2,x,labels:[foo]
    ///               |                          |
    ///               |                        Sink() --------------+
    ///               |                          |                  |
    ///               +------------+      x------+          A,A,1,w,labels:[foo]
    ///                            |                        A,B,2,x,labels:[foo]
    ///                         A,A,1,w                             |
    ///                         A,B,2,x                             |
    ///                            |                                |
    ///                    QualifierRegex("B")                      |
    ///                            |                                |
    ///                         A,B,2,x                             |
    ///                            |                                |
    ///                            +--------------------------------+
    ///                            |
    ///                         A,A,1,w,labels:[foo]
    ///                         A,B,2,x,labels:[foo]  // could be switched
    ///                         A,B,2,x               // could be switched
    ///
    /// Despite being excluded by the qualifier filter, a copy of every cell
    /// that reaches the sink is present in the final result.
    ///
    /// As with an [Interleave][google.bigtable.v2.RowFilter.Interleave],
    /// duplicate cells are possible, and appear in an unspecified mutual order.
    /// In this case we have a duplicate with column "A:B" and timestamp 2,
    /// because one copy passed through the all filter while the other was
    /// passed through the label and sink. Note that one copy has label "foo",
    /// while the other does not.
    ///
    /// Cannot be used within the `predicate_filter`, `true_filter`, or
    /// `false_filter` of a [Condition][google.bigtable.v2.RowFilter.Condition].
    case sink(Bool)
    /// Matches all cells, regardless of input. Functionally equivalent to
    /// leaving `filter` unset, but included for completeness.
    case passAllFilter(Bool)
    /// Does not match any cells, regardless of input. Useful for temporarily
    /// disabling just part of a filter.
    case blockAllFilter(Bool)
    /// Matches only cells from rows whose keys satisfy the given RE2 regex. In
    /// other words, passes through the entire row when the key matches, and
    /// otherwise produces an empty row.
    /// Note that, since row keys can contain arbitrary bytes, the `\C` escape
    /// sequence must be used if a true wildcard is desired. The `.` character
    /// will not match the new line character `\n`, which may be present in a
    /// binary key.
    case rowKeyRegexFilter(Data)
    /// Matches all cells from a row with probability p, and matches no cells
    /// from the row with probability 1-p.
    case rowSampleFilter(Double)
    /// Matches only cells from columns whose families satisfy the given RE2
    /// regex. For technical reasons, the regex must not contain the `:`
    /// character, even if it is not being used as a literal.
    /// Note that, since column families cannot contain the new line character
    /// `\n`, it is sufficient to use `.` as a full wildcard when matching
    /// column family names.
    case familyNameRegexFilter(String)
    /// Matches only cells from columns whose qualifiers satisfy the given RE2
    /// regex.
    /// Note that, since column qualifiers can contain arbitrary bytes, the `\C`
    /// escape sequence must be used if a true wildcard is desired. The `.`
    /// character will not match the new line character `\n`, which may be
    /// present in a binary qualifier.
    case columnQualifierRegexFilter(Data)
    /// Matches only cells from columns within the given range.
    case columnRangeFilter(Google_Bigtable_V2_ColumnRange)
    /// Matches only cells with timestamps within the given range.
    case timestampRangeFilter(Google_Bigtable_V2_TimestampRange)
    /// Matches only cells with values that satisfy the given regular expression.
    /// Note that, since cell values can contain arbitrary bytes, the `\C` escape
    /// sequence must be used if a true wildcard is desired. The `.` character
    /// will not match the new line character `\n`, which may be present in a
    /// binary value.
    case valueRegexFilter(Data)
    /// Matches only cells with values that fall within the given range.
    case valueRangeFilter(Google_Bigtable_V2_ValueRange)
    /// Skips the first N cells of each row, matching all subsequent cells.
    /// If duplicate cells are present, as is possible when using an Interleave,
    /// each copy of the cell is counted separately.
    case cellsPerRowOffsetFilter(Int32)
    /// Matches only the first N cells of each row.
    /// If duplicate cells are present, as is possible when using an Interleave,
    /// each copy of the cell is counted separately.
    case cellsPerRowLimitFilter(Int32)
    /// Matches only the most recent N cells within each column. For example,
    /// if N=2, this filter would match column `foo:bar` at timestamps 10 and 9,
    /// skip all earlier cells in `foo:bar`, and then begin matching again in
    /// column `foo:bar2`.
    /// If duplicate cells are present, as is possible when using an Interleave,
    /// each copy of the cell is counted separately.
    case cellsPerColumnLimitFilter(Int32)
    /// Replaces each cell's value with the empty string.
    case stripValueTransformer(Bool)
    /// Applies the given label to all cells in the output row. This allows
    /// the client to determine which results were produced from which part of
    /// the filter.
    ///
    /// Values must be at most 15 characters in length, and match the RE2
    /// pattern `[a-z0-9\\-]+`
    ///
    /// Due to a technical limitation, it is not currently possible to apply
    /// multiple labels to a cell. As a result, a Chain may have no more than
    /// one sub-filter which contains a `apply_label_transformer`. It is okay for
    /// an Interleave to contain multiple `apply_label_transformers`, as they
    /// will be applied to separate copies of the input. This may be relaxed in
    /// the future.
    case applyLabelTransformer(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_RowFilter.OneOf_Filter, rhs: Google_Bigtable_V2_RowFilter.OneOf_Filter) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.chain, .chain): return {
        guard case .chain(let l) = lhs, case .chain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.interleave, .interleave): return {
        guard case .interleave(let l) = lhs, case .interleave(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.condition, .condition): return {
        guard case .condition(let l) = lhs, case .condition(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sink, .sink): return {
        guard case .sink(let l) = lhs, case .sink(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.passAllFilter, .passAllFilter): return {
        guard case .passAllFilter(let l) = lhs, case .passAllFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.blockAllFilter, .blockAllFilter): return {
        guard case .blockAllFilter(let l) = lhs, case .blockAllFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rowKeyRegexFilter, .rowKeyRegexFilter): return {
        guard case .rowKeyRegexFilter(let l) = lhs, case .rowKeyRegexFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rowSampleFilter, .rowSampleFilter): return {
        guard case .rowSampleFilter(let l) = lhs, case .rowSampleFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.familyNameRegexFilter, .familyNameRegexFilter): return {
        guard case .familyNameRegexFilter(let l) = lhs, case .familyNameRegexFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.columnQualifierRegexFilter, .columnQualifierRegexFilter): return {
        guard case .columnQualifierRegexFilter(let l) = lhs, case .columnQualifierRegexFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.columnRangeFilter, .columnRangeFilter): return {
        guard case .columnRangeFilter(let l) = lhs, case .columnRangeFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestampRangeFilter, .timestampRangeFilter): return {
        guard case .timestampRangeFilter(let l) = lhs, case .timestampRangeFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.valueRegexFilter, .valueRegexFilter): return {
        guard case .valueRegexFilter(let l) = lhs, case .valueRegexFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.valueRangeFilter, .valueRangeFilter): return {
        guard case .valueRangeFilter(let l) = lhs, case .valueRangeFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cellsPerRowOffsetFilter, .cellsPerRowOffsetFilter): return {
        guard case .cellsPerRowOffsetFilter(let l) = lhs, case .cellsPerRowOffsetFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cellsPerRowLimitFilter, .cellsPerRowLimitFilter): return {
        guard case .cellsPerRowLimitFilter(let l) = lhs, case .cellsPerRowLimitFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cellsPerColumnLimitFilter, .cellsPerColumnLimitFilter): return {
        guard case .cellsPerColumnLimitFilter(let l) = lhs, case .cellsPerColumnLimitFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stripValueTransformer, .stripValueTransformer): return {
        guard case .stripValueTransformer(let l) = lhs, case .stripValueTransformer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applyLabelTransformer, .applyLabelTransformer): return {
        guard case .applyLabelTransformer(let l) = lhs, case .applyLabelTransformer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A RowFilter which sends rows through several RowFilters in sequence.
  public struct Chain {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The elements of "filters" are chained together to process the input row:
    /// in row -> f(0) -> intermediate row -> f(1) -> ... -> f(N) -> out row
    /// The full chain is executed atomically.
    public var filters: [Google_Bigtable_V2_RowFilter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A RowFilter which sends each row to each of several component
  /// RowFilters and interleaves the results.
  public struct Interleave {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The elements of "filters" all process a copy of the input row, and the
    /// results are pooled, sorted, and combined into a single output row.
    /// If multiple cells are produced with the same column and timestamp,
    /// they will all appear in the output row in an unspecified mutual order.
    /// Consider the following example, with three filters:
    ///
    ///                                  input row
    ///                                      |
    ///            -----------------------------------------------------
    ///            |                         |                         |
    ///           f(0)                      f(1)                      f(2)
    ///            |                         |                         |
    ///     1: foo,bar,10,x             foo,bar,10,z              far,bar,7,a
    ///     2: foo,blah,11,z            far,blah,5,x              far,blah,5,x
    ///            |                         |                         |
    ///            -----------------------------------------------------
    ///                                      |
    ///     1:                      foo,bar,10,z   // could have switched with #2
    ///     2:                      foo,bar,10,x   // could have switched with #1
    ///     3:                      foo,blah,11,z
    ///     4:                      far,bar,7,a
    ///     5:                      far,blah,5,x   // identical to #6
    ///     6:                      far,blah,5,x   // identical to #5
    ///
    /// All interleaved filters are executed atomically.
    public var filters: [Google_Bigtable_V2_RowFilter] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A RowFilter which evaluates one of two possible RowFilters, depending on
  /// whether or not a predicate RowFilter outputs any cells from the input row.
  ///
  /// IMPORTANT NOTE: The predicate filter does not execute atomically with the
  /// true and false filters, which may lead to inconsistent or unexpected
  /// results. Additionally, Condition filters have poor performance, especially
  /// when filters are set for the false condition.
  public struct Condition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If `predicate_filter` outputs any cells, then `true_filter` will be
    /// evaluated on the input row. Otherwise, `false_filter` will be evaluated.
    public var predicateFilter: Google_Bigtable_V2_RowFilter {
      get {return _storage._predicateFilter ?? Google_Bigtable_V2_RowFilter()}
      set {_uniqueStorage()._predicateFilter = newValue}
    }
    /// Returns true if `predicateFilter` has been explicitly set.
    public var hasPredicateFilter: Bool {return _storage._predicateFilter != nil}
    /// Clears the value of `predicateFilter`. Subsequent reads from it will return its default value.
    public mutating func clearPredicateFilter() {_uniqueStorage()._predicateFilter = nil}

    /// The filter to apply to the input row if `predicate_filter` returns any
    /// results. If not provided, no results will be returned in the true case.
    public var trueFilter: Google_Bigtable_V2_RowFilter {
      get {return _storage._trueFilter ?? Google_Bigtable_V2_RowFilter()}
      set {_uniqueStorage()._trueFilter = newValue}
    }
    /// Returns true if `trueFilter` has been explicitly set.
    public var hasTrueFilter: Bool {return _storage._trueFilter != nil}
    /// Clears the value of `trueFilter`. Subsequent reads from it will return its default value.
    public mutating func clearTrueFilter() {_uniqueStorage()._trueFilter = nil}

    /// The filter to apply to the input row if `predicate_filter` does not
    /// return any results. If not provided, no results will be returned in the
    /// false case.
    public var falseFilter: Google_Bigtable_V2_RowFilter {
      get {return _storage._falseFilter ?? Google_Bigtable_V2_RowFilter()}
      set {_uniqueStorage()._falseFilter = newValue}
    }
    /// Returns true if `falseFilter` has been explicitly set.
    public var hasFalseFilter: Bool {return _storage._falseFilter != nil}
    /// Clears the value of `falseFilter`. Subsequent reads from it will return its default value.
    public mutating func clearFalseFilter() {_uniqueStorage()._falseFilter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Specifies a particular change to be made to the contents of a row.
public struct Google_Bigtable_V2_Mutation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which of the possible Mutation types to apply.
  public var mutation: Google_Bigtable_V2_Mutation.OneOf_Mutation? = nil

  /// Set a cell's value.
  public var setCell: Google_Bigtable_V2_Mutation.SetCell {
    get {
      if case .setCell(let v)? = mutation {return v}
      return Google_Bigtable_V2_Mutation.SetCell()
    }
    set {mutation = .setCell(newValue)}
  }

  /// Deletes cells from a column.
  public var deleteFromColumn: Google_Bigtable_V2_Mutation.DeleteFromColumn {
    get {
      if case .deleteFromColumn(let v)? = mutation {return v}
      return Google_Bigtable_V2_Mutation.DeleteFromColumn()
    }
    set {mutation = .deleteFromColumn(newValue)}
  }

  /// Deletes cells from a column family.
  public var deleteFromFamily: Google_Bigtable_V2_Mutation.DeleteFromFamily {
    get {
      if case .deleteFromFamily(let v)? = mutation {return v}
      return Google_Bigtable_V2_Mutation.DeleteFromFamily()
    }
    set {mutation = .deleteFromFamily(newValue)}
  }

  /// Deletes cells from the entire row.
  public var deleteFromRow: Google_Bigtable_V2_Mutation.DeleteFromRow {
    get {
      if case .deleteFromRow(let v)? = mutation {return v}
      return Google_Bigtable_V2_Mutation.DeleteFromRow()
    }
    set {mutation = .deleteFromRow(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Which of the possible Mutation types to apply.
  public enum OneOf_Mutation: Equatable {
    /// Set a cell's value.
    case setCell(Google_Bigtable_V2_Mutation.SetCell)
    /// Deletes cells from a column.
    case deleteFromColumn(Google_Bigtable_V2_Mutation.DeleteFromColumn)
    /// Deletes cells from a column family.
    case deleteFromFamily(Google_Bigtable_V2_Mutation.DeleteFromFamily)
    /// Deletes cells from the entire row.
    case deleteFromRow(Google_Bigtable_V2_Mutation.DeleteFromRow)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_Mutation.OneOf_Mutation, rhs: Google_Bigtable_V2_Mutation.OneOf_Mutation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.setCell, .setCell): return {
        guard case .setCell(let l) = lhs, case .setCell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteFromColumn, .deleteFromColumn): return {
        guard case .deleteFromColumn(let l) = lhs, case .deleteFromColumn(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteFromFamily, .deleteFromFamily): return {
        guard case .deleteFromFamily(let l) = lhs, case .deleteFromFamily(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteFromRow, .deleteFromRow): return {
        guard case .deleteFromRow(let l) = lhs, case .deleteFromRow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A Mutation which sets the value of the specified cell.
  public struct SetCell {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the family into which new data should be written.
    /// Must match `[-_.a-zA-Z0-9]+`
    public var familyName: String = String()

    /// The qualifier of the column into which new data should be written.
    /// Can be any byte string, including the empty string.
    public var columnQualifier: Data = Data()

    /// The timestamp of the cell into which new data should be written.
    /// Use -1 for current Bigtable server time.
    /// Otherwise, the client should set this value itself, noting that the
    /// default value is a timestamp of zero if the field is left unspecified.
    /// Values must match the granularity of the table (e.g. micros, millis).
    public var timestampMicros: Int64 = 0

    /// The value to be written into the specified cell.
    public var value: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A Mutation which deletes cells from the specified column, optionally
  /// restricting the deletions to a given timestamp range.
  public struct DeleteFromColumn {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the family from which cells should be deleted.
    /// Must match `[-_.a-zA-Z0-9]+`
    public var familyName: String = String()

    /// The qualifier of the column from which cells should be deleted.
    /// Can be any byte string, including the empty string.
    public var columnQualifier: Data = Data()

    /// The range of timestamps within which cells should be deleted.
    public var timeRange: Google_Bigtable_V2_TimestampRange {
      get {return _timeRange ?? Google_Bigtable_V2_TimestampRange()}
      set {_timeRange = newValue}
    }
    /// Returns true if `timeRange` has been explicitly set.
    public var hasTimeRange: Bool {return self._timeRange != nil}
    /// Clears the value of `timeRange`. Subsequent reads from it will return its default value.
    public mutating func clearTimeRange() {self._timeRange = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timeRange: Google_Bigtable_V2_TimestampRange? = nil
  }

  /// A Mutation which deletes all cells from the specified column family.
  public struct DeleteFromFamily {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the family from which cells should be deleted.
    /// Must match `[-_.a-zA-Z0-9]+`
    public var familyName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A Mutation which deletes all cells from the containing row.
  public struct DeleteFromRow {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Specifies an atomic read/modify/write operation on the latest value of the
/// specified column.
public struct Google_Bigtable_V2_ReadModifyWriteRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the family to which the read/modify/write should be applied.
  /// Must match `[-_.a-zA-Z0-9]+`
  public var familyName: String = String()

  /// The qualifier of the column to which the read/modify/write should be
  /// applied.
  /// Can be any byte string, including the empty string.
  public var columnQualifier: Data = Data()

  /// The rule used to determine the column's new latest value from its current
  /// latest value.
  public var rule: Google_Bigtable_V2_ReadModifyWriteRule.OneOf_Rule? = nil

  /// Rule specifying that `append_value` be appended to the existing value.
  /// If the targeted cell is unset, it will be treated as containing the
  /// empty string.
  public var appendValue: Data {
    get {
      if case .appendValue(let v)? = rule {return v}
      return Data()
    }
    set {rule = .appendValue(newValue)}
  }

  /// Rule specifying that `increment_amount` be added to the existing value.
  /// If the targeted cell is unset, it will be treated as containing a zero.
  /// Otherwise, the targeted cell must contain an 8-byte value (interpreted
  /// as a 64-bit big-endian signed integer), or the entire request will fail.
  public var incrementAmount: Int64 {
    get {
      if case .incrementAmount(let v)? = rule {return v}
      return 0
    }
    set {rule = .incrementAmount(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The rule used to determine the column's new latest value from its current
  /// latest value.
  public enum OneOf_Rule: Equatable {
    /// Rule specifying that `append_value` be appended to the existing value.
    /// If the targeted cell is unset, it will be treated as containing the
    /// empty string.
    case appendValue(Data)
    /// Rule specifying that `increment_amount` be added to the existing value.
    /// If the targeted cell is unset, it will be treated as containing a zero.
    /// Otherwise, the targeted cell must contain an 8-byte value (interpreted
    /// as a 64-bit big-endian signed integer), or the entire request will fail.
    case incrementAmount(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_V2_ReadModifyWriteRule.OneOf_Rule, rhs: Google_Bigtable_V2_ReadModifyWriteRule.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.appendValue, .appendValue): return {
        guard case .appendValue(let l) = lhs, case .appendValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.incrementAmount, .incrementAmount): return {
        guard case .incrementAmount(let l) = lhs, case .incrementAmount(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.v2"

extension Google_Bigtable_V2_Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Row"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "families"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.families) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.families.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.families, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Row, rhs: Google_Bigtable_V2_Row) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.families != rhs.families {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Family: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Family"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "columns"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.columns) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.columns.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.columns, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Family, rhs: Google_Bigtable_V2_Family) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.columns != rhs.columns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Column: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Column"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "qualifier"),
    2: .same(proto: "cells"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.qualifier) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cells) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.qualifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.qualifier, fieldNumber: 1)
    }
    if !self.cells.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cells, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Column, rhs: Google_Bigtable_V2_Column) -> Bool {
    if lhs.qualifier != rhs.qualifier {return false}
    if lhs.cells != rhs.cells {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Cell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cell"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_micros"),
    2: .same(proto: "value"),
    3: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.timestampMicros) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMicros, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Cell, rhs: Google_Bigtable_V2_Cell) -> Bool {
    if lhs.timestampMicros != rhs.timestampMicros {return false}
    if lhs.value != rhs.value {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_RowRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RowRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_key_closed"),
    2: .standard(proto: "start_key_open"),
    3: .standard(proto: "end_key_open"),
    4: .standard(proto: "end_key_closed"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.startKey != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.startKey = .startKeyClosed(v)}
      }()
      case 2: try {
        if self.startKey != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.startKey = .startKeyOpen(v)}
      }()
      case 3: try {
        if self.endKey != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.endKey = .endKeyOpen(v)}
      }()
      case 4: try {
        if self.endKey != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.endKey = .endKeyClosed(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.startKey {
    case .startKeyClosed?: try {
      guard case .startKeyClosed(let v)? = self.startKey else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .startKeyOpen?: try {
      guard case .startKeyOpen(let v)? = self.startKey else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.endKey {
    case .endKeyOpen?: try {
      guard case .endKeyOpen(let v)? = self.endKey else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .endKeyClosed?: try {
      guard case .endKeyClosed(let v)? = self.endKey else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_RowRange, rhs: Google_Bigtable_V2_RowRange) -> Bool {
    if lhs.startKey != rhs.startKey {return false}
    if lhs.endKey != rhs.endKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_RowSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RowSet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_keys"),
    2: .standard(proto: "row_ranges"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.rowKeys) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rowRanges) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.rowKeys, fieldNumber: 1)
    }
    if !self.rowRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rowRanges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_RowSet, rhs: Google_Bigtable_V2_RowSet) -> Bool {
    if lhs.rowKeys != rhs.rowKeys {return false}
    if lhs.rowRanges != rhs.rowRanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ColumnRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ColumnRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "family_name"),
    2: .standard(proto: "start_qualifier_closed"),
    3: .standard(proto: "start_qualifier_open"),
    4: .standard(proto: "end_qualifier_closed"),
    5: .standard(proto: "end_qualifier_open"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 2: try {
        if self.startQualifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.startQualifier = .startQualifierClosed(v)}
      }()
      case 3: try {
        if self.startQualifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.startQualifier = .startQualifierOpen(v)}
      }()
      case 4: try {
        if self.endQualifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.endQualifier = .endQualifierClosed(v)}
      }()
      case 5: try {
        if self.endQualifier != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.endQualifier = .endQualifierOpen(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.startQualifier {
    case .startQualifierClosed?: try {
      guard case .startQualifierClosed(let v)? = self.startQualifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .startQualifierOpen?: try {
      guard case .startQualifierOpen(let v)? = self.startQualifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.endQualifier {
    case .endQualifierClosed?: try {
      guard case .endQualifierClosed(let v)? = self.endQualifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case .endQualifierOpen?: try {
      guard case .endQualifierOpen(let v)? = self.endQualifier else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ColumnRange, rhs: Google_Bigtable_V2_ColumnRange) -> Bool {
    if lhs.familyName != rhs.familyName {return false}
    if lhs.startQualifier != rhs.startQualifier {return false}
    if lhs.endQualifier != rhs.endQualifier {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_TimestampRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimestampRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_timestamp_micros"),
    2: .standard(proto: "end_timestamp_micros"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startTimestampMicros) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endTimestampMicros) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startTimestampMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestampMicros, fieldNumber: 1)
    }
    if self.endTimestampMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.endTimestampMicros, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_TimestampRange, rhs: Google_Bigtable_V2_TimestampRange) -> Bool {
    if lhs.startTimestampMicros != rhs.startTimestampMicros {return false}
    if lhs.endTimestampMicros != rhs.endTimestampMicros {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ValueRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValueRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_value_closed"),
    2: .standard(proto: "start_value_open"),
    3: .standard(proto: "end_value_closed"),
    4: .standard(proto: "end_value_open"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.startValue != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.startValue = .startValueClosed(v)}
      }()
      case 2: try {
        if self.startValue != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.startValue = .startValueOpen(v)}
      }()
      case 3: try {
        if self.endValue != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.endValue = .endValueClosed(v)}
      }()
      case 4: try {
        if self.endValue != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.endValue = .endValueOpen(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.startValue {
    case .startValueClosed?: try {
      guard case .startValueClosed(let v)? = self.startValue else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .startValueOpen?: try {
      guard case .startValueOpen(let v)? = self.startValue else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.endValue {
    case .endValueClosed?: try {
      guard case .endValueClosed(let v)? = self.endValue else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .endValueOpen?: try {
      guard case .endValueOpen(let v)? = self.endValue else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ValueRange, rhs: Google_Bigtable_V2_ValueRange) -> Bool {
    if lhs.startValue != rhs.startValue {return false}
    if lhs.endValue != rhs.endValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_RowFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RowFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
    2: .same(proto: "interleave"),
    3: .same(proto: "condition"),
    16: .same(proto: "sink"),
    17: .standard(proto: "pass_all_filter"),
    18: .standard(proto: "block_all_filter"),
    4: .standard(proto: "row_key_regex_filter"),
    14: .standard(proto: "row_sample_filter"),
    5: .standard(proto: "family_name_regex_filter"),
    6: .standard(proto: "column_qualifier_regex_filter"),
    7: .standard(proto: "column_range_filter"),
    8: .standard(proto: "timestamp_range_filter"),
    9: .standard(proto: "value_regex_filter"),
    15: .standard(proto: "value_range_filter"),
    10: .standard(proto: "cells_per_row_offset_filter"),
    11: .standard(proto: "cells_per_row_limit_filter"),
    12: .standard(proto: "cells_per_column_limit_filter"),
    13: .standard(proto: "strip_value_transformer"),
    19: .standard(proto: "apply_label_transformer"),
  ]

  fileprivate class _StorageClass {
    var _filter: Google_Bigtable_V2_RowFilter.OneOf_Filter?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _filter = source._filter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Google_Bigtable_V2_RowFilter.Chain?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .chain(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .chain(v)}
        }()
        case 2: try {
          var v: Google_Bigtable_V2_RowFilter.Interleave?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .interleave(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .interleave(v)}
        }()
        case 3: try {
          var v: Google_Bigtable_V2_RowFilter.Condition?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .condition(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .condition(v)}
        }()
        case 4: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._filter = .rowKeyRegexFilter(v)}
        }()
        case 5: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .familyNameRegexFilter(v)}
        }()
        case 6: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._filter = .columnQualifierRegexFilter(v)}
        }()
        case 7: try {
          var v: Google_Bigtable_V2_ColumnRange?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .columnRangeFilter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .columnRangeFilter(v)}
        }()
        case 8: try {
          var v: Google_Bigtable_V2_TimestampRange?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .timestampRangeFilter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .timestampRangeFilter(v)}
        }()
        case 9: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Data?
          try decoder.decodeSingularBytesField(value: &v)
          if let v = v {_storage._filter = .valueRegexFilter(v)}
        }()
        case 10: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {_storage._filter = .cellsPerRowOffsetFilter(v)}
        }()
        case 11: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {_storage._filter = .cellsPerRowLimitFilter(v)}
        }()
        case 12: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Int32?
          try decoder.decodeSingularInt32Field(value: &v)
          if let v = v {_storage._filter = .cellsPerColumnLimitFilter(v)}
        }()
        case 13: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._filter = .stripValueTransformer(v)}
        }()
        case 14: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Double?
          try decoder.decodeSingularDoubleField(value: &v)
          if let v = v {_storage._filter = .rowSampleFilter(v)}
        }()
        case 15: try {
          var v: Google_Bigtable_V2_ValueRange?
          if let current = _storage._filter {
            try decoder.handleConflictingOneOf()
            if case .valueRangeFilter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._filter = .valueRangeFilter(v)}
        }()
        case 16: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._filter = .sink(v)}
        }()
        case 17: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._filter = .passAllFilter(v)}
        }()
        case 18: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: Bool?
          try decoder.decodeSingularBoolField(value: &v)
          if let v = v {_storage._filter = .blockAllFilter(v)}
        }()
        case 19: try {
          if _storage._filter != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._filter = .applyLabelTransformer(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._filter {
      case .chain?: try {
        guard case .chain(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .interleave?: try {
        guard case .interleave(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .condition?: try {
        guard case .condition(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .rowKeyRegexFilter?: try {
        guard case .rowKeyRegexFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
      }()
      case .familyNameRegexFilter?: try {
        guard case .familyNameRegexFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }()
      case .columnQualifierRegexFilter?: try {
        guard case .columnQualifierRegexFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      }()
      case .columnRangeFilter?: try {
        guard case .columnRangeFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .timestampRangeFilter?: try {
        guard case .timestampRangeFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .valueRegexFilter?: try {
        guard case .valueRegexFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBytesField(value: v, fieldNumber: 9)
      }()
      case .cellsPerRowOffsetFilter?: try {
        guard case .cellsPerRowOffsetFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 10)
      }()
      case .cellsPerRowLimitFilter?: try {
        guard case .cellsPerRowLimitFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 11)
      }()
      case .cellsPerColumnLimitFilter?: try {
        guard case .cellsPerColumnLimitFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 12)
      }()
      case .stripValueTransformer?: try {
        guard case .stripValueTransformer(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      }()
      case .rowSampleFilter?: try {
        guard case .rowSampleFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularDoubleField(value: v, fieldNumber: 14)
      }()
      case .valueRangeFilter?: try {
        guard case .valueRangeFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .sink?: try {
        guard case .sink(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 16)
      }()
      case .passAllFilter?: try {
        guard case .passAllFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      }()
      case .blockAllFilter?: try {
        guard case .blockAllFilter(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularBoolField(value: v, fieldNumber: 18)
      }()
      case .applyLabelTransformer?: try {
        guard case .applyLabelTransformer(let v)? = _storage._filter else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 19)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_RowFilter, rhs: Google_Bigtable_V2_RowFilter) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._filter != rhs_storage._filter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_RowFilter.Chain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_RowFilter.protoMessageName + ".Chain"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_RowFilter.Chain, rhs: Google_Bigtable_V2_RowFilter.Chain) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_RowFilter.Interleave: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_RowFilter.protoMessageName + ".Interleave"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_RowFilter.Interleave, rhs: Google_Bigtable_V2_RowFilter.Interleave) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_RowFilter.Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_RowFilter.protoMessageName + ".Condition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "predicate_filter"),
    2: .standard(proto: "true_filter"),
    3: .standard(proto: "false_filter"),
  ]

  fileprivate class _StorageClass {
    var _predicateFilter: Google_Bigtable_V2_RowFilter? = nil
    var _trueFilter: Google_Bigtable_V2_RowFilter? = nil
    var _falseFilter: Google_Bigtable_V2_RowFilter? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _predicateFilter = source._predicateFilter
      _trueFilter = source._trueFilter
      _falseFilter = source._falseFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._predicateFilter) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._trueFilter) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._falseFilter) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._predicateFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._trueFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._falseFilter {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_RowFilter.Condition, rhs: Google_Bigtable_V2_RowFilter.Condition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._predicateFilter != rhs_storage._predicateFilter {return false}
        if _storage._trueFilter != rhs_storage._trueFilter {return false}
        if _storage._falseFilter != rhs_storage._falseFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Mutation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Mutation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "set_cell"),
    2: .standard(proto: "delete_from_column"),
    3: .standard(proto: "delete_from_family"),
    4: .standard(proto: "delete_from_row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Bigtable_V2_Mutation.SetCell?
        if let current = self.mutation {
          try decoder.handleConflictingOneOf()
          if case .setCell(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mutation = .setCell(v)}
      }()
      case 2: try {
        var v: Google_Bigtable_V2_Mutation.DeleteFromColumn?
        if let current = self.mutation {
          try decoder.handleConflictingOneOf()
          if case .deleteFromColumn(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mutation = .deleteFromColumn(v)}
      }()
      case 3: try {
        var v: Google_Bigtable_V2_Mutation.DeleteFromFamily?
        if let current = self.mutation {
          try decoder.handleConflictingOneOf()
          if case .deleteFromFamily(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mutation = .deleteFromFamily(v)}
      }()
      case 4: try {
        var v: Google_Bigtable_V2_Mutation.DeleteFromRow?
        if let current = self.mutation {
          try decoder.handleConflictingOneOf()
          if case .deleteFromRow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mutation = .deleteFromRow(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.mutation {
    case .setCell?: try {
      guard case .setCell(let v)? = self.mutation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .deleteFromColumn?: try {
      guard case .deleteFromColumn(let v)? = self.mutation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deleteFromFamily?: try {
      guard case .deleteFromFamily(let v)? = self.mutation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteFromRow?: try {
      guard case .deleteFromRow(let v)? = self.mutation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Mutation, rhs: Google_Bigtable_V2_Mutation) -> Bool {
    if lhs.mutation != rhs.mutation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Mutation.SetCell: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_Mutation.protoMessageName + ".SetCell"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "family_name"),
    2: .standard(proto: "column_qualifier"),
    3: .standard(proto: "timestamp_micros"),
    4: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.columnQualifier) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestampMicros) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 1)
    }
    if !self.columnQualifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.columnQualifier, fieldNumber: 2)
    }
    if self.timestampMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMicros, fieldNumber: 3)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Mutation.SetCell, rhs: Google_Bigtable_V2_Mutation.SetCell) -> Bool {
    if lhs.familyName != rhs.familyName {return false}
    if lhs.columnQualifier != rhs.columnQualifier {return false}
    if lhs.timestampMicros != rhs.timestampMicros {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Mutation.DeleteFromColumn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_Mutation.protoMessageName + ".DeleteFromColumn"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "family_name"),
    2: .standard(proto: "column_qualifier"),
    3: .standard(proto: "time_range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.columnQualifier) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timeRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 1)
    }
    if !self.columnQualifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.columnQualifier, fieldNumber: 2)
    }
    if let v = self._timeRange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Mutation.DeleteFromColumn, rhs: Google_Bigtable_V2_Mutation.DeleteFromColumn) -> Bool {
    if lhs.familyName != rhs.familyName {return false}
    if lhs.columnQualifier != rhs.columnQualifier {return false}
    if lhs._timeRange != rhs._timeRange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Mutation.DeleteFromFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_Mutation.protoMessageName + ".DeleteFromFamily"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "family_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Mutation.DeleteFromFamily, rhs: Google_Bigtable_V2_Mutation.DeleteFromFamily) -> Bool {
    if lhs.familyName != rhs.familyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_Mutation.DeleteFromRow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_Mutation.protoMessageName + ".DeleteFromRow"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_Mutation.DeleteFromRow, rhs: Google_Bigtable_V2_Mutation.DeleteFromRow) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ReadModifyWriteRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadModifyWriteRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "family_name"),
    2: .standard(proto: "column_qualifier"),
    3: .standard(proto: "append_value"),
    4: .standard(proto: "increment_amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.familyName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.columnQualifier) }()
      case 3: try {
        if self.rule != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.rule = .appendValue(v)}
      }()
      case 4: try {
        if self.rule != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.rule = .incrementAmount(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.familyName.isEmpty {
      try visitor.visitSingularStringField(value: self.familyName, fieldNumber: 1)
    }
    if !self.columnQualifier.isEmpty {
      try visitor.visitSingularBytesField(value: self.columnQualifier, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rule {
    case .appendValue?: try {
      guard case .appendValue(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }()
    case .incrementAmount?: try {
      guard case .incrementAmount(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ReadModifyWriteRule, rhs: Google_Bigtable_V2_ReadModifyWriteRule) -> Bool {
    if lhs.familyName != rhs.familyName {return false}
    if lhs.columnQualifier != rhs.columnQualifier {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/v2/bigtable.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request message for Bigtable.ReadRows.
public struct Google_Bigtable_V2_ReadRowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table from which to read.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/tables/<table>`.
  public var tableName: String = String()

  /// This value specifies routing for replication. If not specified, the
  /// "default" application profile will be used.
  public var appProfileID: String = String()

  /// The row keys and/or ranges to read. If not specified, reads from all rows.
  public var rows: Google_Bigtable_V2_RowSet {
    get {return _rows ?? Google_Bigtable_V2_RowSet()}
    set {_rows = newValue}
  }
  /// Returns true if `rows` has been explicitly set.
  public var hasRows: Bool {return self._rows != nil}
  /// Clears the value of `rows`. Subsequent reads from it will return its default value.
  public mutating func clearRows() {self._rows = nil}

  /// The filter to apply to the contents of the specified row(s). If unset,
  /// reads the entirety of each row.
  public var filter: Google_Bigtable_V2_RowFilter {
    get {return _filter ?? Google_Bigtable_V2_RowFilter()}
    set {_filter = newValue}
  }
  /// Returns true if `filter` has been explicitly set.
  public var hasFilter: Bool {return self._filter != nil}
  /// Clears the value of `filter`. Subsequent reads from it will return its default value.
  public mutating func clearFilter() {self._filter = nil}

  /// The read will terminate after committing to N rows' worth of results. The
  /// default (zero) is to return all results.
  public var rowsLimit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rows: Google_Bigtable_V2_RowSet? = nil
  fileprivate var _filter: Google_Bigtable_V2_RowFilter? = nil
}

/// Response message for Bigtable.ReadRows.
public struct Google_Bigtable_V2_ReadRowsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A collection of a row's contents as part of the read request.
  public var chunks: [Google_Bigtable_V2_ReadRowsResponse.CellChunk] = []

  /// Optionally the server might return the row key of the last row it
  /// has scanned.  The client can use this to construct a more
  /// efficient retry request if needed: any row keys or portions of
  /// ranges less than this row key can be dropped from the request.
  /// This is primarily useful for cases where the server has read a
  /// lot of data that was filtered out since the last committed row
  /// key, allowing the client to skip that work on a retry.
  public var lastScannedRowKey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies a piece of a row's contents returned as part of the read
  /// response stream.
  public struct CellChunk {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The row key for this chunk of data.  If the row key is empty,
    /// this CellChunk is a continuation of the same row as the previous
    /// CellChunk in the response stream, even if that CellChunk was in a
    /// previous ReadRowsResponse message.
    public var rowKey: Data = Data()

    /// The column family name for this chunk of data.  If this message
    /// is not present this CellChunk is a continuation of the same column
    /// family as the previous CellChunk.  The empty string can occur as a
    /// column family name in a response so clients must check
    /// explicitly for the presence of this message, not just for
    /// `family_name.value` being non-empty.
    public var familyName: SwiftProtobuf.Google_Protobuf_StringValue {
      get {return _familyName ?? SwiftProtobuf.Google_Protobuf_StringValue()}
      set {_familyName = newValue}
    }
    /// Returns true if `familyName` has been explicitly set.
    public var hasFamilyName: Bool {return self._familyName != nil}
    /// Clears the value of `familyName`. Subsequent reads from it will return its default value.
    public mutating func clearFamilyName() {self._familyName = nil}

    /// The column qualifier for this chunk of data.  If this message
    /// is not present, this CellChunk is a continuation of the same column
    /// as the previous CellChunk.  Column qualifiers may be empty so
    /// clients must check for the presence of this message, not just
    /// for `qualifier.value` being non-empty.
    public var qualifier: SwiftProtobuf.Google_Protobuf_BytesValue {
      get {return _qualifier ?? SwiftProtobuf.Google_Protobuf_BytesValue()}
      set {_qualifier = newValue}
    }
    /// Returns true if `qualifier` has been explicitly set.
    public var hasQualifier: Bool {return self._qualifier != nil}
    /// Clears the value of `qualifier`. Subsequent reads from it will return its default value.
    public mutating func clearQualifier() {self._qualifier = nil}

    /// The cell's stored timestamp, which also uniquely identifies it
    /// within its column.  Values are always expressed in
    /// microseconds, but individual tables may set a coarser
    /// granularity to further restrict the allowed values. For
    /// example, a table which specifies millisecond granularity will
    /// only allow values of `timestamp_micros` which are multiples of
    /// 1000.  Timestamps are only set in the first CellChunk per cell
    /// (for cells split into multiple chunks).
    public var timestampMicros: Int64 = 0

    /// Labels applied to the cell by a
    /// [RowFilter][google.bigtable.v2.RowFilter].  Labels are only set
    /// on the first CellChunk per cell.
    public var labels: [String] = []

    /// The value stored in the cell.  Cell values can be split across
    /// multiple CellChunks.  In that case only the value field will be
    /// set in CellChunks after the first: the timestamp and labels
    /// will only be present in the first CellChunk, even if the first
    /// CellChunk came in a previous ReadRowsResponse.
    public var value: Data = Data()

    /// If this CellChunk is part of a chunked cell value and this is
    /// not the final chunk of that cell, value_size will be set to the
    /// total length of the cell value.  The client can use this size
    /// to pre-allocate memory to hold the full cell value.
    public var valueSize: Int32 = 0

    /// Signals to the client concerning previous CellChunks received.
    public var rowStatus: Google_Bigtable_V2_ReadRowsResponse.CellChunk.OneOf_RowStatus? = nil

    /// Indicates that the client should drop all previous chunks for
    /// `row_key`, as it will be re-read from the beginning.
    public var resetRow: Bool {
      get {
        if case .resetRow(let v)? = rowStatus {return v}
        return false
      }
      set {rowStatus = .resetRow(newValue)}
    }

    /// Indicates that the client can safely process all previous chunks for
    /// `row_key`, as its data has been fully read.
    public var commitRow: Bool {
      get {
        if case .commitRow(let v)? = rowStatus {return v}
        return false
      }
      set {rowStatus = .commitRow(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Signals to the client concerning previous CellChunks received.
    public enum OneOf_RowStatus: Equatable {
      /// Indicates that the client should drop all previous chunks for
      /// `row_key`, as it will be re-read from the beginning.
      case resetRow(Bool)
      /// Indicates that the client can safely process all previous chunks for
      /// `row_key`, as its data has been fully read.
      case commitRow(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Bigtable_V2_ReadRowsResponse.CellChunk.OneOf_RowStatus, rhs: Google_Bigtable_V2_ReadRowsResponse.CellChunk.OneOf_RowStatus) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.resetRow, .resetRow): return {
          guard case .resetRow(let l) = lhs, case .resetRow(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.commitRow, .commitRow): return {
          guard case .commitRow(let l) = lhs, case .commitRow(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}

    fileprivate var _familyName: SwiftProtobuf.Google_Protobuf_StringValue? = nil
    fileprivate var _qualifier: SwiftProtobuf.Google_Protobuf_BytesValue? = nil
  }

  public init() {}
}

/// Request message for Bigtable.SampleRowKeys.
public struct Google_Bigtable_V2_SampleRowKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table from which to sample row keys.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/tables/<table>`.
  public var tableName: String = String()

  /// This value specifies routing for replication. If not specified, the
  /// "default" application profile will be used.
  public var appProfileID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for Bigtable.SampleRowKeys.
public struct Google_Bigtable_V2_SampleRowKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sorted streamed sequence of sample row keys in the table. The table might
  /// have contents before the first row key in the list and after the last one,
  /// but a key containing the empty string indicates "end of table" and will be
  /// the last response given, if present.
  /// Note that row keys in this list may not have ever been written to or read
  /// from, and users should therefore not make any assumptions about the row key
  /// structure that are specific to their use case.
  public var rowKey: Data = Data()

  /// Approximate total storage space used by all rows in the table which precede
  /// `row_key`. Buffering the contents of all rows between two subsequent
  /// samples would require space roughly equal to the difference in their
  /// `offset_bytes` fields.
  public var offsetBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for Bigtable.MutateRow.
public struct Google_Bigtable_V2_MutateRowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table to which the mutation should be applied.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/tables/<table>`.
  public var tableName: String = String()

  /// This value specifies routing for replication. If not specified, the
  /// "default" application profile will be used.
  public var appProfileID: String = String()

  /// Required. The key of the row to which the mutation should be applied.
  public var rowKey: Data = Data()

  /// Required. Changes to be atomically applied to the specified row. Entries are applied
  /// in order, meaning that earlier mutations can be masked by later ones.
  /// Must contain at least one entry and at most 100000.
  public var mutations: [Google_Bigtable_V2_Mutation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for Bigtable.MutateRow.
public struct Google_Bigtable_V2_MutateRowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for BigtableService.MutateRows.
public struct Google_Bigtable_V2_MutateRowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table to which the mutations should be applied.
  public var tableName: String = String()

  /// This value specifies routing for replication. If not specified, the
  /// "default" application profile will be used.
  public var appProfileID: String = String()

  /// Required. The row keys and corresponding mutations to be applied in bulk.
  /// Each entry is applied as an atomic mutation, but the entries may be
  /// applied in arbitrary order (even between entries for the same row).
  /// At least one entry must be specified, and in total the entries can
  /// contain at most 100000 mutations.
  public var entries: [Google_Bigtable_V2_MutateRowsRequest.Entry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A mutation for a given row.
  public struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The key of the row to which the `mutations` should be applied.
    public var rowKey: Data = Data()

    /// Required. Changes to be atomically applied to the specified row. Mutations are
    /// applied in order, meaning that earlier mutations can be masked by
    /// later ones.
    /// You must specify at least one mutation.
    public var mutations: [Google_Bigtable_V2_Mutation] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Response message for BigtableService.MutateRows.
public struct Google_Bigtable_V2_MutateRowsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One or more results for Entries from the batch request.
  public var entries: [Google_Bigtable_V2_MutateRowsResponse.Entry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The result of applying a passed mutation in the original request.
  public struct Entry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The index into the original request's `entries` list of the Entry
    /// for which a result is being reported.
    public var index: Int64 = 0

    /// The result of the request Entry identified by `index`.
    /// Depending on how requests are batched during execution, it is possible
    /// for one Entry to fail due to an error with another Entry. In the event
    /// that this occurs, the same error will be reported for both entries.
    public var status: Google_Rpc_Status {
      get {return _status ?? Google_Rpc_Status()}
      set {_status = newValue}
    }
    /// Returns true if `status` has been explicitly set.
    public var hasStatus: Bool {return self._status != nil}
    /// Clears the value of `status`. Subsequent reads from it will return its default value.
    public mutating func clearStatus() {self._status = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _status: Google_Rpc_Status? = nil
  }

  public init() {}
}

/// Request message for Bigtable.CheckAndMutateRow.
public struct Google_Bigtable_V2_CheckAndMutateRowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table to which the conditional mutation should be
  /// applied.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/tables/<table>`.
  public var tableName: String = String()

  /// This value specifies routing for replication. If not specified, the
  /// "default" application profile will be used.
  public var appProfileID: String = String()

  /// Required. The key of the row to which the conditional mutation should be applied.
  public var rowKey: Data = Data()

  /// The filter to be applied to the contents of the specified row. Depending
  /// on whether or not any results are yielded, either `true_mutations` or
  /// `false_mutations` will be executed. If unset, checks that the row contains
  /// any values at all.
  public var predicateFilter: Google_Bigtable_V2_RowFilter {
    get {return _predicateFilter ?? Google_Bigtable_V2_RowFilter()}
    set {_predicateFilter = newValue}
  }
  /// Returns true if `predicateFilter` has been explicitly set.
  public var hasPredicateFilter: Bool {return self._predicateFilter != nil}
  /// Clears the value of `predicateFilter`. Subsequent reads from it will return its default value.
  public mutating func clearPredicateFilter() {self._predicateFilter = nil}

  /// Changes to be atomically applied to the specified row if `predicate_filter`
  /// yields at least one cell when applied to `row_key`. Entries are applied in
  /// order, meaning that earlier mutations can be masked by later ones.
  /// Must contain at least one entry if `false_mutations` is empty, and at most
  /// 100000.
  public var trueMutations: [Google_Bigtable_V2_Mutation] = []

  /// Changes to be atomically applied to the specified row if `predicate_filter`
  /// does not yield any cells when applied to `row_key`. Entries are applied in
  /// order, meaning that earlier mutations can be masked by later ones.
  /// Must contain at least one entry if `true_mutations` is empty, and at most
  /// 100000.
  public var falseMutations: [Google_Bigtable_V2_Mutation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _predicateFilter: Google_Bigtable_V2_RowFilter? = nil
}

/// Response message for Bigtable.CheckAndMutateRow.
public struct Google_Bigtable_V2_CheckAndMutateRowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not the request's `predicate_filter` yielded any results for
  /// the specified row.
  public var predicateMatched: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for Bigtable.ReadModifyWriteRow.
public struct Google_Bigtable_V2_ReadModifyWriteRowRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table to which the read/modify/write rules should be
  /// applied.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/tables/<table>`.
  public var tableName: String = String()

  /// This value specifies routing for replication. If not specified, the
  /// "default" application profile will be used.
  public var appProfileID: String = String()

  /// Required. The key of the row to which the read/modify/write rules should be applied.
  public var rowKey: Data = Data()

  /// Required. Rules specifying how the specified row's contents are to be transformed
  /// into writes. Entries are applied in order, meaning that earlier rules will
  /// affect the results of later ones.
  public var rules: [Google_Bigtable_V2_ReadModifyWriteRule] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for Bigtable.ReadModifyWriteRow.
public struct Google_Bigtable_V2_ReadModifyWriteRowResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A Row containing the new contents of all cells modified by the request.
  public var row: Google_Bigtable_V2_Row {
    get {return _row ?? Google_Bigtable_V2_Row()}
    set {_row = newValue}
  }
  /// Returns true if `row` has been explicitly set.
  public var hasRow: Bool {return self._row != nil}
  /// Clears the value of `row`. Subsequent reads from it will return its default value.
  public mutating func clearRow() {self._row = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _row: Google_Bigtable_V2_Row? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.v2"

extension Google_Bigtable_V2_ReadRowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadRowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    5: .standard(proto: "app_profile_id"),
    2: .same(proto: "rows"),
    3: .same(proto: "filter"),
    4: .standard(proto: "rows_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rows) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._filter) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.rowsLimit) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.appProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if let v = self._rows {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._filter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.rowsLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.rowsLimit, fieldNumber: 4)
    }
    if !self.appProfileID.isEmpty {
      try visitor.visitSingularStringField(value: self.appProfileID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ReadRowsRequest, rhs: Google_Bigtable_V2_ReadRowsRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.appProfileID != rhs.appProfileID {return false}
    if lhs._rows != rhs._rows {return false}
    if lhs._filter != rhs._filter {return false}
    if lhs.rowsLimit != rhs.rowsLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ReadRowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadRowsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunks"),
    2: .standard(proto: "last_scanned_row_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.chunks) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.lastScannedRowKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chunks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chunks, fieldNumber: 1)
    }
    if !self.lastScannedRowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastScannedRowKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ReadRowsResponse, rhs: Google_Bigtable_V2_ReadRowsResponse) -> Bool {
    if lhs.chunks != rhs.chunks {return false}
    if lhs.lastScannedRowKey != rhs.lastScannedRowKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ReadRowsResponse.CellChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_ReadRowsResponse.protoMessageName + ".CellChunk"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_key"),
    2: .standard(proto: "family_name"),
    3: .same(proto: "qualifier"),
    4: .standard(proto: "timestamp_micros"),
    5: .same(proto: "labels"),
    6: .same(proto: "value"),
    7: .standard(proto: "value_size"),
    8: .standard(proto: "reset_row"),
    9: .standard(proto: "commit_row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._familyName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._qualifier) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timestampMicros) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.labels) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.valueSize) }()
      case 8: try {
        if self.rowStatus != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.rowStatus = .resetRow(v)}
      }()
      case 9: try {
        if self.rowStatus != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.rowStatus = .commitRow(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 1)
    }
    if let v = self._familyName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._qualifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.timestampMicros != 0 {
      try visitor.visitSingularInt64Field(value: self.timestampMicros, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labels, fieldNumber: 5)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 6)
    }
    if self.valueSize != 0 {
      try visitor.visitSingularInt32Field(value: self.valueSize, fieldNumber: 7)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rowStatus {
    case .resetRow?: try {
      guard case .resetRow(let v)? = self.rowStatus else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
    }()
    case .commitRow?: try {
      guard case .commitRow(let v)? = self.rowStatus else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ReadRowsResponse.CellChunk, rhs: Google_Bigtable_V2_ReadRowsResponse.CellChunk) -> Bool {
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs._familyName != rhs._familyName {return false}
    if lhs._qualifier != rhs._qualifier {return false}
    if lhs.timestampMicros != rhs.timestampMicros {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.value != rhs.value {return false}
    if lhs.valueSize != rhs.valueSize {return false}
    if lhs.rowStatus != rhs.rowStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_SampleRowKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampleRowKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .standard(proto: "app_profile_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.appProfileID.isEmpty {
      try visitor.visitSingularStringField(value: self.appProfileID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_SampleRowKeysRequest, rhs: Google_Bigtable_V2_SampleRowKeysRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.appProfileID != rhs.appProfileID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_SampleRowKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SampleRowKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_key"),
    2: .standard(proto: "offset_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.offsetBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 1)
    }
    if self.offsetBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.offsetBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_SampleRowKeysResponse, rhs: Google_Bigtable_V2_SampleRowKeysResponse) -> Bool {
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.offsetBytes != rhs.offsetBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_MutateRowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    4: .standard(proto: "app_profile_id"),
    2: .standard(proto: "row_key"),
    3: .same(proto: "mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 2)
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 3)
    }
    if !self.appProfileID.isEmpty {
      try visitor.visitSingularStringField(value: self.appProfileID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_MutateRowRequest, rhs: Google_Bigtable_V2_MutateRowRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.appProfileID != rhs.appProfileID {return false}
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_MutateRowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_MutateRowResponse, rhs: Google_Bigtable_V2_MutateRowResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_MutateRowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    3: .standard(proto: "app_profile_id"),
    2: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    if !self.appProfileID.isEmpty {
      try visitor.visitSingularStringField(value: self.appProfileID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_MutateRowsRequest, rhs: Google_Bigtable_V2_MutateRowsRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.appProfileID != rhs.appProfileID {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_MutateRowsRequest.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_MutateRowsRequest.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "row_key"),
    2: .same(proto: "mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 1)
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_MutateRowsRequest.Entry, rhs: Google_Bigtable_V2_MutateRowsRequest.Entry) -> Bool {
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_MutateRowsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MutateRowsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_MutateRowsResponse, rhs: Google_Bigtable_V2_MutateRowsResponse) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_MutateRowsResponse.Entry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_V2_MutateRowsResponse.protoMessageName + ".Entry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_MutateRowsResponse.Entry, rhs: Google_Bigtable_V2_MutateRowsResponse.Entry) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_CheckAndMutateRowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckAndMutateRowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    7: .standard(proto: "app_profile_id"),
    2: .standard(proto: "row_key"),
    6: .standard(proto: "predicate_filter"),
    4: .standard(proto: "true_mutations"),
    5: .standard(proto: "false_mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.trueMutations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.falseMutations) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._predicateFilter) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.appProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 2)
    }
    if !self.trueMutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.trueMutations, fieldNumber: 4)
    }
    if !self.falseMutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.falseMutations, fieldNumber: 5)
    }
    if let v = self._predicateFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.appProfileID.isEmpty {
      try visitor.visitSingularStringField(value: self.appProfileID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_CheckAndMutateRowRequest, rhs: Google_Bigtable_V2_CheckAndMutateRowRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.appProfileID != rhs.appProfileID {return false}
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs._predicateFilter != rhs._predicateFilter {return false}
    if lhs.trueMutations != rhs.trueMutations {return false}
    if lhs.falseMutations != rhs.falseMutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_CheckAndMutateRowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckAndMutateRowResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "predicate_matched"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.predicateMatched) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.predicateMatched != false {
      try visitor.visitSingularBoolField(value: self.predicateMatched, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_CheckAndMutateRowResponse, rhs: Google_Bigtable_V2_CheckAndMutateRowResponse) -> Bool {
    if lhs.predicateMatched != rhs.predicateMatched {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ReadModifyWriteRowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadModifyWriteRowRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    4: .standard(proto: "app_profile_id"),
    2: .standard(proto: "row_key"),
    3: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rowKey) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appProfileID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    if !self.rowKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.rowKey, fieldNumber: 2)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 3)
    }
    if !self.appProfileID.isEmpty {
      try visitor.visitSingularStringField(value: self.appProfileID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ReadModifyWriteRowRequest, rhs: Google_Bigtable_V2_ReadModifyWriteRowRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.appProfileID != rhs.appProfileID {return false}
    if lhs.rowKey != rhs.rowKey {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_V2_ReadModifyWriteRowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadModifyWriteRowResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "row"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._row) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._row {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_V2_ReadModifyWriteRowResponse, rhs: Google_Bigtable_V2_ReadModifyWriteRowResponse) -> Bool {
    if lhs._row != rhs._row {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/admin/v2/table.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicates the type of the restore source.
public enum Google_Bigtable_Admin_V2_RestoreSourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No restore associated.
  case unspecified // = 0

  /// A backup was used as the source of the restore.
  case backup // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .backup
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .backup: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Bigtable_Admin_V2_RestoreSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_RestoreSourceType] = [
    .unspecified,
    .backup,
  ]
}

#endif  // swift(>=4.2)

/// Information about a table restore.
public struct Google_Bigtable_Admin_V2_RestoreInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the restore source.
  public var sourceType: Google_Bigtable_Admin_V2_RestoreSourceType = .unspecified

  /// Information about the source used to restore the table.
  public var sourceInfo: Google_Bigtable_Admin_V2_RestoreInfo.OneOf_SourceInfo? = nil

  /// Information about the backup used to restore the table. The backup
  /// may no longer exist.
  public var backupInfo: Google_Bigtable_Admin_V2_BackupInfo {
    get {
      if case .backupInfo(let v)? = sourceInfo {return v}
      return Google_Bigtable_Admin_V2_BackupInfo()
    }
    set {sourceInfo = .backupInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information about the source used to restore the table.
  public enum OneOf_SourceInfo: Equatable {
    /// Information about the backup used to restore the table. The backup
    /// may no longer exist.
    case backupInfo(Google_Bigtable_Admin_V2_BackupInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_V2_RestoreInfo.OneOf_SourceInfo, rhs: Google_Bigtable_Admin_V2_RestoreInfo.OneOf_SourceInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.backupInfo, .backupInfo): return {
        guard case .backupInfo(let l) = lhs, case .backupInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A collection of user data indexed by row, column, and timestamp.
/// Each table is served using the resources of its parent cluster.
public struct Google_Bigtable_Admin_V2_Table {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The unique name of the table. Values are of the form
  /// `projects/<project>/instances/<instance>/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
  /// Views: `NAME_ONLY`, `SCHEMA_VIEW`, `REPLICATION_VIEW`, `FULL`
  public var name: String = String()

  /// Output only. Map from cluster ID to per-cluster table state.
  /// If it could not be determined whether or not the table has data in a
  /// particular cluster (for example, if its zone is unavailable), then
  /// there will be an entry for the cluster with UNKNOWN `replication_status`.
  /// Views: `REPLICATION_VIEW`, `FULL`
  public var clusterStates: Dictionary<String,Google_Bigtable_Admin_V2_Table.ClusterState> = [:]

  /// (`CreationOnly`)
  /// The column families configured for this table, mapped by column family ID.
  /// Views: `SCHEMA_VIEW`, `FULL`
  public var columnFamilies: Dictionary<String,Google_Bigtable_Admin_V2_ColumnFamily> = [:]

  /// (`CreationOnly`)
  /// The granularity (i.e. `MILLIS`) at which timestamps are stored in
  /// this table. Timestamps not matching the granularity will be rejected.
  /// If unspecified at creation time, the value will be set to `MILLIS`.
  /// Views: `SCHEMA_VIEW`, `FULL`.
  public var granularity: Google_Bigtable_Admin_V2_Table.TimestampGranularity = .unspecified

  /// Output only. If this table was restored from another data source (e.g. a
  /// backup), this field will be populated with information about the restore.
  public var restoreInfo: Google_Bigtable_Admin_V2_RestoreInfo {
    get {return _restoreInfo ?? Google_Bigtable_Admin_V2_RestoreInfo()}
    set {_restoreInfo = newValue}
  }
  /// Returns true if `restoreInfo` has been explicitly set.
  public var hasRestoreInfo: Bool {return self._restoreInfo != nil}
  /// Clears the value of `restoreInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRestoreInfo() {self._restoreInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible timestamp granularities to use when keeping multiple versions
  /// of data in a table.
  public enum TimestampGranularity: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The user did not specify a granularity. Should not be returned.
    /// When specified during table creation, MILLIS will be used.
    case unspecified // = 0

    /// The table keeps data versioned at a granularity of 1ms.
    case millis // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .millis
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .millis: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Defines a view over a table's fields.
  public enum View: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Uses the default view for each method as documented in its request.
    case unspecified // = 0

    /// Only populates `name`.
    case nameOnly // = 1

    /// Only populates `name` and fields related to the table's schema.
    case schemaView // = 2

    /// Only populates `name` and fields related to the table's replication
    /// state.
    case replicationView // = 3

    /// Populates all fields.
    case full // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .nameOnly
      case 2: self = .schemaView
      case 3: self = .replicationView
      case 4: self = .full
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .nameOnly: return 1
      case .schemaView: return 2
      case .replicationView: return 3
      case .full: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The state of a table's data in a particular cluster.
  public struct ClusterState {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Output only. The state of replication for the table in this cluster.
    public var replicationState: Google_Bigtable_Admin_V2_Table.ClusterState.ReplicationState = .stateNotKnown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Table replication states.
    public enum ReplicationState: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// The replication state of the table is unknown in this cluster.
      case stateNotKnown // = 0

      /// The cluster was recently created, and the table must finish copying
      /// over pre-existing data from other clusters before it can begin
      /// receiving live replication updates and serving Data API requests.
      case initializing // = 1

      /// The table is temporarily unable to serve Data API requests from this
      /// cluster due to planned internal maintenance.
      case plannedMaintenance // = 2

      /// The table is temporarily unable to serve Data API requests from this
      /// cluster due to unplanned or emergency maintenance.
      case unplannedMaintenance // = 3

      /// The table can serve Data API requests from this cluster. Depending on
      /// replication delay, reads may not immediately reflect the state of the
      /// table in other clusters.
      case ready // = 4

      /// The table is fully created and ready for use after a restore, and is
      /// being optimized for performance. When optimizations are complete, the
      /// table will transition to `READY` state.
      case readyOptimizing // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .stateNotKnown
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stateNotKnown
        case 1: self = .initializing
        case 2: self = .plannedMaintenance
        case 3: self = .unplannedMaintenance
        case 4: self = .ready
        case 5: self = .readyOptimizing
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .stateNotKnown: return 0
        case .initializing: return 1
        case .plannedMaintenance: return 2
        case .unplannedMaintenance: return 3
        case .ready: return 4
        case .readyOptimizing: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _restoreInfo: Google_Bigtable_Admin_V2_RestoreInfo? = nil
}

#if swift(>=4.2)

extension Google_Bigtable_Admin_V2_Table.TimestampGranularity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Table.TimestampGranularity] = [
    .unspecified,
    .millis,
  ]
}

extension Google_Bigtable_Admin_V2_Table.View: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Table.View] = [
    .unspecified,
    .nameOnly,
    .schemaView,
    .replicationView,
    .full,
  ]
}

extension Google_Bigtable_Admin_V2_Table.ClusterState.ReplicationState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Table.ClusterState.ReplicationState] = [
    .stateNotKnown,
    .initializing,
    .plannedMaintenance,
    .unplannedMaintenance,
    .ready,
    .readyOptimizing,
  ]
}

#endif  // swift(>=4.2)

/// A set of columns within a table which share a common configuration.
public struct Google_Bigtable_Admin_V2_ColumnFamily {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Garbage collection rule specified as a protobuf.
  /// Must serialize to at most 500 bytes.
  ///
  /// NOTE: Garbage collection executes opportunistically in the background, and
  /// so it's possible for reads to return a cell even if it matches the active
  /// GC expression for its family.
  public var gcRule: Google_Bigtable_Admin_V2_GcRule {
    get {return _gcRule ?? Google_Bigtable_Admin_V2_GcRule()}
    set {_gcRule = newValue}
  }
  /// Returns true if `gcRule` has been explicitly set.
  public var hasGcRule: Bool {return self._gcRule != nil}
  /// Clears the value of `gcRule`. Subsequent reads from it will return its default value.
  public mutating func clearGcRule() {self._gcRule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gcRule: Google_Bigtable_Admin_V2_GcRule? = nil
}

/// Rule for determining which cells to delete during garbage collection.
public struct Google_Bigtable_Admin_V2_GcRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Garbage collection rules.
  public var rule: Google_Bigtable_Admin_V2_GcRule.OneOf_Rule? = nil

  /// Delete all cells in a column except the most recent N.
  public var maxNumVersions: Int32 {
    get {
      if case .maxNumVersions(let v)? = rule {return v}
      return 0
    }
    set {rule = .maxNumVersions(newValue)}
  }

  /// Delete cells in a column older than the given age.
  /// Values must be at least one millisecond, and will be truncated to
  /// microsecond granularity.
  public var maxAge: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .maxAge(let v)? = rule {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {rule = .maxAge(newValue)}
  }

  /// Delete cells that would be deleted by every nested rule.
  public var intersection: Google_Bigtable_Admin_V2_GcRule.Intersection {
    get {
      if case .intersection(let v)? = rule {return v}
      return Google_Bigtable_Admin_V2_GcRule.Intersection()
    }
    set {rule = .intersection(newValue)}
  }

  /// Delete cells that would be deleted by any nested rule.
  public var union: Google_Bigtable_Admin_V2_GcRule.Union {
    get {
      if case .union(let v)? = rule {return v}
      return Google_Bigtable_Admin_V2_GcRule.Union()
    }
    set {rule = .union(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Garbage collection rules.
  public enum OneOf_Rule: Equatable {
    /// Delete all cells in a column except the most recent N.
    case maxNumVersions(Int32)
    /// Delete cells in a column older than the given age.
    /// Values must be at least one millisecond, and will be truncated to
    /// microsecond granularity.
    case maxAge(SwiftProtobuf.Google_Protobuf_Duration)
    /// Delete cells that would be deleted by every nested rule.
    case intersection(Google_Bigtable_Admin_V2_GcRule.Intersection)
    /// Delete cells that would be deleted by any nested rule.
    case union(Google_Bigtable_Admin_V2_GcRule.Union)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_V2_GcRule.OneOf_Rule, rhs: Google_Bigtable_Admin_V2_GcRule.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.maxNumVersions, .maxNumVersions): return {
        guard case .maxNumVersions(let l) = lhs, case .maxNumVersions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.maxAge, .maxAge): return {
        guard case .maxAge(let l) = lhs, case .maxAge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intersection, .intersection): return {
        guard case .intersection(let l) = lhs, case .intersection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.union, .union): return {
        guard case .union(let l) = lhs, case .union(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A GcRule which deletes cells matching all of the given rules.
  public struct Intersection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only delete cells which would be deleted by every element of `rules`.
    public var rules: [Google_Bigtable_Admin_V2_GcRule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A GcRule which deletes cells matching any of the given rules.
  public struct Union {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delete cells which would be deleted by any element of `rules`.
    public var rules: [Google_Bigtable_Admin_V2_GcRule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// A snapshot of a table at a particular time. A snapshot can be used as a
/// checkpoint for data restoration or a data source for a new table.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_Snapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The unique name of the snapshot.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/clusters/<cluster>/snapshots/<snapshot>`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. The source table at the time the snapshot was taken.
  public var sourceTable: Google_Bigtable_Admin_V2_Table {
    get {return _storage._sourceTable ?? Google_Bigtable_Admin_V2_Table()}
    set {_uniqueStorage()._sourceTable = newValue}
  }
  /// Returns true if `sourceTable` has been explicitly set.
  public var hasSourceTable: Bool {return _storage._sourceTable != nil}
  /// Clears the value of `sourceTable`. Subsequent reads from it will return its default value.
  public mutating func clearSourceTable() {_uniqueStorage()._sourceTable = nil}

  /// Output only. The size of the data in the source table at the time the
  /// snapshot was taken. In some cases, this value may be computed
  /// asynchronously via a background process and a placeholder of 0 will be used
  /// in the meantime.
  public var dataSizeBytes: Int64 {
    get {return _storage._dataSizeBytes}
    set {_uniqueStorage()._dataSizeBytes = newValue}
  }

  /// Output only. The time when the snapshot is created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time when the snapshot will be deleted. The maximum amount
  /// of time a snapshot can stay active is 365 days. If 'ttl' is not specified,
  /// the default maximum of 365 days will be used.
  public var deleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deleteTime = newValue}
  }
  /// Returns true if `deleteTime` has been explicitly set.
  public var hasDeleteTime: Bool {return _storage._deleteTime != nil}
  /// Clears the value of `deleteTime`. Subsequent reads from it will return its default value.
  public mutating func clearDeleteTime() {_uniqueStorage()._deleteTime = nil}

  /// Output only. The current state of the snapshot.
  public var state: Google_Bigtable_Admin_V2_Snapshot.State {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// Output only. Description of the snapshot.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible states of a snapshot.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the snapshot could not be determined.
    case notKnown // = 0

    /// The snapshot has been successfully created and can serve all requests.
    case ready // = 1

    /// The snapshot is currently being created, and may be destroyed if the
    /// creation process encounters an error. A snapshot may not be restored to a
    /// table while it is being created.
    case creating // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .notKnown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notKnown
      case 1: self = .ready
      case 2: self = .creating
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notKnown: return 0
      case .ready: return 1
      case .creating: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Bigtable_Admin_V2_Snapshot.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Snapshot.State] = [
    .notKnown,
    .ready,
    .creating,
  ]
}

#endif  // swift(>=4.2)

/// A backup of a Cloud Bigtable table.
public struct Google_Bigtable_Admin_V2_Backup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. A globally unique identifier for the backup which cannot be
  /// changed. Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/
  ///    backups/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`
  /// The final segment of the name must be between 1 and 50 characters
  /// in length.
  ///
  /// The backup is stored in the cluster identified by the prefix of the backup
  /// name of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
  public var name: String = String()

  /// Required. Immutable. Name of the table from which this backup was created.
  /// This needs to be in the same instance as the backup. Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{source_table}`.
  public var sourceTable: String = String()

  /// Required. The expiration time of the backup, with microseconds
  /// granularity that must be at least 6 hours and at most 30 days
  /// from the time the request is received. Once the `expire_time`
  /// has passed, Cloud Bigtable will delete the backup and free the
  /// resources used by the backup.
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  /// Output only. `start_time` is the time that the backup was started
  /// (i.e. approximately the time the
  /// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup]
  /// request is received).  The row data in this backup will be no older than
  /// this timestamp.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Output only. `end_time` is the time that the backup was finished. The row
  /// data in the backup will be no newer than this timestamp.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Output only. Size of the backup in bytes.
  public var sizeBytes: Int64 = 0

  /// Output only. The current state of the backup.
  public var state: Google_Bigtable_Admin_V2_Backup.State = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the current state of the backup.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// The pending backup is still being created. Operations on the
    /// backup may fail with `FAILED_PRECONDITION` in this state.
    case creating // = 1

    /// The backup is complete and ready for use.
    case ready // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .ready
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .ready: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Bigtable_Admin_V2_Backup.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Backup.State] = [
    .unspecified,
    .creating,
    .ready,
  ]
}

#endif  // swift(>=4.2)

/// Information about a backup.
public struct Google_Bigtable_Admin_V2_BackupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Name of the backup.
  public var backup: String = String()

  /// Output only. The time that the backup was started. Row data in the backup
  /// will be no older than this timestamp.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// Output only. This time that the backup was finished. Row data in the
  /// backup will be no newer than this timestamp.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Output only. Name of the table the backup was created from.
  public var sourceTable: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.admin.v2"

extension Google_Bigtable_Admin_V2_RestoreSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESTORE_SOURCE_TYPE_UNSPECIFIED"),
    1: .same(proto: "BACKUP"),
  ]
}

extension Google_Bigtable_Admin_V2_RestoreInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_type"),
    2: .standard(proto: "backup_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      case 2: try {
        var v: Google_Bigtable_Admin_V2_BackupInfo?
        if let current = self.sourceInfo {
          try decoder.handleConflictingOneOf()
          if case .backupInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sourceInfo = .backupInfo(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceType != .unspecified {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 1)
    }
    if case .backupInfo(let v)? = self.sourceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_RestoreInfo, rhs: Google_Bigtable_Admin_V2_RestoreInfo) -> Bool {
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.sourceInfo != rhs.sourceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Table: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Table"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "cluster_states"),
    3: .standard(proto: "column_families"),
    4: .same(proto: "granularity"),
    6: .standard(proto: "restore_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Bigtable_Admin_V2_Table.ClusterState>.self, value: &self.clusterStates) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Bigtable_Admin_V2_ColumnFamily>.self, value: &self.columnFamilies) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.granularity) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._restoreInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.clusterStates.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Bigtable_Admin_V2_Table.ClusterState>.self, value: self.clusterStates, fieldNumber: 2)
    }
    if !self.columnFamilies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Bigtable_Admin_V2_ColumnFamily>.self, value: self.columnFamilies, fieldNumber: 3)
    }
    if self.granularity != .unspecified {
      try visitor.visitSingularEnumField(value: self.granularity, fieldNumber: 4)
    }
    if let v = self._restoreInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_Table, rhs: Google_Bigtable_Admin_V2_Table) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.clusterStates != rhs.clusterStates {return false}
    if lhs.columnFamilies != rhs.columnFamilies {return false}
    if lhs.granularity != rhs.granularity {return false}
    if lhs._restoreInfo != rhs._restoreInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Table.TimestampGranularity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIMESTAMP_GRANULARITY_UNSPECIFIED"),
    1: .same(proto: "MILLIS"),
  ]
}

extension Google_Bigtable_Admin_V2_Table.View: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIEW_UNSPECIFIED"),
    1: .same(proto: "NAME_ONLY"),
    2: .same(proto: "SCHEMA_VIEW"),
    3: .same(proto: "REPLICATION_VIEW"),
    4: .same(proto: "FULL"),
  ]
}

extension Google_Bigtable_Admin_V2_Table.ClusterState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_Table.protoMessageName + ".ClusterState"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "replication_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.replicationState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.replicationState != .stateNotKnown {
      try visitor.visitSingularEnumField(value: self.replicationState, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_Table.ClusterState, rhs: Google_Bigtable_Admin_V2_Table.ClusterState) -> Bool {
    if lhs.replicationState != rhs.replicationState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Table.ClusterState.ReplicationState: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_NOT_KNOWN"),
    1: .same(proto: "INITIALIZING"),
    2: .same(proto: "PLANNED_MAINTENANCE"),
    3: .same(proto: "UNPLANNED_MAINTENANCE"),
    4: .same(proto: "READY"),
    5: .same(proto: "READY_OPTIMIZING"),
  ]
}

extension Google_Bigtable_Admin_V2_ColumnFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ColumnFamily"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gc_rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._gcRule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._gcRule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ColumnFamily, rhs: Google_Bigtable_Admin_V2_ColumnFamily) -> Bool {
    if lhs._gcRule != rhs._gcRule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GcRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_num_versions"),
    2: .standard(proto: "max_age"),
    3: .same(proto: "intersection"),
    4: .same(proto: "union"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.rule != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.rule = .maxNumVersions(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.rule {
          try decoder.handleConflictingOneOf()
          if case .maxAge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rule = .maxAge(v)}
      }()
      case 3: try {
        var v: Google_Bigtable_Admin_V2_GcRule.Intersection?
        if let current = self.rule {
          try decoder.handleConflictingOneOf()
          if case .intersection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rule = .intersection(v)}
      }()
      case 4: try {
        var v: Google_Bigtable_Admin_V2_GcRule.Union?
        if let current = self.rule {
          try decoder.handleConflictingOneOf()
          if case .union(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rule = .union(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rule {
    case .maxNumVersions?: try {
      guard case .maxNumVersions(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .maxAge?: try {
      guard case .maxAge(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .intersection?: try {
      guard case .intersection(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .union?: try {
      guard case .union(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GcRule, rhs: Google_Bigtable_Admin_V2_GcRule) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GcRule.Intersection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_GcRule.protoMessageName + ".Intersection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GcRule.Intersection, rhs: Google_Bigtable_Admin_V2_GcRule.Intersection) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GcRule.Union: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_GcRule.protoMessageName + ".Union"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GcRule.Union, rhs: Google_Bigtable_Admin_V2_GcRule.Union) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Snapshot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "source_table"),
    3: .standard(proto: "data_size_bytes"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "delete_time"),
    6: .same(proto: "state"),
    7: .same(proto: "description"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _sourceTable: Google_Bigtable_Admin_V2_Table? = nil
    var _dataSizeBytes: Int64 = 0
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Google_Bigtable_Admin_V2_Snapshot.State = .notKnown
    var _description_p: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _sourceTable = source._sourceTable
      _dataSizeBytes = source._dataSizeBytes
      _createTime = source._createTime
      _deleteTime = source._deleteTime
      _state = source._state
      _description_p = source._description_p
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._sourceTable) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._dataSizeBytes) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._deleteTime) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._sourceTable {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._dataSizeBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._dataSizeBytes, fieldNumber: 3)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._deleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._state != .notKnown {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_Snapshot, rhs: Google_Bigtable_Admin_V2_Snapshot) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._sourceTable != rhs_storage._sourceTable {return false}
        if _storage._dataSizeBytes != rhs_storage._dataSizeBytes {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._deleteTime != rhs_storage._deleteTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Snapshot.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_NOT_KNOWN"),
    1: .same(proto: "READY"),
    2: .same(proto: "CREATING"),
  ]
}

extension Google_Bigtable_Admin_V2_Backup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Backup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "source_table"),
    3: .standard(proto: "expire_time"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "size_bytes"),
    7: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceTable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.sourceTable.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceTable, fieldNumber: 2)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 6)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_Backup, rhs: Google_Bigtable_Admin_V2_Backup) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sourceTable != rhs.sourceTable {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Backup.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
  ]
}

extension Google_Bigtable_Admin_V2_BackupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BackupInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backup"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "end_time"),
    4: .standard(proto: "source_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.backup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sourceTable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.backup.isEmpty {
      try visitor.visitSingularStringField(value: self.backup, fieldNumber: 1)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.sourceTable.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceTable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_BackupInfo, rhs: Google_Bigtable_Admin_V2_BackupInfo) -> Bool {
    if lhs.backup != rhs.backup {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.sourceTable != rhs.sourceTable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

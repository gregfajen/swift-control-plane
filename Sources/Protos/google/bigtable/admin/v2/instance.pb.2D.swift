// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/admin/v2/instance.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A collection of Bigtable [Tables][google.bigtable.admin.v2.Table] and
/// the resources that serve them.
/// All tables in an instance are served from all
/// [Clusters][google.bigtable.admin.v2.Cluster] in the instance.
public struct Google_Bigtable_Admin_V2_Instance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the instance. Values are of the form
  /// `projects/{project}/instances/[a-z][a-z0-9\\-]+[a-z0-9]`.
  public var name: String = String()

  /// Required. The descriptive name for this instance as it appears in UIs.
  /// Can be changed at any time, but should be kept globally unique
  /// to avoid confusion.
  public var displayName: String = String()

  /// (`OutputOnly`)
  /// The current state of the instance.
  public var state: Google_Bigtable_Admin_V2_Instance.State = .notKnown

  /// The type of the instance. Defaults to `PRODUCTION`.
  public var type: Google_Bigtable_Admin_V2_Instance.TypeEnum = .unspecified

  /// Labels are a flexible and lightweight mechanism for organizing cloud
  /// resources into groups that reflect a customer's organizational needs and
  /// deployment strategies. They can be used to filter resources and aggregate
  /// metrics.
  ///
  /// * Label keys must be between 1 and 63 characters long and must conform to
  ///   the regular expression: `[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}`.
  /// * Label values must be between 0 and 63 characters long and must conform to
  ///   the regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`.
  /// * No more than 64 labels can be associated with a given resource.
  /// * Keys and values must both be under 128 bytes.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible states of an instance.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the instance could not be determined.
    case notKnown // = 0

    /// The instance has been successfully created and can serve requests
    /// to its tables.
    case ready // = 1

    /// The instance is currently being created, and may be destroyed
    /// if the creation process encounters an error.
    case creating // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .notKnown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notKnown
      case 1: self = .ready
      case 2: self = .creating
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notKnown: return 0
      case .ready: return 1
      case .creating: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The type of the instance.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The type of the instance is unspecified. If set when creating an
    /// instance, a `PRODUCTION` instance will be created. If set when updating
    /// an instance, the type will be left unchanged.
    case unspecified // = 0

    /// An instance meant for production use. `serve_nodes` must be set
    /// on the cluster.
    case production // = 1

    /// The instance is meant for development and testing purposes only; it has
    /// no performance or uptime guarantees and is not covered by SLA.
    /// After a development instance is created, it can be upgraded by
    /// updating the instance to type `PRODUCTION`. An instance created
    /// as a production instance cannot be changed to a development instance.
    /// When creating a development instance, `serve_nodes` on the cluster must
    /// not be set.
    case development // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .production
      case 2: self = .development
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .production: return 1
      case .development: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Bigtable_Admin_V2_Instance.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Instance.State] = [
    .notKnown,
    .ready,
    .creating,
  ]
}

extension Google_Bigtable_Admin_V2_Instance.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Instance.TypeEnum] = [
    .unspecified,
    .production,
    .development,
  ]
}

#endif  // swift(>=4.2)

/// A resizable group of nodes in a particular cloud location, capable
/// of serving all [Tables][google.bigtable.admin.v2.Table] in the parent
/// [Instance][google.bigtable.admin.v2.Instance].
public struct Google_Bigtable_Admin_V2_Cluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the cluster. Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/[a-z][-a-z0-9]*`.
  public var name: String = String()

  /// (`CreationOnly`)
  /// The location where this cluster's nodes and storage reside. For best
  /// performance, clients should be located as close as possible to this
  /// cluster. Currently only zones are supported, so values should be of the
  /// form `projects/{project}/locations/{zone}`.
  public var location: String = String()

  /// The current state of the cluster.
  public var state: Google_Bigtable_Admin_V2_Cluster.State = .notKnown

  /// Required. The number of nodes allocated to this cluster. More nodes enable
  /// higher throughput and more consistent performance.
  public var serveNodes: Int32 = 0

  /// (`CreationOnly`)
  /// The type of storage used by this cluster to serve its
  /// parent instance's tables, unless explicitly overridden.
  public var defaultStorageType: Google_Bigtable_Admin_V2_StorageType = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible states of a cluster.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The state of the cluster could not be determined.
    case notKnown // = 0

    /// The cluster has been successfully created and is ready to serve requests.
    case ready // = 1

    /// The cluster is currently being created, and may be destroyed
    /// if the creation process encounters an error.
    /// A cluster may not be able to serve requests while being created.
    case creating // = 2

    /// The cluster is currently being resized, and may revert to its previous
    /// node count if the process encounters an error.
    /// A cluster is still capable of serving requests while being resized,
    /// but may exhibit performance as if its number of allocated nodes is
    /// between the starting and requested states.
    case resizing // = 3

    /// The cluster has no backing nodes. The data (tables) still
    /// exist, but no operations can be performed on the cluster.
    case disabled // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .notKnown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notKnown
      case 1: self = .ready
      case 2: self = .creating
      case 3: self = .resizing
      case 4: self = .disabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notKnown: return 0
      case .ready: return 1
      case .creating: return 2
      case .resizing: return 3
      case .disabled: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Bigtable_Admin_V2_Cluster.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_V2_Cluster.State] = [
    .notKnown,
    .ready,
    .creating,
    .resizing,
    .disabled,
  ]
}

#endif  // swift(>=4.2)

/// A configuration object describing how Cloud Bigtable should treat traffic
/// from a particular end user application.
public struct Google_Bigtable_Admin_V2_AppProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// (`OutputOnly`)
  /// The unique name of the app profile. Values are of the form
  /// `projects/<project>/instances/<instance>/appProfiles/[_a-zA-Z0-9][-_.a-zA-Z0-9]*`.
  public var name: String = String()

  /// Strongly validated etag for optimistic concurrency control. Preserve the
  /// value returned from `GetAppProfile` when calling `UpdateAppProfile` to
  /// fail the request if there has been a modification in the mean time. The
  /// `update_mask` of the request need not include `etag` for this protection
  /// to apply.
  /// See [Wikipedia](https://en.wikipedia.org/wiki/HTTP_ETag) and
  /// [RFC 7232](https://tools.ietf.org/html/rfc7232#section-2.3) for more
  /// details.
  public var etag: String = String()

  /// Optional long form description of the use case for this AppProfile.
  public var description_p: String = String()

  /// The routing policy for all read/write requests that use this app profile.
  /// A value must be explicitly set.
  public var routingPolicy: Google_Bigtable_Admin_V2_AppProfile.OneOf_RoutingPolicy? = nil

  /// Use a multi-cluster routing policy.
  public var multiClusterRoutingUseAny: Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny {
    get {
      if case .multiClusterRoutingUseAny(let v)? = routingPolicy {return v}
      return Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny()
    }
    set {routingPolicy = .multiClusterRoutingUseAny(newValue)}
  }

  /// Use a single-cluster routing policy.
  public var singleClusterRouting: Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting {
    get {
      if case .singleClusterRouting(let v)? = routingPolicy {return v}
      return Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting()
    }
    set {routingPolicy = .singleClusterRouting(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The routing policy for all read/write requests that use this app profile.
  /// A value must be explicitly set.
  public enum OneOf_RoutingPolicy: Equatable {
    /// Use a multi-cluster routing policy.
    case multiClusterRoutingUseAny(Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny)
    /// Use a single-cluster routing policy.
    case singleClusterRouting(Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_V2_AppProfile.OneOf_RoutingPolicy, rhs: Google_Bigtable_Admin_V2_AppProfile.OneOf_RoutingPolicy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.multiClusterRoutingUseAny, .multiClusterRoutingUseAny): return {
        guard case .multiClusterRoutingUseAny(let l) = lhs, case .multiClusterRoutingUseAny(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.singleClusterRouting, .singleClusterRouting): return {
        guard case .singleClusterRouting(let l) = lhs, case .singleClusterRouting(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Read/write requests are routed to the nearest cluster in the instance, and
  /// will fail over to the nearest cluster that is available in the event of
  /// transient errors or delays. Clusters in a region are considered
  /// equidistant. Choosing this option sacrifices read-your-writes consistency
  /// to improve availability.
  public struct MultiClusterRoutingUseAny {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Unconditionally routes all read/write requests to a specific cluster.
  /// This option preserves read-your-writes consistency but does not improve
  /// availability.
  public struct SingleClusterRouting {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The cluster to which read/write requests should be routed.
    public var clusterID: String = String()

    /// Whether or not `CheckAndMutateRow` and `ReadModifyWriteRow` requests are
    /// allowed by this app profile. It is unsafe to send these requests to
    /// the same table/row/column in multiple clusters.
    public var allowTransactionalWrites: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.admin.v2"

extension Google_Bigtable_Admin_V2_Instance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "state"),
    4: .same(proto: "type"),
    5: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if self.state != .notKnown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_Instance, rhs: Google_Bigtable_Admin_V2_Instance) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.state != rhs.state {return false}
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Instance.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_NOT_KNOWN"),
    1: .same(proto: "READY"),
    2: .same(proto: "CREATING"),
  ]
}

extension Google_Bigtable_Admin_V2_Instance.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "PRODUCTION"),
    2: .same(proto: "DEVELOPMENT"),
  ]
}

extension Google_Bigtable_Admin_V2_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "location"),
    3: .same(proto: "state"),
    4: .standard(proto: "serve_nodes"),
    5: .standard(proto: "default_storage_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.serveNodes) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.defaultStorageType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 2)
    }
    if self.state != .notKnown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if self.serveNodes != 0 {
      try visitor.visitSingularInt32Field(value: self.serveNodes, fieldNumber: 4)
    }
    if self.defaultStorageType != .unspecified {
      try visitor.visitSingularEnumField(value: self.defaultStorageType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_Cluster, rhs: Google_Bigtable_Admin_V2_Cluster) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.location != rhs.location {return false}
    if lhs.state != rhs.state {return false}
    if lhs.serveNodes != rhs.serveNodes {return false}
    if lhs.defaultStorageType != rhs.defaultStorageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_Cluster.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_NOT_KNOWN"),
    1: .same(proto: "READY"),
    2: .same(proto: "CREATING"),
    3: .same(proto: "RESIZING"),
    4: .same(proto: "DISABLED"),
  ]
}

extension Google_Bigtable_Admin_V2_AppProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AppProfile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "etag"),
    3: .same(proto: "description"),
    5: .standard(proto: "multi_cluster_routing_use_any"),
    6: .standard(proto: "single_cluster_routing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.etag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try {
        var v: Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny?
        if let current = self.routingPolicy {
          try decoder.handleConflictingOneOf()
          if case .multiClusterRoutingUseAny(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.routingPolicy = .multiClusterRoutingUseAny(v)}
      }()
      case 6: try {
        var v: Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting?
        if let current = self.routingPolicy {
          try decoder.handleConflictingOneOf()
          if case .singleClusterRouting(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.routingPolicy = .singleClusterRouting(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularStringField(value: self.etag, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.routingPolicy {
    case .multiClusterRoutingUseAny?: try {
      guard case .multiClusterRoutingUseAny(let v)? = self.routingPolicy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .singleClusterRouting?: try {
      guard case .singleClusterRouting(let v)? = self.routingPolicy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_AppProfile, rhs: Google_Bigtable_Admin_V2_AppProfile) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.routingPolicy != rhs.routingPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_AppProfile.protoMessageName + ".MultiClusterRoutingUseAny"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny, rhs: Google_Bigtable_Admin_V2_AppProfile.MultiClusterRoutingUseAny) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_AppProfile.protoMessageName + ".SingleClusterRouting"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cluster_id"),
    2: .standard(proto: "allow_transactional_writes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allowTransactionalWrites) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 1)
    }
    if self.allowTransactionalWrites != false {
      try visitor.visitSingularBoolField(value: self.allowTransactionalWrites, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting, rhs: Google_Bigtable_Admin_V2_AppProfile.SingleClusterRouting) -> Bool {
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.allowTransactionalWrites != rhs.allowTransactionalWrites {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

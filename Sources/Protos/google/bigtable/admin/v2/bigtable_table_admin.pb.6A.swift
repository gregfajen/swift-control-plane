// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/admin/v2/bigtable_table_admin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for
/// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable].
public struct Google_Bigtable_Admin_V2_RestoreTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the instance in which to create the restored
  /// table. This instance must be the parent of the source backup. Values are
  /// of the form `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// Required. The id of the table to create and restore to. This
  /// table must not already exist. The `table_id` appended to
  /// `parent` forms the full table name of the form
  /// `projects/<project>/instances/<instance>/tables/<table_id>`.
  public var tableID: String = String()

  /// Required. The source from which to restore.
  public var source: Google_Bigtable_Admin_V2_RestoreTableRequest.OneOf_Source? = nil

  /// Name of the backup from which to restore.  Values are of the form
  /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
  public var backup: String {
    get {
      if case .backup(let v)? = source {return v}
      return String()
    }
    set {source = .backup(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The source from which to restore.
  public enum OneOf_Source: Equatable {
    /// Name of the backup from which to restore.  Values are of the form
    /// `projects/<project>/instances/<instance>/clusters/<cluster>/backups/<backup>`.
    case backup(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_V2_RestoreTableRequest.OneOf_Source, rhs: Google_Bigtable_Admin_V2_RestoreTableRequest.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.backup, .backup): return {
        guard case .backup(let l) = lhs, case .backup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Metadata type for the long-running operation returned by
/// [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable].
public struct Google_Bigtable_Admin_V2_RestoreTableMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the table being created and restored to.
  public var name: String = String()

  /// The type of the restore source.
  public var sourceType: Google_Bigtable_Admin_V2_RestoreSourceType = .unspecified

  /// Information about the source used to restore the table, as specified by
  /// `source` in [RestoreTableRequest][google.bigtable.admin.v2.RestoreTableRequest].
  public var sourceInfo: Google_Bigtable_Admin_V2_RestoreTableMetadata.OneOf_SourceInfo? = nil

  public var backupInfo: Google_Bigtable_Admin_V2_BackupInfo {
    get {
      if case .backupInfo(let v)? = sourceInfo {return v}
      return Google_Bigtable_Admin_V2_BackupInfo()
    }
    set {sourceInfo = .backupInfo(newValue)}
  }

  /// If exists, the name of the long-running operation that will be used to
  /// track the post-restore optimization process to optimize the performance of
  /// the restored table. The metadata type of the long-running operation is
  /// [OptimizeRestoreTableMetadata][]. The response type is
  /// [Empty][google.protobuf.Empty]. This long-running operation may be
  /// automatically created by the system if applicable after the
  /// RestoreTable long-running operation completes successfully. This operation
  /// may not be created if the table is already optimized or the restore was
  /// not successful.
  public var optimizeTableOperationName: String = String()

  /// The progress of the [RestoreTable][google.bigtable.admin.v2.BigtableTableAdmin.RestoreTable]
  /// operation.
  public var progress: Google_Bigtable_Admin_V2_OperationProgress {
    get {return _progress ?? Google_Bigtable_Admin_V2_OperationProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information about the source used to restore the table, as specified by
  /// `source` in [RestoreTableRequest][google.bigtable.admin.v2.RestoreTableRequest].
  public enum OneOf_SourceInfo: Equatable {
    case backupInfo(Google_Bigtable_Admin_V2_BackupInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_V2_RestoreTableMetadata.OneOf_SourceInfo, rhs: Google_Bigtable_Admin_V2_RestoreTableMetadata.OneOf_SourceInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.backupInfo, .backupInfo): return {
        guard case .backupInfo(let l) = lhs, case .backupInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _progress: Google_Bigtable_Admin_V2_OperationProgress? = nil
}

/// Metadata type for the long-running operation used to track the progress
/// of optimizations performed on a newly restored table. This long-running
/// operation is automatically created by the system after the successful
/// completion of a table restore, and cannot be cancelled.
public struct Google_Bigtable_Admin_V2_OptimizeRestoredTableMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the restored table being optimized.
  public var name: String = String()

  /// The progress of the post-restore optimizations.
  public var progress: Google_Bigtable_Admin_V2_OperationProgress {
    get {return _progress ?? Google_Bigtable_Admin_V2_OperationProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _progress: Google_Bigtable_Admin_V2_OperationProgress? = nil
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTable][google.bigtable.admin.v2.BigtableTableAdmin.CreateTable]
public struct Google_Bigtable_Admin_V2_CreateTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the instance in which to create the table.
  /// Values are of the form `projects/{project}/instances/{instance}`.
  public var parent: String = String()

  /// Required. The name by which the new table should be referred to within the parent
  /// instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
  /// Maximum 50 characters.
  public var tableID: String = String()

  /// Required. The Table to create.
  public var table: Google_Bigtable_Admin_V2_Table {
    get {return _table ?? Google_Bigtable_Admin_V2_Table()}
    set {_table = newValue}
  }
  /// Returns true if `table` has been explicitly set.
  public var hasTable: Bool {return self._table != nil}
  /// Clears the value of `table`. Subsequent reads from it will return its default value.
  public mutating func clearTable() {self._table = nil}

  /// The optional list of row keys that will be used to initially split the
  /// table into several tablets (tablets are similar to HBase regions).
  /// Given two split keys, `s1` and `s2`, three tablets will be created,
  /// spanning the key ranges: `[, s1), [s1, s2), [s2, )`.
  ///
  /// Example:
  ///
  /// * Row keys := `["a", "apple", "custom", "customer_1", "customer_2",`
  ///                `"other", "zz"]`
  /// * initial_split_keys := `["apple", "customer_1", "customer_2", "other"]`
  /// * Key assignment:
  ///     - Tablet 1 `[, apple)                => {"a"}.`
  ///     - Tablet 2 `[apple, customer_1)      => {"apple", "custom"}.`
  ///     - Tablet 3 `[customer_1, customer_2) => {"customer_1"}.`
  ///     - Tablet 4 `[customer_2, other)      => {"customer_2"}.`
  ///     - Tablet 5 `[other, )                => {"other", "zz"}.`
  public var initialSplits: [Google_Bigtable_Admin_V2_CreateTableRequest.Split] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An initial split point for a newly created table.
  public struct Split {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Row key to use as an initial tablet boundary.
    public var key: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _table: Google_Bigtable_Admin_V2_Table? = nil
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.CreateTableFromSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the instance in which to create the table.
  /// Values are of the form `projects/{project}/instances/{instance}`.
  public var parent: String = String()

  /// Required. The name by which the new table should be referred to within the parent
  /// instance, e.g., `foobar` rather than `{parent}/tables/foobar`.
  public var tableID: String = String()

  /// Required. The unique name of the snapshot from which to restore the table. The
  /// snapshot and the table must be in the same instance.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
  public var sourceSnapshot: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange][google.bigtable.admin.v2.BigtableTableAdmin.DropRowRange]
public struct Google_Bigtable_Admin_V2_DropRowRangeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table on which to drop a range of rows.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  /// Delete all rows or by prefix.
  public var target: Google_Bigtable_Admin_V2_DropRowRangeRequest.OneOf_Target? = nil

  /// Delete all rows that start with this row key prefix. Prefix cannot be
  /// zero length.
  public var rowKeyPrefix: Data {
    get {
      if case .rowKeyPrefix(let v)? = target {return v}
      return Data()
    }
    set {target = .rowKeyPrefix(newValue)}
  }

  /// Delete all rows in the table. Setting this to false is a no-op.
  public var deleteAllDataFromTable: Bool {
    get {
      if case .deleteAllDataFromTable(let v)? = target {return v}
      return false
    }
    set {target = .deleteAllDataFromTable(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Delete all rows or by prefix.
  public enum OneOf_Target: Equatable {
    /// Delete all rows that start with this row key prefix. Prefix cannot be
    /// zero length.
    case rowKeyPrefix(Data)
    /// Delete all rows in the table. Setting this to false is a no-op.
    case deleteAllDataFromTable(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_V2_DropRowRangeRequest.OneOf_Target, rhs: Google_Bigtable_Admin_V2_DropRowRangeRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rowKeyPrefix, .rowKeyPrefix): return {
        guard case .rowKeyPrefix(let l) = lhs, case .rowKeyPrefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteAllDataFromTable, .deleteAllDataFromTable): return {
        guard case .deleteAllDataFromTable(let l) = lhs, case .deleteAllDataFromTable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables][google.bigtable.admin.v2.BigtableTableAdmin.ListTables]
public struct Google_Bigtable_Admin_V2_ListTablesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the instance for which tables should be listed.
  /// Values are of the form `projects/{project}/instances/{instance}`.
  public var parent: String = String()

  /// The view to be applied to the returned tables' fields.
  /// Only NAME_ONLY view (default) and REPLICATION_VIEW are supported.
  public var view: Google_Bigtable_Admin_V2_Table.View = .unspecified

  /// Maximum number of results per page.
  ///
  /// A page_size of zero lets the server choose the number of items to return.
  /// A page_size which is strictly positive will return at most that many items.
  /// A negative page_size will cause an error.
  ///
  /// Following the first request, subsequent paginated calls are not required
  /// to pass a page_size. If a page_size is set in subsequent calls, it must
  /// match the page_size given in the first request.
  public var pageSize: Int32 = 0

  /// The value of `next_page_token` returned by a previous call.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListTables][google.bigtable.admin.v2.BigtableTableAdmin.ListTables]
public struct Google_Bigtable_Admin_V2_ListTablesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tables present in the requested instance.
  public var tables: [Google_Bigtable_Admin_V2_Table] = []

  /// Set if not all tables could be returned in a single response.
  /// Pass this value to `page_token` in another request to get the next
  /// page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetTable][google.bigtable.admin.v2.BigtableTableAdmin.GetTable]
public struct Google_Bigtable_Admin_V2_GetTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the requested table.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  /// The view to be applied to the returned table's fields.
  /// Defaults to `SCHEMA_VIEW` if unspecified.
  public var view: Google_Bigtable_Admin_V2_Table.View = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable][google.bigtable.admin.v2.BigtableTableAdmin.DeleteTable]
public struct Google_Bigtable_Admin_V2_DeleteTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table to be deleted.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies][google.bigtable.admin.v2.BigtableTableAdmin.ModifyColumnFamilies]
public struct Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table whose families should be modified.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  /// Required. Modifications to be atomically applied to the specified table's families.
  /// Entries are applied in order, meaning that earlier modifications can be
  /// masked by later ones (in the case of repeated updates to the same family,
  /// for example).
  public var modifications: [Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A create, update, or delete of a particular column family.
  public struct Modification {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the column family to be modified.
    public var id: String = String()

    /// Column familiy modifications.
    public var mod: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification.OneOf_Mod? = nil

    /// Create a new column family with the specified schema, or fail if
    /// one already exists with the given ID.
    public var create: Google_Bigtable_Admin_V2_ColumnFamily {
      get {
        if case .create(let v)? = mod {return v}
        return Google_Bigtable_Admin_V2_ColumnFamily()
      }
      set {mod = .create(newValue)}
    }

    /// Update an existing column family to the specified schema, or fail
    /// if no column family exists with the given ID.
    public var update: Google_Bigtable_Admin_V2_ColumnFamily {
      get {
        if case .update(let v)? = mod {return v}
        return Google_Bigtable_Admin_V2_ColumnFamily()
      }
      set {mod = .update(newValue)}
    }

    /// Drop (delete) the column family with the given ID, or fail if no such
    /// family exists.
    public var drop: Bool {
      get {
        if case .drop(let v)? = mod {return v}
        return false
      }
      set {mod = .drop(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Column familiy modifications.
    public enum OneOf_Mod: Equatable {
      /// Create a new column family with the specified schema, or fail if
      /// one already exists with the given ID.
      case create(Google_Bigtable_Admin_V2_ColumnFamily)
      /// Update an existing column family to the specified schema, or fail
      /// if no column family exists with the given ID.
      case update(Google_Bigtable_Admin_V2_ColumnFamily)
      /// Drop (delete) the column family with the given ID, or fail if no such
      /// family exists.
      case drop(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification.OneOf_Mod, rhs: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification.OneOf_Mod) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.create, .create): return {
          guard case .create(let l) = lhs, case .create(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.update, .update): return {
          guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.drop, .drop): return {
          guard case .drop(let l) = lhs, case .drop(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken][google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]
public struct Google_Bigtable_Admin_V2_GenerateConsistencyTokenRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the Table for which to create a consistency token.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken][google.bigtable.admin.v2.BigtableTableAdmin.GenerateConsistencyToken]
public struct Google_Bigtable_Admin_V2_GenerateConsistencyTokenResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The generated consistency token.
  public var consistencyToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency][google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]
public struct Google_Bigtable_Admin_V2_CheckConsistencyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the Table for which to check replication consistency.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  /// Required. The token created using GenerateConsistencyToken for the Table.
  public var consistencyToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency][google.bigtable.admin.v2.BigtableTableAdmin.CheckConsistency]
public struct Google_Bigtable_Admin_V2_CheckConsistencyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True only if the token is consistent. A token is consistent if replication
  /// has caught up with the restrictions specified in the request.
  public var consistent: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable][google.bigtable.admin.v2.BigtableTableAdmin.SnapshotTable]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_SnapshotTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the table to have the snapshot taken.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/tables/{table}`.
  public var name: String = String()

  /// Required. The name of the cluster where the snapshot will be created in.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
  public var cluster: String = String()

  /// Required. The ID by which the new snapshot should be referred to within the parent
  /// cluster, e.g., `mysnapshot` of the form: `[_a-zA-Z0-9][-_.a-zA-Z0-9]*`
  /// rather than
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/mysnapshot`.
  public var snapshotID: String = String()

  /// The amount of time that the new snapshot can stay active after it is
  /// created. Once 'ttl' expires, the snapshot will get deleted. The maximum
  /// amount of time a snapshot can stay active is 7 days. If 'ttl' is not
  /// specified, the default value of 24 hours will be used.
  public var ttl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _ttl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_ttl = newValue}
  }
  /// Returns true if `ttl` has been explicitly set.
  public var hasTtl: Bool {return self._ttl != nil}
  /// Clears the value of `ttl`. Subsequent reads from it will return its default value.
  public mutating func clearTtl() {self._ttl = nil}

  /// Description of the snapshot.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _ttl: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.GetSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_GetSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the requested snapshot.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots][google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_ListSnapshotsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the cluster for which snapshots should be listed.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}`.
  /// Use `{cluster} = '-'` to list snapshots for all clusters in an instance,
  /// e.g., `projects/{project}/instances/{instance}/clusters/-`.
  public var parent: String = String()

  /// The maximum number of snapshots to return per page.
  /// CURRENTLY UNIMPLEMENTED AND IGNORED.
  public var pageSize: Int32 = 0

  /// The value of `next_page_token` returned by a previous call.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots][google.bigtable.admin.v2.BigtableTableAdmin.ListSnapshots]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_ListSnapshotsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The snapshots present in the requested cluster.
  public var snapshots: [Google_Bigtable_Admin_V2_Snapshot] = []

  /// Set if not all snapshots could be returned in a single response.
  /// Pass this value to `page_token` in another request to get the next
  /// page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for
/// [google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot][google.bigtable.admin.v2.BigtableTableAdmin.DeleteSnapshot]
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_DeleteSnapshotRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The unique name of the snapshot to be deleted.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/snapshots/{snapshot}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The metadata for the Operation returned by SnapshotTable.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_SnapshotTableMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request that prompted the initiation of this SnapshotTable operation.
  public var originalRequest: Google_Bigtable_Admin_V2_SnapshotTableRequest {
    get {return _originalRequest ?? Google_Bigtable_Admin_V2_SnapshotTableRequest()}
    set {_originalRequest = newValue}
  }
  /// Returns true if `originalRequest` has been explicitly set.
  public var hasOriginalRequest: Bool {return self._originalRequest != nil}
  /// Clears the value of `originalRequest`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalRequest() {self._originalRequest = nil}

  /// The time at which the original request was received.
  public var requestTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _requestTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_requestTime = newValue}
  }
  /// Returns true if `requestTime` has been explicitly set.
  public var hasRequestTime: Bool {return self._requestTime != nil}
  /// Clears the value of `requestTime`. Subsequent reads from it will return its default value.
  public mutating func clearRequestTime() {self._requestTime = nil}

  /// The time at which the operation failed or was completed successfully.
  public var finishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _finishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_finishTime = newValue}
  }
  /// Returns true if `finishTime` has been explicitly set.
  public var hasFinishTime: Bool {return self._finishTime != nil}
  /// Clears the value of `finishTime`. Subsequent reads from it will return its default value.
  public mutating func clearFinishTime() {self._finishTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalRequest: Google_Bigtable_Admin_V2_SnapshotTableRequest? = nil
  fileprivate var _requestTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _finishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The metadata for the Operation returned by CreateTableFromSnapshot.
///
/// Note: This is a private alpha release of Cloud Bigtable snapshots. This
/// feature is not currently available to most Cloud Bigtable customers. This
/// feature might be changed in backward-incompatible ways and is not recommended
/// for production use. It is not subject to any SLA or deprecation policy.
public struct Google_Bigtable_Admin_V2_CreateTableFromSnapshotMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request that prompted the initiation of this CreateTableFromSnapshot
  /// operation.
  public var originalRequest: Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest {
    get {return _originalRequest ?? Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest()}
    set {_originalRequest = newValue}
  }
  /// Returns true if `originalRequest` has been explicitly set.
  public var hasOriginalRequest: Bool {return self._originalRequest != nil}
  /// Clears the value of `originalRequest`. Subsequent reads from it will return its default value.
  public mutating func clearOriginalRequest() {self._originalRequest = nil}

  /// The time at which the original request was received.
  public var requestTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _requestTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_requestTime = newValue}
  }
  /// Returns true if `requestTime` has been explicitly set.
  public var hasRequestTime: Bool {return self._requestTime != nil}
  /// Clears the value of `requestTime`. Subsequent reads from it will return its default value.
  public mutating func clearRequestTime() {self._requestTime = nil}

  /// The time at which the operation failed or was completed successfully.
  public var finishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _finishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_finishTime = newValue}
  }
  /// Returns true if `finishTime` has been explicitly set.
  public var hasFinishTime: Bool {return self._finishTime != nil}
  /// Clears the value of `finishTime`. Subsequent reads from it will return its default value.
  public mutating func clearFinishTime() {self._finishTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _originalRequest: Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest? = nil
  fileprivate var _requestTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _finishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup].
public struct Google_Bigtable_Admin_V2_CreateBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. This must be one of the clusters in the instance in which this
  /// table is located. The backup will be stored in this cluster. Values are
  /// of the form `projects/{project}/instances/{instance}/clusters/{cluster}`.
  public var parent: String = String()

  /// Required. The id of the backup to be created. The `backup_id` along with
  /// the parent `parent` are combined as {parent}/backups/{backup_id} to create
  /// the full backup name, of the form:
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup_id}`.
  /// This string must be between 1 and 50 characters in length and match the
  /// regex [_a-zA-Z0-9][-_.a-zA-Z0-9]*.
  public var backupID: String = String()

  /// Required. The backup to create.
  public var backup: Google_Bigtable_Admin_V2_Backup {
    get {return _backup ?? Google_Bigtable_Admin_V2_Backup()}
    set {_backup = newValue}
  }
  /// Returns true if `backup` has been explicitly set.
  public var hasBackup: Bool {return self._backup != nil}
  /// Clears the value of `backup`. Subsequent reads from it will return its default value.
  public mutating func clearBackup() {self._backup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _backup: Google_Bigtable_Admin_V2_Backup? = nil
}

/// Metadata type for the operation returned by
/// [CreateBackup][google.bigtable.admin.v2.BigtableTableAdmin.CreateBackup].
public struct Google_Bigtable_Admin_V2_CreateBackupMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the backup being created.
  public var name: String = String()

  /// The name of the table the backup is created from.
  public var sourceTable: String = String()

  /// The time at which this operation started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// If set, the time at which this operation finished or was cancelled.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [UpdateBackup][google.bigtable.admin.v2.BigtableTableAdmin.UpdateBackup].
public struct Google_Bigtable_Admin_V2_UpdateBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The backup to update. `backup.name`, and the fields to be updated
  /// as specified by `update_mask` are required. Other fields are ignored.
  /// Update is only supported for the following fields:
  ///  * `backup.expire_time`.
  public var backup: Google_Bigtable_Admin_V2_Backup {
    get {return _backup ?? Google_Bigtable_Admin_V2_Backup()}
    set {_backup = newValue}
  }
  /// Returns true if `backup` has been explicitly set.
  public var hasBackup: Bool {return self._backup != nil}
  /// Clears the value of `backup`. Subsequent reads from it will return its default value.
  public mutating func clearBackup() {self._backup = nil}

  /// Required. A mask specifying which fields (e.g. `expire_time`) in the
  /// Backup resource should be updated. This mask is relative to the Backup
  /// resource, not to the request message. The field mask must always be
  /// specified; this prevents any future fields from being erased accidentally
  /// by clients that do not know about them.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _backup: Google_Bigtable_Admin_V2_Backup? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request for [GetBackup][google.bigtable.admin.v2.BigtableTableAdmin.GetBackup].
public struct Google_Bigtable_Admin_V2_GetBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the backup.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [DeleteBackup][google.bigtable.admin.v2.BigtableTableAdmin.DeleteBackup].
public struct Google_Bigtable_Admin_V2_DeleteBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the backup to delete.
  /// Values are of the form
  /// `projects/{project}/instances/{instance}/clusters/{cluster}/backups/{backup}`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups].
public struct Google_Bigtable_Admin_V2_ListBackupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The cluster to list backups from.  Values are of the
  /// form `projects/{project}/instances/{instance}/clusters/{cluster}`.
  /// Use `{cluster} = '-'` to list backups for all clusters in an instance,
  /// e.g., `projects/{project}/instances/{instance}/clusters/-`.
  public var parent: String = String()

  /// A filter expression that filters backups listed in the response.
  /// The expression must specify the field name, a comparison operator,
  /// and the value that you want to use for filtering. The value must be a
  /// string, a number, or a boolean. The comparison operator must be
  /// <, >, <=, >=, !=, =, or :. Colon ':' represents a HAS operator which is
  /// roughly synonymous with equality. Filter rules are case insensitive.
  ///
  /// The fields eligible for filtering are:
  ///   * `name`
  ///   * `source_table`
  ///   * `state`
  ///   * `start_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
  ///   * `end_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
  ///   * `expire_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
  ///   * `size_bytes`
  ///
  /// To filter on multiple expressions, provide each separate expression within
  /// parentheses. By default, each expression is an AND expression. However,
  /// you can include AND, OR, and NOT expressions explicitly.
  ///
  /// Some examples of using filters are:
  ///
  ///   * `name:"exact"` --> The backup's name is the string "exact".
  ///   * `name:howl` --> The backup's name contains the string "howl".
  ///   * `source_table:prod`
  ///          --> The source_table's name contains the string "prod".
  ///   * `state:CREATING` --> The backup is pending creation.
  ///   * `state:READY` --> The backup is fully created and ready for use.
  ///   * `(name:howl) AND (start_time < \"2018-03-28T14:50:00Z\")`
  ///          --> The backup name contains the string "howl" and start_time
  ///              of the backup is before 2018-03-28T14:50:00Z.
  ///   * `size_bytes > 10000000000` --> The backup's size is greater than 10GB
  public var filter: String = String()

  /// An expression for specifying the sort order of the results of the request.
  /// The string value should specify one or more fields in [Backup][google.bigtable.admin.v2.Backup]. The full
  /// syntax is described at https://aip.dev/132#ordering.
  ///
  /// Fields supported are:
  ///    * name
  ///    * source_table
  ///    * expire_time
  ///    * start_time
  ///    * end_time
  ///    * size_bytes
  ///    * state
  ///
  /// For example, "start_time". The default sorting order is ascending.
  /// To specify descending order for the field, a suffix " desc" should
  /// be appended to the field name. For example, "start_time desc".
  /// Redundant space characters in the syntax are insigificant.
  ///
  /// If order_by is empty, results will be sorted by `start_time` in descending
  /// order starting from the most recently created backup.
  public var orderBy: String = String()

  /// Number of backups to be returned in the response. If 0 or
  /// less, defaults to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.bigtable.admin.v2.ListBackupsResponse.next_page_token] from a
  /// previous [ListBackupsResponse][google.bigtable.admin.v2.ListBackupsResponse] to the same `parent` and with the same
  /// `filter`.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups].
public struct Google_Bigtable_Admin_V2_ListBackupsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching backups.
  public var backups: [Google_Bigtable_Admin_V2_Backup] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListBackups][google.bigtable.admin.v2.BigtableTableAdmin.ListBackups] call to fetch more
  /// of the matching backups.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.admin.v2"

extension Google_Bigtable_Admin_V2_RestoreTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "table_id"),
    3: .same(proto: "backup"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tableID) }()
      case 3: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .backup(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.tableID.isEmpty {
      try visitor.visitSingularStringField(value: self.tableID, fieldNumber: 2)
    }
    if case .backup(let v)? = self.source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_RestoreTableRequest, rhs: Google_Bigtable_Admin_V2_RestoreTableRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.tableID != rhs.tableID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_RestoreTableMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreTableMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "source_type"),
    3: .standard(proto: "backup_info"),
    4: .standard(proto: "optimize_table_operation_name"),
    5: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      case 3: try {
        var v: Google_Bigtable_Admin_V2_BackupInfo?
        if let current = self.sourceInfo {
          try decoder.handleConflictingOneOf()
          if case .backupInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sourceInfo = .backupInfo(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.optimizeTableOperationName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.sourceType != .unspecified {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 2)
    }
    if case .backupInfo(let v)? = self.sourceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.optimizeTableOperationName.isEmpty {
      try visitor.visitSingularStringField(value: self.optimizeTableOperationName, fieldNumber: 4)
    }
    if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_RestoreTableMetadata, rhs: Google_Bigtable_Admin_V2_RestoreTableMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.sourceInfo != rhs.sourceInfo {return false}
    if lhs.optimizeTableOperationName != rhs.optimizeTableOperationName {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_OptimizeRestoredTableMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptimizeRestoredTableMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_OptimizeRestoredTableMetadata, rhs: Google_Bigtable_Admin_V2_OptimizeRestoredTableMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CreateTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "table_id"),
    3: .same(proto: "table"),
    4: .standard(proto: "initial_splits"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tableID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._table) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.initialSplits) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.tableID.isEmpty {
      try visitor.visitSingularStringField(value: self.tableID, fieldNumber: 2)
    }
    if let v = self._table {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.initialSplits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initialSplits, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CreateTableRequest, rhs: Google_Bigtable_Admin_V2_CreateTableRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.tableID != rhs.tableID {return false}
    if lhs._table != rhs._table {return false}
    if lhs.initialSplits != rhs.initialSplits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CreateTableRequest.Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_CreateTableRequest.protoMessageName + ".Split"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CreateTableRequest.Split, rhs: Google_Bigtable_Admin_V2_CreateTableRequest.Split) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTableFromSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "table_id"),
    3: .standard(proto: "source_snapshot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tableID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceSnapshot) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.tableID.isEmpty {
      try visitor.visitSingularStringField(value: self.tableID, fieldNumber: 2)
    }
    if !self.sourceSnapshot.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceSnapshot, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest, rhs: Google_Bigtable_Admin_V2_CreateTableFromSnapshotRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.tableID != rhs.tableID {return false}
    if lhs.sourceSnapshot != rhs.sourceSnapshot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_DropRowRangeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DropRowRangeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "row_key_prefix"),
    3: .standard(proto: "delete_all_data_from_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.target = .rowKeyPrefix(v)}
      }()
      case 3: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.target = .deleteAllDataFromTable(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .rowKeyPrefix?: try {
      guard case .rowKeyPrefix(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .deleteAllDataFromTable?: try {
      guard case .deleteAllDataFromTable(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_DropRowRangeRequest, rhs: Google_Bigtable_Admin_V2_DropRowRangeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ListTablesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTablesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "view"),
    4: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.view != .unspecified {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ListTablesRequest, rhs: Google_Bigtable_Admin_V2_ListTablesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.view != rhs.view {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ListTablesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTablesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tables"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tables) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tables, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ListTablesResponse, rhs: Google_Bigtable_Admin_V2_ListTablesResponse) -> Bool {
    if lhs.tables != rhs.tables {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GetTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "view"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.view != .unspecified {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GetTableRequest, rhs: Google_Bigtable_Admin_V2_GetTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.view != rhs.view {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_DeleteTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_DeleteTableRequest, rhs: Google_Bigtable_Admin_V2_DeleteTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ModifyColumnFamiliesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "modifications"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modifications) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.modifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modifications, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest, rhs: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.modifications != rhs.modifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.protoMessageName + ".Modification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "create"),
    3: .same(proto: "update"),
    4: .same(proto: "drop"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try {
        var v: Google_Bigtable_Admin_V2_ColumnFamily?
        if let current = self.mod {
          try decoder.handleConflictingOneOf()
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mod = .create(v)}
      }()
      case 3: try {
        var v: Google_Bigtable_Admin_V2_ColumnFamily?
        if let current = self.mod {
          try decoder.handleConflictingOneOf()
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mod = .update(v)}
      }()
      case 4: try {
        if self.mod != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.mod = .drop(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.mod {
    case .create?: try {
      guard case .create(let v)? = self.mod else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .update?: try {
      guard case .update(let v)? = self.mod else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .drop?: try {
      guard case .drop(let v)? = self.mod else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification, rhs: Google_Bigtable_Admin_V2_ModifyColumnFamiliesRequest.Modification) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.mod != rhs.mod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GenerateConsistencyTokenRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateConsistencyTokenRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GenerateConsistencyTokenRequest, rhs: Google_Bigtable_Admin_V2_GenerateConsistencyTokenRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GenerateConsistencyTokenResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenerateConsistencyTokenResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consistency_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.consistencyToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.consistencyToken.isEmpty {
      try visitor.visitSingularStringField(value: self.consistencyToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GenerateConsistencyTokenResponse, rhs: Google_Bigtable_Admin_V2_GenerateConsistencyTokenResponse) -> Bool {
    if lhs.consistencyToken != rhs.consistencyToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CheckConsistencyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckConsistencyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "consistency_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.consistencyToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.consistencyToken.isEmpty {
      try visitor.visitSingularStringField(value: self.consistencyToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CheckConsistencyRequest, rhs: Google_Bigtable_Admin_V2_CheckConsistencyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.consistencyToken != rhs.consistencyToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CheckConsistencyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CheckConsistencyResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "consistent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.consistent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.consistent != false {
      try visitor.visitSingularBoolField(value: self.consistent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CheckConsistencyResponse, rhs: Google_Bigtable_Admin_V2_CheckConsistencyResponse) -> Bool {
    if lhs.consistent != rhs.consistent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_SnapshotTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SnapshotTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "cluster"),
    3: .standard(proto: "snapshot_id"),
    4: .same(proto: "ttl"),
    5: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cluster) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.snapshotID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ttl) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.cluster.isEmpty {
      try visitor.visitSingularStringField(value: self.cluster, fieldNumber: 2)
    }
    if !self.snapshotID.isEmpty {
      try visitor.visitSingularStringField(value: self.snapshotID, fieldNumber: 3)
    }
    if let v = self._ttl {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_SnapshotTableRequest, rhs: Google_Bigtable_Admin_V2_SnapshotTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.cluster != rhs.cluster {return false}
    if lhs.snapshotID != rhs.snapshotID {return false}
    if lhs._ttl != rhs._ttl {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GetSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GetSnapshotRequest, rhs: Google_Bigtable_Admin_V2_GetSnapshotRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ListSnapshotsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSnapshotsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ListSnapshotsRequest, rhs: Google_Bigtable_Admin_V2_ListSnapshotsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ListSnapshotsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSnapshotsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.snapshots) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.snapshots, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ListSnapshotsResponse, rhs: Google_Bigtable_Admin_V2_ListSnapshotsResponse) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_DeleteSnapshotRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteSnapshotRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_DeleteSnapshotRequest, rhs: Google_Bigtable_Admin_V2_DeleteSnapshotRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_SnapshotTableMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SnapshotTableMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_request"),
    2: .standard(proto: "request_time"),
    3: .standard(proto: "finish_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requestTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finishTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._originalRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._requestTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._finishTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_SnapshotTableMetadata, rhs: Google_Bigtable_Admin_V2_SnapshotTableMetadata) -> Bool {
    if lhs._originalRequest != rhs._originalRequest {return false}
    if lhs._requestTime != rhs._requestTime {return false}
    if lhs._finishTime != rhs._finishTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CreateTableFromSnapshotMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTableFromSnapshotMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_request"),
    2: .standard(proto: "request_time"),
    3: .standard(proto: "finish_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._originalRequest) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requestTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._finishTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._originalRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._requestTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._finishTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CreateTableFromSnapshotMetadata, rhs: Google_Bigtable_Admin_V2_CreateTableFromSnapshotMetadata) -> Bool {
    if lhs._originalRequest != rhs._originalRequest {return false}
    if lhs._requestTime != rhs._requestTime {return false}
    if lhs._finishTime != rhs._finishTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CreateBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "backup_id"),
    3: .same(proto: "backup"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backupID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._backup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.backupID.isEmpty {
      try visitor.visitSingularStringField(value: self.backupID, fieldNumber: 2)
    }
    if let v = self._backup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CreateBackupRequest, rhs: Google_Bigtable_Admin_V2_CreateBackupRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.backupID != rhs.backupID {return false}
    if lhs._backup != rhs._backup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_CreateBackupMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateBackupMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "source_table"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceTable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.sourceTable.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceTable, fieldNumber: 2)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_CreateBackupMetadata, rhs: Google_Bigtable_Admin_V2_CreateBackupMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sourceTable != rhs.sourceTable {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_UpdateBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backup"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._backup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._backup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_UpdateBackupRequest, rhs: Google_Bigtable_Admin_V2_UpdateBackupRequest) -> Bool {
    if lhs._backup != rhs._backup {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_GetBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_GetBackupRequest, rhs: Google_Bigtable_Admin_V2_GetBackupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_DeleteBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_DeleteBackupRequest, rhs: Google_Bigtable_Admin_V2_DeleteBackupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ListBackupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBackupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "order_by"),
    4: .standard(proto: "page_size"),
    5: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 3)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 4)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ListBackupsRequest, rhs: Google_Bigtable_Admin_V2_ListBackupsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_V2_ListBackupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBackupsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backups"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.backups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.backups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.backups, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_V2_ListBackupsResponse, rhs: Google_Bigtable_Admin_V2_ListBackupsResponse) -> Bool {
    if lhs.backups != rhs.backups {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

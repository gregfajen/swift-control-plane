// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/admin/table/v1/bigtable_table_service_messages.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Google_Bigtable_Admin_Table_V1_CreateTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the cluster in which to create the new table.
  public var name: String = String()

  /// The name by which the new table should be referred to within the cluster,
  /// e.g. "foobar" rather than "<cluster_name>/tables/foobar".
  public var tableID: String = String()

  /// The Table to create. The `name` field of the Table and all of its
  /// ColumnFamilies must be left blank, and will be populated in the response.
  public var table: Google_Bigtable_Admin_Table_V1_Table {
    get {return _table ?? Google_Bigtable_Admin_Table_V1_Table()}
    set {_table = newValue}
  }
  /// Returns true if `table` has been explicitly set.
  public var hasTable: Bool {return self._table != nil}
  /// Clears the value of `table`. Subsequent reads from it will return its default value.
  public mutating func clearTable() {self._table = nil}

  /// The optional list of row keys that will be used to initially split the
  /// table into several tablets (Tablets are similar to HBase regions).
  /// Given two split keys, "s1" and "s2", three tablets will be created,
  /// spanning the key ranges: [, s1), [s1, s2), [s2, ).
  ///
  /// Example:
  ///  * Row keys := ["a", "apple", "custom", "customer_1", "customer_2",
  ///                 "other", "zz"]
  ///  * initial_split_keys := ["apple", "customer_1", "customer_2", "other"]
  ///  * Key assignment:
  ///    - Tablet 1 [, apple)                => {"a"}.
  ///    - Tablet 2 [apple, customer_1)      => {"apple", "custom"}.
  ///    - Tablet 3 [customer_1, customer_2) => {"customer_1"}.
  ///    - Tablet 4 [customer_2, other)      => {"customer_2"}.
  ///    - Tablet 5 [other, )                => {"other", "zz"}.
  public var initialSplitKeys: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _table: Google_Bigtable_Admin_Table_V1_Table? = nil
}

public struct Google_Bigtable_Admin_Table_V1_ListTablesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the cluster for which tables should be listed.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Bigtable_Admin_Table_V1_ListTablesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The tables present in the requested cluster.
  /// At present, only the names of the tables are populated.
  public var tables: [Google_Bigtable_Admin_Table_V1_Table] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Bigtable_Admin_Table_V1_GetTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the requested table.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Bigtable_Admin_Table_V1_DeleteTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table to be deleted.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Bigtable_Admin_Table_V1_RenameTableRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The current unique name of the table.
  public var name: String = String()

  /// The new name by which the table should be referred to within its containing
  /// cluster, e.g. "foobar" rather than "<cluster_name>/tables/foobar".
  public var newID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Bigtable_Admin_Table_V1_CreateColumnFamilyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table in which to create the new column family.
  public var name: String = String()

  /// The name by which the new column family should be referred to within the
  /// table, e.g. "foobar" rather than "<table_name>/columnFamilies/foobar".
  public var columnFamilyID: String = String()

  /// The column family to create. The `name` field must be left blank.
  public var columnFamily: Google_Bigtable_Admin_Table_V1_ColumnFamily {
    get {return _columnFamily ?? Google_Bigtable_Admin_Table_V1_ColumnFamily()}
    set {_columnFamily = newValue}
  }
  /// Returns true if `columnFamily` has been explicitly set.
  public var hasColumnFamily: Bool {return self._columnFamily != nil}
  /// Clears the value of `columnFamily`. Subsequent reads from it will return its default value.
  public mutating func clearColumnFamily() {self._columnFamily = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _columnFamily: Google_Bigtable_Admin_Table_V1_ColumnFamily? = nil
}

public struct Google_Bigtable_Admin_Table_V1_DeleteColumnFamilyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the column family to be deleted.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the table on which to perform the bulk delete
  public var tableName: String = String()

  public var target: Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest.OneOf_Target? = nil

  /// Delete all rows that start with this row key prefix. Prefix cannot be
  /// zero length.
  public var rowKeyPrefix: Data {
    get {
      if case .rowKeyPrefix(let v)? = target {return v}
      return Data()
    }
    set {target = .rowKeyPrefix(newValue)}
  }

  /// Delete all rows in the table. Setting this to false is a no-op.
  public var deleteAllDataFromTable: Bool {
    get {
      if case .deleteAllDataFromTable(let v)? = target {return v}
      return false
    }
    set {target = .deleteAllDataFromTable(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Target: Equatable {
    /// Delete all rows that start with this row key prefix. Prefix cannot be
    /// zero length.
    case rowKeyPrefix(Data)
    /// Delete all rows in the table. Setting this to false is a no-op.
    case deleteAllDataFromTable(Bool)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest.OneOf_Target, rhs: Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest.OneOf_Target) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rowKeyPrefix, .rowKeyPrefix): return {
        guard case .rowKeyPrefix(let l) = lhs, case .rowKeyPrefix(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteAllDataFromTable, .deleteAllDataFromTable): return {
        guard case .deleteAllDataFromTable(let l) = lhs, case .deleteAllDataFromTable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.admin.table.v1"

extension Google_Bigtable_Admin_Table_V1_CreateTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "table_id"),
    3: .same(proto: "table"),
    4: .standard(proto: "initial_split_keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tableID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._table) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.initialSplitKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.tableID.isEmpty {
      try visitor.visitSingularStringField(value: self.tableID, fieldNumber: 2)
    }
    if let v = self._table {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.initialSplitKeys.isEmpty {
      try visitor.visitRepeatedStringField(value: self.initialSplitKeys, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_CreateTableRequest, rhs: Google_Bigtable_Admin_Table_V1_CreateTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.tableID != rhs.tableID {return false}
    if lhs._table != rhs._table {return false}
    if lhs.initialSplitKeys != rhs.initialSplitKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_ListTablesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTablesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_ListTablesRequest, rhs: Google_Bigtable_Admin_Table_V1_ListTablesRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_ListTablesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTablesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tables"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.tables) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tables, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_ListTablesResponse, rhs: Google_Bigtable_Admin_Table_V1_ListTablesResponse) -> Bool {
    if lhs.tables != rhs.tables {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_GetTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_GetTableRequest, rhs: Google_Bigtable_Admin_Table_V1_GetTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_DeleteTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_DeleteTableRequest, rhs: Google_Bigtable_Admin_Table_V1_DeleteTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_RenameTableRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameTableRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "new_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.newID.isEmpty {
      try visitor.visitSingularStringField(value: self.newID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_RenameTableRequest, rhs: Google_Bigtable_Admin_Table_V1_RenameTableRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.newID != rhs.newID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_CreateColumnFamilyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateColumnFamilyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "column_family_id"),
    3: .standard(proto: "column_family"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.columnFamilyID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._columnFamily) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.columnFamilyID.isEmpty {
      try visitor.visitSingularStringField(value: self.columnFamilyID, fieldNumber: 2)
    }
    if let v = self._columnFamily {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_CreateColumnFamilyRequest, rhs: Google_Bigtable_Admin_Table_V1_CreateColumnFamilyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.columnFamilyID != rhs.columnFamilyID {return false}
    if lhs._columnFamily != rhs._columnFamily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_DeleteColumnFamilyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteColumnFamilyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_DeleteColumnFamilyRequest, rhs: Google_Bigtable_Admin_Table_V1_DeleteColumnFamilyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BulkDeleteRowsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "table_name"),
    2: .standard(proto: "row_key_prefix"),
    3: .standard(proto: "delete_all_data_from_table"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tableName) }()
      case 2: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.target = .rowKeyPrefix(v)}
      }()
      case 3: try {
        if self.target != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.target = .deleteAllDataFromTable(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tableName.isEmpty {
      try visitor.visitSingularStringField(value: self.tableName, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.target {
    case .rowKeyPrefix?: try {
      guard case .rowKeyPrefix(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .deleteAllDataFromTable?: try {
      guard case .deleteAllDataFromTable(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest, rhs: Google_Bigtable_Admin_Table_V1_BulkDeleteRowsRequest) -> Bool {
    if lhs.tableName != rhs.tableName {return false}
    if lhs.target != rhs.target {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

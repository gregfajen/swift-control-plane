// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/bigtable/admin/table/v1/bigtable_table_data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A collection of user data indexed by row, column, and timestamp.
/// Each table is served using the resources of its parent cluster.
public struct Google_Bigtable_Admin_Table_V1_Table {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier of the form
  /// <cluster_name>/tables/[_a-zA-Z0-9][-_.a-zA-Z0-9]*
  public var name: String = String()

  /// If this Table is in the process of being created, the Operation used to
  /// track its progress. As long as this operation is present, the Table will
  /// not accept any Table Admin or Read/Write requests.
  public var currentOperation: Google_Longrunning_Operation {
    get {return _currentOperation ?? Google_Longrunning_Operation()}
    set {_currentOperation = newValue}
  }
  /// Returns true if `currentOperation` has been explicitly set.
  public var hasCurrentOperation: Bool {return self._currentOperation != nil}
  /// Clears the value of `currentOperation`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentOperation() {self._currentOperation = nil}

  /// The column families configured for this table, mapped by column family id.
  public var columnFamilies: Dictionary<String,Google_Bigtable_Admin_Table_V1_ColumnFamily> = [:]

  /// The granularity (e.g. MILLIS, MICROS) at which timestamps are stored in
  /// this table. Timestamps not matching the granularity will be rejected.
  /// Cannot be changed once the table is created.
  public var granularity: Google_Bigtable_Admin_Table_V1_Table.TimestampGranularity = .millis

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TimestampGranularity: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case millis // = 0
    case UNRECOGNIZED(Int)

    public init() {
      self = .millis
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .millis
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .millis: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _currentOperation: Google_Longrunning_Operation? = nil
}

#if swift(>=4.2)

extension Google_Bigtable_Admin_Table_V1_Table.TimestampGranularity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Bigtable_Admin_Table_V1_Table.TimestampGranularity] = [
    .millis,
  ]
}

#endif  // swift(>=4.2)

/// A set of columns within a table which share a common configuration.
public struct Google_Bigtable_Admin_Table_V1_ColumnFamily {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier of the form <table_name>/columnFamilies/[-_.a-zA-Z0-9]+
  /// The last segment is the same as the "name" field in
  /// google.bigtable.v1.Family.
  public var name: String = String()

  /// Garbage collection expression specified by the following grammar:
  ///   GC = EXPR
  ///      | "" ;
  ///   EXPR = EXPR, "||", EXPR              (* lowest precedence *)
  ///        | EXPR, "&&", EXPR
  ///        | "(", EXPR, ")"                (* highest precedence *)
  ///        | PROP ;
  ///   PROP = "version() >", NUM32
  ///        | "age() >", NUM64, [ UNIT ] ;
  ///   NUM32 = non-zero-digit { digit } ;    (* # NUM32 <= 2^32 - 1 *)
  ///   NUM64 = non-zero-digit { digit } ;    (* # NUM64 <= 2^63 - 1 *)
  ///   UNIT =  "d" | "h" | "m"  (* d=days, h=hours, m=minutes, else micros *)
  /// GC expressions can be up to 500 characters in length
  ///
  /// The different types of PROP are defined as follows:
  ///   version() - cell index, counting from most recent and starting at 1
  ///   age() - age of the cell (current time minus cell timestamp)
  ///
  /// Example: "version() > 3 || (age() > 3d && version() > 1)"
  ///   drop cells beyond the most recent three, and drop cells older than three
  ///   days unless they're the most recent cell in the row/column
  ///
  /// Garbage collection executes opportunistically in the background, and so
  /// it's possible for reads to return a cell even if it matches the active GC
  /// expression for its family.
  public var gcExpression: String = String()

  /// Garbage collection rule specified as a protobuf.
  /// Supersedes `gc_expression`.
  /// Must serialize to at most 500 bytes.
  ///
  /// NOTE: Garbage collection executes opportunistically in the background, and
  /// so it's possible for reads to return a cell even if it matches the active
  /// GC expression for its family.
  public var gcRule: Google_Bigtable_Admin_Table_V1_GcRule {
    get {return _gcRule ?? Google_Bigtable_Admin_Table_V1_GcRule()}
    set {_gcRule = newValue}
  }
  /// Returns true if `gcRule` has been explicitly set.
  public var hasGcRule: Bool {return self._gcRule != nil}
  /// Clears the value of `gcRule`. Subsequent reads from it will return its default value.
  public mutating func clearGcRule() {self._gcRule = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _gcRule: Google_Bigtable_Admin_Table_V1_GcRule? = nil
}

/// Rule for determining which cells to delete during garbage collection.
public struct Google_Bigtable_Admin_Table_V1_GcRule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rule: Google_Bigtable_Admin_Table_V1_GcRule.OneOf_Rule? = nil

  /// Delete all cells in a column except the most recent N.
  public var maxNumVersions: Int32 {
    get {
      if case .maxNumVersions(let v)? = rule {return v}
      return 0
    }
    set {rule = .maxNumVersions(newValue)}
  }

  /// Delete cells in a column older than the given age.
  /// Values must be at least one millisecond, and will be truncated to
  /// microsecond granularity.
  public var maxAge: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .maxAge(let v)? = rule {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {rule = .maxAge(newValue)}
  }

  /// Delete cells that would be deleted by every nested rule.
  public var intersection: Google_Bigtable_Admin_Table_V1_GcRule.Intersection {
    get {
      if case .intersection(let v)? = rule {return v}
      return Google_Bigtable_Admin_Table_V1_GcRule.Intersection()
    }
    set {rule = .intersection(newValue)}
  }

  /// Delete cells that would be deleted by any nested rule.
  public var union: Google_Bigtable_Admin_Table_V1_GcRule.Union {
    get {
      if case .union(let v)? = rule {return v}
      return Google_Bigtable_Admin_Table_V1_GcRule.Union()
    }
    set {rule = .union(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Rule: Equatable {
    /// Delete all cells in a column except the most recent N.
    case maxNumVersions(Int32)
    /// Delete cells in a column older than the given age.
    /// Values must be at least one millisecond, and will be truncated to
    /// microsecond granularity.
    case maxAge(SwiftProtobuf.Google_Protobuf_Duration)
    /// Delete cells that would be deleted by every nested rule.
    case intersection(Google_Bigtable_Admin_Table_V1_GcRule.Intersection)
    /// Delete cells that would be deleted by any nested rule.
    case union(Google_Bigtable_Admin_Table_V1_GcRule.Union)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Bigtable_Admin_Table_V1_GcRule.OneOf_Rule, rhs: Google_Bigtable_Admin_Table_V1_GcRule.OneOf_Rule) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.maxNumVersions, .maxNumVersions): return {
        guard case .maxNumVersions(let l) = lhs, case .maxNumVersions(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.maxAge, .maxAge): return {
        guard case .maxAge(let l) = lhs, case .maxAge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.intersection, .intersection): return {
        guard case .intersection(let l) = lhs, case .intersection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.union, .union): return {
        guard case .union(let l) = lhs, case .union(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A GcRule which deletes cells matching all of the given rules.
  public struct Intersection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only delete cells which would be deleted by every element of `rules`.
    public var rules: [Google_Bigtable_Admin_Table_V1_GcRule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A GcRule which deletes cells matching any of the given rules.
  public struct Union {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delete cells which would be deleted by any element of `rules`.
    public var rules: [Google_Bigtable_Admin_Table_V1_GcRule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.bigtable.admin.table.v1"

extension Google_Bigtable_Admin_Table_V1_Table: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Table"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "current_operation"),
    3: .standard(proto: "column_families"),
    4: .same(proto: "granularity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._currentOperation) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Bigtable_Admin_Table_V1_ColumnFamily>.self, value: &self.columnFamilies) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.granularity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._currentOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.columnFamilies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Bigtable_Admin_Table_V1_ColumnFamily>.self, value: self.columnFamilies, fieldNumber: 3)
    }
    if self.granularity != .millis {
      try visitor.visitSingularEnumField(value: self.granularity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_Table, rhs: Google_Bigtable_Admin_Table_V1_Table) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._currentOperation != rhs._currentOperation {return false}
    if lhs.columnFamilies != rhs.columnFamilies {return false}
    if lhs.granularity != rhs.granularity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_Table.TimestampGranularity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MILLIS"),
  ]
}

extension Google_Bigtable_Admin_Table_V1_ColumnFamily: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ColumnFamily"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "gc_expression"),
    3: .standard(proto: "gc_rule"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.gcExpression) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._gcRule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.gcExpression.isEmpty {
      try visitor.visitSingularStringField(value: self.gcExpression, fieldNumber: 2)
    }
    if let v = self._gcRule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_ColumnFamily, rhs: Google_Bigtable_Admin_Table_V1_ColumnFamily) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.gcExpression != rhs.gcExpression {return false}
    if lhs._gcRule != rhs._gcRule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_GcRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_num_versions"),
    2: .standard(proto: "max_age"),
    3: .same(proto: "intersection"),
    4: .same(proto: "union"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.rule != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.rule = .maxNumVersions(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.rule {
          try decoder.handleConflictingOneOf()
          if case .maxAge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rule = .maxAge(v)}
      }()
      case 3: try {
        var v: Google_Bigtable_Admin_Table_V1_GcRule.Intersection?
        if let current = self.rule {
          try decoder.handleConflictingOneOf()
          if case .intersection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rule = .intersection(v)}
      }()
      case 4: try {
        var v: Google_Bigtable_Admin_Table_V1_GcRule.Union?
        if let current = self.rule {
          try decoder.handleConflictingOneOf()
          if case .union(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.rule = .union(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.rule {
    case .maxNumVersions?: try {
      guard case .maxNumVersions(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .maxAge?: try {
      guard case .maxAge(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .intersection?: try {
      guard case .intersection(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .union?: try {
      guard case .union(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_GcRule, rhs: Google_Bigtable_Admin_Table_V1_GcRule) -> Bool {
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_GcRule.Intersection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_Table_V1_GcRule.protoMessageName + ".Intersection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_GcRule.Intersection, rhs: Google_Bigtable_Admin_Table_V1_GcRule.Intersection) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Bigtable_Admin_Table_V1_GcRule.Union: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Bigtable_Admin_Table_V1_GcRule.protoMessageName + ".Union"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Bigtable_Admin_Table_V1_GcRule.Union, rhs: Google_Bigtable_Admin_Table_V1_GcRule.Union) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

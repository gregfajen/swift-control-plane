// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/storagetransfer/v1/transfer_types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Google service account
public struct Google_Storagetransfer_V1_GoogleServiceAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  public var accountEmail: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AWS access key (see
/// [AWS Security
/// Credentials](http://docs.aws.amazon.com/general/latest/gr/aws-security-credentials.html)).
public struct Google_Storagetransfer_V1_AwsAccessKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AWS access key ID.
  /// Required.
  public var accessKeyID: String = String()

  /// AWS secret access key. This field is not returned in RPC responses.
  /// Required.
  public var secretAccessKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Conditions that determine which objects will be transferred.
public struct Google_Storagetransfer_V1_ObjectConditions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If unspecified, `minTimeElapsedSinceLastModification` takes a zero value
  /// and `maxTimeElapsedSinceLastModification` takes the maximum possible
  /// value of Duration. Objects that satisfy the object conditions
  /// must either have a `lastModificationTime` greater or equal to
  /// `NOW` - `maxTimeElapsedSinceLastModification` and less than
  /// `NOW` - `minTimeElapsedSinceLastModification`, or not have a
  /// `lastModificationTime`.
  public var minTimeElapsedSinceLastModification: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minTimeElapsedSinceLastModification ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minTimeElapsedSinceLastModification = newValue}
  }
  /// Returns true if `minTimeElapsedSinceLastModification` has been explicitly set.
  public var hasMinTimeElapsedSinceLastModification: Bool {return self._minTimeElapsedSinceLastModification != nil}
  /// Clears the value of `minTimeElapsedSinceLastModification`. Subsequent reads from it will return its default value.
  public mutating func clearMinTimeElapsedSinceLastModification() {self._minTimeElapsedSinceLastModification = nil}

  /// `maxTimeElapsedSinceLastModification` is the complement to
  /// `minTimeElapsedSinceLastModification`.
  public var maxTimeElapsedSinceLastModification: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maxTimeElapsedSinceLastModification ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maxTimeElapsedSinceLastModification = newValue}
  }
  /// Returns true if `maxTimeElapsedSinceLastModification` has been explicitly set.
  public var hasMaxTimeElapsedSinceLastModification: Bool {return self._maxTimeElapsedSinceLastModification != nil}
  /// Clears the value of `maxTimeElapsedSinceLastModification`. Subsequent reads from it will return its default value.
  public mutating func clearMaxTimeElapsedSinceLastModification() {self._maxTimeElapsedSinceLastModification = nil}

  /// If `includePrefixes` is specified, objects that satisfy the object
  /// conditions must have names that start with one of the `includePrefixes`
  /// and that do not start with any of the `excludePrefixes`. If
  /// `includePrefixes` is not specified, all objects except those that have
  /// names starting with one of the `excludePrefixes` must satisfy the object
  /// conditions.
  ///
  /// Requirements:
  ///
  ///   * Each include-prefix and exclude-prefix can contain any sequence of
  ///     Unicode characters, of max length 1024 bytes when UTF8-encoded, and
  ///     must not contain Carriage Return or Line Feed characters.  Wildcard
  ///     matching and regular expression matching are not supported.
  ///
  ///   * Each include-prefix and exclude-prefix must omit the leading slash.
  ///     For example, to include the `requests.gz` object in a transfer from
  ///     `s3://my-aws-bucket/logs/y=2015/requests.gz`, specify the include
  ///     prefix as `logs/y=2015/requests.gz`.
  ///
  ///   * None of the include-prefix or the exclude-prefix values can be empty,
  ///     if specified.
  ///
  ///   * Each include-prefix must include a distinct portion of the object
  ///     namespace, i.e., no include-prefix may be a prefix of another
  ///     include-prefix.
  ///
  ///   * Each exclude-prefix must exclude a distinct portion of the object
  ///     namespace, i.e., no exclude-prefix may be a prefix of another
  ///     exclude-prefix.
  ///
  ///   * If `includePrefixes` is specified, then each exclude-prefix must start
  ///     with the value of a path explicitly included by `includePrefixes`.
  ///
  /// The max size of `includePrefixes` is 1000.
  public var includePrefixes: [String] = []

  /// `excludePrefixes` must follow the requirements described for
  /// `includePrefixes`.
  ///
  /// The max size of `excludePrefixes` is 1000.
  public var excludePrefixes: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _minTimeElapsedSinceLastModification: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maxTimeElapsedSinceLastModification: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// In a GcsData, an object's name is the Google Cloud Storage object's name and
/// its `lastModificationTime` refers to the object's updated time, which changes
/// when the content or the metadata of the object is updated.
public struct Google_Storagetransfer_V1_GcsData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Google Cloud Storage bucket name (see
  /// [Bucket Name
  /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
  /// Required.
  public var bucketName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An AwsS3Data can be a data source, but not a data sink.
/// In an AwsS3Data, an object's name is the S3 object's key name.
public struct Google_Storagetransfer_V1_AwsS3Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// S3 Bucket name (see
  /// [Creating a
  /// bucket](http://docs.aws.amazon.com/AmazonS3/latest/dev/create-bucket-get-location-example.html)).
  /// Required.
  public var bucketName: String = String()

  /// AWS access key used to sign the API requests to the AWS S3 bucket.
  /// Permissions on the bucket must be granted to the access ID of the
  /// AWS access key.
  /// Required.
  public var awsAccessKey: Google_Storagetransfer_V1_AwsAccessKey {
    get {return _awsAccessKey ?? Google_Storagetransfer_V1_AwsAccessKey()}
    set {_awsAccessKey = newValue}
  }
  /// Returns true if `awsAccessKey` has been explicitly set.
  public var hasAwsAccessKey: Bool {return self._awsAccessKey != nil}
  /// Clears the value of `awsAccessKey`. Subsequent reads from it will return its default value.
  public mutating func clearAwsAccessKey() {self._awsAccessKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _awsAccessKey: Google_Storagetransfer_V1_AwsAccessKey? = nil
}

/// An HttpData specifies a list of objects on the web to be transferred over
/// HTTP.  The information of the objects to be transferred is contained in a
/// file referenced by a URL. The first line in the file must be
/// "TsvHttpData-1.0", which specifies the format of the file.  Subsequent lines
/// specify the information of the list of objects, one object per list entry.
/// Each entry has the following tab-delimited fields:
///
/// * HTTP URL - The location of the object.
///
/// * Length - The size of the object in bytes.
///
/// * MD5 - The base64-encoded MD5 hash of the object.
///
/// For an example of a valid TSV file, see
/// [Transferring data from
/// URLs](https://cloud.google.com/storage/transfer/create-url-list).
///
/// When transferring data based on a URL list, keep the following in mind:
///
/// * When an object located at `http(s)://hostname:port/<URL-path>` is
/// transferred to a data sink, the name of the object at the data sink is
/// `<hostname>/<URL-path>`.
///
/// * If the specified size of an object does not match the actual size of the
/// object fetched, the object will not be transferred.
///
/// * If the specified MD5 does not match the MD5 computed from the transferred
/// bytes, the object transfer will fail. For more information, see
/// [Generating MD5 hashes](https://cloud.google.com/storage/transfer/#md5)
///
/// * Ensure that each URL you specify is publicly accessible. For
/// example, in Google Cloud Storage you can
/// [share an object publicly]
/// (https://cloud.google.com/storage/docs/cloud-console#_sharingdata) and get
/// a link to it.
///
/// * Storage Transfer Service obeys `robots.txt` rules and requires the source
/// HTTP server to support `Range` requests and to return a `Content-Length`
/// header in each response.
///
/// * [ObjectConditions](#ObjectConditions) have no effect when filtering objects
/// to transfer.
public struct Google_Storagetransfer_V1_HttpData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The URL that points to the file that stores the object list entries.
  /// This file must allow public access.  Currently, only URLs with HTTP and
  /// HTTPS schemes are supported.
  /// Required.
  public var listURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// TransferOptions uses three boolean parameters to define the actions
/// to be performed on objects in a transfer.
public struct Google_Storagetransfer_V1_TransferOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether overwriting objects that already exist in the sink is allowed.
  public var overwriteObjectsAlreadyExistingInSink: Bool = false

  /// Whether objects that exist only in the sink should be deleted.  Note that
  /// this option and `deleteObjectsFromSourceAfterTransfer` are mutually
  /// exclusive.
  public var deleteObjectsUniqueInSink: Bool = false

  /// Whether objects should be deleted from the source after they are
  /// transferred to the sink.  Note that this option and
  /// `deleteObjectsUniqueInSink` are mutually exclusive.
  public var deleteObjectsFromSourceAfterTransfer: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for running a transfer.
public struct Google_Storagetransfer_V1_TransferSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The read source of the data.
  public var dataSource: Google_Storagetransfer_V1_TransferSpec.OneOf_DataSource? = nil

  /// A Google Cloud Storage data source.
  public var gcsDataSource: Google_Storagetransfer_V1_GcsData {
    get {
      if case .gcsDataSource(let v)? = dataSource {return v}
      return Google_Storagetransfer_V1_GcsData()
    }
    set {dataSource = .gcsDataSource(newValue)}
  }

  /// An AWS S3 data source.
  public var awsS3DataSource: Google_Storagetransfer_V1_AwsS3Data {
    get {
      if case .awsS3DataSource(let v)? = dataSource {return v}
      return Google_Storagetransfer_V1_AwsS3Data()
    }
    set {dataSource = .awsS3DataSource(newValue)}
  }

  /// An HTTP URL data source.
  public var httpDataSource: Google_Storagetransfer_V1_HttpData {
    get {
      if case .httpDataSource(let v)? = dataSource {return v}
      return Google_Storagetransfer_V1_HttpData()
    }
    set {dataSource = .httpDataSource(newValue)}
  }

  /// The write sink for the data.
  public var dataSink: Google_Storagetransfer_V1_TransferSpec.OneOf_DataSink? = nil

  /// A Google Cloud Storage data sink.
  public var gcsDataSink: Google_Storagetransfer_V1_GcsData {
    get {
      if case .gcsDataSink(let v)? = dataSink {return v}
      return Google_Storagetransfer_V1_GcsData()
    }
    set {dataSink = .gcsDataSink(newValue)}
  }

  /// Only objects that satisfy these object conditions are included in the set
  /// of data source and data sink objects.  Object conditions based on
  /// objects' `lastModificationTime` do not exclude objects in a data sink.
  public var objectConditions: Google_Storagetransfer_V1_ObjectConditions {
    get {return _objectConditions ?? Google_Storagetransfer_V1_ObjectConditions()}
    set {_objectConditions = newValue}
  }
  /// Returns true if `objectConditions` has been explicitly set.
  public var hasObjectConditions: Bool {return self._objectConditions != nil}
  /// Clears the value of `objectConditions`. Subsequent reads from it will return its default value.
  public mutating func clearObjectConditions() {self._objectConditions = nil}

  /// If the option `deleteObjectsUniqueInSink` is `true`, object conditions
  /// based on objects' `lastModificationTime` are ignored and do not exclude
  /// objects in a data source or a data sink.
  public var transferOptions: Google_Storagetransfer_V1_TransferOptions {
    get {return _transferOptions ?? Google_Storagetransfer_V1_TransferOptions()}
    set {_transferOptions = newValue}
  }
  /// Returns true if `transferOptions` has been explicitly set.
  public var hasTransferOptions: Bool {return self._transferOptions != nil}
  /// Clears the value of `transferOptions`. Subsequent reads from it will return its default value.
  public mutating func clearTransferOptions() {self._transferOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The read source of the data.
  public enum OneOf_DataSource: Equatable {
    /// A Google Cloud Storage data source.
    case gcsDataSource(Google_Storagetransfer_V1_GcsData)
    /// An AWS S3 data source.
    case awsS3DataSource(Google_Storagetransfer_V1_AwsS3Data)
    /// An HTTP URL data source.
    case httpDataSource(Google_Storagetransfer_V1_HttpData)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Storagetransfer_V1_TransferSpec.OneOf_DataSource, rhs: Google_Storagetransfer_V1_TransferSpec.OneOf_DataSource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsDataSource, .gcsDataSource): return {
        guard case .gcsDataSource(let l) = lhs, case .gcsDataSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.awsS3DataSource, .awsS3DataSource): return {
        guard case .awsS3DataSource(let l) = lhs, case .awsS3DataSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpDataSource, .httpDataSource): return {
        guard case .httpDataSource(let l) = lhs, case .httpDataSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The write sink for the data.
  public enum OneOf_DataSink: Equatable {
    /// A Google Cloud Storage data sink.
    case gcsDataSink(Google_Storagetransfer_V1_GcsData)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Storagetransfer_V1_TransferSpec.OneOf_DataSink, rhs: Google_Storagetransfer_V1_TransferSpec.OneOf_DataSink) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.gcsDataSink, .gcsDataSink): return {
        guard case .gcsDataSink(let l) = lhs, case .gcsDataSink(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _objectConditions: Google_Storagetransfer_V1_ObjectConditions? = nil
  fileprivate var _transferOptions: Google_Storagetransfer_V1_TransferOptions? = nil
}

/// Transfers can be scheduled to recur or to run just once.
public struct Google_Storagetransfer_V1_Schedule {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The first day the recurring transfer is scheduled to run. If
  /// `scheduleStartDate` is in the past, the transfer will run for the first
  /// time on the following day.
  /// Required.
  public var scheduleStartDate: Google_Type_Date {
    get {return _scheduleStartDate ?? Google_Type_Date()}
    set {_scheduleStartDate = newValue}
  }
  /// Returns true if `scheduleStartDate` has been explicitly set.
  public var hasScheduleStartDate: Bool {return self._scheduleStartDate != nil}
  /// Clears the value of `scheduleStartDate`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleStartDate() {self._scheduleStartDate = nil}

  /// The last day the recurring transfer will be run. If `scheduleEndDate`
  /// is the same as `scheduleStartDate`, the transfer will be executed only
  /// once.
  public var scheduleEndDate: Google_Type_Date {
    get {return _scheduleEndDate ?? Google_Type_Date()}
    set {_scheduleEndDate = newValue}
  }
  /// Returns true if `scheduleEndDate` has been explicitly set.
  public var hasScheduleEndDate: Bool {return self._scheduleEndDate != nil}
  /// Clears the value of `scheduleEndDate`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleEndDate() {self._scheduleEndDate = nil}

  /// The time in UTC at which the transfer will be scheduled to start in a day.
  /// Transfers may start later than this time. If not specified, recurring and
  /// one-time transfers that are scheduled to run today will run immediately;
  /// recurring transfers that are scheduled to run on a future date will start
  /// at approximately midnight UTC on that date. Note that when configuring a
  /// transfer with the Cloud Platform Console, the transfer's start time in a
  /// day is specified in your local timezone.
  public var startTimeOfDay: Google_Type_TimeOfDay {
    get {return _startTimeOfDay ?? Google_Type_TimeOfDay()}
    set {_startTimeOfDay = newValue}
  }
  /// Returns true if `startTimeOfDay` has been explicitly set.
  public var hasStartTimeOfDay: Bool {return self._startTimeOfDay != nil}
  /// Clears the value of `startTimeOfDay`. Subsequent reads from it will return its default value.
  public mutating func clearStartTimeOfDay() {self._startTimeOfDay = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _scheduleStartDate: Google_Type_Date? = nil
  fileprivate var _scheduleEndDate: Google_Type_Date? = nil
  fileprivate var _startTimeOfDay: Google_Type_TimeOfDay? = nil
}

/// This resource represents the configuration of a transfer job that runs
/// periodically.
public struct Google_Storagetransfer_V1_TransferJob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A globally unique name assigned by Storage Transfer Service when the
  /// job is created. This field should be left empty in requests to create a new
  /// transfer job; otherwise, the requests result in an `INVALID_ARGUMENT`
  /// error.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A description provided by the user for the job. Its max length is 1024
  /// bytes when Unicode-encoded.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The ID of the Google Cloud Platform Console project that owns the job.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// Transfer specification.
  public var transferSpec: Google_Storagetransfer_V1_TransferSpec {
    get {return _storage._transferSpec ?? Google_Storagetransfer_V1_TransferSpec()}
    set {_uniqueStorage()._transferSpec = newValue}
  }
  /// Returns true if `transferSpec` has been explicitly set.
  public var hasTransferSpec: Bool {return _storage._transferSpec != nil}
  /// Clears the value of `transferSpec`. Subsequent reads from it will return its default value.
  public mutating func clearTransferSpec() {_uniqueStorage()._transferSpec = nil}

  /// Schedule specification.
  public var schedule: Google_Storagetransfer_V1_Schedule {
    get {return _storage._schedule ?? Google_Storagetransfer_V1_Schedule()}
    set {_uniqueStorage()._schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  public var hasSchedule: Bool {return _storage._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  public mutating func clearSchedule() {_uniqueStorage()._schedule = nil}

  /// Status of the job. This value MUST be specified for
  /// `CreateTransferJobRequests`.
  ///
  /// NOTE: The effect of the new job status takes place during a subsequent job
  /// run. For example, if you change the job status from `ENABLED` to
  /// `DISABLED`, and an operation spawned by the transfer is running, the status
  /// change would not affect the current operation.
  public var status: Google_Storagetransfer_V1_TransferJob.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// This field cannot be changed by user requests.
  public var creationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._creationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._creationTime = newValue}
  }
  /// Returns true if `creationTime` has been explicitly set.
  public var hasCreationTime: Bool {return _storage._creationTime != nil}
  /// Clears the value of `creationTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreationTime() {_uniqueStorage()._creationTime = nil}

  /// This field cannot be changed by user requests.
  public var lastModificationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModificationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModificationTime = newValue}
  }
  /// Returns true if `lastModificationTime` has been explicitly set.
  public var hasLastModificationTime: Bool {return _storage._lastModificationTime != nil}
  /// Clears the value of `lastModificationTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastModificationTime() {_uniqueStorage()._lastModificationTime = nil}

  /// This field cannot be changed by user requests.
  public var deletionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deletionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deletionTime = newValue}
  }
  /// Returns true if `deletionTime` has been explicitly set.
  public var hasDeletionTime: Bool {return _storage._deletionTime != nil}
  /// Clears the value of `deletionTime`. Subsequent reads from it will return its default value.
  public mutating func clearDeletionTime() {_uniqueStorage()._deletionTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The status of the transfer job.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Zero is an illegal value.
    case unspecified // = 0

    /// New transfers will be performed based on the schedule.
    case enabled // = 1

    /// New transfers will not be scheduled.
    case disabled // = 2

    /// This is a soft delete state. After a transfer job is set to this
    /// state, the job and all the transfer executions are subject to
    /// garbage collection.
    case deleted // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enabled
      case 2: self = .disabled
      case 3: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enabled: return 1
      case .disabled: return 2
      case .deleted: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Storagetransfer_V1_TransferJob.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Storagetransfer_V1_TransferJob.Status] = [
    .unspecified,
    .enabled,
    .disabled,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

/// An entry describing an error that has occurred.
public struct Google_Storagetransfer_V1_ErrorLogEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A URL that refers to the target (a data source, a data sink,
  /// or an object) with which the error is associated.
  /// Required.
  public var url: String = String()

  /// A list of messages that carry the error details.
  public var errorDetails: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of errors by error code, plus a count and sample error log
/// entries.
public struct Google_Storagetransfer_V1_ErrorSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required.
  public var errorCode: Google_Rpc_Code = .ok

  /// Count of this type of error.
  /// Required.
  public var errorCount: Int64 = 0

  /// Error samples.
  public var errorLogEntries: [Google_Storagetransfer_V1_ErrorLogEntry] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A collection of counters that report the progress of a transfer operation.
public struct Google_Storagetransfer_V1_TransferCounters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Objects found in the data source that are scheduled to be transferred,
  /// excluding any that are filtered based on object conditions or skipped due
  /// to sync.
  public var objectsFoundFromSource: Int64 = 0

  /// Bytes found in the data source that are scheduled to be transferred,
  /// excluding any that are filtered based on object conditions or skipped due
  /// to sync.
  public var bytesFoundFromSource: Int64 = 0

  /// Objects found only in the data sink that are scheduled to be deleted.
  public var objectsFoundOnlyFromSink: Int64 = 0

  /// Bytes found only in the data sink that are scheduled to be deleted.
  public var bytesFoundOnlyFromSink: Int64 = 0

  /// Objects in the data source that are not transferred because they already
  /// exist in the data sink.
  public var objectsFromSourceSkippedBySync: Int64 = 0

  /// Bytes in the data source that are not transferred because they already
  /// exist in the data sink.
  public var bytesFromSourceSkippedBySync: Int64 = 0

  /// Objects that are copied to the data sink.
  public var objectsCopiedToSink: Int64 = 0

  /// Bytes that are copied to the data sink.
  public var bytesCopiedToSink: Int64 = 0

  /// Objects that are deleted from the data source.
  public var objectsDeletedFromSource: Int64 = 0

  /// Bytes that are deleted from the data source.
  public var bytesDeletedFromSource: Int64 = 0

  /// Objects that are deleted from the data sink.
  public var objectsDeletedFromSink: Int64 = 0

  /// Bytes that are deleted from the data sink.
  public var bytesDeletedFromSink: Int64 = 0

  /// Objects in the data source that failed during the transfer.
  public var objectsFromSourceFailed: Int64 = 0

  /// Bytes in the data source that failed during the transfer.
  public var bytesFromSourceFailed: Int64 = 0

  /// Objects that failed to be deleted from the data sink.
  public var objectsFailedToDeleteFromSink: Int64 = 0

  /// Bytes that failed to be deleted from the data sink.
  public var bytesFailedToDeleteFromSink: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A description of the execution of a transfer.
public struct Google_Storagetransfer_V1_TransferOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A globally unique ID assigned by the system.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The ID of the Google Cloud Platform Console project that owns the
  /// operation. Required.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// Transfer specification.
  /// Required.
  public var transferSpec: Google_Storagetransfer_V1_TransferSpec {
    get {return _storage._transferSpec ?? Google_Storagetransfer_V1_TransferSpec()}
    set {_uniqueStorage()._transferSpec = newValue}
  }
  /// Returns true if `transferSpec` has been explicitly set.
  public var hasTransferSpec: Bool {return _storage._transferSpec != nil}
  /// Clears the value of `transferSpec`. Subsequent reads from it will return its default value.
  public mutating func clearTransferSpec() {_uniqueStorage()._transferSpec = nil}

  /// Start time of this transfer execution.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// End time of this transfer execution.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Status of the transfer operation.
  public var status: Google_Storagetransfer_V1_TransferOperation.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Information about the progress of the transfer operation.
  public var counters: Google_Storagetransfer_V1_TransferCounters {
    get {return _storage._counters ?? Google_Storagetransfer_V1_TransferCounters()}
    set {_uniqueStorage()._counters = newValue}
  }
  /// Returns true if `counters` has been explicitly set.
  public var hasCounters: Bool {return _storage._counters != nil}
  /// Clears the value of `counters`. Subsequent reads from it will return its default value.
  public mutating func clearCounters() {_uniqueStorage()._counters = nil}

  /// Summarizes errors encountered with sample error log entries.
  public var errorBreakdowns: [Google_Storagetransfer_V1_ErrorSummary] {
    get {return _storage._errorBreakdowns}
    set {_uniqueStorage()._errorBreakdowns = newValue}
  }

  /// The name of the transfer job that triggers this transfer operation.
  public var transferJobName: String {
    get {return _storage._transferJobName}
    set {_uniqueStorage()._transferJobName = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The status of a TransferOperation.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Zero is an illegal value.
    case unspecified // = 0

    /// In progress.
    case inProgress // = 1

    /// Paused.
    case paused // = 2

    /// Completed successfully.
    case success // = 3

    /// Terminated due to an unrecoverable failure.
    case failed // = 4

    /// Aborted by the user.
    case aborted // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .inProgress
      case 2: self = .paused
      case 3: self = .success
      case 4: self = .failed
      case 5: self = .aborted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .inProgress: return 1
      case .paused: return 2
      case .success: return 3
      case .failed: return 4
      case .aborted: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Storagetransfer_V1_TransferOperation.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Storagetransfer_V1_TransferOperation.Status] = [
    .unspecified,
    .inProgress,
    .paused,
    .success,
    .failed,
    .aborted,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.storagetransfer.v1"

extension Google_Storagetransfer_V1_GoogleServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GoogleServiceAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_email"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountEmail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.accountEmail, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_GoogleServiceAccount, rhs: Google_Storagetransfer_V1_GoogleServiceAccount) -> Bool {
    if lhs.accountEmail != rhs.accountEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_AwsAccessKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AwsAccessKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "access_key_id"),
    2: .standard(proto: "secret_access_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accessKeyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secretAccessKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accessKeyID.isEmpty {
      try visitor.visitSingularStringField(value: self.accessKeyID, fieldNumber: 1)
    }
    if !self.secretAccessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.secretAccessKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_AwsAccessKey, rhs: Google_Storagetransfer_V1_AwsAccessKey) -> Bool {
    if lhs.accessKeyID != rhs.accessKeyID {return false}
    if lhs.secretAccessKey != rhs.secretAccessKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_ObjectConditions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ObjectConditions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_time_elapsed_since_last_modification"),
    2: .standard(proto: "max_time_elapsed_since_last_modification"),
    3: .standard(proto: "include_prefixes"),
    4: .standard(proto: "exclude_prefixes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._minTimeElapsedSinceLastModification) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._maxTimeElapsedSinceLastModification) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.includePrefixes) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.excludePrefixes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._minTimeElapsedSinceLastModification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._maxTimeElapsedSinceLastModification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.includePrefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includePrefixes, fieldNumber: 3)
    }
    if !self.excludePrefixes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludePrefixes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_ObjectConditions, rhs: Google_Storagetransfer_V1_ObjectConditions) -> Bool {
    if lhs._minTimeElapsedSinceLastModification != rhs._minTimeElapsedSinceLastModification {return false}
    if lhs._maxTimeElapsedSinceLastModification != rhs._maxTimeElapsedSinceLastModification {return false}
    if lhs.includePrefixes != rhs.includePrefixes {return false}
    if lhs.excludePrefixes != rhs.excludePrefixes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_GcsData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GcsData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucketName.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_GcsData, rhs: Google_Storagetransfer_V1_GcsData) -> Bool {
    if lhs.bucketName != rhs.bucketName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_AwsS3Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AwsS3Data"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bucket_name"),
    2: .standard(proto: "aws_access_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucketName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._awsAccessKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucketName.isEmpty {
      try visitor.visitSingularStringField(value: self.bucketName, fieldNumber: 1)
    }
    if let v = self._awsAccessKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_AwsS3Data, rhs: Google_Storagetransfer_V1_AwsS3Data) -> Bool {
    if lhs.bucketName != rhs.bucketName {return false}
    if lhs._awsAccessKey != rhs._awsAccessKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_HttpData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "list_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.listURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.listURL.isEmpty {
      try visitor.visitSingularStringField(value: self.listURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_HttpData, rhs: Google_Storagetransfer_V1_HttpData) -> Bool {
    if lhs.listURL != rhs.listURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "overwrite_objects_already_existing_in_sink"),
    2: .standard(proto: "delete_objects_unique_in_sink"),
    3: .standard(proto: "delete_objects_from_source_after_transfer"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.overwriteObjectsAlreadyExistingInSink) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deleteObjectsUniqueInSink) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.deleteObjectsFromSourceAfterTransfer) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.overwriteObjectsAlreadyExistingInSink != false {
      try visitor.visitSingularBoolField(value: self.overwriteObjectsAlreadyExistingInSink, fieldNumber: 1)
    }
    if self.deleteObjectsUniqueInSink != false {
      try visitor.visitSingularBoolField(value: self.deleteObjectsUniqueInSink, fieldNumber: 2)
    }
    if self.deleteObjectsFromSourceAfterTransfer != false {
      try visitor.visitSingularBoolField(value: self.deleteObjectsFromSourceAfterTransfer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_TransferOptions, rhs: Google_Storagetransfer_V1_TransferOptions) -> Bool {
    if lhs.overwriteObjectsAlreadyExistingInSink != rhs.overwriteObjectsAlreadyExistingInSink {return false}
    if lhs.deleteObjectsUniqueInSink != rhs.deleteObjectsUniqueInSink {return false}
    if lhs.deleteObjectsFromSourceAfterTransfer != rhs.deleteObjectsFromSourceAfterTransfer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferSpec"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gcs_data_source"),
    2: .standard(proto: "aws_s3_data_source"),
    3: .standard(proto: "http_data_source"),
    4: .standard(proto: "gcs_data_sink"),
    5: .standard(proto: "object_conditions"),
    6: .standard(proto: "transfer_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Storagetransfer_V1_GcsData?
        if let current = self.dataSource {
          try decoder.handleConflictingOneOf()
          if case .gcsDataSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataSource = .gcsDataSource(v)}
      }()
      case 2: try {
        var v: Google_Storagetransfer_V1_AwsS3Data?
        if let current = self.dataSource {
          try decoder.handleConflictingOneOf()
          if case .awsS3DataSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataSource = .awsS3DataSource(v)}
      }()
      case 3: try {
        var v: Google_Storagetransfer_V1_HttpData?
        if let current = self.dataSource {
          try decoder.handleConflictingOneOf()
          if case .httpDataSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataSource = .httpDataSource(v)}
      }()
      case 4: try {
        var v: Google_Storagetransfer_V1_GcsData?
        if let current = self.dataSink {
          try decoder.handleConflictingOneOf()
          if case .gcsDataSink(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.dataSink = .gcsDataSink(v)}
      }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._objectConditions) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._transferOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.dataSource {
    case .gcsDataSource?: try {
      guard case .gcsDataSource(let v)? = self.dataSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .awsS3DataSource?: try {
      guard case .awsS3DataSource(let v)? = self.dataSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .httpDataSource?: try {
      guard case .httpDataSource(let v)? = self.dataSource else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if case .gcsDataSink(let v)? = self.dataSink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._objectConditions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._transferOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_TransferSpec, rhs: Google_Storagetransfer_V1_TransferSpec) -> Bool {
    if lhs.dataSource != rhs.dataSource {return false}
    if lhs.dataSink != rhs.dataSink {return false}
    if lhs._objectConditions != rhs._objectConditions {return false}
    if lhs._transferOptions != rhs._transferOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Schedule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "schedule_start_date"),
    2: .standard(proto: "schedule_end_date"),
    3: .standard(proto: "start_time_of_day"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scheduleStartDate) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduleEndDate) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTimeOfDay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._scheduleStartDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._scheduleEndDate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._startTimeOfDay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_Schedule, rhs: Google_Storagetransfer_V1_Schedule) -> Bool {
    if lhs._scheduleStartDate != rhs._scheduleStartDate {return false}
    if lhs._scheduleEndDate != rhs._scheduleEndDate {return false}
    if lhs._startTimeOfDay != rhs._startTimeOfDay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferJob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "project_id"),
    4: .standard(proto: "transfer_spec"),
    5: .same(proto: "schedule"),
    6: .same(proto: "status"),
    7: .standard(proto: "creation_time"),
    8: .standard(proto: "last_modification_time"),
    9: .standard(proto: "deletion_time"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _projectID: String = String()
    var _transferSpec: Google_Storagetransfer_V1_TransferSpec? = nil
    var _schedule: Google_Storagetransfer_V1_Schedule? = nil
    var _status: Google_Storagetransfer_V1_TransferJob.Status = .unspecified
    var _creationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModificationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deletionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _projectID = source._projectID
      _transferSpec = source._transferSpec
      _schedule = source._schedule
      _status = source._status
      _creationTime = source._creationTime
      _lastModificationTime = source._lastModificationTime
      _deletionTime = source._deletionTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._transferSpec) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._schedule) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._creationTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastModificationTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._deletionTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 3)
      }
      if let v = _storage._transferSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._schedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 6)
      }
      if let v = _storage._creationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._lastModificationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._deletionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_TransferJob, rhs: Google_Storagetransfer_V1_TransferJob) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._transferSpec != rhs_storage._transferSpec {return false}
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._creationTime != rhs_storage._creationTime {return false}
        if _storage._lastModificationTime != rhs_storage._lastModificationTime {return false}
        if _storage._deletionTime != rhs_storage._deletionTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferJob.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "ENABLED"),
    2: .same(proto: "DISABLED"),
    3: .same(proto: "DELETED"),
  ]
}

extension Google_Storagetransfer_V1_ErrorLogEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorLogEntry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    3: .standard(proto: "error_details"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.errorDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.errorDetails.isEmpty {
      try visitor.visitRepeatedStringField(value: self.errorDetails, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_ErrorLogEntry, rhs: Google_Storagetransfer_V1_ErrorLogEntry) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.errorDetails != rhs.errorDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_ErrorSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
    2: .standard(proto: "error_count"),
    3: .standard(proto: "error_log_entries"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.errorCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.errorLogEntries) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .ok {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if self.errorCount != 0 {
      try visitor.visitSingularInt64Field(value: self.errorCount, fieldNumber: 2)
    }
    if !self.errorLogEntries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errorLogEntries, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_ErrorSummary, rhs: Google_Storagetransfer_V1_ErrorSummary) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.errorCount != rhs.errorCount {return false}
    if lhs.errorLogEntries != rhs.errorLogEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferCounters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferCounters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "objects_found_from_source"),
    2: .standard(proto: "bytes_found_from_source"),
    3: .standard(proto: "objects_found_only_from_sink"),
    4: .standard(proto: "bytes_found_only_from_sink"),
    5: .standard(proto: "objects_from_source_skipped_by_sync"),
    6: .standard(proto: "bytes_from_source_skipped_by_sync"),
    7: .standard(proto: "objects_copied_to_sink"),
    8: .standard(proto: "bytes_copied_to_sink"),
    9: .standard(proto: "objects_deleted_from_source"),
    10: .standard(proto: "bytes_deleted_from_source"),
    11: .standard(proto: "objects_deleted_from_sink"),
    12: .standard(proto: "bytes_deleted_from_sink"),
    13: .standard(proto: "objects_from_source_failed"),
    14: .standard(proto: "bytes_from_source_failed"),
    15: .standard(proto: "objects_failed_to_delete_from_sink"),
    16: .standard(proto: "bytes_failed_to_delete_from_sink"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.objectsFoundFromSource) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.bytesFoundFromSource) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.objectsFoundOnlyFromSink) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.bytesFoundOnlyFromSink) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.objectsFromSourceSkippedBySync) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.bytesFromSourceSkippedBySync) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.objectsCopiedToSink) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.bytesCopiedToSink) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.objectsDeletedFromSource) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.bytesDeletedFromSource) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.objectsDeletedFromSink) }()
      case 12: try { try decoder.decodeSingularInt64Field(value: &self.bytesDeletedFromSink) }()
      case 13: try { try decoder.decodeSingularInt64Field(value: &self.objectsFromSourceFailed) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.bytesFromSourceFailed) }()
      case 15: try { try decoder.decodeSingularInt64Field(value: &self.objectsFailedToDeleteFromSink) }()
      case 16: try { try decoder.decodeSingularInt64Field(value: &self.bytesFailedToDeleteFromSink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.objectsFoundFromSource != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsFoundFromSource, fieldNumber: 1)
    }
    if self.bytesFoundFromSource != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesFoundFromSource, fieldNumber: 2)
    }
    if self.objectsFoundOnlyFromSink != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsFoundOnlyFromSink, fieldNumber: 3)
    }
    if self.bytesFoundOnlyFromSink != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesFoundOnlyFromSink, fieldNumber: 4)
    }
    if self.objectsFromSourceSkippedBySync != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsFromSourceSkippedBySync, fieldNumber: 5)
    }
    if self.bytesFromSourceSkippedBySync != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesFromSourceSkippedBySync, fieldNumber: 6)
    }
    if self.objectsCopiedToSink != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsCopiedToSink, fieldNumber: 7)
    }
    if self.bytesCopiedToSink != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesCopiedToSink, fieldNumber: 8)
    }
    if self.objectsDeletedFromSource != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsDeletedFromSource, fieldNumber: 9)
    }
    if self.bytesDeletedFromSource != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesDeletedFromSource, fieldNumber: 10)
    }
    if self.objectsDeletedFromSink != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsDeletedFromSink, fieldNumber: 11)
    }
    if self.bytesDeletedFromSink != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesDeletedFromSink, fieldNumber: 12)
    }
    if self.objectsFromSourceFailed != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsFromSourceFailed, fieldNumber: 13)
    }
    if self.bytesFromSourceFailed != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesFromSourceFailed, fieldNumber: 14)
    }
    if self.objectsFailedToDeleteFromSink != 0 {
      try visitor.visitSingularInt64Field(value: self.objectsFailedToDeleteFromSink, fieldNumber: 15)
    }
    if self.bytesFailedToDeleteFromSink != 0 {
      try visitor.visitSingularInt64Field(value: self.bytesFailedToDeleteFromSink, fieldNumber: 16)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_TransferCounters, rhs: Google_Storagetransfer_V1_TransferCounters) -> Bool {
    if lhs.objectsFoundFromSource != rhs.objectsFoundFromSource {return false}
    if lhs.bytesFoundFromSource != rhs.bytesFoundFromSource {return false}
    if lhs.objectsFoundOnlyFromSink != rhs.objectsFoundOnlyFromSink {return false}
    if lhs.bytesFoundOnlyFromSink != rhs.bytesFoundOnlyFromSink {return false}
    if lhs.objectsFromSourceSkippedBySync != rhs.objectsFromSourceSkippedBySync {return false}
    if lhs.bytesFromSourceSkippedBySync != rhs.bytesFromSourceSkippedBySync {return false}
    if lhs.objectsCopiedToSink != rhs.objectsCopiedToSink {return false}
    if lhs.bytesCopiedToSink != rhs.bytesCopiedToSink {return false}
    if lhs.objectsDeletedFromSource != rhs.objectsDeletedFromSource {return false}
    if lhs.bytesDeletedFromSource != rhs.bytesDeletedFromSource {return false}
    if lhs.objectsDeletedFromSink != rhs.objectsDeletedFromSink {return false}
    if lhs.bytesDeletedFromSink != rhs.bytesDeletedFromSink {return false}
    if lhs.objectsFromSourceFailed != rhs.objectsFromSourceFailed {return false}
    if lhs.bytesFromSourceFailed != rhs.bytesFromSourceFailed {return false}
    if lhs.objectsFailedToDeleteFromSink != rhs.objectsFailedToDeleteFromSink {return false}
    if lhs.bytesFailedToDeleteFromSink != rhs.bytesFailedToDeleteFromSink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransferOperation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "project_id"),
    3: .standard(proto: "transfer_spec"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .same(proto: "status"),
    7: .same(proto: "counters"),
    8: .standard(proto: "error_breakdowns"),
    9: .standard(proto: "transfer_job_name"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _projectID: String = String()
    var _transferSpec: Google_Storagetransfer_V1_TransferSpec? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Google_Storagetransfer_V1_TransferOperation.Status = .unspecified
    var _counters: Google_Storagetransfer_V1_TransferCounters? = nil
    var _errorBreakdowns: [Google_Storagetransfer_V1_ErrorSummary] = []
    var _transferJobName: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _projectID = source._projectID
      _transferSpec = source._transferSpec
      _startTime = source._startTime
      _endTime = source._endTime
      _status = source._status
      _counters = source._counters
      _errorBreakdowns = source._errorBreakdowns
      _transferJobName = source._transferJobName
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._transferSpec) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._counters) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._errorBreakdowns) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._transferJobName) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 2)
      }
      if let v = _storage._transferSpec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 6)
      }
      if let v = _storage._counters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._errorBreakdowns.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._errorBreakdowns, fieldNumber: 8)
      }
      if !_storage._transferJobName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transferJobName, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Storagetransfer_V1_TransferOperation, rhs: Google_Storagetransfer_V1_TransferOperation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._transferSpec != rhs_storage._transferSpec {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._counters != rhs_storage._counters {return false}
        if _storage._errorBreakdowns != rhs_storage._errorBreakdowns {return false}
        if _storage._transferJobName != rhs_storage._transferJobName {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Storagetransfer_V1_TransferOperation.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "IN_PROGRESS"),
    2: .same(proto: "PAUSED"),
    3: .same(proto: "SUCCESS"),
    4: .same(proto: "FAILED"),
    5: .same(proto: "ABORTED"),
  ]
}

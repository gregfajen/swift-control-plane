// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/type/datetime.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents civil time (or occasionally physical time).
///
/// This type can represent a civil time in one of a few possible ways:
///
///  * When utc_offset is set and time_zone is unset: a civil time on a calendar
///    day with a particular offset from UTC.
///  * When time_zone is set and utc_offset is unset: a civil time on a calendar
///    day in a particular time zone.
///  * When neither time_zone nor utc_offset is set: a civil time on a calendar
///    day in local time.
///
/// The date is relative to the Proleptic Gregorian Calendar.
///
/// If year is 0, the DateTime is considered not to have a specific year. month
/// and day must have valid, non-zero values.
///
/// This type may also be used to represent a physical time if all the date and
/// time fields are set and either case of the `time_offset` oneof is set.
/// Consider using `Timestamp` message for physical time instead. If your use
/// case also would like to store the user's timezone, that can be done in
/// another field.
///
/// This type is more flexible than some applications may want. Make sure to
/// document and validate your application's limitations.
public struct Google_Type_DateTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a
  /// datetime without a year.
  public var year: Int32 = 0

  /// Required. Month of year. Must be from 1 to 12.
  public var month: Int32 = 0

  /// Required. Day of month. Must be from 1 to 31 and valid for the year and
  /// month.
  public var day: Int32 = 0

  /// Required. Hours of day in 24 hour format. Should be from 0 to 23. An API
  /// may choose to allow the value "24:00:00" for scenarios like business
  /// closing time.
  public var hours: Int32 = 0

  /// Required. Minutes of hour of day. Must be from 0 to 59.
  public var minutes: Int32 = 0

  /// Required. Seconds of minutes of the time. Must normally be from 0 to 59. An
  /// API may allow the value 60 if it allows leap-seconds.
  public var seconds: Int32 = 0

  /// Required. Fractions of seconds in nanoseconds. Must be from 0 to
  /// 999,999,999.
  public var nanos: Int32 = 0

  /// Optional. Specifies either the UTC offset or the time zone of the DateTime.
  /// Choose carefully between them, considering that time zone data may change
  /// in the future (for example, a country modifies their DST start/end dates,
  /// and future DateTimes in the affected range had already been stored).
  /// If omitted, the DateTime is considered to be in local time.
  public var timeOffset: Google_Type_DateTime.OneOf_TimeOffset? = nil

  /// UTC offset. Must be whole seconds, between -18 hours and +18 hours.
  /// For example, a UTC offset of -4:00 would be represented as
  /// { seconds: -14400 }.
  public var utcOffset: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .utcOffset(let v)? = timeOffset {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {timeOffset = .utcOffset(newValue)}
  }

  /// Time zone.
  public var timeZone: Google_Type_TimeZone {
    get {
      if case .timeZone(let v)? = timeOffset {return v}
      return Google_Type_TimeZone()
    }
    set {timeOffset = .timeZone(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Optional. Specifies either the UTC offset or the time zone of the DateTime.
  /// Choose carefully between them, considering that time zone data may change
  /// in the future (for example, a country modifies their DST start/end dates,
  /// and future DateTimes in the affected range had already been stored).
  /// If omitted, the DateTime is considered to be in local time.
  public enum OneOf_TimeOffset: Equatable {
    /// UTC offset. Must be whole seconds, between -18 hours and +18 hours.
    /// For example, a UTC offset of -4:00 would be represented as
    /// { seconds: -14400 }.
    case utcOffset(SwiftProtobuf.Google_Protobuf_Duration)
    /// Time zone.
    case timeZone(Google_Type_TimeZone)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Type_DateTime.OneOf_TimeOffset, rhs: Google_Type_DateTime.OneOf_TimeOffset) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.utcOffset, .utcOffset): return {
        guard case .utcOffset(let l) = lhs, case .utcOffset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timeZone, .timeZone): return {
        guard case .timeZone(let l) = lhs, case .timeZone(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Represents a time zone from the
/// [IANA Time Zone Database](https://www.iana.org/time-zones).
public struct Google_Type_TimeZone {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IANA Time Zone Database time zone, e.g. "America/New_York".
  public var id: String = String()

  /// Optional. IANA Time Zone Database version number, e.g. "2019a".
  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.type"

extension Google_Type_DateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DateTime"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "year"),
    2: .same(proto: "month"),
    3: .same(proto: "day"),
    4: .same(proto: "hours"),
    5: .same(proto: "minutes"),
    6: .same(proto: "seconds"),
    7: .same(proto: "nanos"),
    8: .standard(proto: "utc_offset"),
    9: .standard(proto: "time_zone"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.month) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.day) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.hours) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.minutes) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.seconds) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.nanos) }()
      case 8: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.timeOffset {
          try decoder.handleConflictingOneOf()
          if case .utcOffset(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.timeOffset = .utcOffset(v)}
      }()
      case 9: try {
        var v: Google_Type_TimeZone?
        if let current = self.timeOffset {
          try decoder.handleConflictingOneOf()
          if case .timeZone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.timeOffset = .timeZone(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 1)
    }
    if self.month != 0 {
      try visitor.visitSingularInt32Field(value: self.month, fieldNumber: 2)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 3)
    }
    if self.hours != 0 {
      try visitor.visitSingularInt32Field(value: self.hours, fieldNumber: 4)
    }
    if self.minutes != 0 {
      try visitor.visitSingularInt32Field(value: self.minutes, fieldNumber: 5)
    }
    if self.seconds != 0 {
      try visitor.visitSingularInt32Field(value: self.seconds, fieldNumber: 6)
    }
    if self.nanos != 0 {
      try visitor.visitSingularInt32Field(value: self.nanos, fieldNumber: 7)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.timeOffset {
    case .utcOffset?: try {
      guard case .utcOffset(let v)? = self.timeOffset else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .timeZone?: try {
      guard case .timeZone(let v)? = self.timeOffset else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Type_DateTime, rhs: Google_Type_DateTime) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.hours != rhs.hours {return false}
    if lhs.minutes != rhs.minutes {return false}
    if lhs.seconds != rhs.seconds {return false}
    if lhs.nanos != rhs.nanos {return false}
    if lhs.timeOffset != rhs.timeOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Type_TimeZone: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeZone"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Type_TimeZone, rhs: Google_Type_TimeZone) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

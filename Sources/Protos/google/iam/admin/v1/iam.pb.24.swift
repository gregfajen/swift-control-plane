// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/iam/admin/v1/iam.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Supported key algorithms.
public enum Google_Iam_Admin_V1_ServiceAccountKeyAlgorithm: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// An unspecified key algorithm.
  case keyAlgUnspecified // = 0

  /// 1k RSA Key.
  case keyAlgRsa1024 // = 1

  /// 2k RSA Key.
  case keyAlgRsa2048 // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .keyAlgUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .keyAlgUnspecified
    case 1: self = .keyAlgRsa1024
    case 2: self = .keyAlgRsa2048
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .keyAlgUnspecified: return 0
    case .keyAlgRsa1024: return 1
    case .keyAlgRsa2048: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_ServiceAccountKeyAlgorithm: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_ServiceAccountKeyAlgorithm] = [
    .keyAlgUnspecified,
    .keyAlgRsa1024,
    .keyAlgRsa2048,
  ]
}

#endif  // swift(>=4.2)

/// Supported private key output formats.
public enum Google_Iam_Admin_V1_ServiceAccountPrivateKeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified. Equivalent to `TYPE_GOOGLE_CREDENTIALS_FILE`.
  case typeUnspecified // = 0

  /// PKCS12 format.
  /// The password for the PKCS12 file is `notasecret`.
  /// For more information, see https://tools.ietf.org/html/rfc7292.
  case typePkcs12File // = 1

  /// Google Credentials File format.
  case typeGoogleCredentialsFile // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .typeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeUnspecified
    case 1: self = .typePkcs12File
    case 2: self = .typeGoogleCredentialsFile
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .typeUnspecified: return 0
    case .typePkcs12File: return 1
    case .typeGoogleCredentialsFile: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_ServiceAccountPrivateKeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_ServiceAccountPrivateKeyType] = [
    .typeUnspecified,
    .typePkcs12File,
    .typeGoogleCredentialsFile,
  ]
}

#endif  // swift(>=4.2)

/// Supported public key output formats.
public enum Google_Iam_Admin_V1_ServiceAccountPublicKeyType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unspecified. Returns nothing here.
  case typeNone // = 0

  /// X509 PEM format.
  case typeX509PemFile // = 1

  /// Raw public key.
  case typeRawPublicKey // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .typeNone
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeNone
    case 1: self = .typeX509PemFile
    case 2: self = .typeRawPublicKey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .typeNone: return 0
    case .typeX509PemFile: return 1
    case .typeRawPublicKey: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_ServiceAccountPublicKeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_ServiceAccountPublicKeyType] = [
    .typeNone,
    .typeX509PemFile,
    .typeRawPublicKey,
  ]
}

#endif  // swift(>=4.2)

/// A view for Role objects.
public enum Google_Iam_Admin_V1_RoleView: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Omits the `included_permissions` field.
  /// This is the default value.
  case basic // = 0

  /// Returns all fields.
  case full // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .basic
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .basic
    case 1: self = .full
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .basic: return 0
    case .full: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_RoleView: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_RoleView] = [
    .basic,
    .full,
  ]
}

#endif  // swift(>=4.2)

/// A service account in the Identity and Access Management API.
///
/// To create a service account, specify the `project_id` and the `account_id`
/// for the account.  The `account_id` is unique within the project, and is used
/// to generate the service account email address and a stable
/// `unique_id`.
///
/// If the account already exists, the account's resource name is returned
/// in the format of projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}. The caller
/// can use the name in other methods to access the account.
///
/// All other methods can identify the service account using the format
/// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
/// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
/// the account. The `ACCOUNT` value can be the `email` address or the
/// `unique_id` of the service account.
public struct Google_Iam_Admin_V1_ServiceAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  ///
  /// Requests using `-` as a wildcard for the `PROJECT_ID` will infer the
  /// project from the `account` and the `ACCOUNT` value can be the `email`
  /// address or the `unique_id` of the service account.
  ///
  /// In responses the resource name will always be in the format
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  public var name: String = String()

  /// @OutputOnly The id of the project that owns the service account.
  public var projectID: String = String()

  /// @OutputOnly The unique and stable id of the service account.
  public var uniqueID: String = String()

  /// @OutputOnly The email address of the service account.
  public var email: String = String()

  /// Optional. A user-specified name for the service account.
  /// Must be less than or equal to 100 UTF-8 bytes.
  public var displayName: String = String()

  /// Optional. Note: `etag` is an inoperable legacy field that is only returned
  /// for backwards compatibility.
  public var etag: Data = Data()

  /// @OutputOnly. The OAuth2 client id for the service account.
  /// This is used in conjunction with the OAuth2 clientconfig API to make
  /// three legged OAuth2 (3LO) flows to access the data of Google users.
  public var oauth2ClientID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account create request.
public struct Google_Iam_Admin_V1_CreateServiceAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the project associated with the service
  /// accounts, such as `projects/my-project-123`.
  public var name: String = String()

  /// Required. The account id that is used to generate the service account
  /// email address and a stable unique id. It is unique within a project,
  /// must be 6-30 characters long, and match the regular expression
  /// `[a-z]([-a-z0-9]*[a-z0-9])` to comply with RFC1035.
  public var accountID: String = String()

  /// The [ServiceAccount][google.iam.admin.v1.ServiceAccount] resource to
  /// create. Currently, only the following values are user assignable:
  /// `display_name` and `description`.
  public var serviceAccount: Google_Iam_Admin_V1_ServiceAccount {
    get {return _serviceAccount ?? Google_Iam_Admin_V1_ServiceAccount()}
    set {_serviceAccount = newValue}
  }
  /// Returns true if `serviceAccount` has been explicitly set.
  public var hasServiceAccount: Bool {return self._serviceAccount != nil}
  /// Clears the value of `serviceAccount`. Subsequent reads from it will return its default value.
  public mutating func clearServiceAccount() {self._serviceAccount = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _serviceAccount: Google_Iam_Admin_V1_ServiceAccount? = nil
}

/// The service account list request.
public struct Google_Iam_Admin_V1_ListServiceAccountsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the project associated with the service
  /// accounts, such as `projects/my-project-123`.
  public var name: String = String()

  /// Optional limit on the number of service accounts to include in the
  /// response. Further accounts can subsequently be obtained by including the
  /// [ListServiceAccountsResponse.next_page_token][google.iam.admin.v1.ListServiceAccountsResponse.next_page_token]
  /// in a subsequent request.
  public var pageSize: Int32 = 0

  /// Optional pagination token returned in an earlier
  /// [ListServiceAccountsResponse.next_page_token][google.iam.admin.v1.ListServiceAccountsResponse.next_page_token].
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account list response.
public struct Google_Iam_Admin_V1_ListServiceAccountsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching service accounts.
  public var accounts: [Google_Iam_Admin_V1_ServiceAccount] = []

  /// To retrieve the next page of results, set
  /// [ListServiceAccountsRequest.page_token][google.iam.admin.v1.ListServiceAccountsRequest.page_token]
  /// to this value.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account get request.
public struct Google_Iam_Admin_V1_GetServiceAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account delete request.
public struct Google_Iam_Admin_V1_DeleteServiceAccountRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account keys list request.
public struct Google_Iam_Admin_V1_ListServiceAccountKeysRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  ///
  /// Using `-` as a wildcard for the `PROJECT_ID`, will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  /// Filters the types of keys the user wants to include in the list
  /// response. Duplicate key types are not allowed. If no key type
  /// is provided, all keys are returned.
  public var keyTypes: [Google_Iam_Admin_V1_ListServiceAccountKeysRequest.KeyType] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// `KeyType` filters to selectively retrieve certain varieties
  /// of keys.
  public enum KeyType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified key type. The presence of this in the
    /// message will immediately result in an error.
    case unspecified // = 0

    /// User-managed keys (managed and rotated by the user).
    case userManaged // = 1

    /// System-managed keys (managed and rotated by Google).
    case systemManaged // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .userManaged
      case 2: self = .systemManaged
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .userManaged: return 1
      case .systemManaged: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_ListServiceAccountKeysRequest.KeyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_ListServiceAccountKeysRequest.KeyType] = [
    .unspecified,
    .userManaged,
    .systemManaged,
  ]
}

#endif  // swift(>=4.2)

/// The service account keys list response.
public struct Google_Iam_Admin_V1_ListServiceAccountKeysResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The public keys for the service account.
  public var keys: [Google_Iam_Admin_V1_ServiceAccountKey] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account key get by id request.
public struct Google_Iam_Admin_V1_GetServiceAccountKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account key in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
  ///
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  /// The output format of the public key requested.
  /// X509_PEM is the default output format.
  public var publicKeyType: Google_Iam_Admin_V1_ServiceAccountPublicKeyType = .typeNone

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a service account key.
///
/// A service account has two sets of key-pairs: user-managed, and
/// system-managed.
///
/// User-managed key-pairs can be created and deleted by users.  Users are
/// responsible for rotating these keys periodically to ensure security of
/// their service accounts.  Users retain the private key of these key-pairs,
/// and Google retains ONLY the public key.
///
/// System-managed keys are automatically rotated by Google, and are used for
/// signing for a maximum of two weeks. The rotation process is probabilistic,
/// and usage of the new key will gradually ramp up and down over the key's
/// lifetime. We recommend caching the public key set for a service account for
/// no more than 24 hours to ensure you have access to the latest keys.
///
/// Public keys for all service accounts are also published at the OAuth2
/// Service Account API.
public struct Google_Iam_Admin_V1_ServiceAccountKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the service account key in the following format
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
  public var name: String = String()

  /// The output format for the private key.
  /// Only provided in `CreateServiceAccountKey` responses, not
  /// in `GetServiceAccountKey` or `ListServiceAccountKey` responses.
  ///
  /// Google never exposes system-managed private keys, and never retains
  /// user-managed private keys.
  public var privateKeyType: Google_Iam_Admin_V1_ServiceAccountPrivateKeyType = .typeUnspecified

  /// Specifies the algorithm (and possibly key size) for the key.
  public var keyAlgorithm: Google_Iam_Admin_V1_ServiceAccountKeyAlgorithm = .keyAlgUnspecified

  /// The private key data. Only provided in `CreateServiceAccountKey`
  /// responses. Make sure to keep the private key data secure because it
  /// allows for the assertion of the service account identity.
  /// When base64 decoded, the private key data can be used to authenticate with
  /// Google API client libraries and with
  /// <a href="/sdk/gcloud/reference/auth/activate-service-account">gcloud
  /// auth activate-service-account</a>.
  public var privateKeyData: Data = Data()

  /// The public key data. Only provided in `GetServiceAccountKey` responses.
  public var publicKeyData: Data = Data()

  /// The key can be used after this timestamp.
  public var validAfterTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validAfterTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validAfterTime = newValue}
  }
  /// Returns true if `validAfterTime` has been explicitly set.
  public var hasValidAfterTime: Bool {return self._validAfterTime != nil}
  /// Clears the value of `validAfterTime`. Subsequent reads from it will return its default value.
  public mutating func clearValidAfterTime() {self._validAfterTime = nil}

  /// The key can be used before this timestamp.
  /// For system-managed key pairs, this timestamp is the end time for the
  /// private key signing operation. The public key could still be used
  /// for verification for a few hours after this time.
  public var validBeforeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _validBeforeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_validBeforeTime = newValue}
  }
  /// Returns true if `validBeforeTime` has been explicitly set.
  public var hasValidBeforeTime: Bool {return self._validBeforeTime != nil}
  /// Clears the value of `validBeforeTime`. Subsequent reads from it will return its default value.
  public mutating func clearValidBeforeTime() {self._validBeforeTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _validAfterTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _validBeforeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The service account key create request.
public struct Google_Iam_Admin_V1_CreateServiceAccountKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  /// The output format of the private key. The default value is
  /// `TYPE_GOOGLE_CREDENTIALS_FILE`, which is the Google Credentials File
  /// format.
  public var privateKeyType: Google_Iam_Admin_V1_ServiceAccountPrivateKeyType = .typeUnspecified

  /// Which type of key and algorithm to use for the key.
  /// The default is currently a 2K RSA key.  However this may change in the
  /// future.
  public var keyAlgorithm: Google_Iam_Admin_V1_ServiceAccountKeyAlgorithm = .keyAlgUnspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account key delete request.
public struct Google_Iam_Admin_V1_DeleteServiceAccountKeyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account key in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}/keys/{key}`.
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account sign blob request.
public struct Google_Iam_Admin_V1_SignBlobRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  /// Required. The bytes to sign.
  public var bytesToSign: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account sign blob response.
public struct Google_Iam_Admin_V1_SignBlobResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the key used to sign the blob.
  public var keyID: String = String()

  /// The signed blob.
  public var signature: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account sign JWT request.
public struct Google_Iam_Admin_V1_SignJwtRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The resource name of the service account in the following format:
  /// `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  /// Using `-` as a wildcard for the `PROJECT_ID` will infer the project from
  /// the account. The `ACCOUNT` value can be the `email` address or the
  /// `unique_id` of the service account.
  public var name: String = String()

  /// Required. The JWT payload to sign, a JSON JWT Claim set.
  public var payload: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The service account sign JWT response.
public struct Google_Iam_Admin_V1_SignJwtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the key used to sign the JWT.
  public var keyID: String = String()

  /// The signed JWT.
  public var signedJwt: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A role in the Identity and Access Management API.
public struct Google_Iam_Admin_V1_Role {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the role.
  ///
  /// When Role is used in CreateRole, the role name must not be set.
  ///
  /// When Role is used in output and other input such as UpdateRole, the role
  /// name is the complete path, e.g., roles/logging.viewer for predefined roles
  /// and organizations/{ORGANIZATION_ID}/roles/logging.viewer for custom roles.
  public var name: String = String()

  /// Optional. A human-readable title for the role.  Typically this
  /// is limited to 100 UTF-8 bytes.
  public var title: String = String()

  /// Optional. A human-readable description for the role.
  public var description_p: String = String()

  /// The names of the permissions this role grants when bound in an IAM policy.
  public var includedPermissions: [String] = []

  /// The current launch stage of the role. If the `ALPHA` launch stage has been
  /// selected for a role, the `stage` field will not be included in the
  /// returned definition for the role.
  public var stage: Google_Iam_Admin_V1_Role.RoleLaunchStage = .alpha

  /// Used to perform a consistent read-modify-write.
  public var etag: Data = Data()

  /// The current deleted state of the role. This field is read only.
  /// It will be ignored in calls to CreateRole and UpdateRole.
  public var deleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A stage representing a role's lifecycle phase.
  public enum RoleLaunchStage: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The user has indicated this role is currently in an Alpha phase. If this
    /// launch stage is selected, the `stage` field will not be included when
    /// requesting the definition for a given role.
    case alpha // = 0

    /// The user has indicated this role is currently in a Beta phase.
    case beta // = 1

    /// The user has indicated this role is generally available.
    case ga // = 2

    /// The user has indicated this role is being deprecated.
    case deprecated // = 4

    /// This role is disabled and will not contribute permissions to any members
    /// it is granted to in policies.
    case disabled // = 5

    /// The user has indicated this role is currently in an EAP phase.
    case eap // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .alpha
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .alpha
      case 1: self = .beta
      case 2: self = .ga
      case 4: self = .deprecated
      case 5: self = .disabled
      case 6: self = .eap
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .alpha: return 0
      case .beta: return 1
      case .ga: return 2
      case .deprecated: return 4
      case .disabled: return 5
      case .eap: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_Role.RoleLaunchStage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_Role.RoleLaunchStage] = [
    .alpha,
    .beta,
    .ga,
    .deprecated,
    .disabled,
    .eap,
  ]
}

#endif  // swift(>=4.2)

/// The grantable role query request.
public struct Google_Iam_Admin_V1_QueryGrantableRolesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name to query from the list of grantable roles.
  ///
  /// The name follows the Google Cloud Platform resource format.
  /// For example, a Cloud Platform project with id `my-project` will be named
  /// `//cloudresourcemanager.googleapis.com/projects/my-project`.
  public var fullResourceName: String = String()

  public var view: Google_Iam_Admin_V1_RoleView = .basic

  /// Optional limit on the number of roles to include in the response.
  public var pageSize: Int32 = 0

  /// Optional pagination token returned in an earlier
  /// QueryGrantableRolesResponse.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The grantable role query response.
public struct Google_Iam_Admin_V1_QueryGrantableRolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching roles.
  public var roles: [Google_Iam_Admin_V1_Role] = []

  /// To retrieve the next page of results, set
  /// `QueryGrantableRolesRequest.page_token` to this value.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request to get all roles defined under a resource.
public struct Google_Iam_Admin_V1_ListRolesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `parent` parameter's value depends on the target resource for the
  /// request, namely
  /// [`roles`](/iam/reference/rest/v1/roles),
  /// [`projects`](/iam/reference/rest/v1/projects.roles), or
  /// [`organizations`](/iam/reference/rest/v1/organizations.roles). Each
  /// resource type's `parent` value format is described below:
  ///
  /// * [`roles.list()`](/iam/reference/rest/v1/roles/list): An empty string.
  ///   This method doesn't require a resource; it simply returns all
  ///   [predefined roles](/iam/docs/understanding-roles#predefined_roles) in
  ///   Cloud IAM. Example request URL:
  ///   `https://iam.googleapis.com/v1/roles`
  ///
  /// * [`projects.roles.list()`](/iam/reference/rest/v1/projects.roles/list):
  ///   `projects/{PROJECT_ID}`. This method lists all project-level
  ///   [custom roles](/iam/docs/understanding-custom-roles).
  ///   Example request URL:
  ///   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles`
  ///
  /// * [`organizations.roles.list()`](/iam/reference/rest/v1/organizations.roles/list):
  ///   `organizations/{ORGANIZATION_ID}`. This method lists all
  ///   organization-level [custom roles](/iam/docs/understanding-custom-roles).
  ///   Example request URL:
  ///   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles`
  ///
  /// Note: Wildcard (*) values are invalid; you must specify a complete project
  /// ID or organization ID.
  public var parent: String = String()

  /// Optional limit on the number of roles to include in the response.
  public var pageSize: Int32 = 0

  /// Optional pagination token returned in an earlier ListRolesResponse.
  public var pageToken: String = String()

  /// Optional view for the returned Role objects. When `FULL` is specified,
  /// the `includedPermissions` field is returned, which includes a list of all
  /// permissions in the role. The default value is `BASIC`, which does not
  /// return the `includedPermissions` field.
  public var view: Google_Iam_Admin_V1_RoleView = .basic

  /// Include Roles that have been deleted.
  public var showDeleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response containing the roles defined under a resource.
public struct Google_Iam_Admin_V1_ListRolesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Roles defined on this resource.
  public var roles: [Google_Iam_Admin_V1_Role] = []

  /// To retrieve the next page of results, set
  /// `ListRolesRequest.page_token` to this value.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request to get the definition of an existing role.
public struct Google_Iam_Admin_V1_GetRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `name` parameter's value depends on the target resource for the
  /// request, namely
  /// [`roles`](/iam/reference/rest/v1/roles),
  /// [`projects`](/iam/reference/rest/v1/projects.roles), or
  /// [`organizations`](/iam/reference/rest/v1/organizations.roles). Each
  /// resource type's `name` value format is described below:
  ///
  /// * [`roles.get()`](/iam/reference/rest/v1/roles/get): `roles/{ROLE_NAME}`.
  ///   This method returns results from all
  ///   [predefined roles](/iam/docs/understanding-roles#predefined_roles) in
  ///   Cloud IAM. Example request URL:
  ///   `https://iam.googleapis.com/v1/roles/{ROLE_NAME}`
  ///
  /// * [`projects.roles.get()`](/iam/reference/rest/v1/projects.roles/get):
  ///   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method returns only
  ///   [custom roles](/iam/docs/understanding-custom-roles) that have been
  ///   created at the project level. Example request URL:
  ///   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// * [`organizations.roles.get()`](/iam/reference/rest/v1/organizations.roles/get):
  ///   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
  ///   returns only [custom roles](/iam/docs/understanding-custom-roles) that
  ///   have been created at the organization level. Example request URL:
  ///   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// Note: Wildcard (*) values are invalid; you must specify a complete project
  /// ID or organization ID.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request to create a new role.
public struct Google_Iam_Admin_V1_CreateRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `parent` parameter's value depends on the target resource for the
  /// request, namely
  /// [`projects`](/iam/reference/rest/v1/projects.roles) or
  /// [`organizations`](/iam/reference/rest/v1/organizations.roles). Each
  /// resource type's `parent` value format is described below:
  ///
  /// * [`projects.roles.create()`](/iam/reference/rest/v1/projects.roles/create):
  ///   `projects/{PROJECT_ID}`. This method creates project-level
  ///   [custom roles](/iam/docs/understanding-custom-roles).
  ///   Example request URL:
  ///   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles`
  ///
  /// * [`organizations.roles.create()`](/iam/reference/rest/v1/organizations.roles/create):
  ///   `organizations/{ORGANIZATION_ID}`. This method creates organization-level
  ///   [custom roles](/iam/docs/understanding-custom-roles). Example request
  ///   URL:
  ///   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles`
  ///
  /// Note: Wildcard (*) values are invalid; you must specify a complete project
  /// ID or organization ID.
  public var parent: String = String()

  /// The role ID to use for this role.
  public var roleID: String = String()

  /// The Role resource to create.
  public var role: Google_Iam_Admin_V1_Role {
    get {return _role ?? Google_Iam_Admin_V1_Role()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Google_Iam_Admin_V1_Role? = nil
}

/// The request to update a role.
public struct Google_Iam_Admin_V1_UpdateRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `name` parameter's value depends on the target resource for the
  /// request, namely
  /// [`projects`](/iam/reference/rest/v1/projects.roles) or
  /// [`organizations`](/iam/reference/rest/v1/organizations.roles). Each
  /// resource type's `name` value format is described below:
  ///
  /// * [`projects.roles.patch()`](/iam/reference/rest/v1/projects.roles/patch):
  ///   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method updates only
  ///   [custom roles](/iam/docs/understanding-custom-roles) that have been
  ///   created at the project level. Example request URL:
  ///   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// * [`organizations.roles.patch()`](/iam/reference/rest/v1/organizations.roles/patch):
  ///   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
  ///   updates only [custom roles](/iam/docs/understanding-custom-roles) that
  ///   have been created at the organization level. Example request URL:
  ///   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// Note: Wildcard (*) values are invalid; you must specify a complete project
  /// ID or organization ID.
  public var name: String = String()

  /// The updated role.
  public var role: Google_Iam_Admin_V1_Role {
    get {return _role ?? Google_Iam_Admin_V1_Role()}
    set {_role = newValue}
  }
  /// Returns true if `role` has been explicitly set.
  public var hasRole: Bool {return self._role != nil}
  /// Clears the value of `role`. Subsequent reads from it will return its default value.
  public mutating func clearRole() {self._role = nil}

  /// A mask describing which fields in the Role have changed.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _role: Google_Iam_Admin_V1_Role? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request to delete an existing role.
public struct Google_Iam_Admin_V1_DeleteRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `name` parameter's value depends on the target resource for the
  /// request, namely
  /// [`projects`](/iam/reference/rest/v1/projects.roles) or
  /// [`organizations`](/iam/reference/rest/v1/organizations.roles). Each
  /// resource type's `name` value format is described below:
  ///
  /// * [`projects.roles.delete()`](/iam/reference/rest/v1/projects.roles/delete):
  ///   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method deletes only
  ///   [custom roles](/iam/docs/understanding-custom-roles) that have been
  ///   created at the project level. Example request URL:
  ///   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// * [`organizations.roles.delete()`](/iam/reference/rest/v1/organizations.roles/delete):
  ///   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
  ///   deletes only [custom roles](/iam/docs/understanding-custom-roles) that
  ///   have been created at the organization level. Example request URL:
  ///   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// Note: Wildcard (*) values are invalid; you must specify a complete project
  /// ID or organization ID.
  public var name: String = String()

  /// Used to perform a consistent read-modify-write.
  public var etag: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request to undelete an existing role.
public struct Google_Iam_Admin_V1_UndeleteRoleRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `name` parameter's value depends on the target resource for the
  /// request, namely
  /// [`projects`](/iam/reference/rest/v1/projects.roles) or
  /// [`organizations`](/iam/reference/rest/v1/organizations.roles). Each
  /// resource type's `name` value format is described below:
  ///
  /// * [`projects.roles.undelete()`](/iam/reference/rest/v1/projects.roles/undelete):
  ///   `projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`. This method undeletes
  ///   only [custom roles](/iam/docs/understanding-custom-roles) that have been
  ///   created at the project level. Example request URL:
  ///   `https://iam.googleapis.com/v1/projects/{PROJECT_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// * [`organizations.roles.undelete()`](/iam/reference/rest/v1/organizations.roles/undelete):
  ///   `organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`. This method
  ///   undeletes only [custom roles](/iam/docs/understanding-custom-roles) that
  ///   have been created at the organization level. Example request URL:
  ///   `https://iam.googleapis.com/v1/organizations/{ORGANIZATION_ID}/roles/{CUSTOM_ROLE_ID}`
  ///
  /// Note: Wildcard (*) values are invalid; you must specify a complete project
  /// ID or organization ID.
  public var name: String = String()

  /// Used to perform a consistent read-modify-write.
  public var etag: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A permission which can be included by a role.
public struct Google_Iam_Admin_V1_Permission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this Permission.
  public var name: String = String()

  /// The title of this Permission.
  public var title: String = String()

  /// A brief description of what this Permission is used for.
  /// This permission can ONLY be used in predefined roles.
  public var description_p: String = String()

  /// This permission can ONLY be used in predefined roles.
  public var onlyInPredefinedRoles: Bool = false

  /// The current launch stage of the permission.
  public var stage: Google_Iam_Admin_V1_Permission.PermissionLaunchStage = .alpha

  /// The current custom role support level.
  public var customRolesSupportLevel: Google_Iam_Admin_V1_Permission.CustomRolesSupportLevel = .supported

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A stage representing a permission's lifecycle phase.
  public enum PermissionLaunchStage: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The permission is currently in an alpha phase.
    case alpha // = 0

    /// The permission is currently in a beta phase.
    case beta // = 1

    /// The permission is generally available.
    case ga // = 2

    /// The permission is being deprecated.
    case deprecated // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .alpha
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .alpha
      case 1: self = .beta
      case 2: self = .ga
      case 3: self = .deprecated
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .alpha: return 0
      case .beta: return 1
      case .ga: return 2
      case .deprecated: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The state of the permission with regards to custom roles.
  public enum CustomRolesSupportLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Permission is fully supported for custom role use.
    case supported // = 0

    /// Permission is being tested to check custom role compatibility.
    case testing // = 1

    /// Permission is not supported for custom role use.
    case notSupported // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .supported
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .supported
      case 1: self = .testing
      case 2: self = .notSupported
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .supported: return 0
      case .testing: return 1
      case .notSupported: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Iam_Admin_V1_Permission.PermissionLaunchStage: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_Permission.PermissionLaunchStage] = [
    .alpha,
    .beta,
    .ga,
    .deprecated,
  ]
}

extension Google_Iam_Admin_V1_Permission.CustomRolesSupportLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_Admin_V1_Permission.CustomRolesSupportLevel] = [
    .supported,
    .testing,
    .notSupported,
  ]
}

#endif  // swift(>=4.2)

/// A request to get permissions which can be tested on a resource.
public struct Google_Iam_Admin_V1_QueryTestablePermissionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The full resource name to query from the list of testable
  /// permissions.
  ///
  /// The name follows the Google Cloud Platform resource format.
  /// For example, a Cloud Platform project with id `my-project` will be named
  /// `//cloudresourcemanager.googleapis.com/projects/my-project`.
  public var fullResourceName: String = String()

  /// Optional limit on the number of permissions to include in the response.
  public var pageSize: Int32 = 0

  /// Optional pagination token returned in an earlier
  /// QueryTestablePermissionsRequest.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response containing permissions which can be tested on a resource.
public struct Google_Iam_Admin_V1_QueryTestablePermissionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Permissions testable on the requested resource.
  public var permissions: [Google_Iam_Admin_V1_Permission] = []

  /// To retrieve the next page of results, set
  /// `QueryTestableRolesRequest.page_token` to this value.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.iam.admin.v1"

extension Google_Iam_Admin_V1_ServiceAccountKeyAlgorithm: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_ALG_UNSPECIFIED"),
    1: .same(proto: "KEY_ALG_RSA_1024"),
    2: .same(proto: "KEY_ALG_RSA_2048"),
  ]
}

extension Google_Iam_Admin_V1_ServiceAccountPrivateKeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "TYPE_PKCS12_FILE"),
    2: .same(proto: "TYPE_GOOGLE_CREDENTIALS_FILE"),
  ]
}

extension Google_Iam_Admin_V1_ServiceAccountPublicKeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_NONE"),
    1: .same(proto: "TYPE_X509_PEM_FILE"),
    2: .same(proto: "TYPE_RAW_PUBLIC_KEY"),
  ]
}

extension Google_Iam_Admin_V1_RoleView: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "BASIC"),
    1: .same(proto: "FULL"),
  ]
}

extension Google_Iam_Admin_V1_ServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceAccount"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "project_id"),
    4: .standard(proto: "unique_id"),
    5: .same(proto: "email"),
    6: .standard(proto: "display_name"),
    7: .same(proto: "etag"),
    9: .standard(proto: "oauth2_client_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.uniqueID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.etag) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.oauth2ClientID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 2)
    }
    if !self.uniqueID.isEmpty {
      try visitor.visitSingularStringField(value: self.uniqueID, fieldNumber: 4)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 5)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 6)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularBytesField(value: self.etag, fieldNumber: 7)
    }
    if !self.oauth2ClientID.isEmpty {
      try visitor.visitSingularStringField(value: self.oauth2ClientID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ServiceAccount, rhs: Google_Iam_Admin_V1_ServiceAccount) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.uniqueID != rhs.uniqueID {return false}
    if lhs.email != rhs.email {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.oauth2ClientID != rhs.oauth2ClientID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_CreateServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateServiceAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "account_id"),
    3: .standard(proto: "service_account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serviceAccount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 2)
    }
    if let v = self._serviceAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_CreateServiceAccountRequest, rhs: Google_Iam_Admin_V1_CreateServiceAccountRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.accountID != rhs.accountID {return false}
    if lhs._serviceAccount != rhs._serviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ListServiceAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListServiceAccountsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ListServiceAccountsRequest, rhs: Google_Iam_Admin_V1_ListServiceAccountsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ListServiceAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListServiceAccountsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accounts"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.accounts) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accounts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accounts, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ListServiceAccountsResponse, rhs: Google_Iam_Admin_V1_ListServiceAccountsResponse) -> Bool {
    if lhs.accounts != rhs.accounts {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_GetServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_GetServiceAccountRequest, rhs: Google_Iam_Admin_V1_GetServiceAccountRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_DeleteServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteServiceAccountRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_DeleteServiceAccountRequest, rhs: Google_Iam_Admin_V1_DeleteServiceAccountRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ListServiceAccountKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListServiceAccountKeysRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "key_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.keyTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.keyTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.keyTypes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ListServiceAccountKeysRequest, rhs: Google_Iam_Admin_V1_ListServiceAccountKeysRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.keyTypes != rhs.keyTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ListServiceAccountKeysRequest.KeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "KEY_TYPE_UNSPECIFIED"),
    1: .same(proto: "USER_MANAGED"),
    2: .same(proto: "SYSTEM_MANAGED"),
  ]
}

extension Google_Iam_Admin_V1_ListServiceAccountKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListServiceAccountKeysResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ListServiceAccountKeysResponse, rhs: Google_Iam_Admin_V1_ListServiceAccountKeysResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_GetServiceAccountKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceAccountKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "public_key_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.publicKeyType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.publicKeyType != .typeNone {
      try visitor.visitSingularEnumField(value: self.publicKeyType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_GetServiceAccountKeyRequest, rhs: Google_Iam_Admin_V1_GetServiceAccountKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.publicKeyType != rhs.publicKeyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ServiceAccountKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceAccountKey"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "private_key_type"),
    8: .standard(proto: "key_algorithm"),
    3: .standard(proto: "private_key_data"),
    7: .standard(proto: "public_key_data"),
    4: .standard(proto: "valid_after_time"),
    5: .standard(proto: "valid_before_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.privateKeyType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.privateKeyData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._validAfterTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._validBeforeTime) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.publicKeyData) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.keyAlgorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.privateKeyType != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.privateKeyType, fieldNumber: 2)
    }
    if !self.privateKeyData.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKeyData, fieldNumber: 3)
    }
    if let v = self._validAfterTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._validBeforeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.publicKeyData.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKeyData, fieldNumber: 7)
    }
    if self.keyAlgorithm != .keyAlgUnspecified {
      try visitor.visitSingularEnumField(value: self.keyAlgorithm, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ServiceAccountKey, rhs: Google_Iam_Admin_V1_ServiceAccountKey) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.privateKeyType != rhs.privateKeyType {return false}
    if lhs.keyAlgorithm != rhs.keyAlgorithm {return false}
    if lhs.privateKeyData != rhs.privateKeyData {return false}
    if lhs.publicKeyData != rhs.publicKeyData {return false}
    if lhs._validAfterTime != rhs._validAfterTime {return false}
    if lhs._validBeforeTime != rhs._validBeforeTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_CreateServiceAccountKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateServiceAccountKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "private_key_type"),
    3: .standard(proto: "key_algorithm"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.privateKeyType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.keyAlgorithm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.privateKeyType != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.privateKeyType, fieldNumber: 2)
    }
    if self.keyAlgorithm != .keyAlgUnspecified {
      try visitor.visitSingularEnumField(value: self.keyAlgorithm, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_CreateServiceAccountKeyRequest, rhs: Google_Iam_Admin_V1_CreateServiceAccountKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.privateKeyType != rhs.privateKeyType {return false}
    if lhs.keyAlgorithm != rhs.keyAlgorithm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_DeleteServiceAccountKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteServiceAccountKeyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_DeleteServiceAccountKeyRequest, rhs: Google_Iam_Admin_V1_DeleteServiceAccountKeyRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_SignBlobRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignBlobRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "bytes_to_sign"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.bytesToSign) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.bytesToSign.isEmpty {
      try visitor.visitSingularBytesField(value: self.bytesToSign, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_SignBlobRequest, rhs: Google_Iam_Admin_V1_SignBlobRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.bytesToSign != rhs.bytesToSign {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_SignBlobResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignBlobResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_SignBlobResponse, rhs: Google_Iam_Admin_V1_SignBlobResponse) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_SignJwtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignJwtRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "payload"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.payload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.payload.isEmpty {
      try visitor.visitSingularStringField(value: self.payload, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_SignJwtRequest, rhs: Google_Iam_Admin_V1_SignJwtRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_SignJwtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignJwtResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_id"),
    2: .standard(proto: "signed_jwt"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.signedJwt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.signedJwt.isEmpty {
      try visitor.visitSingularStringField(value: self.signedJwt, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_SignJwtResponse, rhs: Google_Iam_Admin_V1_SignJwtResponse) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.signedJwt != rhs.signedJwt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_Role: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Role"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    7: .standard(proto: "included_permissions"),
    8: .same(proto: "stage"),
    9: .same(proto: "etag"),
    11: .same(proto: "deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.includedPermissions) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.etag) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.deleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.includedPermissions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.includedPermissions, fieldNumber: 7)
    }
    if self.stage != .alpha {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 8)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularBytesField(value: self.etag, fieldNumber: 9)
    }
    if self.deleted != false {
      try visitor.visitSingularBoolField(value: self.deleted, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_Role, rhs: Google_Iam_Admin_V1_Role) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.includedPermissions != rhs.includedPermissions {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.deleted != rhs.deleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_Role.RoleLaunchStage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALPHA"),
    1: .same(proto: "BETA"),
    2: .same(proto: "GA"),
    4: .same(proto: "DEPRECATED"),
    5: .same(proto: "DISABLED"),
    6: .same(proto: "EAP"),
  ]
}

extension Google_Iam_Admin_V1_QueryGrantableRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGrantableRolesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_resource_name"),
    2: .same(proto: "view"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 1)
    }
    if self.view != .basic {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_QueryGrantableRolesRequest, rhs: Google_Iam_Admin_V1_QueryGrantableRolesRequest) -> Bool {
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs.view != rhs.view {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_QueryGrantableRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryGrantableRolesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_QueryGrantableRolesResponse, rhs: Google_Iam_Admin_V1_QueryGrantableRolesResponse) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ListRolesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRolesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "view"),
    6: .standard(proto: "show_deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.showDeleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.view != .basic {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 4)
    }
    if self.showDeleted != false {
      try visitor.visitSingularBoolField(value: self.showDeleted, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ListRolesRequest, rhs: Google_Iam_Admin_V1_ListRolesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.view != rhs.view {return false}
    if lhs.showDeleted != rhs.showDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_ListRolesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListRolesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "roles"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.roles) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.roles, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_ListRolesResponse, rhs: Google_Iam_Admin_V1_ListRolesResponse) -> Bool {
    if lhs.roles != rhs.roles {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_GetRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_GetRoleRequest, rhs: Google_Iam_Admin_V1_GetRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_CreateRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "role_id"),
    3: .same(proto: "role"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.roleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.roleID.isEmpty {
      try visitor.visitSingularStringField(value: self.roleID, fieldNumber: 2)
    }
    if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_CreateRoleRequest, rhs: Google_Iam_Admin_V1_CreateRoleRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.roleID != rhs.roleID {return false}
    if lhs._role != rhs._role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_UpdateRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "role"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._role) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._role {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_UpdateRoleRequest, rhs: Google_Iam_Admin_V1_UpdateRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._role != rhs._role {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_DeleteRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "etag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.etag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularBytesField(value: self.etag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_DeleteRoleRequest, rhs: Google_Iam_Admin_V1_DeleteRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_UndeleteRoleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UndeleteRoleRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "etag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.etag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.etag.isEmpty {
      try visitor.visitSingularBytesField(value: self.etag, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_UndeleteRoleRequest, rhs: Google_Iam_Admin_V1_UndeleteRoleRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.etag != rhs.etag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .standard(proto: "only_in_predefined_roles"),
    5: .same(proto: "stage"),
    6: .standard(proto: "custom_roles_support_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.onlyInPredefinedRoles) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.customRolesSupportLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.onlyInPredefinedRoles != false {
      try visitor.visitSingularBoolField(value: self.onlyInPredefinedRoles, fieldNumber: 4)
    }
    if self.stage != .alpha {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 5)
    }
    if self.customRolesSupportLevel != .supported {
      try visitor.visitSingularEnumField(value: self.customRolesSupportLevel, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_Permission, rhs: Google_Iam_Admin_V1_Permission) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.onlyInPredefinedRoles != rhs.onlyInPredefinedRoles {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.customRolesSupportLevel != rhs.customRolesSupportLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_Permission.PermissionLaunchStage: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALPHA"),
    1: .same(proto: "BETA"),
    2: .same(proto: "GA"),
    3: .same(proto: "DEPRECATED"),
  ]
}

extension Google_Iam_Admin_V1_Permission.CustomRolesSupportLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUPPORTED"),
    1: .same(proto: "TESTING"),
    2: .same(proto: "NOT_SUPPORTED"),
  ]
}

extension Google_Iam_Admin_V1_QueryTestablePermissionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTestablePermissionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "full_resource_name"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullResourceName) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullResourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullResourceName, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_QueryTestablePermissionsRequest, rhs: Google_Iam_Admin_V1_QueryTestablePermissionsRequest) -> Bool {
    if lhs.fullResourceName != rhs.fullResourceName {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_Admin_V1_QueryTestablePermissionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryTestablePermissionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "permissions"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_Admin_V1_QueryTestablePermissionsResponse, rhs: Google_Iam_Admin_V1_QueryTestablePermissionsResponse) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/iam/v1beta/workload_identity_pool.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents a collection of external workload identities. You can define IAM
/// policies to grant these identities access to Google Cloud resources.
public struct Google_Iam_V1beta_WorkloadIdentityPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the pool.
  public var name: String = String()

  /// A display name for the pool. Cannot exceed 32 characters.
  public var displayName: String = String()

  /// A description of the pool. Cannot exceed 256 characters.
  public var description_p: String = String()

  /// Output only. The state of the pool.
  public var state: Google_Iam_V1beta_WorkloadIdentityPool.State = .unspecified

  /// Whether the pool is disabled. You cannot use a disabled pool to exchange
  /// tokens, or use existing tokens to access resources. If
  /// the pool is re-enabled, existing tokens grant access again.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current state of the pool.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// State unspecified.
    case unspecified // = 0

    /// The pool is active, and may be used in Google Cloud policies.
    case active // = 1

    /// The pool is soft-deleted. Soft-deleted pools are permanently deleted
    /// after approximately 30 days. You can restore a soft-deleted pool using
    /// [UndeleteWorkloadIdentityPool][google.iam.v1beta.WorkloadIdentityPools.UndeleteWorkloadIdentityPool].
    ///
    /// You cannot reuse the ID of a soft-deleted pool until it is permanently
    /// deleted.
    ///
    /// While a pool is deleted, you cannot use it to exchange tokens, or use
    /// existing tokens to access resources. If the pool is undeleted, existing
    /// tokens grant access again.
    case deleted // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .deleted: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Iam_V1beta_WorkloadIdentityPool.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_V1beta_WorkloadIdentityPool.State] = [
    .unspecified,
    .active,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

/// A configuration for an external identity provider.
public struct Google_Iam_V1beta_WorkloadIdentityPoolProvider {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The resource name of the provider.
  public var name: String = String()

  /// A display name for the provider. Cannot exceed 32 characters.
  public var displayName: String = String()

  /// A description for the provider. Cannot exceed 256 characters.
  public var description_p: String = String()

  /// Output only. The state of the provider.
  public var state: Google_Iam_V1beta_WorkloadIdentityPoolProvider.State = .unspecified

  /// Whether the provider is disabled. You cannot use a disabled provider to
  /// exchange tokens. However, existing tokens still grant access.
  public var disabled: Bool = false

  /// Maps attributes from authentication credentials issued by an external
  /// identity provider to Google Cloud attributes, such as `subject` and
  /// `segment`.
  ///
  /// Each key must be a string specifying the Google Cloud IAM attribute to
  /// map to.
  ///
  /// The following keys are supported:
  ///
  /// * `google.subject`: The principal IAM is authenticating. You can reference
  ///                     this value in IAM bindings. This is also the
  ///                     subject that appears in Cloud Logging logs.
  ///                     Cannot exceed 127 characters.
  ///
  /// * `google.groups`: Groups the external identity belongs to. You can grant
  ///                    groups access to resources using an IAM `principalSet`
  ///                    binding; access applies to all members of the group.
  ///
  /// You can also provide custom attributes by specifying
  /// `attribute.{custom_attribute}`, where `{custom_attribute}` is the name of
  /// the custom attribute to be mapped. You can define a maximum of 50 custom
  /// attributes. The maximum length of a mapped attribute key is
  /// 100 characters, and the key may only contain the characters [a-z0-9_].
  ///
  /// You can reference these attributes in IAM policies to define fine-grained
  /// access for a workload to Google Cloud resources. For example:
  ///
  /// * `google.subject`:
  /// `principal://iam.googleapis.com/projects/{project}/locations/{location}/workloadIdentityPools/{pool}/subject/{value}`
  ///
  /// * `google.groups`:
  /// `principalSet://iam.googleapis.com/projects/{project}/locations/{location}/workloadIdentityPools/{pool}/group/{value}`
  ///
  /// * `attribute.{custom_attribute}`:
  /// `principalSet://iam.googleapis.com/projects/{project}/locations/{location}/workloadIdentityPools/{pool}/attribute.{custom_attribute}/{value}`
  ///
  /// Each value must be a [Common Expression Language]
  /// (https://opensource.google/projects/cel) function that maps an
  /// identity provider credential to the normalized attribute specified by the
  /// corresponding map key.
  ///
  /// You can use the `assertion` keyword in the expression to access a JSON
  /// representation of the authentication credential issued by the provider.
  ///
  /// The maximum length of an attribute mapping expression is 2048 characters.
  /// When evaluated, the total size of all mapped attributes must not exceed
  /// 8KB.
  ///
  /// For AWS providers, the following rules apply:
  ///
  /// - If no attribute mapping is defined, the following default mapping
  ///   applies:
  ///
  ///   ```
  ///   {
  ///     "google.subject":"assertion.arn",
  ///     "attribute.aws_role":
  ///         "assertion.arn.contains('assumed-role')"
  ///         " ? assertion.arn.extract('{account_arn}assumed-role/')"
  ///         "   + 'assumed-role/'"
  ///         "   + assertion.arn.extract('assumed-role/{role_name}/')"
  ///         " : assertion.arn",
  ///   }
  ///   ```
  ///
  /// - If any custom attribute mappings are defined, they must include a mapping
  ///   to the `google.subject` attribute.
  ///
  ///
  /// For OIDC providers, the following rules apply:
  ///
  /// - Custom attribute mappings must be defined, and must include a mapping to
  ///   the `google.subject` attribute. For example, the following maps the
  ///   `sub` claim of the incoming credential to the `subject` attribute on
  ///   a Google token.
  ///
  ///   ```
  ///   {"google.subject": "assertion.sub"}
  ///   ```
  public var attributeMapping: Dictionary<String,String> = [:]

  /// [A Common Expression Language](https://opensource.google/projects/cel)
  /// expression, in plain text, to restrict what otherwise valid authentication
  /// credentials issued by the provider should not be accepted.
  ///
  /// The expression must output a boolean representing whether to allow the
  /// federation.
  ///
  /// The following keywords may be referenced in the expressions:
  ///
  /// * `assertion`: JSON representing the authentication credential issued by
  ///                the provider.
  /// * `google`: The Google attributes mapped from the assertion in the
  ///             `attribute_mappings`.
  /// * `attribute`: The custom attributes mapped from the assertion in the
  ///                `attribute_mappings`.
  ///
  /// The maximum length of the attribute condition expression is 4096
  /// characters. If unspecified, all valid authentication credential are
  /// accepted.
  ///
  /// The following example shows how to only allow credentials with a mapped
  /// `google.groups` value of `admins`:
  ///
  /// ```
  /// "'admins' in google.groups"
  /// ```
  public var attributeCondition: String = String()

  /// Identity provider configuration types.
  public var providerConfig: Google_Iam_V1beta_WorkloadIdentityPoolProvider.OneOf_ProviderConfig? = nil

  /// An Amazon Web Services identity provider.
  public var aws: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws {
    get {
      if case .aws(let v)? = providerConfig {return v}
      return Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws()
    }
    set {providerConfig = .aws(newValue)}
  }

  /// An OpenId Connect 1.0 identity provider.
  public var oidc: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc {
    get {
      if case .oidc(let v)? = providerConfig {return v}
      return Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc()
    }
    set {providerConfig = .oidc(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Identity provider configuration types.
  public enum OneOf_ProviderConfig: Equatable {
    /// An Amazon Web Services identity provider.
    case aws(Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws)
    /// An OpenId Connect 1.0 identity provider.
    case oidc(Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider.OneOf_ProviderConfig, rhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider.OneOf_ProviderConfig) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.aws, .aws): return {
        guard case .aws(let l) = lhs, case .aws(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oidc, .oidc): return {
        guard case .oidc(let l) = lhs, case .oidc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The current state of the provider.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// State unspecified.
    case unspecified // = 0

    /// The provider is active, and may be used to validate authentication
    /// credentials.
    case active // = 1

    /// The provider is soft-deleted. Soft-deleted providers are permanently
    /// deleted after approximately 30 days. You can restore a soft-deleted
    /// provider using
    /// [UndeleteWorkloadIdentityPoolProvider][google.iam.v1beta.WorkloadIdentityPools.UndeleteWorkloadIdentityPoolProvider].
    ///
    /// You cannot reuse the ID of a soft-deleted provider until it is
    /// permanently deleted.
    case deleted // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .active
      case 2: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .active: return 1
      case .deleted: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Represents an Amazon Web Services identity provider.
  public struct Aws {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The AWS account ID.
    public var accountID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Represents an OpenId Connect 1.0 identity provider.
  public struct Oidc {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The OIDC issuer URL.
    public var issuerUri: String = String()

    /// Acceptable values for the `aud` field (audience) in the OIDC token. Token
    /// exchange requests are rejected if the token audience does not match one
    /// of the configured values. Each audience may be at most 256 characters. A
    /// maximum of 10 audiences may be configured.
    ///
    /// If this list is empty, the OIDC token audience must be equal to
    /// the full canonical resource name of the WorkloadIdentityPoolProvider,
    /// with or without the HTTPS prefix. For example:
    ///
    /// ```
    /// //iam.googleapis.com/projects/<project-number>/locations/<location>/workloadIdentityPools/<pool-id>/providers/<provider-id>
    /// https://iam.googleapis.com/projects/<project-number>/locations/<location>/workloadIdentityPools/<pool-id>/providers/<provider-id>
    /// ```
    public var allowedAudiences: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Iam_V1beta_WorkloadIdentityPoolProvider.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Iam_V1beta_WorkloadIdentityPoolProvider.State] = [
    .unspecified,
    .active,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

/// Request message for ListWorkloadIdentityPools.
public struct Google_Iam_V1beta_ListWorkloadIdentityPoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource to list pools for.
  public var parent: String = String()

  /// The maximum number of pools to return.
  /// If unspecified, at most 50 pools are returned.
  /// The maximum value is 1000; values above are 1000 truncated to 1000.
  public var pageSize: Int32 = 0

  /// A page token, received from a previous `ListWorkloadIdentityPools`
  /// call. Provide this to retrieve the subsequent page.
  public var pageToken: String = String()

  /// Whether to return soft-deleted pools.
  public var showDeleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for ListWorkloadIdentityPools.
public struct Google_Iam_V1beta_ListWorkloadIdentityPoolsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of pools.
  public var workloadIdentityPools: [Google_Iam_V1beta_WorkloadIdentityPool] = []

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GetWorkloadIdentityPool.
public struct Google_Iam_V1beta_GetWorkloadIdentityPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the pool to retrieve.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateWorkloadIdentityPool.
public struct Google_Iam_V1beta_CreateWorkloadIdentityPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The parent resource to create the pool in. The only supported
  /// location is `global`.
  public var parent: String = String()

  /// Required. The pool to create.
  public var workloadIdentityPool: Google_Iam_V1beta_WorkloadIdentityPool {
    get {return _workloadIdentityPool ?? Google_Iam_V1beta_WorkloadIdentityPool()}
    set {_workloadIdentityPool = newValue}
  }
  /// Returns true if `workloadIdentityPool` has been explicitly set.
  public var hasWorkloadIdentityPool: Bool {return self._workloadIdentityPool != nil}
  /// Clears the value of `workloadIdentityPool`. Subsequent reads from it will return its default value.
  public mutating func clearWorkloadIdentityPool() {self._workloadIdentityPool = nil}

  /// Required. The ID to use for the pool, which becomes the
  /// final component of the resource name. This value should be 4-32 characters,
  /// and may contain the characters [a-z0-9-]. The prefix `gcp-` is
  /// reserved for use by Google, and may not be specified.
  public var workloadIdentityPoolID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workloadIdentityPool: Google_Iam_V1beta_WorkloadIdentityPool? = nil
}

/// Request message for UpdateWorkloadIdentityPool.
public struct Google_Iam_V1beta_UpdateWorkloadIdentityPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The pool to update. The `name` field is used to identify the pool.
  public var workloadIdentityPool: Google_Iam_V1beta_WorkloadIdentityPool {
    get {return _workloadIdentityPool ?? Google_Iam_V1beta_WorkloadIdentityPool()}
    set {_workloadIdentityPool = newValue}
  }
  /// Returns true if `workloadIdentityPool` has been explicitly set.
  public var hasWorkloadIdentityPool: Bool {return self._workloadIdentityPool != nil}
  /// Clears the value of `workloadIdentityPool`. Subsequent reads from it will return its default value.
  public mutating func clearWorkloadIdentityPool() {self._workloadIdentityPool = nil}

  /// Required. The list of fields update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workloadIdentityPool: Google_Iam_V1beta_WorkloadIdentityPool? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for DeleteWorkloadIdentityPool.
public struct Google_Iam_V1beta_DeleteWorkloadIdentityPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the pool to delete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for UndeleteWorkloadIdentityPool.
public struct Google_Iam_V1beta_UndeleteWorkloadIdentityPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the pool to undelete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for ListWorkloadIdentityPoolProviders.
public struct Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The pool to list providers for.
  public var parent: String = String()

  /// The maximum number of providers to return.
  /// If unspecified, at most 50 providers are returned.
  /// The maximum value is 100; values above 100 are truncated to 100.
  public var pageSize: Int32 = 0

  /// A page token, received from a previous
  /// `ListWorkloadIdentityPoolProviders` call. Provide this to retrieve the
  /// subsequent page.
  public var pageToken: String = String()

  /// Whether to return soft-deleted providers.
  public var showDeleted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response message for ListWorkloadIdentityPoolProviders.
public struct Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of providers.
  public var workloadIdentityPoolProviders: [Google_Iam_V1beta_WorkloadIdentityPoolProvider] = []

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for GetWorkloadIdentityPoolProvider.
public struct Google_Iam_V1beta_GetWorkloadIdentityPoolProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the provider to retrieve.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for CreateWorkloadIdentityPoolProvider.
public struct Google_Iam_V1beta_CreateWorkloadIdentityPoolProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The pool to create this provider in.
  public var parent: String = String()

  /// Required. The provider to create.
  public var workloadIdentityPoolProvider: Google_Iam_V1beta_WorkloadIdentityPoolProvider {
    get {return _workloadIdentityPoolProvider ?? Google_Iam_V1beta_WorkloadIdentityPoolProvider()}
    set {_workloadIdentityPoolProvider = newValue}
  }
  /// Returns true if `workloadIdentityPoolProvider` has been explicitly set.
  public var hasWorkloadIdentityPoolProvider: Bool {return self._workloadIdentityPoolProvider != nil}
  /// Clears the value of `workloadIdentityPoolProvider`. Subsequent reads from it will return its default value.
  public mutating func clearWorkloadIdentityPoolProvider() {self._workloadIdentityPoolProvider = nil}

  /// Required. The ID for the provider, which becomes the
  /// final component of the resource name. This value must be 4-32 characters,
  /// and may contain the characters [a-z0-9-]. The prefix `gcp-` is
  /// reserved for use by Google, and may not be specified.
  public var workloadIdentityPoolProviderID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workloadIdentityPoolProvider: Google_Iam_V1beta_WorkloadIdentityPoolProvider? = nil
}

/// Request message for UpdateWorkloadIdentityPoolProvider.
public struct Google_Iam_V1beta_UpdateWorkloadIdentityPoolProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The provider to update.
  public var workloadIdentityPoolProvider: Google_Iam_V1beta_WorkloadIdentityPoolProvider {
    get {return _workloadIdentityPoolProvider ?? Google_Iam_V1beta_WorkloadIdentityPoolProvider()}
    set {_workloadIdentityPoolProvider = newValue}
  }
  /// Returns true if `workloadIdentityPoolProvider` has been explicitly set.
  public var hasWorkloadIdentityPoolProvider: Bool {return self._workloadIdentityPoolProvider != nil}
  /// Clears the value of `workloadIdentityPoolProvider`. Subsequent reads from it will return its default value.
  public mutating func clearWorkloadIdentityPoolProvider() {self._workloadIdentityPoolProvider = nil}

  /// Required. The list of fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workloadIdentityPoolProvider: Google_Iam_V1beta_WorkloadIdentityPoolProvider? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request message for DeleteWorkloadIdentityPoolProvider.
public struct Google_Iam_V1beta_DeleteWorkloadIdentityPoolProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the provider to delete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request message for UndeleteWorkloadIdentityPoolProvider.
public struct Google_Iam_V1beta_UndeleteWorkloadIdentityPoolProviderRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the provider to undelete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata for long-running WorkloadIdentityPool operations.
public struct Google_Iam_V1beta_WorkloadIdentityPoolOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata for long-running WorkloadIdentityPoolProvider operations.
public struct Google_Iam_V1beta_WorkloadIdentityPoolProviderOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.iam.v1beta"

extension Google_Iam_V1beta_WorkloadIdentityPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkloadIdentityPool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .same(proto: "state"),
    5: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPool, rhs: Google_Iam_V1beta_WorkloadIdentityPool) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.state != rhs.state {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_WorkloadIdentityPool.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "DELETED"),
  ]
}

extension Google_Iam_V1beta_WorkloadIdentityPoolProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkloadIdentityPoolProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .same(proto: "state"),
    5: .same(proto: "disabled"),
    6: .standard(proto: "attribute_mapping"),
    7: .standard(proto: "attribute_condition"),
    8: .same(proto: "aws"),
    9: .same(proto: "oidc"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.attributeMapping) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.attributeCondition) }()
      case 8: try {
        var v: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws?
        if let current = self.providerConfig {
          try decoder.handleConflictingOneOf()
          if case .aws(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.providerConfig = .aws(v)}
      }()
      case 9: try {
        var v: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc?
        if let current = self.providerConfig {
          try decoder.handleConflictingOneOf()
          if case .oidc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.providerConfig = .oidc(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 5)
    }
    if !self.attributeMapping.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.attributeMapping, fieldNumber: 6)
    }
    if !self.attributeCondition.isEmpty {
      try visitor.visitSingularStringField(value: self.attributeCondition, fieldNumber: 7)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.providerConfig {
    case .aws?: try {
      guard case .aws(let v)? = self.providerConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .oidc?: try {
      guard case .oidc(let v)? = self.providerConfig else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider, rhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.state != rhs.state {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.attributeMapping != rhs.attributeMapping {return false}
    if lhs.attributeCondition != rhs.attributeCondition {return false}
    if lhs.providerConfig != rhs.providerConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_WorkloadIdentityPoolProvider.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "ACTIVE"),
    2: .same(proto: "DELETED"),
  ]
}

extension Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Iam_V1beta_WorkloadIdentityPoolProvider.protoMessageName + ".Aws"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.accountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.accountID.isEmpty {
      try visitor.visitSingularStringField(value: self.accountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws, rhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Aws) -> Bool {
    if lhs.accountID != rhs.accountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Iam_V1beta_WorkloadIdentityPoolProvider.protoMessageName + ".Oidc"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "issuer_uri"),
    2: .standard(proto: "allowed_audiences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.issuerUri) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.allowedAudiences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.issuerUri.isEmpty {
      try visitor.visitSingularStringField(value: self.issuerUri, fieldNumber: 1)
    }
    if !self.allowedAudiences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedAudiences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc, rhs: Google_Iam_V1beta_WorkloadIdentityPoolProvider.Oidc) -> Bool {
    if lhs.issuerUri != rhs.issuerUri {return false}
    if lhs.allowedAudiences != rhs.allowedAudiences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_ListWorkloadIdentityPoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkloadIdentityPoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "show_deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showDeleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.showDeleted != false {
      try visitor.visitSingularBoolField(value: self.showDeleted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_ListWorkloadIdentityPoolsRequest, rhs: Google_Iam_V1beta_ListWorkloadIdentityPoolsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.showDeleted != rhs.showDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_ListWorkloadIdentityPoolsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkloadIdentityPoolsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workload_identity_pools"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workloadIdentityPools) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workloadIdentityPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workloadIdentityPools, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_ListWorkloadIdentityPoolsResponse, rhs: Google_Iam_V1beta_ListWorkloadIdentityPoolsResponse) -> Bool {
    if lhs.workloadIdentityPools != rhs.workloadIdentityPools {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_GetWorkloadIdentityPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkloadIdentityPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_GetWorkloadIdentityPoolRequest, rhs: Google_Iam_V1beta_GetWorkloadIdentityPoolRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_CreateWorkloadIdentityPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkloadIdentityPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "workload_identity_pool"),
    3: .standard(proto: "workload_identity_pool_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workloadIdentityPool) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workloadIdentityPoolID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._workloadIdentityPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.workloadIdentityPoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.workloadIdentityPoolID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_CreateWorkloadIdentityPoolRequest, rhs: Google_Iam_V1beta_CreateWorkloadIdentityPoolRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._workloadIdentityPool != rhs._workloadIdentityPool {return false}
    if lhs.workloadIdentityPoolID != rhs.workloadIdentityPoolID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_UpdateWorkloadIdentityPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkloadIdentityPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workload_identity_pool"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workloadIdentityPool) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._workloadIdentityPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_UpdateWorkloadIdentityPoolRequest, rhs: Google_Iam_V1beta_UpdateWorkloadIdentityPoolRequest) -> Bool {
    if lhs._workloadIdentityPool != rhs._workloadIdentityPool {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_DeleteWorkloadIdentityPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkloadIdentityPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_DeleteWorkloadIdentityPoolRequest, rhs: Google_Iam_V1beta_DeleteWorkloadIdentityPoolRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_UndeleteWorkloadIdentityPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UndeleteWorkloadIdentityPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_UndeleteWorkloadIdentityPoolRequest, rhs: Google_Iam_V1beta_UndeleteWorkloadIdentityPoolRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkloadIdentityPoolProvidersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .standard(proto: "show_deleted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.showDeleted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if self.showDeleted != false {
      try visitor.visitSingularBoolField(value: self.showDeleted, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersRequest, rhs: Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.showDeleted != rhs.showDeleted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkloadIdentityPoolProvidersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workload_identity_pool_providers"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workloadIdentityPoolProviders) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workloadIdentityPoolProviders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workloadIdentityPoolProviders, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersResponse, rhs: Google_Iam_V1beta_ListWorkloadIdentityPoolProvidersResponse) -> Bool {
    if lhs.workloadIdentityPoolProviders != rhs.workloadIdentityPoolProviders {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_GetWorkloadIdentityPoolProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkloadIdentityPoolProviderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_GetWorkloadIdentityPoolProviderRequest, rhs: Google_Iam_V1beta_GetWorkloadIdentityPoolProviderRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_CreateWorkloadIdentityPoolProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkloadIdentityPoolProviderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "workload_identity_pool_provider"),
    3: .standard(proto: "workload_identity_pool_provider_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workloadIdentityPoolProvider) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workloadIdentityPoolProviderID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._workloadIdentityPoolProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.workloadIdentityPoolProviderID.isEmpty {
      try visitor.visitSingularStringField(value: self.workloadIdentityPoolProviderID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_CreateWorkloadIdentityPoolProviderRequest, rhs: Google_Iam_V1beta_CreateWorkloadIdentityPoolProviderRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._workloadIdentityPoolProvider != rhs._workloadIdentityPoolProvider {return false}
    if lhs.workloadIdentityPoolProviderID != rhs.workloadIdentityPoolProviderID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_UpdateWorkloadIdentityPoolProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkloadIdentityPoolProviderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workload_identity_pool_provider"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workloadIdentityPoolProvider) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._workloadIdentityPoolProvider {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_UpdateWorkloadIdentityPoolProviderRequest, rhs: Google_Iam_V1beta_UpdateWorkloadIdentityPoolProviderRequest) -> Bool {
    if lhs._workloadIdentityPoolProvider != rhs._workloadIdentityPoolProvider {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_DeleteWorkloadIdentityPoolProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkloadIdentityPoolProviderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_DeleteWorkloadIdentityPoolProviderRequest, rhs: Google_Iam_V1beta_DeleteWorkloadIdentityPoolProviderRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_UndeleteWorkloadIdentityPoolProviderRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UndeleteWorkloadIdentityPoolProviderRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_UndeleteWorkloadIdentityPoolProviderRequest, rhs: Google_Iam_V1beta_UndeleteWorkloadIdentityPoolProviderRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_WorkloadIdentityPoolOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkloadIdentityPoolOperationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPoolOperationMetadata, rhs: Google_Iam_V1beta_WorkloadIdentityPoolOperationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Iam_V1beta_WorkloadIdentityPoolProviderOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkloadIdentityPoolProviderOperationMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Iam_V1beta_WorkloadIdentityPoolProviderOperationMetadata, rhs: Google_Iam_V1beta_WorkloadIdentityPoolProviderOperationMetadata) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/identity/accesscontextmanager/v1/access_level.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An `AccessLevel` is a label that can be applied to requests to Google Cloud
/// services, along with a list of requirements necessary for the label to be
/// applied.
public struct Google_Identity_Accesscontextmanager_V1_AccessLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Resource name for the Access Level. The `short_name` component
  /// must begin with a letter and only include alphanumeric and '_'. Format:
  /// `accessPolicies/{policy_id}/accessLevels/{short_name}`. The maximum length
  /// of the `short_name` component is 50 characters.
  public var name: String = String()

  /// Human readable title. Must be unique within the Policy.
  public var title: String = String()

  /// Description of the `AccessLevel` and its use. Does not affect behavior.
  public var description_p: String = String()

  /// Required. Describes the necessary conditions for the level to apply.
  public var level: Google_Identity_Accesscontextmanager_V1_AccessLevel.OneOf_Level? = nil

  /// A `BasicLevel` composed of `Conditions`.
  public var basic: Google_Identity_Accesscontextmanager_V1_BasicLevel {
    get {
      if case .basic(let v)? = level {return v}
      return Google_Identity_Accesscontextmanager_V1_BasicLevel()
    }
    set {level = .basic(newValue)}
  }

  /// A `CustomLevel` written in the Common Expression Language.
  public var custom: Google_Identity_Accesscontextmanager_V1_CustomLevel {
    get {
      if case .custom(let v)? = level {return v}
      return Google_Identity_Accesscontextmanager_V1_CustomLevel()
    }
    set {level = .custom(newValue)}
  }

  /// Output only. Time the `AccessLevel` was created in UTC.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Time the `AccessLevel` was updated in UTC.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {self._updateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Describes the necessary conditions for the level to apply.
  public enum OneOf_Level: Equatable {
    /// A `BasicLevel` composed of `Conditions`.
    case basic(Google_Identity_Accesscontextmanager_V1_BasicLevel)
    /// A `CustomLevel` written in the Common Expression Language.
    case custom(Google_Identity_Accesscontextmanager_V1_CustomLevel)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_AccessLevel.OneOf_Level, rhs: Google_Identity_Accesscontextmanager_V1_AccessLevel.OneOf_Level) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.basic, .basic): return {
        guard case .basic(let l) = lhs, case .basic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// `BasicLevel` is an `AccessLevel` using a set of recommended features.
public struct Google_Identity_Accesscontextmanager_V1_BasicLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A list of requirements for the `AccessLevel` to be granted.
  public var conditions: [Google_Identity_Accesscontextmanager_V1_Condition] = []

  /// How the `conditions` list should be combined to determine if a request is
  /// granted this `AccessLevel`. If AND is used, each `Condition` in
  /// `conditions` must be satisfied for the `AccessLevel` to be applied. If OR
  /// is used, at least one `Condition` in `conditions` must be satisfied for the
  /// `AccessLevel` to be applied. Default behavior is AND.
  public var combiningFunction: Google_Identity_Accesscontextmanager_V1_BasicLevel.ConditionCombiningFunction = .and

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for how the `conditions` list should be combined to determine if
  /// this `AccessLevel` is applied. Default is AND.
  public enum ConditionCombiningFunction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// All `Conditions` must be true for the `BasicLevel` to be true.
    case and // = 0

    /// If at least one `Condition` is true, then the `BasicLevel` is true.
    case or // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .and
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .and
      case 1: self = .or
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .and: return 0
      case .or: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Identity_Accesscontextmanager_V1_BasicLevel.ConditionCombiningFunction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Identity_Accesscontextmanager_V1_BasicLevel.ConditionCombiningFunction] = [
    .and,
    .or,
  ]
}

#endif  // swift(>=4.2)

/// A condition necessary for an `AccessLevel` to be granted. The Condition is an
/// AND over its fields. So a Condition is true if: 1) the request IP is from one
/// of the listed subnetworks AND 2) the originating device complies with the
/// listed device policy AND 3) all listed access levels are granted AND 4) the
/// request was sent at a time allowed by the DateTimeRestriction.
public struct Google_Identity_Accesscontextmanager_V1_Condition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// CIDR block IP subnetwork specification. May be IPv4 or IPv6. Note that for
  /// a CIDR IP address block, the specified IP address portion must be properly
  /// truncated (i.e. all the host bits must be zero) or the input is considered
  /// malformed. For example, "192.0.2.0/24" is accepted but "192.0.2.1/24" is
  /// not. Similarly, for IPv6, "2001:db8::/32" is accepted whereas
  /// "2001:db8::1/32" is not. The originating IP of a request must be in one of
  /// the listed subnets in order for this Condition to be true. If empty, all IP
  /// addresses are allowed.
  public var ipSubnetworks: [String] = []

  /// Device specific restrictions, all restrictions must hold for the
  /// Condition to be true. If not specified, all devices are allowed.
  public var devicePolicy: Google_Identity_Accesscontextmanager_V1_DevicePolicy {
    get {return _devicePolicy ?? Google_Identity_Accesscontextmanager_V1_DevicePolicy()}
    set {_devicePolicy = newValue}
  }
  /// Returns true if `devicePolicy` has been explicitly set.
  public var hasDevicePolicy: Bool {return self._devicePolicy != nil}
  /// Clears the value of `devicePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearDevicePolicy() {self._devicePolicy = nil}

  /// A list of other access levels defined in the same `Policy`, referenced by
  /// resource name. Referencing an `AccessLevel` which does not exist is an
  /// error. All access levels listed must be granted for the Condition
  /// to be true. Example:
  /// "`accessPolicies/MY_POLICY/accessLevels/LEVEL_NAME"`
  public var requiredAccessLevels: [String] = []

  /// Whether to negate the Condition. If true, the Condition becomes a NAND over
  /// its non-empty fields, each field must be false for the Condition overall to
  /// be satisfied. Defaults to false.
  public var negate: Bool = false

  /// The request must be made by one of the provided user or service
  /// accounts. Groups are not supported.
  /// Syntax:
  /// `user:{emailid}`
  /// `serviceAccount:{emailid}`
  /// If not specified, a request may come from any user.
  public var members: [String] = []

  /// The request must originate from one of the provided countries/regions.
  /// Must be valid ISO 3166-1 alpha-2 codes.
  public var regions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _devicePolicy: Google_Identity_Accesscontextmanager_V1_DevicePolicy? = nil
}

/// `CustomLevel` is an `AccessLevel` using the Cloud Common Expression Language
/// to represent the necessary conditions for the level to apply to a request.
/// See CEL spec at: https://github.com/google/cel-spec
public struct Google_Identity_Accesscontextmanager_V1_CustomLevel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A Cloud CEL expression evaluating to a boolean.
  public var expr: Google_Type_Expr {
    get {return _expr ?? Google_Type_Expr()}
    set {_expr = newValue}
  }
  /// Returns true if `expr` has been explicitly set.
  public var hasExpr: Bool {return self._expr != nil}
  /// Clears the value of `expr`. Subsequent reads from it will return its default value.
  public mutating func clearExpr() {self._expr = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expr: Google_Type_Expr? = nil
}

/// `DevicePolicy` specifies device specific restrictions necessary to acquire a
/// given access level. A `DevicePolicy` specifies requirements for requests from
/// devices to be granted access levels, it does not do any enforcement on the
/// device. `DevicePolicy` acts as an AND over all specified fields, and each
/// repeated field is an OR over its elements. Any unset fields are ignored. For
/// example, if the proto is { os_type : DESKTOP_WINDOWS, os_type :
/// DESKTOP_LINUX, encryption_status: ENCRYPTED}, then the DevicePolicy will be
/// true for requests originating from encrypted Linux desktops and encrypted
/// Windows desktops.
public struct Google_Identity_Accesscontextmanager_V1_DevicePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not screenlock is required for the DevicePolicy to be true.
  /// Defaults to `false`.
  public var requireScreenlock: Bool = false

  /// Allowed encryptions statuses, an empty list allows all statuses.
  public var allowedEncryptionStatuses: [Google_Identity_Accesscontextmanager_Type_DeviceEncryptionStatus] = []

  /// Allowed OS versions, an empty list allows all types and all versions.
  public var osConstraints: [Google_Identity_Accesscontextmanager_V1_OsConstraint] = []

  /// Allowed device management levels, an empty list allows all management
  /// levels.
  public var allowedDeviceManagementLevels: [Google_Identity_Accesscontextmanager_Type_DeviceManagementLevel] = []

  /// Whether the device needs to be approved by the customer admin.
  public var requireAdminApproval: Bool = false

  /// Whether the device needs to be corp owned.
  public var requireCorpOwned: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A restriction on the OS type and version of devices making requests.
public struct Google_Identity_Accesscontextmanager_V1_OsConstraint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The allowed OS type.
  public var osType: Google_Identity_Accesscontextmanager_Type_OsType = .osUnspecified

  /// The minimum allowed OS version. If not set, any version of this OS
  /// satisfies the constraint. Format: `"major.minor.patch"`.
  /// Examples: `"10.5.301"`, `"9.2.1"`.
  public var minimumVersion: String = String()

  /// Only allows requests from devices with a verified Chrome OS.
  /// Verifications includes requirements that the device is enterprise-managed,
  /// conformant to domain policies, and the caller has permission to call
  /// the API targeted by the request.
  public var requireVerifiedChromeOs: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.identity.accesscontextmanager.v1"

extension Google_Identity_Accesscontextmanager_V1_AccessLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccessLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "title"),
    3: .same(proto: "description"),
    4: .same(proto: "basic"),
    5: .same(proto: "custom"),
    6: .standard(proto: "create_time"),
    7: .standard(proto: "update_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try {
        var v: Google_Identity_Accesscontextmanager_V1_BasicLevel?
        if let current = self.level {
          try decoder.handleConflictingOneOf()
          if case .basic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.level = .basic(v)}
      }()
      case 5: try {
        var v: Google_Identity_Accesscontextmanager_V1_CustomLevel?
        if let current = self.level {
          try decoder.handleConflictingOneOf()
          if case .custom(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.level = .custom(v)}
      }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.level {
    case .basic?: try {
      guard case .basic(let v)? = self.level else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .custom?: try {
      guard case .custom(let v)? = self.level else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_AccessLevel, rhs: Google_Identity_Accesscontextmanager_V1_AccessLevel) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.level != rhs.level {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Identity_Accesscontextmanager_V1_BasicLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BasicLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "conditions"),
    2: .standard(proto: "combining_function"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.combiningFunction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    if self.combiningFunction != .and {
      try visitor.visitSingularEnumField(value: self.combiningFunction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_BasicLevel, rhs: Google_Identity_Accesscontextmanager_V1_BasicLevel) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs.combiningFunction != rhs.combiningFunction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Identity_Accesscontextmanager_V1_BasicLevel.ConditionCombiningFunction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AND"),
    1: .same(proto: "OR"),
  ]
}

extension Google_Identity_Accesscontextmanager_V1_Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Condition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ip_subnetworks"),
    2: .standard(proto: "device_policy"),
    3: .standard(proto: "required_access_levels"),
    5: .same(proto: "negate"),
    6: .same(proto: "members"),
    7: .same(proto: "regions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.ipSubnetworks) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._devicePolicy) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.requiredAccessLevels) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.negate) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.members) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.regions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ipSubnetworks.isEmpty {
      try visitor.visitRepeatedStringField(value: self.ipSubnetworks, fieldNumber: 1)
    }
    if let v = self._devicePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.requiredAccessLevels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requiredAccessLevels, fieldNumber: 3)
    }
    if self.negate != false {
      try visitor.visitSingularBoolField(value: self.negate, fieldNumber: 5)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedStringField(value: self.members, fieldNumber: 6)
    }
    if !self.regions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.regions, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_Condition, rhs: Google_Identity_Accesscontextmanager_V1_Condition) -> Bool {
    if lhs.ipSubnetworks != rhs.ipSubnetworks {return false}
    if lhs._devicePolicy != rhs._devicePolicy {return false}
    if lhs.requiredAccessLevels != rhs.requiredAccessLevels {return false}
    if lhs.negate != rhs.negate {return false}
    if lhs.members != rhs.members {return false}
    if lhs.regions != rhs.regions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Identity_Accesscontextmanager_V1_CustomLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expr"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._expr) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._expr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_CustomLevel, rhs: Google_Identity_Accesscontextmanager_V1_CustomLevel) -> Bool {
    if lhs._expr != rhs._expr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Identity_Accesscontextmanager_V1_DevicePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DevicePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "require_screenlock"),
    2: .standard(proto: "allowed_encryption_statuses"),
    3: .standard(proto: "os_constraints"),
    6: .standard(proto: "allowed_device_management_levels"),
    7: .standard(proto: "require_admin_approval"),
    8: .standard(proto: "require_corp_owned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.requireScreenlock) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.allowedEncryptionStatuses) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.osConstraints) }()
      case 6: try { try decoder.decodeRepeatedEnumField(value: &self.allowedDeviceManagementLevels) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.requireAdminApproval) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.requireCorpOwned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requireScreenlock != false {
      try visitor.visitSingularBoolField(value: self.requireScreenlock, fieldNumber: 1)
    }
    if !self.allowedEncryptionStatuses.isEmpty {
      try visitor.visitPackedEnumField(value: self.allowedEncryptionStatuses, fieldNumber: 2)
    }
    if !self.osConstraints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.osConstraints, fieldNumber: 3)
    }
    if !self.allowedDeviceManagementLevels.isEmpty {
      try visitor.visitPackedEnumField(value: self.allowedDeviceManagementLevels, fieldNumber: 6)
    }
    if self.requireAdminApproval != false {
      try visitor.visitSingularBoolField(value: self.requireAdminApproval, fieldNumber: 7)
    }
    if self.requireCorpOwned != false {
      try visitor.visitSingularBoolField(value: self.requireCorpOwned, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_DevicePolicy, rhs: Google_Identity_Accesscontextmanager_V1_DevicePolicy) -> Bool {
    if lhs.requireScreenlock != rhs.requireScreenlock {return false}
    if lhs.allowedEncryptionStatuses != rhs.allowedEncryptionStatuses {return false}
    if lhs.osConstraints != rhs.osConstraints {return false}
    if lhs.allowedDeviceManagementLevels != rhs.allowedDeviceManagementLevels {return false}
    if lhs.requireAdminApproval != rhs.requireAdminApproval {return false}
    if lhs.requireCorpOwned != rhs.requireCorpOwned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Identity_Accesscontextmanager_V1_OsConstraint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OsConstraint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "os_type"),
    2: .standard(proto: "minimum_version"),
    3: .standard(proto: "require_verified_chrome_os"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.osType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.minimumVersion) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.requireVerifiedChromeOs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.osType != .osUnspecified {
      try visitor.visitSingularEnumField(value: self.osType, fieldNumber: 1)
    }
    if !self.minimumVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.minimumVersion, fieldNumber: 2)
    }
    if self.requireVerifiedChromeOs != false {
      try visitor.visitSingularBoolField(value: self.requireVerifiedChromeOs, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Identity_Accesscontextmanager_V1_OsConstraint, rhs: Google_Identity_Accesscontextmanager_V1_OsConstraint) -> Bool {
    if lhs.osType != rhs.osType {return false}
    if lhs.minimumVersion != rhs.minimumVersion {return false}
    if lhs.requireVerifiedChromeOs != rhs.requireVerifiedChromeOs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

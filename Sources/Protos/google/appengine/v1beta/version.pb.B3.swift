// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/appengine/v1beta/version.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Available inbound services.
public enum Google_Appengine_V1beta_InboundServiceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified.
  case inboundServiceUnspecified // = 0

  /// Allows an application to receive mail.
  case inboundServiceMail // = 1

  /// Allows an application to receive email-bound notifications.
  case inboundServiceMailBounce // = 2

  /// Allows an application to receive error stanzas.
  case inboundServiceXmppError // = 3

  /// Allows an application to receive instant messages.
  case inboundServiceXmppMessage // = 4

  /// Allows an application to receive user subscription POSTs.
  case inboundServiceXmppSubscribe // = 5

  /// Allows an application to receive a user's chat presence.
  case inboundServiceXmppPresence // = 6

  /// Registers an application for notifications when a client connects or
  /// disconnects from a channel.
  case inboundServiceChannelPresence // = 7

  /// Enables warmup requests.
  case inboundServiceWarmup // = 9
  case UNRECOGNIZED(Int)

  public init() {
    self = .inboundServiceUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inboundServiceUnspecified
    case 1: self = .inboundServiceMail
    case 2: self = .inboundServiceMailBounce
    case 3: self = .inboundServiceXmppError
    case 4: self = .inboundServiceXmppMessage
    case 5: self = .inboundServiceXmppSubscribe
    case 6: self = .inboundServiceXmppPresence
    case 7: self = .inboundServiceChannelPresence
    case 9: self = .inboundServiceWarmup
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .inboundServiceUnspecified: return 0
    case .inboundServiceMail: return 1
    case .inboundServiceMailBounce: return 2
    case .inboundServiceXmppError: return 3
    case .inboundServiceXmppMessage: return 4
    case .inboundServiceXmppSubscribe: return 5
    case .inboundServiceXmppPresence: return 6
    case .inboundServiceChannelPresence: return 7
    case .inboundServiceWarmup: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Appengine_V1beta_InboundServiceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_InboundServiceType] = [
    .inboundServiceUnspecified,
    .inboundServiceMail,
    .inboundServiceMailBounce,
    .inboundServiceXmppError,
    .inboundServiceXmppMessage,
    .inboundServiceXmppSubscribe,
    .inboundServiceXmppPresence,
    .inboundServiceChannelPresence,
    .inboundServiceWarmup,
  ]
}

#endif  // swift(>=4.2)

/// Run states of a version.
public enum Google_Appengine_V1beta_ServingStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified.
  case unspecified // = 0

  /// Currently serving. Instances are created according to the
  /// scaling settings of the version.
  case serving // = 1

  /// Disabled. No instances will be created and the scaling
  /// settings are ignored until the state of the version changes
  /// to `SERVING`.
  case stopped // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .serving
    case 2: self = .stopped
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .serving: return 1
    case .stopped: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Appengine_V1beta_ServingStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_ServingStatus] = [
    .unspecified,
    .serving,
    .stopped,
  ]
}

#endif  // swift(>=4.2)

/// A Version resource is a specific set of source code and configuration files
/// that are deployed into a service.
public struct Google_Appengine_V1beta_Version {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full path to the Version resource in the API.  Example:
  /// `apps/myapp/services/default/versions/v1`.
  ///
  /// @OutputOnly
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Relative name of the version within the service.  Example: `v1`.
  /// Version names can contain only lowercase letters, numbers, or hyphens.
  /// Reserved names: "default", "latest", and any name with the prefix "ah-".
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Controls how instances are created.
  ///
  /// Defaults to `AutomaticScaling`.
  public var scaling: OneOf_Scaling? {
    get {return _storage._scaling}
    set {_uniqueStorage()._scaling = newValue}
  }

  /// Automatic scaling is based on request rate, response latencies, and other
  /// application metrics.
  public var automaticScaling: Google_Appengine_V1beta_AutomaticScaling {
    get {
      if case .automaticScaling(let v)? = _storage._scaling {return v}
      return Google_Appengine_V1beta_AutomaticScaling()
    }
    set {_uniqueStorage()._scaling = .automaticScaling(newValue)}
  }

  /// A service with basic scaling will create an instance when the application
  /// receives a request. The instance will be turned down when the app becomes
  /// idle. Basic scaling is ideal for work that is intermittent or driven by
  /// user activity.
  public var basicScaling: Google_Appengine_V1beta_BasicScaling {
    get {
      if case .basicScaling(let v)? = _storage._scaling {return v}
      return Google_Appengine_V1beta_BasicScaling()
    }
    set {_uniqueStorage()._scaling = .basicScaling(newValue)}
  }

  /// A service with manual scaling runs continuously, allowing you to perform
  /// complex initialization and rely on the state of its memory over time.
  public var manualScaling: Google_Appengine_V1beta_ManualScaling {
    get {
      if case .manualScaling(let v)? = _storage._scaling {return v}
      return Google_Appengine_V1beta_ManualScaling()
    }
    set {_uniqueStorage()._scaling = .manualScaling(newValue)}
  }

  /// Before an application can receive email or XMPP messages, the application
  /// must be configured to enable the service.
  public var inboundServices: [Google_Appengine_V1beta_InboundServiceType] {
    get {return _storage._inboundServices}
    set {_uniqueStorage()._inboundServices = newValue}
  }

  /// Instance class that is used to run this version. Valid values are:
  ///
  /// * AutomaticScaling: `F1`, `F2`, `F4`, `F4_1G`
  /// * ManualScaling or BasicScaling: `B1`, `B2`, `B4`, `B8`, `B4_1G`
  ///
  /// Defaults to `F1` for AutomaticScaling and `B1` for ManualScaling or
  /// BasicScaling.
  public var instanceClass: String {
    get {return _storage._instanceClass}
    set {_uniqueStorage()._instanceClass = newValue}
  }

  /// Extra network settings.
  /// Only applicable in the App Engine flexible environment.
  public var network: Google_Appengine_V1beta_Network {
    get {return _storage._network ?? Google_Appengine_V1beta_Network()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  public var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  public mutating func clearNetwork() {_uniqueStorage()._network = nil}

  /// The Google Compute Engine zones that are supported by this version in the
  /// App Engine flexible environment. Deprecated.
  public var zones: [String] {
    get {return _storage._zones}
    set {_uniqueStorage()._zones = newValue}
  }

  /// Machine resources for this version.
  /// Only applicable in the App Engine flexible environment.
  public var resources: Google_Appengine_V1beta_Resources {
    get {return _storage._resources ?? Google_Appengine_V1beta_Resources()}
    set {_uniqueStorage()._resources = newValue}
  }
  /// Returns true if `resources` has been explicitly set.
  public var hasResources: Bool {return _storage._resources != nil}
  /// Clears the value of `resources`. Subsequent reads from it will return its default value.
  public mutating func clearResources() {_uniqueStorage()._resources = nil}

  /// Desired runtime. Example: `python27`.
  public var runtime: String {
    get {return _storage._runtime}
    set {_uniqueStorage()._runtime = newValue}
  }

  /// The channel of the runtime to use. Only available for some
  /// runtimes. Defaults to the `default` channel.
  public var runtimeChannel: String {
    get {return _storage._runtimeChannel}
    set {_uniqueStorage()._runtimeChannel = newValue}
  }

  /// Whether multiple requests can be dispatched to this version at once.
  public var threadsafe: Bool {
    get {return _storage._threadsafe}
    set {_uniqueStorage()._threadsafe = newValue}
  }

  /// Whether to deploy this version in a container on a virtual machine.
  public var vm: Bool {
    get {return _storage._vm}
    set {_uniqueStorage()._vm = newValue}
  }

  /// Metadata settings that are supplied to this version to enable
  /// beta runtime features.
  public var betaSettings: Dictionary<String,String> {
    get {return _storage._betaSettings}
    set {_uniqueStorage()._betaSettings = newValue}
  }

  /// App Engine execution environment for this version.
  ///
  /// Defaults to `standard`.
  public var env: String {
    get {return _storage._env}
    set {_uniqueStorage()._env = newValue}
  }

  /// Current serving status of this version. Only the versions with a
  /// `SERVING` status create instances and can be billed.
  ///
  /// `SERVING_STATUS_UNSPECIFIED` is an invalid value. Defaults to `SERVING`.
  public var servingStatus: Google_Appengine_V1beta_ServingStatus {
    get {return _storage._servingStatus}
    set {_uniqueStorage()._servingStatus = newValue}
  }

  /// Email address of the user who created this version.
  ///
  /// @OutputOnly
  public var createdBy: String {
    get {return _storage._createdBy}
    set {_uniqueStorage()._createdBy = newValue}
  }

  /// Time that this version was created.
  ///
  /// @OutputOnly
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Total size in bytes of all the files that are included in this version
  /// and currently hosted on the App Engine disk.
  ///
  /// @OutputOnly
  public var diskUsageBytes: Int64 {
    get {return _storage._diskUsageBytes}
    set {_uniqueStorage()._diskUsageBytes = newValue}
  }

  /// The version of the API in the given runtime environment. Please see the
  /// app.yaml reference for valid values at
  /// https://cloud.google.com/appengine/docs/standard/<language>/config/appref
  public var runtimeApiVersion: String {
    get {return _storage._runtimeApiVersion}
    set {_uniqueStorage()._runtimeApiVersion = newValue}
  }

  /// The path or name of the app's main executable.
  public var runtimeMainExecutablePath: String {
    get {return _storage._runtimeMainExecutablePath}
    set {_uniqueStorage()._runtimeMainExecutablePath = newValue}
  }

  /// An ordered list of URL-matching patterns that should be applied to incoming
  /// requests. The first matching URL handles the request and other request
  /// handlers are not attempted.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var handlers: [Google_Appengine_V1beta_UrlMap] {
    get {return _storage._handlers}
    set {_uniqueStorage()._handlers = newValue}
  }

  /// Custom static error pages. Limited to 10KB per page.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var errorHandlers: [Google_Appengine_V1beta_ErrorHandler] {
    get {return _storage._errorHandlers}
    set {_uniqueStorage()._errorHandlers = newValue}
  }

  /// Configuration for third-party Python runtime libraries that are required
  /// by the application.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var libraries: [Google_Appengine_V1beta_Library] {
    get {return _storage._libraries}
    set {_uniqueStorage()._libraries = newValue}
  }

  /// Serving configuration for
  /// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/).
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var apiConfig: Google_Appengine_V1beta_ApiConfigHandler {
    get {return _storage._apiConfig ?? Google_Appengine_V1beta_ApiConfigHandler()}
    set {_uniqueStorage()._apiConfig = newValue}
  }
  /// Returns true if `apiConfig` has been explicitly set.
  public var hasApiConfig: Bool {return _storage._apiConfig != nil}
  /// Clears the value of `apiConfig`. Subsequent reads from it will return its default value.
  public mutating func clearApiConfig() {_uniqueStorage()._apiConfig = nil}

  /// Environment variables available to the application.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var envVariables: Dictionary<String,String> {
    get {return _storage._envVariables}
    set {_uniqueStorage()._envVariables = newValue}
  }

  /// Duration that static files should be cached by web proxies and browsers.
  /// Only applicable if the corresponding
  /// [StaticFilesHandler](https://cloud.google.com/appengine/docs/admin-api/reference/rest/v1beta/apps.services.versions#StaticFilesHandler)
  /// does not specify its own expiration time.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var defaultExpiration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._defaultExpiration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._defaultExpiration = newValue}
  }
  /// Returns true if `defaultExpiration` has been explicitly set.
  public var hasDefaultExpiration: Bool {return _storage._defaultExpiration != nil}
  /// Clears the value of `defaultExpiration`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultExpiration() {_uniqueStorage()._defaultExpiration = nil}

  /// Configures health checking for instances. Unhealthy instances are
  /// stopped and replaced with new instances.
  /// Only applicable in the App Engine flexible environment.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var healthCheck: Google_Appengine_V1beta_HealthCheck {
    get {return _storage._healthCheck ?? Google_Appengine_V1beta_HealthCheck()}
    set {_uniqueStorage()._healthCheck = newValue}
  }
  /// Returns true if `healthCheck` has been explicitly set.
  public var hasHealthCheck: Bool {return _storage._healthCheck != nil}
  /// Clears the value of `healthCheck`. Subsequent reads from it will return its default value.
  public mutating func clearHealthCheck() {_uniqueStorage()._healthCheck = nil}

  /// Configures readiness health checking for instances.
  /// Unhealthy instances are not put into the backend traffic rotation.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var readinessCheck: Google_Appengine_V1beta_ReadinessCheck {
    get {return _storage._readinessCheck ?? Google_Appengine_V1beta_ReadinessCheck()}
    set {_uniqueStorage()._readinessCheck = newValue}
  }
  /// Returns true if `readinessCheck` has been explicitly set.
  public var hasReadinessCheck: Bool {return _storage._readinessCheck != nil}
  /// Clears the value of `readinessCheck`. Subsequent reads from it will return its default value.
  public mutating func clearReadinessCheck() {_uniqueStorage()._readinessCheck = nil}

  /// Configures liveness health checking for instances.
  /// Unhealthy instances are stopped and replaced with new instances
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var livenessCheck: Google_Appengine_V1beta_LivenessCheck {
    get {return _storage._livenessCheck ?? Google_Appengine_V1beta_LivenessCheck()}
    set {_uniqueStorage()._livenessCheck = newValue}
  }
  /// Returns true if `livenessCheck` has been explicitly set.
  public var hasLivenessCheck: Bool {return _storage._livenessCheck != nil}
  /// Clears the value of `livenessCheck`. Subsequent reads from it will return its default value.
  public mutating func clearLivenessCheck() {_uniqueStorage()._livenessCheck = nil}

  /// Files that match this pattern will not be built into this version.
  /// Only applicable for Go runtimes.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var nobuildFilesRegex: String {
    get {return _storage._nobuildFilesRegex}
    set {_uniqueStorage()._nobuildFilesRegex = newValue}
  }

  /// Code and application artifacts that make up this version.
  ///
  /// Only returned in `GET` requests if `view=FULL` is set.
  public var deployment: Google_Appengine_V1beta_Deployment {
    get {return _storage._deployment ?? Google_Appengine_V1beta_Deployment()}
    set {_uniqueStorage()._deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  public var hasDeployment: Bool {return _storage._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  public mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

  /// Serving URL for this version. Example:
  /// "https://myversion-dot-myservice-dot-myapp.appspot.com"
  ///
  /// @OutputOnly
  public var versionURL: String {
    get {return _storage._versionURL}
    set {_uniqueStorage()._versionURL = newValue}
  }

  /// Cloud Endpoints configuration.
  ///
  /// If endpoints_api_service is set, the Cloud Endpoints Extensible Service
  /// Proxy will be provided to serve the API implemented by the app.
  public var endpointsApiService: Google_Appengine_V1beta_EndpointsApiService {
    get {return _storage._endpointsApiService ?? Google_Appengine_V1beta_EndpointsApiService()}
    set {_uniqueStorage()._endpointsApiService = newValue}
  }
  /// Returns true if `endpointsApiService` has been explicitly set.
  public var hasEndpointsApiService: Bool {return _storage._endpointsApiService != nil}
  /// Clears the value of `endpointsApiService`. Subsequent reads from it will return its default value.
  public mutating func clearEndpointsApiService() {_uniqueStorage()._endpointsApiService = nil}

  /// The entrypoint for the application.
  public var entrypoint: Google_Appengine_V1beta_Entrypoint {
    get {return _storage._entrypoint ?? Google_Appengine_V1beta_Entrypoint()}
    set {_uniqueStorage()._entrypoint = newValue}
  }
  /// Returns true if `entrypoint` has been explicitly set.
  public var hasEntrypoint: Bool {return _storage._entrypoint != nil}
  /// Clears the value of `entrypoint`. Subsequent reads from it will return its default value.
  public mutating func clearEntrypoint() {_uniqueStorage()._entrypoint = nil}

  /// Enables VPC connectivity for standard apps.
  public var vpcAccessConnector: Google_Appengine_V1beta_VpcAccessConnector {
    get {return _storage._vpcAccessConnector ?? Google_Appengine_V1beta_VpcAccessConnector()}
    set {_uniqueStorage()._vpcAccessConnector = newValue}
  }
  /// Returns true if `vpcAccessConnector` has been explicitly set.
  public var hasVpcAccessConnector: Bool {return _storage._vpcAccessConnector != nil}
  /// Clears the value of `vpcAccessConnector`. Subsequent reads from it will return its default value.
  public mutating func clearVpcAccessConnector() {_uniqueStorage()._vpcAccessConnector = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Controls how instances are created.
  ///
  /// Defaults to `AutomaticScaling`.
  public enum OneOf_Scaling: Equatable {
    /// Automatic scaling is based on request rate, response latencies, and other
    /// application metrics.
    case automaticScaling(Google_Appengine_V1beta_AutomaticScaling)
    /// A service with basic scaling will create an instance when the application
    /// receives a request. The instance will be turned down when the app becomes
    /// idle. Basic scaling is ideal for work that is intermittent or driven by
    /// user activity.
    case basicScaling(Google_Appengine_V1beta_BasicScaling)
    /// A service with manual scaling runs continuously, allowing you to perform
    /// complex initialization and rely on the state of its memory over time.
    case manualScaling(Google_Appengine_V1beta_ManualScaling)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Appengine_V1beta_Version.OneOf_Scaling, rhs: Google_Appengine_V1beta_Version.OneOf_Scaling) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.automaticScaling, .automaticScaling): return {
        guard case .automaticScaling(let l) = lhs, case .automaticScaling(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.basicScaling, .basicScaling): return {
        guard case .basicScaling(let l) = lhs, case .basicScaling(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.manualScaling, .manualScaling): return {
        guard case .manualScaling(let l) = lhs, case .manualScaling(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// [Cloud Endpoints](https://cloud.google.com/endpoints) configuration.
/// The Endpoints API Service provides tooling for serving Open API and gRPC
/// endpoints via an NGINX proxy. Only valid for App Engine Flexible environment
/// deployments.
///
/// The fields here refer to the name and configuration ID of a "service"
/// resource in the [Service Management API](https://cloud.google.com/service-management/overview).
public struct Google_Appengine_V1beta_EndpointsApiService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoints service name which is the name of the "service" resource in the
  /// Service Management API. For example "myapi.endpoints.myproject.cloud.goog"
  public var name: String = String()

  /// Endpoints service configuration ID as specified by the Service Management
  /// API. For example "2016-09-19r1".
  ///
  /// By default, the rollout strategy for Endpoints is `RolloutStrategy.FIXED`.
  /// This means that Endpoints starts up with a particular configuration ID.
  /// When a new configuration is rolled out, Endpoints must be given the new
  /// configuration ID. The `config_id` field is used to give the configuration
  /// ID and is required in this case.
  ///
  /// Endpoints also has a rollout strategy called `RolloutStrategy.MANAGED`.
  /// When using this, Endpoints fetches the latest configuration and does not
  /// need the configuration ID. In this case, `config_id` must be omitted.
  public var configID: String = String()

  /// Endpoints rollout strategy. If `FIXED`, `config_id` must be specified. If
  /// `MANAGED`, `config_id` must be omitted.
  public var rolloutStrategy: Google_Appengine_V1beta_EndpointsApiService.RolloutStrategy = .unspecifiedRolloutStrategy

  /// Enable or disable trace sampling. By default, this is set to false for
  /// enabled.
  public var disableTraceSampling: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Available rollout strategies.
  public enum RolloutStrategy: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. Defaults to `FIXED`.
    case unspecifiedRolloutStrategy // = 0

    /// Endpoints service configuration ID will be fixed to the configuration ID
    /// specified by `config_id`.
    case fixed // = 1

    /// Endpoints service configuration ID will be updated with each rollout.
    case managed // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecifiedRolloutStrategy
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecifiedRolloutStrategy
      case 1: self = .fixed
      case 2: self = .managed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecifiedRolloutStrategy: return 0
      case .fixed: return 1
      case .managed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Appengine_V1beta_EndpointsApiService.RolloutStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_EndpointsApiService.RolloutStrategy] = [
    .unspecifiedRolloutStrategy,
    .fixed,
    .managed,
  ]
}

#endif  // swift(>=4.2)

/// Automatic scaling is based on request rate, response latencies, and other
/// application metrics.
public struct Google_Appengine_V1beta_AutomaticScaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time period that the
  /// [Autoscaler](https://cloud.google.com/compute/docs/autoscaler/)
  /// should wait before it starts collecting information from a new instance.
  /// This prevents the autoscaler from collecting information when the instance
  /// is initializing, during which the collected usage would not be reliable.
  /// Only applicable in the App Engine flexible environment.
  public var coolDownPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._coolDownPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._coolDownPeriod = newValue}
  }
  /// Returns true if `coolDownPeriod` has been explicitly set.
  public var hasCoolDownPeriod: Bool {return _storage._coolDownPeriod != nil}
  /// Clears the value of `coolDownPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearCoolDownPeriod() {_uniqueStorage()._coolDownPeriod = nil}

  /// Target scaling by CPU usage.
  public var cpuUtilization: Google_Appengine_V1beta_CpuUtilization {
    get {return _storage._cpuUtilization ?? Google_Appengine_V1beta_CpuUtilization()}
    set {_uniqueStorage()._cpuUtilization = newValue}
  }
  /// Returns true if `cpuUtilization` has been explicitly set.
  public var hasCpuUtilization: Bool {return _storage._cpuUtilization != nil}
  /// Clears the value of `cpuUtilization`. Subsequent reads from it will return its default value.
  public mutating func clearCpuUtilization() {_uniqueStorage()._cpuUtilization = nil}

  /// Number of concurrent requests an automatic scaling instance can accept
  /// before the scheduler spawns a new instance.
  ///
  /// Defaults to a runtime-specific value.
  public var maxConcurrentRequests: Int32 {
    get {return _storage._maxConcurrentRequests}
    set {_uniqueStorage()._maxConcurrentRequests = newValue}
  }

  /// Maximum number of idle instances that should be maintained for this
  /// version.
  public var maxIdleInstances: Int32 {
    get {return _storage._maxIdleInstances}
    set {_uniqueStorage()._maxIdleInstances = newValue}
  }

  /// Maximum number of instances that should be started to handle requests for
  /// this version.
  public var maxTotalInstances: Int32 {
    get {return _storage._maxTotalInstances}
    set {_uniqueStorage()._maxTotalInstances = newValue}
  }

  /// Maximum amount of time that a request should wait in the pending queue
  /// before starting a new instance to handle it.
  public var maxPendingLatency: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._maxPendingLatency ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._maxPendingLatency = newValue}
  }
  /// Returns true if `maxPendingLatency` has been explicitly set.
  public var hasMaxPendingLatency: Bool {return _storage._maxPendingLatency != nil}
  /// Clears the value of `maxPendingLatency`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPendingLatency() {_uniqueStorage()._maxPendingLatency = nil}

  /// Minimum number of idle instances that should be maintained for
  /// this version. Only applicable for the default version of a service.
  public var minIdleInstances: Int32 {
    get {return _storage._minIdleInstances}
    set {_uniqueStorage()._minIdleInstances = newValue}
  }

  /// Minimum number of running instances that should be maintained for this
  /// version.
  public var minTotalInstances: Int32 {
    get {return _storage._minTotalInstances}
    set {_uniqueStorage()._minTotalInstances = newValue}
  }

  /// Minimum amount of time a request should wait in the pending queue before
  /// starting a new instance to handle it.
  public var minPendingLatency: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._minPendingLatency ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._minPendingLatency = newValue}
  }
  /// Returns true if `minPendingLatency` has been explicitly set.
  public var hasMinPendingLatency: Bool {return _storage._minPendingLatency != nil}
  /// Clears the value of `minPendingLatency`. Subsequent reads from it will return its default value.
  public mutating func clearMinPendingLatency() {_uniqueStorage()._minPendingLatency = nil}

  /// Target scaling by request utilization.
  public var requestUtilization: Google_Appengine_V1beta_RequestUtilization {
    get {return _storage._requestUtilization ?? Google_Appengine_V1beta_RequestUtilization()}
    set {_uniqueStorage()._requestUtilization = newValue}
  }
  /// Returns true if `requestUtilization` has been explicitly set.
  public var hasRequestUtilization: Bool {return _storage._requestUtilization != nil}
  /// Clears the value of `requestUtilization`. Subsequent reads from it will return its default value.
  public mutating func clearRequestUtilization() {_uniqueStorage()._requestUtilization = nil}

  /// Target scaling by disk usage.
  public var diskUtilization: Google_Appengine_V1beta_DiskUtilization {
    get {return _storage._diskUtilization ?? Google_Appengine_V1beta_DiskUtilization()}
    set {_uniqueStorage()._diskUtilization = newValue}
  }
  /// Returns true if `diskUtilization` has been explicitly set.
  public var hasDiskUtilization: Bool {return _storage._diskUtilization != nil}
  /// Clears the value of `diskUtilization`. Subsequent reads from it will return its default value.
  public mutating func clearDiskUtilization() {_uniqueStorage()._diskUtilization = nil}

  /// Target scaling by network usage.
  public var networkUtilization: Google_Appengine_V1beta_NetworkUtilization {
    get {return _storage._networkUtilization ?? Google_Appengine_V1beta_NetworkUtilization()}
    set {_uniqueStorage()._networkUtilization = newValue}
  }
  /// Returns true if `networkUtilization` has been explicitly set.
  public var hasNetworkUtilization: Bool {return _storage._networkUtilization != nil}
  /// Clears the value of `networkUtilization`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkUtilization() {_uniqueStorage()._networkUtilization = nil}

  /// Target scaling by user-provided metrics.
  /// Only applicable in the App Engine flexible environment.
  public var customMetrics: [Google_Appengine_V1beta_CustomMetric] {
    get {return _storage._customMetrics}
    set {_uniqueStorage()._customMetrics = newValue}
  }

  /// Scheduler settings for standard environment.
  public var standardSchedulerSettings: Google_Appengine_V1beta_StandardSchedulerSettings {
    get {return _storage._standardSchedulerSettings ?? Google_Appengine_V1beta_StandardSchedulerSettings()}
    set {_uniqueStorage()._standardSchedulerSettings = newValue}
  }
  /// Returns true if `standardSchedulerSettings` has been explicitly set.
  public var hasStandardSchedulerSettings: Bool {return _storage._standardSchedulerSettings != nil}
  /// Clears the value of `standardSchedulerSettings`. Subsequent reads from it will return its default value.
  public mutating func clearStandardSchedulerSettings() {_uniqueStorage()._standardSchedulerSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A service with basic scaling will create an instance when the application
/// receives a request. The instance will be turned down when the app becomes
/// idle. Basic scaling is ideal for work that is intermittent or driven by
/// user activity.
public struct Google_Appengine_V1beta_BasicScaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Duration of time after the last request that an instance must wait before
  /// the instance is shut down.
  public var idleTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _idleTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_idleTimeout = newValue}
  }
  /// Returns true if `idleTimeout` has been explicitly set.
  public var hasIdleTimeout: Bool {return self._idleTimeout != nil}
  /// Clears the value of `idleTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearIdleTimeout() {self._idleTimeout = nil}

  /// Maximum number of instances to create for this version.
  public var maxInstances: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _idleTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A service with manual scaling runs continuously, allowing you to perform
/// complex initialization and rely on the state of its memory over time.
public struct Google_Appengine_V1beta_ManualScaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of instances to assign to the service at the start. This number
  /// can later be altered by using the
  /// [Modules API](https://cloud.google.com/appengine/docs/python/modules/functions)
  /// `set_num_instances()` function.
  public var instances: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Target scaling by CPU usage.
public struct Google_Appengine_V1beta_CpuUtilization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Period of time over which CPU utilization is calculated.
  public var aggregationWindowLength: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _aggregationWindowLength ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_aggregationWindowLength = newValue}
  }
  /// Returns true if `aggregationWindowLength` has been explicitly set.
  public var hasAggregationWindowLength: Bool {return self._aggregationWindowLength != nil}
  /// Clears the value of `aggregationWindowLength`. Subsequent reads from it will return its default value.
  public mutating func clearAggregationWindowLength() {self._aggregationWindowLength = nil}

  /// Target CPU utilization ratio to maintain when scaling. Must be between 0
  /// and 1.
  public var targetUtilization: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _aggregationWindowLength: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Target scaling by request utilization.
/// Only applicable in the App Engine flexible environment.
public struct Google_Appengine_V1beta_RequestUtilization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target requests per second.
  public var targetRequestCountPerSecond: Int32 = 0

  /// Target number of concurrent requests.
  public var targetConcurrentRequests: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Target scaling by disk usage.
/// Only applicable in the App Engine flexible environment.
public struct Google_Appengine_V1beta_DiskUtilization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target bytes written per second.
  public var targetWriteBytesPerSecond: Int32 = 0

  /// Target ops written per second.
  public var targetWriteOpsPerSecond: Int32 = 0

  /// Target bytes read per second.
  public var targetReadBytesPerSecond: Int32 = 0

  /// Target ops read per seconds.
  public var targetReadOpsPerSecond: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Target scaling by network usage.
/// Only applicable in the App Engine flexible environment.
public struct Google_Appengine_V1beta_NetworkUtilization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target bytes sent per second.
  public var targetSentBytesPerSecond: Int32 = 0

  /// Target packets sent per second.
  public var targetSentPacketsPerSecond: Int32 = 0

  /// Target bytes received per second.
  public var targetReceivedBytesPerSecond: Int32 = 0

  /// Target packets received per second.
  public var targetReceivedPacketsPerSecond: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Allows autoscaling based on Stackdriver metrics.
public struct Google_Appengine_V1beta_CustomMetric {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the metric.
  public var metricName: String = String()

  /// The type of the metric. Must be a string representing a Stackdriver
  /// metric type e.g. GAGUE, DELTA_PER_SECOND, etc.
  public var targetType: String = String()

  /// The target spec.
  public var targetSpec: Google_Appengine_V1beta_CustomMetric.OneOf_TargetSpec? = nil

  /// The target value for the metric.
  public var targetUtilization: Double {
    get {
      if case .targetUtilization(let v)? = targetSpec {return v}
      return 0
    }
    set {targetSpec = .targetUtilization(newValue)}
  }

  /// May be used instead of `target_utilization` when an instance can handle a
  /// specific amount of work/resources and the metric value is equal to the
  /// current amount of work remaining. The autoscaler will try to keep the
  /// number of instances equal to the metric value divided by
  /// `single_instance_assignment`.
  public var singleInstanceAssignment: Double {
    get {
      if case .singleInstanceAssignment(let v)? = targetSpec {return v}
      return 0
    }
    set {targetSpec = .singleInstanceAssignment(newValue)}
  }

  /// Allows filtering on the metric's fields.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The target spec.
  public enum OneOf_TargetSpec: Equatable {
    /// The target value for the metric.
    case targetUtilization(Double)
    /// May be used instead of `target_utilization` when an instance can handle a
    /// specific amount of work/resources and the metric value is equal to the
    /// current amount of work remaining. The autoscaler will try to keep the
    /// number of instances equal to the metric value divided by
    /// `single_instance_assignment`.
    case singleInstanceAssignment(Double)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Appengine_V1beta_CustomMetric.OneOf_TargetSpec, rhs: Google_Appengine_V1beta_CustomMetric.OneOf_TargetSpec) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetUtilization, .targetUtilization): return {
        guard case .targetUtilization(let l) = lhs, case .targetUtilization(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.singleInstanceAssignment, .singleInstanceAssignment): return {
        guard case .singleInstanceAssignment(let l) = lhs, case .singleInstanceAssignment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Scheduler settings for standard environment.
public struct Google_Appengine_V1beta_StandardSchedulerSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target CPU utilization ratio to maintain when scaling.
  public var targetCpuUtilization: Double = 0

  /// Target throughput utilization ratio to maintain when scaling
  public var targetThroughputUtilization: Double = 0

  /// Minimum number of instances to run for this version. Set to zero to disable
  /// `min_instances` configuration.
  public var minInstances: Int32 = 0

  /// Maximum number of instances to run for this version. Set to zero to disable
  /// `max_instances` configuration.
  public var maxInstances: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Extra network settings.
/// Only applicable in the App Engine flexible environment.
public struct Google_Appengine_V1beta_Network {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of ports, or port pairs, to forward from the virtual machine to the
  /// application container.
  /// Only applicable in the App Engine flexible environment.
  public var forwardedPorts: [String] = []

  /// Tag to apply to the instance during creation.
  /// Only applicable in the App Engine flexible environment.
  public var instanceTag: String = String()

  /// Google Compute Engine network where the virtual machines are created.
  /// Specify the short name, not the resource path.
  ///
  /// Defaults to `default`.
  public var name: String = String()

  /// Google Cloud Platform sub-network where the virtual machines are created.
  /// Specify the short name, not the resource path.
  ///
  /// If a subnetwork name is specified, a network name will also be required
  /// unless it is for the default network.
  ///
  /// * If the network that the instance is being created in is a Legacy network,
  /// then the IP address is allocated from the IPv4Range.
  /// * If the network that the instance is being created in is an auto Subnet
  /// Mode Network, then only network name should be specified (not the
  /// subnetwork_name) and the IP address is created from the IPCidrRange of the
  /// subnetwork that exists in that zone for that network.
  /// * If the network that the instance is being created in is a custom Subnet
  /// Mode Network, then the subnetwork_name must be specified and the
  /// IP address is created from the IPCidrRange of the subnetwork.
  ///
  /// If specified, the subnetwork must exist in the same region as the
  /// App Engine flexible environment application.
  public var subnetworkName: String = String()

  /// Enable session affinity.
  /// Only applicable in the App Engine flexible environment.
  public var sessionAffinity: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Volumes mounted within the app container.
/// Only applicable in the App Engine flexible environment.
public struct Google_Appengine_V1beta_Volume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique name for the volume.
  public var name: String = String()

  /// Underlying volume type, e.g. 'tmpfs'.
  public var volumeType: String = String()

  /// Volume size in gigabytes.
  public var sizeGb: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Machine resources for a version.
public struct Google_Appengine_V1beta_Resources {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of CPU cores needed.
  public var cpu: Double = 0

  /// Disk size (GB) needed.
  public var diskGb: Double = 0

  /// Memory (GB) needed.
  public var memoryGb: Double = 0

  /// User specified volumes.
  public var volumes: [Google_Appengine_V1beta_Volume] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// VPC access connector specification.
public struct Google_Appengine_V1beta_VpcAccessConnector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full Serverless VPC Access Connector name e.g.
  /// /projects/my-project/locations/us-central1/connectors/c1.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The entrypoint for the application.
public struct Google_Appengine_V1beta_Entrypoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The command to run.
  public var command: Google_Appengine_V1beta_Entrypoint.OneOf_Command? = nil

  /// The format should be a shell command that can be fed to `bash -c`.
  public var shell: String {
    get {
      if case .shell(let v)? = command {return v}
      return String()
    }
    set {command = .shell(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The command to run.
  public enum OneOf_Command: Equatable {
    /// The format should be a shell command that can be fed to `bash -c`.
    case shell(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Appengine_V1beta_Entrypoint.OneOf_Command, rhs: Google_Appengine_V1beta_Entrypoint.OneOf_Command) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.shell, .shell): return {
        guard case .shell(let l) = lhs, case .shell(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.appengine.v1beta"

extension Google_Appengine_V1beta_InboundServiceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INBOUND_SERVICE_UNSPECIFIED"),
    1: .same(proto: "INBOUND_SERVICE_MAIL"),
    2: .same(proto: "INBOUND_SERVICE_MAIL_BOUNCE"),
    3: .same(proto: "INBOUND_SERVICE_XMPP_ERROR"),
    4: .same(proto: "INBOUND_SERVICE_XMPP_MESSAGE"),
    5: .same(proto: "INBOUND_SERVICE_XMPP_SUBSCRIBE"),
    6: .same(proto: "INBOUND_SERVICE_XMPP_PRESENCE"),
    7: .same(proto: "INBOUND_SERVICE_CHANNEL_PRESENCE"),
    9: .same(proto: "INBOUND_SERVICE_WARMUP"),
  ]
}

extension Google_Appengine_V1beta_ServingStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVING_STATUS_UNSPECIFIED"),
    1: .same(proto: "SERVING"),
    2: .same(proto: "STOPPED"),
  ]
}

extension Google_Appengine_V1beta_Version: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Version"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
    3: .standard(proto: "automatic_scaling"),
    4: .standard(proto: "basic_scaling"),
    5: .standard(proto: "manual_scaling"),
    6: .standard(proto: "inbound_services"),
    7: .standard(proto: "instance_class"),
    8: .same(proto: "network"),
    118: .same(proto: "zones"),
    9: .same(proto: "resources"),
    10: .same(proto: "runtime"),
    117: .standard(proto: "runtime_channel"),
    11: .same(proto: "threadsafe"),
    12: .same(proto: "vm"),
    13: .standard(proto: "beta_settings"),
    14: .same(proto: "env"),
    15: .standard(proto: "serving_status"),
    16: .standard(proto: "created_by"),
    17: .standard(proto: "create_time"),
    18: .standard(proto: "disk_usage_bytes"),
    21: .standard(proto: "runtime_api_version"),
    22: .standard(proto: "runtime_main_executable_path"),
    100: .same(proto: "handlers"),
    101: .standard(proto: "error_handlers"),
    102: .same(proto: "libraries"),
    103: .standard(proto: "api_config"),
    104: .standard(proto: "env_variables"),
    105: .standard(proto: "default_expiration"),
    106: .standard(proto: "health_check"),
    112: .standard(proto: "readiness_check"),
    113: .standard(proto: "liveness_check"),
    107: .standard(proto: "nobuild_files_regex"),
    108: .same(proto: "deployment"),
    109: .standard(proto: "version_url"),
    110: .standard(proto: "endpoints_api_service"),
    122: .same(proto: "entrypoint"),
    121: .standard(proto: "vpc_access_connector"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _id: String = String()
    var _scaling: Google_Appengine_V1beta_Version.OneOf_Scaling?
    var _inboundServices: [Google_Appengine_V1beta_InboundServiceType] = []
    var _instanceClass: String = String()
    var _network: Google_Appengine_V1beta_Network? = nil
    var _zones: [String] = []
    var _resources: Google_Appengine_V1beta_Resources? = nil
    var _runtime: String = String()
    var _runtimeChannel: String = String()
    var _threadsafe: Bool = false
    var _vm: Bool = false
    var _betaSettings: Dictionary<String,String> = [:]
    var _env: String = String()
    var _servingStatus: Google_Appengine_V1beta_ServingStatus = .unspecified
    var _createdBy: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _diskUsageBytes: Int64 = 0
    var _runtimeApiVersion: String = String()
    var _runtimeMainExecutablePath: String = String()
    var _handlers: [Google_Appengine_V1beta_UrlMap] = []
    var _errorHandlers: [Google_Appengine_V1beta_ErrorHandler] = []
    var _libraries: [Google_Appengine_V1beta_Library] = []
    var _apiConfig: Google_Appengine_V1beta_ApiConfigHandler? = nil
    var _envVariables: Dictionary<String,String> = [:]
    var _defaultExpiration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _healthCheck: Google_Appengine_V1beta_HealthCheck? = nil
    var _readinessCheck: Google_Appengine_V1beta_ReadinessCheck? = nil
    var _livenessCheck: Google_Appengine_V1beta_LivenessCheck? = nil
    var _nobuildFilesRegex: String = String()
    var _deployment: Google_Appengine_V1beta_Deployment? = nil
    var _versionURL: String = String()
    var _endpointsApiService: Google_Appengine_V1beta_EndpointsApiService? = nil
    var _entrypoint: Google_Appengine_V1beta_Entrypoint? = nil
    var _vpcAccessConnector: Google_Appengine_V1beta_VpcAccessConnector? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _id = source._id
      _scaling = source._scaling
      _inboundServices = source._inboundServices
      _instanceClass = source._instanceClass
      _network = source._network
      _zones = source._zones
      _resources = source._resources
      _runtime = source._runtime
      _runtimeChannel = source._runtimeChannel
      _threadsafe = source._threadsafe
      _vm = source._vm
      _betaSettings = source._betaSettings
      _env = source._env
      _servingStatus = source._servingStatus
      _createdBy = source._createdBy
      _createTime = source._createTime
      _diskUsageBytes = source._diskUsageBytes
      _runtimeApiVersion = source._runtimeApiVersion
      _runtimeMainExecutablePath = source._runtimeMainExecutablePath
      _handlers = source._handlers
      _errorHandlers = source._errorHandlers
      _libraries = source._libraries
      _apiConfig = source._apiConfig
      _envVariables = source._envVariables
      _defaultExpiration = source._defaultExpiration
      _healthCheck = source._healthCheck
      _readinessCheck = source._readinessCheck
      _livenessCheck = source._livenessCheck
      _nobuildFilesRegex = source._nobuildFilesRegex
      _deployment = source._deployment
      _versionURL = source._versionURL
      _endpointsApiService = source._endpointsApiService
      _entrypoint = source._entrypoint
      _vpcAccessConnector = source._vpcAccessConnector
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 3: try {
          var v: Google_Appengine_V1beta_AutomaticScaling?
          if let current = _storage._scaling {
            try decoder.handleConflictingOneOf()
            if case .automaticScaling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scaling = .automaticScaling(v)}
        }()
        case 4: try {
          var v: Google_Appengine_V1beta_BasicScaling?
          if let current = _storage._scaling {
            try decoder.handleConflictingOneOf()
            if case .basicScaling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scaling = .basicScaling(v)}
        }()
        case 5: try {
          var v: Google_Appengine_V1beta_ManualScaling?
          if let current = _storage._scaling {
            try decoder.handleConflictingOneOf()
            if case .manualScaling(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._scaling = .manualScaling(v)}
        }()
        case 6: try { try decoder.decodeRepeatedEnumField(value: &_storage._inboundServices) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._instanceClass) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._network) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._resources) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._runtime) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._threadsafe) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._vm) }()
        case 13: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._betaSettings) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._env) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._servingStatus) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._createdBy) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 18: try { try decoder.decodeSingularInt64Field(value: &_storage._diskUsageBytes) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._runtimeApiVersion) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._runtimeMainExecutablePath) }()
        case 100: try { try decoder.decodeRepeatedMessageField(value: &_storage._handlers) }()
        case 101: try { try decoder.decodeRepeatedMessageField(value: &_storage._errorHandlers) }()
        case 102: try { try decoder.decodeRepeatedMessageField(value: &_storage._libraries) }()
        case 103: try { try decoder.decodeSingularMessageField(value: &_storage._apiConfig) }()
        case 104: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._envVariables) }()
        case 105: try { try decoder.decodeSingularMessageField(value: &_storage._defaultExpiration) }()
        case 106: try { try decoder.decodeSingularMessageField(value: &_storage._healthCheck) }()
        case 107: try { try decoder.decodeSingularStringField(value: &_storage._nobuildFilesRegex) }()
        case 108: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        case 109: try { try decoder.decodeSingularStringField(value: &_storage._versionURL) }()
        case 110: try { try decoder.decodeSingularMessageField(value: &_storage._endpointsApiService) }()
        case 112: try { try decoder.decodeSingularMessageField(value: &_storage._readinessCheck) }()
        case 113: try { try decoder.decodeSingularMessageField(value: &_storage._livenessCheck) }()
        case 117: try { try decoder.decodeSingularStringField(value: &_storage._runtimeChannel) }()
        case 118: try { try decoder.decodeRepeatedStringField(value: &_storage._zones) }()
        case 121: try { try decoder.decodeSingularMessageField(value: &_storage._vpcAccessConnector) }()
        case 122: try { try decoder.decodeSingularMessageField(value: &_storage._entrypoint) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._scaling {
      case .automaticScaling?: try {
        guard case .automaticScaling(let v)? = _storage._scaling else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .basicScaling?: try {
        guard case .basicScaling(let v)? = _storage._scaling else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .manualScaling?: try {
        guard case .manualScaling(let v)? = _storage._scaling else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
      if !_storage._inboundServices.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._inboundServices, fieldNumber: 6)
      }
      if !_storage._instanceClass.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instanceClass, fieldNumber: 7)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._resources {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._runtime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtime, fieldNumber: 10)
      }
      if _storage._threadsafe != false {
        try visitor.visitSingularBoolField(value: _storage._threadsafe, fieldNumber: 11)
      }
      if _storage._vm != false {
        try visitor.visitSingularBoolField(value: _storage._vm, fieldNumber: 12)
      }
      if !_storage._betaSettings.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._betaSettings, fieldNumber: 13)
      }
      if !_storage._env.isEmpty {
        try visitor.visitSingularStringField(value: _storage._env, fieldNumber: 14)
      }
      if _storage._servingStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._servingStatus, fieldNumber: 15)
      }
      if !_storage._createdBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdBy, fieldNumber: 16)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if _storage._diskUsageBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._diskUsageBytes, fieldNumber: 18)
      }
      if !_storage._runtimeApiVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtimeApiVersion, fieldNumber: 21)
      }
      if !_storage._runtimeMainExecutablePath.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtimeMainExecutablePath, fieldNumber: 22)
      }
      if !_storage._handlers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._handlers, fieldNumber: 100)
      }
      if !_storage._errorHandlers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._errorHandlers, fieldNumber: 101)
      }
      if !_storage._libraries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._libraries, fieldNumber: 102)
      }
      if let v = _storage._apiConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      }
      if !_storage._envVariables.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._envVariables, fieldNumber: 104)
      }
      if let v = _storage._defaultExpiration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 105)
      }
      if let v = _storage._healthCheck {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 106)
      }
      if !_storage._nobuildFilesRegex.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nobuildFilesRegex, fieldNumber: 107)
      }
      if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
      }
      if !_storage._versionURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionURL, fieldNumber: 109)
      }
      if let v = _storage._endpointsApiService {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 110)
      }
      if let v = _storage._readinessCheck {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 112)
      }
      if let v = _storage._livenessCheck {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 113)
      }
      if !_storage._runtimeChannel.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runtimeChannel, fieldNumber: 117)
      }
      if !_storage._zones.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._zones, fieldNumber: 118)
      }
      if let v = _storage._vpcAccessConnector {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 121)
      }
      if let v = _storage._entrypoint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 122)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_Version, rhs: Google_Appengine_V1beta_Version) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._scaling != rhs_storage._scaling {return false}
        if _storage._inboundServices != rhs_storage._inboundServices {return false}
        if _storage._instanceClass != rhs_storage._instanceClass {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._zones != rhs_storage._zones {return false}
        if _storage._resources != rhs_storage._resources {return false}
        if _storage._runtime != rhs_storage._runtime {return false}
        if _storage._runtimeChannel != rhs_storage._runtimeChannel {return false}
        if _storage._threadsafe != rhs_storage._threadsafe {return false}
        if _storage._vm != rhs_storage._vm {return false}
        if _storage._betaSettings != rhs_storage._betaSettings {return false}
        if _storage._env != rhs_storage._env {return false}
        if _storage._servingStatus != rhs_storage._servingStatus {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._diskUsageBytes != rhs_storage._diskUsageBytes {return false}
        if _storage._runtimeApiVersion != rhs_storage._runtimeApiVersion {return false}
        if _storage._runtimeMainExecutablePath != rhs_storage._runtimeMainExecutablePath {return false}
        if _storage._handlers != rhs_storage._handlers {return false}
        if _storage._errorHandlers != rhs_storage._errorHandlers {return false}
        if _storage._libraries != rhs_storage._libraries {return false}
        if _storage._apiConfig != rhs_storage._apiConfig {return false}
        if _storage._envVariables != rhs_storage._envVariables {return false}
        if _storage._defaultExpiration != rhs_storage._defaultExpiration {return false}
        if _storage._healthCheck != rhs_storage._healthCheck {return false}
        if _storage._readinessCheck != rhs_storage._readinessCheck {return false}
        if _storage._livenessCheck != rhs_storage._livenessCheck {return false}
        if _storage._nobuildFilesRegex != rhs_storage._nobuildFilesRegex {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        if _storage._versionURL != rhs_storage._versionURL {return false}
        if _storage._endpointsApiService != rhs_storage._endpointsApiService {return false}
        if _storage._entrypoint != rhs_storage._entrypoint {return false}
        if _storage._vpcAccessConnector != rhs_storage._vpcAccessConnector {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_EndpointsApiService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EndpointsApiService"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "config_id"),
    3: .standard(proto: "rollout_strategy"),
    4: .standard(proto: "disable_trace_sampling"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.configID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.rolloutStrategy) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.disableTraceSampling) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.configID.isEmpty {
      try visitor.visitSingularStringField(value: self.configID, fieldNumber: 2)
    }
    if self.rolloutStrategy != .unspecifiedRolloutStrategy {
      try visitor.visitSingularEnumField(value: self.rolloutStrategy, fieldNumber: 3)
    }
    if self.disableTraceSampling != false {
      try visitor.visitSingularBoolField(value: self.disableTraceSampling, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_EndpointsApiService, rhs: Google_Appengine_V1beta_EndpointsApiService) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.configID != rhs.configID {return false}
    if lhs.rolloutStrategy != rhs.rolloutStrategy {return false}
    if lhs.disableTraceSampling != rhs.disableTraceSampling {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_EndpointsApiService.RolloutStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED_ROLLOUT_STRATEGY"),
    1: .same(proto: "FIXED"),
    2: .same(proto: "MANAGED"),
  ]
}

extension Google_Appengine_V1beta_AutomaticScaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutomaticScaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cool_down_period"),
    2: .standard(proto: "cpu_utilization"),
    3: .standard(proto: "max_concurrent_requests"),
    4: .standard(proto: "max_idle_instances"),
    5: .standard(proto: "max_total_instances"),
    6: .standard(proto: "max_pending_latency"),
    7: .standard(proto: "min_idle_instances"),
    8: .standard(proto: "min_total_instances"),
    9: .standard(proto: "min_pending_latency"),
    10: .standard(proto: "request_utilization"),
    11: .standard(proto: "disk_utilization"),
    12: .standard(proto: "network_utilization"),
    21: .standard(proto: "custom_metrics"),
    20: .standard(proto: "standard_scheduler_settings"),
  ]

  fileprivate class _StorageClass {
    var _coolDownPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _cpuUtilization: Google_Appengine_V1beta_CpuUtilization? = nil
    var _maxConcurrentRequests: Int32 = 0
    var _maxIdleInstances: Int32 = 0
    var _maxTotalInstances: Int32 = 0
    var _maxPendingLatency: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _minIdleInstances: Int32 = 0
    var _minTotalInstances: Int32 = 0
    var _minPendingLatency: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _requestUtilization: Google_Appengine_V1beta_RequestUtilization? = nil
    var _diskUtilization: Google_Appengine_V1beta_DiskUtilization? = nil
    var _networkUtilization: Google_Appengine_V1beta_NetworkUtilization? = nil
    var _customMetrics: [Google_Appengine_V1beta_CustomMetric] = []
    var _standardSchedulerSettings: Google_Appengine_V1beta_StandardSchedulerSettings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _coolDownPeriod = source._coolDownPeriod
      _cpuUtilization = source._cpuUtilization
      _maxConcurrentRequests = source._maxConcurrentRequests
      _maxIdleInstances = source._maxIdleInstances
      _maxTotalInstances = source._maxTotalInstances
      _maxPendingLatency = source._maxPendingLatency
      _minIdleInstances = source._minIdleInstances
      _minTotalInstances = source._minTotalInstances
      _minPendingLatency = source._minPendingLatency
      _requestUtilization = source._requestUtilization
      _diskUtilization = source._diskUtilization
      _networkUtilization = source._networkUtilization
      _customMetrics = source._customMetrics
      _standardSchedulerSettings = source._standardSchedulerSettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._coolDownPeriod) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._cpuUtilization) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._maxConcurrentRequests) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._maxIdleInstances) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._maxTotalInstances) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._maxPendingLatency) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._minIdleInstances) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._minTotalInstances) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._minPendingLatency) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._requestUtilization) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._diskUtilization) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._networkUtilization) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._standardSchedulerSettings) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._customMetrics) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._coolDownPeriod {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._cpuUtilization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._maxConcurrentRequests != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxConcurrentRequests, fieldNumber: 3)
      }
      if _storage._maxIdleInstances != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxIdleInstances, fieldNumber: 4)
      }
      if _storage._maxTotalInstances != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxTotalInstances, fieldNumber: 5)
      }
      if let v = _storage._maxPendingLatency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._minIdleInstances != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minIdleInstances, fieldNumber: 7)
      }
      if _storage._minTotalInstances != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minTotalInstances, fieldNumber: 8)
      }
      if let v = _storage._minPendingLatency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if let v = _storage._requestUtilization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._diskUtilization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._networkUtilization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._standardSchedulerSettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if !_storage._customMetrics.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._customMetrics, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_AutomaticScaling, rhs: Google_Appengine_V1beta_AutomaticScaling) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._coolDownPeriod != rhs_storage._coolDownPeriod {return false}
        if _storage._cpuUtilization != rhs_storage._cpuUtilization {return false}
        if _storage._maxConcurrentRequests != rhs_storage._maxConcurrentRequests {return false}
        if _storage._maxIdleInstances != rhs_storage._maxIdleInstances {return false}
        if _storage._maxTotalInstances != rhs_storage._maxTotalInstances {return false}
        if _storage._maxPendingLatency != rhs_storage._maxPendingLatency {return false}
        if _storage._minIdleInstances != rhs_storage._minIdleInstances {return false}
        if _storage._minTotalInstances != rhs_storage._minTotalInstances {return false}
        if _storage._minPendingLatency != rhs_storage._minPendingLatency {return false}
        if _storage._requestUtilization != rhs_storage._requestUtilization {return false}
        if _storage._diskUtilization != rhs_storage._diskUtilization {return false}
        if _storage._networkUtilization != rhs_storage._networkUtilization {return false}
        if _storage._customMetrics != rhs_storage._customMetrics {return false}
        if _storage._standardSchedulerSettings != rhs_storage._standardSchedulerSettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_BasicScaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BasicScaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "idle_timeout"),
    2: .standard(proto: "max_instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._idleTimeout) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxInstances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._idleTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.maxInstances != 0 {
      try visitor.visitSingularInt32Field(value: self.maxInstances, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_BasicScaling, rhs: Google_Appengine_V1beta_BasicScaling) -> Bool {
    if lhs._idleTimeout != rhs._idleTimeout {return false}
    if lhs.maxInstances != rhs.maxInstances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_ManualScaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManualScaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.instances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.instances != 0 {
      try visitor.visitSingularInt32Field(value: self.instances, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_ManualScaling, rhs: Google_Appengine_V1beta_ManualScaling) -> Bool {
    if lhs.instances != rhs.instances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_CpuUtilization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CpuUtilization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "aggregation_window_length"),
    2: .standard(proto: "target_utilization"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._aggregationWindowLength) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.targetUtilization) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._aggregationWindowLength {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.targetUtilization != 0 {
      try visitor.visitSingularDoubleField(value: self.targetUtilization, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_CpuUtilization, rhs: Google_Appengine_V1beta_CpuUtilization) -> Bool {
    if lhs._aggregationWindowLength != rhs._aggregationWindowLength {return false}
    if lhs.targetUtilization != rhs.targetUtilization {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_RequestUtilization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestUtilization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_request_count_per_second"),
    2: .standard(proto: "target_concurrent_requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.targetRequestCountPerSecond) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.targetConcurrentRequests) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetRequestCountPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetRequestCountPerSecond, fieldNumber: 1)
    }
    if self.targetConcurrentRequests != 0 {
      try visitor.visitSingularInt32Field(value: self.targetConcurrentRequests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_RequestUtilization, rhs: Google_Appengine_V1beta_RequestUtilization) -> Bool {
    if lhs.targetRequestCountPerSecond != rhs.targetRequestCountPerSecond {return false}
    if lhs.targetConcurrentRequests != rhs.targetConcurrentRequests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_DiskUtilization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DiskUtilization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .standard(proto: "target_write_bytes_per_second"),
    15: .standard(proto: "target_write_ops_per_second"),
    16: .standard(proto: "target_read_bytes_per_second"),
    17: .standard(proto: "target_read_ops_per_second"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 14: try { try decoder.decodeSingularInt32Field(value: &self.targetWriteBytesPerSecond) }()
      case 15: try { try decoder.decodeSingularInt32Field(value: &self.targetWriteOpsPerSecond) }()
      case 16: try { try decoder.decodeSingularInt32Field(value: &self.targetReadBytesPerSecond) }()
      case 17: try { try decoder.decodeSingularInt32Field(value: &self.targetReadOpsPerSecond) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetWriteBytesPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetWriteBytesPerSecond, fieldNumber: 14)
    }
    if self.targetWriteOpsPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetWriteOpsPerSecond, fieldNumber: 15)
    }
    if self.targetReadBytesPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetReadBytesPerSecond, fieldNumber: 16)
    }
    if self.targetReadOpsPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetReadOpsPerSecond, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_DiskUtilization, rhs: Google_Appengine_V1beta_DiskUtilization) -> Bool {
    if lhs.targetWriteBytesPerSecond != rhs.targetWriteBytesPerSecond {return false}
    if lhs.targetWriteOpsPerSecond != rhs.targetWriteOpsPerSecond {return false}
    if lhs.targetReadBytesPerSecond != rhs.targetReadBytesPerSecond {return false}
    if lhs.targetReadOpsPerSecond != rhs.targetReadOpsPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_NetworkUtilization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkUtilization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_sent_bytes_per_second"),
    11: .standard(proto: "target_sent_packets_per_second"),
    12: .standard(proto: "target_received_bytes_per_second"),
    13: .standard(proto: "target_received_packets_per_second"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.targetSentBytesPerSecond) }()
      case 11: try { try decoder.decodeSingularInt32Field(value: &self.targetSentPacketsPerSecond) }()
      case 12: try { try decoder.decodeSingularInt32Field(value: &self.targetReceivedBytesPerSecond) }()
      case 13: try { try decoder.decodeSingularInt32Field(value: &self.targetReceivedPacketsPerSecond) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetSentBytesPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetSentBytesPerSecond, fieldNumber: 1)
    }
    if self.targetSentPacketsPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetSentPacketsPerSecond, fieldNumber: 11)
    }
    if self.targetReceivedBytesPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetReceivedBytesPerSecond, fieldNumber: 12)
    }
    if self.targetReceivedPacketsPerSecond != 0 {
      try visitor.visitSingularInt32Field(value: self.targetReceivedPacketsPerSecond, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_NetworkUtilization, rhs: Google_Appengine_V1beta_NetworkUtilization) -> Bool {
    if lhs.targetSentBytesPerSecond != rhs.targetSentBytesPerSecond {return false}
    if lhs.targetSentPacketsPerSecond != rhs.targetSentPacketsPerSecond {return false}
    if lhs.targetReceivedBytesPerSecond != rhs.targetReceivedBytesPerSecond {return false}
    if lhs.targetReceivedPacketsPerSecond != rhs.targetReceivedPacketsPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_CustomMetric: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomMetric"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "metric_name"),
    2: .standard(proto: "target_type"),
    3: .standard(proto: "target_utilization"),
    4: .standard(proto: "single_instance_assignment"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.metricName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetType) }()
      case 3: try {
        if self.targetSpec != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.targetSpec = .targetUtilization(v)}
      }()
      case 4: try {
        if self.targetSpec != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.targetSpec = .singleInstanceAssignment(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metricName.isEmpty {
      try visitor.visitSingularStringField(value: self.metricName, fieldNumber: 1)
    }
    if !self.targetType.isEmpty {
      try visitor.visitSingularStringField(value: self.targetType, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.targetSpec {
    case .targetUtilization?: try {
      guard case .targetUtilization(let v)? = self.targetSpec else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .singleInstanceAssignment?: try {
      guard case .singleInstanceAssignment(let v)? = self.targetSpec else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_CustomMetric, rhs: Google_Appengine_V1beta_CustomMetric) -> Bool {
    if lhs.metricName != rhs.metricName {return false}
    if lhs.targetType != rhs.targetType {return false}
    if lhs.targetSpec != rhs.targetSpec {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_StandardSchedulerSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StandardSchedulerSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_cpu_utilization"),
    2: .standard(proto: "target_throughput_utilization"),
    3: .standard(proto: "min_instances"),
    4: .standard(proto: "max_instances"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.targetCpuUtilization) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.targetThroughputUtilization) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.minInstances) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maxInstances) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.targetCpuUtilization != 0 {
      try visitor.visitSingularDoubleField(value: self.targetCpuUtilization, fieldNumber: 1)
    }
    if self.targetThroughputUtilization != 0 {
      try visitor.visitSingularDoubleField(value: self.targetThroughputUtilization, fieldNumber: 2)
    }
    if self.minInstances != 0 {
      try visitor.visitSingularInt32Field(value: self.minInstances, fieldNumber: 3)
    }
    if self.maxInstances != 0 {
      try visitor.visitSingularInt32Field(value: self.maxInstances, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_StandardSchedulerSettings, rhs: Google_Appengine_V1beta_StandardSchedulerSettings) -> Bool {
    if lhs.targetCpuUtilization != rhs.targetCpuUtilization {return false}
    if lhs.targetThroughputUtilization != rhs.targetThroughputUtilization {return false}
    if lhs.minInstances != rhs.minInstances {return false}
    if lhs.maxInstances != rhs.maxInstances {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Network"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "forwarded_ports"),
    2: .standard(proto: "instance_tag"),
    3: .same(proto: "name"),
    4: .standard(proto: "subnetwork_name"),
    5: .standard(proto: "session_affinity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.forwardedPorts) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instanceTag) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subnetworkName) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.sessionAffinity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.forwardedPorts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.forwardedPorts, fieldNumber: 1)
    }
    if !self.instanceTag.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceTag, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.subnetworkName.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetworkName, fieldNumber: 4)
    }
    if self.sessionAffinity != false {
      try visitor.visitSingularBoolField(value: self.sessionAffinity, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_Network, rhs: Google_Appengine_V1beta_Network) -> Bool {
    if lhs.forwardedPorts != rhs.forwardedPorts {return false}
    if lhs.instanceTag != rhs.instanceTag {return false}
    if lhs.name != rhs.name {return false}
    if lhs.subnetworkName != rhs.subnetworkName {return false}
    if lhs.sessionAffinity != rhs.sessionAffinity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_Volume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Volume"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "volume_type"),
    3: .standard(proto: "size_gb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.volumeType) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.sizeGb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.volumeType.isEmpty {
      try visitor.visitSingularStringField(value: self.volumeType, fieldNumber: 2)
    }
    if self.sizeGb != 0 {
      try visitor.visitSingularDoubleField(value: self.sizeGb, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_Volume, rhs: Google_Appengine_V1beta_Volume) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.volumeType != rhs.volumeType {return false}
    if lhs.sizeGb != rhs.sizeGb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_Resources: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resources"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cpu"),
    2: .standard(proto: "disk_gb"),
    3: .standard(proto: "memory_gb"),
    4: .same(proto: "volumes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.cpu) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.diskGb) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.memoryGb) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.volumes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cpu != 0 {
      try visitor.visitSingularDoubleField(value: self.cpu, fieldNumber: 1)
    }
    if self.diskGb != 0 {
      try visitor.visitSingularDoubleField(value: self.diskGb, fieldNumber: 2)
    }
    if self.memoryGb != 0 {
      try visitor.visitSingularDoubleField(value: self.memoryGb, fieldNumber: 3)
    }
    if !self.volumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.volumes, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_Resources, rhs: Google_Appengine_V1beta_Resources) -> Bool {
    if lhs.cpu != rhs.cpu {return false}
    if lhs.diskGb != rhs.diskGb {return false}
    if lhs.memoryGb != rhs.memoryGb {return false}
    if lhs.volumes != rhs.volumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_VpcAccessConnector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VpcAccessConnector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_VpcAccessConnector, rhs: Google_Appengine_V1beta_VpcAccessConnector) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_Entrypoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Entrypoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "shell"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.command != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.command = .shell(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .shell(let v)? = self.command {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_Entrypoint, rhs: Google_Appengine_V1beta_Entrypoint) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

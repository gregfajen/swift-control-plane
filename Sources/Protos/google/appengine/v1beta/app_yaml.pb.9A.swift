// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/appengine/v1beta/app_yaml.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Actions to take when the user is not logged in.
public enum Google_Appengine_V1beta_AuthFailAction: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified. `AUTH_FAIL_ACTION_REDIRECT` is assumed.
  case unspecified // = 0

  /// Redirects user to "accounts.google.com". The user is redirected back to the
  /// application URL after signing in or creating an account.
  case redirect // = 1

  /// Rejects request with a `401` HTTP status code and an error
  /// message.
  case unauthorized // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .redirect
    case 2: self = .unauthorized
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .redirect: return 1
    case .unauthorized: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Appengine_V1beta_AuthFailAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_AuthFailAction] = [
    .unspecified,
    .redirect,
    .unauthorized,
  ]
}

#endif  // swift(>=4.2)

/// Methods to restrict access to a URL based on login status.
public enum Google_Appengine_V1beta_LoginRequirement: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified. `LOGIN_OPTIONAL` is assumed.
  case loginUnspecified // = 0

  /// Does not require that the user is signed in.
  case loginOptional // = 1

  /// If the user is not signed in, the `auth_fail_action` is taken.
  /// In addition, if the user is not an administrator for the
  /// application, they are given an error message regardless of
  /// `auth_fail_action`. If the user is an administrator, the handler
  /// proceeds.
  case loginAdmin // = 2

  /// If the user has signed in, the handler proceeds normally. Otherwise, the
  /// auth_fail_action is taken.
  case loginRequired // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .loginUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .loginUnspecified
    case 1: self = .loginOptional
    case 2: self = .loginAdmin
    case 3: self = .loginRequired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .loginUnspecified: return 0
    case .loginOptional: return 1
    case .loginAdmin: return 2
    case .loginRequired: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Appengine_V1beta_LoginRequirement: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_LoginRequirement] = [
    .loginUnspecified,
    .loginOptional,
    .loginAdmin,
    .loginRequired,
  ]
}

#endif  // swift(>=4.2)

/// Methods to enforce security (HTTPS) on a URL.
public enum Google_Appengine_V1beta_SecurityLevel: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not specified.
  case secureUnspecified // = 0

  /// Both HTTP and HTTPS requests with URLs that match the handler succeed
  /// without redirects. The application can examine the request to determine
  /// which protocol was used, and respond accordingly.
  public static let secureDefault = secureUnspecified

  /// Requests for a URL that match this handler that use HTTPS are automatically
  /// redirected to the HTTP equivalent URL.
  case secureNever // = 1

  /// Both HTTP and HTTPS requests with URLs that match the handler succeed
  /// without redirects. The application can examine the request to determine
  /// which protocol was used and respond accordingly.
  case secureOptional // = 2

  /// Requests for a URL that match this handler that do not use HTTPS are
  /// automatically redirected to the HTTPS URL with the same path. Query
  /// parameters are reserved for the redirect.
  case secureAlways // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .secureUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .secureUnspecified
    case 1: self = .secureNever
    case 2: self = .secureOptional
    case 3: self = .secureAlways
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .secureUnspecified: return 0
    case .secureNever: return 1
    case .secureOptional: return 2
    case .secureAlways: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Appengine_V1beta_SecurityLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_SecurityLevel] = [
    .secureUnspecified,
    .secureNever,
    .secureOptional,
    .secureAlways,
  ]
}

#endif  // swift(>=4.2)

/// [Google Cloud Endpoints](https://cloud.google.com/appengine/docs/python/endpoints/)
/// configuration for API handlers.
public struct Google_Appengine_V1beta_ApiConfigHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Action to take when users access resources that require
  /// authentication. Defaults to `redirect`.
  public var authFailAction: Google_Appengine_V1beta_AuthFailAction = .unspecified

  /// Level of login required to access this resource. Defaults to
  /// `optional`.
  public var login: Google_Appengine_V1beta_LoginRequirement = .loginUnspecified

  /// Path to the script from the application root directory.
  public var script: String = String()

  /// Security (HTTPS) enforcement for this URL.
  public var securityLevel: Google_Appengine_V1beta_SecurityLevel = .secureUnspecified

  /// URL to serve the endpoint at.
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Custom static error page to be served when an error occurs.
public struct Google_Appengine_V1beta_ErrorHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Error condition this handler applies to.
  public var errorCode: Google_Appengine_V1beta_ErrorHandler.ErrorCode = .unspecified

  /// Static file content to be served for this error.
  public var staticFile: String = String()

  /// MIME type of file. Defaults to `text/html`.
  public var mimeType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Error codes.
  public enum ErrorCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. ERROR_CODE_DEFAULT is assumed.
    case unspecified // = 0

    /// All other error types.
    public static let `default` = unspecified

    /// Application has exceeded a resource quota.
    case overQuota // = 1

    /// Client blocked by the application's Denial of Service protection
    /// configuration.
    case dosApiDenial // = 2

    /// Deadline reached before the application responds.
    case timeout // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .overQuota
      case 2: self = .dosApiDenial
      case 3: self = .timeout
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .overQuota: return 1
      case .dosApiDenial: return 2
      case .timeout: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Appengine_V1beta_ErrorHandler.ErrorCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_ErrorHandler.ErrorCode] = [
    .unspecified,
    .overQuota,
    .dosApiDenial,
    .timeout,
  ]
}

#endif  // swift(>=4.2)

/// URL pattern and description of how the URL should be handled. App Engine can
/// handle URLs by executing application code or by serving static files
/// uploaded with the version, such as images, CSS, or JavaScript.
public struct Google_Appengine_V1beta_UrlMap {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// URL prefix. Uses regular expression syntax, which means regexp
  /// special characters must be escaped, but should not contain groupings.
  /// All URLs that begin with this prefix are handled by this handler, using the
  /// portion of the URL after the prefix as part of the file path.
  public var urlRegex: String = String()

  /// Type of handler for this URL pattern.
  public var handlerType: Google_Appengine_V1beta_UrlMap.OneOf_HandlerType? = nil

  /// Returns the contents of a file, such as an image, as the response.
  public var staticFiles: Google_Appengine_V1beta_StaticFilesHandler {
    get {
      if case .staticFiles(let v)? = handlerType {return v}
      return Google_Appengine_V1beta_StaticFilesHandler()
    }
    set {handlerType = .staticFiles(newValue)}
  }

  /// Executes a script to handle the requests that match this URL
  /// pattern. Only the `auto` value is supported for Node.js in the
  /// App Engine standard environment, for example `"script": "auto"`.
  public var script: Google_Appengine_V1beta_ScriptHandler {
    get {
      if case .script(let v)? = handlerType {return v}
      return Google_Appengine_V1beta_ScriptHandler()
    }
    set {handlerType = .script(newValue)}
  }

  /// Uses API Endpoints to handle requests.
  public var apiEndpoint: Google_Appengine_V1beta_ApiEndpointHandler {
    get {
      if case .apiEndpoint(let v)? = handlerType {return v}
      return Google_Appengine_V1beta_ApiEndpointHandler()
    }
    set {handlerType = .apiEndpoint(newValue)}
  }

  /// Security (HTTPS) enforcement for this URL.
  public var securityLevel: Google_Appengine_V1beta_SecurityLevel = .secureUnspecified

  /// Level of login required to access this resource. Not supported for Node.js
  /// in the App Engine standard environment.
  public var login: Google_Appengine_V1beta_LoginRequirement = .loginUnspecified

  /// Action to take when users access resources that require
  /// authentication. Defaults to `redirect`.
  public var authFailAction: Google_Appengine_V1beta_AuthFailAction = .unspecified

  /// `30x` code to use when performing redirects for the `secure` field.
  /// Defaults to `302`.
  public var redirectHTTPResponseCode: Google_Appengine_V1beta_UrlMap.RedirectHttpResponseCode = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of handler for this URL pattern.
  public enum OneOf_HandlerType: Equatable {
    /// Returns the contents of a file, such as an image, as the response.
    case staticFiles(Google_Appengine_V1beta_StaticFilesHandler)
    /// Executes a script to handle the requests that match this URL
    /// pattern. Only the `auto` value is supported for Node.js in the
    /// App Engine standard environment, for example `"script": "auto"`.
    case script(Google_Appengine_V1beta_ScriptHandler)
    /// Uses API Endpoints to handle requests.
    case apiEndpoint(Google_Appengine_V1beta_ApiEndpointHandler)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Appengine_V1beta_UrlMap.OneOf_HandlerType, rhs: Google_Appengine_V1beta_UrlMap.OneOf_HandlerType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.staticFiles, .staticFiles): return {
        guard case .staticFiles(let l) = lhs, case .staticFiles(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.script, .script): return {
        guard case .script(let l) = lhs, case .script(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.apiEndpoint, .apiEndpoint): return {
        guard case .apiEndpoint(let l) = lhs, case .apiEndpoint(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Redirect codes.
  public enum RedirectHttpResponseCode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified. `302` is assumed.
    case unspecified // = 0

    /// `301 Moved Permanently` code.
    case redirectHTTPResponseCode301 // = 1

    /// `302 Moved Temporarily` code.
    case redirectHTTPResponseCode302 // = 2

    /// `303 See Other` code.
    case redirectHTTPResponseCode303 // = 3

    /// `307 Temporary Redirect` code.
    case redirectHTTPResponseCode307 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .redirectHTTPResponseCode301
      case 2: self = .redirectHTTPResponseCode302
      case 3: self = .redirectHTTPResponseCode303
      case 4: self = .redirectHTTPResponseCode307
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .redirectHTTPResponseCode301: return 1
      case .redirectHTTPResponseCode302: return 2
      case .redirectHTTPResponseCode303: return 3
      case .redirectHTTPResponseCode307: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Appengine_V1beta_UrlMap.RedirectHttpResponseCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1beta_UrlMap.RedirectHttpResponseCode] = [
    .unspecified,
    .redirectHTTPResponseCode301,
    .redirectHTTPResponseCode302,
    .redirectHTTPResponseCode303,
    .redirectHTTPResponseCode307,
  ]
}

#endif  // swift(>=4.2)

/// Files served directly to the user for a given URL, such as images, CSS
/// stylesheets, or JavaScript source files. Static file handlers describe which
/// files in the application directory are static files, and which URLs serve
/// them.
public struct Google_Appengine_V1beta_StaticFilesHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the static files matched by the URL pattern, from the
  /// application root directory. The path can refer to text matched in groupings
  /// in the URL pattern.
  public var path: String = String()

  /// Regular expression that matches the file paths for all files that should be
  /// referenced by this handler.
  public var uploadPathRegex: String = String()

  /// HTTP headers to use for all responses from these URLs.
  public var httpHeaders: Dictionary<String,String> = [:]

  /// MIME type used to serve all files served by this handler.
  ///
  /// Defaults to file-specific MIME types, which are derived from each file's
  /// filename extension.
  public var mimeType: String = String()

  /// Time a static file served by this handler should be cached
  /// by web proxies and browsers.
  public var expiration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _expiration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_expiration = newValue}
  }
  /// Returns true if `expiration` has been explicitly set.
  public var hasExpiration: Bool {return self._expiration != nil}
  /// Clears the value of `expiration`. Subsequent reads from it will return its default value.
  public mutating func clearExpiration() {self._expiration = nil}

  /// Whether this handler should match the request if the file
  /// referenced by the handler does not exist.
  public var requireMatchingFile: Bool = false

  /// Whether files should also be uploaded as code data. By default, files
  /// declared in static file handlers are uploaded as static
  /// data and are only served to end users; they cannot be read by the
  /// application. If enabled, uploads are charged against both your code and
  /// static data storage resource quotas.
  public var applicationReadable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expiration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Executes a script to handle the request that matches the URL pattern.
public struct Google_Appengine_V1beta_ScriptHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the script from the application root directory.
  public var scriptPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Uses Google Cloud Endpoints to handle requests.
public struct Google_Appengine_V1beta_ApiEndpointHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the script from the application root directory.
  public var scriptPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances. Only applicable for
/// instances in App Engine flexible environment.
public struct Google_Appengine_V1beta_HealthCheck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether to explicitly disable health checks for this instance.
  public var disableHealthCheck: Bool = false

  /// Host header to send when performing an HTTP health check.
  /// Example: "myapp.appspot.com"
  public var host: String = String()

  /// Number of consecutive successful health checks required before receiving
  /// traffic.
  public var healthyThreshold: UInt32 = 0

  /// Number of consecutive failed health checks required before removing
  /// traffic.
  public var unhealthyThreshold: UInt32 = 0

  /// Number of consecutive failed health checks required before an instance is
  /// restarted.
  public var restartThreshold: UInt32 = 0

  /// Interval between health checks.
  public var checkInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _checkInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_checkInterval = newValue}
  }
  /// Returns true if `checkInterval` has been explicitly set.
  public var hasCheckInterval: Bool {return self._checkInterval != nil}
  /// Clears the value of `checkInterval`. Subsequent reads from it will return its default value.
  public mutating func clearCheckInterval() {self._checkInterval = nil}

  /// Time before the health check is considered failed.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _checkInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Readiness checking configuration for VM instances. Unhealthy instances
/// are removed from traffic rotation.
public struct Google_Appengine_V1beta_ReadinessCheck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request path.
  public var path: String = String()

  /// Host header to send when performing a HTTP Readiness check.
  /// Example: "myapp.appspot.com"
  public var host: String = String()

  /// Number of consecutive failed checks required before removing
  /// traffic.
  public var failureThreshold: UInt32 = 0

  /// Number of consecutive successful checks required before receiving
  /// traffic.
  public var successThreshold: UInt32 = 0

  /// Interval between health checks.
  public var checkInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _checkInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_checkInterval = newValue}
  }
  /// Returns true if `checkInterval` has been explicitly set.
  public var hasCheckInterval: Bool {return self._checkInterval != nil}
  /// Clears the value of `checkInterval`. Subsequent reads from it will return its default value.
  public mutating func clearCheckInterval() {self._checkInterval = nil}

  /// Time before the check is considered failed.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// A maximum time limit on application initialization, measured from moment
  /// the application successfully replies to a healthcheck until it is ready to
  /// serve traffic.
  public var appStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _appStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_appStartTimeout = newValue}
  }
  /// Returns true if `appStartTimeout` has been explicitly set.
  public var hasAppStartTimeout: Bool {return self._appStartTimeout != nil}
  /// Clears the value of `appStartTimeout`. Subsequent reads from it will return its default value.
  public mutating func clearAppStartTimeout() {self._appStartTimeout = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _checkInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _appStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Health checking configuration for VM instances. Unhealthy instances
/// are killed and replaced with new instances.
public struct Google_Appengine_V1beta_LivenessCheck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request path.
  public var path: String = String()

  /// Host header to send when performing a HTTP Liveness check.
  /// Example: "myapp.appspot.com"
  public var host: String = String()

  /// Number of consecutive failed checks required before considering the
  /// VM unhealthy.
  public var failureThreshold: UInt32 = 0

  /// Number of consecutive successful checks required before considering
  /// the VM healthy.
  public var successThreshold: UInt32 = 0

  /// Interval between health checks.
  public var checkInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _checkInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_checkInterval = newValue}
  }
  /// Returns true if `checkInterval` has been explicitly set.
  public var hasCheckInterval: Bool {return self._checkInterval != nil}
  /// Clears the value of `checkInterval`. Subsequent reads from it will return its default value.
  public mutating func clearCheckInterval() {self._checkInterval = nil}

  /// Time before the check is considered failed.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {self._timeout = nil}

  /// The initial delay before starting to execute the checks.
  public var initialDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _initialDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_initialDelay = newValue}
  }
  /// Returns true if `initialDelay` has been explicitly set.
  public var hasInitialDelay: Bool {return self._initialDelay != nil}
  /// Clears the value of `initialDelay`. Subsequent reads from it will return its default value.
  public mutating func clearInitialDelay() {self._initialDelay = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _checkInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _initialDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Third-party Python runtime library that is required by the application.
public struct Google_Appengine_V1beta_Library {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the library. Example: "django".
  public var name: String = String()

  /// Version of the library to select, or "latest".
  public var version: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.appengine.v1beta"

extension Google_Appengine_V1beta_AuthFailAction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AUTH_FAIL_ACTION_UNSPECIFIED"),
    1: .same(proto: "AUTH_FAIL_ACTION_REDIRECT"),
    2: .same(proto: "AUTH_FAIL_ACTION_UNAUTHORIZED"),
  ]
}

extension Google_Appengine_V1beta_LoginRequirement: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGIN_UNSPECIFIED"),
    1: .same(proto: "LOGIN_OPTIONAL"),
    2: .same(proto: "LOGIN_ADMIN"),
    3: .same(proto: "LOGIN_REQUIRED"),
  ]
}

extension Google_Appengine_V1beta_SecurityLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "SECURE_UNSPECIFIED", aliases: ["SECURE_DEFAULT"]),
    1: .same(proto: "SECURE_NEVER"),
    2: .same(proto: "SECURE_OPTIONAL"),
    3: .same(proto: "SECURE_ALWAYS"),
  ]
}

extension Google_Appengine_V1beta_ApiConfigHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiConfigHandler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auth_fail_action"),
    2: .same(proto: "login"),
    3: .same(proto: "script"),
    4: .standard(proto: "security_level"),
    5: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.authFailAction) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.login) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.script) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.securityLevel) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.authFailAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.authFailAction, fieldNumber: 1)
    }
    if self.login != .loginUnspecified {
      try visitor.visitSingularEnumField(value: self.login, fieldNumber: 2)
    }
    if !self.script.isEmpty {
      try visitor.visitSingularStringField(value: self.script, fieldNumber: 3)
    }
    if self.securityLevel != .secureUnspecified {
      try visitor.visitSingularEnumField(value: self.securityLevel, fieldNumber: 4)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_ApiConfigHandler, rhs: Google_Appengine_V1beta_ApiConfigHandler) -> Bool {
    if lhs.authFailAction != rhs.authFailAction {return false}
    if lhs.login != rhs.login {return false}
    if lhs.script != rhs.script {return false}
    if lhs.securityLevel != rhs.securityLevel {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_ErrorHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorHandler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_code"),
    2: .standard(proto: "static_file"),
    3: .standard(proto: "mime_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.errorCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.staticFile) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.errorCode != .unspecified {
      try visitor.visitSingularEnumField(value: self.errorCode, fieldNumber: 1)
    }
    if !self.staticFile.isEmpty {
      try visitor.visitSingularStringField(value: self.staticFile, fieldNumber: 2)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_ErrorHandler, rhs: Google_Appengine_V1beta_ErrorHandler) -> Bool {
    if lhs.errorCode != rhs.errorCode {return false}
    if lhs.staticFile != rhs.staticFile {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_ErrorHandler.ErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .aliased(proto: "ERROR_CODE_UNSPECIFIED", aliases: ["ERROR_CODE_DEFAULT"]),
    1: .same(proto: "ERROR_CODE_OVER_QUOTA"),
    2: .same(proto: "ERROR_CODE_DOS_API_DENIAL"),
    3: .same(proto: "ERROR_CODE_TIMEOUT"),
  ]
}

extension Google_Appengine_V1beta_UrlMap: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UrlMap"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "url_regex"),
    2: .standard(proto: "static_files"),
    3: .same(proto: "script"),
    4: .standard(proto: "api_endpoint"),
    5: .standard(proto: "security_level"),
    6: .same(proto: "login"),
    7: .standard(proto: "auth_fail_action"),
    8: .standard(proto: "redirect_http_response_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.urlRegex) }()
      case 2: try {
        var v: Google_Appengine_V1beta_StaticFilesHandler?
        if let current = self.handlerType {
          try decoder.handleConflictingOneOf()
          if case .staticFiles(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.handlerType = .staticFiles(v)}
      }()
      case 3: try {
        var v: Google_Appengine_V1beta_ScriptHandler?
        if let current = self.handlerType {
          try decoder.handleConflictingOneOf()
          if case .script(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.handlerType = .script(v)}
      }()
      case 4: try {
        var v: Google_Appengine_V1beta_ApiEndpointHandler?
        if let current = self.handlerType {
          try decoder.handleConflictingOneOf()
          if case .apiEndpoint(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.handlerType = .apiEndpoint(v)}
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.securityLevel) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.login) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.authFailAction) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.redirectHTTPResponseCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.urlRegex.isEmpty {
      try visitor.visitSingularStringField(value: self.urlRegex, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.handlerType {
    case .staticFiles?: try {
      guard case .staticFiles(let v)? = self.handlerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .script?: try {
      guard case .script(let v)? = self.handlerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .apiEndpoint?: try {
      guard case .apiEndpoint(let v)? = self.handlerType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.securityLevel != .secureUnspecified {
      try visitor.visitSingularEnumField(value: self.securityLevel, fieldNumber: 5)
    }
    if self.login != .loginUnspecified {
      try visitor.visitSingularEnumField(value: self.login, fieldNumber: 6)
    }
    if self.authFailAction != .unspecified {
      try visitor.visitSingularEnumField(value: self.authFailAction, fieldNumber: 7)
    }
    if self.redirectHTTPResponseCode != .unspecified {
      try visitor.visitSingularEnumField(value: self.redirectHTTPResponseCode, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_UrlMap, rhs: Google_Appengine_V1beta_UrlMap) -> Bool {
    if lhs.urlRegex != rhs.urlRegex {return false}
    if lhs.handlerType != rhs.handlerType {return false}
    if lhs.securityLevel != rhs.securityLevel {return false}
    if lhs.login != rhs.login {return false}
    if lhs.authFailAction != rhs.authFailAction {return false}
    if lhs.redirectHTTPResponseCode != rhs.redirectHTTPResponseCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_UrlMap.RedirectHttpResponseCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REDIRECT_HTTP_RESPONSE_CODE_UNSPECIFIED"),
    1: .same(proto: "REDIRECT_HTTP_RESPONSE_CODE_301"),
    2: .same(proto: "REDIRECT_HTTP_RESPONSE_CODE_302"),
    3: .same(proto: "REDIRECT_HTTP_RESPONSE_CODE_303"),
    4: .same(proto: "REDIRECT_HTTP_RESPONSE_CODE_307"),
  ]
}

extension Google_Appengine_V1beta_StaticFilesHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StaticFilesHandler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .standard(proto: "upload_path_regex"),
    3: .standard(proto: "http_headers"),
    4: .standard(proto: "mime_type"),
    5: .same(proto: "expiration"),
    6: .standard(proto: "require_matching_file"),
    7: .standard(proto: "application_readable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uploadPathRegex) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.httpHeaders) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiration) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.requireMatchingFile) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.applicationReadable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.uploadPathRegex.isEmpty {
      try visitor.visitSingularStringField(value: self.uploadPathRegex, fieldNumber: 2)
    }
    if !self.httpHeaders.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.httpHeaders, fieldNumber: 3)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 4)
    }
    if let v = self._expiration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.requireMatchingFile != false {
      try visitor.visitSingularBoolField(value: self.requireMatchingFile, fieldNumber: 6)
    }
    if self.applicationReadable != false {
      try visitor.visitSingularBoolField(value: self.applicationReadable, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_StaticFilesHandler, rhs: Google_Appengine_V1beta_StaticFilesHandler) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.uploadPathRegex != rhs.uploadPathRegex {return false}
    if lhs.httpHeaders != rhs.httpHeaders {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs._expiration != rhs._expiration {return false}
    if lhs.requireMatchingFile != rhs.requireMatchingFile {return false}
    if lhs.applicationReadable != rhs.applicationReadable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_ScriptHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScriptHandler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "script_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scriptPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scriptPath.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_ScriptHandler, rhs: Google_Appengine_V1beta_ScriptHandler) -> Bool {
    if lhs.scriptPath != rhs.scriptPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_ApiEndpointHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiEndpointHandler"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "script_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scriptPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.scriptPath.isEmpty {
      try visitor.visitSingularStringField(value: self.scriptPath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_ApiEndpointHandler, rhs: Google_Appengine_V1beta_ApiEndpointHandler) -> Bool {
    if lhs.scriptPath != rhs.scriptPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_HealthCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HealthCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "disable_health_check"),
    2: .same(proto: "host"),
    3: .standard(proto: "healthy_threshold"),
    4: .standard(proto: "unhealthy_threshold"),
    5: .standard(proto: "restart_threshold"),
    6: .standard(proto: "check_interval"),
    7: .same(proto: "timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disableHealthCheck) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.healthyThreshold) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.unhealthyThreshold) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.restartThreshold) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._checkInterval) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disableHealthCheck != false {
      try visitor.visitSingularBoolField(value: self.disableHealthCheck, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    if self.healthyThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.healthyThreshold, fieldNumber: 3)
    }
    if self.unhealthyThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.unhealthyThreshold, fieldNumber: 4)
    }
    if self.restartThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.restartThreshold, fieldNumber: 5)
    }
    if let v = self._checkInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_HealthCheck, rhs: Google_Appengine_V1beta_HealthCheck) -> Bool {
    if lhs.disableHealthCheck != rhs.disableHealthCheck {return false}
    if lhs.host != rhs.host {return false}
    if lhs.healthyThreshold != rhs.healthyThreshold {return false}
    if lhs.unhealthyThreshold != rhs.unhealthyThreshold {return false}
    if lhs.restartThreshold != rhs.restartThreshold {return false}
    if lhs._checkInterval != rhs._checkInterval {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_ReadinessCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadinessCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "host"),
    3: .standard(proto: "failure_threshold"),
    4: .standard(proto: "success_threshold"),
    5: .standard(proto: "check_interval"),
    6: .same(proto: "timeout"),
    7: .standard(proto: "app_start_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.failureThreshold) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.successThreshold) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._checkInterval) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._appStartTimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    if self.failureThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.failureThreshold, fieldNumber: 3)
    }
    if self.successThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.successThreshold, fieldNumber: 4)
    }
    if let v = self._checkInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._appStartTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_ReadinessCheck, rhs: Google_Appengine_V1beta_ReadinessCheck) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.host != rhs.host {return false}
    if lhs.failureThreshold != rhs.failureThreshold {return false}
    if lhs.successThreshold != rhs.successThreshold {return false}
    if lhs._checkInterval != rhs._checkInterval {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._appStartTimeout != rhs._appStartTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_LivenessCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LivenessCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "host"),
    3: .standard(proto: "failure_threshold"),
    4: .standard(proto: "success_threshold"),
    5: .standard(proto: "check_interval"),
    6: .same(proto: "timeout"),
    7: .standard(proto: "initial_delay"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.host) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.failureThreshold) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.successThreshold) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._checkInterval) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timeout) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._initialDelay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.host.isEmpty {
      try visitor.visitSingularStringField(value: self.host, fieldNumber: 2)
    }
    if self.failureThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.failureThreshold, fieldNumber: 3)
    }
    if self.successThreshold != 0 {
      try visitor.visitSingularUInt32Field(value: self.successThreshold, fieldNumber: 4)
    }
    if let v = self._checkInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._timeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._initialDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_LivenessCheck, rhs: Google_Appengine_V1beta_LivenessCheck) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.host != rhs.host {return false}
    if lhs.failureThreshold != rhs.failureThreshold {return false}
    if lhs.successThreshold != rhs.successThreshold {return false}
    if lhs._checkInterval != rhs._checkInterval {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._initialDelay != rhs._initialDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1beta_Library: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Library"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1beta_Library, rhs: Google_Appengine_V1beta_Library) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

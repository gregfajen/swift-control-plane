// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/appengine/v1/certificate.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// State of certificate management. Refers to the most recent certificate
/// acquisition or renewal attempt.
public enum Google_Appengine_V1_ManagementStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case unspecified // = 0

  /// Certificate was successfully obtained and inserted into the serving
  /// system.
  case ok // = 1

  /// Certificate is under active attempts to acquire or renew.
  case pending // = 2

  /// Most recent renewal failed due to an invalid DNS setup and will be
  /// retried. Renewal attempts will continue to fail until the certificate
  /// domain's DNS configuration is fixed. The last successfully provisioned
  /// certificate may still be serving.
  case failedRetryingNotVisible // = 4

  /// All renewal attempts have been exhausted, likely due to an invalid DNS
  /// setup.
  case failedPermanent // = 6

  /// Most recent renewal failed due to an explicit CAA record that does not
  /// include one of the in-use CAs (Google CA and Let's Encrypt). Renewals will
  /// continue to fail until the CAA is reconfigured. The last successfully
  /// provisioned certificate may still be serving.
  case failedRetryingCaaForbidden // = 7

  /// Most recent renewal failed due to a CAA retrieval failure. This means that
  /// the domain's DNS provider does not properly handle CAA records, failing
  /// requests for CAA records when no CAA records are defined. Renewals will
  /// continue to fail until the DNS provider is changed or a CAA record is
  /// added for the given domain. The last successfully provisioned certificate
  /// may still be serving.
  case failedRetryingCaaChecking // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .ok
    case 2: self = .pending
    case 4: self = .failedRetryingNotVisible
    case 6: self = .failedPermanent
    case 7: self = .failedRetryingCaaForbidden
    case 8: self = .failedRetryingCaaChecking
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .ok: return 1
    case .pending: return 2
    case .failedRetryingNotVisible: return 4
    case .failedPermanent: return 6
    case .failedRetryingCaaForbidden: return 7
    case .failedRetryingCaaChecking: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Appengine_V1_ManagementStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Appengine_V1_ManagementStatus] = [
    .unspecified,
    .ok,
    .pending,
    .failedRetryingNotVisible,
    .failedPermanent,
    .failedRetryingCaaForbidden,
    .failedRetryingCaaChecking,
  ]
}

#endif  // swift(>=4.2)

/// An SSL certificate that a user has been authorized to administer. A user
/// is authorized to administer any certificate that applies to one of their
/// authorized domains.
public struct Google_Appengine_V1_AuthorizedCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full path to the `AuthorizedCertificate` resource in the API. Example:
  /// `apps/myapp/authorizedCertificates/12345`.
  ///
  /// @OutputOnly
  public var name: String = String()

  /// Relative name of the certificate. This is a unique value autogenerated
  /// on `AuthorizedCertificate` resource creation. Example: `12345`.
  ///
  /// @OutputOnly
  public var id: String = String()

  /// The user-specified display name of the certificate. This is not
  /// guaranteed to be unique. Example: `My Certificate`.
  public var displayName: String = String()

  /// Topmost applicable domains of this certificate. This certificate
  /// applies to these domains and their subdomains. Example: `example.com`.
  ///
  /// @OutputOnly
  public var domainNames: [String] = []

  /// The time when this certificate expires. To update the renewal time on this
  /// certificate, upload an SSL certificate with a different expiration time
  /// using [`AuthorizedCertificates.UpdateAuthorizedCertificate`]().
  ///
  /// @OutputOnly
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  /// The SSL certificate serving the `AuthorizedCertificate` resource. This
  /// must be obtained independently from a certificate authority.
  public var certificateRawData: Google_Appengine_V1_CertificateRawData {
    get {return _certificateRawData ?? Google_Appengine_V1_CertificateRawData()}
    set {_certificateRawData = newValue}
  }
  /// Returns true if `certificateRawData` has been explicitly set.
  public var hasCertificateRawData: Bool {return self._certificateRawData != nil}
  /// Clears the value of `certificateRawData`. Subsequent reads from it will return its default value.
  public mutating func clearCertificateRawData() {self._certificateRawData = nil}

  /// Only applicable if this certificate is managed by App Engine. Managed
  /// certificates are tied to the lifecycle of a `DomainMapping` and cannot be
  /// updated or deleted via the `AuthorizedCertificates` API. If this
  /// certificate is manually administered by the user, this field will be empty.
  ///
  /// @OutputOnly
  public var managedCertificate: Google_Appengine_V1_ManagedCertificate {
    get {return _managedCertificate ?? Google_Appengine_V1_ManagedCertificate()}
    set {_managedCertificate = newValue}
  }
  /// Returns true if `managedCertificate` has been explicitly set.
  public var hasManagedCertificate: Bool {return self._managedCertificate != nil}
  /// Clears the value of `managedCertificate`. Subsequent reads from it will return its default value.
  public mutating func clearManagedCertificate() {self._managedCertificate = nil}

  /// The full paths to user visible Domain Mapping resources that have this
  /// certificate mapped. Example: `apps/myapp/domainMappings/example.com`.
  ///
  /// This may not represent the full list of mapped domain mappings if the user
  /// does not have `VIEWER` permissions on all of the applications that have
  /// this certificate mapped. See `domain_mappings_count` for a complete count.
  ///
  /// Only returned by `GET` or `LIST` requests when specifically requested by
  /// the `view=FULL_CERTIFICATE` option.
  ///
  /// @OutputOnly
  public var visibleDomainMappings: [String] = []

  /// Aggregate count of the domain mappings with this certificate mapped. This
  /// count includes domain mappings on applications for which the user does not
  /// have `VIEWER` permissions.
  ///
  /// Only returned by `GET` or `LIST` requests when specifically requested by
  /// the `view=FULL_CERTIFICATE` option.
  ///
  /// @OutputOnly
  public var domainMappingsCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _certificateRawData: Google_Appengine_V1_CertificateRawData? = nil
  fileprivate var _managedCertificate: Google_Appengine_V1_ManagedCertificate? = nil
}

/// An SSL certificate obtained from a certificate authority.
public struct Google_Appengine_V1_CertificateRawData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PEM encoded x.509 public key certificate. This field is set once on
  /// certificate creation. Must include the header and footer. Example:
  /// <pre>
  /// -----BEGIN CERTIFICATE-----
  /// <certificate_value>
  /// -----END CERTIFICATE-----
  /// </pre>
  public var publicCertificate: String = String()

  /// Unencrypted PEM encoded RSA private key. This field is set once on
  /// certificate creation and then encrypted. The key size must be 2048
  /// bits or fewer. Must include the header and footer. Example:
  /// <pre>
  /// -----BEGIN RSA PRIVATE KEY-----
  /// <unencrypted_key_value>
  /// -----END RSA PRIVATE KEY-----
  /// </pre>
  /// @InputOnly
  public var privateKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A certificate managed by App Engine.
public struct Google_Appengine_V1_ManagedCertificate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time at which the certificate was last renewed. The renewal process is
  /// fully managed. Certificate renewal will automatically occur before the
  /// certificate expires. Renewal errors can be tracked via `ManagementStatus`.
  ///
  /// @OutputOnly
  public var lastRenewalTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastRenewalTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastRenewalTime = newValue}
  }
  /// Returns true if `lastRenewalTime` has been explicitly set.
  public var hasLastRenewalTime: Bool {return self._lastRenewalTime != nil}
  /// Clears the value of `lastRenewalTime`. Subsequent reads from it will return its default value.
  public mutating func clearLastRenewalTime() {self._lastRenewalTime = nil}

  /// Status of certificate management. Refers to the most recent certificate
  /// acquisition or renewal attempt.
  ///
  /// @OutputOnly
  public var status: Google_Appengine_V1_ManagementStatus = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _lastRenewalTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.appengine.v1"

extension Google_Appengine_V1_ManagementStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MANAGEMENT_STATUS_UNSPECIFIED"),
    1: .same(proto: "OK"),
    2: .same(proto: "PENDING"),
    4: .same(proto: "FAILED_RETRYING_NOT_VISIBLE"),
    6: .same(proto: "FAILED_PERMANENT"),
    7: .same(proto: "FAILED_RETRYING_CAA_FORBIDDEN"),
    8: .same(proto: "FAILED_RETRYING_CAA_CHECKING"),
  ]
}

extension Google_Appengine_V1_AuthorizedCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthorizedCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
    3: .standard(proto: "display_name"),
    4: .standard(proto: "domain_names"),
    5: .standard(proto: "expire_time"),
    6: .standard(proto: "certificate_raw_data"),
    7: .standard(proto: "managed_certificate"),
    8: .standard(proto: "visible_domain_mappings"),
    9: .standard(proto: "domain_mappings_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.domainNames) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._certificateRawData) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._managedCertificate) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.visibleDomainMappings) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.domainMappingsCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.domainNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.domainNames, fieldNumber: 4)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._certificateRawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._managedCertificate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.visibleDomainMappings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.visibleDomainMappings, fieldNumber: 8)
    }
    if self.domainMappingsCount != 0 {
      try visitor.visitSingularInt32Field(value: self.domainMappingsCount, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1_AuthorizedCertificate, rhs: Google_Appengine_V1_AuthorizedCertificate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.id != rhs.id {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.domainNames != rhs.domainNames {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs._certificateRawData != rhs._certificateRawData {return false}
    if lhs._managedCertificate != rhs._managedCertificate {return false}
    if lhs.visibleDomainMappings != rhs.visibleDomainMappings {return false}
    if lhs.domainMappingsCount != rhs.domainMappingsCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1_CertificateRawData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateRawData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_certificate"),
    2: .standard(proto: "private_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publicCertificate) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.privateKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publicCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.publicCertificate, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularStringField(value: self.privateKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1_CertificateRawData, rhs: Google_Appengine_V1_CertificateRawData) -> Bool {
    if lhs.publicCertificate != rhs.publicCertificate {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_V1_ManagedCertificate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ManagedCertificate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_renewal_time"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastRenewalTime) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._lastRenewalTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_V1_ManagedCertificate, rhs: Google_Appengine_V1_ManagedCertificate) -> Bool {
    if lhs._lastRenewalTime != rhs._lastRenewalTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

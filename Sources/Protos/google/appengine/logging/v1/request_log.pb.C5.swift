// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/appengine/logging/v1/request_log.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Application log line emitted while processing a request.
public struct Google_Appengine_Logging_V1_LogLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Approximate time when this log entry was made.
  public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  public var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  public mutating func clearTime() {self._time = nil}

  /// Severity of this log entry.
  public var severity: Google_Logging_Type_LogSeverity = .default

  /// App-provided log message.
  public var logMessage: String = String()

  /// Where in the source code this log message was written.
  public var sourceLocation: Google_Appengine_Logging_V1_SourceLocation {
    get {return _sourceLocation ?? Google_Appengine_Logging_V1_SourceLocation()}
    set {_sourceLocation = newValue}
  }
  /// Returns true if `sourceLocation` has been explicitly set.
  public var hasSourceLocation: Bool {return self._sourceLocation != nil}
  /// Clears the value of `sourceLocation`. Subsequent reads from it will return its default value.
  public mutating func clearSourceLocation() {self._sourceLocation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _sourceLocation: Google_Appengine_Logging_V1_SourceLocation? = nil
}

/// Specifies a location in a source code file.
public struct Google_Appengine_Logging_V1_SourceLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Source file name. Depending on the runtime environment, this might be a
  /// simple name or a fully-qualified name.
  public var file: String = String()

  /// Line within the source file.
  public var line: Int64 = 0

  /// Human-readable name of the function or method being invoked, with optional
  /// context such as the class or package name. This information is used in
  /// contexts such as the logs viewer, where a file and line number are less
  /// meaningful. The format can vary by language. For example:
  /// `qual.if.ied.Class.method` (Java), `dir/package.func` (Go), `function`
  /// (Python).
  public var functionName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A reference to a particular snapshot of the source tree used to build and
/// deploy an application.
public struct Google_Appengine_Logging_V1_SourceReference {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional. A URI string identifying the repository.
  /// Example: "https://github.com/GoogleCloudPlatform/kubernetes.git"
  public var repository: String = String()

  /// The canonical and persistent identifier of the deployed revision.
  /// Example (git): "0035781c50ec7aa23385dc841529ce8a4b70db1b"
  public var revisionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Complete log information about a single HTTP request to an App Engine
/// application.
public struct Google_Appengine_Logging_V1_RequestLog {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Application that handled this request.
  public var appID: String {
    get {return _storage._appID}
    set {_uniqueStorage()._appID = newValue}
  }

  /// Module of the application that handled this request.
  public var moduleID: String {
    get {return _storage._moduleID}
    set {_uniqueStorage()._moduleID = newValue}
  }

  /// Version of the application that handled this request.
  public var versionID: String {
    get {return _storage._versionID}
    set {_uniqueStorage()._versionID = newValue}
  }

  /// Globally unique identifier for a request, which is based on the request
  /// start time.  Request IDs for requests which started later will compare
  /// greater as strings than those for requests which started earlier.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Origin IP address.
  public var ip: String {
    get {return _storage._ip}
    set {_uniqueStorage()._ip = newValue}
  }

  /// Time when the request started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Time when the request finished.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return _storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  /// Latency of the request.
  public var latency: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._latency ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._latency = newValue}
  }
  /// Returns true if `latency` has been explicitly set.
  public var hasLatency: Bool {return _storage._latency != nil}
  /// Clears the value of `latency`. Subsequent reads from it will return its default value.
  public mutating func clearLatency() {_uniqueStorage()._latency = nil}

  /// Number of CPU megacycles used to process request.
  public var megaCycles: Int64 {
    get {return _storage._megaCycles}
    set {_uniqueStorage()._megaCycles = newValue}
  }

  /// Request method. Example: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`, `"DELETE"`.
  public var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  /// Contains the path and query portion of the URL that was requested. For
  /// example, if the URL was "http://example.com/app?name=val", the resource
  /// would be "/app?name=val".  The fragment identifier, which is identified by
  /// the `#` character, is not included.
  public var resource: String {
    get {return _storage._resource}
    set {_uniqueStorage()._resource = newValue}
  }

  /// HTTP version of request. Example: `"HTTP/1.1"`.
  public var httpVersion: String {
    get {return _storage._httpVersion}
    set {_uniqueStorage()._httpVersion = newValue}
  }

  /// HTTP response status code. Example: 200, 404.
  public var status: Int32 {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Size in bytes sent back to client by request.
  public var responseSize: Int64 {
    get {return _storage._responseSize}
    set {_uniqueStorage()._responseSize = newValue}
  }

  /// Referrer URL of request.
  public var referrer: String {
    get {return _storage._referrer}
    set {_uniqueStorage()._referrer = newValue}
  }

  /// User agent that made the request.
  public var userAgent: String {
    get {return _storage._userAgent}
    set {_uniqueStorage()._userAgent = newValue}
  }

  /// The logged-in user who made the request.
  ///
  /// Most likely, this is the part of the user's email before the `@` sign.  The
  /// field value is the same for different requests from the same user, but
  /// different users can have similar names.  This information is also
  /// available to the application via the App Engine Users API.
  ///
  /// This field will be populated starting with App Engine 1.9.21.
  public var nickname: String {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  /// File or class that handled the request.
  public var urlMapEntry: String {
    get {return _storage._urlMapEntry}
    set {_uniqueStorage()._urlMapEntry = newValue}
  }

  /// Internet host and port number of the resource being requested.
  public var host: String {
    get {return _storage._host}
    set {_uniqueStorage()._host = newValue}
  }

  /// An indication of the relative cost of serving this request.
  public var cost: Double {
    get {return _storage._cost}
    set {_uniqueStorage()._cost = newValue}
  }

  /// Queue name of the request, in the case of an offline request.
  public var taskQueueName: String {
    get {return _storage._taskQueueName}
    set {_uniqueStorage()._taskQueueName = newValue}
  }

  /// Task name of the request, in the case of an offline request.
  public var taskName: String {
    get {return _storage._taskName}
    set {_uniqueStorage()._taskName = newValue}
  }

  /// Whether this was a loading request for the instance.
  public var wasLoadingRequest: Bool {
    get {return _storage._wasLoadingRequest}
    set {_uniqueStorage()._wasLoadingRequest = newValue}
  }

  /// Time this request spent in the pending request queue.
  public var pendingTime: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._pendingTime ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._pendingTime = newValue}
  }
  /// Returns true if `pendingTime` has been explicitly set.
  public var hasPendingTime: Bool {return _storage._pendingTime != nil}
  /// Clears the value of `pendingTime`. Subsequent reads from it will return its default value.
  public mutating func clearPendingTime() {_uniqueStorage()._pendingTime = nil}

  /// If the instance processing this request belongs to a manually scaled
  /// module, then this is the 0-based index of the instance. Otherwise, this
  /// value is -1.
  public var instanceIndex: Int32 {
    get {return _storage._instanceIndex}
    set {_uniqueStorage()._instanceIndex = newValue}
  }

  /// Whether this request is finished or active.
  public var finished: Bool {
    get {return _storage._finished}
    set {_uniqueStorage()._finished = newValue}
  }

  /// Whether this is the first `RequestLog` entry for this request.  If an
  /// active request has several `RequestLog` entries written to Stackdriver
  /// Logging, then this field will be set for one of them.
  public var first: Bool {
    get {return _storage._first}
    set {_uniqueStorage()._first = newValue}
  }

  /// An identifier for the instance that handled the request.
  public var instanceID: String {
    get {return _storage._instanceID}
    set {_uniqueStorage()._instanceID = newValue}
  }

  /// A list of log lines emitted by the application while serving this request.
  public var line: [Google_Appengine_Logging_V1_LogLine] {
    get {return _storage._line}
    set {_uniqueStorage()._line = newValue}
  }

  /// App Engine release version.
  public var appEngineRelease: String {
    get {return _storage._appEngineRelease}
    set {_uniqueStorage()._appEngineRelease = newValue}
  }

  /// Stackdriver Trace identifier for this request.
  public var traceID: String {
    get {return _storage._traceID}
    set {_uniqueStorage()._traceID = newValue}
  }

  /// If true, the value in the 'trace_id' field was sampled for storage in a
  /// trace backend.
  public var traceSampled: Bool {
    get {return _storage._traceSampled}
    set {_uniqueStorage()._traceSampled = newValue}
  }

  /// Source code for the application that handled this request. There can be
  /// more than one source reference per deployed application if source code is
  /// distributed among multiple repositories.
  public var sourceReference: [Google_Appengine_Logging_V1_SourceReference] {
    get {return _storage._sourceReference}
    set {_uniqueStorage()._sourceReference = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.appengine.logging.v1"

extension Google_Appengine_Logging_V1_LogLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LogLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "severity"),
    3: .standard(proto: "log_message"),
    4: .standard(proto: "source_location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.logMessage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sourceLocation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.severity != .default {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if !self.logMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.logMessage, fieldNumber: 3)
    }
    if let v = self._sourceLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_Logging_V1_LogLine, rhs: Google_Appengine_Logging_V1_LogLine) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.logMessage != rhs.logMessage {return false}
    if lhs._sourceLocation != rhs._sourceLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_Logging_V1_SourceLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "file"),
    2: .same(proto: "line"),
    3: .standard(proto: "function_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.file) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.functionName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.file.isEmpty {
      try visitor.visitSingularStringField(value: self.file, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt64Field(value: self.line, fieldNumber: 2)
    }
    if !self.functionName.isEmpty {
      try visitor.visitSingularStringField(value: self.functionName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_Logging_V1_SourceLocation, rhs: Google_Appengine_Logging_V1_SourceLocation) -> Bool {
    if lhs.file != rhs.file {return false}
    if lhs.line != rhs.line {return false}
    if lhs.functionName != rhs.functionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_Logging_V1_SourceReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceReference"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "repository"),
    2: .standard(proto: "revision_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.repository) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.revisionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.repository.isEmpty {
      try visitor.visitSingularStringField(value: self.repository, fieldNumber: 1)
    }
    if !self.revisionID.isEmpty {
      try visitor.visitSingularStringField(value: self.revisionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_Logging_V1_SourceReference, rhs: Google_Appengine_Logging_V1_SourceReference) -> Bool {
    if lhs.repository != rhs.repository {return false}
    if lhs.revisionID != rhs.revisionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Appengine_Logging_V1_RequestLog: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestLog"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "app_id"),
    37: .standard(proto: "module_id"),
    2: .standard(proto: "version_id"),
    3: .standard(proto: "request_id"),
    4: .same(proto: "ip"),
    6: .standard(proto: "start_time"),
    7: .standard(proto: "end_time"),
    8: .same(proto: "latency"),
    9: .standard(proto: "mega_cycles"),
    10: .same(proto: "method"),
    11: .same(proto: "resource"),
    12: .standard(proto: "http_version"),
    13: .same(proto: "status"),
    14: .standard(proto: "response_size"),
    15: .same(proto: "referrer"),
    16: .standard(proto: "user_agent"),
    40: .same(proto: "nickname"),
    17: .standard(proto: "url_map_entry"),
    20: .same(proto: "host"),
    21: .same(proto: "cost"),
    22: .standard(proto: "task_queue_name"),
    23: .standard(proto: "task_name"),
    24: .standard(proto: "was_loading_request"),
    25: .standard(proto: "pending_time"),
    26: .standard(proto: "instance_index"),
    27: .same(proto: "finished"),
    42: .same(proto: "first"),
    28: .standard(proto: "instance_id"),
    29: .same(proto: "line"),
    38: .standard(proto: "app_engine_release"),
    39: .standard(proto: "trace_id"),
    43: .standard(proto: "trace_sampled"),
    41: .standard(proto: "source_reference"),
  ]

  fileprivate class _StorageClass {
    var _appID: String = String()
    var _moduleID: String = String()
    var _versionID: String = String()
    var _requestID: String = String()
    var _ip: String = String()
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _latency: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _megaCycles: Int64 = 0
    var _method: String = String()
    var _resource: String = String()
    var _httpVersion: String = String()
    var _status: Int32 = 0
    var _responseSize: Int64 = 0
    var _referrer: String = String()
    var _userAgent: String = String()
    var _nickname: String = String()
    var _urlMapEntry: String = String()
    var _host: String = String()
    var _cost: Double = 0
    var _taskQueueName: String = String()
    var _taskName: String = String()
    var _wasLoadingRequest: Bool = false
    var _pendingTime: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _instanceIndex: Int32 = 0
    var _finished: Bool = false
    var _first: Bool = false
    var _instanceID: String = String()
    var _line: [Google_Appengine_Logging_V1_LogLine] = []
    var _appEngineRelease: String = String()
    var _traceID: String = String()
    var _traceSampled: Bool = false
    var _sourceReference: [Google_Appengine_Logging_V1_SourceReference] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _appID = source._appID
      _moduleID = source._moduleID
      _versionID = source._versionID
      _requestID = source._requestID
      _ip = source._ip
      _startTime = source._startTime
      _endTime = source._endTime
      _latency = source._latency
      _megaCycles = source._megaCycles
      _method = source._method
      _resource = source._resource
      _httpVersion = source._httpVersion
      _status = source._status
      _responseSize = source._responseSize
      _referrer = source._referrer
      _userAgent = source._userAgent
      _nickname = source._nickname
      _urlMapEntry = source._urlMapEntry
      _host = source._host
      _cost = source._cost
      _taskQueueName = source._taskQueueName
      _taskName = source._taskName
      _wasLoadingRequest = source._wasLoadingRequest
      _pendingTime = source._pendingTime
      _instanceIndex = source._instanceIndex
      _finished = source._finished
      _first = source._first
      _instanceID = source._instanceID
      _line = source._line
      _appEngineRelease = source._appEngineRelease
      _traceID = source._traceID
      _traceSampled = source._traceSampled
      _sourceReference = source._sourceReference
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._appID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._versionID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._ip) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._latency) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._megaCycles) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._resource) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._httpVersion) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._responseSize) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._referrer) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._userAgent) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._urlMapEntry) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 21: try { try decoder.decodeSingularDoubleField(value: &_storage._cost) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._taskQueueName) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._taskName) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._wasLoadingRequest) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._pendingTime) }()
        case 26: try { try decoder.decodeSingularInt32Field(value: &_storage._instanceIndex) }()
        case 27: try { try decoder.decodeSingularBoolField(value: &_storage._finished) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._instanceID) }()
        case 29: try { try decoder.decodeRepeatedMessageField(value: &_storage._line) }()
        case 37: try { try decoder.decodeSingularStringField(value: &_storage._moduleID) }()
        case 38: try { try decoder.decodeSingularStringField(value: &_storage._appEngineRelease) }()
        case 39: try { try decoder.decodeSingularStringField(value: &_storage._traceID) }()
        case 40: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 41: try { try decoder.decodeRepeatedMessageField(value: &_storage._sourceReference) }()
        case 42: try { try decoder.decodeSingularBoolField(value: &_storage._first) }()
        case 43: try { try decoder.decodeSingularBoolField(value: &_storage._traceSampled) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._appID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appID, fieldNumber: 1)
      }
      if !_storage._versionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._versionID, fieldNumber: 2)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 3)
      }
      if !_storage._ip.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ip, fieldNumber: 4)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._latency {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if _storage._megaCycles != 0 {
        try visitor.visitSingularInt64Field(value: _storage._megaCycles, fieldNumber: 9)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 10)
      }
      if !_storage._resource.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resource, fieldNumber: 11)
      }
      if !_storage._httpVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._httpVersion, fieldNumber: 12)
      }
      if _storage._status != 0 {
        try visitor.visitSingularInt32Field(value: _storage._status, fieldNumber: 13)
      }
      if _storage._responseSize != 0 {
        try visitor.visitSingularInt64Field(value: _storage._responseSize, fieldNumber: 14)
      }
      if !_storage._referrer.isEmpty {
        try visitor.visitSingularStringField(value: _storage._referrer, fieldNumber: 15)
      }
      if !_storage._userAgent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userAgent, fieldNumber: 16)
      }
      if !_storage._urlMapEntry.isEmpty {
        try visitor.visitSingularStringField(value: _storage._urlMapEntry, fieldNumber: 17)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 20)
      }
      if _storage._cost != 0 {
        try visitor.visitSingularDoubleField(value: _storage._cost, fieldNumber: 21)
      }
      if !_storage._taskQueueName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueueName, fieldNumber: 22)
      }
      if !_storage._taskName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskName, fieldNumber: 23)
      }
      if _storage._wasLoadingRequest != false {
        try visitor.visitSingularBoolField(value: _storage._wasLoadingRequest, fieldNumber: 24)
      }
      if let v = _storage._pendingTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }
      if _storage._instanceIndex != 0 {
        try visitor.visitSingularInt32Field(value: _storage._instanceIndex, fieldNumber: 26)
      }
      if _storage._finished != false {
        try visitor.visitSingularBoolField(value: _storage._finished, fieldNumber: 27)
      }
      if !_storage._instanceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._instanceID, fieldNumber: 28)
      }
      if !_storage._line.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._line, fieldNumber: 29)
      }
      if !_storage._moduleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._moduleID, fieldNumber: 37)
      }
      if !_storage._appEngineRelease.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appEngineRelease, fieldNumber: 38)
      }
      if !_storage._traceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._traceID, fieldNumber: 39)
      }
      if !_storage._nickname.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nickname, fieldNumber: 40)
      }
      if !_storage._sourceReference.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sourceReference, fieldNumber: 41)
      }
      if _storage._first != false {
        try visitor.visitSingularBoolField(value: _storage._first, fieldNumber: 42)
      }
      if _storage._traceSampled != false {
        try visitor.visitSingularBoolField(value: _storage._traceSampled, fieldNumber: 43)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Appengine_Logging_V1_RequestLog, rhs: Google_Appengine_Logging_V1_RequestLog) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._appID != rhs_storage._appID {return false}
        if _storage._moduleID != rhs_storage._moduleID {return false}
        if _storage._versionID != rhs_storage._versionID {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._ip != rhs_storage._ip {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._latency != rhs_storage._latency {return false}
        if _storage._megaCycles != rhs_storage._megaCycles {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._httpVersion != rhs_storage._httpVersion {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._responseSize != rhs_storage._responseSize {return false}
        if _storage._referrer != rhs_storage._referrer {return false}
        if _storage._userAgent != rhs_storage._userAgent {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._urlMapEntry != rhs_storage._urlMapEntry {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._cost != rhs_storage._cost {return false}
        if _storage._taskQueueName != rhs_storage._taskQueueName {return false}
        if _storage._taskName != rhs_storage._taskName {return false}
        if _storage._wasLoadingRequest != rhs_storage._wasLoadingRequest {return false}
        if _storage._pendingTime != rhs_storage._pendingTime {return false}
        if _storage._instanceIndex != rhs_storage._instanceIndex {return false}
        if _storage._finished != rhs_storage._finished {return false}
        if _storage._first != rhs_storage._first {return false}
        if _storage._instanceID != rhs_storage._instanceID {return false}
        if _storage._line != rhs_storage._line {return false}
        if _storage._appEngineRelease != rhs_storage._appEngineRelease {return false}
        if _storage._traceID != rhs_storage._traceID {return false}
        if _storage._traceSampled != rhs_storage._traceSampled {return false}
        if _storage._sourceReference != rhs_storage._sourceReference {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

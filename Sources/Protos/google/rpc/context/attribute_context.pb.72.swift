// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/rpc/context/attribute_context.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// This message defines the standard attribute vocabulary for Google APIs.
///
/// An attribute is a piece of metadata that describes an activity on a network
/// service. For example, the size of an HTTP request, or the status code of
/// an HTTP response.
///
/// Each attribute has a type and a name, which is logically defined as
/// a proto message field in `AttributeContext`. The field type becomes the
/// attribute type, and the field path becomes the attribute name. For example,
/// the attribute `source.ip` maps to field `AttributeContext.source.ip`.
///
/// This message definition is guaranteed not to have any wire breaking change.
/// So you can use it directly for passing attributes across different systems.
///
/// NOTE: Different system may generate different subset of attributes. Please
/// verify the system specification before relying on an attribute generated
/// a system.
public struct Google_Rpc_Context_AttributeContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The origin of a network activity. In a multi hop network activity,
  /// the origin represents the sender of the first hop. For the first hop,
  /// the `source` and the `origin` must have the same content.
  public var origin: Google_Rpc_Context_AttributeContext.Peer {
    get {return _storage._origin ?? Google_Rpc_Context_AttributeContext.Peer()}
    set {_uniqueStorage()._origin = newValue}
  }
  /// Returns true if `origin` has been explicitly set.
  public var hasOrigin: Bool {return _storage._origin != nil}
  /// Clears the value of `origin`. Subsequent reads from it will return its default value.
  public mutating func clearOrigin() {_uniqueStorage()._origin = nil}

  /// The source of a network activity, such as starting a TCP connection.
  /// In a multi hop network activity, the source represents the sender of the
  /// last hop.
  public var source: Google_Rpc_Context_AttributeContext.Peer {
    get {return _storage._source ?? Google_Rpc_Context_AttributeContext.Peer()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {_uniqueStorage()._source = nil}

  /// The destination of a network activity, such as accepting a TCP connection.
  /// In a multi hop network activity, the destination represents the receiver of
  /// the last hop.
  public var destination: Google_Rpc_Context_AttributeContext.Peer {
    get {return _storage._destination ?? Google_Rpc_Context_AttributeContext.Peer()}
    set {_uniqueStorage()._destination = newValue}
  }
  /// Returns true if `destination` has been explicitly set.
  public var hasDestination: Bool {return _storage._destination != nil}
  /// Clears the value of `destination`. Subsequent reads from it will return its default value.
  public mutating func clearDestination() {_uniqueStorage()._destination = nil}

  /// Represents a network request, such as an HTTP request.
  public var request: Google_Rpc_Context_AttributeContext.Request {
    get {return _storage._request ?? Google_Rpc_Context_AttributeContext.Request()}
    set {_uniqueStorage()._request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  public var hasRequest: Bool {return _storage._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  public mutating func clearRequest() {_uniqueStorage()._request = nil}

  /// Represents a network response, such as an HTTP response.
  public var response: Google_Rpc_Context_AttributeContext.Response {
    get {return _storage._response ?? Google_Rpc_Context_AttributeContext.Response()}
    set {_uniqueStorage()._response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  public var hasResponse: Bool {return _storage._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  public mutating func clearResponse() {_uniqueStorage()._response = nil}

  /// Represents a target resource that is involved with a network activity.
  /// If multiple resources are involved with an activity, this must be the
  /// primary one.
  public var resource: Google_Rpc_Context_AttributeContext.Resource {
    get {return _storage._resource ?? Google_Rpc_Context_AttributeContext.Resource()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Represents an API operation that is involved to a network activity.
  public var api: Google_Rpc_Context_AttributeContext.Api {
    get {return _storage._api ?? Google_Rpc_Context_AttributeContext.Api()}
    set {_uniqueStorage()._api = newValue}
  }
  /// Returns true if `api` has been explicitly set.
  public var hasApi: Bool {return _storage._api != nil}
  /// Clears the value of `api`. Subsequent reads from it will return its default value.
  public mutating func clearApi() {_uniqueStorage()._api = nil}

  /// Supports extensions for advanced use cases, such as logs and metrics.
  public var extensions: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._extensions}
    set {_uniqueStorage()._extensions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This message defines attributes for a node that handles a network request.
  /// The node can be either a service or an application that sends, forwards,
  /// or receives the request. Service peers should fill in
  /// `principal` and `labels` as appropriate.
  public struct Peer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The IP address of the peer.
    public var ip: String = String()

    /// The network port of the peer.
    public var port: Int64 = 0

    /// The labels associated with the peer.
    public var labels: Dictionary<String,String> = [:]

    /// The identity of this peer. Similar to `Request.auth.principal`, but
    /// relative to the peer instead of the request. For example, the
    /// idenity associated with a load balancer that forwared the request.
    public var principal: String = String()

    /// The CLDR country/region code associated with the above IP address.
    /// If the IP address is private, the `region_code` should reflect the
    /// physical location where this peer is running.
    public var regionCode: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// This message defines attributes associated with API operations, such as
  /// a network API request. The terminology is based on the conventions used
  /// by Google APIs, Istio, and OpenAPI.
  public struct Api {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The API service name. It is a logical identifier for a networked API,
    /// such as "pubsub.googleapis.com". The naming syntax depends on the
    /// API management system being used for handling the request.
    public var service: String = String()

    /// The API operation name. For gRPC requests, it is the fully qualified API
    /// method name, such as "google.pubsub.v1.Publisher.Publish". For OpenAPI
    /// requests, it is the `operationId`, such as "getPet".
    public var operation: String = String()

    /// The API protocol used for sending the request, such as "http", "https",
    /// "grpc", or "internal".
    public var `protocol`: String = String()

    /// The API version associated with the API operation above, such as "v1" or
    /// "v1alpha1".
    public var version: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// This message defines request authentication attributes. Terminology is
  /// based on the JSON Web Token (JWT) standard, but the terms also
  /// correlate to concepts in other standards.
  public struct Auth {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The authenticated principal. Reflects the issuer (`iss`) and subject
    /// (`sub`) claims within a JWT. The issuer and subject should be `/`
    /// delimited, with `/` percent-encoded within the subject fragment. For
    /// Google accounts, the principal format is:
    /// "https://accounts.google.com/{id}"
    public var principal: String = String()

    /// The intended audience(s) for this authentication information. Reflects
    /// the audience (`aud`) claim within a JWT. The audience
    /// value(s) depends on the `issuer`, but typically include one or more of
    /// the following pieces of information:
    ///
    /// *  The services intended to receive the credential. For example,
    ///    ["https://pubsub.googleapis.com/", "https://storage.googleapis.com/"].
    /// *  A set of service-based scopes. For example,
    ///    ["https://www.googleapis.com/auth/cloud-platform"].
    /// *  The client id of an app, such as the Firebase project id for JWTs
    ///    from Firebase Auth.
    ///
    /// Consult the documentation for the credential issuer to determine the
    /// information provided.
    public var audiences: [String] = []

    /// The authorized presenter of the credential. Reflects the optional
    /// Authorized Presenter (`azp`) claim within a JWT or the
    /// OAuth client id. For example, a Google Cloud Platform client id looks
    /// as follows: "123456789012.apps.googleusercontent.com".
    public var presenter: String = String()

    /// Structured claims presented with the credential. JWTs include
    /// `{key: value}` pairs for standard and private claims. The following
    /// is a subset of the standard required and optional claims that would
    /// typically be presented for a Google-based JWT:
    ///
    ///    {'iss': 'accounts.google.com',
    ///     'sub': '113289723416554971153',
    ///     'aud': ['123456789012', 'pubsub.googleapis.com'],
    ///     'azp': '123456789012.apps.googleusercontent.com',
    ///     'email': 'jsmith@example.com',
    ///     'iat': 1353601026,
    ///     'exp': 1353604926}
    ///
    /// SAML assertions are similarly specified, but with an identity provider
    /// dependent structure.
    public var claims: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _claims ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_claims = newValue}
    }
    /// Returns true if `claims` has been explicitly set.
    public var hasClaims: Bool {return self._claims != nil}
    /// Clears the value of `claims`. Subsequent reads from it will return its default value.
    public mutating func clearClaims() {self._claims = nil}

    /// A list of access level resource names that allow resources to be
    /// accessed by authenticated requester. It is part of Secure GCP processing
    /// for the incoming request. An access level string has the format:
    /// "//{api_service_name}/accessPolicies/{policy_id}/accessLevels/{short_name}"
    ///
    /// Example:
    /// "//accesscontextmanager.googleapis.com/accessPolicies/MY_POLICY_ID/accessLevels/MY_LEVEL"
    public var accessLevels: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _claims: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  /// This message defines attributes for an HTTP request. If the actual
  /// request is not an HTTP request, the runtime system should try to map
  /// the actual request to an equivalent HTTP request.
  public struct Request {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unique ID for a request, which can be propagated to downstream
    /// systems. The ID should have low probability of collision
    /// within a single day for a specific service.
    public var id: String {
      get {return _storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    /// The HTTP request method, such as `GET`, `POST`.
    public var method: String {
      get {return _storage._method}
      set {_uniqueStorage()._method = newValue}
    }

    /// The HTTP request headers. If multiple headers share the same key, they
    /// must be merged according to the HTTP spec. All header keys must be
    /// lowercased, because HTTP header keys are case-insensitive.
    public var headers: Dictionary<String,String> {
      get {return _storage._headers}
      set {_uniqueStorage()._headers = newValue}
    }

    /// The HTTP URL path.
    public var path: String {
      get {return _storage._path}
      set {_uniqueStorage()._path = newValue}
    }

    /// The HTTP request `Host` header value.
    public var host: String {
      get {return _storage._host}
      set {_uniqueStorage()._host = newValue}
    }

    /// The HTTP URL scheme, such as `http` and `https`.
    public var scheme: String {
      get {return _storage._scheme}
      set {_uniqueStorage()._scheme = newValue}
    }

    /// The HTTP URL query in the format of `name1=value1&name2=value2`, as it
    /// appears in the first line of the HTTP request. No decoding is performed.
    public var query: String {
      get {return _storage._query}
      set {_uniqueStorage()._query = newValue}
    }

    /// The timestamp when the `destination` service receives the first byte of
    /// the request.
    public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return _storage._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {_uniqueStorage()._time = nil}

    /// The HTTP request size in bytes. If unknown, it must be -1.
    public var size: Int64 {
      get {return _storage._size}
      set {_uniqueStorage()._size = newValue}
    }

    /// The network protocol used with the request, such as "http/1.1",
    /// "spdy/3", "h2", "h2c", "webrtc", "tcp", "udp", "quic". See
    /// https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
    /// for details.
    public var `protocol`: String {
      get {return _storage._protocol}
      set {_uniqueStorage()._protocol = newValue}
    }

    /// A special parameter for request reason. It is used by security systems
    /// to associate auditing information with a request.
    public var reason: String {
      get {return _storage._reason}
      set {_uniqueStorage()._reason = newValue}
    }

    /// The request authentication. May be absent for unauthenticated requests.
    /// Derived from the HTTP request `Authorization` header or equivalent.
    public var auth: Google_Rpc_Context_AttributeContext.Auth {
      get {return _storage._auth ?? Google_Rpc_Context_AttributeContext.Auth()}
      set {_uniqueStorage()._auth = newValue}
    }
    /// Returns true if `auth` has been explicitly set.
    public var hasAuth: Bool {return _storage._auth != nil}
    /// Clears the value of `auth`. Subsequent reads from it will return its default value.
    public mutating func clearAuth() {_uniqueStorage()._auth = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  /// This message defines attributes for a typical network response. It
  /// generally models semantics of an HTTP response.
  public struct Response {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The HTTP response status code, such as `200` and `404`.
    public var code: Int64 = 0

    /// The HTTP response size in bytes. If unknown, it must be -1.
    public var size: Int64 = 0

    /// The HTTP response headers. If multiple headers share the same key, they
    /// must be merged according to HTTP spec. All header keys must be
    /// lowercased, because HTTP header keys are case-insensitive.
    public var headers: Dictionary<String,String> = [:]

    /// The timestamp when the `destination` service generates the first byte of
    /// the response.
    public var time: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {self._time = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  /// This message defines core attributes for a resource. A resource is an
  /// addressable (named) entity provided by the destination service. For
  /// example, a file stored on a network storage service.
  public struct Resource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the service that this resource belongs to, such as
    /// `pubsub.googleapis.com`. The service may be different from the DNS
    /// hostname that actually serves the request.
    public var service: String = String()

    /// The stable identifier (name) of a resource on the `service`. A resource
    /// can be logically identified as "//{resource.service}/{resource.name}".
    /// The differences between a resource name and a URI are:
    ///
    /// *   Resource name is a logical identifier, independent of network
    ///     protocol and API version. For example,
    ///     `//pubsub.googleapis.com/projects/123/topics/news-feed`.
    /// *   URI often includes protocol and version information, so it can
    ///     be used directly by applications. For example,
    ///     `https://pubsub.googleapis.com/v1/projects/123/topics/news-feed`.
    ///
    /// See https://cloud.google.com/apis/design/resource_names for details.
    public var name: String = String()

    /// The type of the resource. The syntax is platform-specific because
    /// different platforms define their resources differently.
    ///
    /// For Google APIs, the type format must be "{service}/{kind}".
    public var type: String = String()

    /// The labels or tags on the resource, such as AWS resource tags and
    /// Kubernetes resource labels.
    public var labels: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.rpc.context"

extension Google_Rpc_Context_AttributeContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttributeContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "origin"),
    1: .same(proto: "source"),
    2: .same(proto: "destination"),
    3: .same(proto: "request"),
    4: .same(proto: "response"),
    5: .same(proto: "resource"),
    6: .same(proto: "api"),
    8: .same(proto: "extensions"),
  ]

  fileprivate class _StorageClass {
    var _origin: Google_Rpc_Context_AttributeContext.Peer? = nil
    var _source: Google_Rpc_Context_AttributeContext.Peer? = nil
    var _destination: Google_Rpc_Context_AttributeContext.Peer? = nil
    var _request: Google_Rpc_Context_AttributeContext.Request? = nil
    var _response: Google_Rpc_Context_AttributeContext.Response? = nil
    var _resource: Google_Rpc_Context_AttributeContext.Resource? = nil
    var _api: Google_Rpc_Context_AttributeContext.Api? = nil
    var _extensions: [SwiftProtobuf.Google_Protobuf_Any] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _origin = source._origin
      _source = source._source
      _destination = source._destination
      _request = source._request
      _response = source._response
      _resource = source._resource
      _api = source._api
      _extensions = source._extensions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._destination) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._request) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._response) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._api) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._origin) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._extensions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._destination {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._request {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._response {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._api {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._origin {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._extensions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._extensions, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext, rhs: Google_Rpc_Context_AttributeContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._origin != rhs_storage._origin {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._destination != rhs_storage._destination {return false}
        if _storage._request != rhs_storage._request {return false}
        if _storage._response != rhs_storage._response {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._api != rhs_storage._api {return false}
        if _storage._extensions != rhs_storage._extensions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Rpc_Context_AttributeContext.Peer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Rpc_Context_AttributeContext.protoMessageName + ".Peer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ip"),
    2: .same(proto: "port"),
    6: .same(proto: "labels"),
    7: .same(proto: "principal"),
    8: .standard(proto: "region_code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.port) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.principal) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt64Field(value: self.port, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 6)
    }
    if !self.principal.isEmpty {
      try visitor.visitSingularStringField(value: self.principal, fieldNumber: 7)
    }
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext.Peer, rhs: Google_Rpc_Context_AttributeContext.Peer) -> Bool {
    if lhs.ip != rhs.ip {return false}
    if lhs.port != rhs.port {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.principal != rhs.principal {return false}
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Rpc_Context_AttributeContext.Api: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Rpc_Context_AttributeContext.protoMessageName + ".Api"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .same(proto: "operation"),
    3: .same(proto: "protocol"),
    4: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 2)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 3)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext.Api, rhs: Google_Rpc_Context_AttributeContext.Api) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Rpc_Context_AttributeContext.Auth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Rpc_Context_AttributeContext.protoMessageName + ".Auth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "principal"),
    2: .same(proto: "audiences"),
    3: .same(proto: "presenter"),
    4: .same(proto: "claims"),
    5: .standard(proto: "access_levels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.principal) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.audiences) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.presenter) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._claims) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.accessLevels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.principal.isEmpty {
      try visitor.visitSingularStringField(value: self.principal, fieldNumber: 1)
    }
    if !self.audiences.isEmpty {
      try visitor.visitRepeatedStringField(value: self.audiences, fieldNumber: 2)
    }
    if !self.presenter.isEmpty {
      try visitor.visitSingularStringField(value: self.presenter, fieldNumber: 3)
    }
    if let v = self._claims {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.accessLevels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.accessLevels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext.Auth, rhs: Google_Rpc_Context_AttributeContext.Auth) -> Bool {
    if lhs.principal != rhs.principal {return false}
    if lhs.audiences != rhs.audiences {return false}
    if lhs.presenter != rhs.presenter {return false}
    if lhs._claims != rhs._claims {return false}
    if lhs.accessLevels != rhs.accessLevels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Rpc_Context_AttributeContext.Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Rpc_Context_AttributeContext.protoMessageName + ".Request"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "method"),
    3: .same(proto: "headers"),
    4: .same(proto: "path"),
    5: .same(proto: "host"),
    6: .same(proto: "scheme"),
    7: .same(proto: "query"),
    9: .same(proto: "time"),
    10: .same(proto: "size"),
    11: .same(proto: "protocol"),
    12: .same(proto: "reason"),
    13: .same(proto: "auth"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _method: String = String()
    var _headers: Dictionary<String,String> = [:]
    var _path: String = String()
    var _host: String = String()
    var _scheme: String = String()
    var _query: String = String()
    var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _size: Int64 = 0
    var _protocol: String = String()
    var _reason: String = String()
    var _auth: Google_Rpc_Context_AttributeContext.Auth? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _method = source._method
      _headers = source._headers
      _path = source._path
      _host = source._host
      _scheme = source._scheme
      _query = source._query
      _time = source._time
      _size = source._size
      _protocol = source._protocol
      _reason = source._reason
      _auth = source._auth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._method) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._headers) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._path) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._host) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._scheme) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._query) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._time) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._size) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._protocol) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._auth) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 2)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._headers, fieldNumber: 3)
      }
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 4)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 5)
      }
      if !_storage._scheme.isEmpty {
        try visitor.visitSingularStringField(value: _storage._scheme, fieldNumber: 6)
      }
      if !_storage._query.isEmpty {
        try visitor.visitSingularStringField(value: _storage._query, fieldNumber: 7)
      }
      if let v = _storage._time {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if _storage._size != 0 {
        try visitor.visitSingularInt64Field(value: _storage._size, fieldNumber: 10)
      }
      if !_storage._protocol.isEmpty {
        try visitor.visitSingularStringField(value: _storage._protocol, fieldNumber: 11)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 12)
      }
      if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext.Request, rhs: Google_Rpc_Context_AttributeContext.Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._method != rhs_storage._method {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._path != rhs_storage._path {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._scheme != rhs_storage._scheme {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._time != rhs_storage._time {return false}
        if _storage._size != rhs_storage._size {return false}
        if _storage._protocol != rhs_storage._protocol {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._auth != rhs_storage._auth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Rpc_Context_AttributeContext.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Rpc_Context_AttributeContext.protoMessageName + ".Response"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "size"),
    3: .same(proto: "headers"),
    4: .same(proto: "time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt64Field(value: self.code, fieldNumber: 1)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 2)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 3)
    }
    if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext.Response, rhs: Google_Rpc_Context_AttributeContext.Response) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.size != rhs.size {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Rpc_Context_AttributeContext.Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Rpc_Context_AttributeContext.protoMessageName + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
    2: .same(proto: "name"),
    3: .same(proto: "type"),
    4: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Rpc_Context_AttributeContext.Resource, rhs: Google_Rpc_Context_AttributeContext.Resource) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

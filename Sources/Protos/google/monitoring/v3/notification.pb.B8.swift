// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/notification.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A description of a notification channel. The descriptor includes
/// the properties of the channel and the set of labels or fields that
/// must be specified to configure channels of a given type.
public struct Google_Monitoring_V3_NotificationChannelDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full REST resource name for this descriptor. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[TYPE]
  ///
  /// In the above, `[TYPE]` is the value of the `type` field.
  public var name: String = String()

  /// The type of notification channel, such as "email", "sms", etc.
  /// Notification channel types are globally unique.
  public var type: String = String()

  /// A human-readable name for the notification channel type.  This
  /// form of the name is suitable for a user interface.
  public var displayName: String = String()

  /// A human-readable description of the notification channel
  /// type. The description may include a description of the properties
  /// of the channel and pointers to external documentation.
  public var description_p: String = String()

  /// The set of labels that must be defined to identify a particular
  /// channel of the corresponding type. Each label includes a
  /// description for how that field should be populated.
  public var labels: [Google_Api_LabelDescriptor] = []

  /// The tiers that support this notification channel; the project service tier
  /// must be one of the supported_tiers.
  public var supportedTiers: [Google_Monitoring_V3_ServiceTier] = []

  /// The product launch stage for channels of this type.
  public var launchStage: Google_Api_LaunchStage = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A `NotificationChannel` is a medium through which an alert is
/// delivered when a policy violation is detected. Examples of channels
/// include email, SMS, and third-party messaging applications. Fields
/// containing sensitive information like authentication tokens or
/// contact info are only partially populated on retrieval.
public struct Google_Monitoring_V3_NotificationChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the notification channel. This field matches the
  /// value of the [NotificationChannelDescriptor.type][google.monitoring.v3.NotificationChannelDescriptor.type] field.
  public var type: String = String()

  /// The full REST resource name for this channel. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
  ///
  /// The `[CHANNEL_ID]` is automatically assigned by the server on creation.
  public var name: String = String()

  /// An optional human-readable name for this notification channel. It is
  /// recommended that you specify a non-empty and unique name in order to
  /// make it easier to identify the channels in your project, though this is
  /// not enforced. The display name is limited to 512 Unicode characters.
  public var displayName: String = String()

  /// An optional human-readable description of this notification channel. This
  /// description may provide additional details, beyond the display
  /// name, for the channel. This may not exceed 1024 Unicode characters.
  public var description_p: String = String()

  /// Configuration fields that define the channel and its behavior. The
  /// permissible and required labels are specified in the
  /// [NotificationChannelDescriptor.labels][google.monitoring.v3.NotificationChannelDescriptor.labels] of the
  /// `NotificationChannelDescriptor` corresponding to the `type` field.
  public var labels: Dictionary<String,String> = [:]

  /// User-supplied key/value data that does not need to conform to
  /// the corresponding `NotificationChannelDescriptor`'s schema, unlike
  /// the `labels` field. This field is intended to be used for organizing
  /// and identifying the `NotificationChannel` objects.
  ///
  /// The field can contain up to 64 entries. Each key and value is limited to
  /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
  /// values can contain only lowercase letters, numerals, underscores, and
  /// dashes. Keys must begin with a letter.
  public var userLabels: Dictionary<String,String> = [:]

  /// Indicates whether this channel has been verified or not. On a
  /// [`ListNotificationChannels`][google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
  /// or
  /// [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
  /// operation, this field is expected to be populated.
  ///
  /// If the value is `UNVERIFIED`, then it indicates that the channel is
  /// non-functioning (it both requires verification and lacks verification);
  /// otherwise, it is assumed that the channel works.
  ///
  /// If the channel is neither `VERIFIED` nor `UNVERIFIED`, it implies that
  /// the channel is of a type that does not require verification or that
  /// this specific channel has been exempted from verification because it was
  /// created prior to verification being required for channels of this type.
  ///
  /// This field cannot be modified using a standard
  /// [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
  /// operation. To change the value of this field, you must call
  /// [`VerifyNotificationChannel`][google.monitoring.v3.NotificationChannelService.VerifyNotificationChannel].
  public var verificationStatus: Google_Monitoring_V3_NotificationChannel.VerificationStatus = .unspecified

  /// Whether notifications are forwarded to the described channel. This makes
  /// it possible to disable delivery of notifications to a particular channel
  /// without removing the channel from all alerting policies that reference
  /// the channel. This is a more convenient approach when the change is
  /// temporary and you want to receive notifications from the same set
  /// of alerting policies on the channel at some point in the future.
  public var enabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _enabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  public var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  public mutating func clearEnabled() {self._enabled = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates whether the channel has been verified or not. It is illegal
  /// to specify this field in a
  /// [`CreateNotificationChannel`][google.monitoring.v3.NotificationChannelService.CreateNotificationChannel]
  /// or an
  /// [`UpdateNotificationChannel`][google.monitoring.v3.NotificationChannelService.UpdateNotificationChannel]
  /// operation.
  public enum VerificationStatus: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Sentinel value used to indicate that the state is unknown, omitted, or
    /// is not applicable (as in the case of channels that neither support
    /// nor require verification in order to function).
    case unspecified // = 0

    /// The channel has yet to be verified and requires verification to function.
    /// Note that this state also applies to the case where the verification
    /// process has been initiated by sending a verification code but where
    /// the verification code has not been submitted to complete the process.
    case unverified // = 1

    /// It has been proven that notifications can be received on this
    /// notification channel and that someone on the project has access
    /// to messages that are delivered to that channel.
    case verified // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unverified
      case 2: self = .verified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unverified: return 1
      case .verified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _enabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
}

#if swift(>=4.2)

extension Google_Monitoring_V3_NotificationChannel.VerificationStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_NotificationChannel.VerificationStatus] = [
    .unspecified,
    .unverified,
    .verified,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_NotificationChannelDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationChannelDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "name"),
    1: .same(proto: "type"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "description"),
    4: .same(proto: "labels"),
    5: .standard(proto: "supported_tiers"),
    7: .standard(proto: "launch_stage"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      case 5: try { try decoder.decodeRepeatedEnumField(value: &self.supportedTiers) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.launchStage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 4)
    }
    if !self.supportedTiers.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedTiers, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if self.launchStage != .unspecified {
      try visitor.visitSingularEnumField(value: self.launchStage, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_NotificationChannelDescriptor, rhs: Google_Monitoring_V3_NotificationChannelDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.supportedTiers != rhs.supportedTiers {return false}
    if lhs.launchStage != rhs.launchStage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_NotificationChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotificationChannel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    6: .same(proto: "name"),
    3: .standard(proto: "display_name"),
    4: .same(proto: "description"),
    5: .same(proto: "labels"),
    8: .standard(proto: "user_labels"),
    9: .standard(proto: "verification_status"),
    11: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.userLabels) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.verificationStatus) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if !self.userLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.userLabels, fieldNumber: 8)
    }
    if self.verificationStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.verificationStatus, fieldNumber: 9)
    }
    if let v = self._enabled {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_NotificationChannel, rhs: Google_Monitoring_V3_NotificationChannel) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.userLabels != rhs.userLabels {return false}
    if lhs.verificationStatus != rhs.verificationStatus {return false}
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_NotificationChannel.VerificationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VERIFICATION_STATUS_UNSPECIFIED"),
    1: .same(proto: "UNVERIFIED"),
    2: .same(proto: "VERIFIED"),
  ]
}

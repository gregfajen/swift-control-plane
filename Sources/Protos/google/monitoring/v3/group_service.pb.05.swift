// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/group_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The `ListGroup` request.
public struct Google_Monitoring_V3_ListGroupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project whose groups are to be listed. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]
  public var name: String = String()

  /// An optional filter consisting of a single group name.  The filters limit
  /// the groups returned based on their parent-child relationship with the
  /// specified group. If no filter is specified, all groups are returned.
  public var filter: Google_Monitoring_V3_ListGroupsRequest.OneOf_Filter? = nil

  /// A group name. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
  ///
  /// Returns groups whose `parent_name` field contains the group
  /// name.  If no groups have this parent, the results are empty.
  public var childrenOfGroup: String {
    get {
      if case .childrenOfGroup(let v)? = filter {return v}
      return String()
    }
    set {filter = .childrenOfGroup(newValue)}
  }

  /// A group name. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
  ///
  /// Returns groups that are ancestors of the specified group.
  /// The groups are returned in order, starting with the immediate parent and
  /// ending with the most distant ancestor.  If the specified group has no
  /// immediate parent, the results are empty.
  public var ancestorsOfGroup: String {
    get {
      if case .ancestorsOfGroup(let v)? = filter {return v}
      return String()
    }
    set {filter = .ancestorsOfGroup(newValue)}
  }

  /// A group name. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
  ///
  /// Returns the descendants of the specified group.  This is a superset of
  /// the results returned by the `children_of_group` filter, and includes
  /// children-of-children, and so forth.
  public var descendantsOfGroup: String {
    get {
      if case .descendantsOfGroup(let v)? = filter {return v}
      return String()
    }
    set {filter = .descendantsOfGroup(newValue)}
  }

  /// A positive number that is the maximum number of results to return.
  public var pageSize: Int32 = 0

  /// If this field is not empty then it must contain the `next_page_token` value
  /// returned by a previous call to this method.  Using this field causes the
  /// method to return additional results from the previous method call.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// An optional filter consisting of a single group name.  The filters limit
  /// the groups returned based on their parent-child relationship with the
  /// specified group. If no filter is specified, all groups are returned.
  public enum OneOf_Filter: Equatable {
    /// A group name. The format is:
    ///
    ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    ///
    /// Returns groups whose `parent_name` field contains the group
    /// name.  If no groups have this parent, the results are empty.
    case childrenOfGroup(String)
    /// A group name. The format is:
    ///
    ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    ///
    /// Returns groups that are ancestors of the specified group.
    /// The groups are returned in order, starting with the immediate parent and
    /// ending with the most distant ancestor.  If the specified group has no
    /// immediate parent, the results are empty.
    case ancestorsOfGroup(String)
    /// A group name. The format is:
    ///
    ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
    ///
    /// Returns the descendants of the specified group.  This is a superset of
    /// the results returned by the `children_of_group` filter, and includes
    /// children-of-children, and so forth.
    case descendantsOfGroup(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_ListGroupsRequest.OneOf_Filter, rhs: Google_Monitoring_V3_ListGroupsRequest.OneOf_Filter) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.childrenOfGroup, .childrenOfGroup): return {
        guard case .childrenOfGroup(let l) = lhs, case .childrenOfGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ancestorsOfGroup, .ancestorsOfGroup): return {
        guard case .ancestorsOfGroup(let l) = lhs, case .ancestorsOfGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.descendantsOfGroup, .descendantsOfGroup): return {
        guard case .descendantsOfGroup(let l) = lhs, case .descendantsOfGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The `ListGroups` response.
public struct Google_Monitoring_V3_ListGroupsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The groups that match the specified filters.
  public var group: [Google_Monitoring_V3_Group] = []

  /// If there are more results than have been returned, then this field is set
  /// to a non-empty value.  To see the additional results,
  /// use that value as `page_token` in the next call to this method.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `GetGroup` request.
public struct Google_Monitoring_V3_GetGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The group to retrieve. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `CreateGroup` request.
public struct Google_Monitoring_V3_CreateGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project in which to create the group. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]
  public var name: String = String()

  /// Required. A group definition. It is an error to define the `name` field because
  /// the system assigns the name.
  public var group: Google_Monitoring_V3_Group {
    get {return _group ?? Google_Monitoring_V3_Group()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  /// If true, validate this request but do not create the group.
  public var validateOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: Google_Monitoring_V3_Group? = nil
}

/// The `UpdateGroup` request.
public struct Google_Monitoring_V3_UpdateGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The new definition of the group.  All fields of the existing group,
  /// excepting `name`, are replaced with the corresponding fields of this group.
  public var group: Google_Monitoring_V3_Group {
    get {return _group ?? Google_Monitoring_V3_Group()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  public var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  public mutating func clearGroup() {self._group = nil}

  /// If true, validate this request but do not update the existing group.
  public var validateOnly: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _group: Google_Monitoring_V3_Group? = nil
}

/// The `DeleteGroup` request. The default behavior is to be able to delete a
/// single group without any descendants.
public struct Google_Monitoring_V3_DeleteGroupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The group to delete. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
  public var name: String = String()

  /// If this field is true, then the request means to delete a group with all
  /// its descendants. Otherwise, the request means to delete a group only when
  /// it has no descendants. The default value is false.
  public var recursive: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `ListGroupMembers` request.
public struct Google_Monitoring_V3_ListGroupMembersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The group whose members are listed. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]
  public var name: String = String()

  /// A positive number that is the maximum number of results to return.
  public var pageSize: Int32 = 0

  /// If this field is not empty then it must contain the `next_page_token` value
  /// returned by a previous call to this method.  Using this field causes the
  /// method to return additional results from the previous method call.
  public var pageToken: String = String()

  /// An optional [list
  /// filter](https://cloud.google.com/monitoring/api/learn_more#filtering)
  /// describing the members to be returned.  The filter may reference the type,
  /// labels, and metadata of monitored resources that comprise the group. For
  /// example, to return only resources representing Compute Engine VM instances,
  /// use this filter:
  ///
  ///     `resource.type = "gce_instance"`
  public var filter: String = String()

  /// An optional time interval for which results should be returned. Only
  /// members that were part of the group during the specified interval are
  /// included in the response.  If no interval is provided then the group
  /// membership over the last minute is returned.
  public var interval: Google_Monitoring_V3_TimeInterval {
    get {return _interval ?? Google_Monitoring_V3_TimeInterval()}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  public var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  public mutating func clearInterval() {self._interval = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interval: Google_Monitoring_V3_TimeInterval? = nil
}

/// The `ListGroupMembers` response.
public struct Google_Monitoring_V3_ListGroupMembersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A set of monitored resources in the group.
  public var members: [Google_Api_MonitoredResource] = []

  /// If there are more results than have been returned, then this field is
  /// set to a non-empty value.  To see the additional results, use that value as
  /// `page_token` in the next call to this method.
  public var nextPageToken: String = String()

  /// The total number of elements matching this request.
  public var totalSize: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_ListGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGroupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "name"),
    2: .standard(proto: "children_of_group"),
    3: .standard(proto: "ancestors_of_group"),
    4: .standard(proto: "descendants_of_group"),
    5: .standard(proto: "page_size"),
    6: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.filter = .childrenOfGroup(v)}
      }()
      case 3: try {
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.filter = .ancestorsOfGroup(v)}
      }()
      case 4: try {
        if self.filter != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.filter = .descendantsOfGroup(v)}
      }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.filter {
    case .childrenOfGroup?: try {
      guard case .childrenOfGroup(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .ancestorsOfGroup?: try {
      guard case .ancestorsOfGroup(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .descendantsOfGroup?: try {
      guard case .descendantsOfGroup(let v)? = self.filter else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 5)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListGroupsRequest, rhs: Google_Monitoring_V3_ListGroupsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ListGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGroupsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.group) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.group.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.group, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListGroupsResponse, rhs: Google_Monitoring_V3_ListGroupsResponse) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_GetGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_GetGroupRequest, rhs: Google_Monitoring_V3_GetGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_CreateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "name"),
    2: .same(proto: "group"),
    3: .standard(proto: "validate_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.validateOnly) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.validateOnly != false {
      try visitor.visitSingularBoolField(value: self.validateOnly, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_CreateGroupRequest, rhs: Google_Monitoring_V3_CreateGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._group != rhs._group {return false}
    if lhs.validateOnly != rhs.validateOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UpdateGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "group"),
    3: .standard(proto: "validate_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.validateOnly) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.validateOnly != false {
      try visitor.visitSingularBoolField(value: self.validateOnly, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UpdateGroupRequest, rhs: Google_Monitoring_V3_UpdateGroupRequest) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.validateOnly != rhs.validateOnly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_DeleteGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteGroupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    4: .same(proto: "recursive"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.recursive) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.recursive != false {
      try visitor.visitSingularBoolField(value: self.recursive, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_DeleteGroupRequest, rhs: Google_Monitoring_V3_DeleteGroupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.recursive != rhs.recursive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ListGroupMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGroupMembersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "name"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .same(proto: "filter"),
    6: .same(proto: "interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._interval) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    if let v = self._interval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListGroupMembersRequest, rhs: Google_Monitoring_V3_ListGroupMembersRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs._interval != rhs._interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ListGroupMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListGroupMembersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "members"),
    2: .standard(proto: "next_page_token"),
    3: .standard(proto: "total_size"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.totalSize) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if self.totalSize != 0 {
      try visitor.visitSingularInt32Field(value: self.totalSize, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListGroupMembersResponse, rhs: Google_Monitoring_V3_ListGroupMembersResponse) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.totalSize != rhs.totalSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

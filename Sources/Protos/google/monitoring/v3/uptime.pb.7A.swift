// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/uptime.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The regions from which an Uptime check can be run.
public enum Google_Monitoring_V3_UptimeCheckRegion: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default value if no region is specified. Will result in Uptime checks
  /// running from all regions.
  case regionUnspecified // = 0

  /// Allows checks to run from locations within the United States of America.
  case usa // = 1

  /// Allows checks to run from locations within the continent of Europe.
  case europe // = 2

  /// Allows checks to run from locations within the continent of South
  /// America.
  case southAmerica // = 3

  /// Allows checks to run from locations within the Asia Pacific area (ex:
  /// Singapore).
  case asiaPacific // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .regionUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .regionUnspecified
    case 1: self = .usa
    case 2: self = .europe
    case 3: self = .southAmerica
    case 4: self = .asiaPacific
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .regionUnspecified: return 0
    case .usa: return 1
    case .europe: return 2
    case .southAmerica: return 3
    case .asiaPacific: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Monitoring_V3_UptimeCheckRegion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_UptimeCheckRegion] = [
    .regionUnspecified,
    .usa,
    .europe,
    .southAmerica,
    .asiaPacific,
  ]
}

#endif  // swift(>=4.2)

/// The supported resource types that can be used as values of
/// `group_resource.resource_type`.
/// `INSTANCE` includes `gce_instance` and `aws_ec2_instance` resource types.
/// The resource types `gae_app` and `uptime_url` are not valid here because
/// group checks on App Engine modules and URLs are not allowed.
public enum Google_Monitoring_V3_GroupResourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Default value (not valid).
  case resourceTypeUnspecified // = 0

  /// A group of instances from Google Cloud Platform (GCP) or
  /// Amazon Web Services (AWS).
  case instance // = 1

  /// A group of Amazon ELB load balancers.
  case awsElbLoadBalancer // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .resourceTypeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resourceTypeUnspecified
    case 1: self = .instance
    case 2: self = .awsElbLoadBalancer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .resourceTypeUnspecified: return 0
    case .instance: return 1
    case .awsElbLoadBalancer: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Monitoring_V3_GroupResourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_GroupResourceType] = [
    .resourceTypeUnspecified,
    .instance,
    .awsElbLoadBalancer,
  ]
}

#endif  // swift(>=4.2)

/// An internal checker allows Uptime checks to run on private/internal GCP
/// resources.
public struct Google_Monitoring_V3_InternalChecker {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique resource name for this InternalChecker. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/internalCheckers/[INTERNAL_CHECKER_ID]
  ///
  /// `[PROJECT_ID_OR_NUMBER]` is the Stackdriver Workspace project for the
  /// Uptime check config associated with the internal checker.
  public var name: String = String()

  /// The checker's human-readable name. The display name
  /// should be unique within a Stackdriver Workspace in order to make it easier
  /// to identify; however, uniqueness is not enforced.
  public var displayName: String = String()

  /// The [GCP VPC network](https://cloud.google.com/vpc/docs/vpc) where the
  /// internal resource lives (ex: "default").
  public var network: String = String()

  /// The GCP zone the Uptime check should egress from. Only respected for
  /// internal Uptime checks, where internal_network is specified.
  public var gcpZone: String = String()

  /// The GCP project ID where the internal checker lives. Not necessary
  /// the same as the Workspace project.
  public var peerProjectID: String = String()

  /// The current operational state of the internal checker.
  public var state: Google_Monitoring_V3_InternalChecker.State = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operational states for an internal checker.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An internal checker should never be in the unspecified state.
    case unspecified // = 0

    /// The checker is being created, provisioned, and configured. A checker in
    /// this state can be returned by `ListInternalCheckers` or
    /// `GetInternalChecker`, as well as by examining the [long running
    /// Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
    /// that created it.
    case creating // = 1

    /// The checker is running and available for use. A checker in this state
    /// can be returned by `ListInternalCheckers` or `GetInternalChecker` as
    /// well as by examining the [long running
    /// Operation](https://cloud.google.com/apis/design/design_patterns#long_running_operations)
    /// that created it.
    /// If a checker is being torn down, it is neither visible nor usable, so
    /// there is no "deleting" or "down" state.
    case running // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .running
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .running: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Monitoring_V3_InternalChecker.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_InternalChecker.State] = [
    .unspecified,
    .creating,
    .running,
  ]
}

#endif  // swift(>=4.2)

/// This message configures which resources and services to monitor for
/// availability.
public struct Google_Monitoring_V3_UptimeCheckConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique resource name for this Uptime check configuration. The format is:
  ///
  ///      projects/[PROJECT_ID_OR_NUMBER]/uptimeCheckConfigs/[UPTIME_CHECK_ID]
  ///
  /// This field should be omitted when creating the Uptime check configuration;
  /// on create, the resource name is assigned by the server and included in the
  /// response.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A human-friendly name for the Uptime check configuration. The display name
  /// should be unique within a Stackdriver Workspace in order to make it easier
  /// to identify; however, uniqueness is not enforced. Required.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// The resource the check is checking. Required.
  public var resource: OneOf_Resource? {
    get {return _storage._resource}
    set {_uniqueStorage()._resource = newValue}
  }

  /// The [monitored
  /// resource](https://cloud.google.com/monitoring/api/resources) associated
  /// with the configuration.
  /// The following monitored resource types are supported for Uptime checks:
  ///   `uptime_url`,
  ///   `gce_instance`,
  ///   `gae_app`,
  ///   `aws_ec2_instance`,
  ///   `aws_elb_load_balancer`
  public var monitoredResource: Google_Api_MonitoredResource {
    get {
      if case .monitoredResource(let v)? = _storage._resource {return v}
      return Google_Api_MonitoredResource()
    }
    set {_uniqueStorage()._resource = .monitoredResource(newValue)}
  }

  /// The group resource associated with the configuration.
  public var resourceGroup: Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup {
    get {
      if case .resourceGroup(let v)? = _storage._resource {return v}
      return Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup()
    }
    set {_uniqueStorage()._resource = .resourceGroup(newValue)}
  }

  /// The type of Uptime check request.
  public var checkRequestType: OneOf_CheckRequestType? {
    get {return _storage._checkRequestType}
    set {_uniqueStorage()._checkRequestType = newValue}
  }

  /// Contains information needed to make an HTTP or HTTPS check.
  public var httpCheck: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck {
    get {
      if case .httpCheck(let v)? = _storage._checkRequestType {return v}
      return Google_Monitoring_V3_UptimeCheckConfig.HttpCheck()
    }
    set {_uniqueStorage()._checkRequestType = .httpCheck(newValue)}
  }

  /// Contains information needed to make a TCP check.
  public var tcpCheck: Google_Monitoring_V3_UptimeCheckConfig.TcpCheck {
    get {
      if case .tcpCheck(let v)? = _storage._checkRequestType {return v}
      return Google_Monitoring_V3_UptimeCheckConfig.TcpCheck()
    }
    set {_uniqueStorage()._checkRequestType = .tcpCheck(newValue)}
  }

  /// How often, in seconds, the Uptime check is performed.
  /// Currently, the only supported values are `60s` (1 minute), `300s`
  /// (5 minutes), `600s` (10 minutes), and `900s` (15 minutes). Optional,
  /// defaults to `60s`.
  public var period: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._period ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._period = newValue}
  }
  /// Returns true if `period` has been explicitly set.
  public var hasPeriod: Bool {return _storage._period != nil}
  /// Clears the value of `period`. Subsequent reads from it will return its default value.
  public mutating func clearPeriod() {_uniqueStorage()._period = nil}

  /// The maximum amount of time to wait for the request to complete (must be
  /// between 1 and 60 seconds). Required.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// The content that is expected to appear in the data returned by the target
  /// server against which the check is run.  Currently, only the first entry
  /// in the `content_matchers` list is supported, and additional entries will
  /// be ignored. This field is optional and should only be specified if a
  /// content match is required as part of the/ Uptime check.
  public var contentMatchers: [Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher] {
    get {return _storage._contentMatchers}
    set {_uniqueStorage()._contentMatchers = newValue}
  }

  /// The list of regions from which the check will be run.
  /// Some regions contain one location, and others contain more than one.
  /// If this field is specified, enough regions must be provided to include a
  /// minimum of 3 locations.  Not specifying this field will result in Uptime
  /// checks running from all available regions.
  public var selectedRegions: [Google_Monitoring_V3_UptimeCheckRegion] {
    get {return _storage._selectedRegions}
    set {_uniqueStorage()._selectedRegions = newValue}
  }

  /// If this is `true`, then checks are made only from the 'internal_checkers'.
  /// If it is `false`, then checks are made only from the 'selected_regions'.
  /// It is an error to provide 'selected_regions' when is_internal is `true`,
  /// or to provide 'internal_checkers' when is_internal is `false`.
  public var isInternal: Bool {
    get {return _storage._isInternal}
    set {_uniqueStorage()._isInternal = newValue}
  }

  /// The internal checkers that this check will egress from. If `is_internal` is
  /// `true` and this list is empty, the check will egress from all the
  /// InternalCheckers configured for the project that owns this
  /// `UptimeCheckConfig`.
  public var internalCheckers: [Google_Monitoring_V3_InternalChecker] {
    get {return _storage._internalCheckers}
    set {_uniqueStorage()._internalCheckers = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The resource the check is checking. Required.
  public enum OneOf_Resource: Equatable {
    /// The [monitored
    /// resource](https://cloud.google.com/monitoring/api/resources) associated
    /// with the configuration.
    /// The following monitored resource types are supported for Uptime checks:
    ///   `uptime_url`,
    ///   `gce_instance`,
    ///   `gae_app`,
    ///   `aws_ec2_instance`,
    ///   `aws_elb_load_balancer`
    case monitoredResource(Google_Api_MonitoredResource)
    /// The group resource associated with the configuration.
    case resourceGroup(Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.OneOf_Resource, rhs: Google_Monitoring_V3_UptimeCheckConfig.OneOf_Resource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.monitoredResource, .monitoredResource): return {
        guard case .monitoredResource(let l) = lhs, case .monitoredResource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.resourceGroup, .resourceGroup): return {
        guard case .resourceGroup(let l) = lhs, case .resourceGroup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The type of Uptime check request.
  public enum OneOf_CheckRequestType: Equatable {
    /// Contains information needed to make an HTTP or HTTPS check.
    case httpCheck(Google_Monitoring_V3_UptimeCheckConfig.HttpCheck)
    /// Contains information needed to make a TCP check.
    case tcpCheck(Google_Monitoring_V3_UptimeCheckConfig.TcpCheck)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.OneOf_CheckRequestType, rhs: Google_Monitoring_V3_UptimeCheckConfig.OneOf_CheckRequestType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.httpCheck, .httpCheck): return {
        guard case .httpCheck(let l) = lhs, case .httpCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tcpCheck, .tcpCheck): return {
        guard case .tcpCheck(let l) = lhs, case .tcpCheck(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The resource submessage for group checks. It can be used instead of a
  /// monitored resource, when multiple resources are being monitored.
  public struct ResourceGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The group of resources being monitored. Should be only the `[GROUP_ID]`,
    /// and not the full-path
    /// `projects/[PROJECT_ID_OR_NUMBER]/groups/[GROUP_ID]`.
    public var groupID: String = String()

    /// The resource type of the group members.
    public var resourceType: Google_Monitoring_V3_GroupResourceType = .resourceTypeUnspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Information involved in an HTTP/HTTPS Uptime check request.
  public struct HttpCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The HTTP request method to use for the check.
    public var requestMethod: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.RequestMethod = .methodUnspecified

    /// If `true`, use HTTPS instead of HTTP to run the check.
    public var useSsl: Bool = false

    /// Optional (defaults to "/"). The path to the page against which to run
    /// the check. Will be combined with the `host` (specified within the
    /// `monitored_resource`) and `port` to construct the full URL. If the
    /// provided path does not begin with "/", a "/" will be prepended
    /// automatically.
    public var path: String = String()

    /// Optional (defaults to 80 when `use_ssl` is `false`, and 443 when
    /// `use_ssl` is `true`). The TCP port on the HTTP server against which to
    /// run the check. Will be combined with host (specified within the
    /// `monitored_resource`) and `path` to construct the full URL.
    public var port: Int32 = 0

    /// The authentication information. Optional when creating an HTTP check;
    /// defaults to empty.
    public var authInfo: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.BasicAuthentication {
      get {return _authInfo ?? Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.BasicAuthentication()}
      set {_authInfo = newValue}
    }
    /// Returns true if `authInfo` has been explicitly set.
    public var hasAuthInfo: Bool {return self._authInfo != nil}
    /// Clears the value of `authInfo`. Subsequent reads from it will return its default value.
    public mutating func clearAuthInfo() {self._authInfo = nil}

    /// Boolean specifiying whether to encrypt the header information.
    /// Encryption should be specified for any headers related to authentication
    /// that you do not wish to be seen when retrieving the configuration. The
    /// server will be responsible for encrypting the headers.
    /// On Get/List calls, if `mask_headers` is set to `true` then the headers
    /// will be obscured with `******.`
    public var maskHeaders: Bool = false

    /// The list of headers to send as part of the Uptime check request.
    /// If two headers have the same key and different values, they should
    /// be entered as a single header, with the value being a comma-separated
    /// list of all the desired values as described at
    /// https://www.w3.org/Protocols/rfc2616/rfc2616.txt (page 31).
    /// Entering two separate headers with the same key in a Create call will
    /// cause the first to be overwritten by the second.
    /// The maximum number of headers allowed is 100.
    public var headers: Dictionary<String,String> = [:]

    /// The content type to use for the check.
    public var contentType: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.ContentType = .typeUnspecified

    /// Boolean specifying whether to include SSL certificate validation as a
    /// part of the Uptime check. Only applies to checks where
    /// `monitored_resource` is set to `uptime_url`. If `use_ssl` is `false`,
    /// setting `validate_ssl` to `true` has no effect.
    public var validateSsl: Bool = false

    /// The request body associated with the HTTP request. If `content_type` is
    /// `URL_ENCODED`, the body passed in must be URL-encoded. Users can provide
    /// a `Content-Length` header via the `headers` field or the API will do
    /// so. The maximum byte size is 1 megabyte. Note: As with all `bytes` fields
    /// JSON representations are base64 encoded.
    public var body: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The HTTP request method options.
    public enum RequestMethod: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// No request method specified.
      case methodUnspecified // = 0

      /// GET request.
      case get // = 1

      /// POST request.
      case post // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .methodUnspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .methodUnspecified
        case 1: self = .get
        case 2: self = .post
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .methodUnspecified: return 0
        case .get: return 1
        case .post: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// Header options corresponding to the Content-Type of the body in HTTP
    /// requests. Note that a `Content-Type` header cannot be present in the
    /// `headers` field if this field is specified.
    public enum ContentType: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// No content type specified. If the request method is POST, an
      /// unspecified content type results in a check creation rejection.
      case typeUnspecified // = 0

      /// `body` is in URL-encoded form. Equivalent to setting the `Content-Type`
      /// to `application/x-www-form-urlencoded` in the HTTP request.
      case urlEncoded // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .typeUnspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .typeUnspecified
        case 1: self = .urlEncoded
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .typeUnspecified: return 0
        case .urlEncoded: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    /// The authentication parameters to provide to the specified resource or
    /// URL that requires a username and password. Currently, only
    /// [Basic HTTP authentication](https://tools.ietf.org/html/rfc7617) is
    /// supported in Uptime checks.
    public struct BasicAuthentication {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The username to use when authenticating with the HTTP server.
      public var username: String = String()

      /// The password to use when authenticating with the HTTP server.
      public var password: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _authInfo: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.BasicAuthentication? = nil
  }

  /// Information required for a TCP Uptime check request.
  public struct TcpCheck {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The TCP port on the server against which to run the check. Will be
    /// combined with host (specified within the `monitored_resource`) to
    /// construct the full URL. Required.
    public var port: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Optional. Used to perform content matching. This allows matching based on
  /// substrings and regular expressions, together with their negations. Only the
  /// first 4&nbsp;MB of an HTTP or HTTPS check's response (and the first
  /// 1&nbsp;MB of a TCP check's response) are examined for purposes of content
  /// matching.
  public struct ContentMatcher {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// String or regex content to match. Maximum 1024 bytes. An empty `content`
    /// string indicates no content matching is to be performed.
    public var content: String = String()

    /// The type of content matcher that will be applied to the server output,
    /// compared to the `content` string when the check is run.
    public var matcher: Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher.ContentMatcherOption = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Options to perform content matching.
    public enum ContentMatcherOption: SwiftProtobuf.Enum {
      public typealias RawValue = Int

      /// No content matcher type specified (maintained for backward
      /// compatibility, but deprecated for future use).
      /// Treated as `CONTAINS_STRING`.
      case unspecified // = 0

      /// Selects substring matching. The match succeeds if the output contains
      /// the `content` string.  This is the default value for checks without
      /// a `matcher` option, or where the value of `matcher` is
      /// `CONTENT_MATCHER_OPTION_UNSPECIFIED`.
      case containsString // = 1

      /// Selects negation of substring matching. The match succeeds if the
      /// output does _NOT_ contain the `content` string.
      case notContainsString // = 2

      /// Selects regular-expression matching. The match succeeds of the output
      /// matches the regular expression specified in the `content` string.
      case matchesRegex // = 3

      /// Selects negation of regular-expression matching. The match succeeds if
      /// the output does _NOT_ match the regular expression specified in the
      /// `content` string.
      case notMatchesRegex // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .containsString
        case 2: self = .notContainsString
        case 3: self = .matchesRegex
        case 4: self = .notMatchesRegex
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .containsString: return 1
        case .notContainsString: return 2
        case .matchesRegex: return 3
        case .notMatchesRegex: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.RequestMethod: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.RequestMethod] = [
    .methodUnspecified,
    .get,
    .post,
  ]
}

extension Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.ContentType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.ContentType] = [
    .typeUnspecified,
    .urlEncoded,
  ]
}

extension Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher.ContentMatcherOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher.ContentMatcherOption] = [
    .unspecified,
    .containsString,
    .notContainsString,
    .matchesRegex,
    .notMatchesRegex,
  ]
}

#endif  // swift(>=4.2)

/// Contains the region, location, and list of IP
/// addresses where checkers in the location run from.
public struct Google_Monitoring_V3_UptimeCheckIp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A broad region category in which the IP address is located.
  public var region: Google_Monitoring_V3_UptimeCheckRegion = .regionUnspecified

  /// A more specific location within the region that typically encodes
  /// a particular city/town/metro (and its containing state/province or country)
  /// within the broader umbrella region category.
  public var location: String = String()

  /// The IP address from which the Uptime check originates. This is a fully
  /// specified IP address (not an IP address range). Most IP addresses, as of
  /// this publication, are in IPv4 format; however, one should not rely on the
  /// IP addresses being in IPv4 format indefinitely, and should support
  /// interpreting this field in either IPv4 or IPv6 format.
  public var ipAddress: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_UptimeCheckRegion: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGION_UNSPECIFIED"),
    1: .same(proto: "USA"),
    2: .same(proto: "EUROPE"),
    3: .same(proto: "SOUTH_AMERICA"),
    4: .same(proto: "ASIA_PACIFIC"),
  ]
}

extension Google_Monitoring_V3_GroupResourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESOURCE_TYPE_UNSPECIFIED"),
    1: .same(proto: "INSTANCE"),
    2: .same(proto: "AWS_ELB_LOAD_BALANCER"),
  ]
}

extension Google_Monitoring_V3_InternalChecker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InternalChecker"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "network"),
    4: .standard(proto: "gcp_zone"),
    6: .standard(proto: "peer_project_id"),
    7: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.gcpZone) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.peerProjectID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    if !self.gcpZone.isEmpty {
      try visitor.visitSingularStringField(value: self.gcpZone, fieldNumber: 4)
    }
    if !self.peerProjectID.isEmpty {
      try visitor.visitSingularStringField(value: self.peerProjectID, fieldNumber: 6)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_InternalChecker, rhs: Google_Monitoring_V3_InternalChecker) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.network != rhs.network {return false}
    if lhs.gcpZone != rhs.gcpZone {return false}
    if lhs.peerProjectID != rhs.peerProjectID {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_InternalChecker.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "RUNNING"),
  ]
}

extension Google_Monitoring_V3_UptimeCheckConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UptimeCheckConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .standard(proto: "monitored_resource"),
    4: .standard(proto: "resource_group"),
    5: .standard(proto: "http_check"),
    6: .standard(proto: "tcp_check"),
    7: .same(proto: "period"),
    8: .same(proto: "timeout"),
    9: .standard(proto: "content_matchers"),
    10: .standard(proto: "selected_regions"),
    15: .standard(proto: "is_internal"),
    14: .standard(proto: "internal_checkers"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _resource: Google_Monitoring_V3_UptimeCheckConfig.OneOf_Resource?
    var _checkRequestType: Google_Monitoring_V3_UptimeCheckConfig.OneOf_CheckRequestType?
    var _period: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _contentMatchers: [Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher] = []
    var _selectedRegions: [Google_Monitoring_V3_UptimeCheckRegion] = []
    var _isInternal: Bool = false
    var _internalCheckers: [Google_Monitoring_V3_InternalChecker] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _resource = source._resource
      _checkRequestType = source._checkRequestType
      _period = source._period
      _timeout = source._timeout
      _contentMatchers = source._contentMatchers
      _selectedRegions = source._selectedRegions
      _isInternal = source._isInternal
      _internalCheckers = source._internalCheckers
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 3: try {
          var v: Google_Api_MonitoredResource?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .monitoredResource(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .monitoredResource(v)}
        }()
        case 4: try {
          var v: Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .resourceGroup(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .resourceGroup(v)}
        }()
        case 5: try {
          var v: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck?
          if let current = _storage._checkRequestType {
            try decoder.handleConflictingOneOf()
            if case .httpCheck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._checkRequestType = .httpCheck(v)}
        }()
        case 6: try {
          var v: Google_Monitoring_V3_UptimeCheckConfig.TcpCheck?
          if let current = _storage._checkRequestType {
            try decoder.handleConflictingOneOf()
            if case .tcpCheck(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._checkRequestType = .tcpCheck(v)}
        }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._period) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._contentMatchers) }()
        case 10: try { try decoder.decodeRepeatedEnumField(value: &_storage._selectedRegions) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._internalCheckers) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._isInternal) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._resource {
      case .monitoredResource?: try {
        guard case .monitoredResource(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .resourceGroup?: try {
        guard case .resourceGroup(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case nil: break
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._checkRequestType {
      case .httpCheck?: try {
        guard case .httpCheck(let v)? = _storage._checkRequestType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .tcpCheck?: try {
        guard case .tcpCheck(let v)? = _storage._checkRequestType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case nil: break
      }
      if let v = _storage._period {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._contentMatchers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contentMatchers, fieldNumber: 9)
      }
      if !_storage._selectedRegions.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._selectedRegions, fieldNumber: 10)
      }
      if !_storage._internalCheckers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._internalCheckers, fieldNumber: 14)
      }
      if _storage._isInternal != false {
        try visitor.visitSingularBoolField(value: _storage._isInternal, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig, rhs: Google_Monitoring_V3_UptimeCheckConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._checkRequestType != rhs_storage._checkRequestType {return false}
        if _storage._period != rhs_storage._period {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._contentMatchers != rhs_storage._contentMatchers {return false}
        if _storage._selectedRegions != rhs_storage._selectedRegions {return false}
        if _storage._isInternal != rhs_storage._isInternal {return false}
        if _storage._internalCheckers != rhs_storage._internalCheckers {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_UptimeCheckConfig.protoMessageName + ".ResourceGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "resource_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resourceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if self.resourceType != .resourceTypeUnspecified {
      try visitor.visitSingularEnumField(value: self.resourceType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup, rhs: Google_Monitoring_V3_UptimeCheckConfig.ResourceGroup) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UptimeCheckConfig.HttpCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_UptimeCheckConfig.protoMessageName + ".HttpCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    8: .standard(proto: "request_method"),
    1: .standard(proto: "use_ssl"),
    2: .same(proto: "path"),
    3: .same(proto: "port"),
    4: .standard(proto: "auth_info"),
    5: .standard(proto: "mask_headers"),
    6: .same(proto: "headers"),
    9: .standard(proto: "content_type"),
    7: .standard(proto: "validate_ssl"),
    10: .same(proto: "body"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useSsl) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._authInfo) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.maskHeaders) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.headers) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.validateSsl) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.requestMethod) }()
      case 9: try { try decoder.decodeSingularEnumField(value: &self.contentType) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useSsl != false {
      try visitor.visitSingularBoolField(value: self.useSsl, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 3)
    }
    if let v = self._authInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.maskHeaders != false {
      try visitor.visitSingularBoolField(value: self.maskHeaders, fieldNumber: 5)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.headers, fieldNumber: 6)
    }
    if self.validateSsl != false {
      try visitor.visitSingularBoolField(value: self.validateSsl, fieldNumber: 7)
    }
    if self.requestMethod != .methodUnspecified {
      try visitor.visitSingularEnumField(value: self.requestMethod, fieldNumber: 8)
    }
    if self.contentType != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.contentType, fieldNumber: 9)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck, rhs: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck) -> Bool {
    if lhs.requestMethod != rhs.requestMethod {return false}
    if lhs.useSsl != rhs.useSsl {return false}
    if lhs.path != rhs.path {return false}
    if lhs.port != rhs.port {return false}
    if lhs._authInfo != rhs._authInfo {return false}
    if lhs.maskHeaders != rhs.maskHeaders {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.contentType != rhs.contentType {return false}
    if lhs.validateSsl != rhs.validateSsl {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.RequestMethod: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "METHOD_UNSPECIFIED"),
    1: .same(proto: "GET"),
    2: .same(proto: "POST"),
  ]
}

extension Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.ContentType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "URL_ENCODED"),
  ]
}

extension Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.BasicAuthentication: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.protoMessageName + ".BasicAuthentication"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.BasicAuthentication, rhs: Google_Monitoring_V3_UptimeCheckConfig.HttpCheck.BasicAuthentication) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UptimeCheckConfig.TcpCheck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_UptimeCheckConfig.protoMessageName + ".TcpCheck"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.port) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.TcpCheck, rhs: Google_Monitoring_V3_UptimeCheckConfig.TcpCheck) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_UptimeCheckConfig.protoMessageName + ".ContentMatcher"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .same(proto: "matcher"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.matcher) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if self.matcher != .unspecified {
      try visitor.visitSingularEnumField(value: self.matcher, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher, rhs: Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.matcher != rhs.matcher {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UptimeCheckConfig.ContentMatcher.ContentMatcherOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CONTENT_MATCHER_OPTION_UNSPECIFIED"),
    1: .same(proto: "CONTAINS_STRING"),
    2: .same(proto: "NOT_CONTAINS_STRING"),
    3: .same(proto: "MATCHES_REGEX"),
    4: .same(proto: "NOT_MATCHES_REGEX"),
  ]
}

extension Google_Monitoring_V3_UptimeCheckIp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UptimeCheckIp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "region"),
    2: .same(proto: "location"),
    3: .standard(proto: "ip_address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.region != .regionUnspecified {
      try visitor.visitSingularEnumField(value: self.region, fieldNumber: 1)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 2)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UptimeCheckIp, rhs: Google_Monitoring_V3_UptimeCheckIp) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.location != rhs.location {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

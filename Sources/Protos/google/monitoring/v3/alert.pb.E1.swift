// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/alert.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A description of the conditions under which some aspect of your system is
/// considered to be "unhealthy" and the ways to notify people or services about
/// this state. For an overview of alert policies, see
/// [Introduction to Alerting](https://cloud.google.com/monitoring/alerts/).
public struct Google_Monitoring_V3_AlertPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required if the policy exists. The resource name for this policy. The
  /// format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID]
  ///
  /// `[ALERT_POLICY_ID]` is assigned by Stackdriver Monitoring when the policy
  /// is created.  When calling the
  /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
  /// method, do not include the `name` field in the alerting policy passed as
  /// part of the request.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A short name or phrase used to identify the policy in dashboards,
  /// notifications, and incidents. To avoid confusion, don't use the same
  /// display name for multiple policies in the same project. The name is
  /// limited to 512 Unicode characters.
  public var displayName: String {
    get {return _storage._displayName}
    set {_uniqueStorage()._displayName = newValue}
  }

  /// Documentation that is included with notifications and incidents related to
  /// this policy. Best practice is for the documentation to include information
  /// to help responders understand, mitigate, escalate, and correct the
  /// underlying problems detected by the alerting policy. Notification channels
  /// that have limited capacity might not show this documentation.
  public var documentation: Google_Monitoring_V3_AlertPolicy.Documentation {
    get {return _storage._documentation ?? Google_Monitoring_V3_AlertPolicy.Documentation()}
    set {_uniqueStorage()._documentation = newValue}
  }
  /// Returns true if `documentation` has been explicitly set.
  public var hasDocumentation: Bool {return _storage._documentation != nil}
  /// Clears the value of `documentation`. Subsequent reads from it will return its default value.
  public mutating func clearDocumentation() {_uniqueStorage()._documentation = nil}

  /// User-supplied key/value data to be used for organizing and
  /// identifying the `AlertPolicy` objects.
  ///
  /// The field can contain up to 64 entries. Each key and value is limited to
  /// 63 Unicode characters or 128 bytes, whichever is smaller. Labels and
  /// values can contain only lowercase letters, numerals, underscores, and
  /// dashes. Keys must begin with a letter.
  public var userLabels: Dictionary<String,String> {
    get {return _storage._userLabels}
    set {_uniqueStorage()._userLabels = newValue}
  }

  /// A list of conditions for the policy. The conditions are combined by AND or
  /// OR according to the `combiner` field. If the combined conditions evaluate
  /// to true, then an incident is created. A policy can have from one to six
  /// conditions.
  /// If `condition_time_series_query_language` is present, it must be the only
  /// `condition`.
  public var conditions: [Google_Monitoring_V3_AlertPolicy.Condition] {
    get {return _storage._conditions}
    set {_uniqueStorage()._conditions = newValue}
  }

  /// How to combine the results of multiple conditions to determine if an
  /// incident should be opened.
  /// If `condition_time_series_query_language` is present, this must be
  /// `COMBINE_UNSPECIFIED`.
  public var combiner: Google_Monitoring_V3_AlertPolicy.ConditionCombinerType {
    get {return _storage._combiner}
    set {_uniqueStorage()._combiner = newValue}
  }

  /// Whether or not the policy is enabled. On write, the default interpretation
  /// if unset is that the policy is enabled. On read, clients should not make
  /// any assumption about the state if it has not been populated. The
  /// field should always be populated on List and Get operations, unless
  /// a field projection has been specified that strips it out.
  public var enabled: SwiftProtobuf.Google_Protobuf_BoolValue {
    get {return _storage._enabled ?? SwiftProtobuf.Google_Protobuf_BoolValue()}
    set {_uniqueStorage()._enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  public var hasEnabled: Bool {return _storage._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  public mutating func clearEnabled() {_uniqueStorage()._enabled = nil}

  /// Read-only description of how the alert policy is invalid. OK if the alert
  /// policy is valid. If not OK, the alert policy will not generate incidents.
  public var validity: Google_Rpc_Status {
    get {return _storage._validity ?? Google_Rpc_Status()}
    set {_uniqueStorage()._validity = newValue}
  }
  /// Returns true if `validity` has been explicitly set.
  public var hasValidity: Bool {return _storage._validity != nil}
  /// Clears the value of `validity`. Subsequent reads from it will return its default value.
  public mutating func clearValidity() {_uniqueStorage()._validity = nil}

  /// Identifies the notification channels to which notifications should be sent
  /// when incidents are opened or closed or when new violations occur on
  /// an already opened incident. Each element of this array corresponds to
  /// the `name` field in each of the
  /// [`NotificationChannel`][google.monitoring.v3.NotificationChannel]
  /// objects that are returned from the [`ListNotificationChannels`]
  /// [google.monitoring.v3.NotificationChannelService.ListNotificationChannels]
  /// method. The format of the entries in this field is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
  public var notificationChannels: [String] {
    get {return _storage._notificationChannels}
    set {_uniqueStorage()._notificationChannels = newValue}
  }

  /// A read-only record of the creation of the alerting policy. If provided
  /// in a call to create or update, this field will be ignored.
  public var creationRecord: Google_Monitoring_V3_MutationRecord {
    get {return _storage._creationRecord ?? Google_Monitoring_V3_MutationRecord()}
    set {_uniqueStorage()._creationRecord = newValue}
  }
  /// Returns true if `creationRecord` has been explicitly set.
  public var hasCreationRecord: Bool {return _storage._creationRecord != nil}
  /// Clears the value of `creationRecord`. Subsequent reads from it will return its default value.
  public mutating func clearCreationRecord() {_uniqueStorage()._creationRecord = nil}

  /// A read-only record of the most recent change to the alerting policy. If
  /// provided in a call to create or update, this field will be ignored.
  public var mutationRecord: Google_Monitoring_V3_MutationRecord {
    get {return _storage._mutationRecord ?? Google_Monitoring_V3_MutationRecord()}
    set {_uniqueStorage()._mutationRecord = newValue}
  }
  /// Returns true if `mutationRecord` has been explicitly set.
  public var hasMutationRecord: Bool {return _storage._mutationRecord != nil}
  /// Clears the value of `mutationRecord`. Subsequent reads from it will return its default value.
  public mutating func clearMutationRecord() {_uniqueStorage()._mutationRecord = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operators for combining conditions.
  public enum ConditionCombinerType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// An unspecified combiner.
    case combineUnspecified // = 0

    /// Combine conditions using the logical `AND` operator. An
    /// incident is created only if all the conditions are met
    /// simultaneously. This combiner is satisfied if all conditions are
    /// met, even if they are met on completely different resources.
    case and // = 1

    /// Combine conditions using the logical `OR` operator. An incident
    /// is created if any of the listed conditions is met.
    case or // = 2

    /// Combine conditions using logical `AND` operator, but unlike the regular
    /// `AND` option, an incident is created only if all conditions are met
    /// simultaneously on at least one resource.
    case andWithMatchingResource // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .combineUnspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .combineUnspecified
      case 1: self = .and
      case 2: self = .or
      case 3: self = .andWithMatchingResource
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .combineUnspecified: return 0
      case .and: return 1
      case .or: return 2
      case .andWithMatchingResource: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A content string and a MIME type that describes the content string's
  /// format.
  public struct Documentation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The text of the documentation, interpreted according to `mime_type`.
    /// The content may not exceed 8,192 Unicode characters and may not exceed
    /// more than 10,240 bytes when encoded in UTF-8 format, whichever is
    /// smaller.
    public var content: String = String()

    /// The format of the `content` field. Presently, only the value
    /// `"text/markdown"` is supported. See
    /// [Markdown](https://en.wikipedia.org/wiki/Markdown) for more information.
    public var mimeType: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// A condition is a true/false test that determines when an alerting policy
  /// should open an incident. If a condition evaluates to true, it signifies
  /// that something is wrong.
  public struct Condition {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required if the condition exists. The unique resource name for this
    /// condition. Its format is:
    ///
    ///     projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[POLICY_ID]/conditions/[CONDITION_ID]
    ///
    /// `[CONDITION_ID]` is assigned by Stackdriver Monitoring when the
    /// condition is created as part of a new or updated alerting policy.
    ///
    /// When calling the
    /// [alertPolicies.create][google.monitoring.v3.AlertPolicyService.CreateAlertPolicy]
    /// method, do not include the `name` field in the conditions of the
    /// requested alerting policy. Stackdriver Monitoring creates the
    /// condition identifiers and includes them in the new policy.
    ///
    /// When calling the
    /// [alertPolicies.update][google.monitoring.v3.AlertPolicyService.UpdateAlertPolicy]
    /// method to update a policy, including a condition `name` causes the
    /// existing condition to be updated. Conditions without names are added to
    /// the updated policy. Existing conditions are deleted if they are not
    /// updated.
    ///
    /// Best practice is to preserve `[CONDITION_ID]` if you make only small
    /// changes, such as those to condition thresholds, durations, or trigger
    /// values.  Otherwise, treat the change as a new condition and let the
    /// existing condition be deleted.
    public var name: String = String()

    /// A short name or phrase used to identify the condition in dashboards,
    /// notifications, and incidents. To avoid confusion, don't use the same
    /// display name for multiple conditions in the same policy.
    public var displayName: String = String()

    /// Only one of the following condition types will be specified.
    public var condition: Google_Monitoring_V3_AlertPolicy.Condition.OneOf_Condition? = nil

    /// A condition that compares a time series against a threshold.
    public var conditionThreshold: Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold {
      get {
        if case .conditionThreshold(let v)? = condition {return v}
        return Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold()
      }
      set {condition = .conditionThreshold(newValue)}
    }

    /// A condition that checks that a time series continues to
    /// receive new data points.
    public var conditionAbsent: Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence {
      get {
        if case .conditionAbsent(let v)? = condition {return v}
        return Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence()
      }
      set {condition = .conditionAbsent(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Only one of the following condition types will be specified.
    public enum OneOf_Condition: Equatable {
      /// A condition that compares a time series against a threshold.
      case conditionThreshold(Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold)
      /// A condition that checks that a time series continues to
      /// receive new data points.
      case conditionAbsent(Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Condition.OneOf_Condition, rhs: Google_Monitoring_V3_AlertPolicy.Condition.OneOf_Condition) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.conditionThreshold, .conditionThreshold): return {
          guard case .conditionThreshold(let l) = lhs, case .conditionThreshold(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.conditionAbsent, .conditionAbsent): return {
          guard case .conditionAbsent(let l) = lhs, case .conditionAbsent(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    /// Specifies how many time series must fail a predicate to trigger a
    /// condition. If not specified, then a `{count: 1}` trigger is used.
    public struct Trigger {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A type of trigger.
      public var type: Google_Monitoring_V3_AlertPolicy.Condition.Trigger.OneOf_Type? = nil

      /// The absolute number of time series that must fail
      /// the predicate for the condition to be triggered.
      public var count: Int32 {
        get {
          if case .count(let v)? = type {return v}
          return 0
        }
        set {type = .count(newValue)}
      }

      /// The percentage of time series that must fail the
      /// predicate for the condition to be triggered.
      public var percent: Double {
        get {
          if case .percent(let v)? = type {return v}
          return 0
        }
        set {type = .percent(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      /// A type of trigger.
      public enum OneOf_Type: Equatable {
        /// The absolute number of time series that must fail
        /// the predicate for the condition to be triggered.
        case count(Int32)
        /// The percentage of time series that must fail the
        /// predicate for the condition to be triggered.
        case percent(Double)

      #if !swift(>=4.1)
        public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Condition.Trigger.OneOf_Type, rhs: Google_Monitoring_V3_AlertPolicy.Condition.Trigger.OneOf_Type) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.count, .count): return {
            guard case .count(let l) = lhs, case .count(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.percent, .percent): return {
            guard case .percent(let l) = lhs, case .percent(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public init() {}
    }

    /// A condition type that compares a collection of time series
    /// against a threshold.
    public struct MetricThreshold {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
      /// identifies which time series should be compared with the threshold.
      ///
      /// The filter is similar to the one that is specified in the
      /// [`ListTimeSeries`
      /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
      /// (that call is useful to verify the time series that will be retrieved /
      /// processed) and must specify the metric type and optionally may contain
      /// restrictions on resource type, resource labels, and metric labels.
      /// This field may not exceed 2048 Unicode characters in length.
      public var filter: String = String()

      /// Specifies the alignment of data points in individual time series as
      /// well as how to combine the retrieved time series together (such as
      /// when aggregating multiple streams on each resource to a single
      /// stream for each resource or when aggregating streams across all
      /// members of a group of resrouces). Multiple aggregations
      /// are applied in the order specified.
      ///
      /// This field is similar to the one in the [`ListTimeSeries`
      /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
      /// It is advisable to use the `ListTimeSeries` method when debugging this
      /// field.
      public var aggregations: [Google_Monitoring_V3_Aggregation] = []

      /// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
      /// identifies a time series that should be used as the denominator of a
      /// ratio that will be compared with the threshold. If a
      /// `denominator_filter` is specified, the time series specified by the
      /// `filter` field will be used as the numerator.
      ///
      /// The filter must specify the metric type and optionally may contain
      /// restrictions on resource type, resource labels, and metric labels.
      /// This field may not exceed 2048 Unicode characters in length.
      public var denominatorFilter: String = String()

      /// Specifies the alignment of data points in individual time series
      /// selected by `denominatorFilter` as
      /// well as how to combine the retrieved time series together (such as
      /// when aggregating multiple streams on each resource to a single
      /// stream for each resource or when aggregating streams across all
      /// members of a group of resources).
      ///
      /// When computing ratios, the `aggregations` and
      /// `denominator_aggregations` fields must use the same alignment period
      /// and produce time series that have the same periodicity and labels.
      public var denominatorAggregations: [Google_Monitoring_V3_Aggregation] = []

      /// The comparison to apply between the time series (indicated by `filter`
      /// and `aggregation`) and the threshold (indicated by `threshold_value`).
      /// The comparison is applied on each time series, with the time series
      /// on the left-hand side and the threshold on the right-hand side.
      ///
      /// Only `COMPARISON_LT` and `COMPARISON_GT` are supported currently.
      public var comparison: Google_Monitoring_V3_ComparisonType = .comparisonUnspecified

      /// A value against which to compare the time series.
      public var thresholdValue: Double = 0

      /// The amount of time that a time series must violate the
      /// threshold to be considered failing. Currently, only values
      /// that are a multiple of a minute--e.g., 0, 60, 120, or 300
      /// seconds--are supported. If an invalid value is given, an
      /// error will be returned. When choosing a duration, it is useful to
      /// keep in mind the frequency of the underlying time series data
      /// (which may also be affected by any alignments specified in the
      /// `aggregations` field); a good duration is long enough so that a single
      /// outlier does not generate spurious alerts, but short enough that
      /// unhealthy states are detected and alerted on quickly.
      public var duration: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_duration = newValue}
      }
      /// Returns true if `duration` has been explicitly set.
      public var hasDuration: Bool {return self._duration != nil}
      /// Clears the value of `duration`. Subsequent reads from it will return its default value.
      public mutating func clearDuration() {self._duration = nil}

      /// The number/percent of time series for which the comparison must hold
      /// in order for the condition to trigger. If unspecified, then the
      /// condition will trigger if the comparison is true for any of the
      /// time series that have been identified by `filter` and `aggregations`,
      /// or by the ratio, if `denominator_filter` and `denominator_aggregations`
      /// are specified.
      public var trigger: Google_Monitoring_V3_AlertPolicy.Condition.Trigger {
        get {return _trigger ?? Google_Monitoring_V3_AlertPolicy.Condition.Trigger()}
        set {_trigger = newValue}
      }
      /// Returns true if `trigger` has been explicitly set.
      public var hasTrigger: Bool {return self._trigger != nil}
      /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
      public mutating func clearTrigger() {self._trigger = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
      fileprivate var _trigger: Google_Monitoring_V3_AlertPolicy.Condition.Trigger? = nil
    }

    /// A condition type that checks that monitored resources
    /// are reporting data. The configuration defines a metric and
    /// a set of monitored resources. The predicate is considered in violation
    /// when a time series for the specified metric of a monitored
    /// resource does not include any data in the specified `duration`.
    public struct MetricAbsence {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A [filter](https://cloud.google.com/monitoring/api/v3/filters) that
      /// identifies which time series should be compared with the threshold.
      ///
      /// The filter is similar to the one that is specified in the
      /// [`ListTimeSeries`
      /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
      /// (that call is useful to verify the time series that will be retrieved /
      /// processed) and must specify the metric type and optionally may contain
      /// restrictions on resource type, resource labels, and metric labels.
      /// This field may not exceed 2048 Unicode characters in length.
      public var filter: String = String()

      /// Specifies the alignment of data points in individual time series as
      /// well as how to combine the retrieved time series together (such as
      /// when aggregating multiple streams on each resource to a single
      /// stream for each resource or when aggregating streams across all
      /// members of a group of resrouces). Multiple aggregations
      /// are applied in the order specified.
      ///
      /// This field is similar to the one in the [`ListTimeSeries`
      /// request](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list).
      /// It is advisable to use the `ListTimeSeries` method when debugging this
      /// field.
      public var aggregations: [Google_Monitoring_V3_Aggregation] = []

      /// The amount of time that a time series must fail to report new
      /// data to be considered failing. Currently, only values that
      /// are a multiple of a minute--e.g.  60, 120, or 300
      /// seconds--are supported. If an invalid value is given, an
      /// error will be returned. The `Duration.nanos` field is
      /// ignored.
      public var duration: SwiftProtobuf.Google_Protobuf_Duration {
        get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
        set {_duration = newValue}
      }
      /// Returns true if `duration` has been explicitly set.
      public var hasDuration: Bool {return self._duration != nil}
      /// Clears the value of `duration`. Subsequent reads from it will return its default value.
      public mutating func clearDuration() {self._duration = nil}

      /// The number/percent of time series for which the comparison must hold
      /// in order for the condition to trigger. If unspecified, then the
      /// condition will trigger if the comparison is true for any of the
      /// time series that have been identified by `filter` and `aggregations`.
      public var trigger: Google_Monitoring_V3_AlertPolicy.Condition.Trigger {
        get {return _trigger ?? Google_Monitoring_V3_AlertPolicy.Condition.Trigger()}
        set {_trigger = newValue}
      }
      /// Returns true if `trigger` has been explicitly set.
      public var hasTrigger: Bool {return self._trigger != nil}
      /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
      public mutating func clearTrigger() {self._trigger = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
      fileprivate var _trigger: Google_Monitoring_V3_AlertPolicy.Condition.Trigger? = nil
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Monitoring_V3_AlertPolicy.ConditionCombinerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_AlertPolicy.ConditionCombinerType] = [
    .combineUnspecified,
    .and,
    .or,
    .andWithMatchingResource,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_AlertPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AlertPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    13: .same(proto: "documentation"),
    16: .standard(proto: "user_labels"),
    12: .same(proto: "conditions"),
    6: .same(proto: "combiner"),
    17: .same(proto: "enabled"),
    18: .same(proto: "validity"),
    14: .standard(proto: "notification_channels"),
    10: .standard(proto: "creation_record"),
    11: .standard(proto: "mutation_record"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _displayName: String = String()
    var _documentation: Google_Monitoring_V3_AlertPolicy.Documentation? = nil
    var _userLabels: Dictionary<String,String> = [:]
    var _conditions: [Google_Monitoring_V3_AlertPolicy.Condition] = []
    var _combiner: Google_Monitoring_V3_AlertPolicy.ConditionCombinerType = .combineUnspecified
    var _enabled: SwiftProtobuf.Google_Protobuf_BoolValue? = nil
    var _validity: Google_Rpc_Status? = nil
    var _notificationChannels: [String] = []
    var _creationRecord: Google_Monitoring_V3_MutationRecord? = nil
    var _mutationRecord: Google_Monitoring_V3_MutationRecord? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _displayName = source._displayName
      _documentation = source._documentation
      _userLabels = source._userLabels
      _conditions = source._conditions
      _combiner = source._combiner
      _enabled = source._enabled
      _validity = source._validity
      _notificationChannels = source._notificationChannels
      _creationRecord = source._creationRecord
      _mutationRecord = source._mutationRecord
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._displayName) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._combiner) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._creationRecord) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._mutationRecord) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._conditions) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._documentation) }()
        case 14: try { try decoder.decodeRepeatedStringField(value: &_storage._notificationChannels) }()
        case 16: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._userLabels) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._enabled) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._validity) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._displayName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayName, fieldNumber: 2)
      }
      if _storage._combiner != .combineUnspecified {
        try visitor.visitSingularEnumField(value: _storage._combiner, fieldNumber: 6)
      }
      if let v = _storage._creationRecord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._mutationRecord {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._conditions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditions, fieldNumber: 12)
      }
      if let v = _storage._documentation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._notificationChannels.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._notificationChannels, fieldNumber: 14)
      }
      if !_storage._userLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._userLabels, fieldNumber: 16)
      }
      if let v = _storage._enabled {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._validity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_AlertPolicy, rhs: Google_Monitoring_V3_AlertPolicy) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._displayName != rhs_storage._displayName {return false}
        if _storage._documentation != rhs_storage._documentation {return false}
        if _storage._userLabels != rhs_storage._userLabels {return false}
        if _storage._conditions != rhs_storage._conditions {return false}
        if _storage._combiner != rhs_storage._combiner {return false}
        if _storage._enabled != rhs_storage._enabled {return false}
        if _storage._validity != rhs_storage._validity {return false}
        if _storage._notificationChannels != rhs_storage._notificationChannels {return false}
        if _storage._creationRecord != rhs_storage._creationRecord {return false}
        if _storage._mutationRecord != rhs_storage._mutationRecord {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_AlertPolicy.ConditionCombinerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMBINE_UNSPECIFIED"),
    1: .same(proto: "AND"),
    2: .same(proto: "OR"),
    3: .same(proto: "AND_WITH_MATCHING_RESOURCE"),
  ]
}

extension Google_Monitoring_V3_AlertPolicy.Documentation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_AlertPolicy.protoMessageName + ".Documentation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "content"),
    2: .standard(proto: "mime_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Documentation, rhs: Google_Monitoring_V3_AlertPolicy.Documentation) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_AlertPolicy.Condition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_AlertPolicy.protoMessageName + ".Condition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    12: .same(proto: "name"),
    6: .standard(proto: "display_name"),
    1: .standard(proto: "condition_threshold"),
    2: .standard(proto: "condition_absent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .conditionThreshold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .conditionThreshold(v)}
      }()
      case 2: try {
        var v: Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .conditionAbsent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .conditionAbsent(v)}
      }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.condition {
    case .conditionThreshold?: try {
      guard case .conditionThreshold(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .conditionAbsent?: try {
      guard case .conditionAbsent(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Condition, rhs: Google_Monitoring_V3_AlertPolicy.Condition) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.condition != rhs.condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_AlertPolicy.Condition.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_AlertPolicy.Condition.protoMessageName + ".Trigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .same(proto: "percent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: Int32?
        try decoder.decodeSingularInt32Field(value: &v)
        if let v = v {self.type = .count(v)}
      }()
      case 2: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.type = .percent(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .count?: try {
      guard case .count(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    }()
    case .percent?: try {
      guard case .percent(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Condition.Trigger, rhs: Google_Monitoring_V3_AlertPolicy.Condition.Trigger) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_AlertPolicy.Condition.protoMessageName + ".MetricThreshold"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "filter"),
    8: .same(proto: "aggregations"),
    9: .standard(proto: "denominator_filter"),
    10: .standard(proto: "denominator_aggregations"),
    4: .same(proto: "comparison"),
    5: .standard(proto: "threshold_value"),
    6: .same(proto: "duration"),
    7: .same(proto: "trigger"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.comparison) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.thresholdValue) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.aggregations) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.denominatorFilter) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.denominatorAggregations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.comparison != .comparisonUnspecified {
      try visitor.visitSingularEnumField(value: self.comparison, fieldNumber: 4)
    }
    if self.thresholdValue != 0 {
      try visitor.visitSingularDoubleField(value: self.thresholdValue, fieldNumber: 5)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.aggregations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregations, fieldNumber: 8)
    }
    if !self.denominatorFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.denominatorFilter, fieldNumber: 9)
    }
    if !self.denominatorAggregations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.denominatorAggregations, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold, rhs: Google_Monitoring_V3_AlertPolicy.Condition.MetricThreshold) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.aggregations != rhs.aggregations {return false}
    if lhs.denominatorFilter != rhs.denominatorFilter {return false}
    if lhs.denominatorAggregations != rhs.denominatorAggregations {return false}
    if lhs.comparison != rhs.comparison {return false}
    if lhs.thresholdValue != rhs.thresholdValue {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_AlertPolicy.Condition.protoMessageName + ".MetricAbsence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    5: .same(proto: "aggregations"),
    2: .same(proto: "duration"),
    3: .same(proto: "trigger"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.aggregations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 1)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.aggregations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.aggregations, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence, rhs: Google_Monitoring_V3_AlertPolicy.Condition.MetricAbsence) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs.aggregations != rhs.aggregations {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

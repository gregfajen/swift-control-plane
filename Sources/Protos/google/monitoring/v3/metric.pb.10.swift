// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/metric.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A single data point in a time series.
public struct Google_Monitoring_V3_Point {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time interval to which the data point applies.  For `GAUGE` metrics,
  /// the start time is optional, but if it is supplied, it must equal the
  /// end time.  For `DELTA` metrics, the start
  /// and end time should specify a non-zero interval, with subsequent points
  /// specifying contiguous and non-overlapping intervals.  For `CUMULATIVE`
  /// metrics, the start and end time should specify a non-zero interval, with
  /// subsequent points specifying the same start time and increasing end times,
  /// until an event resets the cumulative value to zero and sets a new start
  /// time for the following points.
  public var interval: Google_Monitoring_V3_TimeInterval {
    get {return _interval ?? Google_Monitoring_V3_TimeInterval()}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  public var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  public mutating func clearInterval() {self._interval = nil}

  /// The value of the data point.
  public var value: Google_Monitoring_V3_TypedValue {
    get {return _value ?? Google_Monitoring_V3_TypedValue()}
    set {_value = newValue}
  }
  /// Returns true if `value` has been explicitly set.
  public var hasValue: Bool {return self._value != nil}
  /// Clears the value of `value`. Subsequent reads from it will return its default value.
  public mutating func clearValue() {self._value = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _interval: Google_Monitoring_V3_TimeInterval? = nil
  fileprivate var _value: Google_Monitoring_V3_TypedValue? = nil
}

/// A collection of data points that describes the time-varying values
/// of a metric. A time series is identified by a combination of a
/// fully-specified monitored resource and a fully-specified metric.
/// This type is used for both listing and creating time series.
public struct Google_Monitoring_V3_TimeSeries {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The associated metric. A fully-specified metric used to identify the time
  /// series.
  public var metric: Google_Api_Metric {
    get {return _metric ?? Google_Api_Metric()}
    set {_metric = newValue}
  }
  /// Returns true if `metric` has been explicitly set.
  public var hasMetric: Bool {return self._metric != nil}
  /// Clears the value of `metric`. Subsequent reads from it will return its default value.
  public mutating func clearMetric() {self._metric = nil}

  /// The associated monitored resource.  Custom metrics can use only certain
  /// monitored resource types in their time series data.
  public var resource: Google_Api_MonitoredResource {
    get {return _resource ?? Google_Api_MonitoredResource()}
    set {_resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return self._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {self._resource = nil}

  /// Output only. The associated monitored resource metadata. When reading a
  /// a timeseries, this field will include metadata labels that are explicitly
  /// named in the reduction. When creating a timeseries, this field is ignored.
  public var metadata: Google_Api_MonitoredResourceMetadata {
    get {return _metadata ?? Google_Api_MonitoredResourceMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  public var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  public mutating func clearMetadata() {self._metadata = nil}

  /// The metric kind of the time series. When listing time series, this metric
  /// kind might be different from the metric kind of the associated metric if
  /// this time series is an alignment or reduction of other time series.
  ///
  /// When creating a time series, this field is optional. If present, it must be
  /// the same as the metric kind of the associated metric. If the associated
  /// metric's descriptor must be auto-created, then this field specifies the
  /// metric kind of the new descriptor and must be either `GAUGE` (the default)
  /// or `CUMULATIVE`.
  public var metricKind: Google_Api_MetricDescriptor.MetricKind = .unspecified

  /// The value type of the time series. When listing time series, this value
  /// type might be different from the value type of the associated metric if
  /// this time series is an alignment or reduction of other time series.
  ///
  /// When creating a time series, this field is optional. If present, it must be
  /// the same as the type of the data in the `points` field.
  public var valueType: Google_Api_MetricDescriptor.ValueType = .unspecified

  /// The data points of this time series. When listing time series, points are
  /// returned in reverse time order.
  ///
  /// When creating a time series, this field must contain exactly one point and
  /// the point's type must be the same as the value type of the associated
  /// metric. If the associated metric's descriptor must be auto-created, then
  /// the value type of the descriptor is determined by the point's type, which
  /// must be `BOOL`, `INT64`, `DOUBLE`, or `DISTRIBUTION`.
  public var points: [Google_Monitoring_V3_Point] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _metric: Google_Api_Metric? = nil
  fileprivate var _resource: Google_Api_MonitoredResource? = nil
  fileprivate var _metadata: Google_Api_MonitoredResourceMetadata? = nil
}

/// A descriptor for the labels and points in a timeseries.
public struct Google_Monitoring_V3_TimeSeriesDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Descriptors for the labels.
  public var labelDescriptors: [Google_Api_LabelDescriptor] = []

  /// Descriptors for the point data value columns.
  public var pointDescriptors: [Google_Monitoring_V3_TimeSeriesDescriptor.ValueDescriptor] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A descriptor for the value columns in a data point.
  public struct ValueDescriptor {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The value key.
    public var key: String = String()

    /// The value type.
    public var valueType: Google_Api_MetricDescriptor.ValueType = .unspecified

    /// The value stream kind.
    public var metricKind: Google_Api_MetricDescriptor.MetricKind = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Represents the values of a time series associated with a
/// TimeSeriesDescriptor.
public struct Google_Monitoring_V3_TimeSeriesData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values of the labels in the time series identifier, given in the same
  /// order as the `label_descriptors` field of the TimeSeriesDescriptor
  /// associated with this object. Each value must have a value of the type
  /// given in the corresponding entry of `label_descriptors`.
  public var labelValues: [Google_Monitoring_V3_LabelValue] = []

  /// The points in the time series.
  public var pointData: [Google_Monitoring_V3_TimeSeriesData.PointData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A point's value columns and time interval. Each point has one or more
  /// point values corresponding to the entries in `point_descriptors` field in
  /// the TimeSeriesDescriptor associated with this object.
  public struct PointData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The values that make up the point.
    public var values: [Google_Monitoring_V3_TypedValue] = []

    /// The time interval associated with the point.
    public var timeInterval: Google_Monitoring_V3_TimeInterval {
      get {return _timeInterval ?? Google_Monitoring_V3_TimeInterval()}
      set {_timeInterval = newValue}
    }
    /// Returns true if `timeInterval` has been explicitly set.
    public var hasTimeInterval: Bool {return self._timeInterval != nil}
    /// Clears the value of `timeInterval`. Subsequent reads from it will return its default value.
    public mutating func clearTimeInterval() {self._timeInterval = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timeInterval: Google_Monitoring_V3_TimeInterval? = nil
  }

  public init() {}
}

/// A label value.
public struct Google_Monitoring_V3_LabelValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The label value can be a bool, int64, or string.
  public var value: Google_Monitoring_V3_LabelValue.OneOf_Value? = nil

  /// A bool label value.
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  /// An int64 label value.
  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = value {return v}
      return 0
    }
    set {value = .int64Value(newValue)}
  }

  /// A string label value.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The label value can be a bool, int64, or string.
  public enum OneOf_Value: Equatable {
    /// A bool label value.
    case boolValue(Bool)
    /// An int64 label value.
    case int64Value(Int64)
    /// A string label value.
    case stringValue(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_LabelValue.OneOf_Value, rhs: Google_Monitoring_V3_LabelValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64Value, .int64Value): return {
        guard case .int64Value(let l) = lhs, case .int64Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// An error associated with a query in the time series query language format.
public struct Google_Monitoring_V3_QueryError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The location of the time series query language text that this error applies
  /// to.
  public var locator: Google_Monitoring_V3_TextLocator {
    get {return _locator ?? Google_Monitoring_V3_TextLocator()}
    set {_locator = newValue}
  }
  /// Returns true if `locator` has been explicitly set.
  public var hasLocator: Bool {return self._locator != nil}
  /// Clears the value of `locator`. Subsequent reads from it will return its default value.
  public mutating func clearLocator() {self._locator = nil}

  /// The error message.
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _locator: Google_Monitoring_V3_TextLocator? = nil
}

/// A locator for text. Indicates a particular part of the text of a request or
/// of an object referenced in the request.
///
/// For example, suppose the request field `text` contains:
///
///   text: "The quick brown fox jumps over the lazy dog."
///
/// Then the locator:
///
///   source: "text"
///   start_position {
///     line: 1
///     column: 17
///   }
///   end_position {
///     line: 1
///     column: 19
///   }
///
/// refers to the part of the text: "fox".
public struct Google_Monitoring_V3_TextLocator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The source of the text. The source may be a field in the request, in which
  /// case its format is the format of the
  /// google.rpc.BadRequest.FieldViolation.field field in
  /// https://cloud.google.com/apis/design/errors#error_details. It may also be
  /// be a source other than the request field (e.g. a macro definition
  /// referenced in the text of the query), in which case this is the name of
  /// the source (e.g. the macro name).
  public var source: String {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  /// The position of the first byte within the text.
  public var startPosition: Google_Monitoring_V3_TextLocator.Position {
    get {return _storage._startPosition ?? Google_Monitoring_V3_TextLocator.Position()}
    set {_uniqueStorage()._startPosition = newValue}
  }
  /// Returns true if `startPosition` has been explicitly set.
  public var hasStartPosition: Bool {return _storage._startPosition != nil}
  /// Clears the value of `startPosition`. Subsequent reads from it will return its default value.
  public mutating func clearStartPosition() {_uniqueStorage()._startPosition = nil}

  /// The position of the last byte within the text.
  public var endPosition: Google_Monitoring_V3_TextLocator.Position {
    get {return _storage._endPosition ?? Google_Monitoring_V3_TextLocator.Position()}
    set {_uniqueStorage()._endPosition = newValue}
  }
  /// Returns true if `endPosition` has been explicitly set.
  public var hasEndPosition: Bool {return _storage._endPosition != nil}
  /// Clears the value of `endPosition`. Subsequent reads from it will return its default value.
  public mutating func clearEndPosition() {_uniqueStorage()._endPosition = nil}

  /// If `source`, `start_position`, and `end_position` describe a call on
  /// some object (e.g. a macro in the time series query language text) and a
  /// location is to be designated in that object's text, `nested_locator`
  /// identifies the location within that object.
  public var nestedLocator: Google_Monitoring_V3_TextLocator {
    get {return _storage._nestedLocator ?? Google_Monitoring_V3_TextLocator()}
    set {_uniqueStorage()._nestedLocator = newValue}
  }
  /// Returns true if `nestedLocator` has been explicitly set.
  public var hasNestedLocator: Bool {return _storage._nestedLocator != nil}
  /// Clears the value of `nestedLocator`. Subsequent reads from it will return its default value.
  public mutating func clearNestedLocator() {_uniqueStorage()._nestedLocator = nil}

  /// When `nested_locator` is set, this field gives the reason for the nesting.
  /// Usually, the reason is a macro invocation. In that case, the macro name
  /// (including the leading '@') signals the location of the macro call
  /// in the text and a macro argument name (including the leading '$') signals
  /// the location of the macro argument inside the macro body that got
  /// substituted away.
  public var nestingReason: String {
    get {return _storage._nestingReason}
    set {_uniqueStorage()._nestingReason = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The position of a byte within the text.
  public struct Position {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The line, starting with 1, where the byte is positioned.
    public var line: Int32 = 0

    /// The column within the line, starting with 1, where the byte is
    /// positioned. This is a byte index even though the text is UTF-8.
    public var column: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_Point: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Point"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interval"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._interval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._interval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._value {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Point, rhs: Google_Monitoring_V3_Point) -> Bool {
    if lhs._interval != rhs._interval {return false}
    if lhs._value != rhs._value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeSeries: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeries"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "metric"),
    2: .same(proto: "resource"),
    7: .same(proto: "metadata"),
    3: .standard(proto: "metric_kind"),
    4: .standard(proto: "value_type"),
    5: .same(proto: "points"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metric) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.metricKind) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.valueType) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._metric {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.metricKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.metricKind, fieldNumber: 3)
    }
    if self.valueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 4)
    }
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 5)
    }
    if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeSeries, rhs: Google_Monitoring_V3_TimeSeries) -> Bool {
    if lhs._metric != rhs._metric {return false}
    if lhs._resource != rhs._resource {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.metricKind != rhs.metricKind {return false}
    if lhs.valueType != rhs.valueType {return false}
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeSeriesDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeriesDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "label_descriptors"),
    5: .standard(proto: "point_descriptors"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labelDescriptors) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.pointDescriptors) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labelDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelDescriptors, fieldNumber: 1)
    }
    if !self.pointDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointDescriptors, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeSeriesDescriptor, rhs: Google_Monitoring_V3_TimeSeriesDescriptor) -> Bool {
    if lhs.labelDescriptors != rhs.labelDescriptors {return false}
    if lhs.pointDescriptors != rhs.pointDescriptors {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeSeriesDescriptor.ValueDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_TimeSeriesDescriptor.protoMessageName + ".ValueDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "value_type"),
    3: .standard(proto: "metric_kind"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.valueType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.metricKind) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.valueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.valueType, fieldNumber: 2)
    }
    if self.metricKind != .unspecified {
      try visitor.visitSingularEnumField(value: self.metricKind, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeSeriesDescriptor.ValueDescriptor, rhs: Google_Monitoring_V3_TimeSeriesDescriptor.ValueDescriptor) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.valueType != rhs.valueType {return false}
    if lhs.metricKind != rhs.metricKind {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeSeriesData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeriesData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "label_values"),
    2: .standard(proto: "point_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labelValues) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pointData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labelValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labelValues, fieldNumber: 1)
    }
    if !self.pointData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pointData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeSeriesData, rhs: Google_Monitoring_V3_TimeSeriesData) -> Bool {
    if lhs.labelValues != rhs.labelValues {return false}
    if lhs.pointData != rhs.pointData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeSeriesData.PointData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_TimeSeriesData.protoMessageName + ".PointData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
    2: .standard(proto: "time_interval"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timeInterval) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    if let v = self._timeInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeSeriesData.PointData, rhs: Google_Monitoring_V3_TimeSeriesData.PointData) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs._timeInterval != rhs._timeInterval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_LabelValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bool_value"),
    2: .standard(proto: "int64_value"),
    3: .standard(proto: "string_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .boolValue(v)}
      }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .int64Value(v)}
      }()
      case 3: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .stringValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .int64Value?: try {
      guard case .int64Value(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_LabelValue, rhs: Google_Monitoring_V3_LabelValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_QueryError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "locator"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._locator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._locator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_QueryError, rhs: Google_Monitoring_V3_QueryError) -> Bool {
    if lhs._locator != rhs._locator {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TextLocator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TextLocator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "start_position"),
    3: .standard(proto: "end_position"),
    4: .standard(proto: "nested_locator"),
    5: .standard(proto: "nesting_reason"),
  ]

  fileprivate class _StorageClass {
    var _source: String = String()
    var _startPosition: Google_Monitoring_V3_TextLocator.Position? = nil
    var _endPosition: Google_Monitoring_V3_TextLocator.Position? = nil
    var _nestedLocator: Google_Monitoring_V3_TextLocator? = nil
    var _nestingReason: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _source = source._source
      _startPosition = source._startPosition
      _endPosition = source._endPosition
      _nestedLocator = source._nestedLocator
      _nestingReason = source._nestingReason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._startPosition) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._endPosition) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nestedLocator) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._nestingReason) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._source.isEmpty {
        try visitor.visitSingularStringField(value: _storage._source, fieldNumber: 1)
      }
      if let v = _storage._startPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._endPosition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._nestedLocator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._nestingReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nestingReason, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TextLocator, rhs: Google_Monitoring_V3_TextLocator) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._source != rhs_storage._source {return false}
        if _storage._startPosition != rhs_storage._startPosition {return false}
        if _storage._endPosition != rhs_storage._endPosition {return false}
        if _storage._nestedLocator != rhs_storage._nestedLocator {return false}
        if _storage._nestingReason != rhs_storage._nestingReason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TextLocator.Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_TextLocator.protoMessageName + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "line"),
    2: .same(proto: "column"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.line) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.column) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.line != 0 {
      try visitor.visitSingularInt32Field(value: self.line, fieldNumber: 1)
    }
    if self.column != 0 {
      try visitor.visitSingularInt32Field(value: self.column, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TextLocator.Position, rhs: Google_Monitoring_V3_TextLocator.Position) -> Bool {
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

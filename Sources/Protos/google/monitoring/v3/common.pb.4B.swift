// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies an ordering relationship on two arguments, called `left` and
/// `right`.
public enum Google_Monitoring_V3_ComparisonType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No ordering relationship is specified.
  case comparisonUnspecified // = 0

  /// True if the left argument is greater than the right argument.
  case comparisonGt // = 1

  /// True if the left argument is greater than or equal to the right argument.
  case comparisonGe // = 2

  /// True if the left argument is less than the right argument.
  case comparisonLt // = 3

  /// True if the left argument is less than or equal to the right argument.
  case comparisonLe // = 4

  /// True if the left argument is equal to the right argument.
  case comparisonEq // = 5

  /// True if the left argument is not equal to the right argument.
  case comparisonNe // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .comparisonUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .comparisonUnspecified
    case 1: self = .comparisonGt
    case 2: self = .comparisonGe
    case 3: self = .comparisonLt
    case 4: self = .comparisonLe
    case 5: self = .comparisonEq
    case 6: self = .comparisonNe
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .comparisonUnspecified: return 0
    case .comparisonGt: return 1
    case .comparisonGe: return 2
    case .comparisonLt: return 3
    case .comparisonLe: return 4
    case .comparisonEq: return 5
    case .comparisonNe: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Monitoring_V3_ComparisonType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_ComparisonType] = [
    .comparisonUnspecified,
    .comparisonGt,
    .comparisonGe,
    .comparisonLt,
    .comparisonLe,
    .comparisonEq,
    .comparisonNe,
  ]
}

#endif  // swift(>=4.2)

/// The tier of service for a Workspace. Please see the
/// [service tiers
/// documentation](https://cloud.google.com/monitoring/workspaces/tiers) for more
/// details.
public enum Google_Monitoring_V3_ServiceTier: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// An invalid sentinel value, used to indicate that a tier has not
  /// been provided explicitly.
  case unspecified // = 0

  /// The Stackdriver Basic tier, a free tier of service that provides basic
  /// features, a moderate allotment of logs, and access to built-in metrics.
  /// A number of features are not available in this tier. For more details,
  /// see [the service tiers
  /// documentation](https://cloud.google.com/monitoring/workspaces/tiers).
  case basic // = 1

  /// The Stackdriver Premium tier, a higher, more expensive tier of service
  /// that provides access to all Stackdriver features, lets you use Stackdriver
  /// with AWS accounts, and has a larger allotments for logs and metrics. For
  /// more details, see [the service tiers
  /// documentation](https://cloud.google.com/monitoring/workspaces/tiers).
  case premium // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .basic
    case 2: self = .premium
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .basic: return 1
    case .premium: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Monitoring_V3_ServiceTier: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_ServiceTier] = [
    .unspecified,
    .basic,
    .premium,
  ]
}

#endif  // swift(>=4.2)

/// A single strongly-typed value.
public struct Google_Monitoring_V3_TypedValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The typed value field.
  public var value: Google_Monitoring_V3_TypedValue.OneOf_Value? = nil

  /// A Boolean value: `true` or `false`.
  public var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  /// A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.
  public var int64Value: Int64 {
    get {
      if case .int64Value(let v)? = value {return v}
      return 0
    }
    set {value = .int64Value(newValue)}
  }

  /// A 64-bit double-precision floating-point number. Its magnitude
  /// is approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16
  /// significant digits of precision.
  public var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = value {return v}
      return 0
    }
    set {value = .doubleValue(newValue)}
  }

  /// A variable-length string value.
  public var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  /// A distribution value.
  public var distributionValue: Google_Api_Distribution {
    get {
      if case .distributionValue(let v)? = value {return v}
      return Google_Api_Distribution()
    }
    set {value = .distributionValue(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The typed value field.
  public enum OneOf_Value: Equatable {
    /// A Boolean value: `true` or `false`.
    case boolValue(Bool)
    /// A 64-bit integer. Its range is approximately &plusmn;9.2x10<sup>18</sup>.
    case int64Value(Int64)
    /// A 64-bit double-precision floating-point number. Its magnitude
    /// is approximately &plusmn;10<sup>&plusmn;300</sup> and it has 16
    /// significant digits of precision.
    case doubleValue(Double)
    /// A variable-length string value.
    case stringValue(String)
    /// A distribution value.
    case distributionValue(Google_Api_Distribution)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_TypedValue.OneOf_Value, rhs: Google_Monitoring_V3_TypedValue.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.boolValue, .boolValue): return {
        guard case .boolValue(let l) = lhs, case .boolValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.int64Value, .int64Value): return {
        guard case .int64Value(let l) = lhs, case .int64Value(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distributionValue, .distributionValue): return {
        guard case .distributionValue(let l) = lhs, case .distributionValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A closed time interval. It extends from the start time to the end time, and
/// includes both: `[startTime, endTime]`. Valid time intervals depend on the
/// [`MetricKind`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors#MetricKind)
/// of the metric value. In no case can the end time be earlier than the start
/// time.
///
/// * For a `GAUGE` metric, the `startTime` value is technically optional; if
///   no value is specified, the start time defaults to the value of the
///   end time, and the interval represents a single point in time. If both
///   start and end times are specified, they must be identical. Such an
///   interval is valid only for `GAUGE` metrics, which are point-in-time
///   measurements.
///
/// * For `DELTA` and `CUMULATIVE` metrics, the start time must be earlier
///   than the end time.
///
/// * In all cases, the start time of the next interval must be
///   at least a millisecond after the end time of the previous interval.
///   Because the interval is closed, if the start time of a new interval
///   is the same as the end time of the previous interval, data written
///   at the new start time could overwrite data written at the previous
///   end time.
public struct Google_Monitoring_V3_TimeInterval {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The end of the time interval.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Optional. The beginning of the time interval.  The default value
  /// for the start time is the end time. The start time must not be
  /// later than the end time.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Describes how to combine multiple time series to provide a different view of
/// the data.  Aggregation of time series is done in two steps. First, each time
/// series in the set is _aligned_ to the same time interval boundaries, then the
/// set of time series is optionally _reduced_ in number.
///
/// Alignment consists of applying the `per_series_aligner` operation
/// to each time series after its data has been divided into regular
/// `alignment_period` time intervals. This process takes _all_ of the data
/// points in an alignment period, applies a mathematical transformation such as
/// averaging, minimum, maximum, delta, etc., and converts them into a single
/// data point per period.
///
/// Reduction is when the aligned and transformed time series can optionally be
/// combined, reducing the number of time series through similar mathematical
/// transformations. Reduction involves applying a `cross_series_reducer` to
/// all the time series, optionally sorting the time series into subsets with
/// `group_by_fields`, and applying the reducer to each subset.
///
/// The raw time series data can contain a huge amount of information from
/// multiple sources. Alignment and reduction transforms this mass of data into
/// a more manageable and representative collection of data, for example "the
/// 95% latency across the average of all tasks in a cluster". This
/// representative data can be more easily graphed and comprehended, and the
/// individual time series data is still available for later drilldown. For more
/// details, see [Filtering and
/// aggregation](https://cloud.google.com/monitoring/api/v3/aggregation).
public struct Google_Monitoring_V3_Aggregation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `alignment_period` specifies a time interval, in seconds, that is used
  /// to divide the data in all the
  /// [time series][google.monitoring.v3.TimeSeries] into consistent blocks of
  /// time. This will be done before the per-series aligner can be applied to
  /// the data.
  ///
  /// The value must be at least 60 seconds. If a per-series aligner other than
  /// `ALIGN_NONE` is specified, this field is required or an error is returned.
  /// If no per-series aligner is specified, or the aligner `ALIGN_NONE` is
  /// specified, then this field is ignored.
  public var alignmentPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _alignmentPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_alignmentPeriod = newValue}
  }
  /// Returns true if `alignmentPeriod` has been explicitly set.
  public var hasAlignmentPeriod: Bool {return self._alignmentPeriod != nil}
  /// Clears the value of `alignmentPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearAlignmentPeriod() {self._alignmentPeriod = nil}

  /// An `Aligner` describes how to bring the data points in a single
  /// time series into temporal alignment. Except for `ALIGN_NONE`, all
  /// alignments cause all the data points in an `alignment_period` to be
  /// mathematically grouped together, resulting in a single data point for
  /// each `alignment_period` with end timestamp at the end of the period.
  ///
  /// Not all alignment operations may be applied to all time series. The valid
  /// choices depend on the `metric_kind` and `value_type` of the original time
  /// series. Alignment can change the `metric_kind` or the `value_type` of
  /// the time series.
  ///
  /// Time series data must be aligned in order to perform cross-time
  /// series reduction. If `cross_series_reducer` is specified, then
  /// `per_series_aligner` must be specified and not equal to `ALIGN_NONE`
  /// and `alignment_period` must be specified; otherwise, an error is
  /// returned.
  public var perSeriesAligner: Google_Monitoring_V3_Aggregation.Aligner = .alignNone

  /// The reduction operation to be used to combine time series into a single
  /// time series, where the value of each data point in the resulting series is
  /// a function of all the already aligned values in the input time series.
  ///
  /// Not all reducer operations can be applied to all time series. The valid
  /// choices depend on the `metric_kind` and the `value_type` of the original
  /// time series. Reduction can yield a time series with a different
  /// `metric_kind` or `value_type` than the input time series.
  ///
  /// Time series data must first be aligned (see `per_series_aligner`) in order
  /// to perform cross-time series reduction. If `cross_series_reducer` is
  /// specified, then `per_series_aligner` must be specified, and must not be
  /// `ALIGN_NONE`. An `alignment_period` must also be specified; otherwise, an
  /// error is returned.
  public var crossSeriesReducer: Google_Monitoring_V3_Aggregation.Reducer = .reduceNone

  /// The set of fields to preserve when `cross_series_reducer` is
  /// specified. The `group_by_fields` determine how the time series are
  /// partitioned into subsets prior to applying the aggregation
  /// operation. Each subset contains time series that have the same
  /// value for each of the grouping fields. Each individual time
  /// series is a member of exactly one subset. The
  /// `cross_series_reducer` is applied to each subset of time series.
  /// It is not possible to reduce across different resource types, so
  /// this field implicitly contains `resource.type`.  Fields not
  /// specified in `group_by_fields` are aggregated away.  If
  /// `group_by_fields` is not specified and all the time series have
  /// the same resource type, then the time series are aggregated into
  /// a single output time series. If `cross_series_reducer` is not
  /// defined, this field is ignored.
  public var groupByFields: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The `Aligner` specifies the operation that will be applied to the data
  /// points in each alignment period in a time series. Except for
  /// `ALIGN_NONE`, which specifies that no operation be applied, each alignment
  /// operation replaces the set of data values in each alignment period with
  /// a single value: the result of applying the operation to the data values.
  /// An aligned time series has a single data value at the end of each
  /// `alignment_period`.
  ///
  /// An alignment operation can change the data type of the values, too. For
  /// example, if you apply a counting operation to boolean values, the data
  /// `value_type` in the original time series is `BOOLEAN`, but the `value_type`
  /// in the aligned result is `INT64`.
  public enum Aligner: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No alignment. Raw data is returned. Not valid if cross-series reduction
    /// is requested. The `value_type` of the result is the same as the
    /// `value_type` of the input.
    case alignNone // = 0

    /// Align and convert to
    /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA].
    /// The output is `delta = y1 - y0`.
    ///
    /// This alignment is valid for
    /// [CUMULATIVE][google.api.MetricDescriptor.MetricKind.CUMULATIVE] and
    /// `DELTA` metrics. If the selected alignment period results in periods
    /// with no data, then the aligned value for such a period is created by
    /// interpolation. The `value_type`  of the aligned result is the same as
    /// the `value_type` of the input.
    case alignDelta // = 1

    /// Align and convert to a rate. The result is computed as
    /// `rate = (y1 - y0)/(t1 - t0)`, or "delta over time".
    /// Think of this aligner as providing the slope of the line that passes
    /// through the value at the start and at the end of the `alignment_period`.
    ///
    /// This aligner is valid for `CUMULATIVE`
    /// and `DELTA` metrics with numeric values. If the selected alignment
    /// period results in periods with no data, then the aligned value for
    /// such a period is created by interpolation. The output is a `GAUGE`
    /// metric with `value_type` `DOUBLE`.
    ///
    /// If, by "rate", you mean "percentage change", see the
    /// `ALIGN_PERCENT_CHANGE` aligner instead.
    case alignRate // = 2

    /// Align by interpolating between adjacent points around the alignment
    /// period boundary. This aligner is valid for `GAUGE` metrics with
    /// numeric values. The `value_type` of the aligned result is the same as the
    /// `value_type` of the input.
    case alignInterpolate // = 3

    /// Align by moving the most recent data point before the end of the
    /// alignment period to the boundary at the end of the alignment
    /// period. This aligner is valid for `GAUGE` metrics. The `value_type` of
    /// the aligned result is the same as the `value_type` of the input.
    case alignNextOlder // = 4

    /// Align the time series by returning the minimum value in each alignment
    /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
    /// numeric values. The `value_type` of the aligned result is the same as
    /// the `value_type` of the input.
    case alignMin // = 10

    /// Align the time series by returning the maximum value in each alignment
    /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
    /// numeric values. The `value_type` of the aligned result is the same as
    /// the `value_type` of the input.
    case alignMax // = 11

    /// Align the time series by returning the mean value in each alignment
    /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
    /// numeric values. The `value_type` of the aligned result is `DOUBLE`.
    case alignMean // = 12

    /// Align the time series by returning the number of values in each alignment
    /// period. This aligner is valid for `GAUGE` and `DELTA` metrics with
    /// numeric or Boolean values. The `value_type` of the aligned result is
    /// `INT64`.
    case alignCount // = 13

    /// Align the time series by returning the sum of the values in each
    /// alignment period. This aligner is valid for `GAUGE` and `DELTA`
    /// metrics with numeric and distribution values. The `value_type` of the
    /// aligned result is the same as the `value_type` of the input.
    case alignSum // = 14

    /// Align the time series by returning the standard deviation of the values
    /// in each alignment period. This aligner is valid for `GAUGE` and
    /// `DELTA` metrics with numeric values. The `value_type` of the output is
    /// `DOUBLE`.
    case alignStddev // = 15

    /// Align the time series by returning the number of `True` values in
    /// each alignment period. This aligner is valid for `GAUGE` metrics with
    /// Boolean values. The `value_type` of the output is `INT64`.
    case alignCountTrue // = 16

    /// Align the time series by returning the number of `False` values in
    /// each alignment period. This aligner is valid for `GAUGE` metrics with
    /// Boolean values. The `value_type` of the output is `INT64`.
    case alignCountFalse // = 24

    /// Align the time series by returning the ratio of the number of `True`
    /// values to the total number of values in each alignment period. This
    /// aligner is valid for `GAUGE` metrics with Boolean values. The output
    /// value is in the range [0.0, 1.0] and has `value_type` `DOUBLE`.
    case alignFractionTrue // = 17

    /// Align the time series by using [percentile
    /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
    /// data point in each alignment period is the 99th percentile of all data
    /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
    /// metrics with distribution values. The output is a `GAUGE` metric with
    /// `value_type` `DOUBLE`.
    case alignPercentile99 // = 18

    /// Align the time series by using [percentile
    /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
    /// data point in each alignment period is the 95th percentile of all data
    /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
    /// metrics with distribution values. The output is a `GAUGE` metric with
    /// `value_type` `DOUBLE`.
    case alignPercentile95 // = 19

    /// Align the time series by using [percentile
    /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
    /// data point in each alignment period is the 50th percentile of all data
    /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
    /// metrics with distribution values. The output is a `GAUGE` metric with
    /// `value_type` `DOUBLE`.
    case alignPercentile50 // = 20

    /// Align the time series by using [percentile
    /// aggregation](https://en.wikipedia.org/wiki/Percentile). The resulting
    /// data point in each alignment period is the 5th percentile of all data
    /// points in the period. This aligner is valid for `GAUGE` and `DELTA`
    /// metrics with distribution values. The output is a `GAUGE` metric with
    /// `value_type` `DOUBLE`.
    case alignPercentile05 // = 21

    /// Align and convert to a percentage change. This aligner is valid for
    /// `GAUGE` and `DELTA` metrics with numeric values. This alignment returns
    /// `((current - previous)/previous) * 100`, where the value of `previous` is
    /// determined based on the `alignment_period`.
    ///
    /// If the values of `current` and `previous` are both 0, then the returned
    /// value is 0. If only `previous` is 0, the returned value is infinity.
    ///
    /// A 10-minute moving mean is computed at each point of the alignment period
    /// prior to the above calculation to smooth the metric and prevent false
    /// positives from very short-lived spikes. The moving mean is only
    /// applicable for data whose values are `>= 0`. Any values `< 0` are
    /// treated as a missing datapoint, and are ignored. While `DELTA`
    /// metrics are accepted by this alignment, special care should be taken that
    /// the values for the metric will always be positive. The output is a
    /// `GAUGE` metric with `value_type` `DOUBLE`.
    case alignPercentChange // = 23
    case UNRECOGNIZED(Int)

    public init() {
      self = .alignNone
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .alignNone
      case 1: self = .alignDelta
      case 2: self = .alignRate
      case 3: self = .alignInterpolate
      case 4: self = .alignNextOlder
      case 10: self = .alignMin
      case 11: self = .alignMax
      case 12: self = .alignMean
      case 13: self = .alignCount
      case 14: self = .alignSum
      case 15: self = .alignStddev
      case 16: self = .alignCountTrue
      case 17: self = .alignFractionTrue
      case 18: self = .alignPercentile99
      case 19: self = .alignPercentile95
      case 20: self = .alignPercentile50
      case 21: self = .alignPercentile05
      case 23: self = .alignPercentChange
      case 24: self = .alignCountFalse
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .alignNone: return 0
      case .alignDelta: return 1
      case .alignRate: return 2
      case .alignInterpolate: return 3
      case .alignNextOlder: return 4
      case .alignMin: return 10
      case .alignMax: return 11
      case .alignMean: return 12
      case .alignCount: return 13
      case .alignSum: return 14
      case .alignStddev: return 15
      case .alignCountTrue: return 16
      case .alignFractionTrue: return 17
      case .alignPercentile99: return 18
      case .alignPercentile95: return 19
      case .alignPercentile50: return 20
      case .alignPercentile05: return 21
      case .alignPercentChange: return 23
      case .alignCountFalse: return 24
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// A Reducer operation describes how to aggregate data points from multiple
  /// time series into a single time series, where the value of each data point
  /// in the resulting series is a function of all the already aligned values in
  /// the input time series.
  public enum Reducer: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No cross-time series reduction. The output of the `Aligner` is
    /// returned.
    case reduceNone // = 0

    /// Reduce by computing the mean value across time series for each
    /// alignment period. This reducer is valid for
    /// [DELTA][google.api.MetricDescriptor.MetricKind.DELTA] and
    /// [GAUGE][google.api.MetricDescriptor.MetricKind.GAUGE] metrics with
    /// numeric or distribution values. The `value_type` of the output is
    /// [DOUBLE][google.api.MetricDescriptor.ValueType.DOUBLE].
    case reduceMean // = 1

    /// Reduce by computing the minimum value across time series for each
    /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
    /// with numeric values. The `value_type` of the output is the same as the
    /// `value_type` of the input.
    case reduceMin // = 2

    /// Reduce by computing the maximum value across time series for each
    /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
    /// with numeric values. The `value_type` of the output is the same as the
    /// `value_type` of the input.
    case reduceMax // = 3

    /// Reduce by computing the sum across time series for each
    /// alignment period. This reducer is valid for `DELTA` and `GAUGE` metrics
    /// with numeric and distribution values. The `value_type` of the output is
    /// the same as the `value_type` of the input.
    case reduceSum // = 4

    /// Reduce by computing the standard deviation across time series
    /// for each alignment period. This reducer is valid for `DELTA` and
    /// `GAUGE` metrics with numeric or distribution values. The `value_type`
    /// of the output is `DOUBLE`.
    case reduceStddev // = 5

    /// Reduce by computing the number of data points across time series
    /// for each alignment period. This reducer is valid for `DELTA` and
    /// `GAUGE` metrics of numeric, Boolean, distribution, and string
    /// `value_type`. The `value_type` of the output is `INT64`.
    case reduceCount // = 6

    /// Reduce by computing the number of `True`-valued data points across time
    /// series for each alignment period. This reducer is valid for `DELTA` and
    /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
    /// is `INT64`.
    case reduceCountTrue // = 7

    /// Reduce by computing the number of `False`-valued data points across time
    /// series for each alignment period. This reducer is valid for `DELTA` and
    /// `GAUGE` metrics of Boolean `value_type`. The `value_type` of the output
    /// is `INT64`.
    case reduceCountFalse // = 15

    /// Reduce by computing the ratio of the number of `True`-valued data points
    /// to the total number of data points for each alignment period. This
    /// reducer is valid for `DELTA` and `GAUGE` metrics of Boolean `value_type`.
    /// The output value is in the range [0.0, 1.0] and has `value_type`
    /// `DOUBLE`.
    case reduceFractionTrue // = 8

    /// Reduce by computing the [99th
    /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
    /// across time series for each alignment period. This reducer is valid for
    /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
    /// of the output is `DOUBLE`.
    case reducePercentile99 // = 9

    /// Reduce by computing the [95th
    /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
    /// across time series for each alignment period. This reducer is valid for
    /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
    /// of the output is `DOUBLE`.
    case reducePercentile95 // = 10

    /// Reduce by computing the [50th
    /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
    /// across time series for each alignment period. This reducer is valid for
    /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
    /// of the output is `DOUBLE`.
    case reducePercentile50 // = 11

    /// Reduce by computing the [5th
    /// percentile](https://en.wikipedia.org/wiki/Percentile) of data points
    /// across time series for each alignment period. This reducer is valid for
    /// `GAUGE` and `DELTA` metrics of numeric and distribution type. The value
    /// of the output is `DOUBLE`.
    case reducePercentile05 // = 12
    case UNRECOGNIZED(Int)

    public init() {
      self = .reduceNone
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reduceNone
      case 1: self = .reduceMean
      case 2: self = .reduceMin
      case 3: self = .reduceMax
      case 4: self = .reduceSum
      case 5: self = .reduceStddev
      case 6: self = .reduceCount
      case 7: self = .reduceCountTrue
      case 8: self = .reduceFractionTrue
      case 9: self = .reducePercentile99
      case 10: self = .reducePercentile95
      case 11: self = .reducePercentile50
      case 12: self = .reducePercentile05
      case 15: self = .reduceCountFalse
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .reduceNone: return 0
      case .reduceMean: return 1
      case .reduceMin: return 2
      case .reduceMax: return 3
      case .reduceSum: return 4
      case .reduceStddev: return 5
      case .reduceCount: return 6
      case .reduceCountTrue: return 7
      case .reduceFractionTrue: return 8
      case .reducePercentile99: return 9
      case .reducePercentile95: return 10
      case .reducePercentile50: return 11
      case .reducePercentile05: return 12
      case .reduceCountFalse: return 15
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _alignmentPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=4.2)

extension Google_Monitoring_V3_Aggregation.Aligner: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_Aggregation.Aligner] = [
    .alignNone,
    .alignDelta,
    .alignRate,
    .alignInterpolate,
    .alignNextOlder,
    .alignMin,
    .alignMax,
    .alignMean,
    .alignCount,
    .alignSum,
    .alignStddev,
    .alignCountTrue,
    .alignCountFalse,
    .alignFractionTrue,
    .alignPercentile99,
    .alignPercentile95,
    .alignPercentile50,
    .alignPercentile05,
    .alignPercentChange,
  ]
}

extension Google_Monitoring_V3_Aggregation.Reducer: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_Aggregation.Reducer] = [
    .reduceNone,
    .reduceMean,
    .reduceMin,
    .reduceMax,
    .reduceSum,
    .reduceStddev,
    .reduceCount,
    .reduceCountTrue,
    .reduceCountFalse,
    .reduceFractionTrue,
    .reducePercentile99,
    .reducePercentile95,
    .reducePercentile50,
    .reducePercentile05,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_ComparisonType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMPARISON_UNSPECIFIED"),
    1: .same(proto: "COMPARISON_GT"),
    2: .same(proto: "COMPARISON_GE"),
    3: .same(proto: "COMPARISON_LT"),
    4: .same(proto: "COMPARISON_LE"),
    5: .same(proto: "COMPARISON_EQ"),
    6: .same(proto: "COMPARISON_NE"),
  ]
}

extension Google_Monitoring_V3_ServiceTier: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SERVICE_TIER_UNSPECIFIED"),
    1: .same(proto: "SERVICE_TIER_BASIC"),
    2: .same(proto: "SERVICE_TIER_PREMIUM"),
  ]
}

extension Google_Monitoring_V3_TypedValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypedValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bool_value"),
    2: .standard(proto: "int64_value"),
    3: .standard(proto: "double_value"),
    4: .standard(proto: "string_value"),
    5: .standard(proto: "distribution_value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.value = .boolValue(v)}
      }()
      case 2: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.value = .int64Value(v)}
      }()
      case 3: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {self.value = .doubleValue(v)}
      }()
      case 4: try {
        if self.value != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.value = .stringValue(v)}
      }()
      case 5: try {
        var v: Google_Api_Distribution?
        if let current = self.value {
          try decoder.handleConflictingOneOf()
          if case .distributionValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.value = .distributionValue(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.value {
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .int64Value?: try {
      guard case .int64Value(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .distributionValue?: try {
      guard case .distributionValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TypedValue, rhs: Google_Monitoring_V3_TypedValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeInterval: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeInterval"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "end_time"),
    1: .standard(proto: "start_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeInterval, rhs: Google_Monitoring_V3_TimeInterval) -> Bool {
    if lhs._endTime != rhs._endTime {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Aggregation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Aggregation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alignment_period"),
    2: .standard(proto: "per_series_aligner"),
    4: .standard(proto: "cross_series_reducer"),
    5: .standard(proto: "group_by_fields"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._alignmentPeriod) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.perSeriesAligner) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.crossSeriesReducer) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.groupByFields) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._alignmentPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.perSeriesAligner != .alignNone {
      try visitor.visitSingularEnumField(value: self.perSeriesAligner, fieldNumber: 2)
    }
    if self.crossSeriesReducer != .reduceNone {
      try visitor.visitSingularEnumField(value: self.crossSeriesReducer, fieldNumber: 4)
    }
    if !self.groupByFields.isEmpty {
      try visitor.visitRepeatedStringField(value: self.groupByFields, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Aggregation, rhs: Google_Monitoring_V3_Aggregation) -> Bool {
    if lhs._alignmentPeriod != rhs._alignmentPeriod {return false}
    if lhs.perSeriesAligner != rhs.perSeriesAligner {return false}
    if lhs.crossSeriesReducer != rhs.crossSeriesReducer {return false}
    if lhs.groupByFields != rhs.groupByFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Aggregation.Aligner: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALIGN_NONE"),
    1: .same(proto: "ALIGN_DELTA"),
    2: .same(proto: "ALIGN_RATE"),
    3: .same(proto: "ALIGN_INTERPOLATE"),
    4: .same(proto: "ALIGN_NEXT_OLDER"),
    10: .same(proto: "ALIGN_MIN"),
    11: .same(proto: "ALIGN_MAX"),
    12: .same(proto: "ALIGN_MEAN"),
    13: .same(proto: "ALIGN_COUNT"),
    14: .same(proto: "ALIGN_SUM"),
    15: .same(proto: "ALIGN_STDDEV"),
    16: .same(proto: "ALIGN_COUNT_TRUE"),
    17: .same(proto: "ALIGN_FRACTION_TRUE"),
    18: .same(proto: "ALIGN_PERCENTILE_99"),
    19: .same(proto: "ALIGN_PERCENTILE_95"),
    20: .same(proto: "ALIGN_PERCENTILE_50"),
    21: .same(proto: "ALIGN_PERCENTILE_05"),
    23: .same(proto: "ALIGN_PERCENT_CHANGE"),
    24: .same(proto: "ALIGN_COUNT_FALSE"),
  ]
}

extension Google_Monitoring_V3_Aggregation.Reducer: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REDUCE_NONE"),
    1: .same(proto: "REDUCE_MEAN"),
    2: .same(proto: "REDUCE_MIN"),
    3: .same(proto: "REDUCE_MAX"),
    4: .same(proto: "REDUCE_SUM"),
    5: .same(proto: "REDUCE_STDDEV"),
    6: .same(proto: "REDUCE_COUNT"),
    7: .same(proto: "REDUCE_COUNT_TRUE"),
    8: .same(proto: "REDUCE_FRACTION_TRUE"),
    9: .same(proto: "REDUCE_PERCENTILE_99"),
    10: .same(proto: "REDUCE_PERCENTILE_95"),
    11: .same(proto: "REDUCE_PERCENTILE_50"),
    12: .same(proto: "REDUCE_PERCENTILE_05"),
    15: .same(proto: "REDUCE_COUNT_FALSE"),
  ]
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/notification_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The `ListNotificationChannelDescriptors` request.
public struct Google_Monitoring_V3_ListNotificationChannelDescriptorsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The REST resource name of the parent from which to retrieve
  /// the notification channel descriptors. The expected syntax is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]
  ///
  /// Note that this names the parent container in which to look for the
  /// descriptors; to retrieve a single descriptor by name, use the
  /// [GetNotificationChannelDescriptor][google.monitoring.v3.NotificationChannelService.GetNotificationChannelDescriptor]
  /// operation, instead.
  public var name: String = String()

  /// The maximum number of results to return in a single response. If
  /// not set to a positive number, a reasonable value will be chosen by the
  /// service.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` must contain a value returned as the
  /// `next_page_token` in a previous response to request the next set
  /// of results.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `ListNotificationChannelDescriptors` response.
public struct Google_Monitoring_V3_ListNotificationChannelDescriptorsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The monitored resource descriptors supported for the specified
  /// project, optionally filtered.
  public var channelDescriptors: [Google_Monitoring_V3_NotificationChannelDescriptor] = []

  /// If not empty, indicates that there may be more results that match
  /// the request. Use the value in the `page_token` field in a
  /// subsequent request to fetch the next set of results. If empty,
  /// all results have been returned.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `GetNotificationChannelDescriptor` response.
public struct Google_Monitoring_V3_GetNotificationChannelDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The channel type for which to execute the request. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/notificationChannelDescriptors/[CHANNEL_TYPE]
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `CreateNotificationChannel` request.
public struct Google_Monitoring_V3_CreateNotificationChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project on which to execute the request. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]
  ///
  /// This names the container into which the channel will be
  /// written, this does not name the newly created channel. The resulting
  /// channel's name will have a normalized version of this field as a prefix,
  /// but will add `/notificationChannels/[CHANNEL_ID]` to identify the channel.
  public var name: String = String()

  /// Required. The definition of the `NotificationChannel` to create.
  public var notificationChannel: Google_Monitoring_V3_NotificationChannel {
    get {return _notificationChannel ?? Google_Monitoring_V3_NotificationChannel()}
    set {_notificationChannel = newValue}
  }
  /// Returns true if `notificationChannel` has been explicitly set.
  public var hasNotificationChannel: Bool {return self._notificationChannel != nil}
  /// Clears the value of `notificationChannel`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationChannel() {self._notificationChannel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _notificationChannel: Google_Monitoring_V3_NotificationChannel? = nil
}

/// The `ListNotificationChannels` request.
public struct Google_Monitoring_V3_ListNotificationChannelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The project on which to execute the request. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]
  ///
  /// This names the container
  /// in which to look for the notification channels; it does not name a
  /// specific channel. To query a specific channel by REST resource name, use
  /// the
  /// [`GetNotificationChannel`][google.monitoring.v3.NotificationChannelService.GetNotificationChannel]
  /// operation.
  public var name: String = String()

  /// If provided, this field specifies the criteria that must be met by
  /// notification channels to be included in the response.
  ///
  /// For more details, see [sorting and
  /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
  public var filter: String = String()

  /// A comma-separated list of fields by which to sort the result. Supports
  /// the same set of fields as in `filter`. Entries can be prefixed with
  /// a minus sign to sort in descending rather than ascending order.
  ///
  /// For more details, see [sorting and
  /// filtering](https://cloud.google.com/monitoring/api/v3/sorting-and-filtering).
  public var orderBy: String = String()

  /// The maximum number of results to return in a single response. If
  /// not set to a positive number, a reasonable value will be chosen by the
  /// service.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` must contain a value returned as the
  /// `next_page_token` in a previous response to request the next set
  /// of results.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `ListNotificationChannels` response.
public struct Google_Monitoring_V3_ListNotificationChannelsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The notification channels defined for the specified project.
  public var notificationChannels: [Google_Monitoring_V3_NotificationChannel] = []

  /// If not empty, indicates that there may be more results that match
  /// the request. Use the value in the `page_token` field in a
  /// subsequent request to fetch the next set of results. If empty,
  /// all results have been returned.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `GetNotificationChannel` request.
public struct Google_Monitoring_V3_GetNotificationChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The channel for which to execute the request. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `UpdateNotificationChannel` request.
public struct Google_Monitoring_V3_UpdateNotificationChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// Required. A description of the changes to be applied to the specified
  /// notification channel. The description must provide a definition for
  /// fields to be updated; the names of these fields should also be
  /// included in the `update_mask`.
  public var notificationChannel: Google_Monitoring_V3_NotificationChannel {
    get {return _notificationChannel ?? Google_Monitoring_V3_NotificationChannel()}
    set {_notificationChannel = newValue}
  }
  /// Returns true if `notificationChannel` has been explicitly set.
  public var hasNotificationChannel: Bool {return self._notificationChannel != nil}
  /// Clears the value of `notificationChannel`. Subsequent reads from it will return its default value.
  public mutating func clearNotificationChannel() {self._notificationChannel = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _notificationChannel: Google_Monitoring_V3_NotificationChannel? = nil
}

/// The `DeleteNotificationChannel` request.
public struct Google_Monitoring_V3_DeleteNotificationChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The channel for which to execute the request. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/notificationChannels/[CHANNEL_ID]
  public var name: String = String()

  /// If true, the notification channel will be deleted regardless of its
  /// use in alert policies (the policies will be updated to remove the
  /// channel). If false, channels that are still referenced by an existing
  /// alerting policy will fail to be deleted in a delete operation.
  public var force: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `SendNotificationChannelVerificationCode` request.
public struct Google_Monitoring_V3_SendNotificationChannelVerificationCodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The notification channel to which to send a verification code.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The `GetNotificationChannelVerificationCode` request.
public struct Google_Monitoring_V3_GetNotificationChannelVerificationCodeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The notification channel for which a verification code is to be generated
  /// and retrieved. This must name a channel that is already verified; if
  /// the specified channel is not verified, the request will fail.
  public var name: String = String()

  /// The desired expiration time. If specified, the API will guarantee that
  /// the returned code will not be valid after the specified timestamp;
  /// however, the API cannot guarantee that the returned code will be
  /// valid for at least as long as the requested time (the API puts an upper
  /// bound on the amount of time for which a code may be valid). If omitted,
  /// a default expiration will be used, which may be less than the max
  /// permissible expiration (so specifying an expiration may extend the
  /// code's lifetime over omitting an expiration, even though the API does
  /// impose an upper limit on the maximum expiration that is permitted).
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The `GetNotificationChannelVerificationCode` request.
public struct Google_Monitoring_V3_GetNotificationChannelVerificationCodeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The verification code, which may be used to verify other channels
  /// that have an equivalent identity (i.e. other channels of the same
  /// type with the same fingerprint such as other email channels with
  /// the same email address or other sms channels with the same number).
  public var code: String = String()

  /// The expiration time associated with the code that was returned. If
  /// an expiration was provided in the request, this is the minimum of the
  /// requested expiration in the request and the max permitted expiration.
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The `VerifyNotificationChannel` request.
public struct Google_Monitoring_V3_VerifyNotificationChannelRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The notification channel to verify.
  public var name: String = String()

  /// Required. The verification code that was delivered to the channel as
  /// a result of invoking the `SendNotificationChannelVerificationCode` API
  /// method or that was retrieved from a verified channel via
  /// `GetNotificationChannelVerificationCode`. For example, one might have
  /// "G-123456" or "TKNZGhhd2EyN3I1MnRnMjRv" (in general, one is only
  /// guaranteed that the code is valid UTF-8; one should not
  /// make any assumptions regarding the structure or format of the code).
  public var code: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_ListNotificationChannelDescriptorsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationChannelDescriptorsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "name"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListNotificationChannelDescriptorsRequest, rhs: Google_Monitoring_V3_ListNotificationChannelDescriptorsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ListNotificationChannelDescriptorsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationChannelDescriptorsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "channel_descriptors"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.channelDescriptors) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.channelDescriptors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.channelDescriptors, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListNotificationChannelDescriptorsResponse, rhs: Google_Monitoring_V3_ListNotificationChannelDescriptorsResponse) -> Bool {
    if lhs.channelDescriptors != rhs.channelDescriptors {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_GetNotificationChannelDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotificationChannelDescriptorRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_GetNotificationChannelDescriptorRequest, rhs: Google_Monitoring_V3_GetNotificationChannelDescriptorRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_CreateNotificationChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNotificationChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    2: .standard(proto: "notification_channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._notificationChannel) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._notificationChannel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_CreateNotificationChannelRequest, rhs: Google_Monitoring_V3_CreateNotificationChannelRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._notificationChannel != rhs._notificationChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ListNotificationChannelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationChannelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "name"),
    6: .same(proto: "filter"),
    7: .standard(proto: "order_by"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 6)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListNotificationChannelsRequest, rhs: Google_Monitoring_V3_ListNotificationChannelsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ListNotificationChannelsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotificationChannelsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "notification_channels"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.notificationChannels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.notificationChannels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notificationChannels, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ListNotificationChannelsResponse, rhs: Google_Monitoring_V3_ListNotificationChannelsResponse) -> Bool {
    if lhs.notificationChannels != rhs.notificationChannels {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_GetNotificationChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotificationChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_GetNotificationChannelRequest, rhs: Google_Monitoring_V3_GetNotificationChannelRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_UpdateNotificationChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNotificationChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "update_mask"),
    3: .standard(proto: "notification_channel"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._notificationChannel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._notificationChannel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_UpdateNotificationChannelRequest, rhs: Google_Monitoring_V3_UpdateNotificationChannelRequest) -> Bool {
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._notificationChannel != rhs._notificationChannel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_DeleteNotificationChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNotificationChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    5: .same(proto: "force"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_DeleteNotificationChannelRequest, rhs: Google_Monitoring_V3_DeleteNotificationChannelRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_SendNotificationChannelVerificationCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendNotificationChannelVerificationCodeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_SendNotificationChannelVerificationCodeRequest, rhs: Google_Monitoring_V3_SendNotificationChannelVerificationCodeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_GetNotificationChannelVerificationCodeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotificationChannelVerificationCodeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_GetNotificationChannelVerificationCodeRequest, rhs: Google_Monitoring_V3_GetNotificationChannelVerificationCodeRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_GetNotificationChannelVerificationCodeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNotificationChannelVerificationCodeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 1)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_GetNotificationChannelVerificationCodeResponse, rhs: Google_Monitoring_V3_GetNotificationChannelVerificationCodeResponse) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_VerifyNotificationChannelRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerifyNotificationChannelRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "code"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.code) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularStringField(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_VerifyNotificationChannelRequest, rhs: Google_Monitoring_V3_VerifyNotificationChannelRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

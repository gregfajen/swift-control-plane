// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/v3/service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A `Service` is a discrete, autonomous, and network-accessible unit, designed
/// to solve an individual concern
/// ([Wikipedia](https://en.wikipedia.org/wiki/Service-orientation)). In
/// Cloud Monitoring, a `Service` acts as the root resource under which
/// operational aspects of the service are accessible.
public struct Google_Monitoring_V3_Service {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name for this Service. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]
  public var name: String = String()

  /// Name used for UI elements listing this Service.
  public var displayName: String = String()

  /// REQUIRED. Service-identifying atoms specifying the underlying service.
  public var identifier: Google_Monitoring_V3_Service.OneOf_Identifier? = nil

  /// Custom service type.
  public var custom: Google_Monitoring_V3_Service.Custom {
    get {
      if case .custom(let v)? = identifier {return v}
      return Google_Monitoring_V3_Service.Custom()
    }
    set {identifier = .custom(newValue)}
  }

  /// Type used for App Engine services.
  public var appEngine: Google_Monitoring_V3_Service.AppEngine {
    get {
      if case .appEngine(let v)? = identifier {return v}
      return Google_Monitoring_V3_Service.AppEngine()
    }
    set {identifier = .appEngine(newValue)}
  }

  /// Type used for Cloud Endpoints services.
  public var cloudEndpoints: Google_Monitoring_V3_Service.CloudEndpoints {
    get {
      if case .cloudEndpoints(let v)? = identifier {return v}
      return Google_Monitoring_V3_Service.CloudEndpoints()
    }
    set {identifier = .cloudEndpoints(newValue)}
  }

  /// Type used for Istio services that live in a Kubernetes cluster.
  public var clusterIstio: Google_Monitoring_V3_Service.ClusterIstio {
    get {
      if case .clusterIstio(let v)? = identifier {return v}
      return Google_Monitoring_V3_Service.ClusterIstio()
    }
    set {identifier = .clusterIstio(newValue)}
  }

  /// Type used for Istio services scoped to an Istio mesh.
  public var meshIstio: Google_Monitoring_V3_Service.MeshIstio {
    get {
      if case .meshIstio(let v)? = identifier {return v}
      return Google_Monitoring_V3_Service.MeshIstio()
    }
    set {identifier = .meshIstio(newValue)}
  }

  /// Configuration for how to query telemetry on a Service.
  public var telemetry: Google_Monitoring_V3_Service.Telemetry {
    get {return _telemetry ?? Google_Monitoring_V3_Service.Telemetry()}
    set {_telemetry = newValue}
  }
  /// Returns true if `telemetry` has been explicitly set.
  public var hasTelemetry: Bool {return self._telemetry != nil}
  /// Clears the value of `telemetry`. Subsequent reads from it will return its default value.
  public mutating func clearTelemetry() {self._telemetry = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// REQUIRED. Service-identifying atoms specifying the underlying service.
  public enum OneOf_Identifier: Equatable {
    /// Custom service type.
    case custom(Google_Monitoring_V3_Service.Custom)
    /// Type used for App Engine services.
    case appEngine(Google_Monitoring_V3_Service.AppEngine)
    /// Type used for Cloud Endpoints services.
    case cloudEndpoints(Google_Monitoring_V3_Service.CloudEndpoints)
    /// Type used for Istio services that live in a Kubernetes cluster.
    case clusterIstio(Google_Monitoring_V3_Service.ClusterIstio)
    /// Type used for Istio services scoped to an Istio mesh.
    case meshIstio(Google_Monitoring_V3_Service.MeshIstio)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_Service.OneOf_Identifier, rhs: Google_Monitoring_V3_Service.OneOf_Identifier) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.custom, .custom): return {
        guard case .custom(let l) = lhs, case .custom(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.appEngine, .appEngine): return {
        guard case .appEngine(let l) = lhs, case .appEngine(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.cloudEndpoints, .cloudEndpoints): return {
        guard case .cloudEndpoints(let l) = lhs, case .cloudEndpoints(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.clusterIstio, .clusterIstio): return {
        guard case .clusterIstio(let l) = lhs, case .clusterIstio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.meshIstio, .meshIstio): return {
        guard case .meshIstio(let l) = lhs, case .meshIstio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Custom view of service telemetry. Currently a place-holder pending final
  /// design.
  public struct Custom {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// App Engine service. Learn more at https://cloud.google.com/appengine.
  public struct AppEngine {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the App Engine module underlying this service. Corresponds to
    /// the `module_id` resource label in the `gae_app` monitored resource:
    /// https://cloud.google.com/monitoring/api/resources#tag_gae_app
    public var moduleID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Cloud Endpoints service. Learn more at https://cloud.google.com/endpoints.
  public struct CloudEndpoints {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name of the Cloud Endpoints service underlying this service.
    /// Corresponds to the `service` resource label in the `api` monitored
    /// resource: https://cloud.google.com/monitoring/api/resources#tag_api
    public var service: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Istio service scoped to a single Kubernetes cluster. Learn more at
  /// http://istio.io.
  public struct ClusterIstio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The location of the Kubernetes cluster in which this Istio service is
    /// defined. Corresponds to the `location` resource label in `k8s_cluster`
    /// resources.
    public var location: String = String()

    /// The name of the Kubernetes cluster in which this Istio service is
    /// defined. Corresponds to the `cluster_name` resource label in
    /// `k8s_cluster` resources.
    public var clusterName: String = String()

    /// The namespace of the Istio service underlying this service. Corresponds
    /// to the `destination_service_namespace` metric label in Istio metrics.
    public var serviceNamespace: String = String()

    /// The name of the Istio service underlying this service. Corresponds to the
    /// `destination_service_name` metric label in Istio metrics.
    public var serviceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Istio service scoped to an Istio mesh
  public struct MeshIstio {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identifier for the mesh in which this Istio service is defined.
    /// Corresponds to the `mesh_uid` metric label in Istio metrics.
    public var meshUid: String = String()

    /// The namespace of the Istio service underlying this service. Corresponds
    /// to the `destination_service_namespace` metric label in Istio metrics.
    public var serviceNamespace: String = String()

    /// The name of the Istio service underlying this service. Corresponds to the
    /// `destination_service_name` metric label in Istio metrics.
    public var serviceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Configuration for how to query telemetry on a Service.
  public struct Telemetry {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The full name of the resource that defines this service. Formatted as
    /// described in https://cloud.google.com/apis/design/resource_names.
    public var resourceName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _telemetry: Google_Monitoring_V3_Service.Telemetry? = nil
}

/// A Service-Level Objective (SLO) describes a level of desired good service. It
/// consists of a service-level indicator (SLI), a performance goal, and a period
/// over which the objective is to be evaluated against that goal. The SLO can
/// use SLIs defined in a number of different manners. Typical SLOs might include
/// "99% of requests in each rolling week have latency below 200 milliseconds" or
/// "99.5% of requests in each calendar month return successfully."
public struct Google_Monitoring_V3_ServiceLevelObjective {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name for this `ServiceLevelObjective`. The format is:
  ///
  ///     projects/[PROJECT_ID_OR_NUMBER]/services/[SERVICE_ID]/serviceLevelObjectives/[SLO_NAME]
  public var name: String = String()

  /// Name used for UI elements listing this SLO.
  public var displayName: String = String()

  /// The definition of good service, used to measure and calculate the quality
  /// of the `Service`'s performance with respect to a single aspect of service
  /// quality.
  public var serviceLevelIndicator: Google_Monitoring_V3_ServiceLevelIndicator {
    get {return _serviceLevelIndicator ?? Google_Monitoring_V3_ServiceLevelIndicator()}
    set {_serviceLevelIndicator = newValue}
  }
  /// Returns true if `serviceLevelIndicator` has been explicitly set.
  public var hasServiceLevelIndicator: Bool {return self._serviceLevelIndicator != nil}
  /// Clears the value of `serviceLevelIndicator`. Subsequent reads from it will return its default value.
  public mutating func clearServiceLevelIndicator() {self._serviceLevelIndicator = nil}

  /// The fraction of service that must be good in order for this objective to be
  /// met. `0 < goal <= 0.999`.
  public var goal: Double = 0

  /// The time period over which the objective will be evaluated.
  public var period: Google_Monitoring_V3_ServiceLevelObjective.OneOf_Period? = nil

  /// A rolling time period, semantically "in the past `<rolling_period>`".
  /// Must be an integer multiple of 1 day no larger than 30 days.
  public var rollingPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {
      if case .rollingPeriod(let v)? = period {return v}
      return SwiftProtobuf.Google_Protobuf_Duration()
    }
    set {period = .rollingPeriod(newValue)}
  }

  /// A calendar period, semantically "since the start of the current
  /// `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
  /// `MONTH` are supported.
  public var calendarPeriod: Google_Type_CalendarPeriod {
    get {
      if case .calendarPeriod(let v)? = period {return v}
      return .unspecified
    }
    set {period = .calendarPeriod(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The time period over which the objective will be evaluated.
  public enum OneOf_Period: Equatable {
    /// A rolling time period, semantically "in the past `<rolling_period>`".
    /// Must be an integer multiple of 1 day no larger than 30 days.
    case rollingPeriod(SwiftProtobuf.Google_Protobuf_Duration)
    /// A calendar period, semantically "since the start of the current
    /// `<calendar_period>`". At this time, only `DAY`, `WEEK`, `FORTNIGHT`, and
    /// `MONTH` are supported.
    case calendarPeriod(Google_Type_CalendarPeriod)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_ServiceLevelObjective.OneOf_Period, rhs: Google_Monitoring_V3_ServiceLevelObjective.OneOf_Period) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rollingPeriod, .rollingPeriod): return {
        guard case .rollingPeriod(let l) = lhs, case .rollingPeriod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.calendarPeriod, .calendarPeriod): return {
        guard case .calendarPeriod(let l) = lhs, case .calendarPeriod(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// `ServiceLevelObjective.View` determines what form of
  /// `ServiceLevelObjective` is returned from `GetServiceLevelObjective`,
  /// `ListServiceLevelObjectives`, and `ListServiceLevelObjectiveVersions` RPCs.
  public enum View: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Same as FULL.
    case unspecified // = 0

    /// Return the embedded `ServiceLevelIndicator` in the form in which it was
    /// defined. If it was defined using a `BasicSli`, return that `BasicSli`.
    case full // = 2

    /// For `ServiceLevelIndicator`s using `BasicSli` articulation, instead
    /// return the `ServiceLevelIndicator` with its mode of computation fully
    /// spelled out as a `RequestBasedSli`. For `ServiceLevelIndicator`s using
    /// `RequestBasedSli` or `WindowsBasedSli`, return the
    /// `ServiceLevelIndicator` as it was provided.
    case explicit // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .explicit
      case 2: self = .full
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .explicit: return 1
      case .full: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _serviceLevelIndicator: Google_Monitoring_V3_ServiceLevelIndicator? = nil
}

#if swift(>=4.2)

extension Google_Monitoring_V3_ServiceLevelObjective.View: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_V3_ServiceLevelObjective.View] = [
    .unspecified,
    .full,
    .explicit,
  ]
}

#endif  // swift(>=4.2)

/// A Service-Level Indicator (SLI) describes the "performance" of a service. For
/// some services, the SLI is well-defined. In such cases, the SLI can be
/// described easily by referencing the well-known SLI and providing the needed
/// parameters. Alternatively, a "custom" SLI can be defined with a query to the
/// underlying metric store. An SLI is defined to be `good_service /
/// total_service` over any queried time interval. The value of performance
/// always falls into the range `0 <= performance <= 1`. A custom SLI describes
/// how to compute this ratio, whether this is by dividing values from a pair of
/// time series, cutting a `Distribution` into good and bad counts, or counting
/// time windows in which the service complies with a criterion. For separation
/// of concerns, a single Service-Level Indicator measures performance for only
/// one aspect of service quality, such as fraction of successful queries or
/// fast-enough queries.
public struct Google_Monitoring_V3_ServiceLevelIndicator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Service level indicators can be grouped by whether the "unit" of service
  /// being measured is based on counts of good requests or on counts of good
  /// time windows
  public var type: Google_Monitoring_V3_ServiceLevelIndicator.OneOf_Type? = nil

  /// Basic SLI on a well-known service type.
  public var basicSli: Google_Monitoring_V3_BasicSli {
    get {
      if case .basicSli(let v)? = type {return v}
      return Google_Monitoring_V3_BasicSli()
    }
    set {type = .basicSli(newValue)}
  }

  /// Request-based SLIs
  public var requestBased: Google_Monitoring_V3_RequestBasedSli {
    get {
      if case .requestBased(let v)? = type {return v}
      return Google_Monitoring_V3_RequestBasedSli()
    }
    set {type = .requestBased(newValue)}
  }

  /// Windows-based SLIs
  public var windowsBased: Google_Monitoring_V3_WindowsBasedSli {
    get {
      if case .windowsBased(let v)? = type {return v}
      return Google_Monitoring_V3_WindowsBasedSli()
    }
    set {type = .windowsBased(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Service level indicators can be grouped by whether the "unit" of service
  /// being measured is based on counts of good requests or on counts of good
  /// time windows
  public enum OneOf_Type: Equatable {
    /// Basic SLI on a well-known service type.
    case basicSli(Google_Monitoring_V3_BasicSli)
    /// Request-based SLIs
    case requestBased(Google_Monitoring_V3_RequestBasedSli)
    /// Windows-based SLIs
    case windowsBased(Google_Monitoring_V3_WindowsBasedSli)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_ServiceLevelIndicator.OneOf_Type, rhs: Google_Monitoring_V3_ServiceLevelIndicator.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.basicSli, .basicSli): return {
        guard case .basicSli(let l) = lhs, case .basicSli(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestBased, .requestBased): return {
        guard case .requestBased(let l) = lhs, case .requestBased(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.windowsBased, .windowsBased): return {
        guard case .windowsBased(let l) = lhs, case .windowsBased(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// An SLI measuring performance on a well-known service type. Performance will
/// be computed on the basis of pre-defined metrics. The type of the
/// `service_resource` determines the metrics to use and the
/// `service_resource.labels` and `metric_labels` are used to construct a
/// monitoring filter to filter that metric down to just the data relevant to
/// this service.
public struct Google_Monitoring_V3_BasicSli {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OPTIONAL: The set of RPCs to which this SLI is relevant. Telemetry from
  /// other methods will not be used to calculate performance for this SLI. If
  /// omitted, this SLI applies to all the Service's methods. For service types
  /// that don't support breaking down by method, setting this field will result
  /// in an error.
  public var method: [String] = []

  /// OPTIONAL: The set of locations to which this SLI is relevant. Telemetry
  /// from other locations will not be used to calculate performance for this
  /// SLI. If omitted, this SLI applies to all locations in which the Service has
  /// activity. For service types that don't support breaking down by location,
  /// setting this field will result in an error.
  public var location: [String] = []

  /// OPTIONAL: The set of API versions to which this SLI is relevant. Telemetry
  /// from other API versions will not be used to calculate performance for this
  /// SLI. If omitted, this SLI applies to all API versions. For service types
  /// that don't support breaking down by version, setting this field will result
  /// in an error.
  public var version: [String] = []

  /// This SLI can be evaluated on the basis of availability or latency.
  public var sliCriteria: Google_Monitoring_V3_BasicSli.OneOf_SliCriteria? = nil

  /// Good service is defined to be the count of requests made to this service
  /// that return successfully.
  public var availability: Google_Monitoring_V3_BasicSli.AvailabilityCriteria {
    get {
      if case .availability(let v)? = sliCriteria {return v}
      return Google_Monitoring_V3_BasicSli.AvailabilityCriteria()
    }
    set {sliCriteria = .availability(newValue)}
  }

  /// Good service is defined to be the count of requests made to this service
  /// that are fast enough with respect to `latency.threshold`.
  public var latency: Google_Monitoring_V3_BasicSli.LatencyCriteria {
    get {
      if case .latency(let v)? = sliCriteria {return v}
      return Google_Monitoring_V3_BasicSli.LatencyCriteria()
    }
    set {sliCriteria = .latency(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// This SLI can be evaluated on the basis of availability or latency.
  public enum OneOf_SliCriteria: Equatable {
    /// Good service is defined to be the count of requests made to this service
    /// that return successfully.
    case availability(Google_Monitoring_V3_BasicSli.AvailabilityCriteria)
    /// Good service is defined to be the count of requests made to this service
    /// that are fast enough with respect to `latency.threshold`.
    case latency(Google_Monitoring_V3_BasicSli.LatencyCriteria)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_BasicSli.OneOf_SliCriteria, rhs: Google_Monitoring_V3_BasicSli.OneOf_SliCriteria) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.availability, .availability): return {
        guard case .availability(let l) = lhs, case .availability(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.latency, .latency): return {
        guard case .latency(let l) = lhs, case .latency(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Future parameters for the availability SLI.
  public struct AvailabilityCriteria {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Parameters for a latency threshold SLI.
  public struct LatencyCriteria {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Good service is defined to be the count of requests made to this service
    /// that return in no more than `threshold`.
    public var threshold: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _threshold ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_threshold = newValue}
    }
    /// Returns true if `threshold` has been explicitly set.
    public var hasThreshold: Bool {return self._threshold != nil}
    /// Clears the value of `threshold`. Subsequent reads from it will return its default value.
    public mutating func clearThreshold() {self._threshold = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _threshold: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}
}

/// Range of numerical values, inclusive of `min` and exclusive of `max`. If the
/// open range "< range.max" is desired, set `range.min = -infinity`. If the open
/// range ">= range.min" is desired, set `range.max = infinity`.
public struct Google_Monitoring_V3_Range {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Range minimum.
  public var min: Double = 0

  /// Range maximum.
  public var max: Double = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Service Level Indicators for which atomic units of service are counted
/// directly.
public struct Google_Monitoring_V3_RequestBasedSli {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The means to compute a ratio of `good_service` to `total_service`.
  public var method: Google_Monitoring_V3_RequestBasedSli.OneOf_Method? = nil

  /// `good_total_ratio` is used when the ratio of `good_service` to
  /// `total_service` is computed from two `TimeSeries`.
  public var goodTotalRatio: Google_Monitoring_V3_TimeSeriesRatio {
    get {
      if case .goodTotalRatio(let v)? = method {return v}
      return Google_Monitoring_V3_TimeSeriesRatio()
    }
    set {method = .goodTotalRatio(newValue)}
  }

  /// `distribution_cut` is used when `good_service` is a count of values
  /// aggregated in a `Distribution` that fall into a good range. The
  /// `total_service` is the total count of all values aggregated in the
  /// `Distribution`.
  public var distributionCut: Google_Monitoring_V3_DistributionCut {
    get {
      if case .distributionCut(let v)? = method {return v}
      return Google_Monitoring_V3_DistributionCut()
    }
    set {method = .distributionCut(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The means to compute a ratio of `good_service` to `total_service`.
  public enum OneOf_Method: Equatable {
    /// `good_total_ratio` is used when the ratio of `good_service` to
    /// `total_service` is computed from two `TimeSeries`.
    case goodTotalRatio(Google_Monitoring_V3_TimeSeriesRatio)
    /// `distribution_cut` is used when `good_service` is a count of values
    /// aggregated in a `Distribution` that fall into a good range. The
    /// `total_service` is the total count of all values aggregated in the
    /// `Distribution`.
    case distributionCut(Google_Monitoring_V3_DistributionCut)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_RequestBasedSli.OneOf_Method, rhs: Google_Monitoring_V3_RequestBasedSli.OneOf_Method) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.goodTotalRatio, .goodTotalRatio): return {
        guard case .goodTotalRatio(let l) = lhs, case .goodTotalRatio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distributionCut, .distributionCut): return {
        guard case .distributionCut(let l) = lhs, case .distributionCut(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A `TimeSeriesRatio` specifies two `TimeSeries` to use for computing the
/// `good_service / total_service` ratio. The specified `TimeSeries` must have
/// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
/// DELTA` or `MetricKind = CUMULATIVE`. The `TimeSeriesRatio` must specify
/// exactly two of good, bad, and total, and the relationship `good_service +
/// bad_service = total_service` will be assumed.
public struct Google_Monitoring_V3_TimeSeriesRatio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
  /// specifying a `TimeSeries` quantifying good service provided. Must have
  /// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
  /// DELTA` or `MetricKind = CUMULATIVE`.
  public var goodServiceFilter: String = String()

  /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
  /// specifying a `TimeSeries` quantifying bad service, either demanded service
  /// that was not provided or demanded service that was of inadequate quality.
  /// Must have `ValueType = DOUBLE` or `ValueType = INT64` and must have
  /// `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
  public var badServiceFilter: String = String()

  /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
  /// specifying a `TimeSeries` quantifying total demanded service. Must have
  /// `ValueType = DOUBLE` or `ValueType = INT64` and must have `MetricKind =
  /// DELTA` or `MetricKind = CUMULATIVE`.
  public var totalServiceFilter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A `DistributionCut` defines a `TimeSeries` and thresholds used for measuring
/// good service and total service. The `TimeSeries` must have `ValueType =
/// DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`. The
/// computed `good_service` will be the count of values x in the `Distribution`
/// such that `range.min <= x < range.max`.
public struct Google_Monitoring_V3_DistributionCut {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
  /// specifying a `TimeSeries` aggregating values. Must have `ValueType =
  /// DISTRIBUTION` and `MetricKind = DELTA` or `MetricKind = CUMULATIVE`.
  public var distributionFilter: String = String()

  /// Range of values considered "good." For a one-sided range, set one bound to
  /// an infinite value.
  public var range: Google_Monitoring_V3_Range {
    get {return _range ?? Google_Monitoring_V3_Range()}
    set {_range = newValue}
  }
  /// Returns true if `range` has been explicitly set.
  public var hasRange: Bool {return self._range != nil}
  /// Clears the value of `range`. Subsequent reads from it will return its default value.
  public mutating func clearRange() {self._range = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _range: Google_Monitoring_V3_Range? = nil
}

/// A `WindowsBasedSli` defines `good_service` as the count of time windows for
/// which the provided service was of good quality. Criteria for determining
/// if service was good are embedded in the `window_criterion`.
public struct Google_Monitoring_V3_WindowsBasedSli {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The criterion to use for evaluating window goodness.
  public var windowCriterion: Google_Monitoring_V3_WindowsBasedSli.OneOf_WindowCriterion? = nil

  /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
  /// specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
  /// any `true` values appear in the window.
  public var goodBadMetricFilter: String {
    get {
      if case .goodBadMetricFilter(let v)? = windowCriterion {return v}
      return String()
    }
    set {windowCriterion = .goodBadMetricFilter(newValue)}
  }

  /// A window is good if its `performance` is high enough.
  public var goodTotalRatioThreshold: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold {
    get {
      if case .goodTotalRatioThreshold(let v)? = windowCriterion {return v}
      return Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold()
    }
    set {windowCriterion = .goodTotalRatioThreshold(newValue)}
  }

  /// A window is good if the metric's value is in a good range, averaged
  /// across returned streams.
  public var metricMeanInRange: Google_Monitoring_V3_WindowsBasedSli.MetricRange {
    get {
      if case .metricMeanInRange(let v)? = windowCriterion {return v}
      return Google_Monitoring_V3_WindowsBasedSli.MetricRange()
    }
    set {windowCriterion = .metricMeanInRange(newValue)}
  }

  /// A window is good if the metric's value is in a good range, summed across
  /// returned streams.
  public var metricSumInRange: Google_Monitoring_V3_WindowsBasedSli.MetricRange {
    get {
      if case .metricSumInRange(let v)? = windowCriterion {return v}
      return Google_Monitoring_V3_WindowsBasedSli.MetricRange()
    }
    set {windowCriterion = .metricSumInRange(newValue)}
  }

  /// Duration over which window quality is evaluated. Must be an integer
  /// fraction of a day and at least `60s`.
  public var windowPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _windowPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_windowPeriod = newValue}
  }
  /// Returns true if `windowPeriod` has been explicitly set.
  public var hasWindowPeriod: Bool {return self._windowPeriod != nil}
  /// Clears the value of `windowPeriod`. Subsequent reads from it will return its default value.
  public mutating func clearWindowPeriod() {self._windowPeriod = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The criterion to use for evaluating window goodness.
  public enum OneOf_WindowCriterion: Equatable {
    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying a `TimeSeries` with `ValueType = BOOL`. The window is good if
    /// any `true` values appear in the window.
    case goodBadMetricFilter(String)
    /// A window is good if its `performance` is high enough.
    case goodTotalRatioThreshold(Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold)
    /// A window is good if the metric's value is in a good range, averaged
    /// across returned streams.
    case metricMeanInRange(Google_Monitoring_V3_WindowsBasedSli.MetricRange)
    /// A window is good if the metric's value is in a good range, summed across
    /// returned streams.
    case metricSumInRange(Google_Monitoring_V3_WindowsBasedSli.MetricRange)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_V3_WindowsBasedSli.OneOf_WindowCriterion, rhs: Google_Monitoring_V3_WindowsBasedSli.OneOf_WindowCriterion) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.goodBadMetricFilter, .goodBadMetricFilter): return {
        guard case .goodBadMetricFilter(let l) = lhs, case .goodBadMetricFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.goodTotalRatioThreshold, .goodTotalRatioThreshold): return {
        guard case .goodTotalRatioThreshold(let l) = lhs, case .goodTotalRatioThreshold(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metricMeanInRange, .metricMeanInRange): return {
        guard case .metricMeanInRange(let l) = lhs, case .metricMeanInRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.metricSumInRange, .metricSumInRange): return {
        guard case .metricSumInRange(let l) = lhs, case .metricSumInRange(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// A `PerformanceThreshold` is used when each window is good when that window
  /// has a sufficiently high `performance`.
  public struct PerformanceThreshold {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The means, either a request-based SLI or a basic SLI, by which to compute
    /// performance over a window.
    public var type: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold.OneOf_Type? = nil

    /// `RequestBasedSli` to evaluate to judge window quality.
    public var performance: Google_Monitoring_V3_RequestBasedSli {
      get {
        if case .performance(let v)? = type {return v}
        return Google_Monitoring_V3_RequestBasedSli()
      }
      set {type = .performance(newValue)}
    }

    /// `BasicSli` to evaluate to judge window quality.
    public var basicSliPerformance: Google_Monitoring_V3_BasicSli {
      get {
        if case .basicSliPerformance(let v)? = type {return v}
        return Google_Monitoring_V3_BasicSli()
      }
      set {type = .basicSliPerformance(newValue)}
    }

    /// If window `performance >= threshold`, the window is counted as good.
    public var threshold: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The means, either a request-based SLI or a basic SLI, by which to compute
    /// performance over a window.
    public enum OneOf_Type: Equatable {
      /// `RequestBasedSli` to evaluate to judge window quality.
      case performance(Google_Monitoring_V3_RequestBasedSli)
      /// `BasicSli` to evaluate to judge window quality.
      case basicSliPerformance(Google_Monitoring_V3_BasicSli)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold.OneOf_Type, rhs: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold.OneOf_Type) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.performance, .performance): return {
          guard case .performance(let l) = lhs, case .performance(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.basicSliPerformance, .basicSliPerformance): return {
          guard case .basicSliPerformance(let l) = lhs, case .basicSliPerformance(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  /// A `MetricRange` is used when each window is good when the value x of a
  /// single `TimeSeries` satisfies `range.min <= x < range.max`. The provided
  /// `TimeSeries` must have `ValueType = INT64` or `ValueType = DOUBLE` and
  /// `MetricKind = GAUGE`.
  public struct MetricRange {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
    /// specifying the `TimeSeries` to use for evaluating window quality.
    public var timeSeries: String = String()

    /// Range of values considered "good." For a one-sided range, set one bound
    /// to an infinite value.
    public var range: Google_Monitoring_V3_Range {
      get {return _range ?? Google_Monitoring_V3_Range()}
      set {_range = newValue}
    }
    /// Returns true if `range` has been explicitly set.
    public var hasRange: Bool {return self._range != nil}
    /// Clears the value of `range`. Subsequent reads from it will return its default value.
    public mutating func clearRange() {self._range = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _range: Google_Monitoring_V3_Range? = nil
  }

  public init() {}

  fileprivate var _windowPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.v3"

extension Google_Monitoring_V3_Service: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Service"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    6: .same(proto: "custom"),
    7: .standard(proto: "app_engine"),
    8: .standard(proto: "cloud_endpoints"),
    9: .standard(proto: "cluster_istio"),
    10: .standard(proto: "mesh_istio"),
    13: .same(proto: "telemetry"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 6: try {
        var v: Google_Monitoring_V3_Service.Custom?
        if let current = self.identifier {
          try decoder.handleConflictingOneOf()
          if case .custom(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.identifier = .custom(v)}
      }()
      case 7: try {
        var v: Google_Monitoring_V3_Service.AppEngine?
        if let current = self.identifier {
          try decoder.handleConflictingOneOf()
          if case .appEngine(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.identifier = .appEngine(v)}
      }()
      case 8: try {
        var v: Google_Monitoring_V3_Service.CloudEndpoints?
        if let current = self.identifier {
          try decoder.handleConflictingOneOf()
          if case .cloudEndpoints(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.identifier = .cloudEndpoints(v)}
      }()
      case 9: try {
        var v: Google_Monitoring_V3_Service.ClusterIstio?
        if let current = self.identifier {
          try decoder.handleConflictingOneOf()
          if case .clusterIstio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.identifier = .clusterIstio(v)}
      }()
      case 10: try {
        var v: Google_Monitoring_V3_Service.MeshIstio?
        if let current = self.identifier {
          try decoder.handleConflictingOneOf()
          if case .meshIstio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.identifier = .meshIstio(v)}
      }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._telemetry) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.identifier {
    case .custom?: try {
      guard case .custom(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .appEngine?: try {
      guard case .appEngine(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .cloudEndpoints?: try {
      guard case .cloudEndpoints(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .clusterIstio?: try {
      guard case .clusterIstio(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .meshIstio?: try {
      guard case .meshIstio(let v)? = self.identifier else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    if let v = self._telemetry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service, rhs: Google_Monitoring_V3_Service) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.identifier != rhs.identifier {return false}
    if lhs._telemetry != rhs._telemetry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Service.Custom: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_Service.protoMessageName + ".Custom"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service.Custom, rhs: Google_Monitoring_V3_Service.Custom) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Service.AppEngine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_Service.protoMessageName + ".AppEngine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "module_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.moduleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.moduleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service.AppEngine, rhs: Google_Monitoring_V3_Service.AppEngine) -> Bool {
    if lhs.moduleID != rhs.moduleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Service.CloudEndpoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_Service.protoMessageName + ".CloudEndpoints"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.service) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service.CloudEndpoints, rhs: Google_Monitoring_V3_Service.CloudEndpoints) -> Bool {
    if lhs.service != rhs.service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Service.ClusterIstio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_Service.protoMessageName + ".ClusterIstio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .standard(proto: "cluster_name"),
    3: .standard(proto: "service_namespace"),
    4: .standard(proto: "service_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serviceNamespace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 2)
    }
    if !self.serviceNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceNamespace, fieldNumber: 3)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service.ClusterIstio, rhs: Google_Monitoring_V3_Service.ClusterIstio) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.serviceNamespace != rhs.serviceNamespace {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Service.MeshIstio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_Service.protoMessageName + ".MeshIstio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mesh_uid"),
    3: .standard(proto: "service_namespace"),
    4: .standard(proto: "service_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.meshUid) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serviceNamespace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.serviceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.meshUid.isEmpty {
      try visitor.visitSingularStringField(value: self.meshUid, fieldNumber: 1)
    }
    if !self.serviceNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceNamespace, fieldNumber: 3)
    }
    if !self.serviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service.MeshIstio, rhs: Google_Monitoring_V3_Service.MeshIstio) -> Bool {
    if lhs.meshUid != rhs.meshUid {return false}
    if lhs.serviceNamespace != rhs.serviceNamespace {return false}
    if lhs.serviceName != rhs.serviceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Service.Telemetry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_Service.protoMessageName + ".Telemetry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceName.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Service.Telemetry, rhs: Google_Monitoring_V3_Service.Telemetry) -> Bool {
    if lhs.resourceName != rhs.resourceName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ServiceLevelObjective: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceLevelObjective"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    11: .standard(proto: "display_name"),
    3: .standard(proto: "service_level_indicator"),
    4: .same(proto: "goal"),
    5: .standard(proto: "rolling_period"),
    6: .standard(proto: "calendar_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._serviceLevelIndicator) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.goal) }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.period {
          try decoder.handleConflictingOneOf()
          if case .rollingPeriod(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.period = .rollingPeriod(v)}
      }()
      case 6: try {
        if self.period != nil {try decoder.handleConflictingOneOf()}
        var v: Google_Type_CalendarPeriod?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.period = .calendarPeriod(v)}
      }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._serviceLevelIndicator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if self.goal != 0 {
      try visitor.visitSingularDoubleField(value: self.goal, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.period {
    case .rollingPeriod?: try {
      guard case .rollingPeriod(let v)? = self.period else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .calendarPeriod?: try {
      guard case .calendarPeriod(let v)? = self.period else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ServiceLevelObjective, rhs: Google_Monitoring_V3_ServiceLevelObjective) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._serviceLevelIndicator != rhs._serviceLevelIndicator {return false}
    if lhs.goal != rhs.goal {return false}
    if lhs.period != rhs.period {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_ServiceLevelObjective.View: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIEW_UNSPECIFIED"),
    1: .same(proto: "EXPLICIT"),
    2: .same(proto: "FULL"),
  ]
}

extension Google_Monitoring_V3_ServiceLevelIndicator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServiceLevelIndicator"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "basic_sli"),
    1: .standard(proto: "request_based"),
    2: .standard(proto: "windows_based"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Monitoring_V3_RequestBasedSli?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .requestBased(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .requestBased(v)}
      }()
      case 2: try {
        var v: Google_Monitoring_V3_WindowsBasedSli?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .windowsBased(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .windowsBased(v)}
      }()
      case 4: try {
        var v: Google_Monitoring_V3_BasicSli?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .basicSli(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .basicSli(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .requestBased?: try {
      guard case .requestBased(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .windowsBased?: try {
      guard case .windowsBased(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .basicSli?: try {
      guard case .basicSli(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_ServiceLevelIndicator, rhs: Google_Monitoring_V3_ServiceLevelIndicator) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_BasicSli: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BasicSli"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    7: .same(proto: "method"),
    8: .same(proto: "location"),
    9: .same(proto: "version"),
    2: .same(proto: "availability"),
    3: .same(proto: "latency"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Monitoring_V3_BasicSli.AvailabilityCriteria?
        if let current = self.sliCriteria {
          try decoder.handleConflictingOneOf()
          if case .availability(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sliCriteria = .availability(v)}
      }()
      case 3: try {
        var v: Google_Monitoring_V3_BasicSli.LatencyCriteria?
        if let current = self.sliCriteria {
          try decoder.handleConflictingOneOf()
          if case .latency(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sliCriteria = .latency(v)}
      }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.method) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.location) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sliCriteria {
    case .availability?: try {
      guard case .availability(let v)? = self.sliCriteria else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .latency?: try {
      guard case .latency(let v)? = self.sliCriteria else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.method.isEmpty {
      try visitor.visitRepeatedStringField(value: self.method, fieldNumber: 7)
    }
    if !self.location.isEmpty {
      try visitor.visitRepeatedStringField(value: self.location, fieldNumber: 8)
    }
    if !self.version.isEmpty {
      try visitor.visitRepeatedStringField(value: self.version, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_BasicSli, rhs: Google_Monitoring_V3_BasicSli) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.location != rhs.location {return false}
    if lhs.version != rhs.version {return false}
    if lhs.sliCriteria != rhs.sliCriteria {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_BasicSli.AvailabilityCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_BasicSli.protoMessageName + ".AvailabilityCriteria"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_BasicSli.AvailabilityCriteria, rhs: Google_Monitoring_V3_BasicSli.AvailabilityCriteria) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_BasicSli.LatencyCriteria: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_BasicSli.protoMessageName + ".LatencyCriteria"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._threshold) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._threshold {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_BasicSli.LatencyCriteria, rhs: Google_Monitoring_V3_BasicSli.LatencyCriteria) -> Bool {
    if lhs._threshold != rhs._threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Range"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.min) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.max) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularDoubleField(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularDoubleField(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_Range, rhs: Google_Monitoring_V3_Range) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_RequestBasedSli: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestBasedSli"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "good_total_ratio"),
    3: .standard(proto: "distribution_cut"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Monitoring_V3_TimeSeriesRatio?
        if let current = self.method {
          try decoder.handleConflictingOneOf()
          if case .goodTotalRatio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.method = .goodTotalRatio(v)}
      }()
      case 3: try {
        var v: Google_Monitoring_V3_DistributionCut?
        if let current = self.method {
          try decoder.handleConflictingOneOf()
          if case .distributionCut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.method = .distributionCut(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.method {
    case .goodTotalRatio?: try {
      guard case .goodTotalRatio(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .distributionCut?: try {
      guard case .distributionCut(let v)? = self.method else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_RequestBasedSli, rhs: Google_Monitoring_V3_RequestBasedSli) -> Bool {
    if lhs.method != rhs.method {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_TimeSeriesRatio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeriesRatio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "good_service_filter"),
    5: .standard(proto: "bad_service_filter"),
    6: .standard(proto: "total_service_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularStringField(value: &self.goodServiceFilter) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.badServiceFilter) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.totalServiceFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.goodServiceFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.goodServiceFilter, fieldNumber: 4)
    }
    if !self.badServiceFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.badServiceFilter, fieldNumber: 5)
    }
    if !self.totalServiceFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.totalServiceFilter, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_TimeSeriesRatio, rhs: Google_Monitoring_V3_TimeSeriesRatio) -> Bool {
    if lhs.goodServiceFilter != rhs.goodServiceFilter {return false}
    if lhs.badServiceFilter != rhs.badServiceFilter {return false}
    if lhs.totalServiceFilter != rhs.totalServiceFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_DistributionCut: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DistributionCut"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "distribution_filter"),
    5: .same(proto: "range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try { try decoder.decodeSingularStringField(value: &self.distributionFilter) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.distributionFilter.isEmpty {
      try visitor.visitSingularStringField(value: self.distributionFilter, fieldNumber: 4)
    }
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_DistributionCut, rhs: Google_Monitoring_V3_DistributionCut) -> Bool {
    if lhs.distributionFilter != rhs.distributionFilter {return false}
    if lhs._range != rhs._range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_WindowsBasedSli: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WindowsBasedSli"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "good_bad_metric_filter"),
    2: .standard(proto: "good_total_ratio_threshold"),
    6: .standard(proto: "metric_mean_in_range"),
    7: .standard(proto: "metric_sum_in_range"),
    4: .standard(proto: "window_period"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold?
        if let current = self.windowCriterion {
          try decoder.handleConflictingOneOf()
          if case .goodTotalRatioThreshold(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.windowCriterion = .goodTotalRatioThreshold(v)}
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._windowPeriod) }()
      case 5: try {
        if self.windowCriterion != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.windowCriterion = .goodBadMetricFilter(v)}
      }()
      case 6: try {
        var v: Google_Monitoring_V3_WindowsBasedSli.MetricRange?
        if let current = self.windowCriterion {
          try decoder.handleConflictingOneOf()
          if case .metricMeanInRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.windowCriterion = .metricMeanInRange(v)}
      }()
      case 7: try {
        var v: Google_Monitoring_V3_WindowsBasedSli.MetricRange?
        if let current = self.windowCriterion {
          try decoder.handleConflictingOneOf()
          if case .metricSumInRange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.windowCriterion = .metricSumInRange(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .goodTotalRatioThreshold(let v)? = self.windowCriterion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._windowPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.windowCriterion {
    case .goodBadMetricFilter?: try {
      guard case .goodBadMetricFilter(let v)? = self.windowCriterion else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .metricMeanInRange?: try {
      guard case .metricMeanInRange(let v)? = self.windowCriterion else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .metricSumInRange?: try {
      guard case .metricSumInRange(let v)? = self.windowCriterion else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_WindowsBasedSli, rhs: Google_Monitoring_V3_WindowsBasedSli) -> Bool {
    if lhs.windowCriterion != rhs.windowCriterion {return false}
    if lhs._windowPeriod != rhs._windowPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_WindowsBasedSli.protoMessageName + ".PerformanceThreshold"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "performance"),
    3: .standard(proto: "basic_sli_performance"),
    2: .same(proto: "threshold"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Monitoring_V3_RequestBasedSli?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .performance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .performance(v)}
      }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.threshold) }()
      case 3: try {
        var v: Google_Monitoring_V3_BasicSli?
        if let current = self.type {
          try decoder.handleConflictingOneOf()
          if case .basicSliPerformance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.type = .basicSliPerformance(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .performance(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.threshold != 0 {
      try visitor.visitSingularDoubleField(value: self.threshold, fieldNumber: 2)
    }
    if case .basicSliPerformance(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold, rhs: Google_Monitoring_V3_WindowsBasedSli.PerformanceThreshold) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_V3_WindowsBasedSli.MetricRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_V3_WindowsBasedSli.protoMessageName + ".MetricRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_series"),
    4: .same(proto: "range"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timeSeries) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._range) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timeSeries.isEmpty {
      try visitor.visitSingularStringField(value: self.timeSeries, fieldNumber: 1)
    }
    if let v = self._range {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_V3_WindowsBasedSli.MetricRange, rhs: Google_Monitoring_V3_WindowsBasedSli.MetricRange) -> Bool {
    if lhs.timeSeries != rhs.timeSeries {return false}
    if lhs._range != rhs._range {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

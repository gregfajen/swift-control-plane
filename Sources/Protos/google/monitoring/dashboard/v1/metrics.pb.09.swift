// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/monitoring/dashboard/v1/metrics.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines the possible types of spark chart supported by the `Scorecard`.
public enum Google_Monitoring_Dashboard_V1_SparkChartType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Not allowed in well-formed requests.
  case unspecified // = 0

  /// The sparkline will be rendered as a small line chart.
  case sparkLine // = 1

  /// The sparkbar will be rendered as a small bar chart.
  case sparkBar // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .sparkLine
    case 2: self = .sparkBar
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .sparkLine: return 1
    case .sparkBar: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Monitoring_Dashboard_V1_SparkChartType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_Dashboard_V1_SparkChartType] = [
    .unspecified,
    .sparkLine,
    .sparkBar,
  ]
}

#endif  // swift(>=4.2)

/// TimeSeriesQuery collects the set of supported methods for querying time
/// series data from the Stackdriver metrics API.
public struct Google_Monitoring_Dashboard_V1_TimeSeriesQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Parameters needed to obtain data for the chart.
  public var source: Google_Monitoring_Dashboard_V1_TimeSeriesQuery.OneOf_Source? = nil

  /// Filter parameters to fetch time series.
  public var timeSeriesFilter: Google_Monitoring_Dashboard_V1_TimeSeriesFilter {
    get {
      if case .timeSeriesFilter(let v)? = source {return v}
      return Google_Monitoring_Dashboard_V1_TimeSeriesFilter()
    }
    set {source = .timeSeriesFilter(newValue)}
  }

  /// Parameters to fetch a ratio between two time series filters.
  public var timeSeriesFilterRatio: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio {
    get {
      if case .timeSeriesFilterRatio(let v)? = source {return v}
      return Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio()
    }
    set {source = .timeSeriesFilterRatio(newValue)}
  }

  /// A query used to fetch time series.
  public var timeSeriesQueryLanguage: String {
    get {
      if case .timeSeriesQueryLanguage(let v)? = source {return v}
      return String()
    }
    set {source = .timeSeriesQueryLanguage(newValue)}
  }

  /// The unit of data contained in fetched time series. If non-empty, this
  /// unit will override any unit that accompanies fetched data. The format is
  /// the same as the
  /// [`unit`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors)
  /// field in `MetricDescriptor`.
  public var unitOverride: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Parameters needed to obtain data for the chart.
  public enum OneOf_Source: Equatable {
    /// Filter parameters to fetch time series.
    case timeSeriesFilter(Google_Monitoring_Dashboard_V1_TimeSeriesFilter)
    /// Parameters to fetch a ratio between two time series filters.
    case timeSeriesFilterRatio(Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio)
    /// A query used to fetch time series.
    case timeSeriesQueryLanguage(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesQuery.OneOf_Source, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesQuery.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.timeSeriesFilter, .timeSeriesFilter): return {
        guard case .timeSeriesFilter(let l) = lhs, case .timeSeriesFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timeSeriesFilterRatio, .timeSeriesFilterRatio): return {
        guard case .timeSeriesFilterRatio(let l) = lhs, case .timeSeriesFilterRatio(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timeSeriesQueryLanguage, .timeSeriesQueryLanguage): return {
        guard case .timeSeriesQueryLanguage(let l) = lhs, case .timeSeriesQueryLanguage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// A filter that defines a subset of time series data that is displayed in a
/// widget. Time series data is fetched using the
/// [`ListTimeSeries`](https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.timeSeries/list)
/// method.
public struct Google_Monitoring_Dashboard_V1_TimeSeriesFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The [monitoring filter](https://cloud.google.com/monitoring/api/v3/filters)
  /// that identifies the metric types, resources, and projects to query.
  public var filter: String = String()

  /// By default, the raw time series data is returned.
  /// Use this field to combine multiple time series for different views of the
  /// data.
  public var aggregation: Google_Monitoring_Dashboard_V1_Aggregation {
    get {return _aggregation ?? Google_Monitoring_Dashboard_V1_Aggregation()}
    set {_aggregation = newValue}
  }
  /// Returns true if `aggregation` has been explicitly set.
  public var hasAggregation: Bool {return self._aggregation != nil}
  /// Clears the value of `aggregation`. Subsequent reads from it will return its default value.
  public mutating func clearAggregation() {self._aggregation = nil}

  /// Apply a second aggregation after `aggregation` is applied.
  public var secondaryAggregation: Google_Monitoring_Dashboard_V1_Aggregation {
    get {return _secondaryAggregation ?? Google_Monitoring_Dashboard_V1_Aggregation()}
    set {_secondaryAggregation = newValue}
  }
  /// Returns true if `secondaryAggregation` has been explicitly set.
  public var hasSecondaryAggregation: Bool {return self._secondaryAggregation != nil}
  /// Clears the value of `secondaryAggregation`. Subsequent reads from it will return its default value.
  public mutating func clearSecondaryAggregation() {self._secondaryAggregation = nil}

  /// Selects an optional time series filter.
  public var outputFilter: Google_Monitoring_Dashboard_V1_TimeSeriesFilter.OneOf_OutputFilter? = nil

  /// Ranking based time series filter.
  public var pickTimeSeriesFilter: Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter {
    get {
      if case .pickTimeSeriesFilter(let v)? = outputFilter {return v}
      return Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter()
    }
    set {outputFilter = .pickTimeSeriesFilter(newValue)}
  }

  /// Statistics based time series filter.
  /// Note: This field is deprecated and completely ignored by the API.
  public var statisticalTimeSeriesFilter: Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter {
    get {
      if case .statisticalTimeSeriesFilter(let v)? = outputFilter {return v}
      return Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter()
    }
    set {outputFilter = .statisticalTimeSeriesFilter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Selects an optional time series filter.
  public enum OneOf_OutputFilter: Equatable {
    /// Ranking based time series filter.
    case pickTimeSeriesFilter(Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter)
    /// Statistics based time series filter.
    /// Note: This field is deprecated and completely ignored by the API.
    case statisticalTimeSeriesFilter(Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilter.OneOf_OutputFilter, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilter.OneOf_OutputFilter) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pickTimeSeriesFilter, .pickTimeSeriesFilter): return {
        guard case .pickTimeSeriesFilter(let l) = lhs, case .pickTimeSeriesFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statisticalTimeSeriesFilter, .statisticalTimeSeriesFilter): return {
        guard case .statisticalTimeSeriesFilter(let l) = lhs, case .statisticalTimeSeriesFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _aggregation: Google_Monitoring_Dashboard_V1_Aggregation? = nil
  fileprivate var _secondaryAggregation: Google_Monitoring_Dashboard_V1_Aggregation? = nil
}

/// A pair of time series filters that define a ratio computation. The output
/// time series is the pair-wise division of each aligned element from the
/// numerator and denominator time series.
public struct Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The numerator of the ratio.
  public var numerator: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart {
    get {return _storage._numerator ?? Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart()}
    set {_uniqueStorage()._numerator = newValue}
  }
  /// Returns true if `numerator` has been explicitly set.
  public var hasNumerator: Bool {return _storage._numerator != nil}
  /// Clears the value of `numerator`. Subsequent reads from it will return its default value.
  public mutating func clearNumerator() {_uniqueStorage()._numerator = nil}

  /// The denominator of the ratio.
  public var denominator: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart {
    get {return _storage._denominator ?? Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart()}
    set {_uniqueStorage()._denominator = newValue}
  }
  /// Returns true if `denominator` has been explicitly set.
  public var hasDenominator: Bool {return _storage._denominator != nil}
  /// Clears the value of `denominator`. Subsequent reads from it will return its default value.
  public mutating func clearDenominator() {_uniqueStorage()._denominator = nil}

  /// Apply a second aggregation after the ratio is computed.
  public var secondaryAggregation: Google_Monitoring_Dashboard_V1_Aggregation {
    get {return _storage._secondaryAggregation ?? Google_Monitoring_Dashboard_V1_Aggregation()}
    set {_uniqueStorage()._secondaryAggregation = newValue}
  }
  /// Returns true if `secondaryAggregation` has been explicitly set.
  public var hasSecondaryAggregation: Bool {return _storage._secondaryAggregation != nil}
  /// Clears the value of `secondaryAggregation`. Subsequent reads from it will return its default value.
  public mutating func clearSecondaryAggregation() {_uniqueStorage()._secondaryAggregation = nil}

  /// Selects an optional filter that is applied to the time series after
  /// computing the ratio.
  public var outputFilter: OneOf_OutputFilter? {
    get {return _storage._outputFilter}
    set {_uniqueStorage()._outputFilter = newValue}
  }

  /// Ranking based time series filter.
  public var pickTimeSeriesFilter: Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter {
    get {
      if case .pickTimeSeriesFilter(let v)? = _storage._outputFilter {return v}
      return Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter()
    }
    set {_uniqueStorage()._outputFilter = .pickTimeSeriesFilter(newValue)}
  }

  /// Statistics based time series filter.
  /// Note: This field is deprecated and completely ignored by the API.
  public var statisticalTimeSeriesFilter: Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter {
    get {
      if case .statisticalTimeSeriesFilter(let v)? = _storage._outputFilter {return v}
      return Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter()
    }
    set {_uniqueStorage()._outputFilter = .statisticalTimeSeriesFilter(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Selects an optional filter that is applied to the time series after
  /// computing the ratio.
  public enum OneOf_OutputFilter: Equatable {
    /// Ranking based time series filter.
    case pickTimeSeriesFilter(Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter)
    /// Statistics based time series filter.
    /// Note: This field is deprecated and completely ignored by the API.
    case statisticalTimeSeriesFilter(Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.OneOf_OutputFilter, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.OneOf_OutputFilter) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pickTimeSeriesFilter, .pickTimeSeriesFilter): return {
        guard case .pickTimeSeriesFilter(let l) = lhs, case .pickTimeSeriesFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.statisticalTimeSeriesFilter, .statisticalTimeSeriesFilter): return {
        guard case .statisticalTimeSeriesFilter(let l) = lhs, case .statisticalTimeSeriesFilter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Describes a query to build the numerator or denominator of a
  /// TimeSeriesFilterRatio.
  public struct RatioPart {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The [monitoring
    /// filter](https://cloud.google.com/monitoring/api/v3/filters) that
    /// identifies the metric types, resources, and projects to query.
    public var filter: String = String()

    /// By default, the raw time series data is returned.
    /// Use this field to combine multiple time series for different views of the
    /// data.
    public var aggregation: Google_Monitoring_Dashboard_V1_Aggregation {
      get {return _aggregation ?? Google_Monitoring_Dashboard_V1_Aggregation()}
      set {_aggregation = newValue}
    }
    /// Returns true if `aggregation` has been explicitly set.
    public var hasAggregation: Bool {return self._aggregation != nil}
    /// Clears the value of `aggregation`. Subsequent reads from it will return its default value.
    public mutating func clearAggregation() {self._aggregation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _aggregation: Google_Monitoring_Dashboard_V1_Aggregation? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Defines a threshold for categorizing time series values.
public struct Google_Monitoring_Dashboard_V1_Threshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A label for the threshold.
  public var label: String = String()

  /// The value of the threshold. The value should be defined in the native scale
  /// of the metric.
  public var value: Double = 0

  /// The state color for this threshold. Color is not allowed in a XyChart.
  public var color: Google_Monitoring_Dashboard_V1_Threshold.Color = .unspecified

  /// The direction for the current threshold. Direction is not allowed in a
  /// XyChart.
  public var direction: Google_Monitoring_Dashboard_V1_Threshold.Direction = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The color suggests an interpretation to the viewer when actual values cross
  /// the threshold. Comments on each color provide UX guidance on how users can
  /// be expected to interpret a given state color.
  public enum Color: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Color is unspecified. Not allowed in well-formed requests.
    case unspecified // = 0

    /// Crossing the threshold is "concerning" behavior.
    case yellow // = 4

    /// Crossing the threshold is "emergency" behavior.
    case red // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 4: self = .yellow
      case 6: self = .red
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .yellow: return 4
      case .red: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Whether the threshold is considered crossed by an actual value above or
  /// below its threshold value.
  public enum Direction: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not allowed in well-formed requests.
    case unspecified // = 0

    /// The threshold will be considered crossed if the actual value is above
    /// the threshold value.
    case above // = 1

    /// The threshold will be considered crossed if the actual value is below
    /// the threshold value.
    case below // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .above
      case 2: self = .below
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .above: return 1
      case .below: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Monitoring_Dashboard_V1_Threshold.Color: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_Dashboard_V1_Threshold.Color] = [
    .unspecified,
    .yellow,
    .red,
  ]
}

extension Google_Monitoring_Dashboard_V1_Threshold.Direction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Monitoring_Dashboard_V1_Threshold.Direction] = [
    .unspecified,
    .above,
    .below,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.monitoring.dashboard.v1"

extension Google_Monitoring_Dashboard_V1_SparkChartType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPARK_CHART_TYPE_UNSPECIFIED"),
    1: .same(proto: "SPARK_LINE"),
    2: .same(proto: "SPARK_BAR"),
  ]
}

extension Google_Monitoring_Dashboard_V1_TimeSeriesQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeriesQuery"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_series_filter"),
    2: .standard(proto: "time_series_filter_ratio"),
    3: .standard(proto: "time_series_query_language"),
    5: .standard(proto: "unit_override"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Monitoring_Dashboard_V1_TimeSeriesFilter?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .timeSeriesFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .timeSeriesFilter(v)}
      }()
      case 2: try {
        var v: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .timeSeriesFilterRatio(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .timeSeriesFilterRatio(v)}
      }()
      case 3: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .timeSeriesQueryLanguage(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.unitOverride) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .timeSeriesFilter?: try {
      guard case .timeSeriesFilter(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .timeSeriesFilterRatio?: try {
      guard case .timeSeriesFilterRatio(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .timeSeriesQueryLanguage?: try {
      guard case .timeSeriesQueryLanguage(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.unitOverride.isEmpty {
      try visitor.visitSingularStringField(value: self.unitOverride, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesQuery, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesQuery) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unitOverride != rhs.unitOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_Dashboard_V1_TimeSeriesFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeriesFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "aggregation"),
    3: .standard(proto: "secondary_aggregation"),
    4: .standard(proto: "pick_time_series_filter"),
    5: .standard(proto: "statistical_time_series_filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._aggregation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._secondaryAggregation) }()
      case 4: try {
        var v: Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter?
        if let current = self.outputFilter {
          try decoder.handleConflictingOneOf()
          if case .pickTimeSeriesFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.outputFilter = .pickTimeSeriesFilter(v)}
      }()
      case 5: try {
        var v: Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter?
        if let current = self.outputFilter {
          try decoder.handleConflictingOneOf()
          if case .statisticalTimeSeriesFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.outputFilter = .statisticalTimeSeriesFilter(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 1)
    }
    if let v = self._aggregation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._secondaryAggregation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.outputFilter {
    case .pickTimeSeriesFilter?: try {
      guard case .pickTimeSeriesFilter(let v)? = self.outputFilter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .statisticalTimeSeriesFilter?: try {
      guard case .statisticalTimeSeriesFilter(let v)? = self.outputFilter else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilter, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilter) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs._aggregation != rhs._aggregation {return false}
    if lhs._secondaryAggregation != rhs._secondaryAggregation {return false}
    if lhs.outputFilter != rhs.outputFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSeriesFilterRatio"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "numerator"),
    2: .same(proto: "denominator"),
    3: .standard(proto: "secondary_aggregation"),
    4: .standard(proto: "pick_time_series_filter"),
    5: .standard(proto: "statistical_time_series_filter"),
  ]

  fileprivate class _StorageClass {
    var _numerator: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart? = nil
    var _denominator: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart? = nil
    var _secondaryAggregation: Google_Monitoring_Dashboard_V1_Aggregation? = nil
    var _outputFilter: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.OneOf_OutputFilter?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _numerator = source._numerator
      _denominator = source._denominator
      _secondaryAggregation = source._secondaryAggregation
      _outputFilter = source._outputFilter
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._numerator) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._denominator) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._secondaryAggregation) }()
        case 4: try {
          var v: Google_Monitoring_Dashboard_V1_PickTimeSeriesFilter?
          if let current = _storage._outputFilter {
            try decoder.handleConflictingOneOf()
            if case .pickTimeSeriesFilter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._outputFilter = .pickTimeSeriesFilter(v)}
        }()
        case 5: try {
          var v: Google_Monitoring_Dashboard_V1_StatisticalTimeSeriesFilter?
          if let current = _storage._outputFilter {
            try decoder.handleConflictingOneOf()
            if case .statisticalTimeSeriesFilter(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._outputFilter = .statisticalTimeSeriesFilter(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._numerator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._denominator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._secondaryAggregation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._outputFilter {
      case .pickTimeSeriesFilter?: try {
        guard case .pickTimeSeriesFilter(let v)? = _storage._outputFilter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .statisticalTimeSeriesFilter?: try {
        guard case .statisticalTimeSeriesFilter(let v)? = _storage._outputFilter else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._numerator != rhs_storage._numerator {return false}
        if _storage._denominator != rhs_storage._denominator {return false}
        if _storage._secondaryAggregation != rhs_storage._secondaryAggregation {return false}
        if _storage._outputFilter != rhs_storage._outputFilter {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.protoMessageName + ".RatioPart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "aggregation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._aggregation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 1)
    }
    if let v = self._aggregation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart, rhs: Google_Monitoring_Dashboard_V1_TimeSeriesFilterRatio.RatioPart) -> Bool {
    if lhs.filter != rhs.filter {return false}
    if lhs._aggregation != rhs._aggregation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_Dashboard_V1_Threshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Threshold"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "value"),
    3: .same(proto: "color"),
    4: .same(proto: "direction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.color) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularDoubleField(value: self.value, fieldNumber: 2)
    }
    if self.color != .unspecified {
      try visitor.visitSingularEnumField(value: self.color, fieldNumber: 3)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Monitoring_Dashboard_V1_Threshold, rhs: Google_Monitoring_Dashboard_V1_Threshold) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.value != rhs.value {return false}
    if lhs.color != rhs.color {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Monitoring_Dashboard_V1_Threshold.Color: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COLOR_UNSPECIFIED"),
    4: .same(proto: "YELLOW"),
    6: .same(proto: "RED"),
  ]
}

extension Google_Monitoring_Dashboard_V1_Threshold.Direction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTION_UNSPECIFIED"),
    1: .same(proto: "ABOVE"),
    2: .same(proto: "BELOW"),
  ]
}

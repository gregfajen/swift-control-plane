// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/resultstore/v2/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// These correspond to the prefix of the rule name. Eg cc_test has language CC.
public enum Google_Devtools_Resultstore_V2_Language: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Language unspecified or not listed here.
  case unspecified // = 0

  /// Not related to any particular language
  case none // = 1

  /// Android
  case android // = 2

  /// ActionScript (Flash)
  case `as` // = 3

  /// C++ or C
  case cc // = 4

  /// Cascading-Style-Sheets
  case css // = 5

  /// Dart
  case dart // = 6

  /// Go
  case go // = 7

  /// Google-Web-Toolkit
  case gwt // = 8

  /// Haskell
  case haskell // = 9

  /// Java
  case java // = 10

  /// Javascript
  case js // = 11

  /// Lisp
  case lisp // = 12

  /// Objective-C
  case objc // = 13

  /// Python
  case py // = 14

  /// Shell (Typically Bash)
  case sh // = 15

  /// Swift
  case swift // = 16

  /// Typescript
  case ts // = 18

  /// Webtesting
  case web // = 19

  /// Scala
  case scala // = 20

  /// Protocol Buffer
  case proto // = 21

  /// Extensible Markup Language
  case xml // = 22
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .none
    case 2: self = .android
    case 3: self = .as
    case 4: self = .cc
    case 5: self = .css
    case 6: self = .dart
    case 7: self = .go
    case 8: self = .gwt
    case 9: self = .haskell
    case 10: self = .java
    case 11: self = .js
    case 12: self = .lisp
    case 13: self = .objc
    case 14: self = .py
    case 15: self = .sh
    case 16: self = .swift
    case 18: self = .ts
    case 19: self = .web
    case 20: self = .scala
    case 21: self = .proto
    case 22: self = .xml
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .none: return 1
    case .android: return 2
    case .as: return 3
    case .cc: return 4
    case .css: return 5
    case .dart: return 6
    case .go: return 7
    case .gwt: return 8
    case .haskell: return 9
    case .java: return 10
    case .js: return 11
    case .lisp: return 12
    case .objc: return 13
    case .py: return 14
    case .sh: return 15
    case .swift: return 16
    case .ts: return 18
    case .web: return 19
    case .scala: return 20
    case .proto: return 21
    case .xml: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_Language: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_Language] = [
    .unspecified,
    .none,
    .android,
    .as,
    .cc,
    .css,
    .dart,
    .go,
    .gwt,
    .haskell,
    .java,
    .js,
    .lisp,
    .objc,
    .py,
    .sh,
    .swift,
    .ts,
    .web,
    .scala,
    .proto,
    .xml,
  ]
}

#endif  // swift(>=4.2)

/// Status of a resource.
public enum Google_Devtools_Resultstore_V2_Status: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The implicit default enum value. Should never be set.
  case unspecified // = 0

  /// Displays as "Building". Means the target is compiling, linking, etc.
  case building // = 1

  /// Displays as "Built". Means the target was built successfully.
  /// If testing was requested, it should never reach this status: it should go
  /// straight from BUILDING to TESTING.
  case built // = 2

  /// Displays as "Broken". Means build failure such as compile error.
  case failedToBuild // = 3

  /// Displays as "Testing". Means the test is running.
  case testing // = 4

  /// Displays as "Passed". Means the test was run and passed.
  case passed // = 5

  /// Displays as "Failed". Means the test was run and failed.
  case failed // = 6

  /// Displays as "Timed out". Means the test didn't finish in time.
  case timedOut // = 7

  /// Displays as "Cancelled". Means the build or test was cancelled.
  /// E.g. User hit control-C.
  case cancelled // = 8

  /// Displays as "Tool Failed". Means the build or test had internal tool
  /// failure.
  case toolFailed // = 9

  /// Displays as "Incomplete". Means the build or test did not complete.  This
  /// might happen when a build breakage or test failure causes the tool to stop
  /// trying to build anything more or run any more tests, with the default
  /// bazel --nokeep_going option or the --notest_keep_going option.
  case incomplete // = 10

  /// Displays as "Flaky". Means the aggregate status contains some runs that
  /// were successful, and some that were not.
  case flaky // = 11

  /// Displays as "Unknown". Means the tool uploading to the server died
  /// mid-upload or does not know the state.
  case unknown // = 12

  /// Displays as "Skipped". Means building and testing were skipped.
  /// (E.g. Restricted to a different configuration.)
  case skipped // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .building
    case 2: self = .built
    case 3: self = .failedToBuild
    case 4: self = .testing
    case 5: self = .passed
    case 6: self = .failed
    case 7: self = .timedOut
    case 8: self = .cancelled
    case 9: self = .toolFailed
    case 10: self = .incomplete
    case 11: self = .flaky
    case 12: self = .unknown
    case 13: self = .skipped
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .building: return 1
    case .built: return 2
    case .failedToBuild: return 3
    case .testing: return 4
    case .passed: return 5
    case .failed: return 6
    case .timedOut: return 7
    case .cancelled: return 8
    case .toolFailed: return 9
    case .incomplete: return 10
    case .flaky: return 11
    case .unknown: return 12
    case .skipped: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_Status] = [
    .unspecified,
    .building,
    .built,
    .failedToBuild,
    .testing,
    .passed,
    .failed,
    .timedOut,
    .cancelled,
    .toolFailed,
    .incomplete,
    .flaky,
    .unknown,
    .skipped,
  ]
}

#endif  // swift(>=4.2)

/// Indicates the upload status of the invocation, whether it is
/// post-processing, or immutable, etc.
public enum Google_Devtools_Resultstore_V2_UploadStatus: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The implicit default enum value. Should never be set.
  case unspecified // = 0

  /// The invocation is still uploading to the ResultStore.
  case uploading // = 1

  /// The invocation upload is complete. The ResultStore is still post-processing
  /// the invocation.
  case postProcessing // = 2

  /// All post-processing is complete, and the invocation is now immutable.
  case immutable // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .uploading
    case 2: self = .postProcessing
    case 3: self = .immutable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .uploading: return 1
    case .postProcessing: return 2
    case .immutable: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_UploadStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_UploadStatus] = [
    .unspecified,
    .uploading,
    .postProcessing,
    .immutable,
  ]
}

#endif  // swift(>=4.2)

/// Describes the status of a resource in both enum and string form.
/// Only use description when conveying additional info not captured in the enum
/// name.
public struct Google_Devtools_Resultstore_V2_StatusAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enum representation of the status.
  public var status: Google_Devtools_Resultstore_V2_Status = .unspecified

  /// A longer description about the status.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A generic key-value property definition.
public struct Google_Devtools_Resultstore_V2_Property {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The key.
  public var key: String = String()

  /// The value.
  public var value: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The timing of a particular Invocation, Action, etc. The start_time is
/// specified, stop time can be calculated by adding duration to start_time.
public struct Google_Devtools_Resultstore_V2_Timing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time the resource started running. This is in UTC Epoch time.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The duration for which the resource ran.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Represents a dependency of a resource on another resource. This can be used
/// to define a graph or a workflow paradigm through resources.
public struct Google_Devtools_Resultstore_V2_Dependency {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource depended upon. It may be a Target, ConfiguredTarget, or
  /// Action.
  public var resource: Google_Devtools_Resultstore_V2_Dependency.OneOf_Resource? = nil

  /// The name of a target.  Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  /// This must point to an target under the same invocation.
  public var target: String {
    get {
      if case .target(let v)? = resource {return v}
      return String()
    }
    set {resource = .target(newValue)}
  }

  /// The name of a configured target.  Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
  /// This must point to an configured target under the same invocation.
  public var configuredTarget: String {
    get {
      if case .configuredTarget(let v)? = resource {return v}
      return String()
    }
    set {resource = .configuredTarget(newValue)}
  }

  /// The name of an action.  Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}/actions/${url_encode(ACTION_ID)}
  /// This must point to an action under the same invocation.
  public var action: String {
    get {
      if case .action(let v)? = resource {return v}
      return String()
    }
    set {resource = .action(newValue)}
  }

  /// A label describing this dependency.
  /// The label "Root Cause" is handled specially. It is used to point to the
  /// exact resource that caused a resource to fail.
  public var label: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The resource depended upon. It may be a Target, ConfiguredTarget, or
  /// Action.
  public enum OneOf_Resource: Equatable {
    /// The name of a target.  Its format must be:
    /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
    /// This must point to an target under the same invocation.
    case target(String)
    /// The name of a configured target.  Its format must be:
    /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
    /// This must point to an configured target under the same invocation.
    case configuredTarget(String)
    /// The name of an action.  Its format must be:
    /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}/actions/${url_encode(ACTION_ID)}
    /// This must point to an action under the same invocation.
    case action(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_Dependency.OneOf_Resource, rhs: Google_Devtools_Resultstore_V2_Dependency.OneOf_Resource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.target, .target): return {
        guard case .target(let l) = lhs, case .target(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuredTarget, .configuredTarget): return {
        guard case .configuredTarget(let l) = lhs, case .configuredTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.resultstore.v2"

extension Google_Devtools_Resultstore_V2_Language: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LANGUAGE_UNSPECIFIED"),
    1: .same(proto: "NONE"),
    2: .same(proto: "ANDROID"),
    3: .same(proto: "AS"),
    4: .same(proto: "CC"),
    5: .same(proto: "CSS"),
    6: .same(proto: "DART"),
    7: .same(proto: "GO"),
    8: .same(proto: "GWT"),
    9: .same(proto: "HASKELL"),
    10: .same(proto: "JAVA"),
    11: .same(proto: "JS"),
    12: .same(proto: "LISP"),
    13: .same(proto: "OBJC"),
    14: .same(proto: "PY"),
    15: .same(proto: "SH"),
    16: .same(proto: "SWIFT"),
    18: .same(proto: "TS"),
    19: .same(proto: "WEB"),
    20: .same(proto: "SCALA"),
    21: .same(proto: "PROTO"),
    22: .same(proto: "XML"),
  ]
}

extension Google_Devtools_Resultstore_V2_Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "BUILDING"),
    2: .same(proto: "BUILT"),
    3: .same(proto: "FAILED_TO_BUILD"),
    4: .same(proto: "TESTING"),
    5: .same(proto: "PASSED"),
    6: .same(proto: "FAILED"),
    7: .same(proto: "TIMED_OUT"),
    8: .same(proto: "CANCELLED"),
    9: .same(proto: "TOOL_FAILED"),
    10: .same(proto: "INCOMPLETE"),
    11: .same(proto: "FLAKY"),
    12: .same(proto: "UNKNOWN"),
    13: .same(proto: "SKIPPED"),
  ]
}

extension Google_Devtools_Resultstore_V2_UploadStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPLOAD_STATUS_UNSPECIFIED"),
    1: .same(proto: "UPLOADING"),
    2: .same(proto: "POST_PROCESSING"),
    3: .same(proto: "IMMUTABLE"),
  ]
}

extension Google_Devtools_Resultstore_V2_StatusAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusAttributes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_StatusAttributes, rhs: Google_Devtools_Resultstore_V2_StatusAttributes) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_Property: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Property"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Property, rhs: Google_Devtools_Resultstore_V2_Property) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_Timing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Timing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Timing, rhs: Google_Devtools_Resultstore_V2_Timing) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_Dependency: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dependency"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .standard(proto: "configured_target"),
    3: .same(proto: "action"),
    4: .same(proto: "label"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.resource != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.resource = .target(v)}
      }()
      case 2: try {
        if self.resource != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.resource = .configuredTarget(v)}
      }()
      case 3: try {
        if self.resource != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.resource = .action(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.resource {
    case .target?: try {
      guard case .target(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .configuredTarget?: try {
      guard case .configuredTarget(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .action?: try {
      guard case .action(let v)? = self.resource else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Dependency, rhs: Google_Devtools_Resultstore_V2_Dependency) -> Bool {
    if lhs.resource != rhs.resource {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

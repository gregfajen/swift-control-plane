// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/resultstore/v2/test_suite.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The result of running a test suite, as reported in a <testsuite> element of
/// an XML log.
public struct Google_Devtools_Resultstore_V2_TestSuite {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The full name of this suite, as reported in the name attribute. For Java
  /// tests, this is normally the fully qualified class name. Eg.
  /// "com.google.common.hash.BloomFilterTest".
  public var suiteName: String = String()

  /// The results of the test cases and test suites contained in this suite,
  /// as reported in the <testcase> and <testsuite> elements contained within
  /// this <testsuite>.
  public var tests: [Google_Devtools_Resultstore_V2_Test] = []

  /// Failures reported in <failure> elements within this <testsuite>.
  public var failures: [Google_Devtools_Resultstore_V2_TestFailure] = []

  /// Errors reported in <error> elements within this <testsuite>.
  public var errors: [Google_Devtools_Resultstore_V2_TestError] = []

  /// The timing for the entire TestSuite, as reported by the time attribute.
  public var timing: Google_Devtools_Resultstore_V2_Timing {
    get {return _timing ?? Google_Devtools_Resultstore_V2_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Arbitrary name-value pairs, as reported in custom attributes or in a
  /// <properties> element within this <testsuite>. Multiple properties are
  /// allowed with the same key. Properties will be returned in lexicographical
  /// order by key.
  public var properties: [Google_Devtools_Resultstore_V2_Property] = []

  /// Files produced by this test suite, as reported by undeclared output
  /// annotations.
  /// The file IDs must be unique within this list. Duplicate file IDs will
  /// result in an error. Files will be returned in lexicographical order by ID.
  public var files: [Google_Devtools_Resultstore_V2_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _timing: Google_Devtools_Resultstore_V2_Timing? = nil
}

/// The result of running a test case or test suite. JUnit3 TestDecorators are
/// represented as a TestSuite with a single test.
public struct Google_Devtools_Resultstore_V2_Test {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Either a TestCase of a TestSuite
  public var testType: Google_Devtools_Resultstore_V2_Test.OneOf_TestType? = nil

  /// When this contains just a single TestCase
  public var testCase: Google_Devtools_Resultstore_V2_TestCase {
    get {
      if case .testCase(let v)? = testType {return v}
      return Google_Devtools_Resultstore_V2_TestCase()
    }
    set {testType = .testCase(newValue)}
  }

  /// When this contains a TestSuite of test cases.
  public var testSuite: Google_Devtools_Resultstore_V2_TestSuite {
    get {
      if case .testSuite(let v)? = testType {return v}
      return Google_Devtools_Resultstore_V2_TestSuite()
    }
    set {testType = .testSuite(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Either a TestCase of a TestSuite
  public enum OneOf_TestType: Equatable {
    /// When this contains just a single TestCase
    case testCase(Google_Devtools_Resultstore_V2_TestCase)
    /// When this contains a TestSuite of test cases.
    case testSuite(Google_Devtools_Resultstore_V2_TestSuite)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_Test.OneOf_TestType, rhs: Google_Devtools_Resultstore_V2_Test.OneOf_TestType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.testCase, .testCase): return {
        guard case .testCase(let l) = lhs, case .testCase(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testSuite, .testSuite): return {
        guard case .testSuite(let l) = lhs, case .testSuite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The result of running a test case, as reported in a <testcase> element of
/// an XML log.
public struct Google_Devtools_Resultstore_V2_TestCase {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the test case, as reported in the name attribute. For Java,
  /// this is normally the method name. Eg. "testBasic".
  public var caseName: String = String()

  /// The name of the class in which the test case was defined, as reported in
  /// the classname attribute. For Java, this is normally the fully qualified
  /// class name. Eg. "com.google.common.hash.BloomFilterTest".
  public var className: String = String()

  /// An enum reported in the result attribute that is used in conjunction with
  /// failures and errors below to report the outcome.
  public var result: Google_Devtools_Resultstore_V2_TestCase.Result = .unspecified

  /// Failures reported in <failure> elements within this <testcase>.
  public var failures: [Google_Devtools_Resultstore_V2_TestFailure] = []

  /// Errors reported in <error> elements within this <testcase>.
  public var errors: [Google_Devtools_Resultstore_V2_TestError] = []

  /// The timing for the TestCase, as reported by the time attribute.
  public var timing: Google_Devtools_Resultstore_V2_Timing {
    get {return _timing ?? Google_Devtools_Resultstore_V2_Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {self._timing = nil}

  /// Arbitrary name-value pairs, as reported in custom attributes or in a
  /// <properties> element within this <testcase>. Multiple properties are
  /// allowed with the same key. Properties will be returned in lexicographical
  /// order by key.
  public var properties: [Google_Devtools_Resultstore_V2_Property] = []

  /// Files produced by this test case, as reported by undeclared output
  /// annotations.
  /// The file IDs must be unique within this list. Duplicate file IDs will
  /// result in an error. Files will be returned in lexicographical order by ID.
  public var files: [Google_Devtools_Resultstore_V2_File] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The result of running a test case.
  public enum Result: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The implicit default enum value. Do not use.
    case unspecified // = 0

    /// Test case ran to completion. Look for failures or errors to determine
    /// whether it passed, failed, or errored.
    case completed // = 1

    /// Test case started but did not complete because the test harness received
    /// a signal and decided to stop running tests.
    case interrupted // = 2

    /// Test case was not started because the test harness received a SIGINT or
    /// timed out.
    case cancelled // = 3

    /// Test case was not run because the user or process running the test
    /// specified a filter that excluded this test case.
    case filtered // = 4

    /// Test case was not run to completion because the test case decided it
    /// should not be run (eg. due to a failed assumption in a JUnit4 test).
    /// Per-test setup or tear-down may or may not have run.
    case skipped // = 5

    /// The test framework did not run the test case because it was labeled as
    /// suppressed.  Eg. if someone temporarily disables a failing test.
    case suppressed // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .completed
      case 2: self = .interrupted
      case 3: self = .cancelled
      case 4: self = .filtered
      case 5: self = .skipped
      case 6: self = .suppressed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .completed: return 1
      case .interrupted: return 2
      case .cancelled: return 3
      case .filtered: return 4
      case .skipped: return 5
      case .suppressed: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _timing: Google_Devtools_Resultstore_V2_Timing? = nil
}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_TestCase.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_TestCase.Result] = [
    .unspecified,
    .completed,
    .interrupted,
    .cancelled,
    .filtered,
    .skipped,
    .suppressed,
  ]
}

#endif  // swift(>=4.2)

/// Represents a violated assertion, as reported in a <failure> element within a
/// <testcase>. Some languages allow assertions to be made without stopping the
/// test case when they're violated, leading to multiple TestFailures. For Java,
/// multiple TestFailures are used to represent a chained exception.
public struct Google_Devtools_Resultstore_V2_TestFailure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The exception message reported in the message attribute. Typically short,
  /// but may be multi-line. Eg. "Expected 'foo' but was 'bar'".
  public var failureMessage: String = String()

  /// The type of the exception being thrown, reported in the type attribute.
  /// Eg: "org.junit.ComparisonFailure"
  public var exceptionType: String = String()

  /// The stack trace reported as the content of the <failure> element, often in
  /// a CDATA block. This contains one line for each stack frame, each including
  /// a method/function name, a class/file name, and a line number. Most recent
  /// call is usually first, but not for Python stack traces. May contain the
  /// exception_type and message.
  public var stackTrace: String = String()

  /// The expected values.
  ///
  /// These values can be diffed against the actual values. Often, there is just
  /// one actual and one expected value. If there is more than one, they should
  /// be compared as an unordered collection.
  public var expected: [String] = []

  /// The actual values.
  ///
  /// These values can be diffed against the expected values. Often, there is
  /// just one actual and one expected value. If there is more than one, they
  /// should be compared as an unordered collection.
  public var actual: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents an exception that prevented a test case from completing, as
/// reported in an <error> element within a <testcase>. For Java, multiple
/// TestErrors are used to represent a chained exception.
public struct Google_Devtools_Resultstore_V2_TestError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The exception message, as reported in the message attribute. Typically
  /// short, but may be multi-line. Eg. "argument cannot be null".
  public var errorMessage: String = String()

  /// The type of the exception being thrown, reported in the type attribute.
  /// For Java, this is a fully qualified Throwable class name.
  /// Eg: "java.lang.IllegalArgumentException"
  public var exceptionType: String = String()

  /// The stack trace reported as the content of the <error> element, often in
  /// a CDATA block. This contains one line for each stack frame, each including
  /// a method/function name, a class/file name, and a line number. Most recent
  /// call is usually first, but not for Python stack traces. May contain the
  /// exception_type and message.
  public var stackTrace: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.resultstore.v2"

extension Google_Devtools_Resultstore_V2_TestSuite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestSuite"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suite_name"),
    2: .same(proto: "tests"),
    3: .same(proto: "failures"),
    4: .same(proto: "errors"),
    6: .same(proto: "timing"),
    7: .same(proto: "properties"),
    8: .same(proto: "files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suiteName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.tests) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suiteName.isEmpty {
      try visitor.visitSingularStringField(value: self.suiteName, fieldNumber: 1)
    }
    if !self.tests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.tests, fieldNumber: 2)
    }
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 3)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 4)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 7)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestSuite, rhs: Google_Devtools_Resultstore_V2_TestSuite) -> Bool {
    if lhs.suiteName != rhs.suiteName {return false}
    if lhs.tests != rhs.tests {return false}
    if lhs.failures != rhs.failures {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_Test: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Test"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_case"),
    2: .standard(proto: "test_suite"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Devtools_Resultstore_V2_TestCase?
        if let current = self.testType {
          try decoder.handleConflictingOneOf()
          if case .testCase(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.testType = .testCase(v)}
      }()
      case 2: try {
        var v: Google_Devtools_Resultstore_V2_TestSuite?
        if let current = self.testType {
          try decoder.handleConflictingOneOf()
          if case .testSuite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.testType = .testSuite(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.testType {
    case .testCase?: try {
      guard case .testCase(let v)? = self.testType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .testSuite?: try {
      guard case .testSuite(let v)? = self.testType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Test, rhs: Google_Devtools_Resultstore_V2_Test) -> Bool {
    if lhs.testType != rhs.testType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TestCase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestCase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "case_name"),
    2: .standard(proto: "class_name"),
    3: .same(proto: "result"),
    4: .same(proto: "failures"),
    5: .same(proto: "errors"),
    7: .same(proto: "timing"),
    8: .same(proto: "properties"),
    9: .same(proto: "files"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.caseName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.className) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.errors) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.properties) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.caseName.isEmpty {
      try visitor.visitSingularStringField(value: self.caseName, fieldNumber: 1)
    }
    if !self.className.isEmpty {
      try visitor.visitSingularStringField(value: self.className, fieldNumber: 2)
    }
    if self.result != .unspecified {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 3)
    }
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 4)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.errors, fieldNumber: 5)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.properties.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.properties, fieldNumber: 8)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestCase, rhs: Google_Devtools_Resultstore_V2_TestCase) -> Bool {
    if lhs.caseName != rhs.caseName {return false}
    if lhs.className != rhs.className {return false}
    if lhs.result != rhs.result {return false}
    if lhs.failures != rhs.failures {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.properties != rhs.properties {return false}
    if lhs.files != rhs.files {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TestCase.Result: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNSPECIFIED"),
    1: .same(proto: "COMPLETED"),
    2: .same(proto: "INTERRUPTED"),
    3: .same(proto: "CANCELLED"),
    4: .same(proto: "FILTERED"),
    5: .same(proto: "SKIPPED"),
    6: .same(proto: "SUPPRESSED"),
  ]
}

extension Google_Devtools_Resultstore_V2_TestFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestFailure"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "failure_message"),
    2: .standard(proto: "exception_type"),
    3: .standard(proto: "stack_trace"),
    4: .same(proto: "expected"),
    5: .same(proto: "actual"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.failureMessage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exceptionType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.expected) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.actual) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failureMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.failureMessage, fieldNumber: 1)
    }
    if !self.exceptionType.isEmpty {
      try visitor.visitSingularStringField(value: self.exceptionType, fieldNumber: 2)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 3)
    }
    if !self.expected.isEmpty {
      try visitor.visitRepeatedStringField(value: self.expected, fieldNumber: 4)
    }
    if !self.actual.isEmpty {
      try visitor.visitRepeatedStringField(value: self.actual, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestFailure, rhs: Google_Devtools_Resultstore_V2_TestFailure) -> Bool {
    if lhs.failureMessage != rhs.failureMessage {return false}
    if lhs.exceptionType != rhs.exceptionType {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.expected != rhs.expected {return false}
    if lhs.actual != rhs.actual {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TestError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "error_message"),
    2: .standard(proto: "exception_type"),
    3: .standard(proto: "stack_trace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.exceptionType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stackTrace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 1)
    }
    if !self.exceptionType.isEmpty {
      try visitor.visitSingularStringField(value: self.exceptionType, fieldNumber: 2)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestError, rhs: Google_Devtools_Resultstore_V2_TestError) -> Bool {
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.exceptionType != rhs.exceptionType {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

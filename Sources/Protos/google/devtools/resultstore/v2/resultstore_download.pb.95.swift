// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/resultstore/v2/resultstore_download.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request passed into GetInvocation
public struct Google_Devtools_Resultstore_V2_GetInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the invocation to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}
  /// where INVOCATION_ID must be an RFC 4122-compliant random UUID.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into SearchInvocations
public struct Google_Devtools_Resultstore_V2_SearchInvocationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The maximum number of items to return. Zero means all, but may be capped by
  /// the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_SearchInvocationsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous Search request, if
  /// any.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip. May be rejected if too high.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  /// A filtering query string.
  ///
  /// Only a limited number of fields and operators are supported. Not every
  /// field supports every operator.
  ///
  /// Fields that support equals ("=") restrictions:
  ///
  /// name
  /// status_attributes.status
  /// workspace_info.hostname
  ///
  /// Fields that support contains (":") restrictions:
  ///
  /// invocation_attributes.users
  /// invocation_attributes.labels
  ///
  /// Fields that support comparison ("<", "<=", ">", ">=") restrictions;
  ///
  /// timing.start_time
  ///
  /// Supported custom function global restrictions:
  ///
  /// propertyEquals("key", "value")
  public var query: String = String()

  /// The project id to search under.
  public var projectID: String = String()

  /// If true, all equals or contains restrictions on string fields in query will
  /// require exact match. Otherwise, a string field restriction may ignore case
  /// and punctuation.
  public var exactMatch: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous Search request, if
    /// any.
    case pageToken(String)
    /// Absolute number of results to skip. May be rejected if too high.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_SearchInvocationsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_SearchInvocationsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling SearchInvocations
public struct Google_Devtools_Resultstore_V2_SearchInvocationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Invocations matching the search, possibly capped at request.page_size or a
  /// server limit.
  public var invocations: [Google_Devtools_Resultstore_V2_Invocation] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into GetInvocationDownloadMetadata
public struct Google_Devtools_Resultstore_V2_GetInvocationDownloadMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the download metadata to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}/downloadMetadata
  /// where INVOCATION_ID must be an RFC 4122-compliant random UUID.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into GetConfiguration
public struct Google_Devtools_Resultstore_V2_GetConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the configuration to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}/configs/${url_encode(CONFIGURATION_ID)}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into ListConfigurations
public struct Google_Devtools_Resultstore_V2_ListConfigurationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The invocation name of the configurations to retrieve.
  /// It must match this format: invocations/${INVOCATION_ID}
  public var parent: String = String()

  /// The maximum number of items to return.
  /// Zero means all, but may be capped by the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_ListConfigurationsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous List request, if any.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  /// A filter to return only resources that match it.
  /// Any fields used in the filter must be also specified in the field mask.
  /// May cause pages with 0 results and a next_page_token to be returned.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous List request, if any.
    case pageToken(String)
    /// Absolute number of results to skip.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_ListConfigurationsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_ListConfigurationsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling ListConfigurations
public struct Google_Devtools_Resultstore_V2_ListConfigurationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configurations matching the request invocation,
  /// possibly capped at request.page_size or a server limit.
  public var configurations: [Google_Devtools_Resultstore_V2_Configuration] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into GetTarget
public struct Google_Devtools_Resultstore_V2_GetTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the target to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into ListTargets
public struct Google_Devtools_Resultstore_V2_ListTargetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The invocation name of the targets to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}
  public var parent: String = String()

  /// The maximum number of items to return.
  /// Zero means all, but may be capped by the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_ListTargetsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous List request, if any.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  /// A filter to return only resources that match it.
  /// Any fields used in the filter must be also specified in the field mask.
  /// May cause pages with 0 results and a next_page_token to be returned.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous List request, if any.
    case pageToken(String)
    /// Absolute number of results to skip.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_ListTargetsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_ListTargetsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling ListTargetsResponse
public struct Google_Devtools_Resultstore_V2_ListTargetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Targets matching the request invocation,
  /// possibly capped at request.page_size or a server limit.
  public var targets: [Google_Devtools_Resultstore_V2_Target] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into GetConfiguredTarget
public struct Google_Devtools_Resultstore_V2_GetConfiguredTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the configured target to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIGURATION_ID)}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into ListConfiguredTargets
public struct Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The invocation and target name of the configured targets to retrieve.
  /// It must match this format:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  /// Supports '-' for ${TARGET_ID} meaning all targets.
  public var parent: String = String()

  /// The maximum number of items to return.
  /// Zero means all, but may be capped by the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous List request, if any.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  /// A filter to return only resources that match it.
  /// Any fields used in the filter must be also specified in the field mask.
  /// May cause pages with 0 results and a next_page_token to be returned.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous List request, if any.
    case pageToken(String)
    /// Absolute number of results to skip.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling ListConfiguredTargets
public struct Google_Devtools_Resultstore_V2_ListConfiguredTargetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ConfiguredTargets matching the request,
  /// possibly capped at request.page_size or a server limit.
  public var configuredTargets: [Google_Devtools_Resultstore_V2_ConfiguredTarget] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into GetAction
public struct Google_Devtools_Resultstore_V2_GetActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the action to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIGURATION_ID)}/actions/${url_encode(ACTION_ID)}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into ListActions
public struct Google_Devtools_Resultstore_V2_ListActionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The invocation, target, and configuration name of the action to retrieve.
  /// It must match this format:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIGURATION_ID)}
  /// Supports '-' for ${CONFIGURATION_ID} to mean all Actions for all
  /// Configurations for a Target, or '-' for ${TARGET_ID} and
  /// ${CONFIGURATION_ID} to mean all Actions for all Configurations and all
  /// Targets. Does not support ${TARGET_ID} '-' with a specified configuration.
  public var parent: String = String()

  /// The maximum number of items to return.
  /// Zero means all, but may be capped by the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_ListActionsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous List request, if any.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  /// A filter to return only resources that match it.
  /// Any fields used in the filter must be also specified in the field mask.
  /// May cause pages with 0 results and a next_page_token to be returned.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous List request, if any.
    case pageToken(String)
    /// Absolute number of results to skip.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_ListActionsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_ListActionsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling ListActions
public struct Google_Devtools_Resultstore_V2_ListActionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Actions matching the request,
  /// possibly capped at request.page_size or a server limit.
  public var actions: [Google_Devtools_Resultstore_V2_Action] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into GetFileSet
public struct Google_Devtools_Resultstore_V2_GetFileSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the file set to retrieve. It must match this format:
  /// invocations/${INVOCATION_ID}/fileSets/${url_encode(FILE_SET_ID)}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into ListFileSets
public struct Google_Devtools_Resultstore_V2_ListFileSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The invocation name of the file sets to retrieve.
  /// It must match this format: invocations/${INVOCATION_ID}
  public var parent: String = String()

  /// The maximum number of items to return.
  /// Zero means all, but may be capped by the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_ListFileSetsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous List request, if any.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  /// A filter to return only resources that match it.
  /// Any fields used in the filter must be also specified in the field mask.
  /// May cause pages with 0 results and a next_page_token to be returned.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous List request, if any.
    case pageToken(String)
    /// Absolute number of results to skip.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_ListFileSetsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_ListFileSetsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling ListFileSets
public struct Google_Devtools_Resultstore_V2_ListFileSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File sets matching the request,
  /// possibly capped at request.page_size or a server limit.
  public var fileSets: [Google_Devtools_Resultstore_V2_FileSet] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into TraverseFileSets
public struct Google_Devtools_Resultstore_V2_TraverseFileSetsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the resource to traverse.
  /// It must match one of the following formats:
  ///
  /// invocations/${INVOCATION_ID}/fileSets/${url_encode(FILE_SET_ID)}
  /// This returns the transitive closure of FileSets referenced by the given
  /// FileSet, including itself.
  ///
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIGURATION_ID)}/actions/${url_encode(ACTION_ID)}
  /// This returns the transitive closure of FileSets referenced by the given
  /// Action. If ${ACTION_ID} is "-", this returns the transitive closure of
  /// FileSets referenced by all Actions under the given ConfiguredTarget.
  public var name: String = String()

  /// The maximum number of items to return.
  /// Zero means all, but may be capped by the server.
  public var pageSize: Int32 = 0

  /// Options for pagination.
  public var pageStart: Google_Devtools_Resultstore_V2_TraverseFileSetsRequest.OneOf_PageStart? = nil

  /// The next_page_token value returned from a previous List request, if any.
  /// Page tokens will become larger with every page returned, and if a page
  /// token becomes too large, it will no longer be possible to continue to
  /// calculate the transitive dependencies. The API will return a 400
  /// Bad request (HTTPS), or a INVALID_ARGUMENT (gRPC ) when
  /// this happens.
  public var pageToken: String {
    get {
      if case .pageToken(let v)? = pageStart {return v}
      return String()
    }
    set {pageStart = .pageToken(newValue)}
  }

  /// Absolute number of results to skip.
  /// Not yet implemented. 0 for default.
  public var offset: Int64 {
    get {
      if case .offset(let v)? = pageStart {return v}
      return 0
    }
    set {pageStart = .offset(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options for pagination.
  public enum OneOf_PageStart: Equatable {
    /// The next_page_token value returned from a previous List request, if any.
    /// Page tokens will become larger with every page returned, and if a page
    /// token becomes too large, it will no longer be possible to continue to
    /// calculate the transitive dependencies. The API will return a 400
    /// Bad request (HTTPS), or a INVALID_ARGUMENT (gRPC ) when
    /// this happens.
    case pageToken(String)
    /// Absolute number of results to skip.
    /// Not yet implemented. 0 for default.
    case offset(Int64)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_TraverseFileSetsRequest.OneOf_PageStart, rhs: Google_Devtools_Resultstore_V2_TraverseFileSetsRequest.OneOf_PageStart) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pageToken, .pageToken): return {
        guard case .pageToken(let l) = lhs, case .pageToken(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offset, .offset): return {
        guard case .offset(let l) = lhs, case .offset(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Response from calling TraverseFileSets
public struct Google_Devtools_Resultstore_V2_TraverseFileSetsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// File sets matching the request.
  /// The order in which results are returned is undefined, but stable.
  public var fileSets: [Google_Devtools_Resultstore_V2_FileSet] = []

  /// Token to retrieve the next page of results, or empty if there are no
  /// more results in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.resultstore.v2"

extension Google_Devtools_Resultstore_V2_GetInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetInvocationRequest, rhs: Google_Devtools_Resultstore_V2_GetInvocationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_SearchInvocationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchInvocationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_size"),
    2: .standard(proto: "page_token"),
    3: .same(proto: "offset"),
    4: .same(proto: "query"),
    5: .standard(proto: "project_id"),
    7: .standard(proto: "exact_match"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.exactMatch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 5)
    }
    if self.exactMatch != false {
      try visitor.visitSingularBoolField(value: self.exactMatch, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_SearchInvocationsRequest, rhs: Google_Devtools_Resultstore_V2_SearchInvocationsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.query != rhs.query {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.exactMatch != rhs.exactMatch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_SearchInvocationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SearchInvocationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "invocations"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.invocations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invocations, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_SearchInvocationsResponse, rhs: Google_Devtools_Resultstore_V2_SearchInvocationsResponse) -> Bool {
    if lhs.invocations != rhs.invocations {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetInvocationDownloadMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInvocationDownloadMetadataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetInvocationDownloadMetadataRequest, rhs: Google_Devtools_Resultstore_V2_GetInvocationDownloadMetadataRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfigurationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetConfigurationRequest, rhs: Google_Devtools_Resultstore_V2_GetConfigurationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListConfigurationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConfigurationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "offset"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 4: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListConfigurationsRequest, rhs: Google_Devtools_Resultstore_V2_ListConfigurationsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListConfigurationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConfigurationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "configurations"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configurations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configurations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configurations, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListConfigurationsResponse, rhs: Google_Devtools_Resultstore_V2_ListConfigurationsResponse) -> Bool {
    if lhs.configurations != rhs.configurations {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetTargetRequest, rhs: Google_Devtools_Resultstore_V2_GetTargetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListTargetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTargetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "offset"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 4: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListTargetsRequest, rhs: Google_Devtools_Resultstore_V2_ListTargetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListTargetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTargetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "targets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.targets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.targets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListTargetsResponse, rhs: Google_Devtools_Resultstore_V2_ListTargetsResponse) -> Bool {
    if lhs.targets != rhs.targets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetConfiguredTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConfiguredTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetConfiguredTargetRequest, rhs: Google_Devtools_Resultstore_V2_GetConfiguredTargetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConfiguredTargetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "offset"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 4: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest, rhs: Google_Devtools_Resultstore_V2_ListConfiguredTargetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListConfiguredTargetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConfiguredTargetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "configured_targets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.configuredTargets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.configuredTargets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.configuredTargets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListConfiguredTargetsResponse, rhs: Google_Devtools_Resultstore_V2_ListConfiguredTargetsResponse) -> Bool {
    if lhs.configuredTargets != rhs.configuredTargets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetActionRequest, rhs: Google_Devtools_Resultstore_V2_GetActionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListActionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "offset"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 4: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListActionsRequest, rhs: Google_Devtools_Resultstore_V2_ListActionsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListActionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "actions"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.actions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.actions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.actions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListActionsResponse, rhs: Google_Devtools_Resultstore_V2_ListActionsResponse) -> Bool {
    if lhs.actions != rhs.actions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetFileSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFileSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetFileSetRequest, rhs: Google_Devtools_Resultstore_V2_GetFileSetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListFileSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFileSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "offset"),
    5: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 4: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListFileSetsRequest, rhs: Google_Devtools_Resultstore_V2_ListFileSetsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ListFileSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListFileSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fileSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ListFileSetsResponse, rhs: Google_Devtools_Resultstore_V2_ListFileSetsResponse) -> Bool {
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TraverseFileSetsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraverseFileSetsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.pageStart = .pageToken(v)}
      }()
      case 4: try {
        if self.pageStart != nil {try decoder.handleConflictingOneOf()}
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {self.pageStart = .offset(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.pageStart {
    case .pageToken?: try {
      guard case .pageToken(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .offset?: try {
      guard case .offset(let v)? = self.pageStart else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TraverseFileSetsRequest, rhs: Google_Devtools_Resultstore_V2_TraverseFileSetsRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageStart != rhs.pageStart {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TraverseFileSetsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraverseFileSetsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_sets"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fileSets) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileSets, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TraverseFileSetsResponse, rhs: Google_Devtools_Resultstore_V2_TraverseFileSetsResponse) -> Bool {
    if lhs.fileSets != rhs.fileSets {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

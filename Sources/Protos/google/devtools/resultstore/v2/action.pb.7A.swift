// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/resultstore/v2/action.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicates how/where this Action was executed.
public enum Google_Devtools_Resultstore_V2_ExecutionStrategy: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The action did not indicate how it was executed.
  case unspecified // = 0

  /// The action was executed in some other form.
  case otherEnvironment // = 1

  /// The action used a remote build service.
  case remoteService // = 2

  /// The action was executed locally, in parallel with other actions.
  case localParallel // = 3

  /// The action was executed locally, without parallelism.
  case localSequential // = 4
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .otherEnvironment
    case 2: self = .remoteService
    case 3: self = .localParallel
    case 4: self = .localSequential
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .otherEnvironment: return 1
    case .remoteService: return 2
    case .localParallel: return 3
    case .localSequential: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_ExecutionStrategy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_ExecutionStrategy] = [
    .unspecified,
    .otherEnvironment,
    .remoteService,
    .localParallel,
    .localSequential,
  ]
}

#endif  // swift(>=4.2)

/// Most build systems cache build results to speed up incremental builds.
/// Some also cache test results too. This indicates whether the test results
/// were found in a cache, and where that cache was located.
public enum Google_Devtools_Resultstore_V2_TestCaching: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The implicit default enum value. Should never be set.
  case unspecified // = 0

  /// The test result was found in a local cache, so it wasn't run again.
  case localCacheHit // = 1

  /// The test result was found in a remote cache, so it wasn't run again.
  case remoteCacheHit // = 2

  /// The test result was not found in any cache, so it had to be run again.
  case cacheMiss // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .localCacheHit
    case 2: self = .remoteCacheHit
    case 3: self = .cacheMiss
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .localCacheHit: return 1
    case .remoteCacheHit: return 2
    case .cacheMiss: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_TestCaching: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_TestCaching] = [
    .unspecified,
    .localCacheHit,
    .remoteCacheHit,
    .cacheMiss,
  ]
}

#endif  // swift(>=4.2)

/// An action that happened as part of a configured target. This action could be
/// a build, a test, or another type of action, as specified in action_type
/// oneof.
///
/// Each parent ConfiguredTarget resource should have at least one Action as its
/// child resource before the invocation is finalized. For a simple build, at
/// least one build action should be created to represent the build result, and
/// at at least one test action should be created to represent the test result,
/// if any.
public struct Google_Devtools_Resultstore_V2_Action {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name.  Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/url_encode(${CONFIG_ID})/actions/${url_encode(ACTION_ID)}
  ///
  /// See CreateActionRequest proto for more information.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The resource ID components that identify the Action. They must match the
  /// resource name after proper encoding.
  public var id: Google_Devtools_Resultstore_V2_Action.Id {
    get {return _storage._id ?? Google_Devtools_Resultstore_V2_Action.Id()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// The status of the action.
  public var statusAttributes: Google_Devtools_Resultstore_V2_StatusAttributes {
    get {return _storage._statusAttributes ?? Google_Devtools_Resultstore_V2_StatusAttributes()}
    set {_uniqueStorage()._statusAttributes = newValue}
  }
  /// Returns true if `statusAttributes` has been explicitly set.
  public var hasStatusAttributes: Bool {return _storage._statusAttributes != nil}
  /// Clears the value of `statusAttributes`. Subsequent reads from it will return its default value.
  public mutating func clearStatusAttributes() {_uniqueStorage()._statusAttributes = nil}

  /// The timing of the whole action. For TestActions, the start time may be
  /// before the test actually started, and the duration may last until after the
  /// test actually finished.
  public var timing: Google_Devtools_Resultstore_V2_Timing {
    get {return _storage._timing ?? Google_Devtools_Resultstore_V2_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// The type of the action. The type of an action may not change over the
  /// lifetime of the invocation. If one of these fields is to be set, it must be
  /// set in the CreateAction method. It may be set to an empty message that is
  /// populated in later methods or post-processing. A generic "untyped" action
  /// can be created by not setting any of these fields. An untyped action will
  /// be untyped for the lifetime of the invocation.
  public var actionType: OneOf_ActionType? {
    get {return _storage._actionType}
    set {_uniqueStorage()._actionType = newValue}
  }

  /// Used only when this action represents a build action.
  public var buildAction: Google_Devtools_Resultstore_V2_BuildAction {
    get {
      if case .buildAction(let v)? = _storage._actionType {return v}
      return Google_Devtools_Resultstore_V2_BuildAction()
    }
    set {_uniqueStorage()._actionType = .buildAction(newValue)}
  }

  /// Only for test actions.
  public var testAction: Google_Devtools_Resultstore_V2_TestAction {
    get {
      if case .testAction(let v)? = _storage._actionType {return v}
      return Google_Devtools_Resultstore_V2_TestAction()
    }
    set {_uniqueStorage()._actionType = .testAction(newValue)}
  }

  /// General attributes of the action.
  public var actionAttributes: Google_Devtools_Resultstore_V2_ActionAttributes {
    get {return _storage._actionAttributes ?? Google_Devtools_Resultstore_V2_ActionAttributes()}
    set {_uniqueStorage()._actionAttributes = newValue}
  }
  /// Returns true if `actionAttributes` has been explicitly set.
  public var hasActionAttributes: Bool {return _storage._actionAttributes != nil}
  /// Clears the value of `actionAttributes`. Subsequent reads from it will return its default value.
  public mutating func clearActionAttributes() {_uniqueStorage()._actionAttributes = nil}

  /// A list of resources that this action depended upon. May be used to provide
  /// the cause of a build failure in the case of a failed build action.
  public var actionDependencies: [Google_Devtools_Resultstore_V2_Dependency] {
    get {return _storage._actionDependencies}
    set {_uniqueStorage()._actionDependencies = newValue}
  }

  /// Arbitrary name-value pairs.
  /// This is implemented as a multi-map. Multiple properties are allowed with
  /// the same key. Properties will be returned in lexicographical order by key.
  public var properties: [Google_Devtools_Resultstore_V2_Property] {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  /// A list of file references for action level files.
  /// The file IDs must be unique within this list. Duplicate file IDs will
  /// result in an error. Files will be returned in lexicographical order by ID.
  ///
  /// Files with the following reserved file IDs cause specific post-processing
  /// or have special handling. These files must be immediately available to
  /// ResultStore for processing when the reference is uploaded.
  ///
  /// For build actions:
  /// stdout: The stdout of the action
  /// stderr: The stderr of the action
  /// baseline.lcov: Baseline coverage file to be parsed by the server. This
  ///     uses a stripped down implementation of the LCOV standard.
  ///     http://ltp.sourceforge.net/coverage/lcov/geninfo.1.php
  ///
  /// For test actions:
  /// test.xml: The test suite / test case data in XML format.
  /// test.log: The combined stdout and stderr of the test process.
  /// test.lcov: Coverage file to be parsed by the server. This uses a stripped
  ///     down implementation of the LCOV standard.
  ///     http://ltp.sourceforge.net/coverage/lcov/geninfo.1.php
  public var files: [Google_Devtools_Resultstore_V2_File] {
    get {return _storage._files}
    set {_uniqueStorage()._files = newValue}
  }

  /// List of names of file sets that are referenced from this Action.
  /// Each name must point to a file set under the same Invocation. The name
  /// format must be: invocations/${INVOCATION_ID}/fileSets/${FILE_SET_ID}
  public var fileSets: [String] {
    get {return _storage._fileSets}
    set {_uniqueStorage()._fileSets = newValue}
  }

  /// Coverage data was collected while running the build or test action. This
  /// usually includes line coverage, and may also include branch coverage.
  /// For test actions, this is usually only for the source files which were
  /// actually executed by that particular action.
  /// For build actions, this is the baseline coverage, which captures the
  /// instrumented files and lines, without any lines being executed. This
  /// ensures files that are never covered at all are included.
  public var coverage: Google_Devtools_Resultstore_V2_ActionCoverage {
    get {return _storage._coverage ?? Google_Devtools_Resultstore_V2_ActionCoverage()}
    set {_uniqueStorage()._coverage = newValue}
  }
  /// Returns true if `coverage` has been explicitly set.
  public var hasCoverage: Bool {return _storage._coverage != nil}
  /// Clears the value of `coverage`. Subsequent reads from it will return its default value.
  public mutating func clearCoverage() {_uniqueStorage()._coverage = nil}

  /// ResultStore will read and parse Files with reserved IDs listed above. Read
  /// and parse errors for all these Files are reported here.
  /// This is implemented as a map, with one FileProcessingErrors for each file.
  /// Typically produced when parsing Files, but may also be provided directly
  /// by clients.
  public var fileProcessingErrors: [Google_Devtools_Resultstore_V2_FileProcessingErrors] {
    get {return _storage._fileProcessingErrors}
    set {_uniqueStorage()._fileProcessingErrors = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of the action. The type of an action may not change over the
  /// lifetime of the invocation. If one of these fields is to be set, it must be
  /// set in the CreateAction method. It may be set to an empty message that is
  /// populated in later methods or post-processing. A generic "untyped" action
  /// can be created by not setting any of these fields. An untyped action will
  /// be untyped for the lifetime of the invocation.
  public enum OneOf_ActionType: Equatable {
    /// Used only when this action represents a build action.
    case buildAction(Google_Devtools_Resultstore_V2_BuildAction)
    /// Only for test actions.
    case testAction(Google_Devtools_Resultstore_V2_TestAction)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_Action.OneOf_ActionType, rhs: Google_Devtools_Resultstore_V2_Action.OneOf_ActionType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.buildAction, .buildAction): return {
        guard case .buildAction(let l) = lhs, case .buildAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.testAction, .testAction): return {
        guard case .testAction(let l) = lhs, case .testAction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The resource ID components that identify the Action.
  public struct Id {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The Invocation ID.
    public var invocationID: String = String()

    /// The Target ID.
    public var targetID: String = String()

    /// The Configuration ID.
    public var configurationID: String = String()

    /// The Action ID.
    public var actionID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A build action, such as building a java library.
public struct Google_Devtools_Resultstore_V2_BuildAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the action.  This is intended to be a clue as to how the output
  /// of the action should be parsed. For example "javac" for a Java compile
  /// action.
  public var type: String = String()

  /// The "primary" input artifact processed by this action.  E.g., the .cc file
  /// of a C++ compile action.  Empty string ("") if the action has no input
  /// artifacts or no "primary" input artifact.
  public var primaryInputPath: String = String()

  /// The "primary" output artifact processed by this action.  E.g., the .o file
  /// of a C++ compile action.  Empty string ("") if the action has no output
  /// artifacts or no "primary" output artifact.
  public var primaryOutputPath: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A test action, such as running a JUnit4 test binary.
public struct Google_Devtools_Resultstore_V2_TestAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Timing data for execution of the test action.
  public var testTiming: Google_Devtools_Resultstore_V2_TestTiming {
    get {return _storage._testTiming ?? Google_Devtools_Resultstore_V2_TestTiming()}
    set {_uniqueStorage()._testTiming = newValue}
  }
  /// Returns true if `testTiming` has been explicitly set.
  public var hasTestTiming: Bool {return _storage._testTiming != nil}
  /// Clears the value of `testTiming`. Subsequent reads from it will return its default value.
  public mutating func clearTestTiming() {_uniqueStorage()._testTiming = nil}

  /// If the test is divided up into shards to improve performance, set this to
  /// indicate which shard this test action is for. Value must be in interval
  /// [0, total_shard_count). Defaults to 0, which is appropriate if all test
  /// cases are run in the same process.
  public var shardNumber: Int32 {
    get {return _storage._shardNumber}
    set {_uniqueStorage()._shardNumber = newValue}
  }

  /// If the user requested that every test be run multiple times, as is often
  /// done to measure flakiness, set this to indicate which run this test action
  /// is for. Value must be in interval [0, total_run_count). Defaults to 0,
  /// which is appropriate if multiple runs were not requested.
  public var runNumber: Int32 {
    get {return _storage._runNumber}
    set {_uniqueStorage()._runNumber = newValue}
  }

  /// If flaky tests are automatically retried, set this to indicate which
  /// attempt this test action is for. (e.g. 0 for the first attempt, 1 for
  /// second, and so on). Defaults to 0, which is appropriate if this is only
  /// attempt.
  public var attemptNumber: Int32 {
    get {return _storage._attemptNumber}
    set {_uniqueStorage()._attemptNumber = newValue}
  }

  /// A tree of test suites and test cases that were run by this test action.
  /// Each test case has its own status information, including stack traces.
  /// Typically produced by parsing an XML Log, but may also be provided directly
  /// by clients.
  public var testSuite: Google_Devtools_Resultstore_V2_TestSuite {
    get {return _storage._testSuite ?? Google_Devtools_Resultstore_V2_TestSuite()}
    set {_uniqueStorage()._testSuite = newValue}
  }
  /// Returns true if `testSuite` has been explicitly set.
  public var hasTestSuite: Bool {return _storage._testSuite != nil}
  /// Clears the value of `testSuite`. Subsequent reads from it will return its default value.
  public mutating func clearTestSuite() {_uniqueStorage()._testSuite = nil}

  /// Warnings for this test action.
  public var warnings: [Google_Devtools_Resultstore_V2_TestWarning] {
    get {return _storage._warnings}
    set {_uniqueStorage()._warnings = newValue}
  }

  /// Estimated memory consumption of the test action, in bytes. A default value
  /// of 0 means there is no memory consumption estimate specified.
  public var estimatedMemoryBytes: Int64 {
    get {return _storage._estimatedMemoryBytes}
    set {_uniqueStorage()._estimatedMemoryBytes = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// General attributes of an action
public struct Google_Devtools_Resultstore_V2_ActionAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Strategy used for executing the action.
  public var executionStrategy: Google_Devtools_Resultstore_V2_ExecutionStrategy = .unspecified

  /// Exit code of the process that ran the action. A non-zero value means
  /// failure.
  public var exitCode: Int32 = 0

  /// Where the action was run.
  public var hostname: String = String()

  /// Information about the input files used in all actions under this configured
  /// target.
  public var inputFileInfo: Google_Devtools_Resultstore_V2_InputFileInfo {
    get {return _inputFileInfo ?? Google_Devtools_Resultstore_V2_InputFileInfo()}
    set {_inputFileInfo = newValue}
  }
  /// Returns true if `inputFileInfo` has been explicitly set.
  public var hasInputFileInfo: Bool {return self._inputFileInfo != nil}
  /// Clears the value of `inputFileInfo`. Subsequent reads from it will return its default value.
  public mutating func clearInputFileInfo() {self._inputFileInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _inputFileInfo: Google_Devtools_Resultstore_V2_InputFileInfo? = nil
}

/// File count and size information for the input files to a configured target.
public struct Google_Devtools_Resultstore_V2_InputFileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of input files (counting every file, even if a duplicate).
  public var count: Int64 = 0

  /// The number of distinct input files.
  public var distinctCount: Int64 = 0

  /// The max number of input files allowed by the build system (counting every
  /// file, even if a duplicate).
  public var countLimit: Int64 = 0

  /// The total size of the distinct input files.
  public var distinctBytes: Int64 = 0

  /// The max allowed total size of the distinct input files.
  public var distinctByteLimit: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Timing data for tests executed locally on the machine running the build.
public struct Google_Devtools_Resultstore_V2_LocalTestTiming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time taken by the test process, typically surrounded by a small wrapper
  /// script.
  public var testProcessDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _testProcessDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_testProcessDuration = newValue}
  }
  /// Returns true if `testProcessDuration` has been explicitly set.
  public var hasTestProcessDuration: Bool {return self._testProcessDuration != nil}
  /// Clears the value of `testProcessDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTestProcessDuration() {self._testProcessDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _testProcessDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Timing data for one attempt to execute a test action remotely.
public struct Google_Devtools_Resultstore_V2_RemoteTestAttemptTiming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Idle period before the test process is invoked on the remote machine.
  public var queueDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _queueDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_queueDuration = newValue}
  }
  /// Returns true if `queueDuration` has been explicitly set.
  public var hasQueueDuration: Bool {return self._queueDuration != nil}
  /// Clears the value of `queueDuration`. Subsequent reads from it will return its default value.
  public mutating func clearQueueDuration() {self._queueDuration = nil}

  /// Time to upload data dependencies from the local machine to the remote
  /// machine running the test, or to the distributed cache.
  public var uploadDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _uploadDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uploadDuration = newValue}
  }
  /// Returns true if `uploadDuration` has been explicitly set.
  public var hasUploadDuration: Bool {return self._uploadDuration != nil}
  /// Clears the value of `uploadDuration`. Subsequent reads from it will return its default value.
  public mutating func clearUploadDuration() {self._uploadDuration = nil}

  /// Time to set up the remote machine.
  /// Not to be confused with setup time in
  /// xUnit test frameworks, which falls within the test_process_time.
  public var machineSetupDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _machineSetupDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_machineSetupDuration = newValue}
  }
  /// Returns true if `machineSetupDuration` has been explicitly set.
  public var hasMachineSetupDuration: Bool {return self._machineSetupDuration != nil}
  /// Clears the value of `machineSetupDuration`. Subsequent reads from it will return its default value.
  public mutating func clearMachineSetupDuration() {self._machineSetupDuration = nil}

  /// Time taken by the test process, typically surrounded by a small wrapper
  /// script.
  /// For Java tests, this includes JVM setup, flag parsing, class path setup,
  /// parsing files to setup the suite, and finally running your test methods.
  /// In many cases, only a small fraction of the test process time is spent
  /// running the test methods.
  public var testProcessDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _testProcessDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_testProcessDuration = newValue}
  }
  /// Returns true if `testProcessDuration` has been explicitly set.
  public var hasTestProcessDuration: Bool {return self._testProcessDuration != nil}
  /// Clears the value of `testProcessDuration`. Subsequent reads from it will return its default value.
  public mutating func clearTestProcessDuration() {self._testProcessDuration = nil}

  /// Time spent retrieving test logs and any other test outputs, back to the
  /// local machine.
  public var downloadDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _downloadDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_downloadDuration = newValue}
  }
  /// Returns true if `downloadDuration` has been explicitly set.
  public var hasDownloadDuration: Bool {return self._downloadDuration != nil}
  /// Clears the value of `downloadDuration`. Subsequent reads from it will return its default value.
  public mutating func clearDownloadDuration() {self._downloadDuration = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _queueDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _uploadDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _machineSetupDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _testProcessDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _downloadDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Timing data for the part of the test execution that is done remotely.
public struct Google_Devtools_Resultstore_V2_RemoteTestTiming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time taken locally to determine what to do.
  public var localAnalysisDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _localAnalysisDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_localAnalysisDuration = newValue}
  }
  /// Returns true if `localAnalysisDuration` has been explicitly set.
  public var hasLocalAnalysisDuration: Bool {return self._localAnalysisDuration != nil}
  /// Clears the value of `localAnalysisDuration`. Subsequent reads from it will return its default value.
  public mutating func clearLocalAnalysisDuration() {self._localAnalysisDuration = nil}

  /// Normally there is only one attempt, but the system may retry on internal
  /// errors, leading to multiple attempts.
  public var attempts: [Google_Devtools_Resultstore_V2_RemoteTestAttemptTiming] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _localAnalysisDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Timing data for execution of a test action. The action may be performed
/// locally, on the machine running the build, or remotely.
public struct Google_Devtools_Resultstore_V2_TestTiming {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Test timing for either a local or remote execution.
  public var location: Google_Devtools_Resultstore_V2_TestTiming.OneOf_Location? = nil

  /// Used for local test actions.
  public var local: Google_Devtools_Resultstore_V2_LocalTestTiming {
    get {
      if case .local(let v)? = location {return v}
      return Google_Devtools_Resultstore_V2_LocalTestTiming()
    }
    set {location = .local(newValue)}
  }

  /// Used for remote test actions.
  public var remote: Google_Devtools_Resultstore_V2_RemoteTestTiming {
    get {
      if case .remote(let v)? = location {return v}
      return Google_Devtools_Resultstore_V2_RemoteTestTiming()
    }
    set {location = .remote(newValue)}
  }

  /// The amount of CPU time spent by the test process executing system calls
  /// within the kernel, as opposed to library code. Time the test process spent
  /// blocked does not count towards this figure.
  public var systemTimeDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _systemTimeDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_systemTimeDuration = newValue}
  }
  /// Returns true if `systemTimeDuration` has been explicitly set.
  public var hasSystemTimeDuration: Bool {return self._systemTimeDuration != nil}
  /// Clears the value of `systemTimeDuration`. Subsequent reads from it will return its default value.
  public mutating func clearSystemTimeDuration() {self._systemTimeDuration = nil}

  /// The amount of CPU time spent by the test process executing user-mode code
  /// outside the kernel, as opposed to library code. Time the test process
  /// spent blocked does not count towards this figure. You can add user_time to
  /// system_time to get total CPU time taken by the test process.
  public var userTimeDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _userTimeDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_userTimeDuration = newValue}
  }
  /// Returns true if `userTimeDuration` has been explicitly set.
  public var hasUserTimeDuration: Bool {return self._userTimeDuration != nil}
  /// Clears the value of `userTimeDuration`. Subsequent reads from it will return its default value.
  public mutating func clearUserTimeDuration() {self._userTimeDuration = nil}

  /// Most build systems cache build results to speed up incremental builds.
  /// Some also cache test results too. This indicates whether the test results
  /// were found in a cache, and where that cache was located.
  public var testCaching: Google_Devtools_Resultstore_V2_TestCaching = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Test timing for either a local or remote execution.
  public enum OneOf_Location: Equatable {
    /// Used for local test actions.
    case local(Google_Devtools_Resultstore_V2_LocalTestTiming)
    /// Used for remote test actions.
    case remote(Google_Devtools_Resultstore_V2_RemoteTestTiming)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_TestTiming.OneOf_Location, rhs: Google_Devtools_Resultstore_V2_TestTiming.OneOf_Location) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.local, .local): return {
        guard case .local(let l) = lhs, case .local(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.remote, .remote): return {
        guard case .remote(let l) = lhs, case .remote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _systemTimeDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _userTimeDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// A warning from a test execution.
public struct Google_Devtools_Resultstore_V2_TestWarning {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the message detailing the warning.
  public var warningMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.resultstore.v2"

extension Google_Devtools_Resultstore_V2_ExecutionStrategy: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXECUTION_STRATEGY_UNSPECIFIED"),
    1: .same(proto: "OTHER_ENVIRONMENT"),
    2: .same(proto: "REMOTE_SERVICE"),
    3: .same(proto: "LOCAL_PARALLEL"),
    4: .same(proto: "LOCAL_SEQUENTIAL"),
  ]
}

extension Google_Devtools_Resultstore_V2_TestCaching: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_CACHING_UNSPECIFIED"),
    1: .same(proto: "LOCAL_CACHE_HIT"),
    2: .same(proto: "REMOTE_CACHE_HIT"),
    3: .same(proto: "CACHE_MISS"),
  ]
}

extension Google_Devtools_Resultstore_V2_Action: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Action"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
    3: .standard(proto: "status_attributes"),
    4: .same(proto: "timing"),
    9: .standard(proto: "build_action"),
    10: .standard(proto: "test_action"),
    5: .standard(proto: "action_attributes"),
    14: .standard(proto: "action_dependencies"),
    7: .same(proto: "properties"),
    8: .same(proto: "files"),
    15: .standard(proto: "file_sets"),
    11: .same(proto: "coverage"),
    13: .standard(proto: "file_processing_errors"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _id: Google_Devtools_Resultstore_V2_Action.Id? = nil
    var _statusAttributes: Google_Devtools_Resultstore_V2_StatusAttributes? = nil
    var _timing: Google_Devtools_Resultstore_V2_Timing? = nil
    var _actionType: Google_Devtools_Resultstore_V2_Action.OneOf_ActionType?
    var _actionAttributes: Google_Devtools_Resultstore_V2_ActionAttributes? = nil
    var _actionDependencies: [Google_Devtools_Resultstore_V2_Dependency] = []
    var _properties: [Google_Devtools_Resultstore_V2_Property] = []
    var _files: [Google_Devtools_Resultstore_V2_File] = []
    var _fileSets: [String] = []
    var _coverage: Google_Devtools_Resultstore_V2_ActionCoverage? = nil
    var _fileProcessingErrors: [Google_Devtools_Resultstore_V2_FileProcessingErrors] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _id = source._id
      _statusAttributes = source._statusAttributes
      _timing = source._timing
      _actionType = source._actionType
      _actionAttributes = source._actionAttributes
      _actionDependencies = source._actionDependencies
      _properties = source._properties
      _files = source._files
      _fileSets = source._fileSets
      _coverage = source._coverage
      _fileProcessingErrors = source._fileProcessingErrors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._statusAttributes) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._actionAttributes) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._properties) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._files) }()
        case 9: try {
          var v: Google_Devtools_Resultstore_V2_BuildAction?
          if let current = _storage._actionType {
            try decoder.handleConflictingOneOf()
            if case .buildAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._actionType = .buildAction(v)}
        }()
        case 10: try {
          var v: Google_Devtools_Resultstore_V2_TestAction?
          if let current = _storage._actionType {
            try decoder.handleConflictingOneOf()
            if case .testAction(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._actionType = .testAction(v)}
        }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._coverage) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._fileProcessingErrors) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._actionDependencies) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._fileSets) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._statusAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._actionAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 7)
      }
      if !_storage._files.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._files, fieldNumber: 8)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._actionType {
      case .buildAction?: try {
        guard case .buildAction(let v)? = _storage._actionType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .testAction?: try {
        guard case .testAction(let v)? = _storage._actionType else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case nil: break
      }
      if let v = _storage._coverage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if !_storage._fileProcessingErrors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fileProcessingErrors, fieldNumber: 13)
      }
      if !_storage._actionDependencies.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._actionDependencies, fieldNumber: 14)
      }
      if !_storage._fileSets.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._fileSets, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Action, rhs: Google_Devtools_Resultstore_V2_Action) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._statusAttributes != rhs_storage._statusAttributes {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._actionType != rhs_storage._actionType {return false}
        if _storage._actionAttributes != rhs_storage._actionAttributes {return false}
        if _storage._actionDependencies != rhs_storage._actionDependencies {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._files != rhs_storage._files {return false}
        if _storage._fileSets != rhs_storage._fileSets {return false}
        if _storage._coverage != rhs_storage._coverage {return false}
        if _storage._fileProcessingErrors != rhs_storage._fileProcessingErrors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_Action.Id: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Resultstore_V2_Action.protoMessageName + ".Id"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invocation_id"),
    2: .standard(proto: "target_id"),
    3: .standard(proto: "configuration_id"),
    4: .standard(proto: "action_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.invocationID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.configurationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invocationID.isEmpty {
      try visitor.visitSingularStringField(value: self.invocationID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if !self.configurationID.isEmpty {
      try visitor.visitSingularStringField(value: self.configurationID, fieldNumber: 3)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Action.Id, rhs: Google_Devtools_Resultstore_V2_Action.Id) -> Bool {
    if lhs.invocationID != rhs.invocationID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_BuildAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "primary_input_path"),
    3: .standard(proto: "primary_output_path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.primaryInputPath) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.primaryOutputPath) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.primaryInputPath.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryInputPath, fieldNumber: 2)
    }
    if !self.primaryOutputPath.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryOutputPath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_BuildAction, rhs: Google_Devtools_Resultstore_V2_BuildAction) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.primaryInputPath != rhs.primaryInputPath {return false}
    if lhs.primaryOutputPath != rhs.primaryOutputPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TestAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_timing"),
    2: .standard(proto: "shard_number"),
    3: .standard(proto: "run_number"),
    4: .standard(proto: "attempt_number"),
    5: .standard(proto: "test_suite"),
    8: .same(proto: "warnings"),
    10: .standard(proto: "estimated_memory_bytes"),
  ]

  fileprivate class _StorageClass {
    var _testTiming: Google_Devtools_Resultstore_V2_TestTiming? = nil
    var _shardNumber: Int32 = 0
    var _runNumber: Int32 = 0
    var _attemptNumber: Int32 = 0
    var _testSuite: Google_Devtools_Resultstore_V2_TestSuite? = nil
    var _warnings: [Google_Devtools_Resultstore_V2_TestWarning] = []
    var _estimatedMemoryBytes: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _testTiming = source._testTiming
      _shardNumber = source._shardNumber
      _runNumber = source._runNumber
      _attemptNumber = source._attemptNumber
      _testSuite = source._testSuite
      _warnings = source._warnings
      _estimatedMemoryBytes = source._estimatedMemoryBytes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._testTiming) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._shardNumber) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._runNumber) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._attemptNumber) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._testSuite) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._warnings) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._estimatedMemoryBytes) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._testTiming {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._shardNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._shardNumber, fieldNumber: 2)
      }
      if _storage._runNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._runNumber, fieldNumber: 3)
      }
      if _storage._attemptNumber != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attemptNumber, fieldNumber: 4)
      }
      if let v = _storage._testSuite {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._warnings.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._warnings, fieldNumber: 8)
      }
      if _storage._estimatedMemoryBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._estimatedMemoryBytes, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestAction, rhs: Google_Devtools_Resultstore_V2_TestAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._testTiming != rhs_storage._testTiming {return false}
        if _storage._shardNumber != rhs_storage._shardNumber {return false}
        if _storage._runNumber != rhs_storage._runNumber {return false}
        if _storage._attemptNumber != rhs_storage._attemptNumber {return false}
        if _storage._testSuite != rhs_storage._testSuite {return false}
        if _storage._warnings != rhs_storage._warnings {return false}
        if _storage._estimatedMemoryBytes != rhs_storage._estimatedMemoryBytes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_ActionAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActionAttributes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "execution_strategy"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "input_file_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.executionStrategy) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._inputFileInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.executionStrategy != .unspecified {
      try visitor.visitSingularEnumField(value: self.executionStrategy, fieldNumber: 1)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 2)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    if let v = self._inputFileInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_ActionAttributes, rhs: Google_Devtools_Resultstore_V2_ActionAttributes) -> Bool {
    if lhs.executionStrategy != rhs.executionStrategy {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs._inputFileInfo != rhs._inputFileInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_InputFileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InputFileInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "count"),
    2: .standard(proto: "distinct_count"),
    3: .standard(proto: "count_limit"),
    4: .standard(proto: "distinct_bytes"),
    5: .standard(proto: "distinct_byte_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.distinctCount) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.countLimit) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.distinctBytes) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.distinctByteLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if self.distinctCount != 0 {
      try visitor.visitSingularInt64Field(value: self.distinctCount, fieldNumber: 2)
    }
    if self.countLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.countLimit, fieldNumber: 3)
    }
    if self.distinctBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.distinctBytes, fieldNumber: 4)
    }
    if self.distinctByteLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.distinctByteLimit, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_InputFileInfo, rhs: Google_Devtools_Resultstore_V2_InputFileInfo) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.distinctCount != rhs.distinctCount {return false}
    if lhs.countLimit != rhs.countLimit {return false}
    if lhs.distinctBytes != rhs.distinctBytes {return false}
    if lhs.distinctByteLimit != rhs.distinctByteLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_LocalTestTiming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LocalTestTiming"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_process_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._testProcessDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._testProcessDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_LocalTestTiming, rhs: Google_Devtools_Resultstore_V2_LocalTestTiming) -> Bool {
    if lhs._testProcessDuration != rhs._testProcessDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_RemoteTestAttemptTiming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteTestAttemptTiming"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "queue_duration"),
    2: .standard(proto: "upload_duration"),
    3: .standard(proto: "machine_setup_duration"),
    4: .standard(proto: "test_process_duration"),
    5: .standard(proto: "download_duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queueDuration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._uploadDuration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._machineSetupDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._testProcessDuration) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._downloadDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._queueDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._uploadDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._machineSetupDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._testProcessDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._downloadDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_RemoteTestAttemptTiming, rhs: Google_Devtools_Resultstore_V2_RemoteTestAttemptTiming) -> Bool {
    if lhs._queueDuration != rhs._queueDuration {return false}
    if lhs._uploadDuration != rhs._uploadDuration {return false}
    if lhs._machineSetupDuration != rhs._machineSetupDuration {return false}
    if lhs._testProcessDuration != rhs._testProcessDuration {return false}
    if lhs._downloadDuration != rhs._downloadDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_RemoteTestTiming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoteTestTiming"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "local_analysis_duration"),
    2: .same(proto: "attempts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._localAnalysisDuration) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attempts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._localAnalysisDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.attempts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attempts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_RemoteTestTiming, rhs: Google_Devtools_Resultstore_V2_RemoteTestTiming) -> Bool {
    if lhs._localAnalysisDuration != rhs._localAnalysisDuration {return false}
    if lhs.attempts != rhs.attempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TestTiming: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestTiming"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "local"),
    2: .same(proto: "remote"),
    3: .standard(proto: "system_time_duration"),
    4: .standard(proto: "user_time_duration"),
    5: .standard(proto: "test_caching"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Devtools_Resultstore_V2_LocalTestTiming?
        if let current = self.location {
          try decoder.handleConflictingOneOf()
          if case .local(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.location = .local(v)}
      }()
      case 2: try {
        var v: Google_Devtools_Resultstore_V2_RemoteTestTiming?
        if let current = self.location {
          try decoder.handleConflictingOneOf()
          if case .remote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.location = .remote(v)}
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._systemTimeDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._userTimeDuration) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.testCaching) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.location {
    case .local?: try {
      guard case .local(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .remote?: try {
      guard case .remote(let v)? = self.location else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if let v = self._systemTimeDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._userTimeDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.testCaching != .unspecified {
      try visitor.visitSingularEnumField(value: self.testCaching, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestTiming, rhs: Google_Devtools_Resultstore_V2_TestTiming) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs._systemTimeDuration != rhs._systemTimeDuration {return false}
    if lhs._userTimeDuration != rhs._userTimeDuration {return false}
    if lhs.testCaching != rhs.testCaching {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TestWarning: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TestWarning"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "warning_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.warningMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.warningMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.warningMessage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TestWarning, rhs: Google_Devtools_Resultstore_V2_TestWarning) -> Bool {
    if lhs.warningMessage != rhs.warningMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

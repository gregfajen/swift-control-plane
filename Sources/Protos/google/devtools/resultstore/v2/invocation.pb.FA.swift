// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/resultstore/v2/invocation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An Invocation typically represents the result of running a tool. Each has a
/// unique ID, typically generated by the server. Target resources under each
/// Invocation contain the bulk of the data.
public struct Google_Devtools_Resultstore_V2_Invocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name.  Its format must be:
  /// invocations/${INVOCATION_ID}
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The resource ID components that identify the Invocation. They must match
  /// the resource name after proper encoding.
  public var id: Google_Devtools_Resultstore_V2_Invocation.Id {
    get {return _storage._id ?? Google_Devtools_Resultstore_V2_Invocation.Id()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// The aggregate status of the invocation.
  public var statusAttributes: Google_Devtools_Resultstore_V2_StatusAttributes {
    get {return _storage._statusAttributes ?? Google_Devtools_Resultstore_V2_StatusAttributes()}
    set {_uniqueStorage()._statusAttributes = newValue}
  }
  /// Returns true if `statusAttributes` has been explicitly set.
  public var hasStatusAttributes: Bool {return _storage._statusAttributes != nil}
  /// Clears the value of `statusAttributes`. Subsequent reads from it will return its default value.
  public mutating func clearStatusAttributes() {_uniqueStorage()._statusAttributes = nil}

  /// When this invocation started and its duration.
  public var timing: Google_Devtools_Resultstore_V2_Timing {
    get {return _storage._timing ?? Google_Devtools_Resultstore_V2_Timing()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Attributes of this invocation.
  public var invocationAttributes: Google_Devtools_Resultstore_V2_InvocationAttributes {
    get {return _storage._invocationAttributes ?? Google_Devtools_Resultstore_V2_InvocationAttributes()}
    set {_uniqueStorage()._invocationAttributes = newValue}
  }
  /// Returns true if `invocationAttributes` has been explicitly set.
  public var hasInvocationAttributes: Bool {return _storage._invocationAttributes != nil}
  /// Clears the value of `invocationAttributes`. Subsequent reads from it will return its default value.
  public mutating func clearInvocationAttributes() {_uniqueStorage()._invocationAttributes = nil}

  /// The workspace the tool was run in.
  public var workspaceInfo: Google_Devtools_Resultstore_V2_WorkspaceInfo {
    get {return _storage._workspaceInfo ?? Google_Devtools_Resultstore_V2_WorkspaceInfo()}
    set {_uniqueStorage()._workspaceInfo = newValue}
  }
  /// Returns true if `workspaceInfo` has been explicitly set.
  public var hasWorkspaceInfo: Bool {return _storage._workspaceInfo != nil}
  /// Clears the value of `workspaceInfo`. Subsequent reads from it will return its default value.
  public mutating func clearWorkspaceInfo() {_uniqueStorage()._workspaceInfo = nil}

  /// Arbitrary name-value pairs.
  /// This is implemented as a multi-map. Multiple properties are allowed with
  /// the same key. Properties will be returned in lexicographical order by key.
  public var properties: [Google_Devtools_Resultstore_V2_Property] {
    get {return _storage._properties}
    set {_uniqueStorage()._properties = newValue}
  }

  /// A list of file references for invocation level files.
  /// The file IDs must be unique within this list. Duplicate file IDs will
  /// result in an error. Files will be returned in lexicographical order by ID.
  /// Use this field to specify build logs, and other invocation level logs.
  ///
  /// Files with the following reserved file IDs cause specific post-processing
  /// or have special handling. These files must be immediately available to
  /// ResultStore for processing when the reference is uploaded.
  ///
  /// build.log: The primary log for the Invocation.
  /// coverage_report.lcov: Aggregate coverage report for the invocation.
  public var files: [Google_Devtools_Resultstore_V2_File] {
    get {return _storage._files}
    set {_uniqueStorage()._files = newValue}
  }

  /// Summary of aggregate coverage across all Actions in this Invocation.
  /// If missing, this data will be populated by the server from the
  /// coverage_report.lcov file or the union of all ActionCoverages under this
  /// invocation (in that order).
  public var coverageSummaries: [Google_Devtools_Resultstore_V2_LanguageCoverageSummary] {
    get {return _storage._coverageSummaries}
    set {_uniqueStorage()._coverageSummaries = newValue}
  }

  /// Aggregate code coverage for all build and test Actions within this
  /// Invocation. If missing, this data will be populated by the server
  /// from the coverage_report.lcov file or the union of all ActionCoverages
  /// under this invocation (in that order).
  public var aggregateCoverage: Google_Devtools_Resultstore_V2_AggregateCoverage {
    get {return _storage._aggregateCoverage ?? Google_Devtools_Resultstore_V2_AggregateCoverage()}
    set {_uniqueStorage()._aggregateCoverage = newValue}
  }
  /// Returns true if `aggregateCoverage` has been explicitly set.
  public var hasAggregateCoverage: Bool {return _storage._aggregateCoverage != nil}
  /// Clears the value of `aggregateCoverage`. Subsequent reads from it will return its default value.
  public mutating func clearAggregateCoverage() {_uniqueStorage()._aggregateCoverage = nil}

  /// NOT IMPLEMENTED.
  /// ResultStore will read and parse Files with reserved IDs listed above. Read
  /// and parse errors for all these Files are reported here.
  /// This is implemented as a map, with one FileProcessingErrors for each file.
  /// Typically produced when parsing Files, but may also be provided directly
  /// by clients.
  public var fileProcessingErrors: [Google_Devtools_Resultstore_V2_FileProcessingErrors] {
    get {return _storage._fileProcessingErrors}
    set {_uniqueStorage()._fileProcessingErrors = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The resource ID components that identify the Invocation.
  public struct Id {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The Invocation ID.
    public var invocationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// If known, represents the state of the user/build-system workspace.
public struct Google_Devtools_Resultstore_V2_WorkspaceContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the workspace under which the tool was invoked, this includes
/// information that was fed into the command, the source code referenced, and
/// the tool itself.
public struct Google_Devtools_Resultstore_V2_WorkspaceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data about the workspace that might be useful for debugging.
  public var workspaceContext: Google_Devtools_Resultstore_V2_WorkspaceContext {
    get {return _workspaceContext ?? Google_Devtools_Resultstore_V2_WorkspaceContext()}
    set {_workspaceContext = newValue}
  }
  /// Returns true if `workspaceContext` has been explicitly set.
  public var hasWorkspaceContext: Bool {return self._workspaceContext != nil}
  /// Clears the value of `workspaceContext`. Subsequent reads from it will return its default value.
  public mutating func clearWorkspaceContext() {self._workspaceContext = nil}

  /// Where the tool was invoked
  public var hostname: String = String()

  /// The client's working directory where the build/test was run from.
  public var workingDirectory: String = String()

  /// Tools should set tool_tag to the name of the tool or use case.
  public var toolTag: String = String()

  /// The command lines invoked. The first command line is the one typed by the
  /// user, then each one after that should be an expansion of the previous
  /// command line.
  public var commandLines: [Google_Devtools_Resultstore_V2_CommandLine] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workspaceContext: Google_Devtools_Resultstore_V2_WorkspaceContext? = nil
}

/// The command and arguments that produced this Invocation.
public struct Google_Devtools_Resultstore_V2_CommandLine {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A label describing this command line.
  public var label: String = String()

  /// The command-line tool that is run: argv[0].
  public var tool: String = String()

  /// The arguments to the above tool: argv[1]...argv[N].
  public var args: [String] = []

  /// The actual command that was run with the tool.  (e.g. "build", or "test")
  /// Omit if the tool doesn't accept a command.
  /// This is a duplicate of one of the fields in args.
  public var command: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Attributes that apply to all invocations.
public struct Google_Devtools_Resultstore_V2_InvocationAttributes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Immutable. The Cloud Project that owns this invocation (this is different than the
  /// Consumer Cloud Project that calls this API).
  /// This must be set in the CreateInvocation call, and can't be changed.
  public var projectID: String = String()

  /// The list of users in the command chain.  The first user in this sequence
  /// is the one who instigated the first command in the chain. For example,
  /// this might contain just the user that ran a Bazel command, or a robot
  /// that tested a change as part of a CI system. It could also contain the user
  /// that manually triggered a CI test, then the robot that ran the test.
  public var users: [String] = []

  /// Labels to categorize this invocation.
  /// This is implemented as a set. All labels will be unique. Any duplicate
  /// labels added will be ignored. Labels will be returned in lexicographical
  /// order. Labels should be a list of words describing the Invocation. Labels
  /// should be short, easy to read, and you shouldn't have more than a handful.
  /// Labels should not be used for unique properties such as unique IDs. Use
  /// properties in cases that don't meet these conditions.
  public var labels: [String] = []

  /// This field describes the overall context or purpose of this invocation.
  /// It will be used in the UI to give users more information about
  /// how or why this invocation was run.
  public var description_p: String = String()

  /// If this Invocation was run in the context of a larger Continuous
  /// Integration build or other automated system, this field may contain more
  /// information about the greater context.
  public var invocationContexts: [Google_Devtools_Resultstore_V2_InvocationContext] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes the invocation context which includes a display name and URL.
public struct Google_Devtools_Resultstore_V2_InvocationContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A human readable name for the context under which this Invocation was run.
  public var displayName: String = String()

  /// A URL pointing to a UI containing more information
  public var url: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.resultstore.v2"

extension Google_Devtools_Resultstore_V2_Invocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Invocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
    3: .standard(proto: "status_attributes"),
    4: .same(proto: "timing"),
    5: .standard(proto: "invocation_attributes"),
    6: .standard(proto: "workspace_info"),
    7: .same(proto: "properties"),
    8: .same(proto: "files"),
    9: .standard(proto: "coverage_summaries"),
    10: .standard(proto: "aggregate_coverage"),
    11: .standard(proto: "file_processing_errors"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _id: Google_Devtools_Resultstore_V2_Invocation.Id? = nil
    var _statusAttributes: Google_Devtools_Resultstore_V2_StatusAttributes? = nil
    var _timing: Google_Devtools_Resultstore_V2_Timing? = nil
    var _invocationAttributes: Google_Devtools_Resultstore_V2_InvocationAttributes? = nil
    var _workspaceInfo: Google_Devtools_Resultstore_V2_WorkspaceInfo? = nil
    var _properties: [Google_Devtools_Resultstore_V2_Property] = []
    var _files: [Google_Devtools_Resultstore_V2_File] = []
    var _coverageSummaries: [Google_Devtools_Resultstore_V2_LanguageCoverageSummary] = []
    var _aggregateCoverage: Google_Devtools_Resultstore_V2_AggregateCoverage? = nil
    var _fileProcessingErrors: [Google_Devtools_Resultstore_V2_FileProcessingErrors] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _id = source._id
      _statusAttributes = source._statusAttributes
      _timing = source._timing
      _invocationAttributes = source._invocationAttributes
      _workspaceInfo = source._workspaceInfo
      _properties = source._properties
      _files = source._files
      _coverageSummaries = source._coverageSummaries
      _aggregateCoverage = source._aggregateCoverage
      _fileProcessingErrors = source._fileProcessingErrors
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._statusAttributes) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._invocationAttributes) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workspaceInfo) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._properties) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._files) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._coverageSummaries) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._aggregateCoverage) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._fileProcessingErrors) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._statusAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._invocationAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._workspaceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._properties.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._properties, fieldNumber: 7)
      }
      if !_storage._files.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._files, fieldNumber: 8)
      }
      if !_storage._coverageSummaries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._coverageSummaries, fieldNumber: 9)
      }
      if let v = _storage._aggregateCoverage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._fileProcessingErrors.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._fileProcessingErrors, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Invocation, rhs: Google_Devtools_Resultstore_V2_Invocation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._statusAttributes != rhs_storage._statusAttributes {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._invocationAttributes != rhs_storage._invocationAttributes {return false}
        if _storage._workspaceInfo != rhs_storage._workspaceInfo {return false}
        if _storage._properties != rhs_storage._properties {return false}
        if _storage._files != rhs_storage._files {return false}
        if _storage._coverageSummaries != rhs_storage._coverageSummaries {return false}
        if _storage._aggregateCoverage != rhs_storage._aggregateCoverage {return false}
        if _storage._fileProcessingErrors != rhs_storage._fileProcessingErrors {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_Invocation.Id: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Resultstore_V2_Invocation.protoMessageName + ".Id"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invocation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.invocationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invocationID.isEmpty {
      try visitor.visitSingularStringField(value: self.invocationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_Invocation.Id, rhs: Google_Devtools_Resultstore_V2_Invocation.Id) -> Bool {
    if lhs.invocationID != rhs.invocationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_WorkspaceContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceContext"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_WorkspaceContext, rhs: Google_Devtools_Resultstore_V2_WorkspaceContext) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_WorkspaceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkspaceInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "workspace_context"),
    3: .same(proto: "hostname"),
    4: .standard(proto: "working_directory"),
    5: .standard(proto: "tool_tag"),
    7: .standard(proto: "command_lines"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workspaceContext) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostname) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.workingDirectory) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.toolTag) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.commandLines) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._workspaceContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.hostname.isEmpty {
      try visitor.visitSingularStringField(value: self.hostname, fieldNumber: 3)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 4)
    }
    if !self.toolTag.isEmpty {
      try visitor.visitSingularStringField(value: self.toolTag, fieldNumber: 5)
    }
    if !self.commandLines.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commandLines, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_WorkspaceInfo, rhs: Google_Devtools_Resultstore_V2_WorkspaceInfo) -> Bool {
    if lhs._workspaceContext != rhs._workspaceContext {return false}
    if lhs.hostname != rhs.hostname {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.toolTag != rhs.toolTag {return false}
    if lhs.commandLines != rhs.commandLines {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_CommandLine: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandLine"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "tool"),
    3: .same(proto: "args"),
    4: .same(proto: "command"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tool) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.args) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.command) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.tool.isEmpty {
      try visitor.visitSingularStringField(value: self.tool, fieldNumber: 2)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedStringField(value: self.args, fieldNumber: 3)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CommandLine, rhs: Google_Devtools_Resultstore_V2_CommandLine) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.tool != rhs.tool {return false}
    if lhs.args != rhs.args {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_InvocationAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvocationAttributes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "users"),
    3: .same(proto: "labels"),
    4: .same(proto: "description"),
    6: .standard(proto: "invocation_contexts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.users) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.labels) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.invocationContexts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.users.isEmpty {
      try visitor.visitRepeatedStringField(value: self.users, fieldNumber: 2)
    }
    if !self.labels.isEmpty {
      try visitor.visitRepeatedStringField(value: self.labels, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.invocationContexts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.invocationContexts, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_InvocationAttributes, rhs: Google_Devtools_Resultstore_V2_InvocationAttributes) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.users != rhs.users {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.invocationContexts != rhs.invocationContexts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_InvocationContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InvocationContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_InvocationContext, rhs: Google_Devtools_Resultstore_V2_InvocationContext) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/resultstore/v2/resultstore_upload.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request passed into CreateInvocation
public struct Google_Devtools_Resultstore_V2_CreateInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID. If set, invocation_id must also be provided.
  /// Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// The invocation ID. It is optional, but strongly recommended.
  ///
  /// If left empty then a new unique ID will be assigned by the server. If
  /// populated, a RFC 4122-compliant v4 UUID is preferred, but v3 or v5 UUIDs
  /// are allowed too.
  public var invocationID: String = String()

  /// The invocation to create.  Its name field will be ignored, since the name
  /// will be derived from the id field above and assigned by the server.
  public var invocation: Google_Devtools_Resultstore_V2_Invocation {
    get {return _invocation ?? Google_Devtools_Resultstore_V2_Invocation()}
    set {_invocation = newValue}
  }
  /// Returns true if `invocation` has been explicitly set.
  public var hasInvocation: Bool {return self._invocation != nil}
  /// Clears the value of `invocation`. Subsequent reads from it will return its default value.
  public mutating func clearInvocation() {self._invocation = nil}

  /// This is a token to authorize upload access to this invocation. It must be
  /// set to a RFC 4122-compliant v3, v4, or v5 UUID. Once this is set in
  /// CreateInvocation, all other upload RPCs for that Invocation and any of its
  /// child resources must also include the exact same token, or they will be
  /// rejected. The generated token should be unique to this invocation, and it
  /// should be kept secret.
  ///
  /// The purpose of this field is to prevent other users and tools from
  /// clobbering your upload intentionally or accidentally. The standard way of
  /// using this token is to create a second v4 UUID when the invocation_id is
  /// created, and storing them together during the upload. Essentially, this is
  /// a "password" to the invocation.
  public var authorizationToken: String = String()

  /// By default, Invocations are auto-finalized if they are not modified for 24
  /// hours. If you need auto-finalize to happen sooner, set this field to the
  /// time you'd like auto-finalize to occur.
  public var autoFinalizeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _autoFinalizeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_autoFinalizeTime = newValue}
  }
  /// Returns true if `autoFinalizeTime` has been explicitly set.
  public var hasAutoFinalizeTime: Bool {return self._autoFinalizeTime != nil}
  /// Clears the value of `autoFinalizeTime`. Subsequent reads from it will return its default value.
  public mutating func clearAutoFinalizeTime() {self._autoFinalizeTime = nil}

  /// Client provided unique token for batch upload to ensure data integrity and
  /// to provide a way to resume batch upload in case of a distributed failure on
  /// the client side. The standard uploading client is presumed to have many
  /// machines uploading to ResultStore, and that any given machine could process
  /// any given Invocation at any time. This field is used to coordinate between
  /// the client's machines, resolve concurrency issues, and enforce "exactly
  /// once" semantics on each batch within the upload.
  ///
  /// The typical usage of the resume_token is that it should contain a "key"
  /// indicating to the client where it is in the upload process, so that the
  /// client can use it to resume the upload by reconstructing the state of
  /// upload from the point where it was interrupted.
  ///
  /// If this matches the previously uploaded resume_token, then this request
  /// will silently do nothing, making CreateInvocation idempotent.
  /// If this token is provided, all further upload RPCs must be done through
  /// UploadBatch. This token must not be combined with request_id.
  /// Must be web safe Base64 encoded bytes.
  public var initialResumeToken: String = String()

  /// Client-specific data used to resume batch upload if an error occurs and
  /// retry is needed. This serves a role closely related to resume_token, as
  /// both fields may be used to provide state required to restore a Batch
  /// Upload, but they differ in two important aspects:
  ///  - it is not compared to previous values, and as such does not provide
  ///    concurrency control;
  ///  - it allows for a larger payload, since the contents are never
  ///    inspected/compared;
  /// The size of the message must be within 1 MiB. Too large requests will be
  /// rejected.
  public var uploaderState: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _invocation: Google_Devtools_Resultstore_V2_Invocation? = nil
  fileprivate var _autoFinalizeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Request passed into UpdateInvocation
public struct Google_Devtools_Resultstore_V2_UpdateInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the name and the fields of the invocation to be updated.  The
  /// name format must be: invocations/${INVOCATION_ID}
  public var invocation: Google_Devtools_Resultstore_V2_Invocation {
    get {return _invocation ?? Google_Devtools_Resultstore_V2_Invocation()}
    set {_invocation = newValue}
  }
  /// Returns true if `invocation` has been explicitly set.
  public var hasInvocation: Bool {return self._invocation != nil}
  /// Clears the value of `invocation`. Subsequent reads from it will return its default value.
  public mutating func clearInvocation() {self._invocation = nil}

  /// Indicates which fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _invocation: Google_Devtools_Resultstore_V2_Invocation? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into MergeInvocation
public struct Google_Devtools_Resultstore_V2_MergeInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// Contains the name and the fields of the invocation to be merged.  The
  /// name format must be: invocations/${INVOCATION_ID}
  public var invocation: Google_Devtools_Resultstore_V2_Invocation {
    get {return _invocation ?? Google_Devtools_Resultstore_V2_Invocation()}
    set {_invocation = newValue}
  }
  /// Returns true if `invocation` has been explicitly set.
  public var hasInvocation: Bool {return self._invocation != nil}
  /// Clears the value of `invocation`. Subsequent reads from it will return its default value.
  public mutating func clearInvocation() {self._invocation = nil}

  /// Indicates which fields to merge.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _invocation: Google_Devtools_Resultstore_V2_Invocation? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into TouchInvocation
public struct Google_Devtools_Resultstore_V2_TouchInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the invocation.  Its format must be:
  /// invocations/${INVOCATION_ID}
  public var name: String = String()

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response returned from TouchInvocation
public struct Google_Devtools_Resultstore_V2_TouchInvocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the invocation.  Its format will be:
  /// invocations/${INVOCATION_ID}
  public var name: String = String()

  /// The resource ID components that identify the Invocation.
  public var id: Google_Devtools_Resultstore_V2_Invocation.Id {
    get {return _id ?? Google_Devtools_Resultstore_V2_Invocation.Id()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Google_Devtools_Resultstore_V2_Invocation.Id? = nil
}

/// Request passed into DeleteInvocation
public struct Google_Devtools_Resultstore_V2_DeleteInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the invocation.  Its format must be:
  /// invocations/${INVOCATION_ID}
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request passed into FinalizeInvocation
public struct Google_Devtools_Resultstore_V2_FinalizeInvocationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the invocation.  Its format must be:
  /// invocations/${INVOCATION_ID}
  public var name: String = String()

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response returned from FinalizeInvocation
public struct Google_Devtools_Resultstore_V2_FinalizeInvocationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the invocation.  Its format will be:
  /// invocations/${INVOCATION_ID}
  public var name: String = String()

  /// The resource ID components that identify the Invocation.
  public var id: Google_Devtools_Resultstore_V2_Invocation.Id {
    get {return _id ?? Google_Devtools_Resultstore_V2_Invocation.Id()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Google_Devtools_Resultstore_V2_Invocation.Id? = nil
}

/// Request passed into CreateTarget
public struct Google_Devtools_Resultstore_V2_CreateTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// The name of the parent invocation in which the target is created.
  /// Its format must be invocations/${INVOCATION_ID}
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// The target identifier.  It can be any string up to 1024 Unicode characters
  /// long except for the reserved id '-'.
  public var targetID: String {
    get {return _storage._targetID}
    set {_uniqueStorage()._targetID = newValue}
  }

  /// The target to create.  Its name field will be ignored, since the name will
  /// be derived from the id field above and assigned by the server.
  public var target: Google_Devtools_Resultstore_V2_Target {
    get {return _storage._target ?? Google_Devtools_Resultstore_V2_Target()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {_uniqueStorage()._target = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String {
    get {return _storage._authorizationToken}
    set {_uniqueStorage()._authorizationToken = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request passed into UpdateTarget
public struct Google_Devtools_Resultstore_V2_UpdateTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the name and the fields of the target to be updated.  The name
  /// format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  public var target: Google_Devtools_Resultstore_V2_Target {
    get {return _storage._target ?? Google_Devtools_Resultstore_V2_Target()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {_uniqueStorage()._target = nil}

  /// Indicates which fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String {
    get {return _storage._authorizationToken}
    set {_uniqueStorage()._authorizationToken = newValue}
  }

  /// If true then the Update operation will become a Create operation if the
  /// Target is NOT_FOUND.
  public var createIfNotFound: Bool {
    get {return _storage._createIfNotFound}
    set {_uniqueStorage()._createIfNotFound = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request passed into MergeTarget
public struct Google_Devtools_Resultstore_V2_MergeTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Contains the name and the fields of the target to be merged.  The name
  /// format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  public var target: Google_Devtools_Resultstore_V2_Target {
    get {return _storage._target ?? Google_Devtools_Resultstore_V2_Target()}
    set {_uniqueStorage()._target = newValue}
  }
  /// Returns true if `target` has been explicitly set.
  public var hasTarget: Bool {return _storage._target != nil}
  /// Clears the value of `target`. Subsequent reads from it will return its default value.
  public mutating func clearTarget() {_uniqueStorage()._target = nil}

  /// Indicates which fields to merge.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String {
    get {return _storage._authorizationToken}
    set {_uniqueStorage()._authorizationToken = newValue}
  }

  /// If true then the Merge operation will become a Create operation if the
  /// Target is NOT_FOUND.
  public var createIfNotFound: Bool {
    get {return _storage._createIfNotFound}
    set {_uniqueStorage()._createIfNotFound = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request passed into FinalizeTarget
public struct Google_Devtools_Resultstore_V2_FinalizeTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the target.  Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  public var name: String = String()

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response returned from FinalizeTarget
public struct Google_Devtools_Resultstore_V2_FinalizeTargetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the target.  Its format will be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  public var name: String = String()

  /// The resource ID components that identify the Target.
  public var id: Google_Devtools_Resultstore_V2_Target.Id {
    get {return _id ?? Google_Devtools_Resultstore_V2_Target.Id()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Google_Devtools_Resultstore_V2_Target.Id? = nil
}

/// Request passed into CreateConfiguredTarget
public struct Google_Devtools_Resultstore_V2_CreateConfiguredTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// The name of the parent target in which the configured target is created.
  /// Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}
  public var parent: String {
    get {return _storage._parent}
    set {_uniqueStorage()._parent = newValue}
  }

  /// The configuration identifier. This must match the ID of an existing
  /// Configuration under this Invocation. Cannot be the reserved id '-'.
  public var configID: String {
    get {return _storage._configID}
    set {_uniqueStorage()._configID = newValue}
  }

  /// The configured target to create. Its name field will be ignored, since the
  /// name will be derived from the id field above and assigned by the server.
  public var configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget {
    get {return _storage._configuredTarget ?? Google_Devtools_Resultstore_V2_ConfiguredTarget()}
    set {_uniqueStorage()._configuredTarget = newValue}
  }
  /// Returns true if `configuredTarget` has been explicitly set.
  public var hasConfiguredTarget: Bool {return _storage._configuredTarget != nil}
  /// Clears the value of `configuredTarget`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguredTarget() {_uniqueStorage()._configuredTarget = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String {
    get {return _storage._authorizationToken}
    set {_uniqueStorage()._authorizationToken = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request passed into UpdateConfiguredTarget
public struct Google_Devtools_Resultstore_V2_UpdateConfiguredTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the name and the fields of the configured target to be updated.
  /// The name format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
  public var configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget {
    get {return _storage._configuredTarget ?? Google_Devtools_Resultstore_V2_ConfiguredTarget()}
    set {_uniqueStorage()._configuredTarget = newValue}
  }
  /// Returns true if `configuredTarget` has been explicitly set.
  public var hasConfiguredTarget: Bool {return _storage._configuredTarget != nil}
  /// Clears the value of `configuredTarget`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguredTarget() {_uniqueStorage()._configuredTarget = nil}

  /// Indicates which fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String {
    get {return _storage._authorizationToken}
    set {_uniqueStorage()._authorizationToken = newValue}
  }

  /// If true then the Update operation will become a Create operation if the
  /// ConfiguredTarget is NOT_FOUND.
  public var createIfNotFound: Bool {
    get {return _storage._createIfNotFound}
    set {_uniqueStorage()._createIfNotFound = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request passed into MergeConfiguredTarget
public struct Google_Devtools_Resultstore_V2_MergeConfiguredTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Contains the name and the fields of the configured target to be merged.
  /// The name format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
  public var configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget {
    get {return _storage._configuredTarget ?? Google_Devtools_Resultstore_V2_ConfiguredTarget()}
    set {_uniqueStorage()._configuredTarget = newValue}
  }
  /// Returns true if `configuredTarget` has been explicitly set.
  public var hasConfiguredTarget: Bool {return _storage._configuredTarget != nil}
  /// Clears the value of `configuredTarget`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguredTarget() {_uniqueStorage()._configuredTarget = nil}

  /// Indicates which fields to merge.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String {
    get {return _storage._authorizationToken}
    set {_uniqueStorage()._authorizationToken = newValue}
  }

  /// If true then the Merge operation will become a Create operation if the
  /// ConfiguredTarget is NOT_FOUND.
  public var createIfNotFound: Bool {
    get {return _storage._createIfNotFound}
    set {_uniqueStorage()._createIfNotFound = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request passed into FinalizeConfiguredTarget
public struct Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the configured target. Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
  public var name: String = String()

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response returned from FinalizeConfiguredTarget
public struct Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the configured target. Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
  public var name: String = String()

  /// The resource ID components that identify the ConfiguredTarget.
  public var id: Google_Devtools_Resultstore_V2_ConfiguredTarget.Id {
    get {return _id ?? Google_Devtools_Resultstore_V2_ConfiguredTarget.Id()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Google_Devtools_Resultstore_V2_ConfiguredTarget.Id? = nil
}

/// Request passed into CreateAction
public struct Google_Devtools_Resultstore_V2_CreateActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// The name of the parent configured target in which the action is created.
  /// Its format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}
  public var parent: String = String()

  /// The action identifier. It can be any string up to 512 Unicode characters
  /// long, except for the reserved id '-'.
  ///
  /// Recommended IDs for Test Actions:
  /// "test": For a single test action.
  /// "test_shard0_run0_attempt0" ... "test_shard9_run9_attempt9": For tests with
  ///  shard/run/attempts.
  ///
  /// Recommended IDs for Build Actions:
  /// "build": If you only have a single build action.
  public var actionID: String = String()

  /// The action to create.  Its name field will be ignored, since the
  /// name will be derived from the id field above and assigned by the server.
  public var action: Google_Devtools_Resultstore_V2_Action {
    get {return _action ?? Google_Devtools_Resultstore_V2_Action()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: Google_Devtools_Resultstore_V2_Action? = nil
}

/// Request passed into UpdateAction
public struct Google_Devtools_Resultstore_V2_UpdateActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the name and the fields of the action to be updated.  The
  /// name format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}/actions/${url_encode(ACTION_ID)}
  public var action: Google_Devtools_Resultstore_V2_Action {
    get {return _action ?? Google_Devtools_Resultstore_V2_Action()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  /// Indicates which fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  /// If true then the Update operation will become a Create operation if the
  /// Action is NOT_FOUND.
  public var createIfNotFound: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: Google_Devtools_Resultstore_V2_Action? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into MergeAction
public struct Google_Devtools_Resultstore_V2_MergeActionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// Contains the name and the fields of the action to be merged.  The
  /// name format must be:
  /// invocations/${INVOCATION_ID}/targets/${url_encode(TARGET_ID)}/configuredTargets/${url_encode(CONFIG_ID)}/actions/${url_encode(ACTION_ID)}
  public var action: Google_Devtools_Resultstore_V2_Action {
    get {return _action ?? Google_Devtools_Resultstore_V2_Action()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  /// Indicates which fields to merge.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  /// If true then the Merge operation will become a Create operation if the
  /// Action is NOT_FOUND.
  public var createIfNotFound: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _action: Google_Devtools_Resultstore_V2_Action? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into CreateConfiguration
public struct Google_Devtools_Resultstore_V2_CreateConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// The name of the parent invocation in which the configuration is created.
  /// Its format must be invocations/${INVOCATION_ID}
  public var parent: String = String()

  /// The configuration identifier. It can be any string up to 256 Unicode
  /// characters long. The configuration ID of "default" should be preferred for
  /// the default configuration in a single-config invocation. Cannot be the
  /// reserved id '-'.
  public var configID: String = String()

  /// The configuration to create. Its name field will be ignored, since the name
  /// will be derived from the id field above and assigned by the server.
  public var configuration: Google_Devtools_Resultstore_V2_Configuration {
    get {return _configuration ?? Google_Devtools_Resultstore_V2_Configuration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {self._configuration = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configuration: Google_Devtools_Resultstore_V2_Configuration? = nil
}

/// Request passed into UpdateConfiguration
public struct Google_Devtools_Resultstore_V2_UpdateConfigurationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the name and fields of the configuration to be updated. The name
  /// format must be:
  /// invocations/${INVOCATION_ID}/configs/${url_encode(CONFIG_ID)}
  public var configuration: Google_Devtools_Resultstore_V2_Configuration {
    get {return _configuration ?? Google_Devtools_Resultstore_V2_Configuration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  public var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  public mutating func clearConfiguration() {self._configuration = nil}

  /// Indicates which fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  /// If true then the Update operation will become a Create operation if the
  /// Configuration is NOT_FOUND.
  public var createIfNotFound: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configuration: Google_Devtools_Resultstore_V2_Configuration? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into CreateFileSet
public struct Google_Devtools_Resultstore_V2_CreateFileSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// The name of the parent invocation in which the file set is created.
  /// Its format must be invocations/${INVOCATION_ID}
  public var parent: String = String()

  /// The file set identifier. It can be any string up to 256 Unicode characters
  /// long.
  public var fileSetID: String = String()

  /// The file set to create. Its name field will be ignored, since the name will
  /// be derived from the id field above and assigned by the server.
  public var fileSet: Google_Devtools_Resultstore_V2_FileSet {
    get {return _fileSet ?? Google_Devtools_Resultstore_V2_FileSet()}
    set {_fileSet = newValue}
  }
  /// Returns true if `fileSet` has been explicitly set.
  public var hasFileSet: Bool {return self._fileSet != nil}
  /// Clears the value of `fileSet`. Subsequent reads from it will return its default value.
  public mutating func clearFileSet() {self._fileSet = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fileSet: Google_Devtools_Resultstore_V2_FileSet? = nil
}

/// Request passed into UpdateFileSet
public struct Google_Devtools_Resultstore_V2_UpdateFileSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Contains the name and fields of the file set to be updated. The name format
  /// must be: invocations/${INVOCATION_ID}/fileSets/${url_encode(FILE_SET_ID)}
  public var fileSet: Google_Devtools_Resultstore_V2_FileSet {
    get {return _fileSet ?? Google_Devtools_Resultstore_V2_FileSet()}
    set {_fileSet = newValue}
  }
  /// Returns true if `fileSet` has been explicitly set.
  public var hasFileSet: Bool {return self._fileSet != nil}
  /// Clears the value of `fileSet`. Subsequent reads from it will return its default value.
  public mutating func clearFileSet() {self._fileSet = nil}

  /// Indicates which fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  /// If true then the Update operation will become a Create operation if the
  /// FileSet is NOT_FOUND.
  public var createIfNotFound: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fileSet: Google_Devtools_Resultstore_V2_FileSet? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into MergeFileSet
public struct Google_Devtools_Resultstore_V2_MergeFileSetRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this request. Must be set to a different value for
  /// each request that affects a given resource (eg. a random UUID). Required
  /// for the operation to be idempotent. This is achieved by ignoring this
  /// request if the last successful operation on the resource had the same
  /// request ID.  Restricted to 36 Unicode characters.
  public var requestID: String = String()

  /// Contains the name and fields of the file set to be merged. The name
  /// format must be:
  /// invocations/${INVOCATION_ID}/fileSets/${url_encode(FILE_SET_ID)}
  public var fileSet: Google_Devtools_Resultstore_V2_FileSet {
    get {return _fileSet ?? Google_Devtools_Resultstore_V2_FileSet()}
    set {_fileSet = newValue}
  }
  /// Returns true if `fileSet` has been explicitly set.
  public var hasFileSet: Bool {return self._fileSet != nil}
  /// Clears the value of `fileSet`. Subsequent reads from it will return its default value.
  public mutating func clearFileSet() {self._fileSet = nil}

  /// Indicates which fields to merge.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  /// This is a token to authorize access to this invocation. It must be set to
  /// the same value that was provided in the CreateInvocationRequest.
  public var authorizationToken: String = String()

  /// If true then the Merge operation will become a Create operation if the
  /// FileSet is NOT_FOUND.
  public var createIfNotFound: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fileSet: Google_Devtools_Resultstore_V2_FileSet? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request passed into UploadBatch
public struct Google_Devtools_Resultstore_V2_UploadBatchRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the invocation being modified.
  /// The name format must be: invocations/${INVOCATION_ID}
  public var parent: String = String()

  /// Required. A UUID that must match the value provided in CreateInvocationRequest.
  public var authorizationToken: String = String()

  /// Required. The token of this batch, that will be committed in this UploadBatchRequest.
  /// If this matches the previously uploaded resume_token, then this request
  /// will silently do nothing.
  /// See CreateInvocationRequest.initial_resume_token for more information.
  /// Must be web safe Base64 encoded bytes.
  public var nextResumeToken: String = String()

  /// Required. The token of the previous batch that was committed in a UploadBatchRequest.
  /// This will be checked after next_resume_token match is checked. If this does
  /// not match the previously uploaded resume_token, a 409 Conflict (HTTPS) or
  /// ABORTED (gRPC ) error code indicating a concurrency
  /// failure will be returned, and that the user should call
  /// GetInvocationUploadMetadata to fetch the current resume_token to
  /// reconstruct the state of the upload to resume it.
  /// See CreateInvocationRequest.initial_resume_token for more information.
  /// Must be web safe Base64 encoded bytes.
  public var resumeToken: String = String()

  /// Client-specific data used to resume batch upload if an error occurs and
  /// retry is needed. This serves a role closely related to resume_token, as
  /// both fields may be used to provide state required to restore a Batch
  /// Upload, but they differ in two important aspects:
  ///  - it is not compared to previous values, and as such does not provide
  ///    concurrency control;
  ///  - it allows for a larger payload, since the contents are never
  ///    inspected/compared;
  /// The size of the message must be within 1 MiB. Too large requests will be
  /// rejected.
  public var uploaderState: Data = Data()

  /// The individual upload requests for this batch.
  /// The recommend total size for a batch is 10 MiB. Too large requests may be
  /// rejected.
  /// This field may be empty, allowing this RPC to be used like TouchInvocation.
  public var uploadRequests: [Google_Devtools_Resultstore_V2_UploadRequest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for UploadBatch
public struct Google_Devtools_Resultstore_V2_UploadBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The individual upload requests for this batch.
public struct Google_Devtools_Resultstore_V2_UploadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource ID components that identify the resource being uploaded.
  public var id: Google_Devtools_Resultstore_V2_UploadRequest.Id {
    get {return _storage._id ?? Google_Devtools_Resultstore_V2_UploadRequest.Id()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// The operation for the request (e.g. Create(), Update(), etc.)
  public var uploadOperation: Google_Devtools_Resultstore_V2_UploadRequest.UploadOperation {
    get {return _storage._uploadOperation}
    set {_uniqueStorage()._uploadOperation = newValue}
  }

  /// Required for Update and Merge operations.
  /// Ignored for Create and Finalize operations.
  /// Masks the fields of the resource being uploaded. Provides support for a
  /// more granular upload.
  /// FieldMask must match one of the follow patterns, where * means any single
  /// field name:
  /// Invocation: [*, status_attributes.*, timing.*, invocation_attributes.*,
  /// workspace_info.*].
  /// Target: [*, status_attributes.*, timing.*].
  /// Configuration: [*, status_attributes.*].
  /// ConfiguredTarget: [*, status_attributes.*].
  /// Action: [*, status_attributes.*, timing.*, test_action.test_suite,
  /// test_action.infrastructure_failure_info].
  /// FileSet: [*].
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _storage._updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_uniqueStorage()._updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return _storage._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {_uniqueStorage()._updateMask = nil}

  /// If true then the Update, Merge operation will become a Create operation if
  /// the resource is NOT_FOUND. Not supported for Invocation resource.
  public var createIfNotFound: Bool {
    get {return _storage._createIfNotFound}
    set {_uniqueStorage()._createIfNotFound = newValue}
  }

  /// The proto of the resource being uploaded.
  public var resource: OneOf_Resource? {
    get {return _storage._resource}
    set {_uniqueStorage()._resource = newValue}
  }

  /// The Invocation Resource
  public var invocation: Google_Devtools_Resultstore_V2_Invocation {
    get {
      if case .invocation(let v)? = _storage._resource {return v}
      return Google_Devtools_Resultstore_V2_Invocation()
    }
    set {_uniqueStorage()._resource = .invocation(newValue)}
  }

  /// The Target Resource
  public var target: Google_Devtools_Resultstore_V2_Target {
    get {
      if case .target(let v)? = _storage._resource {return v}
      return Google_Devtools_Resultstore_V2_Target()
    }
    set {_uniqueStorage()._resource = .target(newValue)}
  }

  /// The Configuration Resource
  public var configuration: Google_Devtools_Resultstore_V2_Configuration {
    get {
      if case .configuration(let v)? = _storage._resource {return v}
      return Google_Devtools_Resultstore_V2_Configuration()
    }
    set {_uniqueStorage()._resource = .configuration(newValue)}
  }

  /// The ConfiguredTarget Resource
  public var configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget {
    get {
      if case .configuredTarget(let v)? = _storage._resource {return v}
      return Google_Devtools_Resultstore_V2_ConfiguredTarget()
    }
    set {_uniqueStorage()._resource = .configuredTarget(newValue)}
  }

  /// The Action Resource
  public var action: Google_Devtools_Resultstore_V2_Action {
    get {
      if case .action(let v)? = _storage._resource {return v}
      return Google_Devtools_Resultstore_V2_Action()
    }
    set {_uniqueStorage()._resource = .action(newValue)}
  }

  /// The FileSet Resource
  public var fileSet: Google_Devtools_Resultstore_V2_FileSet {
    get {
      if case .fileSet(let v)? = _storage._resource {return v}
      return Google_Devtools_Resultstore_V2_FileSet()
    }
    set {_uniqueStorage()._resource = .fileSet(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The proto of the resource being uploaded.
  public enum OneOf_Resource: Equatable {
    /// The Invocation Resource
    case invocation(Google_Devtools_Resultstore_V2_Invocation)
    /// The Target Resource
    case target(Google_Devtools_Resultstore_V2_Target)
    /// The Configuration Resource
    case configuration(Google_Devtools_Resultstore_V2_Configuration)
    /// The ConfiguredTarget Resource
    case configuredTarget(Google_Devtools_Resultstore_V2_ConfiguredTarget)
    /// The Action Resource
    case action(Google_Devtools_Resultstore_V2_Action)
    /// The FileSet Resource
    case fileSet(Google_Devtools_Resultstore_V2_FileSet)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Resultstore_V2_UploadRequest.OneOf_Resource, rhs: Google_Devtools_Resultstore_V2_UploadRequest.OneOf_Resource) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.invocation, .invocation): return {
        guard case .invocation(let l) = lhs, case .invocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.target, .target): return {
        guard case .target(let l) = lhs, case .target(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuration, .configuration): return {
        guard case .configuration(let l) = lhs, case .configuration(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.configuredTarget, .configuredTarget): return {
        guard case .configuredTarget(let l) = lhs, case .configuredTarget(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.action, .action): return {
        guard case .action(let l) = lhs, case .action(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.fileSet, .fileSet): return {
        guard case .fileSet(let l) = lhs, case .fileSet(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// The operation for the request (e.g. Create(), Update(), etc.)
  public enum UploadOperation: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified
    case unspecified // = 0

    /// Create the given resources.
    /// For more information, check the Create APIs.
    case create // = 1

    /// Applies a standard update to the resource identified by the given
    /// proto's name. For more information, see the Update APIs.
    /// UploadBatch does not support arbitrary field masks. The list of allowed
    /// field masks can be found below.
    case update // = 2

    /// Applies an merge update to the resource identified by the given
    /// proto's name. For more information, see the Merge APIs.
    /// Currently, only the "files" and "file_processing_errors" fields are
    /// supported by this operation.
    case merge // = 3

    /// Declares the resource with the given name as finalized and immutable by
    /// the uploader. Only supported for Invocation, Target, ConfiguredTarget.
    /// There must be no operation on child resources after parent resource is
    /// Finalized. If there is a Finalize of Invocation, it must be the final
    /// UploadRequest. For more information, see the Finalize APIs.
    /// An empty resource should be provided below.
    case finalize // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .create
      case 2: self = .update
      case 3: self = .merge
      case 4: self = .finalize
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .create: return 1
      case .update: return 2
      case .merge: return 3
      case .finalize: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// The resource ID components that identify the resource being uploaded.
  public struct Id {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required for Target, ConfiguredTarget, or Action.
    /// The Target ID.
    public var targetID: String = String()

    /// Required for Configuration, ConfiguredTarget, or Action.
    /// The Configuration ID.
    public var configurationID: String = String()

    /// Required for Action.
    /// The Action ID.
    public var actionID: String = String()

    /// Required for FileSet.
    /// The FileSet ID.
    public var fileSetID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Devtools_Resultstore_V2_UploadRequest.UploadOperation: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Resultstore_V2_UploadRequest.UploadOperation] = [
    .unspecified,
    .create,
    .update,
    .merge,
    .finalize,
  ]
}

#endif  // swift(>=4.2)

/// Request passed into GetInvocationUploadMetadata
public struct Google_Devtools_Resultstore_V2_GetInvocationUploadMetadataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required
  /// The name of the UploadMetadata being requested.
  /// The name format must be: invocations/${INVOCATION_ID}/uploadMetadata
  public var name: String = String()

  /// Required. A UUID that must match the value provided in CreateInvocationRequest.
  public var authorizationToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.resultstore.v2"

extension Google_Devtools_Resultstore_V2_CreateInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "invocation_id"),
    3: .same(proto: "invocation"),
    4: .standard(proto: "authorization_token"),
    6: .standard(proto: "auto_finalize_time"),
    7: .standard(proto: "initial_resume_token"),
    8: .standard(proto: "uploader_state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.invocationID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._invocation) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._autoFinalizeTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.initialResumeToken) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.uploaderState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.invocationID.isEmpty {
      try visitor.visitSingularStringField(value: self.invocationID, fieldNumber: 2)
    }
    if let v = self._invocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 4)
    }
    if let v = self._autoFinalizeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.initialResumeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.initialResumeToken, fieldNumber: 7)
    }
    if !self.uploaderState.isEmpty {
      try visitor.visitSingularBytesField(value: self.uploaderState, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CreateInvocationRequest, rhs: Google_Devtools_Resultstore_V2_CreateInvocationRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.invocationID != rhs.invocationID {return false}
    if lhs._invocation != rhs._invocation {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs._autoFinalizeTime != rhs._autoFinalizeTime {return false}
    if lhs.initialResumeToken != rhs.initialResumeToken {return false}
    if lhs.uploaderState != rhs.uploaderState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UpdateInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "invocation"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._invocation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._invocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UpdateInvocationRequest, rhs: Google_Devtools_Resultstore_V2_UpdateInvocationRequest) -> Bool {
    if lhs._invocation != rhs._invocation {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_MergeInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    3: .same(proto: "invocation"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._invocation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if let v = self._invocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_MergeInvocationRequest, rhs: Google_Devtools_Resultstore_V2_MergeInvocationRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._invocation != rhs._invocation {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TouchInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TouchInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TouchInvocationRequest, rhs: Google_Devtools_Resultstore_V2_TouchInvocationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_TouchInvocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TouchInvocationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_TouchInvocationResponse, rhs: Google_Devtools_Resultstore_V2_TouchInvocationResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_DeleteInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_DeleteInvocationRequest, rhs: Google_Devtools_Resultstore_V2_DeleteInvocationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_FinalizeInvocationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinalizeInvocationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_FinalizeInvocationRequest, rhs: Google_Devtools_Resultstore_V2_FinalizeInvocationRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_FinalizeInvocationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinalizeInvocationResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_FinalizeInvocationResponse, rhs: Google_Devtools_Resultstore_V2_FinalizeInvocationResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_CreateTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "parent"),
    3: .standard(proto: "target_id"),
    4: .same(proto: "target"),
    5: .standard(proto: "authorization_token"),
  ]

  fileprivate class _StorageClass {
    var _requestID: String = String()
    var _parent: String = String()
    var _targetID: String = String()
    var _target: Google_Devtools_Resultstore_V2_Target? = nil
    var _authorizationToken: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestID = source._requestID
      _parent = source._parent
      _targetID = source._targetID
      _target = source._target
      _authorizationToken = source._authorizationToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._targetID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._authorizationToken) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 1)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 2)
      }
      if !_storage._targetID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._targetID, fieldNumber: 3)
      }
      if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._authorizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationToken, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CreateTargetRequest, rhs: Google_Devtools_Resultstore_V2_CreateTargetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._targetID != rhs_storage._targetID {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._authorizationToken != rhs_storage._authorizationToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UpdateTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "target"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  fileprivate class _StorageClass {
    var _target: Google_Devtools_Resultstore_V2_Target? = nil
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    var _authorizationToken: String = String()
    var _createIfNotFound: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _target = source._target
      _updateMask = source._updateMask
      _authorizationToken = source._authorizationToken
      _createIfNotFound = source._createIfNotFound
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._authorizationToken) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._createIfNotFound) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._authorizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationToken, fieldNumber: 5)
      }
      if _storage._createIfNotFound != false {
        try visitor.visitSingularBoolField(value: _storage._createIfNotFound, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UpdateTargetRequest, rhs: Google_Devtools_Resultstore_V2_UpdateTargetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._target != rhs_storage._target {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        if _storage._authorizationToken != rhs_storage._authorizationToken {return false}
        if _storage._createIfNotFound != rhs_storage._createIfNotFound {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_MergeTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    3: .same(proto: "target"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  fileprivate class _StorageClass {
    var _requestID: String = String()
    var _target: Google_Devtools_Resultstore_V2_Target? = nil
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    var _authorizationToken: String = String()
    var _createIfNotFound: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestID = source._requestID
      _target = source._target
      _updateMask = source._updateMask
      _authorizationToken = source._authorizationToken
      _createIfNotFound = source._createIfNotFound
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._target) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._authorizationToken) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._createIfNotFound) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 1)
      }
      if let v = _storage._target {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._authorizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationToken, fieldNumber: 5)
      }
      if _storage._createIfNotFound != false {
        try visitor.visitSingularBoolField(value: _storage._createIfNotFound, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_MergeTargetRequest, rhs: Google_Devtools_Resultstore_V2_MergeTargetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._target != rhs_storage._target {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        if _storage._authorizationToken != rhs_storage._authorizationToken {return false}
        if _storage._createIfNotFound != rhs_storage._createIfNotFound {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_FinalizeTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinalizeTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_FinalizeTargetRequest, rhs: Google_Devtools_Resultstore_V2_FinalizeTargetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_FinalizeTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinalizeTargetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_FinalizeTargetResponse, rhs: Google_Devtools_Resultstore_V2_FinalizeTargetResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_CreateConfiguredTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConfiguredTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "parent"),
    3: .standard(proto: "config_id"),
    4: .standard(proto: "configured_target"),
    5: .standard(proto: "authorization_token"),
  ]

  fileprivate class _StorageClass {
    var _requestID: String = String()
    var _parent: String = String()
    var _configID: String = String()
    var _configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget? = nil
    var _authorizationToken: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestID = source._requestID
      _parent = source._parent
      _configID = source._configID
      _configuredTarget = source._configuredTarget
      _authorizationToken = source._authorizationToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parent) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._configID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._configuredTarget) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._authorizationToken) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 1)
      }
      if !_storage._parent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parent, fieldNumber: 2)
      }
      if !_storage._configID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._configID, fieldNumber: 3)
      }
      if let v = _storage._configuredTarget {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._authorizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationToken, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CreateConfiguredTargetRequest, rhs: Google_Devtools_Resultstore_V2_CreateConfiguredTargetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._parent != rhs_storage._parent {return false}
        if _storage._configID != rhs_storage._configID {return false}
        if _storage._configuredTarget != rhs_storage._configuredTarget {return false}
        if _storage._authorizationToken != rhs_storage._authorizationToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UpdateConfiguredTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConfiguredTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "configured_target"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  fileprivate class _StorageClass {
    var _configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget? = nil
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    var _authorizationToken: String = String()
    var _createIfNotFound: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _configuredTarget = source._configuredTarget
      _updateMask = source._updateMask
      _authorizationToken = source._authorizationToken
      _createIfNotFound = source._createIfNotFound
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._configuredTarget) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._authorizationToken) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._createIfNotFound) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._configuredTarget {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._authorizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationToken, fieldNumber: 5)
      }
      if _storage._createIfNotFound != false {
        try visitor.visitSingularBoolField(value: _storage._createIfNotFound, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UpdateConfiguredTargetRequest, rhs: Google_Devtools_Resultstore_V2_UpdateConfiguredTargetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._configuredTarget != rhs_storage._configuredTarget {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        if _storage._authorizationToken != rhs_storage._authorizationToken {return false}
        if _storage._createIfNotFound != rhs_storage._createIfNotFound {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_MergeConfiguredTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeConfiguredTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    3: .standard(proto: "configured_target"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  fileprivate class _StorageClass {
    var _requestID: String = String()
    var _configuredTarget: Google_Devtools_Resultstore_V2_ConfiguredTarget? = nil
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    var _authorizationToken: String = String()
    var _createIfNotFound: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestID = source._requestID
      _configuredTarget = source._configuredTarget
      _updateMask = source._updateMask
      _authorizationToken = source._authorizationToken
      _createIfNotFound = source._createIfNotFound
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._configuredTarget) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._authorizationToken) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._createIfNotFound) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 1)
      }
      if let v = _storage._configuredTarget {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._authorizationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authorizationToken, fieldNumber: 5)
      }
      if _storage._createIfNotFound != false {
        try visitor.visitSingularBoolField(value: _storage._createIfNotFound, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_MergeConfiguredTargetRequest, rhs: Google_Devtools_Resultstore_V2_MergeConfiguredTargetRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._configuredTarget != rhs_storage._configuredTarget {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        if _storage._authorizationToken != rhs_storage._authorizationToken {return false}
        if _storage._createIfNotFound != rhs_storage._createIfNotFound {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinalizeConfiguredTargetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetRequest, rhs: Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FinalizeConfiguredTargetResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetResponse, rhs: Google_Devtools_Resultstore_V2_FinalizeConfiguredTargetResponse) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_CreateActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "parent"),
    3: .standard(proto: "action_id"),
    4: .same(proto: "action"),
    5: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 2)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 3)
    }
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CreateActionRequest, rhs: Google_Devtools_Resultstore_V2_CreateActionRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs._action != rhs._action {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UpdateActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "action"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.createIfNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    if self.createIfNotFound != false {
      try visitor.visitSingularBoolField(value: self.createIfNotFound, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UpdateActionRequest, rhs: Google_Devtools_Resultstore_V2_UpdateActionRequest) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.createIfNotFound != rhs.createIfNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_MergeActionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeActionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    3: .same(proto: "action"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.createIfNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    if self.createIfNotFound != false {
      try visitor.visitSingularBoolField(value: self.createIfNotFound, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_MergeActionRequest, rhs: Google_Devtools_Resultstore_V2_MergeActionRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._action != rhs._action {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.createIfNotFound != rhs.createIfNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_CreateConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConfigurationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "parent"),
    3: .standard(proto: "config_id"),
    4: .same(proto: "configuration"),
    5: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.configID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 2)
    }
    if !self.configID.isEmpty {
      try visitor.visitSingularStringField(value: self.configID, fieldNumber: 3)
    }
    if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CreateConfigurationRequest, rhs: Google_Devtools_Resultstore_V2_CreateConfigurationRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.configID != rhs.configID {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UpdateConfigurationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConfigurationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "configuration"),
    4: .standard(proto: "update_mask"),
    5: .standard(proto: "authorization_token"),
    6: .standard(proto: "create_if_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.createIfNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    if self.createIfNotFound != false {
      try visitor.visitSingularBoolField(value: self.createIfNotFound, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UpdateConfigurationRequest, rhs: Google_Devtools_Resultstore_V2_UpdateConfigurationRequest) -> Bool {
    if lhs._configuration != rhs._configuration {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.createIfNotFound != rhs.createIfNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_CreateFileSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateFileSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .same(proto: "parent"),
    3: .standard(proto: "file_set_id"),
    4: .standard(proto: "file_set"),
    5: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fileSetID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._fileSet) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 2)
    }
    if !self.fileSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileSetID, fieldNumber: 3)
    }
    if let v = self._fileSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_CreateFileSetRequest, rhs: Google_Devtools_Resultstore_V2_CreateFileSetRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.fileSetID != rhs.fileSetID {return false}
    if lhs._fileSet != rhs._fileSet {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UpdateFileSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateFileSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_set"),
    2: .standard(proto: "update_mask"),
    3: .standard(proto: "authorization_token"),
    4: .standard(proto: "create_if_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fileSet) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.createIfNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fileSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 3)
    }
    if self.createIfNotFound != false {
      try visitor.visitSingularBoolField(value: self.createIfNotFound, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UpdateFileSetRequest, rhs: Google_Devtools_Resultstore_V2_UpdateFileSetRequest) -> Bool {
    if lhs._fileSet != rhs._fileSet {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.createIfNotFound != rhs.createIfNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_MergeFileSetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MergeFileSetRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "file_set"),
    3: .standard(proto: "update_mask"),
    4: .standard(proto: "authorization_token"),
    5: .standard(proto: "create_if_not_found"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fileSet) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.createIfNotFound) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if let v = self._fileSet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 4)
    }
    if self.createIfNotFound != false {
      try visitor.visitSingularBoolField(value: self.createIfNotFound, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_MergeFileSetRequest, rhs: Google_Devtools_Resultstore_V2_MergeFileSetRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._fileSet != rhs._fileSet {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.createIfNotFound != rhs.createIfNotFound {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UploadBatchRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadBatchRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "authorization_token"),
    3: .standard(proto: "next_resume_token"),
    4: .standard(proto: "resume_token"),
    6: .standard(proto: "uploader_state"),
    5: .standard(proto: "upload_requests"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.nextResumeToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resumeToken) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.uploadRequests) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.uploaderState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 2)
    }
    if !self.nextResumeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextResumeToken, fieldNumber: 3)
    }
    if !self.resumeToken.isEmpty {
      try visitor.visitSingularStringField(value: self.resumeToken, fieldNumber: 4)
    }
    if !self.uploadRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.uploadRequests, fieldNumber: 5)
    }
    if !self.uploaderState.isEmpty {
      try visitor.visitSingularBytesField(value: self.uploaderState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UploadBatchRequest, rhs: Google_Devtools_Resultstore_V2_UploadBatchRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.nextResumeToken != rhs.nextResumeToken {return false}
    if lhs.resumeToken != rhs.resumeToken {return false}
    if lhs.uploaderState != rhs.uploaderState {return false}
    if lhs.uploadRequests != rhs.uploadRequests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UploadBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadBatchResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UploadBatchResponse, rhs: Google_Devtools_Resultstore_V2_UploadBatchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "upload_operation"),
    3: .standard(proto: "update_mask"),
    10: .standard(proto: "create_if_not_found"),
    4: .same(proto: "invocation"),
    5: .same(proto: "target"),
    6: .same(proto: "configuration"),
    7: .standard(proto: "configured_target"),
    8: .same(proto: "action"),
    9: .standard(proto: "file_set"),
  ]

  fileprivate class _StorageClass {
    var _id: Google_Devtools_Resultstore_V2_UploadRequest.Id? = nil
    var _uploadOperation: Google_Devtools_Resultstore_V2_UploadRequest.UploadOperation = .unspecified
    var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    var _createIfNotFound: Bool = false
    var _resource: Google_Devtools_Resultstore_V2_UploadRequest.OneOf_Resource?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _uploadOperation = source._uploadOperation
      _updateMask = source._updateMask
      _createIfNotFound = source._createIfNotFound
      _resource = source._resource
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._uploadOperation) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._updateMask) }()
        case 4: try {
          var v: Google_Devtools_Resultstore_V2_Invocation?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .invocation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .invocation(v)}
        }()
        case 5: try {
          var v: Google_Devtools_Resultstore_V2_Target?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .target(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .target(v)}
        }()
        case 6: try {
          var v: Google_Devtools_Resultstore_V2_Configuration?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .configuration(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .configuration(v)}
        }()
        case 7: try {
          var v: Google_Devtools_Resultstore_V2_ConfiguredTarget?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .configuredTarget(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .configuredTarget(v)}
        }()
        case 8: try {
          var v: Google_Devtools_Resultstore_V2_Action?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .action(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .action(v)}
        }()
        case 9: try {
          var v: Google_Devtools_Resultstore_V2_FileSet?
          if let current = _storage._resource {
            try decoder.handleConflictingOneOf()
            if case .fileSet(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._resource = .fileSet(v)}
        }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._createIfNotFound) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._uploadOperation != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._uploadOperation, fieldNumber: 2)
      }
      if let v = _storage._updateMask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._resource {
      case .invocation?: try {
        guard case .invocation(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .target?: try {
        guard case .target(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .configuration?: try {
        guard case .configuration(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .configuredTarget?: try {
        guard case .configuredTarget(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .action?: try {
        guard case .action(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .fileSet?: try {
        guard case .fileSet(let v)? = _storage._resource else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
      if _storage._createIfNotFound != false {
        try visitor.visitSingularBoolField(value: _storage._createIfNotFound, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UploadRequest, rhs: Google_Devtools_Resultstore_V2_UploadRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._uploadOperation != rhs_storage._uploadOperation {return false}
        if _storage._updateMask != rhs_storage._updateMask {return false}
        if _storage._createIfNotFound != rhs_storage._createIfNotFound {return false}
        if _storage._resource != rhs_storage._resource {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_UploadRequest.UploadOperation: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPLOAD_OPERATION_UNSPECIFIED"),
    1: .same(proto: "CREATE"),
    2: .same(proto: "UPDATE"),
    3: .same(proto: "MERGE"),
    4: .same(proto: "FINALIZE"),
  ]
}

extension Google_Devtools_Resultstore_V2_UploadRequest.Id: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Resultstore_V2_UploadRequest.protoMessageName + ".Id"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "target_id"),
    2: .standard(proto: "configuration_id"),
    3: .standard(proto: "action_id"),
    4: .standard(proto: "file_set_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.configurationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.actionID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.fileSetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 1)
    }
    if !self.configurationID.isEmpty {
      try visitor.visitSingularStringField(value: self.configurationID, fieldNumber: 2)
    }
    if !self.actionID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionID, fieldNumber: 3)
    }
    if !self.fileSetID.isEmpty {
      try visitor.visitSingularStringField(value: self.fileSetID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_UploadRequest.Id, rhs: Google_Devtools_Resultstore_V2_UploadRequest.Id) -> Bool {
    if lhs.targetID != rhs.targetID {return false}
    if lhs.configurationID != rhs.configurationID {return false}
    if lhs.actionID != rhs.actionID {return false}
    if lhs.fileSetID != rhs.fileSetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Resultstore_V2_GetInvocationUploadMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInvocationUploadMetadataRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "authorization_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.authorizationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.authorizationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.authorizationToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Resultstore_V2_GetInvocationUploadMetadataRequest, rhs: Google_Devtools_Resultstore_V2_GetInvocationUploadMetadataRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.authorizationToken != rhs.authorizationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

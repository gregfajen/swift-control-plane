// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/cloudtrace/v1/trace.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A trace describes how long it takes for an application to perform an
/// operation. It consists of a set of spans, each of which represent a single
/// timed event within the operation.
public struct Google_Devtools_Cloudtrace_V1_Trace {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Project ID of the Cloud project where the trace data is stored.
  public var projectID: String = String()

  /// Globally unique identifier for the trace. This identifier is a 128-bit
  /// numeric value formatted as a 32-byte hex string. For example,
  /// `382d4f4c6b7bb2f4a972559d9085001d`.
  public var traceID: String = String()

  /// Collection of spans in the trace.
  public var spans: [Google_Devtools_Cloudtrace_V1_TraceSpan] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// List of new or updated traces.
public struct Google_Devtools_Cloudtrace_V1_Traces {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of traces.
  public var traces: [Google_Devtools_Cloudtrace_V1_Trace] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A span represents a single timed event within a trace. Spans can be nested
/// and form a trace tree. Often, a trace contains a root span that describes the
/// end-to-end latency of an operation and, optionally, one or more subspans for
/// its suboperations. Spans do not need to be contiguous. There may be gaps
/// between spans in a trace.
public struct Google_Devtools_Cloudtrace_V1_TraceSpan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier for the span. Must be a 64-bit integer other than 0 and
  /// unique within a trace. For example, `2205310701640571284`.
  public var spanID: UInt64 = 0

  /// Distinguishes between spans generated in a particular context. For example,
  /// two spans with the same name may be distinguished using `RPC_CLIENT`
  /// and `RPC_SERVER` to identify queueing latency associated with the span.
  public var kind: Google_Devtools_Cloudtrace_V1_TraceSpan.SpanKind = .unspecified

  /// Name of the span. Must be less than 128 bytes. The span name is sanitized
  /// and displayed in the Stackdriver Trace tool in the
  /// Google Cloud Platform Console.
  /// The name may be a method name or some other per-call site name.
  /// For the same executable and the same call point, a best practice is
  /// to use a consistent name, which makes it easier to correlate
  /// cross-trace spans.
  public var name: String = String()

  /// Start time of the span in nanoseconds from the UNIX epoch.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// End time of the span in nanoseconds from the UNIX epoch.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Optional. ID of the parent span, if any.
  public var parentSpanID: UInt64 = 0

  /// Collection of labels associated with the span. Label keys must be less than
  /// 128 bytes. Label values must be less than 16 kilobytes (10MB for
  /// `/stacktrace` values).
  ///
  /// Some predefined label keys exist, or you may create your own. When creating
  /// your own, we recommend the following formats:
  ///
  /// * `/category/product/key` for agents of well-known products (e.g.
  ///   `/db/mongodb/read_size`).
  /// * `short_host/path/key` for domain-specific keys (e.g.
  ///   `foo.com/myproduct/bar`)
  ///
  /// Predefined labels include:
  ///
  /// *   `/agent`
  /// *   `/component`
  /// *   `/error/message`
  /// *   `/error/name`
  /// *   `/http/client_city`
  /// *   `/http/client_country`
  /// *   `/http/client_protocol`
  /// *   `/http/client_region`
  /// *   `/http/host`
  /// *   `/http/method`
  /// *   `/http/path`
  /// *   `/http/redirected_url`
  /// *   `/http/request/size`
  /// *   `/http/response/size`
  /// *   `/http/route`
  /// *   `/http/status_code`
  /// *   `/http/url`
  /// *   `/http/user_agent`
  /// *   `/pid`
  /// *   `/stacktrace`
  /// *   `/tid`
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of span. Can be used to specify additional relationships between spans
  /// in addition to a parent/child relationship.
  public enum SpanKind: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Indicates that the span covers server-side handling of an RPC or other
    /// remote network request.
    case rpcServer // = 1

    /// Indicates that the span covers the client-side wrapper around an RPC or
    /// other remote request.
    case rpcClient // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .rpcServer
      case 2: self = .rpcClient
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .rpcServer: return 1
      case .rpcClient: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Devtools_Cloudtrace_V1_TraceSpan.SpanKind: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudtrace_V1_TraceSpan.SpanKind] = [
    .unspecified,
    .rpcServer,
    .rpcClient,
  ]
}

#endif  // swift(>=4.2)

/// The request message for the `ListTraces` method. All fields are required
/// unless specified.
public struct Google_Devtools_Cloudtrace_V1_ListTracesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the Cloud project where the trace data is stored.
  public var projectID: String = String()

  /// Optional. Type of data returned for traces in the list. Default is
  /// `MINIMAL`.
  public var view: Google_Devtools_Cloudtrace_V1_ListTracesRequest.ViewType = .unspecified

  /// Optional. Maximum number of traces to return. If not specified or <= 0, the
  /// implementation selects a reasonable value.  The implementation may
  /// return fewer traces than the requested page size.
  public var pageSize: Int32 = 0

  /// Token identifying the page of results to return. If provided, use the
  /// value of the `next_page_token` field from a previous request.
  public var pageToken: String = String()

  /// Start of the time interval (inclusive) during which the trace data was
  /// collected from the application.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// End of the time interval (inclusive) during which the trace data was
  /// collected from the application.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  /// Optional. A filter against labels for the request.
  ///
  /// By default, searches use prefix matching. To specify exact match, prepend
  /// a plus symbol (`+`) to the search term.
  /// Multiple terms are ANDed. Syntax:
  ///
  /// *   `root:NAME_PREFIX` or `NAME_PREFIX`: Return traces where any root
  ///     span starts with `NAME_PREFIX`.
  /// *   `+root:NAME` or `+NAME`: Return traces where any root span's name is
  ///     exactly `NAME`.
  /// *   `span:NAME_PREFIX`: Return traces where any span starts with
  ///     `NAME_PREFIX`.
  /// *   `+span:NAME`: Return traces where any span's name is exactly
  ///     `NAME`.
  /// *   `latency:DURATION`: Return traces whose overall latency is
  ///     greater or equal to than `DURATION`. Accepted units are nanoseconds
  ///     (`ns`), milliseconds (`ms`), and seconds (`s`). Default is `ms`. For
  ///     example, `latency:24ms` returns traces whose overall latency
  ///     is greater than or equal to 24 milliseconds.
  /// *   `label:LABEL_KEY`: Return all traces containing the specified
  ///     label key (exact match, case-sensitive) regardless of the key:value
  ///     pair's value (including empty values).
  /// *   `LABEL_KEY:VALUE_PREFIX`: Return all traces containing the specified
  ///     label key (exact match, case-sensitive) whose value starts with
  ///     `VALUE_PREFIX`. Both a key and a value must be specified.
  /// *   `+LABEL_KEY:VALUE`: Return all traces containing a key:value pair
  ///     exactly matching the specified text. Both a key and a value must be
  ///     specified.
  /// *   `method:VALUE`: Equivalent to `/http/method:VALUE`.
  /// *   `url:VALUE`: Equivalent to `/http/url:VALUE`.
  public var filter: String = String()

  /// Optional. Field used to sort the returned traces.
  /// Can be one of the following:
  ///
  /// *   `trace_id`
  /// *   `name` (`name` field of root span in the trace)
  /// *   `duration` (difference between `end_time` and `start_time` fields of
  ///      the root span)
  /// *   `start` (`start_time` field of the root span)
  ///
  /// Descending order can be specified by appending `desc` to the sort field
  /// (for example, `name desc`).
  ///
  /// Only one sort field is permitted.
  public var orderBy: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Type of data returned for traces in the list.
  public enum ViewType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default is `MINIMAL` if unspecified.
    case unspecified // = 0

    /// Minimal view of the trace record that contains only the project
    /// and trace IDs.
    case minimal // = 1

    /// Root span view of the trace record that returns the root spans along
    /// with the minimal trace data.
    case rootspan // = 2

    /// Complete view of the trace record that contains the actual trace data.
    /// This is equivalent to calling the REST `get` or RPC `GetTrace` method
    /// using the ID of each listed trace.
    case complete // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .minimal
      case 2: self = .rootspan
      case 3: self = .complete
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .minimal: return 1
      case .rootspan: return 2
      case .complete: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Devtools_Cloudtrace_V1_ListTracesRequest.ViewType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudtrace_V1_ListTracesRequest.ViewType] = [
    .unspecified,
    .minimal,
    .rootspan,
    .complete,
  ]
}

#endif  // swift(>=4.2)

/// The response message for the `ListTraces` method.
public struct Google_Devtools_Cloudtrace_V1_ListTracesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of trace records as specified by the view parameter.
  public var traces: [Google_Devtools_Cloudtrace_V1_Trace] = []

  /// If defined, indicates that there are more traces that match the request
  /// and that this value should be passed to the next request to continue
  /// retrieving additional traces.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for the `GetTrace` method.
public struct Google_Devtools_Cloudtrace_V1_GetTraceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the Cloud project where the trace data is stored.
  public var projectID: String = String()

  /// Required. ID of the trace to return.
  public var traceID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request message for the `PatchTraces` method.
public struct Google_Devtools_Cloudtrace_V1_PatchTracesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the Cloud project where the trace data is stored.
  public var projectID: String = String()

  /// Required. The body of the message.
  public var traces: Google_Devtools_Cloudtrace_V1_Traces {
    get {return _traces ?? Google_Devtools_Cloudtrace_V1_Traces()}
    set {_traces = newValue}
  }
  /// Returns true if `traces` has been explicitly set.
  public var hasTraces: Bool {return self._traces != nil}
  /// Clears the value of `traces`. Subsequent reads from it will return its default value.
  public mutating func clearTraces() {self._traces = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _traces: Google_Devtools_Cloudtrace_V1_Traces? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.cloudtrace.v1"

extension Google_Devtools_Cloudtrace_V1_Trace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Trace"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "trace_id"),
    3: .same(proto: "spans"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 2)
    }
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_Trace, rhs: Google_Devtools_Cloudtrace_V1_Trace) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.spans != rhs.spans {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V1_Traces: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Traces"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "traces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.traces) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_Traces, rhs: Google_Devtools_Cloudtrace_V1_Traces) -> Bool {
    if lhs.traces != rhs.traces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V1_TraceSpan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TraceSpan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "span_id"),
    2: .same(proto: "kind"),
    3: .same(proto: "name"),
    4: .standard(proto: "start_time"),
    5: .standard(proto: "end_time"),
    6: .standard(proto: "parent_span_id"),
    7: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.spanID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularFixed64Field(value: &self.parentSpanID) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.spanID != 0 {
      try visitor.visitSingularFixed64Field(value: self.spanID, fieldNumber: 1)
    }
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if self.parentSpanID != 0 {
      try visitor.visitSingularFixed64Field(value: self.parentSpanID, fieldNumber: 6)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_TraceSpan, rhs: Google_Devtools_Cloudtrace_V1_TraceSpan) -> Bool {
    if lhs.spanID != rhs.spanID {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.name != rhs.name {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.parentSpanID != rhs.parentSpanID {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V1_TraceSpan.SpanKind: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SPAN_KIND_UNSPECIFIED"),
    1: .same(proto: "RPC_SERVER"),
    2: .same(proto: "RPC_CLIENT"),
  ]
}

extension Google_Devtools_Cloudtrace_V1_ListTracesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTracesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "view"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
    5: .standard(proto: "start_time"),
    6: .standard(proto: "end_time"),
    7: .same(proto: "filter"),
    8: .standard(proto: "order_by"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.view) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.orderBy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if self.view != .unspecified {
      try visitor.visitSingularEnumField(value: self.view, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 7)
    }
    if !self.orderBy.isEmpty {
      try visitor.visitSingularStringField(value: self.orderBy, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_ListTracesRequest, rhs: Google_Devtools_Cloudtrace_V1_ListTracesRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.view != rhs.view {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.orderBy != rhs.orderBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V1_ListTracesRequest.ViewType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VIEW_TYPE_UNSPECIFIED"),
    1: .same(proto: "MINIMAL"),
    2: .same(proto: "ROOTSPAN"),
    3: .same(proto: "COMPLETE"),
  ]
}

extension Google_Devtools_Cloudtrace_V1_ListTracesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTracesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "traces"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.traces) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.traces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.traces, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_ListTracesResponse, rhs: Google_Devtools_Cloudtrace_V1_ListTracesResponse) -> Bool {
    if lhs.traces != rhs.traces {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V1_GetTraceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTraceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "trace_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.traceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.traceID.isEmpty {
      try visitor.visitSingularStringField(value: self.traceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_GetTraceRequest, rhs: Google_Devtools_Cloudtrace_V1_GetTraceRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.traceID != rhs.traceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudtrace_V1_PatchTracesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchTracesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "traces"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._traces) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if let v = self._traces {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudtrace_V1_PatchTracesRequest, rhs: Google_Devtools_Cloudtrace_V1_PatchTracesRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs._traces != rhs._traces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

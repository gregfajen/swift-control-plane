// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/clouddebugger/v2/debugger.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to set a breakpoint
public struct Google_Devtools_Clouddebugger_V2_SetBreakpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the debuggee where the breakpoint is to be set.
  public var debuggeeID: String = String()

  /// Required. Breakpoint specification to set.
  /// The field `location` of the breakpoint must be set.
  public var breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint {
    get {return _breakpoint ?? Google_Devtools_Clouddebugger_V2_Breakpoint()}
    set {_breakpoint = newValue}
  }
  /// Returns true if `breakpoint` has been explicitly set.
  public var hasBreakpoint: Bool {return self._breakpoint != nil}
  /// Clears the value of `breakpoint`. Subsequent reads from it will return its default value.
  public mutating func clearBreakpoint() {self._breakpoint = nil}

  /// Required. The client version making the call.
  /// Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
  public var clientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint? = nil
}

/// Response for setting a breakpoint.
public struct Google_Devtools_Clouddebugger_V2_SetBreakpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Breakpoint resource.
  /// The field `id` is guaranteed to be set (in addition to the echoed fileds).
  public var breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint {
    get {return _breakpoint ?? Google_Devtools_Clouddebugger_V2_Breakpoint()}
    set {_breakpoint = newValue}
  }
  /// Returns true if `breakpoint` has been explicitly set.
  public var hasBreakpoint: Bool {return self._breakpoint != nil}
  /// Clears the value of `breakpoint`. Subsequent reads from it will return its default value.
  public mutating func clearBreakpoint() {self._breakpoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint? = nil
}

/// Request to get breakpoint information.
public struct Google_Devtools_Clouddebugger_V2_GetBreakpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the debuggee whose breakpoint to get.
  public var debuggeeID: String = String()

  /// Required. ID of the breakpoint to get.
  public var breakpointID: String = String()

  /// Required. The client version making the call.
  /// Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
  public var clientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for getting breakpoint information.
public struct Google_Devtools_Clouddebugger_V2_GetBreakpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Complete breakpoint state.
  /// The fields `id` and `location` are guaranteed to be set.
  public var breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint {
    get {return _breakpoint ?? Google_Devtools_Clouddebugger_V2_Breakpoint()}
    set {_breakpoint = newValue}
  }
  /// Returns true if `breakpoint` has been explicitly set.
  public var hasBreakpoint: Bool {return self._breakpoint != nil}
  /// Clears the value of `breakpoint`. Subsequent reads from it will return its default value.
  public mutating func clearBreakpoint() {self._breakpoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint? = nil
}

/// Request to delete a breakpoint.
public struct Google_Devtools_Clouddebugger_V2_DeleteBreakpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the debuggee whose breakpoint to delete.
  public var debuggeeID: String = String()

  /// Required. ID of the breakpoint to delete.
  public var breakpointID: String = String()

  /// Required. The client version making the call.
  /// Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
  public var clientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list breakpoints.
public struct Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the debuggee whose breakpoints to list.
  public var debuggeeID: String = String()

  /// When set to `true`, the response includes the list of breakpoints set by
  /// any user. Otherwise, it includes only breakpoints set by the caller.
  public var includeAllUsers: Bool = false

  /// When set to `true`, the response includes active and inactive
  /// breakpoints. Otherwise, it includes only active breakpoints.
  public var includeInactive: Bool = false

  /// When set, the response includes only breakpoints with the specified action.
  public var action: Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.BreakpointActionValue {
    get {return _action ?? Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.BreakpointActionValue()}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  public var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  public mutating func clearAction() {self._action = nil}

  /// This field is deprecated. The following fields are always stripped out of
  /// the result: `stack_frames`, `evaluated_expressions` and `variable_table`.
  public var stripResults: Bool = false

  /// A wait token that, if specified, blocks the call until the breakpoints
  /// list has changed, or a server selected timeout has expired.  The value
  /// should be set from the last response. The error code
  /// `google.rpc.Code.ABORTED` (RPC) is returned on wait timeout, which
  /// should be called again with the same `wait_token`.
  public var waitToken: String = String()

  /// Required. The client version making the call.
  /// Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
  public var clientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Wrapper message for `Breakpoint.Action`. Defines a filter on the action
  /// field of breakpoints.
  public struct BreakpointActionValue {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only breakpoints with the specified action will pass the filter.
    public var value: Google_Devtools_Clouddebugger_V2_Breakpoint.Action = .capture

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _action: Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.BreakpointActionValue? = nil
}

/// Response for listing breakpoints.
public struct Google_Devtools_Clouddebugger_V2_ListBreakpointsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of breakpoints matching the request.
  /// The fields `id` and `location` are guaranteed to be set on each breakpoint.
  /// The fields: `stack_frames`, `evaluated_expressions` and `variable_table`
  /// are cleared on each breakpoint regardless of its status.
  public var breakpoints: [Google_Devtools_Clouddebugger_V2_Breakpoint] = []

  /// A wait token that can be used in the next call to `list` (REST) or
  /// `ListBreakpoints` (RPC) to block until the list of breakpoints has changes.
  public var nextWaitToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list debuggees.
public struct Google_Devtools_Clouddebugger_V2_ListDebuggeesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Project number of a Google Cloud project whose debuggees to list.
  public var project: String = String()

  /// When set to `true`, the result includes all debuggees. Otherwise, the
  /// result includes only debuggees that are active.
  public var includeInactive: Bool = false

  /// Required. The client version making the call.
  /// Schema: `domain/type/version` (e.g., `google.com/intellij/v1`).
  public var clientVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for listing debuggees.
public struct Google_Devtools_Clouddebugger_V2_ListDebuggeesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of debuggees accessible to the calling user.
  /// The fields `debuggee.id` and `description` are guaranteed to be set.
  /// The `description` field is a human readable field provided by agents and
  /// can be displayed to users.
  public var debuggees: [Google_Devtools_Clouddebugger_V2_Debuggee] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.clouddebugger.v2"

extension Google_Devtools_Clouddebugger_V2_SetBreakpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetBreakpointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debuggee_id"),
    2: .same(proto: "breakpoint"),
    4: .standard(proto: "client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggeeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._breakpoint) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggeeID, fieldNumber: 1)
    }
    if let v = self._breakpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_SetBreakpointRequest, rhs: Google_Devtools_Clouddebugger_V2_SetBreakpointRequest) -> Bool {
    if lhs.debuggeeID != rhs.debuggeeID {return false}
    if lhs._breakpoint != rhs._breakpoint {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_SetBreakpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetBreakpointResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "breakpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._breakpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._breakpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_SetBreakpointResponse, rhs: Google_Devtools_Clouddebugger_V2_SetBreakpointResponse) -> Bool {
    if lhs._breakpoint != rhs._breakpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_GetBreakpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBreakpointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debuggee_id"),
    2: .standard(proto: "breakpoint_id"),
    4: .standard(proto: "client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggeeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.breakpointID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggeeID, fieldNumber: 1)
    }
    if !self.breakpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.breakpointID, fieldNumber: 2)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_GetBreakpointRequest, rhs: Google_Devtools_Clouddebugger_V2_GetBreakpointRequest) -> Bool {
    if lhs.debuggeeID != rhs.debuggeeID {return false}
    if lhs.breakpointID != rhs.breakpointID {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_GetBreakpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBreakpointResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "breakpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._breakpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._breakpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_GetBreakpointResponse, rhs: Google_Devtools_Clouddebugger_V2_GetBreakpointResponse) -> Bool {
    if lhs._breakpoint != rhs._breakpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_DeleteBreakpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteBreakpointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debuggee_id"),
    2: .standard(proto: "breakpoint_id"),
    3: .standard(proto: "client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggeeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.breakpointID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggeeID, fieldNumber: 1)
    }
    if !self.breakpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.breakpointID, fieldNumber: 2)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_DeleteBreakpointRequest, rhs: Google_Devtools_Clouddebugger_V2_DeleteBreakpointRequest) -> Bool {
    if lhs.debuggeeID != rhs.debuggeeID {return false}
    if lhs.breakpointID != rhs.breakpointID {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBreakpointsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debuggee_id"),
    2: .standard(proto: "include_all_users"),
    3: .standard(proto: "include_inactive"),
    4: .same(proto: "action"),
    5: .standard(proto: "strip_results"),
    6: .standard(proto: "wait_token"),
    8: .standard(proto: "client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggeeID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeAllUsers) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeInactive) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._action) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.stripResults) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.waitToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggeeID, fieldNumber: 1)
    }
    if self.includeAllUsers != false {
      try visitor.visitSingularBoolField(value: self.includeAllUsers, fieldNumber: 2)
    }
    if self.includeInactive != false {
      try visitor.visitSingularBoolField(value: self.includeInactive, fieldNumber: 3)
    }
    if let v = self._action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.stripResults != false {
      try visitor.visitSingularBoolField(value: self.stripResults, fieldNumber: 5)
    }
    if !self.waitToken.isEmpty {
      try visitor.visitSingularStringField(value: self.waitToken, fieldNumber: 6)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest, rhs: Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest) -> Bool {
    if lhs.debuggeeID != rhs.debuggeeID {return false}
    if lhs.includeAllUsers != rhs.includeAllUsers {return false}
    if lhs.includeInactive != rhs.includeInactive {return false}
    if lhs._action != rhs._action {return false}
    if lhs.stripResults != rhs.stripResults {return false}
    if lhs.waitToken != rhs.waitToken {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.BreakpointActionValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.protoMessageName + ".BreakpointActionValue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != .capture {
      try visitor.visitSingularEnumField(value: self.value, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.BreakpointActionValue, rhs: Google_Devtools_Clouddebugger_V2_ListBreakpointsRequest.BreakpointActionValue) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListBreakpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBreakpointsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "breakpoints"),
    2: .standard(proto: "next_wait_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.breakpoints) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextWaitToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.breakpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.breakpoints, fieldNumber: 1)
    }
    if !self.nextWaitToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextWaitToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListBreakpointsResponse, rhs: Google_Devtools_Clouddebugger_V2_ListBreakpointsResponse) -> Bool {
    if lhs.breakpoints != rhs.breakpoints {return false}
    if lhs.nextWaitToken != rhs.nextWaitToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListDebuggeesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDebuggeesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "project"),
    3: .standard(proto: "include_inactive"),
    4: .standard(proto: "client_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeInactive) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clientVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 2)
    }
    if self.includeInactive != false {
      try visitor.visitSingularBoolField(value: self.includeInactive, fieldNumber: 3)
    }
    if !self.clientVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.clientVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListDebuggeesRequest, rhs: Google_Devtools_Clouddebugger_V2_ListDebuggeesRequest) -> Bool {
    if lhs.project != rhs.project {return false}
    if lhs.includeInactive != rhs.includeInactive {return false}
    if lhs.clientVersion != rhs.clientVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListDebuggeesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDebuggeesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debuggees"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.debuggees) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggees.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.debuggees, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListDebuggeesResponse, rhs: Google_Devtools_Clouddebugger_V2_ListDebuggeesResponse) -> Bool {
    if lhs.debuggees != rhs.debuggees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/clouddebugger/v2/data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Represents a message with parameters.
public struct Google_Devtools_Clouddebugger_V2_FormatMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Format template for the message. The `format` uses placeholders `$0`,
  /// `$1`, etc. to reference parameters. `$$` can be used to denote the `$`
  /// character.
  ///
  /// Examples:
  ///
  /// *   `Failed to load '$0' which helps debug $1 the first time it
  ///     is loaded.  Again, $0 is very important.`
  /// *   `Please pay $$10 to use $0 instead of $1.`
  public var format: String = String()

  /// Optional parameters to be embedded into the message.
  public var parameters: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a contextual status message.
/// The message can indicate an error or informational status, and refer to
/// specific parts of the containing object.
/// For example, the `Breakpoint.status` field can indicate an error referring
/// to the `BREAKPOINT_SOURCE_LOCATION` with the message `Location not found`.
public struct Google_Devtools_Clouddebugger_V2_StatusMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Distinguishes errors from informational messages.
  public var isError: Bool = false

  /// Reference to which the message applies.
  public var refersTo: Google_Devtools_Clouddebugger_V2_StatusMessage.Reference = .unspecified

  /// Status message text.
  public var description_p: Google_Devtools_Clouddebugger_V2_FormatMessage {
    get {return _description_p ?? Google_Devtools_Clouddebugger_V2_FormatMessage()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  public var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  public mutating func clearDescription_p() {self._description_p = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Enumerates references to which the message applies.
  public enum Reference: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status doesn't refer to any particular input.
    case unspecified // = 0

    /// Status applies to the breakpoint and is related to its location.
    case breakpointSourceLocation // = 3

    /// Status applies to the breakpoint and is related to its condition.
    case breakpointCondition // = 4

    /// Status applies to the breakpoint and is related to its expressions.
    case breakpointExpression // = 7

    /// Status applies to the breakpoint and is related to its age.
    case breakpointAge // = 8

    /// Status applies to the entire variable.
    case variableName // = 5

    /// Status applies to variable value (variable name is valid).
    case variableValue // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 3: self = .breakpointSourceLocation
      case 4: self = .breakpointCondition
      case 5: self = .variableName
      case 6: self = .variableValue
      case 7: self = .breakpointExpression
      case 8: self = .breakpointAge
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .breakpointSourceLocation: return 3
      case .breakpointCondition: return 4
      case .variableName: return 5
      case .variableValue: return 6
      case .breakpointExpression: return 7
      case .breakpointAge: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _description_p: Google_Devtools_Clouddebugger_V2_FormatMessage? = nil
}

#if swift(>=4.2)

extension Google_Devtools_Clouddebugger_V2_StatusMessage.Reference: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Clouddebugger_V2_StatusMessage.Reference] = [
    .unspecified,
    .breakpointSourceLocation,
    .breakpointCondition,
    .breakpointExpression,
    .breakpointAge,
    .variableName,
    .variableValue,
  ]
}

#endif  // swift(>=4.2)

/// Represents a location in the source code.
public struct Google_Devtools_Clouddebugger_V2_SourceLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Path to the source file within the source context of the target binary.
  public var path: String = String()

  /// Line inside the file. The first line in the file has the value `1`.
  public var line: Int32 = 0

  /// Column within a line. The first column in a line as the value `1`.
  /// Agents that do not support setting breakpoints on specific columns ignore
  /// this field.
  public var column: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Represents a variable or an argument possibly of a compound object type.
/// Note how the following variables are represented:
///
/// 1) A simple variable:
///
///     int x = 5
///
///     { name: "x", value: "5", type: "int" }  // Captured variable
///
/// 2) A compound object:
///
///     struct T {
///         int m1;
///         int m2;
///     };
///     T x = { 3, 7 };
///
///     {  // Captured variable
///         name: "x",
///         type: "T",
///         members { name: "m1", value: "3", type: "int" },
///         members { name: "m2", value: "7", type: "int" }
///     }
///
/// 3) A pointer where the pointee was captured:
///
///     T x = { 3, 7 };
///     T* p = &x;
///
///     {   // Captured variable
///         name: "p",
///         type: "T*",
///         value: "0x00500500",
///         members { name: "m1", value: "3", type: "int" },
///         members { name: "m2", value: "7", type: "int" }
///     }
///
/// 4) A pointer where the pointee was not captured:
///
///     T* p = new T;
///
///     {   // Captured variable
///         name: "p",
///         type: "T*",
///         value: "0x00400400"
///         status { is_error: true, description { format: "unavailable" } }
///     }
///
/// The status should describe the reason for the missing value,
/// such as `<optimized out>`, `<inaccessible>`, `<pointers limit reached>`.
///
/// Note that a null pointer should not have members.
///
/// 5) An unnamed value:
///
///     int* p = new int(7);
///
///     {   // Captured variable
///         name: "p",
///         value: "0x00500500",
///         type: "int*",
///         members { value: "7", type: "int" } }
///
/// 6) An unnamed pointer where the pointee was not captured:
///
///     int* p = new int(7);
///     int** pp = &p;
///
///     {  // Captured variable
///         name: "pp",
///         value: "0x00500500",
///         type: "int**",
///         members {
///             value: "0x00400400",
///             type: "int*"
///             status {
///                 is_error: true,
///                 description: { format: "unavailable" } }
///             }
///         }
///     }
///
/// To optimize computation, memory and network traffic, variables that
/// repeat in the output multiple times can be stored once in a shared
/// variable table and be referenced using the `var_table_index` field.  The
/// variables stored in the shared table are nameless and are essentially
/// a partition of the complete variable. To reconstruct the complete
/// variable, merge the referencing variable with the referenced variable.
///
/// When using the shared variable table, the following variables:
///
///     T x = { 3, 7 };
///     T* p = &x;
///     T& r = x;
///
///     { name: "x", var_table_index: 3, type: "T" }  // Captured variables
///     { name: "p", value "0x00500500", type="T*", var_table_index: 3 }
///     { name: "r", type="T&", var_table_index: 3 }
///
///     {  // Shared variable table entry #3:
///         members { name: "m1", value: "3", type: "int" },
///         members { name: "m2", value: "7", type: "int" }
///     }
///
/// Note that the pointer address is stored with the referencing variable
/// and not with the referenced variable. This allows the referenced variable
/// to be shared between pointers and references.
///
/// The type field is optional. The debugger agent may or may not support it.
public struct Google_Devtools_Clouddebugger_V2_Variable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the variable, if any.
  public var name: String = String()

  /// Simple value of the variable.
  public var value: String = String()

  /// Variable type (e.g. `MyClass`). If the variable is split with
  /// `var_table_index`, `type` goes next to `value`. The interpretation of
  /// a type is agent specific. It is recommended to include the dynamic type
  /// rather than a static type of an object.
  public var type: String = String()

  /// Members contained or pointed to by the variable.
  public var members: [Google_Devtools_Clouddebugger_V2_Variable] = []

  /// Reference to a variable in the shared variable table. More than
  /// one variable can reference the same variable in the table. The
  /// `var_table_index` field is an index into `variable_table` in Breakpoint.
  public var varTableIndex: SwiftProtobuf.Google_Protobuf_Int32Value {
    get {return _varTableIndex ?? SwiftProtobuf.Google_Protobuf_Int32Value()}
    set {_varTableIndex = newValue}
  }
  /// Returns true if `varTableIndex` has been explicitly set.
  public var hasVarTableIndex: Bool {return self._varTableIndex != nil}
  /// Clears the value of `varTableIndex`. Subsequent reads from it will return its default value.
  public mutating func clearVarTableIndex() {self._varTableIndex = nil}

  /// Status associated with the variable. This field will usually stay
  /// unset. A status of a single variable only applies to that variable or
  /// expression. The rest of breakpoint data still remains valid. Variables
  /// might be reported in error state even when breakpoint is not in final
  /// state.
  ///
  /// The message may refer to variable name with `refers_to` set to
  /// `VARIABLE_NAME`. Alternatively `refers_to` will be set to `VARIABLE_VALUE`.
  /// In either case variable value and members will be unset.
  ///
  /// Example of error message applied to name: `Invalid expression syntax`.
  ///
  /// Example of information message applied to value: `Not captured`.
  ///
  /// Examples of error message applied to value:
  ///
  /// *   `Malformed string`,
  /// *   `Field f not found in class C`
  /// *   `Null pointer dereference`
  public var status: Google_Devtools_Clouddebugger_V2_StatusMessage {
    get {return _status ?? Google_Devtools_Clouddebugger_V2_StatusMessage()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _varTableIndex: SwiftProtobuf.Google_Protobuf_Int32Value? = nil
  fileprivate var _status: Google_Devtools_Clouddebugger_V2_StatusMessage? = nil
}

/// Represents a stack frame context.
public struct Google_Devtools_Clouddebugger_V2_StackFrame {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Demangled function name at the call site.
  public var function: String = String()

  /// Source location of the call site.
  public var location: Google_Devtools_Clouddebugger_V2_SourceLocation {
    get {return _location ?? Google_Devtools_Clouddebugger_V2_SourceLocation()}
    set {_location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return self._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {self._location = nil}

  /// Set of arguments passed to this function.
  /// Note that this might not be populated for all stack frames.
  public var arguments: [Google_Devtools_Clouddebugger_V2_Variable] = []

  /// Set of local variables at the stack frame location.
  /// Note that this might not be populated for all stack frames.
  public var locals: [Google_Devtools_Clouddebugger_V2_Variable] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _location: Google_Devtools_Clouddebugger_V2_SourceLocation? = nil
}

/// Represents the breakpoint specification, status and results.
public struct Google_Devtools_Clouddebugger_V2_Breakpoint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Breakpoint identifier, unique in the scope of the debuggee.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Action that the agent should perform when the code at the
  /// breakpoint location is hit.
  public var action: Google_Devtools_Clouddebugger_V2_Breakpoint.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  /// Breakpoint source location.
  public var location: Google_Devtools_Clouddebugger_V2_SourceLocation {
    get {return _storage._location ?? Google_Devtools_Clouddebugger_V2_SourceLocation()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  public var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  public mutating func clearLocation() {_uniqueStorage()._location = nil}

  /// Condition that triggers the breakpoint.
  /// The condition is a compound boolean expression composed using expressions
  /// in a programming language at the source location.
  public var condition: String {
    get {return _storage._condition}
    set {_uniqueStorage()._condition = newValue}
  }

  /// List of read-only expressions to evaluate at the breakpoint location.
  /// The expressions are composed using expressions in the programming language
  /// at the source location. If the breakpoint action is `LOG`, the evaluated
  /// expressions are included in log statements.
  public var expressions: [String] {
    get {return _storage._expressions}
    set {_uniqueStorage()._expressions = newValue}
  }

  /// Only relevant when action is `LOG`. Defines the message to log when
  /// the breakpoint hits. The message may include parameter placeholders `$0`,
  /// `$1`, etc. These placeholders are replaced with the evaluated value
  /// of the appropriate expression. Expressions not referenced in
  /// `log_message_format` are not logged.
  ///
  /// Example: `Message received, id = $0, count = $1` with
  /// `expressions` = `[ message.id, message.count ]`.
  public var logMessageFormat: String {
    get {return _storage._logMessageFormat}
    set {_uniqueStorage()._logMessageFormat = newValue}
  }

  /// Indicates the severity of the log. Only relevant when action is `LOG`.
  public var logLevel: Google_Devtools_Clouddebugger_V2_Breakpoint.LogLevel {
    get {return _storage._logLevel}
    set {_uniqueStorage()._logLevel = newValue}
  }

  /// When true, indicates that this is a final result and the
  /// breakpoint state will not change from here on.
  public var isFinalState: Bool {
    get {return _storage._isFinalState}
    set {_uniqueStorage()._isFinalState = newValue}
  }

  /// Time this breakpoint was created by the server in seconds resolution.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Time this breakpoint was finalized as seen by the server in seconds
  /// resolution.
  public var finalTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._finalTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._finalTime = newValue}
  }
  /// Returns true if `finalTime` has been explicitly set.
  public var hasFinalTime: Bool {return _storage._finalTime != nil}
  /// Clears the value of `finalTime`. Subsequent reads from it will return its default value.
  public mutating func clearFinalTime() {_uniqueStorage()._finalTime = nil}

  /// E-mail address of the user that created this breakpoint
  public var userEmail: String {
    get {return _storage._userEmail}
    set {_uniqueStorage()._userEmail = newValue}
  }

  /// Breakpoint status.
  ///
  /// The status includes an error flag and a human readable message.
  /// This field is usually unset. The message can be either
  /// informational or an error message. Regardless, clients should always
  /// display the text message back to the user.
  ///
  /// Error status indicates complete failure of the breakpoint.
  ///
  /// Example (non-final state): `Still loading symbols...`
  ///
  /// Examples (final state):
  ///
  /// *   `Invalid line number` referring to location
  /// *   `Field f not found in class C` referring to condition
  public var status: Google_Devtools_Clouddebugger_V2_StatusMessage {
    get {return _storage._status ?? Google_Devtools_Clouddebugger_V2_StatusMessage()}
    set {_uniqueStorage()._status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return _storage._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {_uniqueStorage()._status = nil}

  /// The stack at breakpoint time, where stack_frames[0] represents the most
  /// recently entered function.
  public var stackFrames: [Google_Devtools_Clouddebugger_V2_StackFrame] {
    get {return _storage._stackFrames}
    set {_uniqueStorage()._stackFrames = newValue}
  }

  /// Values of evaluated expressions at breakpoint time.
  /// The evaluated expressions appear in exactly the same order they
  /// are listed in the `expressions` field.
  /// The `name` field holds the original expression text, the `value` or
  /// `members` field holds the result of the evaluated expression.
  /// If the expression cannot be evaluated, the `status` inside the `Variable`
  /// will indicate an error and contain the error text.
  public var evaluatedExpressions: [Google_Devtools_Clouddebugger_V2_Variable] {
    get {return _storage._evaluatedExpressions}
    set {_uniqueStorage()._evaluatedExpressions = newValue}
  }

  /// The `variable_table` exists to aid with computation, memory and network
  /// traffic optimization.  It enables storing a variable once and reference
  /// it from multiple variables, including variables stored in the
  /// `variable_table` itself.
  /// For example, the same `this` object, which may appear at many levels of
  /// the stack, can have all of its data stored once in this table.  The
  /// stack frame variables then would hold only a reference to it.
  ///
  /// The variable `var_table_index` field is an index into this repeated field.
  /// The stored objects are nameless and get their name from the referencing
  /// variable. The effective variable is a merge of the referencing variable
  /// and the referenced variable.
  public var variableTable: [Google_Devtools_Clouddebugger_V2_Variable] {
    get {return _storage._variableTable}
    set {_uniqueStorage()._variableTable = newValue}
  }

  /// A set of custom breakpoint properties, populated by the agent, to be
  /// displayed to the user.
  public var labels: Dictionary<String,String> {
    get {return _storage._labels}
    set {_uniqueStorage()._labels = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Actions that can be taken when a breakpoint hits.
  /// Agents should reject breakpoints with unsupported or unknown action values.
  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Capture stack frame and variables and update the breakpoint.
    /// The data is only captured once. After that the breakpoint is set
    /// in a final state.
    case capture // = 0

    /// Log each breakpoint hit. The breakpoint remains active until
    /// deleted or expired.
    case log // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .capture
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .capture
      case 1: self = .log
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .capture: return 0
      case .log: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Log severity levels.
  public enum LogLevel: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Information log message.
    case info // = 0

    /// Warning log message.
    case warning // = 1

    /// Error log message.
    case error // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .info
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .info
      case 1: self = .warning
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .info: return 0
      case .warning: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Devtools_Clouddebugger_V2_Breakpoint.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Clouddebugger_V2_Breakpoint.Action] = [
    .capture,
    .log,
  ]
}

extension Google_Devtools_Clouddebugger_V2_Breakpoint.LogLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Clouddebugger_V2_Breakpoint.LogLevel] = [
    .info,
    .warning,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// Represents the debugged application. The application may include one or more
/// replicated processes executing the same code. Each of these processes is
/// attached with a debugger agent, carrying out the debugging commands.
/// Agents attached to the same debuggee identify themselves as such by using
/// exactly the same Debuggee message value when registering.
public struct Google_Devtools_Clouddebugger_V2_Debuggee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique identifier for the debuggee generated by the controller service.
  public var id: String = String()

  /// Project the debuggee is associated with.
  /// Use project number or id when registering a Google Cloud Platform project.
  public var project: String = String()

  /// Uniquifier to further distinguish the application.
  /// It is possible that different applications might have identical values in
  /// the debuggee message, thus, incorrectly identified as a single application
  /// by the Controller service. This field adds salt to further distinguish the
  /// application. Agents should consider seeding this field with value that
  /// identifies the code, binary, configuration and environment.
  public var uniquifier: String = String()

  /// Human readable description of the debuggee.
  /// Including a human-readable project name, environment name and version
  /// information is recommended.
  public var description_p: String = String()

  /// If set to `true`, indicates that Controller service does not detect any
  /// activity from the debuggee agents and the application is possibly stopped.
  public var isInactive: Bool = false

  /// Version ID of the agent.
  /// Schema: `domain/language-platform/vmajor.minor` (for example
  /// `google.com/java-gcp/v1.1`).
  public var agentVersion: String = String()

  /// If set to `true`, indicates that the agent should disable itself and
  /// detach from the debuggee.
  public var isDisabled: Bool = false

  /// Human readable message to be displayed to the user about this debuggee.
  /// Absence of this field indicates no status. The message can be either
  /// informational or an error status.
  public var status: Google_Devtools_Clouddebugger_V2_StatusMessage {
    get {return _status ?? Google_Devtools_Clouddebugger_V2_StatusMessage()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// References to the locations and revisions of the source code used in the
  /// deployed application.
  public var sourceContexts: [Google_Devtools_Source_V1_SourceContext] = []

  /// References to the locations and revisions of the source code used in the
  /// deployed application.
  public var extSourceContexts: [Google_Devtools_Source_V1_ExtendedSourceContext] = []

  /// A set of custom debuggee properties, populated by the agent, to be
  /// displayed to the user.
  public var labels: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Google_Devtools_Clouddebugger_V2_StatusMessage? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.clouddebugger.v2"

extension Google_Devtools_Clouddebugger_V2_FormatMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FormatMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "format"),
    2: .same(proto: "parameters"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.format) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.parameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.format.isEmpty {
      try visitor.visitSingularStringField(value: self.format, fieldNumber: 1)
    }
    if !self.parameters.isEmpty {
      try visitor.visitRepeatedStringField(value: self.parameters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_FormatMessage, rhs: Google_Devtools_Clouddebugger_V2_FormatMessage) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_StatusMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_error"),
    2: .standard(proto: "refers_to"),
    3: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isError) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.refersTo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isError != false {
      try visitor.visitSingularBoolField(value: self.isError, fieldNumber: 1)
    }
    if self.refersTo != .unspecified {
      try visitor.visitSingularEnumField(value: self.refersTo, fieldNumber: 2)
    }
    if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_StatusMessage, rhs: Google_Devtools_Clouddebugger_V2_StatusMessage) -> Bool {
    if lhs.isError != rhs.isError {return false}
    if lhs.refersTo != rhs.refersTo {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_StatusMessage.Reference: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    3: .same(proto: "BREAKPOINT_SOURCE_LOCATION"),
    4: .same(proto: "BREAKPOINT_CONDITION"),
    5: .same(proto: "VARIABLE_NAME"),
    6: .same(proto: "VARIABLE_VALUE"),
    7: .same(proto: "BREAKPOINT_EXPRESSION"),
    8: .same(proto: "BREAKPOINT_AGE"),
  ]
}

extension Google_Devtools_Clouddebugger_V2_SourceLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "line"),
    3: .same(proto: "column"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.line) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.column) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if self.line != 0 {
      try visitor.visitSingularInt32Field(value: self.line, fieldNumber: 2)
    }
    if self.column != 0 {
      try visitor.visitSingularInt32Field(value: self.column, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_SourceLocation, rhs: Google_Devtools_Clouddebugger_V2_SourceLocation) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.line != rhs.line {return false}
    if lhs.column != rhs.column {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_Variable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Variable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
    6: .same(proto: "type"),
    3: .same(proto: "members"),
    4: .standard(proto: "var_table_index"),
    5: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._varTableIndex) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 3)
    }
    if let v = self._varTableIndex {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_Variable, rhs: Google_Devtools_Clouddebugger_V2_Variable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.type != rhs.type {return false}
    if lhs.members != rhs.members {return false}
    if lhs._varTableIndex != rhs._varTableIndex {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_StackFrame: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StackFrame"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "function"),
    2: .same(proto: "location"),
    3: .same(proto: "arguments"),
    4: .same(proto: "locals"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.function) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._location) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.locals) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.function.isEmpty {
      try visitor.visitSingularStringField(value: self.function, fieldNumber: 1)
    }
    if let v = self._location {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 3)
    }
    if !self.locals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locals, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_StackFrame, rhs: Google_Devtools_Clouddebugger_V2_StackFrame) -> Bool {
    if lhs.function != rhs.function {return false}
    if lhs._location != rhs._location {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.locals != rhs.locals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_Breakpoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Breakpoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    13: .same(proto: "action"),
    2: .same(proto: "location"),
    3: .same(proto: "condition"),
    4: .same(proto: "expressions"),
    14: .standard(proto: "log_message_format"),
    15: .standard(proto: "log_level"),
    5: .standard(proto: "is_final_state"),
    11: .standard(proto: "create_time"),
    12: .standard(proto: "final_time"),
    16: .standard(proto: "user_email"),
    10: .same(proto: "status"),
    7: .standard(proto: "stack_frames"),
    8: .standard(proto: "evaluated_expressions"),
    9: .standard(proto: "variable_table"),
    17: .same(proto: "labels"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _action: Google_Devtools_Clouddebugger_V2_Breakpoint.Action = .capture
    var _location: Google_Devtools_Clouddebugger_V2_SourceLocation? = nil
    var _condition: String = String()
    var _expressions: [String] = []
    var _logMessageFormat: String = String()
    var _logLevel: Google_Devtools_Clouddebugger_V2_Breakpoint.LogLevel = .info
    var _isFinalState: Bool = false
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _finalTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _userEmail: String = String()
    var _status: Google_Devtools_Clouddebugger_V2_StatusMessage? = nil
    var _stackFrames: [Google_Devtools_Clouddebugger_V2_StackFrame] = []
    var _evaluatedExpressions: [Google_Devtools_Clouddebugger_V2_Variable] = []
    var _variableTable: [Google_Devtools_Clouddebugger_V2_Variable] = []
    var _labels: Dictionary<String,String> = [:]

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _action = source._action
      _location = source._location
      _condition = source._condition
      _expressions = source._expressions
      _logMessageFormat = source._logMessageFormat
      _logLevel = source._logLevel
      _isFinalState = source._isFinalState
      _createTime = source._createTime
      _finalTime = source._finalTime
      _userEmail = source._userEmail
      _status = source._status
      _stackFrames = source._stackFrames
      _evaluatedExpressions = source._evaluatedExpressions
      _variableTable = source._variableTable
      _labels = source._labels
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._condition) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._expressions) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isFinalState) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._stackFrames) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._evaluatedExpressions) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._variableTable) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._status) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._finalTime) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._logMessageFormat) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._logLevel) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._userEmail) }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._labels) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._condition.isEmpty {
        try visitor.visitSingularStringField(value: _storage._condition, fieldNumber: 3)
      }
      if !_storage._expressions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._expressions, fieldNumber: 4)
      }
      if _storage._isFinalState != false {
        try visitor.visitSingularBoolField(value: _storage._isFinalState, fieldNumber: 5)
      }
      if !_storage._stackFrames.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stackFrames, fieldNumber: 7)
      }
      if !_storage._evaluatedExpressions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._evaluatedExpressions, fieldNumber: 8)
      }
      if !_storage._variableTable.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._variableTable, fieldNumber: 9)
      }
      if let v = _storage._status {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._finalTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._action != .capture {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 13)
      }
      if !_storage._logMessageFormat.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logMessageFormat, fieldNumber: 14)
      }
      if _storage._logLevel != .info {
        try visitor.visitSingularEnumField(value: _storage._logLevel, fieldNumber: 15)
      }
      if !_storage._userEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userEmail, fieldNumber: 16)
      }
      if !_storage._labels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._labels, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_Breakpoint, rhs: Google_Devtools_Clouddebugger_V2_Breakpoint) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._condition != rhs_storage._condition {return false}
        if _storage._expressions != rhs_storage._expressions {return false}
        if _storage._logMessageFormat != rhs_storage._logMessageFormat {return false}
        if _storage._logLevel != rhs_storage._logLevel {return false}
        if _storage._isFinalState != rhs_storage._isFinalState {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._finalTime != rhs_storage._finalTime {return false}
        if _storage._userEmail != rhs_storage._userEmail {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._stackFrames != rhs_storage._stackFrames {return false}
        if _storage._evaluatedExpressions != rhs_storage._evaluatedExpressions {return false}
        if _storage._variableTable != rhs_storage._variableTable {return false}
        if _storage._labels != rhs_storage._labels {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_Breakpoint.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CAPTURE"),
    1: .same(proto: "LOG"),
  ]
}

extension Google_Devtools_Clouddebugger_V2_Breakpoint.LogLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INFO"),
    1: .same(proto: "WARNING"),
    2: .same(proto: "ERROR"),
  ]
}

extension Google_Devtools_Clouddebugger_V2_Debuggee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Debuggee"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "project"),
    3: .same(proto: "uniquifier"),
    4: .same(proto: "description"),
    5: .standard(proto: "is_inactive"),
    6: .standard(proto: "agent_version"),
    7: .standard(proto: "is_disabled"),
    8: .same(proto: "status"),
    9: .standard(proto: "source_contexts"),
    13: .standard(proto: "ext_source_contexts"),
    11: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.project) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uniquifier) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isInactive) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.agentVersion) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.isDisabled) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.sourceContexts) }()
      case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.extSourceContexts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.project.isEmpty {
      try visitor.visitSingularStringField(value: self.project, fieldNumber: 2)
    }
    if !self.uniquifier.isEmpty {
      try visitor.visitSingularStringField(value: self.uniquifier, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if self.isInactive != false {
      try visitor.visitSingularBoolField(value: self.isInactive, fieldNumber: 5)
    }
    if !self.agentVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.agentVersion, fieldNumber: 6)
    }
    if self.isDisabled != false {
      try visitor.visitSingularBoolField(value: self.isDisabled, fieldNumber: 7)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if !self.sourceContexts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sourceContexts, fieldNumber: 9)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 11)
    }
    if !self.extSourceContexts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extSourceContexts, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_Debuggee, rhs: Google_Devtools_Clouddebugger_V2_Debuggee) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.project != rhs.project {return false}
    if lhs.uniquifier != rhs.uniquifier {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.isInactive != rhs.isInactive {return false}
    if lhs.agentVersion != rhs.agentVersion {return false}
    if lhs.isDisabled != rhs.isDisabled {return false}
    if lhs._status != rhs._status {return false}
    if lhs.sourceContexts != rhs.sourceContexts {return false}
    if lhs.extSourceContexts != rhs.extSourceContexts {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/clouddebugger/v2/controller.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Request to register a debuggee.
public struct Google_Devtools_Clouddebugger_V2_RegisterDebuggeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Debuggee information to register.
  /// The fields `project`, `uniquifier`, `description` and `agent_version`
  /// of the debuggee must be set.
  public var debuggee: Google_Devtools_Clouddebugger_V2_Debuggee {
    get {return _debuggee ?? Google_Devtools_Clouddebugger_V2_Debuggee()}
    set {_debuggee = newValue}
  }
  /// Returns true if `debuggee` has been explicitly set.
  public var hasDebuggee: Bool {return self._debuggee != nil}
  /// Clears the value of `debuggee`. Subsequent reads from it will return its default value.
  public mutating func clearDebuggee() {self._debuggee = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _debuggee: Google_Devtools_Clouddebugger_V2_Debuggee? = nil
}

/// Response for registering a debuggee.
public struct Google_Devtools_Clouddebugger_V2_RegisterDebuggeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Debuggee resource.
  /// The field `id` is guaranteed to be set (in addition to the echoed fields).
  /// If the field `is_disabled` is set to `true`, the agent should disable
  /// itself by removing all breakpoints and detaching from the application.
  /// It should however continue to poll `RegisterDebuggee` until reenabled.
  public var debuggee: Google_Devtools_Clouddebugger_V2_Debuggee {
    get {return _debuggee ?? Google_Devtools_Clouddebugger_V2_Debuggee()}
    set {_debuggee = newValue}
  }
  /// Returns true if `debuggee` has been explicitly set.
  public var hasDebuggee: Bool {return self._debuggee != nil}
  /// Clears the value of `debuggee`. Subsequent reads from it will return its default value.
  public mutating func clearDebuggee() {self._debuggee = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _debuggee: Google_Devtools_Clouddebugger_V2_Debuggee? = nil
}

/// Request to list active breakpoints.
public struct Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Identifies the debuggee.
  public var debuggeeID: String = String()

  /// A token that, if specified, blocks the method call until the list
  /// of active breakpoints has changed, or a server-selected timeout has
  /// expired. The value should be set from the `next_wait_token` field in
  /// the last response. The initial value should be set to `"init"`.
  public var waitToken: String = String()

  /// If set to `true` (recommended), returns `google.rpc.Code.OK` status and
  /// sets the `wait_expired` response field to `true` when the server-selected
  /// timeout has expired.
  ///
  /// If set to `false` (deprecated), returns `google.rpc.Code.ABORTED` status
  /// when the server-selected timeout has expired.
  public var successOnTimeout: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for listing active breakpoints.
public struct Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of all active breakpoints.
  /// The fields `id` and `location` are guaranteed to be set on each breakpoint.
  public var breakpoints: [Google_Devtools_Clouddebugger_V2_Breakpoint] = []

  /// A token that can be used in the next method call to block until
  /// the list of breakpoints changes.
  public var nextWaitToken: String = String()

  /// If set to `true`, indicates that there is no change to the
  /// list of active breakpoints and the server-selected timeout has expired.
  /// The `breakpoints` field would be empty and should be ignored.
  public var waitExpired: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to update an active breakpoint.
public struct Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Identifies the debuggee being debugged.
  public var debuggeeID: String = String()

  /// Required. Updated breakpoint information.
  /// The field `id` must be set.
  /// The agent must echo all Breakpoint specification fields in the update.
  public var breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint {
    get {return _breakpoint ?? Google_Devtools_Clouddebugger_V2_Breakpoint()}
    set {_breakpoint = newValue}
  }
  /// Returns true if `breakpoint` has been explicitly set.
  public var hasBreakpoint: Bool {return self._breakpoint != nil}
  /// Clears the value of `breakpoint`. Subsequent reads from it will return its default value.
  public mutating func clearBreakpoint() {self._breakpoint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _breakpoint: Google_Devtools_Clouddebugger_V2_Breakpoint? = nil
}

/// Response for updating an active breakpoint.
/// The message is defined to allow future extensions.
public struct Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.clouddebugger.v2"

extension Google_Devtools_Clouddebugger_V2_RegisterDebuggeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterDebuggeeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debuggee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._debuggee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._debuggee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_RegisterDebuggeeRequest, rhs: Google_Devtools_Clouddebugger_V2_RegisterDebuggeeRequest) -> Bool {
    if lhs._debuggee != rhs._debuggee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_RegisterDebuggeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterDebuggeeResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "debuggee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._debuggee) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._debuggee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_RegisterDebuggeeResponse, rhs: Google_Devtools_Clouddebugger_V2_RegisterDebuggeeResponse) -> Bool {
    if lhs._debuggee != rhs._debuggee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActiveBreakpointsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debuggee_id"),
    2: .standard(proto: "wait_token"),
    3: .standard(proto: "success_on_timeout"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggeeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.waitToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.successOnTimeout) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggeeID, fieldNumber: 1)
    }
    if !self.waitToken.isEmpty {
      try visitor.visitSingularStringField(value: self.waitToken, fieldNumber: 2)
    }
    if self.successOnTimeout != false {
      try visitor.visitSingularBoolField(value: self.successOnTimeout, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsRequest, rhs: Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsRequest) -> Bool {
    if lhs.debuggeeID != rhs.debuggeeID {return false}
    if lhs.waitToken != rhs.waitToken {return false}
    if lhs.successOnTimeout != rhs.successOnTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActiveBreakpointsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "breakpoints"),
    2: .standard(proto: "next_wait_token"),
    3: .standard(proto: "wait_expired"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.breakpoints) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextWaitToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.waitExpired) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.breakpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.breakpoints, fieldNumber: 1)
    }
    if !self.nextWaitToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextWaitToken, fieldNumber: 2)
    }
    if self.waitExpired != false {
      try visitor.visitSingularBoolField(value: self.waitExpired, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsResponse, rhs: Google_Devtools_Clouddebugger_V2_ListActiveBreakpointsResponse) -> Bool {
    if lhs.breakpoints != rhs.breakpoints {return false}
    if lhs.nextWaitToken != rhs.nextWaitToken {return false}
    if lhs.waitExpired != rhs.waitExpired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateActiveBreakpointRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "debuggee_id"),
    2: .same(proto: "breakpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.debuggeeID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._breakpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.debuggeeID.isEmpty {
      try visitor.visitSingularStringField(value: self.debuggeeID, fieldNumber: 1)
    }
    if let v = self._breakpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointRequest, rhs: Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointRequest) -> Bool {
    if lhs.debuggeeID != rhs.debuggeeID {return false}
    if lhs._breakpoint != rhs._breakpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateActiveBreakpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointResponse, rhs: Google_Devtools_Clouddebugger_V2_UpdateActiveBreakpointResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/remoteworkers/v1test2/command.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes a shell-style task to execute, suitable for providing as the Bots
/// interface's `Lease.payload` field.
public struct Google_Devtools_Remoteworkers_V1test2_CommandTask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The inputs to the task.
  public var inputs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs {
    get {return _inputs ?? Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs()}
    set {_inputs = newValue}
  }
  /// Returns true if `inputs` has been explicitly set.
  public var hasInputs: Bool {return self._inputs != nil}
  /// Clears the value of `inputs`. Subsequent reads from it will return its default value.
  public mutating func clearInputs() {self._inputs = nil}

  /// The expected outputs from the task.
  public var expectedOutputs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Outputs {
    get {return _expectedOutputs ?? Google_Devtools_Remoteworkers_V1test2_CommandTask.Outputs()}
    set {_expectedOutputs = newValue}
  }
  /// Returns true if `expectedOutputs` has been explicitly set.
  public var hasExpectedOutputs: Bool {return self._expectedOutputs != nil}
  /// Clears the value of `expectedOutputs`. Subsequent reads from it will return its default value.
  public mutating func clearExpectedOutputs() {self._expectedOutputs = nil}

  /// The timeouts of this task.
  public var timeouts: Google_Devtools_Remoteworkers_V1test2_CommandTask.Timeouts {
    get {return _timeouts ?? Google_Devtools_Remoteworkers_V1test2_CommandTask.Timeouts()}
    set {_timeouts = newValue}
  }
  /// Returns true if `timeouts` has been explicitly set.
  public var hasTimeouts: Bool {return self._timeouts != nil}
  /// Clears the value of `timeouts`. Subsequent reads from it will return its default value.
  public mutating func clearTimeouts() {self._timeouts = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Describes the inputs to a shell-style task.
  public struct Inputs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The command itself to run (e.g., argv).
    ///
    /// This field should be passed directly to the underlying operating system,
    /// and so it must be sensible to that operating system. For example, on
    /// Windows, the first argument might be "C:\Windows\System32\ping.exe" -
    /// that is, using drive letters and backslashes. A command for a *nix
    /// system, on the other hand, would use forward slashes.
    ///
    /// All other fields in the RWAPI must consistently use forward slashes,
    /// since those fields may be interpretted by both the service and the bot.
    public var arguments: [String] = []

    /// The input filesystem to be set up prior to the task beginning. The
    /// contents should be a repeated set of FileMetadata messages though other
    /// formats are allowed if better for the implementation (eg, a LUCI-style
    /// .isolated file).
    ///
    /// This field is repeated since implementations might want to cache the
    /// metadata, in which case it may be useful to break up portions of the
    /// filesystem that change frequently (eg, specific input files) from those
    /// that don't (eg, standard header files).
    public var files: [Google_Devtools_Remoteworkers_V1test2_Digest] = []

    /// Inline contents for blobs expected to be needed by the bot to execute the
    /// task. For example, contents of entries in `files` or blobs that are
    /// indirectly referenced by an entry there.
    ///
    /// The bot should check against this list before downloading required task
    /// inputs to reduce the number of communications between itself and the
    /// remote CAS server.
    public var inlineBlobs: [Google_Devtools_Remoteworkers_V1test2_Blob] = []

    /// All environment variables required by the task.
    public var environmentVariables: [Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs.EnvironmentVariable] = []

    /// Directory from which a command is executed. It is a relative directory
    /// with respect to the bot's working directory (i.e., "./"). If it is
    /// non-empty, then it must exist under "./". Otherwise, "./" will be used.
    public var workingDirectory: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An environment variable required by this task.
    public struct EnvironmentVariable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The envvar name.
      public var name: String = String()

      /// The envvar value.
      public var value: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  /// Describes the expected outputs of the command.
  public struct Outputs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A list of expected files, relative to the execution root. All paths
    /// MUST be delimited by forward slashes.
    public var files: [String] = []

    /// A list of expected directories, relative to the execution root. All paths
    /// MUST be delimited by forward slashes.
    public var directories: [String] = []

    /// The destination to which any stdout should be sent. The method by which
    /// the bot should send the stream contents to that destination is not
    /// defined in this API. As examples, the destination could be a file
    /// referenced in the `files` field in this message, or it could be a URI
    /// that must be written via the ByteStream API.
    public var stdoutDestination: String = String()

    /// The destination to which any stderr should be sent. The method by which
    /// the bot should send the stream contents to that destination is not
    /// defined in this API. As examples, the destination could be a file
    /// referenced in the `files` field in this message, or it could be a URI
    /// that must be written via the ByteStream API.
    public var stderrDestination: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Describes the timeouts associated with this task.
  public struct Timeouts {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This specifies the maximum time that the task can run, excluding the
    /// time required to download inputs or upload outputs. That is, the worker
    /// will terminate the task if it runs longer than this.
    public var execution: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _execution ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {return self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    /// This specifies the maximum amount of time the task can be idle - that is,
    /// go without generating some output in either stdout or stderr. If the
    /// process is silent for more than the specified time, the worker will
    /// terminate the task.
    public var idle: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _idle ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_idle = newValue}
    }
    /// Returns true if `idle` has been explicitly set.
    public var hasIdle: Bool {return self._idle != nil}
    /// Clears the value of `idle`. Subsequent reads from it will return its default value.
    public mutating func clearIdle() {self._idle = nil}

    /// If the execution or IO timeouts are exceeded, the worker will try to
    /// gracefully terminate the task and return any existing logs. However,
    /// tasks may be hard-frozen in which case this process will fail. This
    /// timeout specifies how long to wait for a terminated task to shut down
    /// gracefully (e.g. via SIGTERM) before we bring down the hammer (e.g.
    /// SIGKILL on *nix, CTRL_BREAK_EVENT on Windows).
    public var shutdown: SwiftProtobuf.Google_Protobuf_Duration {
      get {return _shutdown ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_shutdown = newValue}
    }
    /// Returns true if `shutdown` has been explicitly set.
    public var hasShutdown: Bool {return self._shutdown != nil}
    /// Clears the value of `shutdown`. Subsequent reads from it will return its default value.
    public mutating func clearShutdown() {self._shutdown = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _execution: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _idle: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _shutdown: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }

  public init() {}

  fileprivate var _inputs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs? = nil
  fileprivate var _expectedOutputs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Outputs? = nil
  fileprivate var _timeouts: Google_Devtools_Remoteworkers_V1test2_CommandTask.Timeouts? = nil
}

/// DEPRECATED - use CommandResult instead.
/// Describes the actual outputs from the task.
public struct Google_Devtools_Remoteworkers_V1test2_CommandOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// exit_code is only fully reliable if the status' code is OK. If the task
  /// exceeded its deadline or was cancelled, the process may still produce an
  /// exit code as it is cancelled, and this will be populated, but a successful
  /// (zero) is unlikely to be correct unless the status code is OK.
  public var exitCode: Int32 = 0

  /// The output files. The blob referenced by the digest should contain
  /// one of the following (implementation-dependent):
  ///    * A marshalled DirectoryMetadata of the returned filesystem
  ///    * A LUCI-style .isolated file
  public var outputs: Google_Devtools_Remoteworkers_V1test2_Digest {
    get {return _outputs ?? Google_Devtools_Remoteworkers_V1test2_Digest()}
    set {_outputs = newValue}
  }
  /// Returns true if `outputs` has been explicitly set.
  public var hasOutputs: Bool {return self._outputs != nil}
  /// Clears the value of `outputs`. Subsequent reads from it will return its default value.
  public mutating func clearOutputs() {self._outputs = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _outputs: Google_Devtools_Remoteworkers_V1test2_Digest? = nil
}

/// DEPRECATED - use CommandResult instead.
/// Can be used as part of CompleteRequest.metadata, or are part of a more
/// sophisticated message.
public struct Google_Devtools_Remoteworkers_V1test2_CommandOverhead {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The elapsed time between calling Accept and Complete. The server will also
  /// have its own idea of what this should be, but this excludes the overhead of
  /// the RPCs and the bot response time.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// The amount of time *not* spent executing the command (ie
  /// uploading/downloading files).
  public var overhead: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _overhead ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_overhead = newValue}
  }
  /// Returns true if `overhead` has been explicitly set.
  public var hasOverhead: Bool {return self._overhead != nil}
  /// Clears the value of `overhead`. Subsequent reads from it will return its default value.
  public mutating func clearOverhead() {self._overhead = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _overhead: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// All information about the execution of a command, suitable for providing as
/// the Bots interface's `Lease.result` field.
public struct Google_Devtools_Remoteworkers_V1test2_CommandResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An overall status for the command. For example, if the command timed out,
  /// this might have a code of DEADLINE_EXCEEDED; if it was killed by the OS for
  /// memory exhaustion, it might have a code of RESOURCE_EXHAUSTED.
  public var status: Google_Rpc_Status {
    get {return _status ?? Google_Rpc_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  /// The exit code of the process. An exit code of "0" should only be trusted if
  /// `status` has a code of OK (otherwise it may simply be unset).
  public var exitCode: Int32 = 0

  /// The output files. The blob referenced by the digest should contain
  /// one of the following (implementation-dependent):
  ///    * A marshalled DirectoryMetadata of the returned filesystem
  ///    * A LUCI-style .isolated file
  public var outputs: Google_Devtools_Remoteworkers_V1test2_Digest {
    get {return _outputs ?? Google_Devtools_Remoteworkers_V1test2_Digest()}
    set {_outputs = newValue}
  }
  /// Returns true if `outputs` has been explicitly set.
  public var hasOutputs: Bool {return self._outputs != nil}
  /// Clears the value of `outputs`. Subsequent reads from it will return its default value.
  public mutating func clearOutputs() {self._outputs = nil}

  /// The elapsed time between calling Accept and Complete. The server will also
  /// have its own idea of what this should be, but this excludes the overhead of
  /// the RPCs and the bot response time.
  public var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  public var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  public mutating func clearDuration() {self._duration = nil}

  /// The amount of time *not* spent executing the command (ie
  /// uploading/downloading files).
  public var overhead: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _overhead ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_overhead = newValue}
  }
  /// Returns true if `overhead` has been explicitly set.
  public var hasOverhead: Bool {return self._overhead != nil}
  /// Clears the value of `overhead`. Subsequent reads from it will return its default value.
  public mutating func clearOverhead() {self._overhead = nil}

  /// Implementation-dependent metadata about the task. Both servers and bots
  /// may define messages which can be encoded here; bots are free to provide
  /// metadata in multiple formats, and servers are free to choose one or more
  /// of the values to process and ignore others. In particular, it is *not*
  /// considered an error for the bot to provide the server with a field that it
  /// doesn't know about.
  public var metadata: [SwiftProtobuf.Google_Protobuf_Any] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Google_Rpc_Status? = nil
  fileprivate var _outputs: Google_Devtools_Remoteworkers_V1test2_Digest? = nil
  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _overhead: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// The metadata for a file. Similar to the equivalent message in the Remote
/// Execution API.
public struct Google_Devtools_Remoteworkers_V1test2_FileMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path of this file. If this message is part of the
  /// CommandOutputs.outputs fields, the path is relative to the execution root
  /// and must correspond to an entry in CommandTask.outputs.files. If this
  /// message is part of a Directory message, then the path is relative to the
  /// root of that directory. All paths MUST be delimited by forward slashes.
  public var path: String = String()

  /// A pointer to the contents of the file. The method by which a client
  /// retrieves the contents from a CAS system is not defined here.
  public var digest: Google_Devtools_Remoteworkers_V1test2_Digest {
    get {return _digest ?? Google_Devtools_Remoteworkers_V1test2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  /// If the file is small enough, its contents may also or alternatively be
  /// listed here.
  public var contents: Data = Data()

  /// Properties of the file
  public var isExecutable: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Google_Devtools_Remoteworkers_V1test2_Digest? = nil
}

/// The metadata for a directory. Similar to the equivalent message in the Remote
/// Execution API.
public struct Google_Devtools_Remoteworkers_V1test2_DirectoryMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path of the directory, as in [FileMetadata.path][google.devtools.remoteworkers.v1test2.FileMetadata.path].
  public var path: String = String()

  /// A pointer to the contents of the directory, in the form of a marshalled
  /// Directory message.
  public var digest: Google_Devtools_Remoteworkers_V1test2_Digest {
    get {return _digest ?? Google_Devtools_Remoteworkers_V1test2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Google_Devtools_Remoteworkers_V1test2_Digest? = nil
}

/// The CommandTask and CommandResult messages assume the existence of a service
/// that can serve blobs of content, identified by a hash and size known as a
/// "digest." The method by which these blobs may be retrieved is not specified
/// here, but a model implementation is in the Remote Execution API's
/// "ContentAddressibleStorage" interface.
///
/// In the context of the RWAPI, a Digest will virtually always refer to the
/// contents of a file or a directory. The latter is represented by the
/// byte-encoded Directory message.
public struct Google_Devtools_Remoteworkers_V1test2_Digest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A string-encoded hash (eg "1a2b3c", not the byte array [0x1a, 0x2b, 0x3c])
  /// using an implementation-defined hash algorithm (eg SHA-256).
  public var hash: String = String()

  /// The size of the contents. While this is not strictly required as part of an
  /// identifier (after all, any given hash will have exactly one canonical
  /// size), it's useful in almost all cases when one might want to send or
  /// retrieve blobs of content and is included here for this reason.
  public var sizeBytes: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Describes a blob of binary content with its digest.
public struct Google_Devtools_Remoteworkers_V1test2_Blob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The digest of the blob. This should be verified by the receiver.
  public var digest: Google_Devtools_Remoteworkers_V1test2_Digest {
    get {return _digest ?? Google_Devtools_Remoteworkers_V1test2_Digest()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  public var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  public mutating func clearDigest() {self._digest = nil}

  /// The contents of the blob.
  public var contents: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _digest: Google_Devtools_Remoteworkers_V1test2_Digest? = nil
}

/// The contents of a directory. Similar to the equivalent message in the Remote
/// Execution API.
public struct Google_Devtools_Remoteworkers_V1test2_Directory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The files in this directory
  public var files: [Google_Devtools_Remoteworkers_V1test2_FileMetadata] = []

  /// Any subdirectories
  public var directories: [Google_Devtools_Remoteworkers_V1test2_DirectoryMetadata] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.remoteworkers.v1test2"

extension Google_Devtools_Remoteworkers_V1test2_CommandTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandTask"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    4: .standard(proto: "expected_outputs"),
    5: .same(proto: "timeouts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._inputs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._expectedOutputs) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timeouts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._inputs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._expectedOutputs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._timeouts {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandTask, rhs: Google_Devtools_Remoteworkers_V1test2_CommandTask) -> Bool {
    if lhs._inputs != rhs._inputs {return false}
    if lhs._expectedOutputs != rhs._expectedOutputs {return false}
    if lhs._timeouts != rhs._timeouts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Remoteworkers_V1test2_CommandTask.protoMessageName + ".Inputs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "arguments"),
    2: .same(proto: "files"),
    4: .standard(proto: "inline_blobs"),
    3: .standard(proto: "environment_variables"),
    5: .standard(proto: "working_directory"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.arguments) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.environmentVariables) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.inlineBlobs) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.workingDirectory) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedStringField(value: self.arguments, fieldNumber: 1)
    }
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 2)
    }
    if !self.environmentVariables.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.environmentVariables, fieldNumber: 3)
    }
    if !self.inlineBlobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inlineBlobs, fieldNumber: 4)
    }
    if !self.workingDirectory.isEmpty {
      try visitor.visitSingularStringField(value: self.workingDirectory, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs, rhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs) -> Bool {
    if lhs.arguments != rhs.arguments {return false}
    if lhs.files != rhs.files {return false}
    if lhs.inlineBlobs != rhs.inlineBlobs {return false}
    if lhs.environmentVariables != rhs.environmentVariables {return false}
    if lhs.workingDirectory != rhs.workingDirectory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs.EnvironmentVariable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs.protoMessageName + ".EnvironmentVariable"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs.EnvironmentVariable, rhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Inputs.EnvironmentVariable) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandTask.Outputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Remoteworkers_V1test2_CommandTask.protoMessageName + ".Outputs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "directories"),
    3: .standard(proto: "stdout_destination"),
    4: .standard(proto: "stderr_destination"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.directories) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stdoutDestination) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.stderrDestination) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedStringField(value: self.files, fieldNumber: 1)
    }
    if !self.directories.isEmpty {
      try visitor.visitRepeatedStringField(value: self.directories, fieldNumber: 2)
    }
    if !self.stdoutDestination.isEmpty {
      try visitor.visitSingularStringField(value: self.stdoutDestination, fieldNumber: 3)
    }
    if !self.stderrDestination.isEmpty {
      try visitor.visitSingularStringField(value: self.stderrDestination, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Outputs, rhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Outputs) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.directories != rhs.directories {return false}
    if lhs.stdoutDestination != rhs.stdoutDestination {return false}
    if lhs.stderrDestination != rhs.stderrDestination {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandTask.Timeouts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Remoteworkers_V1test2_CommandTask.protoMessageName + ".Timeouts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "execution"),
    2: .same(proto: "idle"),
    3: .same(proto: "shutdown"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._idle) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._shutdown) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._idle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._shutdown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Timeouts, rhs: Google_Devtools_Remoteworkers_V1test2_CommandTask.Timeouts) -> Bool {
    if lhs._execution != rhs._execution {return false}
    if lhs._idle != rhs._idle {return false}
    if lhs._shutdown != rhs._shutdown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandOutputs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exit_code"),
    2: .same(proto: "outputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outputs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 1)
    }
    if let v = self._outputs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandOutputs, rhs: Google_Devtools_Remoteworkers_V1test2_CommandOutputs) -> Bool {
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs._outputs != rhs._outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandOverhead: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandOverhead"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "duration"),
    2: .same(proto: "overhead"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._overhead) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._overhead {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandOverhead, rhs: Google_Devtools_Remoteworkers_V1test2_CommandOverhead) -> Bool {
    if lhs._duration != rhs._duration {return false}
    if lhs._overhead != rhs._overhead {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_CommandResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommandResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "outputs"),
    4: .same(proto: "duration"),
    5: .same(proto: "overhead"),
    6: .same(proto: "metadata"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.exitCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._outputs) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._overhead) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 2)
    }
    if let v = self._outputs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._overhead {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.metadata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.metadata, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_CommandResult, rhs: Google_Devtools_Remoteworkers_V1test2_CommandResult) -> Bool {
    if lhs._status != rhs._status {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs._outputs != rhs._outputs {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._overhead != rhs._overhead {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_FileMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "digest"),
    3: .same(proto: "contents"),
    4: .standard(proto: "is_executable"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.contents) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isExecutable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.contents.isEmpty {
      try visitor.visitSingularBytesField(value: self.contents, fieldNumber: 3)
    }
    if self.isExecutable != false {
      try visitor.visitSingularBoolField(value: self.isExecutable, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_FileMetadata, rhs: Google_Devtools_Remoteworkers_V1test2_FileMetadata) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.isExecutable != rhs.isExecutable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_DirectoryMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DirectoryMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "digest"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_DirectoryMetadata, rhs: Google_Devtools_Remoteworkers_V1test2_DirectoryMetadata) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_Digest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Digest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "size_bytes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularStringField(value: self.hash, fieldNumber: 1)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_Digest, rhs: Google_Devtools_Remoteworkers_V1test2_Digest) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_Blob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Blob"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "digest"),
    2: .same(proto: "contents"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._digest) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.contents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._digest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.contents.isEmpty {
      try visitor.visitSingularBytesField(value: self.contents, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_Blob, rhs: Google_Devtools_Remoteworkers_V1test2_Blob) -> Bool {
    if lhs._digest != rhs._digest {return false}
    if lhs.contents != rhs.contents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Remoteworkers_V1test2_Directory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Directory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "files"),
    2: .same(proto: "directories"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.files) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.directories) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.files.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.files, fieldNumber: 1)
    }
    if !self.directories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.directories, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Remoteworkers_V1test2_Directory, rhs: Google_Devtools_Remoteworkers_V1test2_Directory) -> Bool {
    if lhs.files != rhs.files {return false}
    if lhs.directories != rhs.directories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

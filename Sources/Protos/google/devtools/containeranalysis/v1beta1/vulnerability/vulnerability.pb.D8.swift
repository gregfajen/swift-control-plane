// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/containeranalysis/v1beta1/vulnerability/vulnerability.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Note provider-assigned severity/impact ranking.
public enum Grafeas_V1beta1_Vulnerability_Severity: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// Unknown.
  case unspecified // = 0

  /// Minimal severity.
  case minimal // = 1

  /// Low severity.
  case low // = 2

  /// Medium severity.
  case medium // = 3

  /// High severity.
  case high // = 4

  /// Critical severity.
  case critical // = 5
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .minimal
    case 2: self = .low
    case 3: self = .medium
    case 4: self = .high
    case 5: self = .critical
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .minimal: return 1
    case .low: return 2
    case .medium: return 3
    case .high: return 4
    case .critical: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Grafeas_V1beta1_Vulnerability_Severity: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Grafeas_V1beta1_Vulnerability_Severity] = [
    .unspecified,
    .minimal,
    .low,
    .medium,
    .high,
    .critical,
  ]
}

#endif  // swift(>=4.2)

/// Vulnerability provides metadata about a security vulnerability in a Note.
public struct Grafeas_V1beta1_Vulnerability_Vulnerability {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The CVSS score for this vulnerability.
  public var cvssScore: Float {
    get {return _storage._cvssScore}
    set {_uniqueStorage()._cvssScore = newValue}
  }

  /// Note provider assigned impact of the vulnerability.
  public var severity: Grafeas_V1beta1_Vulnerability_Severity {
    get {return _storage._severity}
    set {_uniqueStorage()._severity = newValue}
  }

  /// All information about the package to specifically identify this
  /// vulnerability. One entry per (version range and cpe_uri) the package
  /// vulnerability has manifested in.
  public var details: [Grafeas_V1beta1_Vulnerability_Vulnerability.Detail] {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// The full description of the CVSSv3.
  public var cvssV3: Grafeas_V1beta1_Vulnerability_CVSSv3 {
    get {return _storage._cvssV3 ?? Grafeas_V1beta1_Vulnerability_CVSSv3()}
    set {_uniqueStorage()._cvssV3 = newValue}
  }
  /// Returns true if `cvssV3` has been explicitly set.
  public var hasCvssV3: Bool {return _storage._cvssV3 != nil}
  /// Clears the value of `cvssV3`. Subsequent reads from it will return its default value.
  public mutating func clearCvssV3() {_uniqueStorage()._cvssV3 = nil}

  /// Windows details get their own format because the information format and
  /// model don't match a normal detail. Specifically Windows updates are done as
  /// patches, thus Windows vulnerabilities really are a missing package, rather
  /// than a package being at an incorrect version.
  public var windowsDetails: [Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail] {
    get {return _storage._windowsDetails}
    set {_uniqueStorage()._windowsDetails = newValue}
  }

  /// The time this information was last changed at the source. This is an
  /// upstream timestamp from the underlying information source - e.g. Ubuntu
  /// security tracker.
  public var sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._sourceUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._sourceUpdateTime = newValue}
  }
  /// Returns true if `sourceUpdateTime` has been explicitly set.
  public var hasSourceUpdateTime: Bool {return _storage._sourceUpdateTime != nil}
  /// Clears the value of `sourceUpdateTime`. Subsequent reads from it will return its default value.
  public mutating func clearSourceUpdateTime() {_uniqueStorage()._sourceUpdateTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Identifies all appearances of this vulnerability in the package for a
  /// specific distro/location. For example: glibc in
  /// cpe:/o:debian:debian_linux:8 for versions 2.1 - 2.2
  public struct Detail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The CPE URI in
    /// [cpe format](https://cpe.mitre.org/specification/) in which the
    /// vulnerability manifests. Examples include distro or storage location for
    /// vulnerable jar.
    public var cpeUri: String {
      get {return _storage._cpeUri}
      set {_uniqueStorage()._cpeUri = newValue}
    }

    /// Required. The name of the package where the vulnerability was found.
    public var package: String {
      get {return _storage._package}
      set {_uniqueStorage()._package = newValue}
    }

    /// The min version of the package in which the vulnerability exists.
    public var minAffectedVersion: Grafeas_V1beta1_Package_Version {
      get {return _storage._minAffectedVersion ?? Grafeas_V1beta1_Package_Version()}
      set {_uniqueStorage()._minAffectedVersion = newValue}
    }
    /// Returns true if `minAffectedVersion` has been explicitly set.
    public var hasMinAffectedVersion: Bool {return _storage._minAffectedVersion != nil}
    /// Clears the value of `minAffectedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearMinAffectedVersion() {_uniqueStorage()._minAffectedVersion = nil}

    /// The max version of the package in which the vulnerability exists.
    public var maxAffectedVersion: Grafeas_V1beta1_Package_Version {
      get {return _storage._maxAffectedVersion ?? Grafeas_V1beta1_Package_Version()}
      set {_uniqueStorage()._maxAffectedVersion = newValue}
    }
    /// Returns true if `maxAffectedVersion` has been explicitly set.
    public var hasMaxAffectedVersion: Bool {return _storage._maxAffectedVersion != nil}
    /// Clears the value of `maxAffectedVersion`. Subsequent reads from it will return its default value.
    public mutating func clearMaxAffectedVersion() {_uniqueStorage()._maxAffectedVersion = nil}

    /// The severity (eg: distro assigned severity) for this vulnerability.
    public var severityName: String {
      get {return _storage._severityName}
      set {_uniqueStorage()._severityName = newValue}
    }

    /// A vendor-specific description of this note.
    public var description_p: String {
      get {return _storage._description_p}
      set {_uniqueStorage()._description_p = newValue}
    }

    /// The fix for this specific package version.
    public var fixedLocation: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation {
      get {return _storage._fixedLocation ?? Grafeas_V1beta1_Vulnerability_VulnerabilityLocation()}
      set {_uniqueStorage()._fixedLocation = newValue}
    }
    /// Returns true if `fixedLocation` has been explicitly set.
    public var hasFixedLocation: Bool {return _storage._fixedLocation != nil}
    /// Clears the value of `fixedLocation`. Subsequent reads from it will return its default value.
    public mutating func clearFixedLocation() {_uniqueStorage()._fixedLocation = nil}

    /// The type of package; whether native or non native(ruby gems, node.js
    /// packages etc).
    public var packageType: String {
      get {return _storage._packageType}
      set {_uniqueStorage()._packageType = newValue}
    }

    /// Whether this detail is obsolete. Occurrences are expected not to point to
    /// obsolete details.
    public var isObsolete: Bool {
      get {return _storage._isObsolete}
      set {_uniqueStorage()._isObsolete = newValue}
    }

    /// The time this information was last changed at the source. This is an
    /// upstream timestamp from the underlying information source - e.g. Ubuntu
    /// security tracker.
    public var sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._sourceUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._sourceUpdateTime = newValue}
    }
    /// Returns true if `sourceUpdateTime` has been explicitly set.
    public var hasSourceUpdateTime: Bool {return _storage._sourceUpdateTime != nil}
    /// Clears the value of `sourceUpdateTime`. Subsequent reads from it will return its default value.
    public mutating func clearSourceUpdateTime() {_uniqueStorage()._sourceUpdateTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct WindowsDetail {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The CPE URI in
    /// [cpe format](https://cpe.mitre.org/specification/) in which the
    /// vulnerability manifests. Examples include distro or storage location for
    /// vulnerable jar.
    public var cpeUri: String = String()

    /// Required. The name of the vulnerability.
    public var name: String = String()

    /// The description of the vulnerability.
    public var description_p: String = String()

    /// Required. The names of the KBs which have hotfixes to mitigate this
    /// vulnerability. Note that there may be multiple hotfixes (and thus
    /// multiple KBs) that mitigate a given vulnerability. Currently any listed
    /// kb's presence is considered a fix.
    public var fixingKbs: [Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail.KnowledgeBase] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct KnowledgeBase {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The KB name (generally of the form KB[0-9]+ i.e. KB123456).
      public var name: String = String()

      /// A link to the KB in the Windows update catalog -
      /// https://www.catalog.update.microsoft.com/
      public var url: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Details of a vulnerability Occurrence.
public struct Grafeas_V1beta1_Vulnerability_Details {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of package; whether native or non native(ruby gems, node.js
  /// packages etc)
  public var type: String = String()

  /// Output only. The note provider assigned Severity of the vulnerability.
  public var severity: Grafeas_V1beta1_Vulnerability_Severity = .unspecified

  /// Output only. The CVSS score of this vulnerability. CVSS score is on a
  /// scale of 0-10 where 0 indicates low severity and 10 indicates high
  /// severity.
  public var cvssScore: Float = 0

  /// Required. The set of affected locations and their fixes (if available)
  /// within the associated resource.
  public var packageIssue: [Grafeas_V1beta1_Vulnerability_PackageIssue] = []

  /// Output only. A one sentence description of this vulnerability.
  public var shortDescription: String = String()

  /// Output only. A detailed description of this vulnerability.
  public var longDescription: String = String()

  /// Output only. URLs related to this vulnerability.
  public var relatedUrls: [Grafeas_V1beta1_RelatedUrl] = []

  /// The distro assigned severity for this vulnerability when it is
  /// available, and note provider assigned severity when distro has not yet
  /// assigned a severity for this vulnerability.
  public var effectiveSeverity: Grafeas_V1beta1_Vulnerability_Severity = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// This message wraps a location affected by a vulnerability and its
/// associated fix (if one is available).
public struct Grafeas_V1beta1_Vulnerability_PackageIssue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The location of the vulnerability.
  public var affectedLocation: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation {
    get {return _affectedLocation ?? Grafeas_V1beta1_Vulnerability_VulnerabilityLocation()}
    set {_affectedLocation = newValue}
  }
  /// Returns true if `affectedLocation` has been explicitly set.
  public var hasAffectedLocation: Bool {return self._affectedLocation != nil}
  /// Clears the value of `affectedLocation`. Subsequent reads from it will return its default value.
  public mutating func clearAffectedLocation() {self._affectedLocation = nil}

  /// The location of the available fix for vulnerability.
  public var fixedLocation: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation {
    get {return _fixedLocation ?? Grafeas_V1beta1_Vulnerability_VulnerabilityLocation()}
    set {_fixedLocation = newValue}
  }
  /// Returns true if `fixedLocation` has been explicitly set.
  public var hasFixedLocation: Bool {return self._fixedLocation != nil}
  /// Clears the value of `fixedLocation`. Subsequent reads from it will return its default value.
  public mutating func clearFixedLocation() {self._fixedLocation = nil}

  /// Deprecated, use Details.effective_severity instead
  /// The severity (e.g., distro assigned severity) for this vulnerability.
  public var severityName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _affectedLocation: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation? = nil
  fileprivate var _fixedLocation: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation? = nil
}

/// The location of the vulnerability.
public struct Grafeas_V1beta1_Vulnerability_VulnerabilityLocation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The CPE URI in [cpe format](https://cpe.mitre.org/specification/)
  /// format. Examples include distro or storage location for vulnerable jar.
  public var cpeUri: String = String()

  /// Required. The package being described.
  public var package: String = String()

  /// Required. The version of the package being described.
  public var version: Grafeas_V1beta1_Package_Version {
    get {return _version ?? Grafeas_V1beta1_Package_Version()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: Grafeas_V1beta1_Package_Version? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grafeas.v1beta1.vulnerability"

extension Grafeas_V1beta1_Vulnerability_Severity: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEVERITY_UNSPECIFIED"),
    1: .same(proto: "MINIMAL"),
    2: .same(proto: "LOW"),
    3: .same(proto: "MEDIUM"),
    4: .same(proto: "HIGH"),
    5: .same(proto: "CRITICAL"),
  ]
}

extension Grafeas_V1beta1_Vulnerability_Vulnerability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vulnerability"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cvss_score"),
    2: .same(proto: "severity"),
    3: .same(proto: "details"),
    4: .standard(proto: "cvss_v3"),
    5: .standard(proto: "windows_details"),
    6: .standard(proto: "source_update_time"),
  ]

  fileprivate class _StorageClass {
    var _cvssScore: Float = 0
    var _severity: Grafeas_V1beta1_Vulnerability_Severity = .unspecified
    var _details: [Grafeas_V1beta1_Vulnerability_Vulnerability.Detail] = []
    var _cvssV3: Grafeas_V1beta1_Vulnerability_CVSSv3? = nil
    var _windowsDetails: [Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail] = []
    var _sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cvssScore = source._cvssScore
      _severity = source._severity
      _details = source._details
      _cvssV3 = source._cvssV3
      _windowsDetails = source._windowsDetails
      _sourceUpdateTime = source._sourceUpdateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFloatField(value: &_storage._cvssScore) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._severity) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._details) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cvssV3) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._windowsDetails) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sourceUpdateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._cvssScore != 0 {
        try visitor.visitSingularFloatField(value: _storage._cvssScore, fieldNumber: 1)
      }
      if _storage._severity != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._severity, fieldNumber: 2)
      }
      if !_storage._details.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._details, fieldNumber: 3)
      }
      if let v = _storage._cvssV3 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._windowsDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._windowsDetails, fieldNumber: 5)
      }
      if let v = _storage._sourceUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_Vulnerability, rhs: Grafeas_V1beta1_Vulnerability_Vulnerability) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cvssScore != rhs_storage._cvssScore {return false}
        if _storage._severity != rhs_storage._severity {return false}
        if _storage._details != rhs_storage._details {return false}
        if _storage._cvssV3 != rhs_storage._cvssV3 {return false}
        if _storage._windowsDetails != rhs_storage._windowsDetails {return false}
        if _storage._sourceUpdateTime != rhs_storage._sourceUpdateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Vulnerability_Vulnerability.Detail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1beta1_Vulnerability_Vulnerability.protoMessageName + ".Detail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpe_uri"),
    2: .same(proto: "package"),
    3: .standard(proto: "min_affected_version"),
    4: .standard(proto: "max_affected_version"),
    5: .standard(proto: "severity_name"),
    6: .same(proto: "description"),
    7: .standard(proto: "fixed_location"),
    8: .standard(proto: "package_type"),
    9: .standard(proto: "is_obsolete"),
    10: .standard(proto: "source_update_time"),
  ]

  fileprivate class _StorageClass {
    var _cpeUri: String = String()
    var _package: String = String()
    var _minAffectedVersion: Grafeas_V1beta1_Package_Version? = nil
    var _maxAffectedVersion: Grafeas_V1beta1_Package_Version? = nil
    var _severityName: String = String()
    var _description_p: String = String()
    var _fixedLocation: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation? = nil
    var _packageType: String = String()
    var _isObsolete: Bool = false
    var _sourceUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _cpeUri = source._cpeUri
      _package = source._package
      _minAffectedVersion = source._minAffectedVersion
      _maxAffectedVersion = source._maxAffectedVersion
      _severityName = source._severityName
      _description_p = source._description_p
      _fixedLocation = source._fixedLocation
      _packageType = source._packageType
      _isObsolete = source._isObsolete
      _sourceUpdateTime = source._sourceUpdateTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._cpeUri) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._package) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._minAffectedVersion) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._maxAffectedVersion) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._severityName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._fixedLocation) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._packageType) }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._isObsolete) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._sourceUpdateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._cpeUri.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cpeUri, fieldNumber: 1)
      }
      if !_storage._package.isEmpty {
        try visitor.visitSingularStringField(value: _storage._package, fieldNumber: 2)
      }
      if let v = _storage._minAffectedVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._maxAffectedVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._severityName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._severityName, fieldNumber: 5)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 6)
      }
      if let v = _storage._fixedLocation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._packageType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._packageType, fieldNumber: 8)
      }
      if _storage._isObsolete != false {
        try visitor.visitSingularBoolField(value: _storage._isObsolete, fieldNumber: 9)
      }
      if let v = _storage._sourceUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_Vulnerability.Detail, rhs: Grafeas_V1beta1_Vulnerability_Vulnerability.Detail) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._cpeUri != rhs_storage._cpeUri {return false}
        if _storage._package != rhs_storage._package {return false}
        if _storage._minAffectedVersion != rhs_storage._minAffectedVersion {return false}
        if _storage._maxAffectedVersion != rhs_storage._maxAffectedVersion {return false}
        if _storage._severityName != rhs_storage._severityName {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._fixedLocation != rhs_storage._fixedLocation {return false}
        if _storage._packageType != rhs_storage._packageType {return false}
        if _storage._isObsolete != rhs_storage._isObsolete {return false}
        if _storage._sourceUpdateTime != rhs_storage._sourceUpdateTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1beta1_Vulnerability_Vulnerability.protoMessageName + ".WindowsDetail"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpe_uri"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .standard(proto: "fixing_kbs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cpeUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fixingKbs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.cpeUri, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.fixingKbs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fixingKbs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail, rhs: Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail) -> Bool {
    if lhs.cpeUri != rhs.cpeUri {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.fixingKbs != rhs.fixingKbs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail.KnowledgeBase: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail.protoMessageName + ".KnowledgeBase"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail.KnowledgeBase, rhs: Grafeas_V1beta1_Vulnerability_Vulnerability.WindowsDetail.KnowledgeBase) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Vulnerability_Details: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Details"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "severity"),
    3: .standard(proto: "cvss_score"),
    4: .standard(proto: "package_issue"),
    5: .standard(proto: "short_description"),
    6: .standard(proto: "long_description"),
    7: .standard(proto: "related_urls"),
    8: .standard(proto: "effective_severity"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.cvssScore) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.packageIssue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.shortDescription) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.longDescription) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.relatedUrls) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.effectiveSeverity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if self.cvssScore != 0 {
      try visitor.visitSingularFloatField(value: self.cvssScore, fieldNumber: 3)
    }
    if !self.packageIssue.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.packageIssue, fieldNumber: 4)
    }
    if !self.shortDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.shortDescription, fieldNumber: 5)
    }
    if !self.longDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.longDescription, fieldNumber: 6)
    }
    if !self.relatedUrls.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.relatedUrls, fieldNumber: 7)
    }
    if self.effectiveSeverity != .unspecified {
      try visitor.visitSingularEnumField(value: self.effectiveSeverity, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_Details, rhs: Grafeas_V1beta1_Vulnerability_Details) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.cvssScore != rhs.cvssScore {return false}
    if lhs.packageIssue != rhs.packageIssue {return false}
    if lhs.shortDescription != rhs.shortDescription {return false}
    if lhs.longDescription != rhs.longDescription {return false}
    if lhs.relatedUrls != rhs.relatedUrls {return false}
    if lhs.effectiveSeverity != rhs.effectiveSeverity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Vulnerability_PackageIssue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PackageIssue"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "affected_location"),
    2: .standard(proto: "fixed_location"),
    3: .standard(proto: "severity_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._affectedLocation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fixedLocation) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.severityName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._affectedLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._fixedLocation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.severityName.isEmpty {
      try visitor.visitSingularStringField(value: self.severityName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_PackageIssue, rhs: Grafeas_V1beta1_Vulnerability_PackageIssue) -> Bool {
    if lhs._affectedLocation != rhs._affectedLocation {return false}
    if lhs._fixedLocation != rhs._fixedLocation {return false}
    if lhs.severityName != rhs.severityName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Vulnerability_VulnerabilityLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VulnerabilityLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "cpe_uri"),
    2: .same(proto: "package"),
    3: .same(proto: "version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cpeUri) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.package) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cpeUri.isEmpty {
      try visitor.visitSingularStringField(value: self.cpeUri, fieldNumber: 1)
    }
    if !self.package.isEmpty {
      try visitor.visitSingularStringField(value: self.package, fieldNumber: 2)
    }
    if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation, rhs: Grafeas_V1beta1_Vulnerability_VulnerabilityLocation) -> Bool {
    if lhs.cpeUri != rhs.cpeUri {return false}
    if lhs.package != rhs.package {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

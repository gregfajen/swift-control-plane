// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/containeranalysis/v1beta1/image/image.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Layer holds metadata specific to a layer of a Docker image.
public struct Grafeas_V1beta1_Image_Layer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The recovered Dockerfile directive used to construct this layer.
  public var directive: Grafeas_V1beta1_Image_Layer.Directive = .unspecified

  /// The recovered arguments to the Dockerfile directive.
  public var arguments: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Instructions from Dockerfile.
  public enum Directive: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Default value for unsupported/missing directive.
    case unspecified // = 0

    /// https://docs.docker.com/engine/reference/builder/
    case maintainer // = 1

    /// https://docs.docker.com/engine/reference/builder/
    case run // = 2

    /// https://docs.docker.com/engine/reference/builder/
    case cmd // = 3

    /// https://docs.docker.com/engine/reference/builder/
    case label // = 4

    /// https://docs.docker.com/engine/reference/builder/
    case expose // = 5

    /// https://docs.docker.com/engine/reference/builder/
    case env // = 6

    /// https://docs.docker.com/engine/reference/builder/
    case add // = 7

    /// https://docs.docker.com/engine/reference/builder/
    case copy // = 8

    /// https://docs.docker.com/engine/reference/builder/
    case entrypoint // = 9

    /// https://docs.docker.com/engine/reference/builder/
    case volume // = 10

    /// https://docs.docker.com/engine/reference/builder/
    case user // = 11

    /// https://docs.docker.com/engine/reference/builder/
    case workdir // = 12

    /// https://docs.docker.com/engine/reference/builder/
    case arg // = 13

    /// https://docs.docker.com/engine/reference/builder/
    case onbuild // = 14

    /// https://docs.docker.com/engine/reference/builder/
    case stopsignal // = 15

    /// https://docs.docker.com/engine/reference/builder/
    case healthcheck // = 16

    /// https://docs.docker.com/engine/reference/builder/
    case shell // = 17
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .maintainer
      case 2: self = .run
      case 3: self = .cmd
      case 4: self = .label
      case 5: self = .expose
      case 6: self = .env
      case 7: self = .add
      case 8: self = .copy
      case 9: self = .entrypoint
      case 10: self = .volume
      case 11: self = .user
      case 12: self = .workdir
      case 13: self = .arg
      case 14: self = .onbuild
      case 15: self = .stopsignal
      case 16: self = .healthcheck
      case 17: self = .shell
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .maintainer: return 1
      case .run: return 2
      case .cmd: return 3
      case .label: return 4
      case .expose: return 5
      case .env: return 6
      case .add: return 7
      case .copy: return 8
      case .entrypoint: return 9
      case .volume: return 10
      case .user: return 11
      case .workdir: return 12
      case .arg: return 13
      case .onbuild: return 14
      case .stopsignal: return 15
      case .healthcheck: return 16
      case .shell: return 17
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Grafeas_V1beta1_Image_Layer.Directive: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Grafeas_V1beta1_Image_Layer.Directive] = [
    .unspecified,
    .maintainer,
    .run,
    .cmd,
    .label,
    .expose,
    .env,
    .add,
    .copy,
    .entrypoint,
    .volume,
    .user,
    .workdir,
    .arg,
    .onbuild,
    .stopsignal,
    .healthcheck,
    .shell,
  ]
}

#endif  // swift(>=4.2)

/// A set of properties that uniquely identify a given Docker image.
public struct Grafeas_V1beta1_Image_Fingerprint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The layer ID of the final layer in the Docker image's v1
  /// representation.
  public var v1Name: String = String()

  /// Required. The ordered list of v2 blobs that represent a given image.
  public var v2Blob: [String] = []

  /// Output only. The name of the image's v2 blobs computed via:
  ///   [bottom] := v2_blob[bottom]
  ///   [N] := sha256(v2_blob[N] + " " + v2_name[N+1])
  /// Only the name of the final blob is kept.
  public var v2Name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Basis describes the base image portion (Note) of the DockerImage
/// relationship. Linked occurrences are derived from this or an
/// equivalent image via:
///   FROM <Basis.resource_url>
/// Or an equivalent reference, e.g. a tag of the resource_url.
public struct Grafeas_V1beta1_Image_Basis {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Immutable. The resource_url for the resource representing the
  /// basis of associated occurrence images.
  public var resourceURL: String = String()

  /// Required. Immutable. The fingerprint of the base image.
  public var fingerprint: Grafeas_V1beta1_Image_Fingerprint {
    get {return _fingerprint ?? Grafeas_V1beta1_Image_Fingerprint()}
    set {_fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return self._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {self._fingerprint = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fingerprint: Grafeas_V1beta1_Image_Fingerprint? = nil
}

/// Details of an image occurrence.
public struct Grafeas_V1beta1_Image_Details {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Immutable. The child image derived from the base image.
  public var derivedImage: Grafeas_V1beta1_Image_Derived {
    get {return _derivedImage ?? Grafeas_V1beta1_Image_Derived()}
    set {_derivedImage = newValue}
  }
  /// Returns true if `derivedImage` has been explicitly set.
  public var hasDerivedImage: Bool {return self._derivedImage != nil}
  /// Clears the value of `derivedImage`. Subsequent reads from it will return its default value.
  public mutating func clearDerivedImage() {self._derivedImage = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _derivedImage: Grafeas_V1beta1_Image_Derived? = nil
}

/// Derived describes the derived image portion (Occurrence) of the DockerImage
/// relationship. This image would be produced from a Dockerfile with FROM
/// <DockerImage.Basis in attached Note>.
public struct Grafeas_V1beta1_Image_Derived {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The fingerprint of the derived image.
  public var fingerprint: Grafeas_V1beta1_Image_Fingerprint {
    get {return _fingerprint ?? Grafeas_V1beta1_Image_Fingerprint()}
    set {_fingerprint = newValue}
  }
  /// Returns true if `fingerprint` has been explicitly set.
  public var hasFingerprint: Bool {return self._fingerprint != nil}
  /// Clears the value of `fingerprint`. Subsequent reads from it will return its default value.
  public mutating func clearFingerprint() {self._fingerprint = nil}

  /// Output only. The number of layers by which this image differs from the
  /// associated image basis.
  public var distance: Int32 = 0

  /// This contains layer-specific metadata, if populated it has length
  /// "distance" and is ordered with [distance] being the layer immediately
  /// following the base image and [1] being the final layer.
  public var layerInfo: [Grafeas_V1beta1_Image_Layer] = []

  /// Output only. This contains the base image URL for the derived image
  /// occurrence.
  public var baseResourceURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fingerprint: Grafeas_V1beta1_Image_Fingerprint? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grafeas.v1beta1.image"

extension Grafeas_V1beta1_Image_Layer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Layer"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "directive"),
    2: .same(proto: "arguments"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.directive) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.arguments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.directive != .unspecified {
      try visitor.visitSingularEnumField(value: self.directive, fieldNumber: 1)
    }
    if !self.arguments.isEmpty {
      try visitor.visitSingularStringField(value: self.arguments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Image_Layer, rhs: Grafeas_V1beta1_Image_Layer) -> Bool {
    if lhs.directive != rhs.directive {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Image_Layer.Directive: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECTIVE_UNSPECIFIED"),
    1: .same(proto: "MAINTAINER"),
    2: .same(proto: "RUN"),
    3: .same(proto: "CMD"),
    4: .same(proto: "LABEL"),
    5: .same(proto: "EXPOSE"),
    6: .same(proto: "ENV"),
    7: .same(proto: "ADD"),
    8: .same(proto: "COPY"),
    9: .same(proto: "ENTRYPOINT"),
    10: .same(proto: "VOLUME"),
    11: .same(proto: "USER"),
    12: .same(proto: "WORKDIR"),
    13: .same(proto: "ARG"),
    14: .same(proto: "ONBUILD"),
    15: .same(proto: "STOPSIGNAL"),
    16: .same(proto: "HEALTHCHECK"),
    17: .same(proto: "SHELL"),
  ]
}

extension Grafeas_V1beta1_Image_Fingerprint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Fingerprint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "v1_name"),
    2: .standard(proto: "v2_blob"),
    3: .standard(proto: "v2_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.v1Name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.v2Blob) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.v2Name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.v1Name.isEmpty {
      try visitor.visitSingularStringField(value: self.v1Name, fieldNumber: 1)
    }
    if !self.v2Blob.isEmpty {
      try visitor.visitRepeatedStringField(value: self.v2Blob, fieldNumber: 2)
    }
    if !self.v2Name.isEmpty {
      try visitor.visitSingularStringField(value: self.v2Name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Image_Fingerprint, rhs: Grafeas_V1beta1_Image_Fingerprint) -> Bool {
    if lhs.v1Name != rhs.v1Name {return false}
    if lhs.v2Blob != rhs.v2Blob {return false}
    if lhs.v2Name != rhs.v2Name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Image_Basis: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Basis"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_url"),
    2: .same(proto: "fingerprint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceURL) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fingerprint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceURL, fieldNumber: 1)
    }
    if let v = self._fingerprint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Image_Basis, rhs: Grafeas_V1beta1_Image_Basis) -> Bool {
    if lhs.resourceURL != rhs.resourceURL {return false}
    if lhs._fingerprint != rhs._fingerprint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Image_Details: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Details"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "derived_image"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._derivedImage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._derivedImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Image_Details, rhs: Grafeas_V1beta1_Image_Details) -> Bool {
    if lhs._derivedImage != rhs._derivedImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Image_Derived: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Derived"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fingerprint"),
    2: .same(proto: "distance"),
    3: .standard(proto: "layer_info"),
    4: .standard(proto: "base_resource_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fingerprint) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.distance) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.layerInfo) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.baseResourceURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._fingerprint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.distance != 0 {
      try visitor.visitSingularInt32Field(value: self.distance, fieldNumber: 2)
    }
    if !self.layerInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layerInfo, fieldNumber: 3)
    }
    if !self.baseResourceURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseResourceURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Image_Derived, rhs: Grafeas_V1beta1_Image_Derived) -> Bool {
    if lhs._fingerprint != rhs._fingerprint {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.layerInfo != rhs.layerInfo {return false}
    if lhs.baseResourceURL != rhs.baseResourceURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

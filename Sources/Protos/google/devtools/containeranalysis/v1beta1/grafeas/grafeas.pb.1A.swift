// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/containeranalysis/v1beta1/grafeas/grafeas.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2018 The Grafeas Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An instance of an analysis type that has been found on a resource.
public struct Grafeas_V1beta1_Occurrence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The name of the occurrence in the form of
  /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Required. Immutable. The resource for which the occurrence applies.
  public var resource: Grafeas_V1beta1_Resource {
    get {return _storage._resource ?? Grafeas_V1beta1_Resource()}
    set {_uniqueStorage()._resource = newValue}
  }
  /// Returns true if `resource` has been explicitly set.
  public var hasResource: Bool {return _storage._resource != nil}
  /// Clears the value of `resource`. Subsequent reads from it will return its default value.
  public mutating func clearResource() {_uniqueStorage()._resource = nil}

  /// Required. Immutable. The analysis note associated with this occurrence, in
  /// the form of `projects/[PROVIDER_ID]/notes/[NOTE_ID]`. This field can be
  /// used as a filter in list requests.
  public var noteName: String {
    get {return _storage._noteName}
    set {_uniqueStorage()._noteName = newValue}
  }

  /// Output only. This explicitly denotes which of the occurrence details are
  /// specified. This field can be used as a filter in list requests.
  public var kind: Grafeas_V1beta1_NoteKind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// A description of actions that can be taken to remedy the note.
  public var remediation: String {
    get {return _storage._remediation}
    set {_uniqueStorage()._remediation = newValue}
  }

  /// Output only. The time this occurrence was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time this occurrence was last updated.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Required. Immutable. Describes the details of the note kind found on this
  /// resource.
  public var details: OneOf_Details? {
    get {return _storage._details}
    set {_uniqueStorage()._details = newValue}
  }

  /// Describes a security vulnerability.
  public var vulnerability: Grafeas_V1beta1_Vulnerability_Details {
    get {
      if case .vulnerability(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Vulnerability_Details()
    }
    set {_uniqueStorage()._details = .vulnerability(newValue)}
  }

  /// Describes a verifiable build.
  public var build: Grafeas_V1beta1_Build_Details {
    get {
      if case .build(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Build_Details()
    }
    set {_uniqueStorage()._details = .build(newValue)}
  }

  /// Describes how this resource derives from the basis in the associated
  /// note.
  public var derivedImage: Grafeas_V1beta1_Image_Details {
    get {
      if case .derivedImage(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Image_Details()
    }
    set {_uniqueStorage()._details = .derivedImage(newValue)}
  }

  /// Describes the installation of a package on the linked resource.
  public var installation: Grafeas_V1beta1_Package_Details {
    get {
      if case .installation(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Package_Details()
    }
    set {_uniqueStorage()._details = .installation(newValue)}
  }

  /// Describes the deployment of an artifact on a runtime.
  public var deployment: Grafeas_V1beta1_Deployment_Details {
    get {
      if case .deployment(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Deployment_Details()
    }
    set {_uniqueStorage()._details = .deployment(newValue)}
  }

  /// Describes when a resource was discovered.
  public var discovered: Grafeas_V1beta1_Discovery_Details {
    get {
      if case .discovered(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Discovery_Details()
    }
    set {_uniqueStorage()._details = .discovered(newValue)}
  }

  /// Describes an attestation of an artifact.
  public var attestation: Grafeas_V1beta1_Attestation_Details {
    get {
      if case .attestation(let v)? = _storage._details {return v}
      return Grafeas_V1beta1_Attestation_Details()
    }
    set {_uniqueStorage()._details = .attestation(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Immutable. Describes the details of the note kind found on this
  /// resource.
  public enum OneOf_Details: Equatable {
    /// Describes a security vulnerability.
    case vulnerability(Grafeas_V1beta1_Vulnerability_Details)
    /// Describes a verifiable build.
    case build(Grafeas_V1beta1_Build_Details)
    /// Describes how this resource derives from the basis in the associated
    /// note.
    case derivedImage(Grafeas_V1beta1_Image_Details)
    /// Describes the installation of a package on the linked resource.
    case installation(Grafeas_V1beta1_Package_Details)
    /// Describes the deployment of an artifact on a runtime.
    case deployment(Grafeas_V1beta1_Deployment_Details)
    /// Describes when a resource was discovered.
    case discovered(Grafeas_V1beta1_Discovery_Details)
    /// Describes an attestation of an artifact.
    case attestation(Grafeas_V1beta1_Attestation_Details)

  #if !swift(>=4.1)
    public static func ==(lhs: Grafeas_V1beta1_Occurrence.OneOf_Details, rhs: Grafeas_V1beta1_Occurrence.OneOf_Details) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vulnerability, .vulnerability): return {
        guard case .vulnerability(let l) = lhs, case .vulnerability(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.build, .build): return {
        guard case .build(let l) = lhs, case .build(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.derivedImage, .derivedImage): return {
        guard case .derivedImage(let l) = lhs, case .derivedImage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.installation, .installation): return {
        guard case .installation(let l) = lhs, case .installation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deployment, .deployment): return {
        guard case .deployment(let l) = lhs, case .deployment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discovered, .discovered): return {
        guard case .discovered(let l) = lhs, case .discovered(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attestation, .attestation): return {
        guard case .attestation(let l) = lhs, case .attestation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An entity that can have metadata. For example, a Docker image.
public struct Grafeas_V1beta1_Resource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the resource. For example, the name of a Docker image -
  /// "Debian".
  public var name: String = String()

  /// Required. The unique URI of the resource. For example,
  /// `https://gcr.io/project/image@sha256:foo` for a Docker image.
  public var uri: String = String()

  /// The hash of the resource content. For example, the Docker digest.
  public var contentHash: Grafeas_V1beta1_Provenance_Hash {
    get {return _contentHash ?? Grafeas_V1beta1_Provenance_Hash()}
    set {_contentHash = newValue}
  }
  /// Returns true if `contentHash` has been explicitly set.
  public var hasContentHash: Bool {return self._contentHash != nil}
  /// Clears the value of `contentHash`. Subsequent reads from it will return its default value.
  public mutating func clearContentHash() {self._contentHash = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _contentHash: Grafeas_V1beta1_Provenance_Hash? = nil
}

/// A type of analysis that can be done for a resource.
public struct Grafeas_V1beta1_Note {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The name of the note in the form of
  /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A one sentence description of this note.
  public var shortDescription: String {
    get {return _storage._shortDescription}
    set {_uniqueStorage()._shortDescription = newValue}
  }

  /// A detailed description of this note.
  public var longDescription: String {
    get {return _storage._longDescription}
    set {_uniqueStorage()._longDescription = newValue}
  }

  /// Output only. The type of analysis. This field can be used as a filter in
  /// list requests.
  public var kind: Grafeas_V1beta1_NoteKind {
    get {return _storage._kind}
    set {_uniqueStorage()._kind = newValue}
  }

  /// URLs associated with this note.
  public var relatedURL: [Grafeas_V1beta1_RelatedUrl] {
    get {return _storage._relatedURL}
    set {_uniqueStorage()._relatedURL = newValue}
  }

  /// Time of expiration for this note. Empty if note does not expire.
  public var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  public var hasExpirationTime: Bool {return _storage._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

  /// Output only. The time this note was created. This field can be used as a
  /// filter in list requests.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. The time this note was last updated. This field can be used as
  /// a filter in list requests.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Other notes related to this note.
  public var relatedNoteNames: [String] {
    get {return _storage._relatedNoteNames}
    set {_uniqueStorage()._relatedNoteNames = newValue}
  }

  /// Required. Immutable. The type of analysis this note represents.
  public var type: OneOf_Type? {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// A note describing a package vulnerability.
  public var vulnerability: Grafeas_V1beta1_Vulnerability_Vulnerability {
    get {
      if case .vulnerability(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Vulnerability_Vulnerability()
    }
    set {_uniqueStorage()._type = .vulnerability(newValue)}
  }

  /// A note describing build provenance for a verifiable build.
  public var build: Grafeas_V1beta1_Build_Build {
    get {
      if case .build(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Build_Build()
    }
    set {_uniqueStorage()._type = .build(newValue)}
  }

  /// A note describing a base image.
  public var baseImage: Grafeas_V1beta1_Image_Basis {
    get {
      if case .baseImage(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Image_Basis()
    }
    set {_uniqueStorage()._type = .baseImage(newValue)}
  }

  /// A note describing a package hosted by various package managers.
  public var package: Grafeas_V1beta1_Package_Package {
    get {
      if case .package(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Package_Package()
    }
    set {_uniqueStorage()._type = .package(newValue)}
  }

  /// A note describing something that can be deployed.
  public var deployable: Grafeas_V1beta1_Deployment_Deployable {
    get {
      if case .deployable(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Deployment_Deployable()
    }
    set {_uniqueStorage()._type = .deployable(newValue)}
  }

  /// A note describing the initial analysis of a resource.
  public var discovery: Grafeas_V1beta1_Discovery_Discovery {
    get {
      if case .discovery(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Discovery_Discovery()
    }
    set {_uniqueStorage()._type = .discovery(newValue)}
  }

  /// A note describing an attestation role.
  public var attestationAuthority: Grafeas_V1beta1_Attestation_Authority {
    get {
      if case .attestationAuthority(let v)? = _storage._type {return v}
      return Grafeas_V1beta1_Attestation_Authority()
    }
    set {_uniqueStorage()._type = .attestationAuthority(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. Immutable. The type of analysis this note represents.
  public enum OneOf_Type: Equatable {
    /// A note describing a package vulnerability.
    case vulnerability(Grafeas_V1beta1_Vulnerability_Vulnerability)
    /// A note describing build provenance for a verifiable build.
    case build(Grafeas_V1beta1_Build_Build)
    /// A note describing a base image.
    case baseImage(Grafeas_V1beta1_Image_Basis)
    /// A note describing a package hosted by various package managers.
    case package(Grafeas_V1beta1_Package_Package)
    /// A note describing something that can be deployed.
    case deployable(Grafeas_V1beta1_Deployment_Deployable)
    /// A note describing the initial analysis of a resource.
    case discovery(Grafeas_V1beta1_Discovery_Discovery)
    /// A note describing an attestation role.
    case attestationAuthority(Grafeas_V1beta1_Attestation_Authority)

  #if !swift(>=4.1)
    public static func ==(lhs: Grafeas_V1beta1_Note.OneOf_Type, rhs: Grafeas_V1beta1_Note.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.vulnerability, .vulnerability): return {
        guard case .vulnerability(let l) = lhs, case .vulnerability(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.build, .build): return {
        guard case .build(let l) = lhs, case .build(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.baseImage, .baseImage): return {
        guard case .baseImage(let l) = lhs, case .baseImage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.package, .package): return {
        guard case .package(let l) = lhs, case .package(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deployable, .deployable): return {
        guard case .deployable(let l) = lhs, case .deployable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.discovery, .discovery): return {
        guard case .discovery(let l) = lhs, case .discovery(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.attestationAuthority, .attestationAuthority): return {
        guard case .attestationAuthority(let l) = lhs, case .attestationAuthority(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Request to get an occurrence.
public struct Grafeas_V1beta1_GetOccurrenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the occurrence in the form of
  /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list occurrences.
public struct Grafeas_V1beta1_ListOccurrencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project to list occurrences for in the form of
  /// `projects/[PROJECT_ID]`.
  public var parent: String = String()

  /// The filter expression.
  public var filter: String = String()

  /// Number of occurrences to return in the list.
  public var pageSize: Int32 = 0

  /// Token to provide to skip to a particular spot in the list.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for listing occurrences.
public struct Grafeas_V1beta1_ListOccurrencesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The occurrences requested.
  public var occurrences: [Grafeas_V1beta1_Occurrence] = []

  /// The next pagination token in the list response. It should be used as
  /// `page_token` for the following request. An empty value means no more
  /// results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to delete a occurrence.
public struct Grafeas_V1beta1_DeleteOccurrenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the occurrence in the form of
  /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create a new occurrence.
public struct Grafeas_V1beta1_CreateOccurrenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
  /// the occurrence is to be created.
  public var parent: String = String()

  /// The occurrence to create.
  public var occurrence: Grafeas_V1beta1_Occurrence {
    get {return _occurrence ?? Grafeas_V1beta1_Occurrence()}
    set {_occurrence = newValue}
  }
  /// Returns true if `occurrence` has been explicitly set.
  public var hasOccurrence: Bool {return self._occurrence != nil}
  /// Clears the value of `occurrence`. Subsequent reads from it will return its default value.
  public mutating func clearOccurrence() {self._occurrence = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _occurrence: Grafeas_V1beta1_Occurrence? = nil
}

/// Request to update an occurrence.
public struct Grafeas_V1beta1_UpdateOccurrenceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the occurrence in the form of
  /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  public var name: String = String()

  /// The updated occurrence.
  public var occurrence: Grafeas_V1beta1_Occurrence {
    get {return _occurrence ?? Grafeas_V1beta1_Occurrence()}
    set {_occurrence = newValue}
  }
  /// Returns true if `occurrence` has been explicitly set.
  public var hasOccurrence: Bool {return self._occurrence != nil}
  /// Clears the value of `occurrence`. Subsequent reads from it will return its default value.
  public mutating func clearOccurrence() {self._occurrence = nil}

  /// The fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _occurrence: Grafeas_V1beta1_Occurrence? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request to get a note.
public struct Grafeas_V1beta1_GetNoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the note in the form of
  /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get the note to which the specified occurrence is attached.
public struct Grafeas_V1beta1_GetOccurrenceNoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the occurrence in the form of
  /// `projects/[PROJECT_ID]/occurrences/[OCCURRENCE_ID]`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list notes.
public struct Grafeas_V1beta1_ListNotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project to list notes for in the form of
  /// `projects/[PROJECT_ID]`.
  public var parent: String = String()

  /// The filter expression.
  public var filter: String = String()

  /// Number of notes to return in the list.
  public var pageSize: Int32 = 0

  /// Token to provide to skip to a particular spot in the list.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for listing notes.
public struct Grafeas_V1beta1_ListNotesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The notes requested.
  public var notes: [Grafeas_V1beta1_Note] = []

  /// The next pagination token in the list response. It should be used as
  /// `page_token` for the following request. An empty value means no more
  /// results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to delete a note.
public struct Grafeas_V1beta1_DeleteNoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the note in the form of
  /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create a new note.
public struct Grafeas_V1beta1_CreateNoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
  /// the note is to be created.
  public var parent: String = String()

  /// The ID to use for this note.
  public var noteID: String = String()

  /// The note to create.
  public var note: Grafeas_V1beta1_Note {
    get {return _note ?? Grafeas_V1beta1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Grafeas_V1beta1_Note? = nil
}

/// Request to update a note.
public struct Grafeas_V1beta1_UpdateNoteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the note in the form of
  /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
  public var name: String = String()

  /// The updated note.
  public var note: Grafeas_V1beta1_Note {
    get {return _note ?? Grafeas_V1beta1_Note()}
    set {_note = newValue}
  }
  /// Returns true if `note` has been explicitly set.
  public var hasNote: Bool {return self._note != nil}
  /// Clears the value of `note`. Subsequent reads from it will return its default value.
  public mutating func clearNote() {self._note = nil}

  /// The fields to update.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _note: Grafeas_V1beta1_Note? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// Request to list occurrences for a note.
public struct Grafeas_V1beta1_ListNoteOccurrencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the note to list occurrences for in the form of
  /// `projects/[PROVIDER_ID]/notes/[NOTE_ID]`.
  public var name: String = String()

  /// The filter expression.
  public var filter: String = String()

  /// Number of occurrences to return in the list.
  public var pageSize: Int32 = 0

  /// Token to provide to skip to a particular spot in the list.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for listing occurrences for a note.
public struct Grafeas_V1beta1_ListNoteOccurrencesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The occurrences attached to the specified note.
  public var occurrences: [Grafeas_V1beta1_Occurrence] = []

  /// Token to provide to skip to a particular spot in the list.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create notes in batch.
public struct Grafeas_V1beta1_BatchCreateNotesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
  /// the notes are to be created.
  public var parent: String = String()

  /// The notes to create.
  public var notes: Dictionary<String,Grafeas_V1beta1_Note> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for creating notes in batch.
public struct Grafeas_V1beta1_BatchCreateNotesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The notes that were created.
  public var notes: [Grafeas_V1beta1_Note] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create occurrences in batch.
public struct Grafeas_V1beta1_BatchCreateOccurrencesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project in the form of `projects/[PROJECT_ID]`, under which
  /// the occurrences are to be created.
  public var parent: String = String()

  /// The occurrences to create.
  public var occurrences: [Grafeas_V1beta1_Occurrence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response for creating occurrences in batch.
public struct Grafeas_V1beta1_BatchCreateOccurrencesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The occurrences that were created.
  public var occurrences: [Grafeas_V1beta1_Occurrence] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to get a vulnerability summary for some set of occurrences.
public struct Grafeas_V1beta1_GetVulnerabilityOccurrencesSummaryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the project to get a vulnerability summary for in the form of
  /// `projects/[PROJECT_ID]`.
  public var parent: String = String()

  /// The filter expression.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A summary of how many vulnerability occurrences there are per resource and
/// severity type.
public struct Grafeas_V1beta1_VulnerabilityOccurrencesSummary {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A listing by resource of the number of fixable and total vulnerabilities.
  public var counts: [Grafeas_V1beta1_VulnerabilityOccurrencesSummary.FixableTotalByDigest] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Per resource and severity counts of fixable and total vulnerabilities.
  public struct FixableTotalByDigest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The affected resource.
    public var resource: Grafeas_V1beta1_Resource {
      get {return _resource ?? Grafeas_V1beta1_Resource()}
      set {_resource = newValue}
    }
    /// Returns true if `resource` has been explicitly set.
    public var hasResource: Bool {return self._resource != nil}
    /// Clears the value of `resource`. Subsequent reads from it will return its default value.
    public mutating func clearResource() {self._resource = nil}

    /// The severity for this count. SEVERITY_UNSPECIFIED indicates total across
    /// all severities.
    public var severity: Grafeas_V1beta1_Vulnerability_Severity = .unspecified

    /// The number of fixable vulnerabilities associated with this resource.
    public var fixableCount: Int64 = 0

    /// The total number of vulnerabilities associated with this resource.
    public var totalCount: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _resource: Grafeas_V1beta1_Resource? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "grafeas.v1beta1"

extension Grafeas_V1beta1_Occurrence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Occurrence"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "resource"),
    3: .standard(proto: "note_name"),
    4: .same(proto: "kind"),
    5: .same(proto: "remediation"),
    6: .standard(proto: "create_time"),
    7: .standard(proto: "update_time"),
    8: .same(proto: "vulnerability"),
    9: .same(proto: "build"),
    10: .standard(proto: "derived_image"),
    11: .same(proto: "installation"),
    12: .same(proto: "deployment"),
    13: .same(proto: "discovered"),
    14: .same(proto: "attestation"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _resource: Grafeas_V1beta1_Resource? = nil
    var _noteName: String = String()
    var _kind: Grafeas_V1beta1_NoteKind = .unspecified
    var _remediation: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _details: Grafeas_V1beta1_Occurrence.OneOf_Details?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _resource = source._resource
      _noteName = source._noteName
      _kind = source._kind
      _remediation = source._remediation
      _createTime = source._createTime
      _updateTime = source._updateTime
      _details = source._details
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._resource) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._noteName) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._remediation) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 8: try {
          var v: Grafeas_V1beta1_Vulnerability_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .vulnerability(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .vulnerability(v)}
        }()
        case 9: try {
          var v: Grafeas_V1beta1_Build_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .build(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .build(v)}
        }()
        case 10: try {
          var v: Grafeas_V1beta1_Image_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .derivedImage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .derivedImage(v)}
        }()
        case 11: try {
          var v: Grafeas_V1beta1_Package_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .installation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .installation(v)}
        }()
        case 12: try {
          var v: Grafeas_V1beta1_Deployment_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .deployment(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .deployment(v)}
        }()
        case 13: try {
          var v: Grafeas_V1beta1_Discovery_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .discovered(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .discovered(v)}
        }()
        case 14: try {
          var v: Grafeas_V1beta1_Attestation_Details?
          if let current = _storage._details {
            try decoder.handleConflictingOneOf()
            if case .attestation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._details = .attestation(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._resource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._noteName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._noteName, fieldNumber: 3)
      }
      if _storage._kind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 4)
      }
      if !_storage._remediation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remediation, fieldNumber: 5)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._details {
      case .vulnerability?: try {
        guard case .vulnerability(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .build?: try {
        guard case .build(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .derivedImage?: try {
        guard case .derivedImage(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .installation?: try {
        guard case .installation(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .deployment?: try {
        guard case .deployment(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .discovered?: try {
        guard case .discovered(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .attestation?: try {
        guard case .attestation(let v)? = _storage._details else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Occurrence, rhs: Grafeas_V1beta1_Occurrence) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._resource != rhs_storage._resource {return false}
        if _storage._noteName != rhs_storage._noteName {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._remediation != rhs_storage._remediation {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._details != rhs_storage._details {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Resource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Resource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "uri"),
    3: .standard(proto: "content_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._contentHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    if let v = self._contentHash {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Resource, rhs: Grafeas_V1beta1_Resource) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs._contentHash != rhs._contentHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_Note: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Note"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "short_description"),
    3: .standard(proto: "long_description"),
    4: .same(proto: "kind"),
    5: .standard(proto: "related_url"),
    6: .standard(proto: "expiration_time"),
    7: .standard(proto: "create_time"),
    8: .standard(proto: "update_time"),
    9: .standard(proto: "related_note_names"),
    10: .same(proto: "vulnerability"),
    11: .same(proto: "build"),
    12: .standard(proto: "base_image"),
    13: .same(proto: "package"),
    14: .same(proto: "deployable"),
    15: .same(proto: "discovery"),
    16: .standard(proto: "attestation_authority"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _shortDescription: String = String()
    var _longDescription: String = String()
    var _kind: Grafeas_V1beta1_NoteKind = .unspecified
    var _relatedURL: [Grafeas_V1beta1_RelatedUrl] = []
    var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _relatedNoteNames: [String] = []
    var _type: Grafeas_V1beta1_Note.OneOf_Type?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _shortDescription = source._shortDescription
      _longDescription = source._longDescription
      _kind = source._kind
      _relatedURL = source._relatedURL
      _expirationTime = source._expirationTime
      _createTime = source._createTime
      _updateTime = source._updateTime
      _relatedNoteNames = source._relatedNoteNames
      _type = source._type
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._shortDescription) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._longDescription) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._kind) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._relatedURL) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        case 9: try { try decoder.decodeRepeatedStringField(value: &_storage._relatedNoteNames) }()
        case 10: try {
          var v: Grafeas_V1beta1_Vulnerability_Vulnerability?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .vulnerability(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .vulnerability(v)}
        }()
        case 11: try {
          var v: Grafeas_V1beta1_Build_Build?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .build(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .build(v)}
        }()
        case 12: try {
          var v: Grafeas_V1beta1_Image_Basis?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .baseImage(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .baseImage(v)}
        }()
        case 13: try {
          var v: Grafeas_V1beta1_Package_Package?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .package(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .package(v)}
        }()
        case 14: try {
          var v: Grafeas_V1beta1_Deployment_Deployable?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .deployable(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .deployable(v)}
        }()
        case 15: try {
          var v: Grafeas_V1beta1_Discovery_Discovery?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .discovery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .discovery(v)}
        }()
        case 16: try {
          var v: Grafeas_V1beta1_Attestation_Authority?
          if let current = _storage._type {
            try decoder.handleConflictingOneOf()
            if case .attestationAuthority(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._type = .attestationAuthority(v)}
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._shortDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._shortDescription, fieldNumber: 2)
      }
      if !_storage._longDescription.isEmpty {
        try visitor.visitSingularStringField(value: _storage._longDescription, fieldNumber: 3)
      }
      if _storage._kind != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._kind, fieldNumber: 4)
      }
      if !_storage._relatedURL.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._relatedURL, fieldNumber: 5)
      }
      if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._relatedNoteNames.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._relatedNoteNames, fieldNumber: 9)
      }
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch _storage._type {
      case .vulnerability?: try {
        guard case .vulnerability(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .build?: try {
        guard case .build(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .baseImage?: try {
        guard case .baseImage(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .package?: try {
        guard case .package(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .deployable?: try {
        guard case .deployable(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .discovery?: try {
        guard case .discovery(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .attestationAuthority?: try {
        guard case .attestationAuthority(let v)? = _storage._type else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_Note, rhs: Grafeas_V1beta1_Note) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._shortDescription != rhs_storage._shortDescription {return false}
        if _storage._longDescription != rhs_storage._longDescription {return false}
        if _storage._kind != rhs_storage._kind {return false}
        if _storage._relatedURL != rhs_storage._relatedURL {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._relatedNoteNames != rhs_storage._relatedNoteNames {return false}
        if _storage._type != rhs_storage._type {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_GetOccurrenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOccurrenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_GetOccurrenceRequest, rhs: Grafeas_V1beta1_GetOccurrenceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_ListOccurrencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOccurrencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_ListOccurrencesRequest, rhs: Grafeas_V1beta1_ListOccurrencesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_ListOccurrencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOccurrencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "occurrences"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.occurrences) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.occurrences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.occurrences, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_ListOccurrencesResponse, rhs: Grafeas_V1beta1_ListOccurrencesResponse) -> Bool {
    if lhs.occurrences != rhs.occurrences {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_DeleteOccurrenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteOccurrenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_DeleteOccurrenceRequest, rhs: Grafeas_V1beta1_DeleteOccurrenceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_CreateOccurrenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateOccurrenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "occurrence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._occurrence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._occurrence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_CreateOccurrenceRequest, rhs: Grafeas_V1beta1_CreateOccurrenceRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._occurrence != rhs._occurrence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_UpdateOccurrenceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateOccurrenceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "occurrence"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._occurrence) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._occurrence {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_UpdateOccurrenceRequest, rhs: Grafeas_V1beta1_UpdateOccurrenceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._occurrence != rhs._occurrence {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_GetNoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_GetNoteRequest, rhs: Grafeas_V1beta1_GetNoteRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_GetOccurrenceNoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOccurrenceNoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_GetOccurrenceNoteRequest, rhs: Grafeas_V1beta1_GetOccurrenceNoteRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_ListNotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_ListNotesRequest, rhs: Grafeas_V1beta1_ListNotesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_ListNotesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNotesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notes"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notes, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_ListNotesResponse, rhs: Grafeas_V1beta1_ListNotesResponse) -> Bool {
    if lhs.notes != rhs.notes {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_DeleteNoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_DeleteNoteRequest, rhs: Grafeas_V1beta1_DeleteNoteRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_CreateNoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "note_id"),
    3: .same(proto: "note"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.noteID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.noteID.isEmpty {
      try visitor.visitSingularStringField(value: self.noteID, fieldNumber: 2)
    }
    if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_CreateNoteRequest, rhs: Grafeas_V1beta1_CreateNoteRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.noteID != rhs.noteID {return false}
    if lhs._note != rhs._note {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_UpdateNoteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNoteRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "note"),
    3: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._note) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._note {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_UpdateNoteRequest, rhs: Grafeas_V1beta1_UpdateNoteRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._note != rhs._note {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_ListNoteOccurrencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNoteOccurrencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_ListNoteOccurrencesRequest, rhs: Grafeas_V1beta1_ListNoteOccurrencesRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_ListNoteOccurrencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNoteOccurrencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "occurrences"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.occurrences) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.occurrences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.occurrences, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_ListNoteOccurrencesResponse, rhs: Grafeas_V1beta1_ListNoteOccurrencesResponse) -> Bool {
    if lhs.occurrences != rhs.occurrences {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_BatchCreateNotesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateNotesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "notes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grafeas_V1beta1_Note>.self, value: &self.notes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.notes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Grafeas_V1beta1_Note>.self, value: self.notes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_BatchCreateNotesRequest, rhs: Grafeas_V1beta1_BatchCreateNotesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.notes != rhs.notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_BatchCreateNotesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateNotesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.notes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.notes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_BatchCreateNotesResponse, rhs: Grafeas_V1beta1_BatchCreateNotesResponse) -> Bool {
    if lhs.notes != rhs.notes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_BatchCreateOccurrencesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateOccurrencesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "occurrences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.occurrences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.occurrences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.occurrences, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_BatchCreateOccurrencesRequest, rhs: Grafeas_V1beta1_BatchCreateOccurrencesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.occurrences != rhs.occurrences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_BatchCreateOccurrencesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateOccurrencesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "occurrences"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.occurrences) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.occurrences.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.occurrences, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_BatchCreateOccurrencesResponse, rhs: Grafeas_V1beta1_BatchCreateOccurrencesResponse) -> Bool {
    if lhs.occurrences != rhs.occurrences {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_GetVulnerabilityOccurrencesSummaryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetVulnerabilityOccurrencesSummaryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_GetVulnerabilityOccurrencesSummaryRequest, rhs: Grafeas_V1beta1_GetVulnerabilityOccurrencesSummaryRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_VulnerabilityOccurrencesSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VulnerabilityOccurrencesSummary"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "counts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.counts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.counts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.counts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_VulnerabilityOccurrencesSummary, rhs: Grafeas_V1beta1_VulnerabilityOccurrencesSummary) -> Bool {
    if lhs.counts != rhs.counts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Grafeas_V1beta1_VulnerabilityOccurrencesSummary.FixableTotalByDigest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Grafeas_V1beta1_VulnerabilityOccurrencesSummary.protoMessageName + ".FixableTotalByDigest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "resource"),
    2: .same(proto: "severity"),
    3: .standard(proto: "fixable_count"),
    4: .standard(proto: "total_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._resource) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.severity) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.fixableCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._resource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.severity != .unspecified {
      try visitor.visitSingularEnumField(value: self.severity, fieldNumber: 2)
    }
    if self.fixableCount != 0 {
      try visitor.visitSingularInt64Field(value: self.fixableCount, fieldNumber: 3)
    }
    if self.totalCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Grafeas_V1beta1_VulnerabilityOccurrencesSummary.FixableTotalByDigest, rhs: Grafeas_V1beta1_VulnerabilityOccurrencesSummary.FixableTotalByDigest) -> Bool {
    if lhs._resource != rhs._resource {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.fixableCount != rhs.fixableCount {return false}
    if lhs.totalCount != rhs.totalCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

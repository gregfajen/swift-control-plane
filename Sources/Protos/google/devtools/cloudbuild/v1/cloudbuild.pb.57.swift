// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/devtools/cloudbuild/v1/cloudbuild.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specifies a build to retry.
public struct Google_Devtools_Cloudbuild_V1_RetryBuildRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the `Build` to retry.
  /// Format: `projects/{project}/locations/{location}/builds/{build}`
  public var name: String = String()

  /// Required. ID of the project.
  public var projectID: String = String()

  /// Required. Build ID of the original build.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Specifies a build trigger to run and the source to use.
public struct Google_Devtools_Cloudbuild_V1_RunBuildTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the project.
  public var projectID: String = String()

  /// Required. ID of the trigger.
  public var triggerID: String = String()

  /// Required. Source to build against this trigger.
  public var source: Google_Devtools_Cloudbuild_V1_RepoSource {
    get {return _source ?? Google_Devtools_Cloudbuild_V1_RepoSource()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {self._source = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _source: Google_Devtools_Cloudbuild_V1_RepoSource? = nil
}

/// Location of the source in an archive file in Google Cloud Storage.
public struct Google_Devtools_Cloudbuild_V1_StorageSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Google Cloud Storage bucket containing the source (see
  /// [Bucket Name
  /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
  public var bucket: String = String()

  /// Google Cloud Storage object containing the source.
  ///
  /// This object must be a gzipped archive file (`.tar.gz`) containing source to
  /// build.
  public var object: String = String()

  /// Google Cloud Storage generation for the object. If the generation is
  /// omitted, the latest generation will be used.
  public var generation: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Location of the source in a Google Cloud Source Repository.
public struct Google_Devtools_Cloudbuild_V1_RepoSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the project that owns the Cloud Source Repository. If omitted, the
  /// project ID requesting the build is assumed.
  public var projectID: String = String()

  /// Required. Name of the Cloud Source Repository.
  public var repoName: String = String()

  /// A revision within the Cloud Source Repository must be specified in
  /// one of these ways.
  public var revision: Google_Devtools_Cloudbuild_V1_RepoSource.OneOf_Revision? = nil

  /// Regex matching branches to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  public var branchName: String {
    get {
      if case .branchName(let v)? = revision {return v}
      return String()
    }
    set {revision = .branchName(newValue)}
  }

  /// Regex matching tags to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  public var tagName: String {
    get {
      if case .tagName(let v)? = revision {return v}
      return String()
    }
    set {revision = .tagName(newValue)}
  }

  /// Explicit commit SHA to build.
  public var commitSha: String {
    get {
      if case .commitSha(let v)? = revision {return v}
      return String()
    }
    set {revision = .commitSha(newValue)}
  }

  /// Directory, relative to the source root, in which to run the build.
  ///
  /// This must be a relative path. If a step's `dir` is specified and is an
  /// absolute path, this value is ignored for that step's execution.
  public var dir: String = String()

  /// Only trigger a build if the revision regex does NOT match the revision
  /// regex.
  public var invertRegex: Bool = false

  /// Substitutions to use in a triggered build.
  /// Should only be used with RunBuildTrigger
  public var substitutions: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A revision within the Cloud Source Repository must be specified in
  /// one of these ways.
  public enum OneOf_Revision: Equatable {
    /// Regex matching branches to build.
    ///
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    case branchName(String)
    /// Regex matching tags to build.
    ///
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    case tagName(String)
    /// Explicit commit SHA to build.
    case commitSha(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Cloudbuild_V1_RepoSource.OneOf_Revision, rhs: Google_Devtools_Cloudbuild_V1_RepoSource.OneOf_Revision) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.branchName, .branchName): return {
        guard case .branchName(let l) = lhs, case .branchName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tagName, .tagName): return {
        guard case .tagName(let l) = lhs, case .tagName(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commitSha, .commitSha): return {
        guard case .commitSha(let l) = lhs, case .commitSha(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Location of the source in a supported storage service.
public struct Google_Devtools_Cloudbuild_V1_Source {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Location of source.
  public var source: Google_Devtools_Cloudbuild_V1_Source.OneOf_Source? = nil

  /// If provided, get the source from this location in Google Cloud Storage.
  public var storageSource: Google_Devtools_Cloudbuild_V1_StorageSource {
    get {
      if case .storageSource(let v)? = source {return v}
      return Google_Devtools_Cloudbuild_V1_StorageSource()
    }
    set {source = .storageSource(newValue)}
  }

  /// If provided, get the source from this location in a Cloud Source
  /// Repository.
  public var repoSource: Google_Devtools_Cloudbuild_V1_RepoSource {
    get {
      if case .repoSource(let v)? = source {return v}
      return Google_Devtools_Cloudbuild_V1_RepoSource()
    }
    set {source = .repoSource(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Location of source.
  public enum OneOf_Source: Equatable {
    /// If provided, get the source from this location in Google Cloud Storage.
    case storageSource(Google_Devtools_Cloudbuild_V1_StorageSource)
    /// If provided, get the source from this location in a Cloud Source
    /// Repository.
    case repoSource(Google_Devtools_Cloudbuild_V1_RepoSource)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Source.OneOf_Source, rhs: Google_Devtools_Cloudbuild_V1_Source.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.storageSource, .storageSource): return {
        guard case .storageSource(let l) = lhs, case .storageSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.repoSource, .repoSource): return {
        guard case .repoSource(let l) = lhs, case .repoSource(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// An image built by the pipeline.
public struct Google_Devtools_Cloudbuild_V1_BuiltImage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name used to push the container image to Google Container Registry, as
  /// presented to `docker push`.
  public var name: String = String()

  /// Docker Registry 2.0 digest.
  public var digest: String = String()

  /// Output only. Stores timing information for pushing the specified image.
  public var pushTiming: Google_Devtools_Cloudbuild_V1_TimeSpan {
    get {return _pushTiming ?? Google_Devtools_Cloudbuild_V1_TimeSpan()}
    set {_pushTiming = newValue}
  }
  /// Returns true if `pushTiming` has been explicitly set.
  public var hasPushTiming: Bool {return self._pushTiming != nil}
  /// Clears the value of `pushTiming`. Subsequent reads from it will return its default value.
  public mutating func clearPushTiming() {self._pushTiming = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _pushTiming: Google_Devtools_Cloudbuild_V1_TimeSpan? = nil
}

/// A step in the build pipeline.
public struct Google_Devtools_Cloudbuild_V1_BuildStep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the container image that will run this particular
  /// build step.
  ///
  /// If the image is available in the host's Docker daemon's cache, it
  /// will be run directly. If not, the host will attempt to pull the image
  /// first, using the builder service account's credentials if necessary.
  ///
  /// The Docker daemon's cache will already have the latest versions of all of
  /// the officially supported build steps
  /// ([https://github.com/GoogleCloudPlatform/cloud-builders](https://github.com/GoogleCloudPlatform/cloud-builders)).
  /// The Docker daemon will also have cached many of the layers for some popular
  /// images, like "ubuntu", "debian", but they will be refreshed at the time you
  /// attempt to use them.
  ///
  /// If you built an image in a previous build step, it will be stored in the
  /// host's Docker daemon's cache and is available to use as the name for a
  /// later build step.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// A list of environment variable definitions to be used when running a step.
  ///
  /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
  /// being given the value "VALUE".
  public var env: [String] {
    get {return _storage._env}
    set {_uniqueStorage()._env = newValue}
  }

  /// A list of arguments that will be presented to the step when it is started.
  ///
  /// If the image used to run the step's container has an entrypoint, the `args`
  /// are used as arguments to that entrypoint. If the image does not define
  /// an entrypoint, the first element in args is used as the entrypoint,
  /// and the remainder will be used as arguments.
  public var args: [String] {
    get {return _storage._args}
    set {_uniqueStorage()._args = newValue}
  }

  /// Working directory to use when running this step's container.
  ///
  /// If this value is a relative path, it is relative to the build's working
  /// directory. If this value is absolute, it may be outside the build's working
  /// directory, in which case the contents of the path may not be persisted
  /// across build step executions, unless a `volume` for that path is specified.
  ///
  /// If the build specifies a `RepoSource` with `dir` and a step with a `dir`,
  /// which specifies an absolute path, the `RepoSource` `dir` is ignored for
  /// the step's execution.
  public var dir: String {
    get {return _storage._dir}
    set {_uniqueStorage()._dir = newValue}
  }

  /// Unique identifier for this build step, used in `wait_for` to
  /// reference this build step as a dependency.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The ID(s) of the step(s) that this build step depends on.
  /// This build step will not start until all the build steps in `wait_for`
  /// have completed successfully. If `wait_for` is empty, this build step will
  /// start when all previous build steps in the `Build.Steps` list have
  /// completed successfully.
  public var waitFor: [String] {
    get {return _storage._waitFor}
    set {_uniqueStorage()._waitFor = newValue}
  }

  /// Entrypoint to be used instead of the build step image's default entrypoint.
  /// If unset, the image's default entrypoint is used.
  public var entrypoint: String {
    get {return _storage._entrypoint}
    set {_uniqueStorage()._entrypoint = newValue}
  }

  /// A list of environment variables which are encrypted using a Cloud Key
  /// Management Service crypto key. These values must be specified in the
  /// build's `Secret`.
  public var secretEnv: [String] {
    get {return _storage._secretEnv}
    set {_uniqueStorage()._secretEnv = newValue}
  }

  /// List of volumes to mount into the build step.
  ///
  /// Each volume is created as an empty volume prior to execution of the
  /// build step. Upon completion of the build, volumes and their contents are
  /// discarded.
  ///
  /// Using a named volume in only one step is not valid as it is indicative
  /// of a build request with an incorrect configuration.
  public var volumes: [Google_Devtools_Cloudbuild_V1_Volume] {
    get {return _storage._volumes}
    set {_uniqueStorage()._volumes = newValue}
  }

  /// Output only. Stores timing information for executing this build step.
  public var timing: Google_Devtools_Cloudbuild_V1_TimeSpan {
    get {return _storage._timing ?? Google_Devtools_Cloudbuild_V1_TimeSpan()}
    set {_uniqueStorage()._timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  public var hasTiming: Bool {return _storage._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  public mutating func clearTiming() {_uniqueStorage()._timing = nil}

  /// Output only. Stores timing information for pulling this build step's
  /// builder image only.
  public var pullTiming: Google_Devtools_Cloudbuild_V1_TimeSpan {
    get {return _storage._pullTiming ?? Google_Devtools_Cloudbuild_V1_TimeSpan()}
    set {_uniqueStorage()._pullTiming = newValue}
  }
  /// Returns true if `pullTiming` has been explicitly set.
  public var hasPullTiming: Bool {return _storage._pullTiming != nil}
  /// Clears the value of `pullTiming`. Subsequent reads from it will return its default value.
  public mutating func clearPullTiming() {_uniqueStorage()._pullTiming = nil}

  /// Time limit for executing this build step. If not defined, the step has no
  /// time limit and will be allowed to continue to run until either it completes
  /// or the build itself times out.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// Output only. Status of the build step. At this time, build step status is
  /// only updated on build completion; step status is not updated in real-time
  /// as the build progresses.
  public var status: Google_Devtools_Cloudbuild_V1_Build.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Volume describes a Docker container volume which is mounted into build steps
/// in order to persist files across build step execution.
public struct Google_Devtools_Cloudbuild_V1_Volume {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the volume to mount.
  ///
  /// Volume names must be unique per build step and must be valid names for
  /// Docker volumes. Each named volume must be used by at least two build steps.
  public var name: String = String()

  /// Path at which to mount the volume.
  ///
  /// Paths must be absolute and cannot conflict with other volume paths on the
  /// same build step or with certain reserved volume paths.
  public var path: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Artifacts created by the build pipeline.
public struct Google_Devtools_Cloudbuild_V1_Results {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Container images that were built as a part of the build.
  public var images: [Google_Devtools_Cloudbuild_V1_BuiltImage] = []

  /// List of build step digests, in the order corresponding to build step
  /// indices.
  public var buildStepImages: [String] = []

  /// Path to the artifact manifest. Only populated when artifacts are uploaded.
  public var artifactManifest: String = String()

  /// Number of artifacts uploaded. Only populated when artifacts are uploaded.
  public var numArtifacts: Int64 = 0

  /// List of build step outputs, produced by builder images, in the order
  /// corresponding to build step indices.
  ///
  /// [Cloud Builders](https://cloud.google.com/cloud-build/docs/cloud-builders)
  /// can produce this output by writing to `$BUILDER_OUTPUT/output`.
  /// Only the first 4KB of data is stored.
  public var buildStepOutputs: [Data] = []

  /// Time to push all non-container artifacts.
  public var artifactTiming: Google_Devtools_Cloudbuild_V1_TimeSpan {
    get {return _artifactTiming ?? Google_Devtools_Cloudbuild_V1_TimeSpan()}
    set {_artifactTiming = newValue}
  }
  /// Returns true if `artifactTiming` has been explicitly set.
  public var hasArtifactTiming: Bool {return self._artifactTiming != nil}
  /// Clears the value of `artifactTiming`. Subsequent reads from it will return its default value.
  public mutating func clearArtifactTiming() {self._artifactTiming = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _artifactTiming: Google_Devtools_Cloudbuild_V1_TimeSpan? = nil
}

/// An artifact that was uploaded during a build. This
/// is a single record in the artifact manifest JSON file.
public struct Google_Devtools_Cloudbuild_V1_ArtifactResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The path of an artifact in a Google Cloud Storage bucket, with the
  /// generation number. For example,
  /// `gs://mybucket/path/to/output.jar#generation`.
  public var location: String = String()

  /// The file hash of the artifact.
  public var fileHash: [Google_Devtools_Cloudbuild_V1_FileHashes] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A build resource in the Cloud Build API.
///
/// At a high level, a `Build` describes where to find source code, how to build
/// it (for example, the builder image to run on the source), and where to store
/// the built artifacts.
///
/// Fields can include the following variables, which will be expanded when the
/// build is created:
///
/// - $PROJECT_ID: the project ID of the build.
/// - $BUILD_ID: the autogenerated ID of the build.
/// - $REPO_NAME: the source repository name specified by RepoSource.
/// - $BRANCH_NAME: the branch name specified by RepoSource.
/// - $TAG_NAME: the tag name specified by RepoSource.
/// - $REVISION_ID or $COMMIT_SHA: the commit SHA specified by RepoSource or
///   resolved from the specified branch or tag.
/// - $SHORT_SHA: first 7 characters of $REVISION_ID or $COMMIT_SHA.
public struct Google_Devtools_Cloudbuild_V1_Build {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The 'Build' name with format:
  /// `projects/{project}/locations/{location}/builds/{build}`, where {build}
  /// is a unique identifier generated by the service.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Output only. Unique identifier of the build.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Output only. ID of the project.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// Output only. Status of the build.
  public var status: Google_Devtools_Cloudbuild_V1_Build.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Output only. Customer-readable message about the current status.
  public var statusDetail: String {
    get {return _storage._statusDetail}
    set {_uniqueStorage()._statusDetail = newValue}
  }

  /// The location of the source files to build.
  public var source: Google_Devtools_Cloudbuild_V1_Source {
    get {return _storage._source ?? Google_Devtools_Cloudbuild_V1_Source()}
    set {_uniqueStorage()._source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  public var hasSource: Bool {return _storage._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  public mutating func clearSource() {_uniqueStorage()._source = nil}

  /// Required. The operations to be performed on the workspace.
  public var steps: [Google_Devtools_Cloudbuild_V1_BuildStep] {
    get {return _storage._steps}
    set {_uniqueStorage()._steps = newValue}
  }

  /// Output only. Results of the build.
  public var results: Google_Devtools_Cloudbuild_V1_Results {
    get {return _storage._results ?? Google_Devtools_Cloudbuild_V1_Results()}
    set {_uniqueStorage()._results = newValue}
  }
  /// Returns true if `results` has been explicitly set.
  public var hasResults: Bool {return _storage._results != nil}
  /// Clears the value of `results`. Subsequent reads from it will return its default value.
  public mutating func clearResults() {_uniqueStorage()._results = nil}

  /// Output only. Time at which the request to create the build was received.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Time at which execution of the build was started.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Output only. Time at which execution of the build was finished.
  ///
  /// The difference between finish_time and start_time is the duration of the
  /// build's execution.
  public var finishTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._finishTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._finishTime = newValue}
  }
  /// Returns true if `finishTime` has been explicitly set.
  public var hasFinishTime: Bool {return _storage._finishTime != nil}
  /// Clears the value of `finishTime`. Subsequent reads from it will return its default value.
  public mutating func clearFinishTime() {_uniqueStorage()._finishTime = nil}

  /// Amount of time that this build should be allowed to run, to second
  /// granularity. If this amount of time elapses, work on the build will cease
  /// and the build status will be `TIMEOUT`.
  ///
  /// `timeout` starts ticking from `startTime`.
  ///
  /// Default time is ten minutes.
  public var timeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._timeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  public var hasTimeout: Bool {return _storage._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  public mutating func clearTimeout() {_uniqueStorage()._timeout = nil}

  /// A list of images to be pushed upon the successful completion of all build
  /// steps.
  ///
  /// The images are pushed using the builder service account's credentials.
  ///
  /// The digests of the pushed images will be stored in the `Build` resource's
  /// results field.
  ///
  /// If any of the images fail to be pushed, the build status is marked
  /// `FAILURE`.
  public var images: [String] {
    get {return _storage._images}
    set {_uniqueStorage()._images = newValue}
  }

  /// TTL in queue for this build. If provided and the build is enqueued longer
  /// than this value, the build will expire and the build status will be
  /// `EXPIRED`.
  ///
  /// The TTL starts ticking from create_time.
  public var queueTtl: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._queueTtl ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._queueTtl = newValue}
  }
  /// Returns true if `queueTtl` has been explicitly set.
  public var hasQueueTtl: Bool {return _storage._queueTtl != nil}
  /// Clears the value of `queueTtl`. Subsequent reads from it will return its default value.
  public mutating func clearQueueTtl() {_uniqueStorage()._queueTtl = nil}

  /// Artifacts produced by the build that should be uploaded upon
  /// successful completion of all build steps.
  public var artifacts: Google_Devtools_Cloudbuild_V1_Artifacts {
    get {return _storage._artifacts ?? Google_Devtools_Cloudbuild_V1_Artifacts()}
    set {_uniqueStorage()._artifacts = newValue}
  }
  /// Returns true if `artifacts` has been explicitly set.
  public var hasArtifacts: Bool {return _storage._artifacts != nil}
  /// Clears the value of `artifacts`. Subsequent reads from it will return its default value.
  public mutating func clearArtifacts() {_uniqueStorage()._artifacts = nil}

  /// Google Cloud Storage bucket where logs should be written (see
  /// [Bucket Name
  /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
  /// Logs file names will be of the format `${logs_bucket}/log-${build_id}.txt`.
  public var logsBucket: String {
    get {return _storage._logsBucket}
    set {_uniqueStorage()._logsBucket = newValue}
  }

  /// Output only. A permanent fixed identifier for source.
  public var sourceProvenance: Google_Devtools_Cloudbuild_V1_SourceProvenance {
    get {return _storage._sourceProvenance ?? Google_Devtools_Cloudbuild_V1_SourceProvenance()}
    set {_uniqueStorage()._sourceProvenance = newValue}
  }
  /// Returns true if `sourceProvenance` has been explicitly set.
  public var hasSourceProvenance: Bool {return _storage._sourceProvenance != nil}
  /// Clears the value of `sourceProvenance`. Subsequent reads from it will return its default value.
  public mutating func clearSourceProvenance() {_uniqueStorage()._sourceProvenance = nil}

  /// Output only. The ID of the `BuildTrigger` that triggered this build, if it
  /// was triggered automatically.
  public var buildTriggerID: String {
    get {return _storage._buildTriggerID}
    set {_uniqueStorage()._buildTriggerID = newValue}
  }

  /// Special options for this build.
  public var options: Google_Devtools_Cloudbuild_V1_BuildOptions {
    get {return _storage._options ?? Google_Devtools_Cloudbuild_V1_BuildOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {_uniqueStorage()._options = nil}

  /// Output only. URL to logs for this build in Google Cloud Console.
  public var logURL: String {
    get {return _storage._logURL}
    set {_uniqueStorage()._logURL = newValue}
  }

  /// Substitutions data for `Build` resource.
  public var substitutions: Dictionary<String,String> {
    get {return _storage._substitutions}
    set {_uniqueStorage()._substitutions = newValue}
  }

  /// Tags for annotation of a `Build`. These are not docker tags.
  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// Secrets to decrypt using Cloud Key Management Service.
  public var secrets: [Google_Devtools_Cloudbuild_V1_Secret] {
    get {return _storage._secrets}
    set {_uniqueStorage()._secrets = newValue}
  }

  /// Output only. Stores timing information for phases of the build. Valid keys
  /// are:
  ///
  /// * BUILD: time to execute all build steps
  /// * PUSH: time to push all specified images.
  /// * FETCHSOURCE: time to fetch source.
  ///
  /// If the build does not specify source or images,
  /// these keys will not be included.
  public var timing: Dictionary<String,Google_Devtools_Cloudbuild_V1_TimeSpan> {
    get {return _storage._timing}
    set {_uniqueStorage()._timing = newValue}
  }

  /// IAM service account whose credentials will be used at build runtime.
  /// Must be of the format `projects/{PROJECT_ID}/serviceAccounts/{ACCOUNT}`.
  /// ACCOUNT can be email address or uniqueId of the service account.
  ///
  /// This field is in alpha and is not publicly available.
  public var serviceAccount: String {
    get {return _storage._serviceAccount}
    set {_uniqueStorage()._serviceAccount = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible status of a build or build step.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status of the build is unknown.
    case unknown // = 0

    /// Build or step is queued; work has not yet begun.
    case queued // = 1

    /// Build or step is being executed.
    case working // = 2

    /// Build or step finished successfully.
    case success // = 3

    /// Build or step failed to complete successfully.
    case failure // = 4

    /// Build or step failed due to an internal cause.
    case internalError // = 5

    /// Build or step took longer than was allowed.
    case timeout // = 6

    /// Build or step was canceled by a user.
    case cancelled // = 7

    /// Build was enqueued for longer than the value of `queue_ttl`.
    case expired // = 9
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .queued
      case 2: self = .working
      case 3: self = .success
      case 4: self = .failure
      case 5: self = .internalError
      case 6: self = .timeout
      case 7: self = .cancelled
      case 9: self = .expired
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .queued: return 1
      case .working: return 2
      case .success: return 3
      case .failure: return 4
      case .internalError: return 5
      case .timeout: return 6
      case .cancelled: return 7
      case .expired: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Devtools_Cloudbuild_V1_Build.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_Build.Status] = [
    .unknown,
    .queued,
    .working,
    .success,
    .failure,
    .internalError,
    .timeout,
    .cancelled,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// Artifacts produced by a build that should be uploaded upon
/// successful completion of all build steps.
public struct Google_Devtools_Cloudbuild_V1_Artifacts {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of images to be pushed upon the successful completion of all build
  /// steps.
  ///
  /// The images will be pushed using the builder service account's credentials.
  ///
  /// The digests of the pushed images will be stored in the Build resource's
  /// results field.
  ///
  /// If any of the images fail to be pushed, the build is marked FAILURE.
  public var images: [String] = []

  /// A list of objects to be uploaded to Cloud Storage upon successful
  /// completion of all build steps.
  ///
  /// Files in the workspace matching specified paths globs will be uploaded to
  /// the specified Cloud Storage location using the builder service account's
  /// credentials.
  ///
  /// The location and generation of the uploaded objects will be stored in the
  /// Build resource's results field.
  ///
  /// If any objects fail to be pushed, the build is marked FAILURE.
  public var objects: Google_Devtools_Cloudbuild_V1_Artifacts.ArtifactObjects {
    get {return _objects ?? Google_Devtools_Cloudbuild_V1_Artifacts.ArtifactObjects()}
    set {_objects = newValue}
  }
  /// Returns true if `objects` has been explicitly set.
  public var hasObjects: Bool {return self._objects != nil}
  /// Clears the value of `objects`. Subsequent reads from it will return its default value.
  public mutating func clearObjects() {self._objects = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Files in the workspace to upload to Cloud Storage upon successful
  /// completion of all build steps.
  public struct ArtifactObjects {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Cloud Storage bucket and optional object path, in the form
    /// "gs://bucket/path/to/somewhere/". (see [Bucket Name
    /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
    ///
    /// Files in the workspace matching any path pattern will be uploaded to
    /// Cloud Storage with this location as a prefix.
    public var location: String = String()

    /// Path globs used to match files in the build's workspace.
    public var paths: [String] = []

    /// Output only. Stores timing information for pushing all artifact objects.
    public var timing: Google_Devtools_Cloudbuild_V1_TimeSpan {
      get {return _timing ?? Google_Devtools_Cloudbuild_V1_TimeSpan()}
      set {_timing = newValue}
    }
    /// Returns true if `timing` has been explicitly set.
    public var hasTiming: Bool {return self._timing != nil}
    /// Clears the value of `timing`. Subsequent reads from it will return its default value.
    public mutating func clearTiming() {self._timing = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _timing: Google_Devtools_Cloudbuild_V1_TimeSpan? = nil
  }

  public init() {}

  fileprivate var _objects: Google_Devtools_Cloudbuild_V1_Artifacts.ArtifactObjects? = nil
}

/// Start and end times for a build execution phase.
public struct Google_Devtools_Cloudbuild_V1_TimeSpan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start of time span.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// End of time span.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata for build operations.
public struct Google_Devtools_Cloudbuild_V1_BuildOperationMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The build that the operation is tracking.
  public var build: Google_Devtools_Cloudbuild_V1_Build {
    get {return _build ?? Google_Devtools_Cloudbuild_V1_Build()}
    set {_build = newValue}
  }
  /// Returns true if `build` has been explicitly set.
  public var hasBuild: Bool {return self._build != nil}
  /// Clears the value of `build`. Subsequent reads from it will return its default value.
  public mutating func clearBuild() {self._build = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _build: Google_Devtools_Cloudbuild_V1_Build? = nil
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
public struct Google_Devtools_Cloudbuild_V1_SourceProvenance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A copy of the build's `source.storage_source`, if exists, with any
  /// generations resolved.
  public var resolvedStorageSource: Google_Devtools_Cloudbuild_V1_StorageSource {
    get {return _resolvedStorageSource ?? Google_Devtools_Cloudbuild_V1_StorageSource()}
    set {_resolvedStorageSource = newValue}
  }
  /// Returns true if `resolvedStorageSource` has been explicitly set.
  public var hasResolvedStorageSource: Bool {return self._resolvedStorageSource != nil}
  /// Clears the value of `resolvedStorageSource`. Subsequent reads from it will return its default value.
  public mutating func clearResolvedStorageSource() {self._resolvedStorageSource = nil}

  /// A copy of the build's `source.repo_source`, if exists, with any
  /// revisions resolved.
  public var resolvedRepoSource: Google_Devtools_Cloudbuild_V1_RepoSource {
    get {return _resolvedRepoSource ?? Google_Devtools_Cloudbuild_V1_RepoSource()}
    set {_resolvedRepoSource = newValue}
  }
  /// Returns true if `resolvedRepoSource` has been explicitly set.
  public var hasResolvedRepoSource: Bool {return self._resolvedRepoSource != nil}
  /// Clears the value of `resolvedRepoSource`. Subsequent reads from it will return its default value.
  public mutating func clearResolvedRepoSource() {self._resolvedRepoSource = nil}

  /// Output only. Hash(es) of the build source, which can be used to verify that
  /// the original source integrity was maintained in the build. Note that
  /// `FileHashes` will only be populated if `BuildOptions` has requested a
  /// `SourceProvenanceHash`.
  ///
  /// The keys to this map are file paths used as build source and the values
  /// contain the hash values for those files.
  ///
  /// If the build source came in a single package such as a gzipped tarfile
  /// (`.tar.gz`), the `FileHash` will be for the single path to that file.
  public var fileHashes: Dictionary<String,Google_Devtools_Cloudbuild_V1_FileHashes> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _resolvedStorageSource: Google_Devtools_Cloudbuild_V1_StorageSource? = nil
  fileprivate var _resolvedRepoSource: Google_Devtools_Cloudbuild_V1_RepoSource? = nil
}

/// Container message for hashes of byte content of files, used in
/// SourceProvenance messages to verify integrity of source input to the build.
public struct Google_Devtools_Cloudbuild_V1_FileHashes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Collection of file hashes.
  public var fileHash: [Google_Devtools_Cloudbuild_V1_Hash] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Container message for hash values.
public struct Google_Devtools_Cloudbuild_V1_Hash {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of hash that was performed.
  public var type: Google_Devtools_Cloudbuild_V1_Hash.HashType = .none

  /// The hash value.
  public var value: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the hash algorithm, if any.
  public enum HashType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No hash requested.
    case none // = 0

    /// Use a sha256 hash.
    case sha256 // = 1

    /// Use a md5 hash.
    case md5 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .none
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .sha256
      case 2: self = .md5
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .none: return 0
      case .sha256: return 1
      case .md5: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Devtools_Cloudbuild_V1_Hash.HashType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_Hash.HashType] = [
    .none,
    .sha256,
    .md5,
  ]
}

#endif  // swift(>=4.2)

/// Pairs a set of secret environment variables containing encrypted
/// values with the Cloud KMS key to use to decrypt the value.
public struct Google_Devtools_Cloudbuild_V1_Secret {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Cloud KMS key name to use to decrypt these envs.
  public var kmsKeyName: String = String()

  /// Map of environment variable name to its encrypted value.
  ///
  /// Secret environment variables must be unique across all of a build's
  /// secrets, and must be used by at least one build step. Values can be at most
  /// 64 KB in size. There can be at most 100 secret values across all of a
  /// build's secrets.
  public var secretEnv: Dictionary<String,Data> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create a new build.
public struct Google_Devtools_Cloudbuild_V1_CreateBuildRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent resource where this build will be created.
  /// Format: `projects/{project}/locations/{location}`
  public var parent: String = String()

  /// Required. ID of the project.
  public var projectID: String = String()

  /// Required. Build resource to create.
  public var build: Google_Devtools_Cloudbuild_V1_Build {
    get {return _build ?? Google_Devtools_Cloudbuild_V1_Build()}
    set {_build = newValue}
  }
  /// Returns true if `build` has been explicitly set.
  public var hasBuild: Bool {return self._build != nil}
  /// Clears the value of `build`. Subsequent reads from it will return its default value.
  public mutating func clearBuild() {self._build = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _build: Google_Devtools_Cloudbuild_V1_Build? = nil
}

/// Request to get a build.
public struct Google_Devtools_Cloudbuild_V1_GetBuildRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the `Build` to retrieve.
  /// Format: `projects/{project}/locations/{location}/builds/{build}`
  public var name: String = String()

  /// Required. ID of the project.
  public var projectID: String = String()

  /// Required. ID of the build.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list builds.
public struct Google_Devtools_Cloudbuild_V1_ListBuildsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent of the collection of `Builds`.
  /// Format: `projects/{project}/locations/location`
  public var parent: String = String()

  /// Required. ID of the project.
  public var projectID: String = String()

  /// Number of results to return in the list.
  public var pageSize: Int32 = 0

  /// Token to provide to skip to a particular spot in the list.
  public var pageToken: String = String()

  /// The raw filter text to constrain the results.
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response including listed builds.
public struct Google_Devtools_Cloudbuild_V1_ListBuildsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Builds will be sorted by `create_time`, descending.
  public var builds: [Google_Devtools_Cloudbuild_V1_Build] = []

  /// Token to receive the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to cancel an ongoing build.
public struct Google_Devtools_Cloudbuild_V1_CancelBuildRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the `Build` to retrieve.
  /// Format: `projects/{project}/locations/{location}/builds/{build}`
  public var name: String = String()

  /// Required. ID of the project.
  public var projectID: String = String()

  /// Required. ID of the build.
  public var id: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for an automated build in response to source repository
/// changes.
public struct Google_Devtools_Cloudbuild_V1_BuildTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. Unique identifier of the trigger.
  public var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// Human-readable description of this trigger.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// User-assigned name of the trigger. Must be unique within the project.
  /// Trigger names must meet the following requirements:
  ///
  /// + They must contain only alphanumeric characters and dashes.
  /// + They can be 1-64 characters long.
  /// + They must begin and end with an alphanumeric character.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Tags for annotation of a `BuildTrigger`
  public var tags: [String] {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  /// Template describing the types of source changes to trigger a build.
  ///
  /// Branch and tag names in trigger templates are interpreted as regular
  /// expressions. Any branch or tag change that matches that regular expression
  /// will trigger a build.
  ///
  /// Mutually exclusive with `github`.
  public var triggerTemplate: Google_Devtools_Cloudbuild_V1_RepoSource {
    get {return _storage._triggerTemplate ?? Google_Devtools_Cloudbuild_V1_RepoSource()}
    set {_uniqueStorage()._triggerTemplate = newValue}
  }
  /// Returns true if `triggerTemplate` has been explicitly set.
  public var hasTriggerTemplate: Bool {return _storage._triggerTemplate != nil}
  /// Clears the value of `triggerTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearTriggerTemplate() {_uniqueStorage()._triggerTemplate = nil}

  /// GitHubEventsConfig describes the configuration of a trigger that creates
  /// a build whenever a GitHub event is received.
  ///
  /// Mutually exclusive with `trigger_template`.
  public var github: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig {
    get {return _storage._github ?? Google_Devtools_Cloudbuild_V1_GitHubEventsConfig()}
    set {_uniqueStorage()._github = newValue}
  }
  /// Returns true if `github` has been explicitly set.
  public var hasGithub: Bool {return _storage._github != nil}
  /// Clears the value of `github`. Subsequent reads from it will return its default value.
  public mutating func clearGithub() {_uniqueStorage()._github = nil}

  /// Template describing the Build request to make when the trigger is matched.
  public var buildTemplate: OneOf_BuildTemplate? {
    get {return _storage._buildTemplate}
    set {_uniqueStorage()._buildTemplate = newValue}
  }

  /// Contents of the build template.
  public var build: Google_Devtools_Cloudbuild_V1_Build {
    get {
      if case .build(let v)? = _storage._buildTemplate {return v}
      return Google_Devtools_Cloudbuild_V1_Build()
    }
    set {_uniqueStorage()._buildTemplate = .build(newValue)}
  }

  /// Path, from the source root, to a file whose contents is used for the
  /// template.
  public var filename: String {
    get {
      if case .filename(let v)? = _storage._buildTemplate {return v}
      return String()
    }
    set {_uniqueStorage()._buildTemplate = .filename(newValue)}
  }

  /// Output only. Time when the trigger was created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// If true, the trigger will never automatically execute a build.
  public var disabled: Bool {
    get {return _storage._disabled}
    set {_uniqueStorage()._disabled = newValue}
  }

  /// Substitutions for Build resource. The keys must match the following
  /// regular expression: `^_[A-Z0-9_]+$`.
  public var substitutions: Dictionary<String,String> {
    get {return _storage._substitutions}
    set {_uniqueStorage()._substitutions = newValue}
  }

  /// ignored_files and included_files are file glob matches using
  /// https://golang.org/pkg/path/filepath/#Match extended with support for "**".
  ///
  /// If ignored_files and changed files are both empty, then they are
  /// not used to determine whether or not to trigger a build.
  ///
  /// If ignored_files is not empty, then we ignore any files that match
  /// any of the ignored_file globs. If the change has no files that are
  /// outside of the ignored_files globs, then we do not trigger a build.
  public var ignoredFiles: [String] {
    get {return _storage._ignoredFiles}
    set {_uniqueStorage()._ignoredFiles = newValue}
  }

  /// If any of the files altered in the commit pass the ignored_files
  /// filter and included_files is empty, then as far as this filter is
  /// concerned, we should trigger the build.
  ///
  /// If any of the files altered in the commit pass the ignored_files
  /// filter and included_files is not empty, then we make sure that at
  /// least one of those files matches a included_files glob. If not,
  /// then we do not trigger a build.
  public var includedFiles: [String] {
    get {return _storage._includedFiles}
    set {_uniqueStorage()._includedFiles = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Template describing the Build request to make when the trigger is matched.
  public enum OneOf_BuildTemplate: Equatable {
    /// Contents of the build template.
    case build(Google_Devtools_Cloudbuild_V1_Build)
    /// Path, from the source root, to a file whose contents is used for the
    /// template.
    case filename(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Cloudbuild_V1_BuildTrigger.OneOf_BuildTemplate, rhs: Google_Devtools_Cloudbuild_V1_BuildTrigger.OneOf_BuildTemplate) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.build, .build): return {
        guard case .build(let l) = lhs, case .build(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filename, .filename): return {
        guard case .filename(let l) = lhs, case .filename(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// GitHubEventsConfig describes the configuration of a trigger that creates a
/// build whenever a GitHub event is received.
///
/// This message is experimental.
public struct Google_Devtools_Cloudbuild_V1_GitHubEventsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The installationID that emits the GitHub event.
  public var installationID: Int64 = 0

  /// Owner of the repository. For example: The owner for
  /// https://github.com/googlecloudplatform/cloud-builders is
  /// "googlecloudplatform".
  public var owner: String = String()

  /// Name of the repository. For example: The name for
  /// https://github.com/googlecloudplatform/cloud-builders is "cloud-builders".
  public var name: String = String()

  /// Filter describing the types of events to trigger a build.
  /// Currently supported event types: push, pull_request.
  public var event: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig.OneOf_Event? = nil

  /// filter to match changes in pull requests.
  public var pullRequest: Google_Devtools_Cloudbuild_V1_PullRequestFilter {
    get {
      if case .pullRequest(let v)? = event {return v}
      return Google_Devtools_Cloudbuild_V1_PullRequestFilter()
    }
    set {event = .pullRequest(newValue)}
  }

  /// filter to match changes in refs like branches, tags.
  public var push: Google_Devtools_Cloudbuild_V1_PushFilter {
    get {
      if case .push(let v)? = event {return v}
      return Google_Devtools_Cloudbuild_V1_PushFilter()
    }
    set {event = .push(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Filter describing the types of events to trigger a build.
  /// Currently supported event types: push, pull_request.
  public enum OneOf_Event: Equatable {
    /// filter to match changes in pull requests.
    case pullRequest(Google_Devtools_Cloudbuild_V1_PullRequestFilter)
    /// filter to match changes in refs like branches, tags.
    case push(Google_Devtools_Cloudbuild_V1_PushFilter)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig.OneOf_Event, rhs: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.pullRequest, .pullRequest): return {
        guard case .pullRequest(let l) = lhs, case .pullRequest(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.push, .push): return {
        guard case .push(let l) = lhs, case .push(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// PullRequestFilter contains filter properties for matching GitHub Pull
/// Requests.
public struct Google_Devtools_Cloudbuild_V1_PullRequestFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Target refs to match.
  /// A target ref is the git reference where the pull request will be applied.
  public var gitRef: Google_Devtools_Cloudbuild_V1_PullRequestFilter.OneOf_GitRef? = nil

  /// Regex of branches to match.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  public var branch: String {
    get {
      if case .branch(let v)? = gitRef {return v}
      return String()
    }
    set {gitRef = .branch(newValue)}
  }

  /// Configure builds to run whether a repository owner or collaborator need to
  /// comment `/gcbrun`.
  public var commentControl: Google_Devtools_Cloudbuild_V1_PullRequestFilter.CommentControl = .commentsDisabled

  /// If true, branches that do NOT match the git_ref will trigger a build.
  public var invertRegex: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Target refs to match.
  /// A target ref is the git reference where the pull request will be applied.
  public enum OneOf_GitRef: Equatable {
    /// Regex of branches to match.
    ///
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    case branch(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Cloudbuild_V1_PullRequestFilter.OneOf_GitRef, rhs: Google_Devtools_Cloudbuild_V1_PullRequestFilter.OneOf_GitRef) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.branch, .branch): return {
        guard case .branch(let l) = lhs, case .branch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Controls behavior of Pull Request comments.
  public enum CommentControl: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Do not require comments on Pull Requests before builds are triggered.
    case commentsDisabled // = 0

    /// Enforce that repository owners or collaborators must comment on Pull
    /// Requests before builds are triggered.
    case commentsEnabled // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .commentsDisabled
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .commentsDisabled
      case 1: self = .commentsEnabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .commentsDisabled: return 0
      case .commentsEnabled: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Devtools_Cloudbuild_V1_PullRequestFilter.CommentControl: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_PullRequestFilter.CommentControl] = [
    .commentsDisabled,
    .commentsEnabled,
  ]
}

#endif  // swift(>=4.2)

/// Push contains filter properties for matching GitHub git pushes.
public struct Google_Devtools_Cloudbuild_V1_PushFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Modified refs to match.
  /// A modified refs are the refs modified by a git push operation.
  public var gitRef: Google_Devtools_Cloudbuild_V1_PushFilter.OneOf_GitRef? = nil

  /// Regexes matching branches to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  public var branch: String {
    get {
      if case .branch(let v)? = gitRef {return v}
      return String()
    }
    set {gitRef = .branch(newValue)}
  }

  /// Regexes matching tags to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  public var tag: String {
    get {
      if case .tag(let v)? = gitRef {return v}
      return String()
    }
    set {gitRef = .tag(newValue)}
  }

  /// When true, only trigger a build if the revision regex does NOT match the
  /// git_ref regex.
  public var invertRegex: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Modified refs to match.
  /// A modified refs are the refs modified by a git push operation.
  public enum OneOf_GitRef: Equatable {
    /// Regexes matching branches to build.
    ///
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    case branch(String)
    /// Regexes matching tags to build.
    ///
    /// The syntax of the regular expressions accepted is the syntax accepted by
    /// RE2 and described at https://github.com/google/re2/wiki/Syntax
    case tag(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Devtools_Cloudbuild_V1_PushFilter.OneOf_GitRef, rhs: Google_Devtools_Cloudbuild_V1_PushFilter.OneOf_GitRef) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.branch, .branch): return {
        guard case .branch(let l) = lhs, case .branch(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tag, .tag): return {
        guard case .tag(let l) = lhs, case .tag(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Request to create a new `BuildTrigger`.
public struct Google_Devtools_Cloudbuild_V1_CreateBuildTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the project for which to configure automatic builds.
  public var projectID: String = String()

  /// Required. `BuildTrigger` to create.
  public var trigger: Google_Devtools_Cloudbuild_V1_BuildTrigger {
    get {return _trigger ?? Google_Devtools_Cloudbuild_V1_BuildTrigger()}
    set {_trigger = newValue}
  }
  /// Returns true if `trigger` has been explicitly set.
  public var hasTrigger: Bool {return self._trigger != nil}
  /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
  public mutating func clearTrigger() {self._trigger = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trigger: Google_Devtools_Cloudbuild_V1_BuildTrigger? = nil
}

/// Returns the `BuildTrigger` with the specified ID.
public struct Google_Devtools_Cloudbuild_V1_GetBuildTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the project that owns the trigger.
  public var projectID: String = String()

  /// Required. Identifier (`id` or `name`) of the `BuildTrigger` to get.
  public var triggerID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to list existing `BuildTriggers`.
public struct Google_Devtools_Cloudbuild_V1_ListBuildTriggersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the project for which to list BuildTriggers.
  public var projectID: String = String()

  /// Number of results to return in the list.
  public var pageSize: Int32 = 0

  /// Token to provide to skip to a particular spot in the list.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response containing existing `BuildTriggers`.
public struct Google_Devtools_Cloudbuild_V1_ListBuildTriggersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `BuildTriggers` for the project, sorted by `create_time` descending.
  public var triggers: [Google_Devtools_Cloudbuild_V1_BuildTrigger] = []

  /// Token to receive the next page of results.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to delete a `BuildTrigger`.
public struct Google_Devtools_Cloudbuild_V1_DeleteBuildTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the project that owns the trigger.
  public var projectID: String = String()

  /// Required. ID of the `BuildTrigger` to delete.
  public var triggerID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to update an existing `BuildTrigger`.
public struct Google_Devtools_Cloudbuild_V1_UpdateBuildTriggerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. ID of the project that owns the trigger.
  public var projectID: String = String()

  /// Required. ID of the `BuildTrigger` to update.
  public var triggerID: String = String()

  /// Required. `BuildTrigger` to update.
  public var trigger: Google_Devtools_Cloudbuild_V1_BuildTrigger {
    get {return _trigger ?? Google_Devtools_Cloudbuild_V1_BuildTrigger()}
    set {_trigger = newValue}
  }
  /// Returns true if `trigger` has been explicitly set.
  public var hasTrigger: Bool {return self._trigger != nil}
  /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
  public mutating func clearTrigger() {self._trigger = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _trigger: Google_Devtools_Cloudbuild_V1_BuildTrigger? = nil
}

/// Optional arguments to enable specific features of builds.
public struct Google_Devtools_Cloudbuild_V1_BuildOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Requested hash for SourceProvenance.
  public var sourceProvenanceHash: [Google_Devtools_Cloudbuild_V1_Hash.HashType] = []

  /// Requested verifiability options.
  public var requestedVerifyOption: Google_Devtools_Cloudbuild_V1_BuildOptions.VerifyOption = .notVerified

  /// Compute Engine machine type on which to run the build.
  public var machineType: Google_Devtools_Cloudbuild_V1_BuildOptions.MachineType = .unspecified

  /// Requested disk size for the VM that runs the build. Note that this is *NOT*
  /// "disk free"; some of the space will be used by the operating system and
  /// build utilities. Also note that this is the minimum disk size that will be
  /// allocated for the build -- the build may run with a larger disk than
  /// requested. At present, the maximum disk size is 1000GB; builds that request
  /// more than the maximum are rejected with an error.
  public var diskSizeGb: Int64 = 0

  /// Option to specify behavior when there is an error in the substitution
  /// checks.
  ///
  /// NOTE: this is always set to ALLOW_LOOSE for triggered builds and cannot
  /// be overridden in the build configuration file.
  public var substitutionOption: Google_Devtools_Cloudbuild_V1_BuildOptions.SubstitutionOption = .mustMatch

  /// Option to specify whether or not to apply bash style string
  /// operations to the substitutions.
  ///
  /// NOTE: this is always enabled for triggered builds and cannot be
  /// overridden in the build configuration file.
  public var dynamicSubstitutions: Bool = false

  /// Option to define build log streaming behavior to Google Cloud
  /// Storage.
  public var logStreamingOption: Google_Devtools_Cloudbuild_V1_BuildOptions.LogStreamingOption = .streamDefault

  /// Option to specify a `WorkerPool` for the build.
  /// Format: projects/{project}/locations/{location}/workerPools/{workerPool}
  ///
  /// This field is experimental.
  public var workerPool: String = String()

  /// Option to specify the logging mode, which determines if and where build
  /// logs are stored.
  public var logging: Google_Devtools_Cloudbuild_V1_BuildOptions.LoggingMode = .loggingUnspecified

  /// A list of global environment variable definitions that will exist for all
  /// build steps in this build. If a variable is defined in both globally and in
  /// a build step, the variable will use the build step value.
  ///
  /// The elements are of the form "KEY=VALUE" for the environment variable "KEY"
  /// being given the value "VALUE".
  public var env: [String] = []

  /// A list of global environment variables, which are encrypted using a Cloud
  /// Key Management Service crypto key. These values must be specified in the
  /// build's `Secret`. These variables will be available to all build steps
  /// in this build.
  public var secretEnv: [String] = []

  /// Global list of volumes to mount for ALL build steps
  ///
  /// Each volume is created as an empty volume prior to starting the build
  /// process. Upon completion of the build, volumes and their contents are
  /// discarded. Global volume names and paths cannot conflict with the volumes
  /// defined a build step.
  ///
  /// Using a global volume in a build with only one step is not valid as
  /// it is indicative of a build request with an incorrect configuration.
  public var volumes: [Google_Devtools_Cloudbuild_V1_Volume] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Specifies the manner in which the build should be verified, if at all.
  public enum VerifyOption: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not a verifiable build. (default)
    case notVerified // = 0

    /// Verified build.
    case verified // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .notVerified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notVerified
      case 1: self = .verified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .notVerified: return 0
      case .verified: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Supported Compute Engine machine types.
  /// For more information, see [Machine
  /// types](https://cloud.google.com/compute/docs/machine-types).
  public enum MachineType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Standard machine type.
    case unspecified // = 0

    /// Highcpu machine with 8 CPUs.
    case n1Highcpu8 // = 1

    /// Highcpu machine with 32 CPUs.
    case n1Highcpu32 // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .n1Highcpu8
      case 2: self = .n1Highcpu32
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .n1Highcpu8: return 1
      case .n1Highcpu32: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies the behavior when there is an error in the substitution checks.
  public enum SubstitutionOption: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Fails the build if error in substitutions checks, like missing
    /// a substitution in the template or in the map.
    case mustMatch // = 0

    /// Do not fail the build if error in substitutions checks.
    case allowLoose // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .mustMatch
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .mustMatch
      case 1: self = .allowLoose
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .mustMatch: return 0
      case .allowLoose: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies the behavior when writing build logs to Google Cloud Storage.
  public enum LogStreamingOption: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Service may automatically determine build log streaming behavior.
    case streamDefault // = 0

    /// Build logs should be streamed to Google Cloud Storage.
    case streamOn // = 1

    /// Build logs should not be streamed to Google Cloud Storage; they will be
    /// written when the build is completed.
    case streamOff // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .streamDefault
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .streamDefault
      case 1: self = .streamOn
      case 2: self = .streamOff
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .streamDefault: return 0
      case .streamOn: return 1
      case .streamOff: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Specifies the logging mode.
  public enum LoggingMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The service determines the logging mode. The default is `LEGACY`. Do not
    /// rely on the default logging behavior as it may change in the future.
    case loggingUnspecified // = 0

    /// Cloud Logging and Cloud Storage logging are enabled.
    case legacy // = 1

    /// Only Cloud Storage logging is enabled.
    case gcsOnly // = 2

    /// This option is the same as CLOUD_LOGGING_ONLY.
    case stackdriverOnly // = 3

    /// Only Cloud Logging is enabled. Note that logs for both the Cloud Console
    /// UI and Cloud SDK are based on Cloud Storage logs, so neither will provide
    /// logs if this option is chosen.
    case cloudLoggingOnly // = 5

    /// Turn off all logging. No build logs will be captured.
    /// Next ID: 6
    case none // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .loggingUnspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .loggingUnspecified
      case 1: self = .legacy
      case 2: self = .gcsOnly
      case 3: self = .stackdriverOnly
      case 4: self = .none
      case 5: self = .cloudLoggingOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .loggingUnspecified: return 0
      case .legacy: return 1
      case .gcsOnly: return 2
      case .stackdriverOnly: return 3
      case .none: return 4
      case .cloudLoggingOnly: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Devtools_Cloudbuild_V1_BuildOptions.VerifyOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_BuildOptions.VerifyOption] = [
    .notVerified,
    .verified,
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.MachineType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_BuildOptions.MachineType] = [
    .unspecified,
    .n1Highcpu8,
    .n1Highcpu32,
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.SubstitutionOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_BuildOptions.SubstitutionOption] = [
    .mustMatch,
    .allowLoose,
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.LogStreamingOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_BuildOptions.LogStreamingOption] = [
    .streamDefault,
    .streamOn,
    .streamOff,
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.LoggingMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_BuildOptions.LoggingMode] = [
    .loggingUnspecified,
    .legacy,
    .gcsOnly,
    .stackdriverOnly,
    .cloudLoggingOnly,
    .none,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for a WorkerPool to run the builds.
///
/// Workers are machines that Cloud Build uses to run your builds. By default,
/// all workers run in a project owned by Cloud Build. To have full control over
/// the workers that execute your builds -- such as enabling them to access
/// private resources on your private network -- you can request Cloud Build to
/// run the workers in your own project by creating a custom workers pool.
public struct Google_Devtools_Cloudbuild_V1_WorkerPool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User-defined name of the `WorkerPool`.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The project ID of the GCP project for which the `WorkerPool` is created.
  public var projectID: String {
    get {return _storage._projectID}
    set {_uniqueStorage()._projectID = newValue}
  }

  /// Output only. The service account used to manage the `WorkerPool`. The
  /// service account must have the Compute Instance Admin (Beta) permission at
  /// the project level.
  public var serviceAccountEmail: String {
    get {return _storage._serviceAccountEmail}
    set {_uniqueStorage()._serviceAccountEmail = newValue}
  }

  /// Total number of workers to be created across all requested regions.
  public var workerCount: Int64 {
    get {return _storage._workerCount}
    set {_uniqueStorage()._workerCount = newValue}
  }

  /// Configuration to be used for a creating workers in the `WorkerPool`.
  public var workerConfig: Google_Devtools_Cloudbuild_V1_WorkerConfig {
    get {return _storage._workerConfig ?? Google_Devtools_Cloudbuild_V1_WorkerConfig()}
    set {_uniqueStorage()._workerConfig = newValue}
  }
  /// Returns true if `workerConfig` has been explicitly set.
  public var hasWorkerConfig: Bool {return _storage._workerConfig != nil}
  /// Clears the value of `workerConfig`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerConfig() {_uniqueStorage()._workerConfig = nil}

  /// List of regions to create the `WorkerPool`. Regions can't be empty.
  /// If Cloud Build adds a new GCP region in the future, the existing
  /// `WorkerPool` will not be enabled in the new region automatically;
  /// you must add the new region to the `regions` field to enable the
  /// `WorkerPool` in that region.
  public var regions: [Google_Devtools_Cloudbuild_V1_WorkerPool.Region] {
    get {return _storage._regions}
    set {_uniqueStorage()._regions = newValue}
  }

  /// Output only. Time at which the request to create the `WorkerPool` was
  /// received.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Output only. Time at which the request to update the `WorkerPool` was
  /// received.
  public var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  public var hasUpdateTime: Bool {return _storage._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateTime() {_uniqueStorage()._updateTime = nil}

  /// Output only. Time at which the request to delete the `WorkerPool` was
  /// received.
  public var deleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deleteTime = newValue}
  }
  /// Returns true if `deleteTime` has been explicitly set.
  public var hasDeleteTime: Bool {return _storage._deleteTime != nil}
  /// Clears the value of `deleteTime`. Subsequent reads from it will return its default value.
  public mutating func clearDeleteTime() {_uniqueStorage()._deleteTime = nil}

  /// Output only. WorkerPool Status.
  public var status: Google_Devtools_Cloudbuild_V1_WorkerPool.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Supported GCP regions to create the `WorkerPool`.
  public enum Region: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// no region
    case unspecified // = 0

    /// us-central1 region
    case usCentral1 // = 1

    /// us-west1 region
    case usWest1 // = 2

    /// us-east1 region
    case usEast1 // = 3

    /// us-east4 region
    case usEast4 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .usCentral1
      case 2: self = .usWest1
      case 3: self = .usEast1
      case 4: self = .usEast4
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .usCentral1: return 1
      case .usWest1: return 2
      case .usEast1: return 3
      case .usEast4: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// `WorkerPool` status
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Status of the `WorkerPool` is unknown.
    case unspecified // = 0

    /// `WorkerPool` is being created.
    case creating // = 1

    /// `WorkerPool` is running.
    case running // = 2

    /// `WorkerPool` is being deleted: cancelling builds and draining workers.
    case deleting // = 3

    /// `WorkerPool` is deleted.
    case deleted // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .running
      case 3: self = .deleting
      case 4: self = .deleted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .running: return 2
      case .deleting: return 3
      case .deleted: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Devtools_Cloudbuild_V1_WorkerPool.Region: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_WorkerPool.Region] = [
    .unspecified,
    .usCentral1,
    .usWest1,
    .usEast1,
    .usEast4,
  ]
}

extension Google_Devtools_Cloudbuild_V1_WorkerPool.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Devtools_Cloudbuild_V1_WorkerPool.Status] = [
    .unspecified,
    .creating,
    .running,
    .deleting,
    .deleted,
  ]
}

#endif  // swift(>=4.2)

/// WorkerConfig defines the configuration to be used for a creating workers in
/// the pool.
public struct Google_Devtools_Cloudbuild_V1_WorkerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Machine Type of the worker, such as n1-standard-1.
  /// See https://cloud.google.com/compute/docs/machine-types.
  /// If left blank, Cloud Build will use a standard unspecified machine to
  /// create the worker pool.
  /// `machine_type` is overridden if you specify a different machine type in
  /// `build_options`. In this case, the VM specified in the `build_options`
  /// will be created on demand at build time. For more information see
  /// https://cloud.google.com/cloud-build/docs/speeding-up-builds#using_custom_virtual_machine_sizes
  public var machineType: String = String()

  /// Size of the disk attached to the worker, in GB.
  /// See https://cloud.google.com/compute/docs/disks/
  /// If `0` is specified, Cloud Build will use a standard disk size.
  /// `disk_size` is overridden if you specify a different disk size in
  /// `build_options`. In this case, a VM with a disk size specified in the
  /// `build_options` will be created on demand at build time. For more
  /// information see
  /// https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.builds#buildoptions
  public var diskSizeGb: Int64 = 0

  /// The network definition used to create the worker.
  /// If this section is left empty, the workers will be created in
  /// WorkerPool.project_id on the default network.
  public var network: Google_Devtools_Cloudbuild_V1_Network {
    get {return _network ?? Google_Devtools_Cloudbuild_V1_Network()}
    set {_network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  public var hasNetwork: Bool {return self._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  public mutating func clearNetwork() {self._network = nil}

  /// The tag applied to the worker, and the same tag used by the firewall rule.
  /// It is used to identify the Cloud Build workers among other VMs.
  /// The default value for tag is `worker`.
  public var tag: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _network: Google_Devtools_Cloudbuild_V1_Network? = nil
}

/// Network describes the GCP network used to create workers in.
public struct Google_Devtools_Cloudbuild_V1_Network {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Project id containing the defined network and subnetwork. For a peered VPC,
  /// this will be the same as the project_id in which the workers are created.
  /// For a shared VPC, this will be the project sharing the network with the
  /// project_id project in which workers will be created. For custom workers
  /// with no VPC, this will be the same as project_id.
  public var projectID: String = String()

  /// Network on which the workers are created.
  /// "default" network is used if empty.
  public var network: String = String()

  /// Subnetwork on which the workers are created.
  /// "default" subnetwork is used if empty.
  public var subnetwork: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to create a new `WorkerPool`.
public struct Google_Devtools_Cloudbuild_V1_CreateWorkerPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the parent project.
  public var parent: String = String()

  /// `WorkerPool` resource to create.
  public var workerPool: Google_Devtools_Cloudbuild_V1_WorkerPool {
    get {return _workerPool ?? Google_Devtools_Cloudbuild_V1_WorkerPool()}
    set {_workerPool = newValue}
  }
  /// Returns true if `workerPool` has been explicitly set.
  public var hasWorkerPool: Bool {return self._workerPool != nil}
  /// Clears the value of `workerPool`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerPool() {self._workerPool = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workerPool: Google_Devtools_Cloudbuild_V1_WorkerPool? = nil
}

/// Request to get a `WorkerPool` with the specified name.
public struct Google_Devtools_Cloudbuild_V1_GetWorkerPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The field will contain name of the resource requested, for example:
  /// "projects/project-1/workerPools/workerpool-name"
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to delete a `WorkerPool`.
public struct Google_Devtools_Cloudbuild_V1_DeleteWorkerPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The field will contain name of the resource requested, for example:
  /// "projects/project-1/workerPools/workerpool-name"
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Request to update a `WorkerPool`.
public struct Google_Devtools_Cloudbuild_V1_UpdateWorkerPoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The field will contain name of the resource requested, for example:
  /// "projects/project-1/workerPools/workerpool-name"
  public var name: String = String()

  /// `WorkerPool` resource to update.
  public var workerPool: Google_Devtools_Cloudbuild_V1_WorkerPool {
    get {return _workerPool ?? Google_Devtools_Cloudbuild_V1_WorkerPool()}
    set {_workerPool = newValue}
  }
  /// Returns true if `workerPool` has been explicitly set.
  public var hasWorkerPool: Bool {return self._workerPool != nil}
  /// Clears the value of `workerPool`. Subsequent reads from it will return its default value.
  public mutating func clearWorkerPool() {self._workerPool = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _workerPool: Google_Devtools_Cloudbuild_V1_WorkerPool? = nil
}

/// Request to list `WorkerPools`.
public struct Google_Devtools_Cloudbuild_V1_ListWorkerPoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the parent project.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Response containing existing `WorkerPools`.
public struct Google_Devtools_Cloudbuild_V1_ListWorkerPoolsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `WorkerPools` for the project.
  public var workerPools: [Google_Devtools_Cloudbuild_V1_WorkerPool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.devtools.cloudbuild.v1"

extension Google_Devtools_Cloudbuild_V1_RetryBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RetryBuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "name"),
    1: .standard(proto: "project_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_RetryBuildRequest, rhs: Google_Devtools_Cloudbuild_V1_RetryBuildRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_RunBuildTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RunBuildTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "trigger_id"),
    3: .same(proto: "source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.triggerID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._source) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.triggerID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerID, fieldNumber: 2)
    }
    if let v = self._source {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_RunBuildTriggerRequest, rhs: Google_Devtools_Cloudbuild_V1_RunBuildTriggerRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.triggerID != rhs.triggerID {return false}
    if lhs._source != rhs._source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_StorageSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StorageSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bucket"),
    2: .same(proto: "object"),
    3: .same(proto: "generation"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bucket) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.object) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.generation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bucket.isEmpty {
      try visitor.visitSingularStringField(value: self.bucket, fieldNumber: 1)
    }
    if !self.object.isEmpty {
      try visitor.visitSingularStringField(value: self.object, fieldNumber: 2)
    }
    if self.generation != 0 {
      try visitor.visitSingularInt64Field(value: self.generation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_StorageSource, rhs: Google_Devtools_Cloudbuild_V1_StorageSource) -> Bool {
    if lhs.bucket != rhs.bucket {return false}
    if lhs.object != rhs.object {return false}
    if lhs.generation != rhs.generation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_RepoSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RepoSource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "repo_name"),
    3: .standard(proto: "branch_name"),
    4: .standard(proto: "tag_name"),
    5: .standard(proto: "commit_sha"),
    7: .same(proto: "dir"),
    8: .standard(proto: "invert_regex"),
    9: .same(proto: "substitutions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.repoName) }()
      case 3: try {
        if self.revision != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.revision = .branchName(v)}
      }()
      case 4: try {
        if self.revision != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.revision = .tagName(v)}
      }()
      case 5: try {
        if self.revision != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.revision = .commitSha(v)}
      }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.dir) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.invertRegex) }()
      case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.substitutions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.repoName.isEmpty {
      try visitor.visitSingularStringField(value: self.repoName, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.revision {
    case .branchName?: try {
      guard case .branchName(let v)? = self.revision else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .tagName?: try {
      guard case .tagName(let v)? = self.revision else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .commitSha?: try {
      guard case .commitSha(let v)? = self.revision else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.dir.isEmpty {
      try visitor.visitSingularStringField(value: self.dir, fieldNumber: 7)
    }
    if self.invertRegex != false {
      try visitor.visitSingularBoolField(value: self.invertRegex, fieldNumber: 8)
    }
    if !self.substitutions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.substitutions, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_RepoSource, rhs: Google_Devtools_Cloudbuild_V1_RepoSource) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.repoName != rhs.repoName {return false}
    if lhs.revision != rhs.revision {return false}
    if lhs.dir != rhs.dir {return false}
    if lhs.invertRegex != rhs.invertRegex {return false}
    if lhs.substitutions != rhs.substitutions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Source: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Source"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "storage_source"),
    3: .standard(proto: "repo_source"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Devtools_Cloudbuild_V1_StorageSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .storageSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .storageSource(v)}
      }()
      case 3: try {
        var v: Google_Devtools_Cloudbuild_V1_RepoSource?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .repoSource(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .repoSource(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.source {
    case .storageSource?: try {
      guard case .storageSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .repoSource?: try {
      guard case .repoSource(let v)? = self.source else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Source, rhs: Google_Devtools_Cloudbuild_V1_Source) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_BuiltImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuiltImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    3: .same(proto: "digest"),
    4: .standard(proto: "push_timing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.digest) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._pushTiming) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.digest.isEmpty {
      try visitor.visitSingularStringField(value: self.digest, fieldNumber: 3)
    }
    if let v = self._pushTiming {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_BuiltImage, rhs: Google_Devtools_Cloudbuild_V1_BuiltImage) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.digest != rhs.digest {return false}
    if lhs._pushTiming != rhs._pushTiming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_BuildStep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildStep"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "env"),
    3: .same(proto: "args"),
    4: .same(proto: "dir"),
    5: .same(proto: "id"),
    6: .standard(proto: "wait_for"),
    7: .same(proto: "entrypoint"),
    8: .standard(proto: "secret_env"),
    9: .same(proto: "volumes"),
    10: .same(proto: "timing"),
    13: .standard(proto: "pull_timing"),
    11: .same(proto: "timeout"),
    12: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _env: [String] = []
    var _args: [String] = []
    var _dir: String = String()
    var _id: String = String()
    var _waitFor: [String] = []
    var _entrypoint: String = String()
    var _secretEnv: [String] = []
    var _volumes: [Google_Devtools_Cloudbuild_V1_Volume] = []
    var _timing: Google_Devtools_Cloudbuild_V1_TimeSpan? = nil
    var _pullTiming: Google_Devtools_Cloudbuild_V1_TimeSpan? = nil
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _status: Google_Devtools_Cloudbuild_V1_Build.Status = .unknown

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _env = source._env
      _args = source._args
      _dir = source._dir
      _id = source._id
      _waitFor = source._waitFor
      _entrypoint = source._entrypoint
      _secretEnv = source._secretEnv
      _volumes = source._volumes
      _timing = source._timing
      _pullTiming = source._pullTiming
      _timeout = source._timeout
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._env) }()
        case 3: try { try decoder.decodeRepeatedStringField(value: &_storage._args) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._dir) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._waitFor) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._entrypoint) }()
        case 8: try { try decoder.decodeRepeatedStringField(value: &_storage._secretEnv) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._volumes) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._timing) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._pullTiming) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._env.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._env, fieldNumber: 2)
      }
      if !_storage._args.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._args, fieldNumber: 3)
      }
      if !_storage._dir.isEmpty {
        try visitor.visitSingularStringField(value: _storage._dir, fieldNumber: 4)
      }
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 5)
      }
      if !_storage._waitFor.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._waitFor, fieldNumber: 6)
      }
      if !_storage._entrypoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entrypoint, fieldNumber: 7)
      }
      if !_storage._secretEnv.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._secretEnv, fieldNumber: 8)
      }
      if !_storage._volumes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._volumes, fieldNumber: 9)
      }
      if let v = _storage._timing {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if _storage._status != .unknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 12)
      }
      if let v = _storage._pullTiming {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_BuildStep, rhs: Google_Devtools_Cloudbuild_V1_BuildStep) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._env != rhs_storage._env {return false}
        if _storage._args != rhs_storage._args {return false}
        if _storage._dir != rhs_storage._dir {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._waitFor != rhs_storage._waitFor {return false}
        if _storage._entrypoint != rhs_storage._entrypoint {return false}
        if _storage._secretEnv != rhs_storage._secretEnv {return false}
        if _storage._volumes != rhs_storage._volumes {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._pullTiming != rhs_storage._pullTiming {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Volume: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Volume"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "path"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Volume, rhs: Google_Devtools_Cloudbuild_V1_Volume) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Results: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Results"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "images"),
    3: .standard(proto: "build_step_images"),
    4: .standard(proto: "artifact_manifest"),
    5: .standard(proto: "num_artifacts"),
    6: .standard(proto: "build_step_outputs"),
    7: .standard(proto: "artifact_timing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.buildStepImages) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.artifactManifest) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.numArtifacts) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.buildStepOutputs) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._artifactTiming) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 2)
    }
    if !self.buildStepImages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildStepImages, fieldNumber: 3)
    }
    if !self.artifactManifest.isEmpty {
      try visitor.visitSingularStringField(value: self.artifactManifest, fieldNumber: 4)
    }
    if self.numArtifacts != 0 {
      try visitor.visitSingularInt64Field(value: self.numArtifacts, fieldNumber: 5)
    }
    if !self.buildStepOutputs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.buildStepOutputs, fieldNumber: 6)
    }
    if let v = self._artifactTiming {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Results, rhs: Google_Devtools_Cloudbuild_V1_Results) -> Bool {
    if lhs.images != rhs.images {return false}
    if lhs.buildStepImages != rhs.buildStepImages {return false}
    if lhs.artifactManifest != rhs.artifactManifest {return false}
    if lhs.numArtifacts != rhs.numArtifacts {return false}
    if lhs.buildStepOutputs != rhs.buildStepOutputs {return false}
    if lhs._artifactTiming != rhs._artifactTiming {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ArtifactResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ArtifactResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .standard(proto: "file_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fileHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.fileHash.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ArtifactResult, rhs: Google_Devtools_Cloudbuild_V1_ArtifactResult) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.fileHash != rhs.fileHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Build: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Build"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    45: .same(proto: "name"),
    1: .same(proto: "id"),
    16: .standard(proto: "project_id"),
    2: .same(proto: "status"),
    24: .standard(proto: "status_detail"),
    3: .same(proto: "source"),
    11: .same(proto: "steps"),
    10: .same(proto: "results"),
    6: .standard(proto: "create_time"),
    7: .standard(proto: "start_time"),
    8: .standard(proto: "finish_time"),
    12: .same(proto: "timeout"),
    13: .same(proto: "images"),
    40: .standard(proto: "queue_ttl"),
    37: .same(proto: "artifacts"),
    19: .standard(proto: "logs_bucket"),
    21: .standard(proto: "source_provenance"),
    22: .standard(proto: "build_trigger_id"),
    23: .same(proto: "options"),
    25: .standard(proto: "log_url"),
    29: .same(proto: "substitutions"),
    31: .same(proto: "tags"),
    32: .same(proto: "secrets"),
    33: .same(proto: "timing"),
    42: .standard(proto: "service_account"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _id: String = String()
    var _projectID: String = String()
    var _status: Google_Devtools_Cloudbuild_V1_Build.Status = .unknown
    var _statusDetail: String = String()
    var _source: Google_Devtools_Cloudbuild_V1_Source? = nil
    var _steps: [Google_Devtools_Cloudbuild_V1_BuildStep] = []
    var _results: Google_Devtools_Cloudbuild_V1_Results? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _finishTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _timeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _images: [String] = []
    var _queueTtl: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _artifacts: Google_Devtools_Cloudbuild_V1_Artifacts? = nil
    var _logsBucket: String = String()
    var _sourceProvenance: Google_Devtools_Cloudbuild_V1_SourceProvenance? = nil
    var _buildTriggerID: String = String()
    var _options: Google_Devtools_Cloudbuild_V1_BuildOptions? = nil
    var _logURL: String = String()
    var _substitutions: Dictionary<String,String> = [:]
    var _tags: [String] = []
    var _secrets: [Google_Devtools_Cloudbuild_V1_Secret] = []
    var _timing: Dictionary<String,Google_Devtools_Cloudbuild_V1_TimeSpan> = [:]
    var _serviceAccount: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _id = source._id
      _projectID = source._projectID
      _status = source._status
      _statusDetail = source._statusDetail
      _source = source._source
      _steps = source._steps
      _results = source._results
      _createTime = source._createTime
      _startTime = source._startTime
      _finishTime = source._finishTime
      _timeout = source._timeout
      _images = source._images
      _queueTtl = source._queueTtl
      _artifacts = source._artifacts
      _logsBucket = source._logsBucket
      _sourceProvenance = source._sourceProvenance
      _buildTriggerID = source._buildTriggerID
      _options = source._options
      _logURL = source._logURL
      _substitutions = source._substitutions
      _tags = source._tags
      _secrets = source._secrets
      _timing = source._timing
      _serviceAccount = source._serviceAccount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._source) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._finishTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._results) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._steps) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._timeout) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._images) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._logsBucket) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._sourceProvenance) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._buildTriggerID) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._options) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._statusDetail) }()
        case 25: try { try decoder.decodeSingularStringField(value: &_storage._logURL) }()
        case 29: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._substitutions) }()
        case 31: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 32: try { try decoder.decodeRepeatedMessageField(value: &_storage._secrets) }()
        case 33: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Devtools_Cloudbuild_V1_TimeSpan>.self, value: &_storage._timing) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._artifacts) }()
        case 40: try { try decoder.decodeSingularMessageField(value: &_storage._queueTtl) }()
        case 42: try { try decoder.decodeSingularStringField(value: &_storage._serviceAccount) }()
        case 45: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._status != .unknown {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 2)
      }
      if let v = _storage._source {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._finishTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if let v = _storage._results {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._steps.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._steps, fieldNumber: 11)
      }
      if let v = _storage._timeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if !_storage._images.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._images, fieldNumber: 13)
      }
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 16)
      }
      if !_storage._logsBucket.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logsBucket, fieldNumber: 19)
      }
      if let v = _storage._sourceProvenance {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if !_storage._buildTriggerID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._buildTriggerID, fieldNumber: 22)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if !_storage._statusDetail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusDetail, fieldNumber: 24)
      }
      if !_storage._logURL.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logURL, fieldNumber: 25)
      }
      if !_storage._substitutions.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._substitutions, fieldNumber: 29)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 31)
      }
      if !_storage._secrets.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._secrets, fieldNumber: 32)
      }
      if !_storage._timing.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Devtools_Cloudbuild_V1_TimeSpan>.self, value: _storage._timing, fieldNumber: 33)
      }
      if let v = _storage._artifacts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }
      if let v = _storage._queueTtl {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }
      if !_storage._serviceAccount.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serviceAccount, fieldNumber: 42)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 45)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Build, rhs: Google_Devtools_Cloudbuild_V1_Build) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._id != rhs_storage._id {return false}
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusDetail != rhs_storage._statusDetail {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._steps != rhs_storage._steps {return false}
        if _storage._results != rhs_storage._results {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._finishTime != rhs_storage._finishTime {return false}
        if _storage._timeout != rhs_storage._timeout {return false}
        if _storage._images != rhs_storage._images {return false}
        if _storage._queueTtl != rhs_storage._queueTtl {return false}
        if _storage._artifacts != rhs_storage._artifacts {return false}
        if _storage._logsBucket != rhs_storage._logsBucket {return false}
        if _storage._sourceProvenance != rhs_storage._sourceProvenance {return false}
        if _storage._buildTriggerID != rhs_storage._buildTriggerID {return false}
        if _storage._options != rhs_storage._options {return false}
        if _storage._logURL != rhs_storage._logURL {return false}
        if _storage._substitutions != rhs_storage._substitutions {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._secrets != rhs_storage._secrets {return false}
        if _storage._timing != rhs_storage._timing {return false}
        if _storage._serviceAccount != rhs_storage._serviceAccount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Build.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNKNOWN"),
    1: .same(proto: "QUEUED"),
    2: .same(proto: "WORKING"),
    3: .same(proto: "SUCCESS"),
    4: .same(proto: "FAILURE"),
    5: .same(proto: "INTERNAL_ERROR"),
    6: .same(proto: "TIMEOUT"),
    7: .same(proto: "CANCELLED"),
    9: .same(proto: "EXPIRED"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_Artifacts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Artifacts"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "images"),
    2: .same(proto: "objects"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.images) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._objects) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.images.isEmpty {
      try visitor.visitRepeatedStringField(value: self.images, fieldNumber: 1)
    }
    if let v = self._objects {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Artifacts, rhs: Google_Devtools_Cloudbuild_V1_Artifacts) -> Bool {
    if lhs.images != rhs.images {return false}
    if lhs._objects != rhs._objects {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Artifacts.ArtifactObjects: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Devtools_Cloudbuild_V1_Artifacts.protoMessageName + ".ArtifactObjects"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "paths"),
    3: .same(proto: "timing"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.paths) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if !self.paths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.paths, fieldNumber: 2)
    }
    if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Artifacts.ArtifactObjects, rhs: Google_Devtools_Cloudbuild_V1_Artifacts.ArtifactObjects) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.paths != rhs.paths {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_TimeSpan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeSpan"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_TimeSpan, rhs: Google_Devtools_Cloudbuild_V1_TimeSpan) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_BuildOperationMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildOperationMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "build"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._build) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._build {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_BuildOperationMetadata, rhs: Google_Devtools_Cloudbuild_V1_BuildOperationMetadata) -> Bool {
    if lhs._build != rhs._build {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_SourceProvenance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SourceProvenance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "resolved_storage_source"),
    6: .standard(proto: "resolved_repo_source"),
    4: .standard(proto: "file_hashes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._resolvedStorageSource) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Devtools_Cloudbuild_V1_FileHashes>.self, value: &self.fileHashes) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._resolvedRepoSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._resolvedStorageSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.fileHashes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Devtools_Cloudbuild_V1_FileHashes>.self, value: self.fileHashes, fieldNumber: 4)
    }
    if let v = self._resolvedRepoSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_SourceProvenance, rhs: Google_Devtools_Cloudbuild_V1_SourceProvenance) -> Bool {
    if lhs._resolvedStorageSource != rhs._resolvedStorageSource {return false}
    if lhs._resolvedRepoSource != rhs._resolvedRepoSource {return false}
    if lhs.fileHashes != rhs.fileHashes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_FileHashes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FileHashes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "file_hash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fileHash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileHash.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fileHash, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_FileHashes, rhs: Google_Devtools_Cloudbuild_V1_FileHashes) -> Bool {
    if lhs.fileHash != rhs.fileHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Hash: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Hash"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .none {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Hash, rhs: Google_Devtools_Cloudbuild_V1_Hash) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Hash.HashType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "SHA256"),
    2: .same(proto: "MD5"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_Secret: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Secret"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "kms_key_name"),
    3: .standard(proto: "secret_env"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.kmsKeyName) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.secretEnv) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.kmsKeyName.isEmpty {
      try visitor.visitSingularStringField(value: self.kmsKeyName, fieldNumber: 1)
    }
    if !self.secretEnv.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.secretEnv, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Secret, rhs: Google_Devtools_Cloudbuild_V1_Secret) -> Bool {
    if lhs.kmsKeyName != rhs.kmsKeyName {return false}
    if lhs.secretEnv != rhs.secretEnv {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_CreateBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateBuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "parent"),
    1: .standard(proto: "project_id"),
    2: .same(proto: "build"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._build) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if let v = self._build {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_CreateBuildRequest, rhs: Google_Devtools_Cloudbuild_V1_CreateBuildRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs._build != rhs._build {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_GetBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "name"),
    1: .standard(proto: "project_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_GetBuildRequest, rhs: Google_Devtools_Cloudbuild_V1_GetBuildRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ListBuildsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBuildsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    9: .same(proto: "parent"),
    1: .standard(proto: "project_id"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    8: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 8)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ListBuildsRequest, rhs: Google_Devtools_Cloudbuild_V1_ListBuildsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ListBuildsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBuildsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "builds"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.builds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.builds.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.builds, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ListBuildsResponse, rhs: Google_Devtools_Cloudbuild_V1_ListBuildsResponse) -> Bool {
    if lhs.builds != rhs.builds {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_CancelBuildRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelBuildRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .same(proto: "name"),
    1: .standard(proto: "project_id"),
    2: .same(proto: "id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_CancelBuildRequest, rhs: Google_Devtools_Cloudbuild_V1_CancelBuildRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.projectID != rhs.projectID {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_BuildTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildTrigger"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    10: .same(proto: "description"),
    21: .same(proto: "name"),
    19: .same(proto: "tags"),
    7: .standard(proto: "trigger_template"),
    13: .same(proto: "github"),
    4: .same(proto: "build"),
    8: .same(proto: "filename"),
    5: .standard(proto: "create_time"),
    9: .same(proto: "disabled"),
    11: .same(proto: "substitutions"),
    15: .standard(proto: "ignored_files"),
    16: .standard(proto: "included_files"),
  ]

  fileprivate class _StorageClass {
    var _id: String = String()
    var _description_p: String = String()
    var _name: String = String()
    var _tags: [String] = []
    var _triggerTemplate: Google_Devtools_Cloudbuild_V1_RepoSource? = nil
    var _github: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig? = nil
    var _buildTemplate: Google_Devtools_Cloudbuild_V1_BuildTrigger.OneOf_BuildTemplate?
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _disabled: Bool = false
    var _substitutions: Dictionary<String,String> = [:]
    var _ignoredFiles: [String] = []
    var _includedFiles: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _description_p = source._description_p
      _name = source._name
      _tags = source._tags
      _triggerTemplate = source._triggerTemplate
      _github = source._github
      _buildTemplate = source._buildTemplate
      _createTime = source._createTime
      _disabled = source._disabled
      _substitutions = source._substitutions
      _ignoredFiles = source._ignoredFiles
      _includedFiles = source._includedFiles
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 4: try {
          var v: Google_Devtools_Cloudbuild_V1_Build?
          if let current = _storage._buildTemplate {
            try decoder.handleConflictingOneOf()
            if case .build(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._buildTemplate = .build(v)}
        }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._triggerTemplate) }()
        case 8: try {
          if _storage._buildTemplate != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._buildTemplate = .filename(v)}
        }()
        case 9: try { try decoder.decodeSingularBoolField(value: &_storage._disabled) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._substitutions) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._github) }()
        case 15: try { try decoder.decodeRepeatedStringField(value: &_storage._ignoredFiles) }()
        case 16: try { try decoder.decodeRepeatedStringField(value: &_storage._includedFiles) }()
        case 19: try { try decoder.decodeRepeatedStringField(value: &_storage._tags) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if case .build(let v)? = _storage._buildTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._triggerTemplate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if case .filename(let v)? = _storage._buildTemplate {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if _storage._disabled != false {
        try visitor.visitSingularBoolField(value: _storage._disabled, fieldNumber: 9)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 10)
      }
      if !_storage._substitutions.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._substitutions, fieldNumber: 11)
      }
      if let v = _storage._github {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if !_storage._ignoredFiles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._ignoredFiles, fieldNumber: 15)
      }
      if !_storage._includedFiles.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._includedFiles, fieldNumber: 16)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._tags, fieldNumber: 19)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_BuildTrigger, rhs: Google_Devtools_Cloudbuild_V1_BuildTrigger) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._tags != rhs_storage._tags {return false}
        if _storage._triggerTemplate != rhs_storage._triggerTemplate {return false}
        if _storage._github != rhs_storage._github {return false}
        if _storage._buildTemplate != rhs_storage._buildTemplate {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._disabled != rhs_storage._disabled {return false}
        if _storage._substitutions != rhs_storage._substitutions {return false}
        if _storage._ignoredFiles != rhs_storage._ignoredFiles {return false}
        if _storage._includedFiles != rhs_storage._includedFiles {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_GitHubEventsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GitHubEventsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installation_id"),
    6: .same(proto: "owner"),
    7: .same(proto: "name"),
    4: .standard(proto: "pull_request"),
    5: .same(proto: "push"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.installationID) }()
      case 4: try {
        var v: Google_Devtools_Cloudbuild_V1_PullRequestFilter?
        if let current = self.event {
          try decoder.handleConflictingOneOf()
          if case .pullRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.event = .pullRequest(v)}
      }()
      case 5: try {
        var v: Google_Devtools_Cloudbuild_V1_PushFilter?
        if let current = self.event {
          try decoder.handleConflictingOneOf()
          if case .push(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.event = .push(v)}
      }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.installationID != 0 {
      try visitor.visitSingularInt64Field(value: self.installationID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .pullRequest?: try {
      guard case .pullRequest(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .push?: try {
      guard case .push(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig, rhs: Google_Devtools_Cloudbuild_V1_GitHubEventsConfig) -> Bool {
    if lhs.installationID != rhs.installationID {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.name != rhs.name {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_PullRequestFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PullRequestFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "branch"),
    5: .standard(proto: "comment_control"),
    6: .standard(proto: "invert_regex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        if self.gitRef != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.gitRef = .branch(v)}
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.commentControl) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.invertRegex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .branch(let v)? = self.gitRef {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if self.commentControl != .commentsDisabled {
      try visitor.visitSingularEnumField(value: self.commentControl, fieldNumber: 5)
    }
    if self.invertRegex != false {
      try visitor.visitSingularBoolField(value: self.invertRegex, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_PullRequestFilter, rhs: Google_Devtools_Cloudbuild_V1_PullRequestFilter) -> Bool {
    if lhs.gitRef != rhs.gitRef {return false}
    if lhs.commentControl != rhs.commentControl {return false}
    if lhs.invertRegex != rhs.invertRegex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_PullRequestFilter.CommentControl: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMENTS_DISABLED"),
    1: .same(proto: "COMMENTS_ENABLED"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_PushFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PushFilter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "branch"),
    3: .same(proto: "tag"),
    4: .standard(proto: "invert_regex"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        if self.gitRef != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.gitRef = .branch(v)}
      }()
      case 3: try {
        if self.gitRef != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.gitRef = .tag(v)}
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.invertRegex) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.gitRef {
    case .branch?: try {
      guard case .branch(let v)? = self.gitRef else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .tag?: try {
      guard case .tag(let v)? = self.gitRef else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.invertRegex != false {
      try visitor.visitSingularBoolField(value: self.invertRegex, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_PushFilter, rhs: Google_Devtools_Cloudbuild_V1_PushFilter) -> Bool {
    if lhs.gitRef != rhs.gitRef {return false}
    if lhs.invertRegex != rhs.invertRegex {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_CreateBuildTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateBuildTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "trigger"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_CreateBuildTriggerRequest, rhs: Google_Devtools_Cloudbuild_V1_CreateBuildTriggerRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_GetBuildTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBuildTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "trigger_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.triggerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.triggerID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_GetBuildTriggerRequest, rhs: Google_Devtools_Cloudbuild_V1_GetBuildTriggerRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.triggerID != rhs.triggerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ListBuildTriggersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBuildTriggersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ListBuildTriggersRequest, rhs: Google_Devtools_Cloudbuild_V1_ListBuildTriggersRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ListBuildTriggersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBuildTriggersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "triggers"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.triggers) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.triggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.triggers, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ListBuildTriggersResponse, rhs: Google_Devtools_Cloudbuild_V1_ListBuildTriggersResponse) -> Bool {
    if lhs.triggers != rhs.triggers {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_DeleteBuildTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteBuildTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "trigger_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.triggerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.triggerID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_DeleteBuildTriggerRequest, rhs: Google_Devtools_Cloudbuild_V1_DeleteBuildTriggerRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.triggerID != rhs.triggerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_UpdateBuildTriggerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBuildTriggerRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .standard(proto: "trigger_id"),
    3: .same(proto: "trigger"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.triggerID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.triggerID.isEmpty {
      try visitor.visitSingularStringField(value: self.triggerID, fieldNumber: 2)
    }
    if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_UpdateBuildTriggerRequest, rhs: Google_Devtools_Cloudbuild_V1_UpdateBuildTriggerRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.triggerID != rhs.triggerID {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BuildOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_provenance_hash"),
    2: .standard(proto: "requested_verify_option"),
    3: .standard(proto: "machine_type"),
    6: .standard(proto: "disk_size_gb"),
    4: .standard(proto: "substitution_option"),
    17: .standard(proto: "dynamic_substitutions"),
    5: .standard(proto: "log_streaming_option"),
    7: .standard(proto: "worker_pool"),
    11: .same(proto: "logging"),
    12: .same(proto: "env"),
    13: .standard(proto: "secret_env"),
    14: .same(proto: "volumes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.sourceProvenanceHash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.requestedVerifyOption) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.machineType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.substitutionOption) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.logStreamingOption) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.diskSizeGb) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.workerPool) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.logging) }()
      case 12: try { try decoder.decodeRepeatedStringField(value: &self.env) }()
      case 13: try { try decoder.decodeRepeatedStringField(value: &self.secretEnv) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.volumes) }()
      case 17: try { try decoder.decodeSingularBoolField(value: &self.dynamicSubstitutions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceProvenanceHash.isEmpty {
      try visitor.visitPackedEnumField(value: self.sourceProvenanceHash, fieldNumber: 1)
    }
    if self.requestedVerifyOption != .notVerified {
      try visitor.visitSingularEnumField(value: self.requestedVerifyOption, fieldNumber: 2)
    }
    if self.machineType != .unspecified {
      try visitor.visitSingularEnumField(value: self.machineType, fieldNumber: 3)
    }
    if self.substitutionOption != .mustMatch {
      try visitor.visitSingularEnumField(value: self.substitutionOption, fieldNumber: 4)
    }
    if self.logStreamingOption != .streamDefault {
      try visitor.visitSingularEnumField(value: self.logStreamingOption, fieldNumber: 5)
    }
    if self.diskSizeGb != 0 {
      try visitor.visitSingularInt64Field(value: self.diskSizeGb, fieldNumber: 6)
    }
    if !self.workerPool.isEmpty {
      try visitor.visitSingularStringField(value: self.workerPool, fieldNumber: 7)
    }
    if self.logging != .loggingUnspecified {
      try visitor.visitSingularEnumField(value: self.logging, fieldNumber: 11)
    }
    if !self.env.isEmpty {
      try visitor.visitRepeatedStringField(value: self.env, fieldNumber: 12)
    }
    if !self.secretEnv.isEmpty {
      try visitor.visitRepeatedStringField(value: self.secretEnv, fieldNumber: 13)
    }
    if !self.volumes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.volumes, fieldNumber: 14)
    }
    if self.dynamicSubstitutions != false {
      try visitor.visitSingularBoolField(value: self.dynamicSubstitutions, fieldNumber: 17)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_BuildOptions, rhs: Google_Devtools_Cloudbuild_V1_BuildOptions) -> Bool {
    if lhs.sourceProvenanceHash != rhs.sourceProvenanceHash {return false}
    if lhs.requestedVerifyOption != rhs.requestedVerifyOption {return false}
    if lhs.machineType != rhs.machineType {return false}
    if lhs.diskSizeGb != rhs.diskSizeGb {return false}
    if lhs.substitutionOption != rhs.substitutionOption {return false}
    if lhs.dynamicSubstitutions != rhs.dynamicSubstitutions {return false}
    if lhs.logStreamingOption != rhs.logStreamingOption {return false}
    if lhs.workerPool != rhs.workerPool {return false}
    if lhs.logging != rhs.logging {return false}
    if lhs.env != rhs.env {return false}
    if lhs.secretEnv != rhs.secretEnv {return false}
    if lhs.volumes != rhs.volumes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.VerifyOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_VERIFIED"),
    1: .same(proto: "VERIFIED"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.MachineType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "N1_HIGHCPU_8"),
    2: .same(proto: "N1_HIGHCPU_32"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.SubstitutionOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUST_MATCH"),
    1: .same(proto: "ALLOW_LOOSE"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.LogStreamingOption: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STREAM_DEFAULT"),
    1: .same(proto: "STREAM_ON"),
    2: .same(proto: "STREAM_OFF"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_BuildOptions.LoggingMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOGGING_UNSPECIFIED"),
    1: .same(proto: "LEGACY"),
    2: .same(proto: "GCS_ONLY"),
    3: .same(proto: "STACKDRIVER_ONLY"),
    4: .same(proto: "NONE"),
    5: .same(proto: "CLOUD_LOGGING_ONLY"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_WorkerPool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerPool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    14: .same(proto: "name"),
    2: .standard(proto: "project_id"),
    3: .standard(proto: "service_account_email"),
    4: .standard(proto: "worker_count"),
    16: .standard(proto: "worker_config"),
    9: .same(proto: "regions"),
    11: .standard(proto: "create_time"),
    17: .standard(proto: "update_time"),
    12: .standard(proto: "delete_time"),
    13: .same(proto: "status"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _projectID: String = String()
    var _serviceAccountEmail: String = String()
    var _workerCount: Int64 = 0
    var _workerConfig: Google_Devtools_Cloudbuild_V1_WorkerConfig? = nil
    var _regions: [Google_Devtools_Cloudbuild_V1_WorkerPool.Region] = []
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Google_Devtools_Cloudbuild_V1_WorkerPool.Status = .unspecified

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _projectID = source._projectID
      _serviceAccountEmail = source._serviceAccountEmail
      _workerCount = source._workerCount
      _workerConfig = source._workerConfig
      _regions = source._regions
      _createTime = source._createTime
      _updateTime = source._updateTime
      _deleteTime = source._deleteTime
      _status = source._status
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._projectID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._serviceAccountEmail) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._workerCount) }()
        case 9: try { try decoder.decodeRepeatedEnumField(value: &_storage._regions) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._deleteTime) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._workerConfig) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._updateTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._projectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._projectID, fieldNumber: 2)
      }
      if !_storage._serviceAccountEmail.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serviceAccountEmail, fieldNumber: 3)
      }
      if _storage._workerCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workerCount, fieldNumber: 4)
      }
      if !_storage._regions.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._regions, fieldNumber: 9)
      }
      if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }
      if let v = _storage._deleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 13)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 14)
      }
      if let v = _storage._workerConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._updateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_WorkerPool, rhs: Google_Devtools_Cloudbuild_V1_WorkerPool) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._projectID != rhs_storage._projectID {return false}
        if _storage._serviceAccountEmail != rhs_storage._serviceAccountEmail {return false}
        if _storage._workerCount != rhs_storage._workerCount {return false}
        if _storage._workerConfig != rhs_storage._workerConfig {return false}
        if _storage._regions != rhs_storage._regions {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._updateTime != rhs_storage._updateTime {return false}
        if _storage._deleteTime != rhs_storage._deleteTime {return false}
        if _storage._status != rhs_storage._status {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_WorkerPool.Region: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGION_UNSPECIFIED"),
    1: .same(proto: "US_CENTRAL1"),
    2: .same(proto: "US_WEST1"),
    3: .same(proto: "US_EAST1"),
    4: .same(proto: "US_EAST4"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_WorkerPool.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "DELETING"),
    4: .same(proto: "DELETED"),
  ]
}

extension Google_Devtools_Cloudbuild_V1_WorkerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "machine_type"),
    2: .standard(proto: "disk_size_gb"),
    3: .same(proto: "network"),
    4: .same(proto: "tag"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.machineType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.diskSizeGb) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._network) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.tag) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.machineType.isEmpty {
      try visitor.visitSingularStringField(value: self.machineType, fieldNumber: 1)
    }
    if self.diskSizeGb != 0 {
      try visitor.visitSingularInt64Field(value: self.diskSizeGb, fieldNumber: 2)
    }
    if let v = self._network {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.tag.isEmpty {
      try visitor.visitSingularStringField(value: self.tag, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_WorkerConfig, rhs: Google_Devtools_Cloudbuild_V1_WorkerConfig) -> Bool {
    if lhs.machineType != rhs.machineType {return false}
    if lhs.diskSizeGb != rhs.diskSizeGb {return false}
    if lhs._network != rhs._network {return false}
    if lhs.tag != rhs.tag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_Network: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Network"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "network"),
    3: .same(proto: "subnetwork"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subnetwork) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.subnetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetwork, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_Network, rhs: Google_Devtools_Cloudbuild_V1_Network) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.network != rhs.network {return false}
    if lhs.subnetwork != rhs.subnetwork {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_CreateWorkerPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkerPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "worker_pool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workerPool) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if let v = self._workerPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_CreateWorkerPoolRequest, rhs: Google_Devtools_Cloudbuild_V1_CreateWorkerPoolRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs._workerPool != rhs._workerPool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_GetWorkerPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_GetWorkerPoolRequest, rhs: Google_Devtools_Cloudbuild_V1_GetWorkerPoolRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_DeleteWorkerPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkerPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_DeleteWorkerPoolRequest, rhs: Google_Devtools_Cloudbuild_V1_DeleteWorkerPoolRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_UpdateWorkerPoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerPoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "name"),
    3: .standard(proto: "worker_pool"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workerPool) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if let v = self._workerPool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_UpdateWorkerPoolRequest, rhs: Google_Devtools_Cloudbuild_V1_UpdateWorkerPoolRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._workerPool != rhs._workerPool {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ListWorkerPoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkerPoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ListWorkerPoolsRequest, rhs: Google_Devtools_Cloudbuild_V1_ListWorkerPoolsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Devtools_Cloudbuild_V1_ListWorkerPoolsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkerPoolsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "worker_pools"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workerPools) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workerPools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerPools, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Devtools_Cloudbuild_V1_ListWorkerPoolsResponse, rhs: Google_Devtools_Cloudbuild_V1_ListWorkerPoolsResponse) -> Bool {
    if lhs.workerPools != rhs.workerPools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

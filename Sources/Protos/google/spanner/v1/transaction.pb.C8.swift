// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/spanner/v1/transaction.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// # Transactions
///
///
/// Each session can have at most one active transaction at a time. After the
/// active transaction is completed, the session can immediately be
/// re-used for the next transaction. It is not necessary to create a
/// new session for each transaction.
///
/// # Transaction Modes
///
/// Cloud Spanner supports three transaction modes:
///
///   1. Locking read-write. This type of transaction is the only way
///      to write data into Cloud Spanner. These transactions rely on
///      pessimistic locking and, if necessary, two-phase commit.
///      Locking read-write transactions may abort, requiring the
///      application to retry.
///
///   2. Snapshot read-only. This transaction type provides guaranteed
///      consistency across several reads, but does not allow
///      writes. Snapshot read-only transactions can be configured to
///      read at timestamps in the past. Snapshot read-only
///      transactions do not need to be committed.
///
///   3. Partitioned DML. This type of transaction is used to execute
///      a single Partitioned DML statement. Partitioned DML partitions
///      the key space and runs the DML statement over each partition
///      in parallel using separate, internal transactions that commit
///      independently. Partitioned DML transactions do not need to be
///      committed.
///
/// For transactions that only read, snapshot read-only transactions
/// provide simpler semantics and are almost always faster. In
/// particular, read-only transactions do not take locks, so they do
/// not conflict with read-write transactions. As a consequence of not
/// taking locks, they also do not abort, so retry loops are not needed.
///
/// Transactions may only read/write data in a single database. They
/// may, however, read/write data in different tables within that
/// database.
///
/// ## Locking Read-Write Transactions
///
/// Locking transactions may be used to atomically read-modify-write
/// data anywhere in a database. This type of transaction is externally
/// consistent.
///
/// Clients should attempt to minimize the amount of time a transaction
/// is active. Faster transactions commit with higher probability
/// and cause less contention. Cloud Spanner attempts to keep read locks
/// active as long as the transaction continues to do reads, and the
/// transaction has not been terminated by
/// [Commit][google.spanner.v1.Spanner.Commit] or
/// [Rollback][google.spanner.v1.Spanner.Rollback].  Long periods of
/// inactivity at the client may cause Cloud Spanner to release a
/// transaction's locks and abort it.
///
/// Conceptually, a read-write transaction consists of zero or more
/// reads or SQL statements followed by
/// [Commit][google.spanner.v1.Spanner.Commit]. At any time before
/// [Commit][google.spanner.v1.Spanner.Commit], the client can send a
/// [Rollback][google.spanner.v1.Spanner.Rollback] request to abort the
/// transaction.
///
/// ### Semantics
///
/// Cloud Spanner can commit the transaction if all read locks it acquired
/// are still valid at commit time, and it is able to acquire write
/// locks for all writes. Cloud Spanner can abort the transaction for any
/// reason. If a commit attempt returns `ABORTED`, Cloud Spanner guarantees
/// that the transaction has not modified any user data in Cloud Spanner.
///
/// Unless the transaction commits, Cloud Spanner makes no guarantees about
/// how long the transaction's locks were held for. It is an error to
/// use Cloud Spanner locks for any sort of mutual exclusion other than
/// between Cloud Spanner transactions themselves.
///
/// ### Retrying Aborted Transactions
///
/// When a transaction aborts, the application can choose to retry the
/// whole transaction again. To maximize the chances of successfully
/// committing the retry, the client should execute the retry in the
/// same session as the original attempt. The original session's lock
/// priority increases with each consecutive abort, meaning that each
/// attempt has a slightly better chance of success than the previous.
///
/// Under some circumstances (e.g., many transactions attempting to
/// modify the same row(s)), a transaction can abort many times in a
/// short period before successfully committing. Thus, it is not a good
/// idea to cap the number of retries a transaction can attempt;
/// instead, it is better to limit the total amount of wall time spent
/// retrying.
///
/// ### Idle Transactions
///
/// A transaction is considered idle if it has no outstanding reads or
/// SQL queries and has not started a read or SQL query within the last 10
/// seconds. Idle transactions can be aborted by Cloud Spanner so that they
/// don't hold on to locks indefinitely. In that case, the commit will
/// fail with error `ABORTED`.
///
/// If this behavior is undesirable, periodically executing a simple
/// SQL query in the transaction (e.g., `SELECT 1`) prevents the
/// transaction from becoming idle.
///
/// ## Snapshot Read-Only Transactions
///
/// Snapshot read-only transactions provides a simpler method than
/// locking read-write transactions for doing several consistent
/// reads. However, this type of transaction does not support writes.
///
/// Snapshot transactions do not take locks. Instead, they work by
/// choosing a Cloud Spanner timestamp, then executing all reads at that
/// timestamp. Since they do not acquire locks, they do not block
/// concurrent read-write transactions.
///
/// Unlike locking read-write transactions, snapshot read-only
/// transactions never abort. They can fail if the chosen read
/// timestamp is garbage collected; however, the default garbage
/// collection policy is generous enough that most applications do not
/// need to worry about this in practice.
///
/// Snapshot read-only transactions do not need to call
/// [Commit][google.spanner.v1.Spanner.Commit] or
/// [Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not
/// permitted to do so).
///
/// To execute a snapshot transaction, the client specifies a timestamp
/// bound, which tells Cloud Spanner how to choose a read timestamp.
///
/// The types of timestamp bound are:
///
///   - Strong (the default).
///   - Bounded staleness.
///   - Exact staleness.
///
/// If the Cloud Spanner database to be read is geographically distributed,
/// stale read-only transactions can execute more quickly than strong
/// or read-write transaction, because they are able to execute far
/// from the leader replica.
///
/// Each type of timestamp bound is discussed in detail below.
///
/// ### Strong
///
/// Strong reads are guaranteed to see the effects of all transactions
/// that have committed before the start of the read. Furthermore, all
/// rows yielded by a single read are consistent with each other -- if
/// any part of the read observes a transaction, all parts of the read
/// see the transaction.
///
/// Strong reads are not repeatable: two consecutive strong read-only
/// transactions might return inconsistent results if there are
/// concurrent writes. If consistency across reads is required, the
/// reads should be executed within a transaction or at an exact read
/// timestamp.
///
/// See [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].
///
/// ### Exact Staleness
///
/// These timestamp bounds execute reads at a user-specified
/// timestamp. Reads at a timestamp are guaranteed to see a consistent
/// prefix of the global transaction history: they observe
/// modifications done by all transactions with a commit timestamp <=
/// the read timestamp, and observe none of the modifications done by
/// transactions with a larger commit timestamp. They will block until
/// all conflicting transactions that may be assigned commit timestamps
/// <= the read timestamp have finished.
///
/// The timestamp can either be expressed as an absolute Cloud Spanner commit
/// timestamp or a staleness relative to the current time.
///
/// These modes do not require a "negotiation phase" to pick a
/// timestamp. As a result, they execute slightly faster than the
/// equivalent boundedly stale concurrency modes. On the other hand,
/// boundedly stale reads usually return fresher results.
///
/// See [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and
/// [TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].
///
/// ### Bounded Staleness
///
/// Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
/// subject to a user-provided staleness bound. Cloud Spanner chooses the
/// newest timestamp within the staleness bound that allows execution
/// of the reads at the closest available replica without blocking.
///
/// All rows yielded are consistent with each other -- if any part of
/// the read observes a transaction, all parts of the read see the
/// transaction. Boundedly stale reads are not repeatable: two stale
/// reads, even if they use the same staleness bound, can execute at
/// different timestamps and thus return inconsistent results.
///
/// Boundedly stale reads execute in two phases: the first phase
/// negotiates a timestamp among all replicas needed to serve the
/// read. In the second phase, reads are executed at the negotiated
/// timestamp.
///
/// As a result of the two phase execution, bounded staleness reads are
/// usually a little slower than comparable exact staleness
/// reads. However, they are typically able to return fresher
/// results, and are more likely to execute at the closest replica.
///
/// Because the timestamp negotiation requires up-front knowledge of
/// which rows will be read, it can only be used with single-use
/// read-only transactions.
///
/// See [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and
/// [TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].
///
/// ### Old Read Timestamps and Garbage Collection
///
/// Cloud Spanner continuously garbage collects deleted and overwritten data
/// in the background to reclaim storage space. This process is known
/// as "version GC". By default, version GC reclaims versions after they
/// are one hour old. Because of this, Cloud Spanner cannot perform reads
/// at read timestamps more than one hour in the past. This
/// restriction also applies to in-progress reads and/or SQL queries whose
/// timestamp become too old while executing. Reads and SQL queries with
/// too-old read timestamps fail with the error `FAILED_PRECONDITION`.
///
/// ## Partitioned DML Transactions
///
/// Partitioned DML transactions are used to execute DML statements with a
/// different execution strategy that provides different, and often better,
/// scalability properties for large, table-wide operations than DML in a
/// ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
/// should prefer using ReadWrite transactions.
///
/// Partitioned DML partitions the keyspace and runs the DML statement on each
/// partition in separate, internal transactions. These transactions commit
/// automatically when complete, and run independently from one another.
///
/// To reduce lock contention, this execution strategy only acquires read locks
/// on rows that match the WHERE clause of the statement. Additionally, the
/// smaller per-partition transactions hold locks for less time.
///
/// That said, Partitioned DML is not a drop-in replacement for standard DML used
/// in ReadWrite transactions.
///
///  - The DML statement must be fully-partitionable. Specifically, the statement
///    must be expressible as the union of many statements which each access only
///    a single row of the table.
///
///  - The statement is not applied atomically to all rows of the table. Rather,
///    the statement is applied atomically to partitions of the table, in
///    independent transactions. Secondary index rows are updated atomically
///    with the base table rows.
///
///  - Partitioned DML does not guarantee exactly-once execution semantics
///    against a partition. The statement will be applied at least once to each
///    partition. It is strongly recommended that the DML statement should be
///    idempotent to avoid unexpected results. For instance, it is potentially
///    dangerous to run a statement such as
///    `UPDATE table SET column = column + 1` as it could be run multiple times
///    against some rows.
///
///  - The partitions are committed automatically - there is no support for
///    Commit or Rollback. If the call returns an error, or if the client issuing
///    the ExecuteSql call dies, it is possible that some rows had the statement
///    executed on them successfully. It is also possible that statement was
///    never executed against other rows.
///
///  - Partitioned DML transactions may only contain the execution of a single
///    DML statement via ExecuteSql or ExecuteStreamingSql.
///
///  - If any error is encountered during the execution of the partitioned DML
///    operation (for instance, a UNIQUE INDEX violation, division by zero, or a
///    value that cannot be stored due to schema constraints), then the
///    operation is stopped at that point and an error is returned. It is
///    possible that at this point, some partitions have been committed (or even
///    committed multiple times), and other partitions have not been run at all.
///
/// Given the above, Partitioned DML is good fit for large, database-wide,
/// operations that are idempotent, such as deleting old rows from a very large
/// table.
public struct Google_Spanner_V1_TransactionOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The type of transaction.
  public var mode: Google_Spanner_V1_TransactionOptions.OneOf_Mode? = nil

  /// Transaction may write.
  ///
  /// Authorization to begin a read-write transaction requires
  /// `spanner.databases.beginOrRollbackReadWriteTransaction` permission
  /// on the `session` resource.
  public var readWrite: Google_Spanner_V1_TransactionOptions.ReadWrite {
    get {
      if case .readWrite(let v)? = mode {return v}
      return Google_Spanner_V1_TransactionOptions.ReadWrite()
    }
    set {mode = .readWrite(newValue)}
  }

  /// Partitioned DML transaction.
  ///
  /// Authorization to begin a Partitioned DML transaction requires
  /// `spanner.databases.beginPartitionedDmlTransaction` permission
  /// on the `session` resource.
  public var partitionedDml: Google_Spanner_V1_TransactionOptions.PartitionedDml {
    get {
      if case .partitionedDml(let v)? = mode {return v}
      return Google_Spanner_V1_TransactionOptions.PartitionedDml()
    }
    set {mode = .partitionedDml(newValue)}
  }

  /// Transaction will not write.
  ///
  /// Authorization to begin a read-only transaction requires
  /// `spanner.databases.beginReadOnlyTransaction` permission
  /// on the `session` resource.
  public var readOnly: Google_Spanner_V1_TransactionOptions.ReadOnly {
    get {
      if case .readOnly(let v)? = mode {return v}
      return Google_Spanner_V1_TransactionOptions.ReadOnly()
    }
    set {mode = .readOnly(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The type of transaction.
  public enum OneOf_Mode: Equatable {
    /// Transaction may write.
    ///
    /// Authorization to begin a read-write transaction requires
    /// `spanner.databases.beginOrRollbackReadWriteTransaction` permission
    /// on the `session` resource.
    case readWrite(Google_Spanner_V1_TransactionOptions.ReadWrite)
    /// Partitioned DML transaction.
    ///
    /// Authorization to begin a Partitioned DML transaction requires
    /// `spanner.databases.beginPartitionedDmlTransaction` permission
    /// on the `session` resource.
    case partitionedDml(Google_Spanner_V1_TransactionOptions.PartitionedDml)
    /// Transaction will not write.
    ///
    /// Authorization to begin a read-only transaction requires
    /// `spanner.databases.beginReadOnlyTransaction` permission
    /// on the `session` resource.
    case readOnly(Google_Spanner_V1_TransactionOptions.ReadOnly)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Spanner_V1_TransactionOptions.OneOf_Mode, rhs: Google_Spanner_V1_TransactionOptions.OneOf_Mode) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.readWrite, .readWrite): return {
        guard case .readWrite(let l) = lhs, case .readWrite(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.partitionedDml, .partitionedDml): return {
        guard case .partitionedDml(let l) = lhs, case .partitionedDml(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.readOnly, .readOnly): return {
        guard case .readOnly(let l) = lhs, case .readOnly(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Message type to initiate a read-write transaction. Currently this
  /// transaction type has no options.
  public struct ReadWrite {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Message type to initiate a Partitioned DML transaction.
  public struct PartitionedDml {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Message type to initiate a read-only transaction.
  public struct ReadOnly {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How to choose the timestamp for the read-only transaction.
    public var timestampBound: Google_Spanner_V1_TransactionOptions.ReadOnly.OneOf_TimestampBound? = nil

    /// Read at a timestamp where all previously committed transactions
    /// are visible.
    public var strong: Bool {
      get {
        if case .strong(let v)? = timestampBound {return v}
        return false
      }
      set {timestampBound = .strong(newValue)}
    }

    /// Executes all reads at a timestamp >= `min_read_timestamp`.
    ///
    /// This is useful for requesting fresher data than some previous
    /// read, or data that is fresh enough to observe the effects of some
    /// previously committed transaction whose timestamp is known.
    ///
    /// Note that this option can only be used in single-use transactions.
    ///
    /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
    /// Example: `"2014-10-02T15:01:23.045123456Z"`.
    public var minReadTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {
        if case .minReadTimestamp(let v)? = timestampBound {return v}
        return SwiftProtobuf.Google_Protobuf_Timestamp()
      }
      set {timestampBound = .minReadTimestamp(newValue)}
    }

    /// Read data at a timestamp >= `NOW - max_staleness`
    /// seconds. Guarantees that all writes that have committed more
    /// than the specified number of seconds ago are visible. Because
    /// Cloud Spanner chooses the exact timestamp, this mode works even if
    /// the client's local clock is substantially skewed from Cloud Spanner
    /// commit timestamps.
    ///
    /// Useful for reading the freshest data available at a nearby
    /// replica, while bounding the possible staleness if the local
    /// replica has fallen behind.
    ///
    /// Note that this option can only be used in single-use
    /// transactions.
    public var maxStaleness: SwiftProtobuf.Google_Protobuf_Duration {
      get {
        if case .maxStaleness(let v)? = timestampBound {return v}
        return SwiftProtobuf.Google_Protobuf_Duration()
      }
      set {timestampBound = .maxStaleness(newValue)}
    }

    /// Executes all reads at the given timestamp. Unlike other modes,
    /// reads at a specific timestamp are repeatable; the same read at
    /// the same timestamp always returns the same data. If the
    /// timestamp is in the future, the read will block until the
    /// specified timestamp, modulo the read's deadline.
    ///
    /// Useful for large scale consistent reads such as mapreduces, or
    /// for coordinating many reads against a consistent snapshot of the
    /// data.
    ///
    /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
    /// Example: `"2014-10-02T15:01:23.045123456Z"`.
    public var readTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {
        if case .readTimestamp(let v)? = timestampBound {return v}
        return SwiftProtobuf.Google_Protobuf_Timestamp()
      }
      set {timestampBound = .readTimestamp(newValue)}
    }

    /// Executes all reads at a timestamp that is `exact_staleness`
    /// old. The timestamp is chosen soon after the read is started.
    ///
    /// Guarantees that all writes that have committed more than the
    /// specified number of seconds ago are visible. Because Cloud Spanner
    /// chooses the exact timestamp, this mode works even if the client's
    /// local clock is substantially skewed from Cloud Spanner commit
    /// timestamps.
    ///
    /// Useful for reading at nearby replicas without the distributed
    /// timestamp negotiation overhead of `max_staleness`.
    public var exactStaleness: SwiftProtobuf.Google_Protobuf_Duration {
      get {
        if case .exactStaleness(let v)? = timestampBound {return v}
        return SwiftProtobuf.Google_Protobuf_Duration()
      }
      set {timestampBound = .exactStaleness(newValue)}
    }

    /// If true, the Cloud Spanner-selected read timestamp is included in
    /// the [Transaction][google.spanner.v1.Transaction] message that describes the transaction.
    public var returnReadTimestamp: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// How to choose the timestamp for the read-only transaction.
    public enum OneOf_TimestampBound: Equatable {
      /// Read at a timestamp where all previously committed transactions
      /// are visible.
      case strong(Bool)
      /// Executes all reads at a timestamp >= `min_read_timestamp`.
      ///
      /// This is useful for requesting fresher data than some previous
      /// read, or data that is fresh enough to observe the effects of some
      /// previously committed transaction whose timestamp is known.
      ///
      /// Note that this option can only be used in single-use transactions.
      ///
      /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
      /// Example: `"2014-10-02T15:01:23.045123456Z"`.
      case minReadTimestamp(SwiftProtobuf.Google_Protobuf_Timestamp)
      /// Read data at a timestamp >= `NOW - max_staleness`
      /// seconds. Guarantees that all writes that have committed more
      /// than the specified number of seconds ago are visible. Because
      /// Cloud Spanner chooses the exact timestamp, this mode works even if
      /// the client's local clock is substantially skewed from Cloud Spanner
      /// commit timestamps.
      ///
      /// Useful for reading the freshest data available at a nearby
      /// replica, while bounding the possible staleness if the local
      /// replica has fallen behind.
      ///
      /// Note that this option can only be used in single-use
      /// transactions.
      case maxStaleness(SwiftProtobuf.Google_Protobuf_Duration)
      /// Executes all reads at the given timestamp. Unlike other modes,
      /// reads at a specific timestamp are repeatable; the same read at
      /// the same timestamp always returns the same data. If the
      /// timestamp is in the future, the read will block until the
      /// specified timestamp, modulo the read's deadline.
      ///
      /// Useful for large scale consistent reads such as mapreduces, or
      /// for coordinating many reads against a consistent snapshot of the
      /// data.
      ///
      /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
      /// Example: `"2014-10-02T15:01:23.045123456Z"`.
      case readTimestamp(SwiftProtobuf.Google_Protobuf_Timestamp)
      /// Executes all reads at a timestamp that is `exact_staleness`
      /// old. The timestamp is chosen soon after the read is started.
      ///
      /// Guarantees that all writes that have committed more than the
      /// specified number of seconds ago are visible. Because Cloud Spanner
      /// chooses the exact timestamp, this mode works even if the client's
      /// local clock is substantially skewed from Cloud Spanner commit
      /// timestamps.
      ///
      /// Useful for reading at nearby replicas without the distributed
      /// timestamp negotiation overhead of `max_staleness`.
      case exactStaleness(SwiftProtobuf.Google_Protobuf_Duration)

    #if !swift(>=4.1)
      public static func ==(lhs: Google_Spanner_V1_TransactionOptions.ReadOnly.OneOf_TimestampBound, rhs: Google_Spanner_V1_TransactionOptions.ReadOnly.OneOf_TimestampBound) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.strong, .strong): return {
          guard case .strong(let l) = lhs, case .strong(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.minReadTimestamp, .minReadTimestamp): return {
          guard case .minReadTimestamp(let l) = lhs, case .minReadTimestamp(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.maxStaleness, .maxStaleness): return {
          guard case .maxStaleness(let l) = lhs, case .maxStaleness(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.readTimestamp, .readTimestamp): return {
          guard case .readTimestamp(let l) = lhs, case .readTimestamp(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.exactStaleness, .exactStaleness): return {
          guard case .exactStaleness(let l) = lhs, case .exactStaleness(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public init() {}
}

/// A transaction.
public struct Google_Spanner_V1_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// `id` may be used to identify the transaction in subsequent
  /// [Read][google.spanner.v1.Spanner.Read],
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql],
  /// [Commit][google.spanner.v1.Spanner.Commit], or
  /// [Rollback][google.spanner.v1.Spanner.Rollback] calls.
  ///
  /// Single-use read-only transactions do not have IDs, because
  /// single-use transactions do not support multiple requests.
  public var id: Data = Data()

  /// For snapshot read-only transactions, the read timestamp chosen
  /// for the transaction. Not returned by default: see
  /// [TransactionOptions.ReadOnly.return_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.return_read_timestamp].
  ///
  /// A timestamp in RFC3339 UTC \"Zulu\" format, accurate to nanoseconds.
  /// Example: `"2014-10-02T15:01:23.045123456Z"`.
  public var readTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _readTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_readTimestamp = newValue}
  }
  /// Returns true if `readTimestamp` has been explicitly set.
  public var hasReadTimestamp: Bool {return self._readTimestamp != nil}
  /// Clears the value of `readTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearReadTimestamp() {self._readTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _readTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// This message is used to select the transaction in which a
/// [Read][google.spanner.v1.Spanner.Read] or
/// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] call runs.
///
/// See [TransactionOptions][google.spanner.v1.TransactionOptions] for more information about transactions.
public struct Google_Spanner_V1_TransactionSelector {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If no fields are set, the default is a single use transaction
  /// with strong concurrency.
  public var selector: Google_Spanner_V1_TransactionSelector.OneOf_Selector? = nil

  /// Execute the read or SQL query in a temporary transaction.
  /// This is the most efficient way to execute a transaction that
  /// consists of a single SQL query.
  public var singleUse: Google_Spanner_V1_TransactionOptions {
    get {
      if case .singleUse(let v)? = selector {return v}
      return Google_Spanner_V1_TransactionOptions()
    }
    set {selector = .singleUse(newValue)}
  }

  /// Execute the read or SQL query in a previously-started transaction.
  public var id: Data {
    get {
      if case .id(let v)? = selector {return v}
      return Data()
    }
    set {selector = .id(newValue)}
  }

  /// Begin a new transaction and execute this read or SQL query in
  /// it. The transaction ID of the new transaction is returned in
  /// [ResultSetMetadata.transaction][google.spanner.v1.ResultSetMetadata.transaction], which is a [Transaction][google.spanner.v1.Transaction].
  public var begin: Google_Spanner_V1_TransactionOptions {
    get {
      if case .begin(let v)? = selector {return v}
      return Google_Spanner_V1_TransactionOptions()
    }
    set {selector = .begin(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If no fields are set, the default is a single use transaction
  /// with strong concurrency.
  public enum OneOf_Selector: Equatable {
    /// Execute the read or SQL query in a temporary transaction.
    /// This is the most efficient way to execute a transaction that
    /// consists of a single SQL query.
    case singleUse(Google_Spanner_V1_TransactionOptions)
    /// Execute the read or SQL query in a previously-started transaction.
    case id(Data)
    /// Begin a new transaction and execute this read or SQL query in
    /// it. The transaction ID of the new transaction is returned in
    /// [ResultSetMetadata.transaction][google.spanner.v1.ResultSetMetadata.transaction], which is a [Transaction][google.spanner.v1.Transaction].
    case begin(Google_Spanner_V1_TransactionOptions)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Spanner_V1_TransactionSelector.OneOf_Selector, rhs: Google_Spanner_V1_TransactionSelector.OneOf_Selector) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.singleUse, .singleUse): return {
        guard case .singleUse(let l) = lhs, case .singleUse(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.id, .id): return {
        guard case .id(let l) = lhs, case .id(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.begin, .begin): return {
        guard case .begin(let l) = lhs, case .begin(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.spanner.v1"

extension Google_Spanner_V1_TransactionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "read_write"),
    3: .standard(proto: "partitioned_dml"),
    2: .standard(proto: "read_only"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Spanner_V1_TransactionOptions.ReadWrite?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .readWrite(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .readWrite(v)}
      }()
      case 2: try {
        var v: Google_Spanner_V1_TransactionOptions.ReadOnly?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .readOnly(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .readOnly(v)}
      }()
      case 3: try {
        var v: Google_Spanner_V1_TransactionOptions.PartitionedDml?
        if let current = self.mode {
          try decoder.handleConflictingOneOf()
          if case .partitionedDml(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.mode = .partitionedDml(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.mode {
    case .readWrite?: try {
      guard case .readWrite(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .readOnly?: try {
      guard case .readOnly(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .partitionedDml?: try {
      guard case .partitionedDml(let v)? = self.mode else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_TransactionOptions, rhs: Google_Spanner_V1_TransactionOptions) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_TransactionOptions.ReadWrite: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Spanner_V1_TransactionOptions.protoMessageName + ".ReadWrite"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_TransactionOptions.ReadWrite, rhs: Google_Spanner_V1_TransactionOptions.ReadWrite) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_TransactionOptions.PartitionedDml: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Spanner_V1_TransactionOptions.protoMessageName + ".PartitionedDml"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_TransactionOptions.PartitionedDml, rhs: Google_Spanner_V1_TransactionOptions.PartitionedDml) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_TransactionOptions.ReadOnly: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Spanner_V1_TransactionOptions.protoMessageName + ".ReadOnly"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "strong"),
    2: .standard(proto: "min_read_timestamp"),
    3: .standard(proto: "max_staleness"),
    4: .standard(proto: "read_timestamp"),
    5: .standard(proto: "exact_staleness"),
    6: .standard(proto: "return_read_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.timestampBound != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.timestampBound = .strong(v)}
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.timestampBound {
          try decoder.handleConflictingOneOf()
          if case .minReadTimestamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.timestampBound = .minReadTimestamp(v)}
      }()
      case 3: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.timestampBound {
          try decoder.handleConflictingOneOf()
          if case .maxStaleness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.timestampBound = .maxStaleness(v)}
      }()
      case 4: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        if let current = self.timestampBound {
          try decoder.handleConflictingOneOf()
          if case .readTimestamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.timestampBound = .readTimestamp(v)}
      }()
      case 5: try {
        var v: SwiftProtobuf.Google_Protobuf_Duration?
        if let current = self.timestampBound {
          try decoder.handleConflictingOneOf()
          if case .exactStaleness(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.timestampBound = .exactStaleness(v)}
      }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.returnReadTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.timestampBound {
    case .strong?: try {
      guard case .strong(let v)? = self.timestampBound else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .minReadTimestamp?: try {
      guard case .minReadTimestamp(let v)? = self.timestampBound else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .maxStaleness?: try {
      guard case .maxStaleness(let v)? = self.timestampBound else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .readTimestamp?: try {
      guard case .readTimestamp(let v)? = self.timestampBound else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .exactStaleness?: try {
      guard case .exactStaleness(let v)? = self.timestampBound else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.returnReadTimestamp != false {
      try visitor.visitSingularBoolField(value: self.returnReadTimestamp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_TransactionOptions.ReadOnly, rhs: Google_Spanner_V1_TransactionOptions.ReadOnly) -> Bool {
    if lhs.timestampBound != rhs.timestampBound {return false}
    if lhs.returnReadTimestamp != rhs.returnReadTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "read_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._readTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if let v = self._readTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_Transaction, rhs: Google_Spanner_V1_Transaction) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._readTimestamp != rhs._readTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_TransactionSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "single_use"),
    2: .same(proto: "id"),
    3: .same(proto: "begin"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Spanner_V1_TransactionOptions?
        if let current = self.selector {
          try decoder.handleConflictingOneOf()
          if case .singleUse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.selector = .singleUse(v)}
      }()
      case 2: try {
        if self.selector != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.selector = .id(v)}
      }()
      case 3: try {
        var v: Google_Spanner_V1_TransactionOptions?
        if let current = self.selector {
          try decoder.handleConflictingOneOf()
          if case .begin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.selector = .begin(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.selector {
    case .singleUse?: try {
      guard case .singleUse(let v)? = self.selector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .id?: try {
      guard case .id(let v)? = self.selector else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .begin?: try {
      guard case .begin(let v)? = self.selector else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_TransactionSelector, rhs: Google_Spanner_V1_TransactionSelector) -> Bool {
    if lhs.selector != rhs.selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

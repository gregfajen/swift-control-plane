// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/spanner/v1/spanner.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The request for [CreateSession][google.spanner.v1.Spanner.CreateSession].
public struct Google_Spanner_V1_CreateSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database in which the new session is created.
  public var database: String = String()

  /// The session to create.
  public var session: Google_Spanner_V1_Session {
    get {return _session ?? Google_Spanner_V1_Session()}
    set {_session = newValue}
  }
  /// Returns true if `session` has been explicitly set.
  public var hasSession: Bool {return self._session != nil}
  /// Clears the value of `session`. Subsequent reads from it will return its default value.
  public mutating func clearSession() {self._session = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _session: Google_Spanner_V1_Session? = nil
}

/// The request for [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
public struct Google_Spanner_V1_BatchCreateSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database in which the new sessions are created.
  public var database: String = String()

  /// Parameters to be applied to each created session.
  public var sessionTemplate: Google_Spanner_V1_Session {
    get {return _sessionTemplate ?? Google_Spanner_V1_Session()}
    set {_sessionTemplate = newValue}
  }
  /// Returns true if `sessionTemplate` has been explicitly set.
  public var hasSessionTemplate: Bool {return self._sessionTemplate != nil}
  /// Clears the value of `sessionTemplate`. Subsequent reads from it will return its default value.
  public mutating func clearSessionTemplate() {self._sessionTemplate = nil}

  /// Required. The number of sessions to be created in this batch call.
  /// The API may return fewer than the requested number of sessions. If a
  /// specific number of sessions are desired, the client can make additional
  /// calls to BatchCreateSessions (adjusting
  /// [session_count][google.spanner.v1.BatchCreateSessionsRequest.session_count] as necessary).
  public var sessionCount: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _sessionTemplate: Google_Spanner_V1_Session? = nil
}

/// The response for [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].
public struct Google_Spanner_V1_BatchCreateSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The freshly created sessions.
  public var session: [Google_Spanner_V1_Session] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A session in the Cloud Spanner API.
public struct Google_Spanner_V1_Session {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the session. This is always system-assigned; values provided
  /// when creating a session are ignored.
  public var name: String = String()

  /// The labels for the session.
  ///
  ///  * Label keys must be between 1 and 63 characters long and must conform to
  ///    the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
  ///  * Label values must be between 0 and 63 characters long and must conform
  ///    to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
  ///  * No more than 64 labels can be associated with a given session.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  public var labels: Dictionary<String,String> = [:]

  /// Output only. The timestamp when the session is created.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The approximate timestamp when the session is last used. It is
  /// typically earlier than the actual last use time.
  public var approximateLastUseTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _approximateLastUseTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_approximateLastUseTime = newValue}
  }
  /// Returns true if `approximateLastUseTime` has been explicitly set.
  public var hasApproximateLastUseTime: Bool {return self._approximateLastUseTime != nil}
  /// Clears the value of `approximateLastUseTime`. Subsequent reads from it will return its default value.
  public mutating func clearApproximateLastUseTime() {self._approximateLastUseTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _approximateLastUseTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [GetSession][google.spanner.v1.Spanner.GetSession].
public struct Google_Spanner_V1_GetSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the session to retrieve.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [ListSessions][google.spanner.v1.Spanner.ListSessions].
public struct Google_Spanner_V1_ListSessionsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database in which to list sessions.
  public var database: String = String()

  /// Number of sessions to be returned in the response. If 0 or less, defaults
  /// to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.v1.ListSessionsResponse.next_page_token] from a previous
  /// [ListSessionsResponse][google.spanner.v1.ListSessionsResponse].
  public var pageToken: String = String()

  /// An expression for filtering the results of the request. Filter rules are
  /// case insensitive. The fields eligible for filtering are:
  ///
  ///   * `labels.key` where key is the name of a label
  ///
  /// Some examples of using filters are:
  ///
  ///   * `labels.env:*` --> The session has the label "env".
  ///   * `labels.env:dev` --> The session has the label "env" and the value of
  ///                        the label contains the string "dev".
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [ListSessions][google.spanner.v1.Spanner.ListSessions].
public struct Google_Spanner_V1_ListSessionsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of requested sessions.
  public var sessions: [Google_Spanner_V1_Session] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListSessions][google.spanner.v1.Spanner.ListSessions] call to fetch more of the matching
  /// sessions.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [DeleteSession][google.spanner.v1.Spanner.DeleteSession].
public struct Google_Spanner_V1_DeleteSessionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the session to delete.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
/// [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql].
public struct Google_Spanner_V1_ExecuteSqlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session in which the SQL query should be performed.
  public var session: String = String()

  /// The transaction to use.
  ///
  /// For queries, if none is provided, the default is a temporary read-only
  /// transaction with strong concurrency.
  ///
  /// Standard DML statements require a read-write transaction. To protect
  /// against replays, single-use transactions are not supported.  The caller
  /// must either supply an existing transaction ID or begin a new transaction.
  ///
  /// Partitioned DML requires an existing Partitioned DML transaction ID.
  public var transaction: Google_Spanner_V1_TransactionSelector {
    get {return _transaction ?? Google_Spanner_V1_TransactionSelector()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  /// Required. The SQL string.
  public var sql: String = String()

  /// Parameter names and values that bind to placeholders in the SQL string.
  ///
  /// A parameter placeholder consists of the `@` character followed by the
  /// parameter name (for example, `@firstName`). Parameter names can contain
  /// letters, numbers, and underscores.
  ///
  /// Parameters can appear anywhere that a literal value is expected.  The same
  /// parameter name can be used more than once, for example:
  ///
  /// `"WHERE id > @msg_id AND id < @msg_id + 100"`
  ///
  /// It is an error to execute a SQL statement with unbound parameters.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  /// It is not always possible for Cloud Spanner to infer the right SQL type
  /// from a JSON value.  For example, values of type `BYTES` and values
  /// of type `STRING` both appear in [params][google.spanner.v1.ExecuteSqlRequest.params] as JSON strings.
  ///
  /// In these cases, `param_types` can be used to specify the exact
  /// SQL type for some or all of the SQL statement parameters. See the
  /// definition of [Type][google.spanner.v1.Type] for more information
  /// about SQL types.
  public var paramTypes: Dictionary<String,Google_Spanner_V1_Type> = [:]

  /// If this request is resuming a previously interrupted SQL statement
  /// execution, `resume_token` should be copied from the last
  /// [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the interruption. Doing this
  /// enables the new SQL statement execution to resume where the last one left
  /// off. The rest of the request parameters must exactly match the
  /// request that yielded this token.
  public var resumeToken: Data = Data()

  /// Used to control the amount of debugging information returned in
  /// [ResultSetStats][google.spanner.v1.ResultSetStats]. If [partition_token][google.spanner.v1.ExecuteSqlRequest.partition_token] is set, [query_mode][google.spanner.v1.ExecuteSqlRequest.query_mode] can only
  /// be set to [QueryMode.NORMAL][google.spanner.v1.ExecuteSqlRequest.QueryMode.NORMAL].
  public var queryMode: Google_Spanner_V1_ExecuteSqlRequest.QueryMode = .normal

  /// If present, results will be restricted to the specified partition
  /// previously created using PartitionQuery().  There must be an exact
  /// match for the values of fields common to this message and the
  /// PartitionQueryRequest message used to create this partition_token.
  public var partitionToken: Data = Data()

  /// A per-transaction sequence number used to identify this request. This field
  /// makes each request idempotent such that if the request is received multiple
  /// times, at most one will succeed.
  ///
  /// The sequence number must be monotonically increasing within the
  /// transaction. If a request arrives for the first time with an out-of-order
  /// sequence number, the transaction may be aborted. Replays of previously
  /// handled requests will yield the same response as the first execution.
  ///
  /// Required for DML statements. Ignored for queries.
  public var seqno: Int64 = 0

  /// Query optimizer configuration to use for the given query.
  public var queryOptions: Google_Spanner_V1_ExecuteSqlRequest.QueryOptions {
    get {return _queryOptions ?? Google_Spanner_V1_ExecuteSqlRequest.QueryOptions()}
    set {_queryOptions = newValue}
  }
  /// Returns true if `queryOptions` has been explicitly set.
  public var hasQueryOptions: Bool {return self._queryOptions != nil}
  /// Clears the value of `queryOptions`. Subsequent reads from it will return its default value.
  public mutating func clearQueryOptions() {self._queryOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Mode in which the statement must be processed.
  public enum QueryMode: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The default mode. Only the statement results are returned.
    case normal // = 0

    /// This mode returns only the query plan, without any results or
    /// execution statistics information.
    case plan // = 1

    /// This mode returns both the query plan and the execution statistics along
    /// with the results.
    case profile // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .normal
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .normal
      case 1: self = .plan
      case 2: self = .profile
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .normal: return 0
      case .plan: return 1
      case .profile: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Query optimizer configuration.
  public struct QueryOptions {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// An option to control the selection of optimizer version.
    ///
    /// This parameter allows individual queries to pick different query
    /// optimizer versions.
    ///
    /// Specifying "latest" as a value instructs Cloud Spanner to use the
    /// latest supported query optimizer version. If not specified, Cloud Spanner
    /// uses optimizer version set at the database level options. Any other
    /// positive integer (from the list of supported optimizer versions)
    /// overrides the default optimizer version for query execution.
    /// The list of supported optimizer versions can be queried from
    /// SPANNER_SYS.SUPPORTED_OPTIMIZER_VERSIONS. Executing a SQL statement
    /// with an invalid optimizer version will fail with a syntax error
    /// (`INVALID_ARGUMENT`) status.
    ///
    /// The `optimizer_version` statement hint has precedence over this setting.
    public var optimizerVersion: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _transaction: Google_Spanner_V1_TransactionSelector? = nil
  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _queryOptions: Google_Spanner_V1_ExecuteSqlRequest.QueryOptions? = nil
}

#if swift(>=4.2)

extension Google_Spanner_V1_ExecuteSqlRequest.QueryMode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Spanner_V1_ExecuteSqlRequest.QueryMode] = [
    .normal,
    .plan,
    .profile,
  ]
}

#endif  // swift(>=4.2)

/// The request for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml].
public struct Google_Spanner_V1_ExecuteBatchDmlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session in which the DML statements should be performed.
  public var session: String = String()

  /// Required. The transaction to use. Must be a read-write transaction.
  ///
  /// To protect against replays, single-use transactions are not supported. The
  /// caller must either supply an existing transaction ID or begin a new
  /// transaction.
  public var transaction: Google_Spanner_V1_TransactionSelector {
    get {return _transaction ?? Google_Spanner_V1_TransactionSelector()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  /// Required. The list of statements to execute in this batch. Statements are executed
  /// serially, such that the effects of statement `i` are visible to statement
  /// `i+1`. Each statement must be a DML statement. Execution stops at the
  /// first failed statement; the remaining statements are not executed.
  ///
  /// Callers must provide at least one statement.
  public var statements: [Google_Spanner_V1_ExecuteBatchDmlRequest.Statement] = []

  /// Required. A per-transaction sequence number used to identify this request. This field
  /// makes each request idempotent such that if the request is received multiple
  /// times, at most one will succeed.
  ///
  /// The sequence number must be monotonically increasing within the
  /// transaction. If a request arrives for the first time with an out-of-order
  /// sequence number, the transaction may be aborted. Replays of previously
  /// handled requests will yield the same response as the first execution.
  public var seqno: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A single DML statement.
  public struct Statement {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Required. The DML string.
    public var sql: String = String()

    /// Parameter names and values that bind to placeholders in the DML string.
    ///
    /// A parameter placeholder consists of the `@` character followed by the
    /// parameter name (for example, `@firstName`). Parameter names can contain
    /// letters, numbers, and underscores.
    ///
    /// Parameters can appear anywhere that a literal value is expected.  The
    /// same parameter name can be used more than once, for example:
    ///
    /// `"WHERE id > @msg_id AND id < @msg_id + 100"`
    ///
    /// It is an error to execute a SQL statement with unbound parameters.
    public var params: SwiftProtobuf.Google_Protobuf_Struct {
      get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
      set {_params = newValue}
    }
    /// Returns true if `params` has been explicitly set.
    public var hasParams: Bool {return self._params != nil}
    /// Clears the value of `params`. Subsequent reads from it will return its default value.
    public mutating func clearParams() {self._params = nil}

    /// It is not always possible for Cloud Spanner to infer the right SQL type
    /// from a JSON value.  For example, values of type `BYTES` and values
    /// of type `STRING` both appear in [params][google.spanner.v1.ExecuteBatchDmlRequest.Statement.params] as JSON strings.
    ///
    /// In these cases, `param_types` can be used to specify the exact
    /// SQL type for some or all of the SQL statement parameters. See the
    /// definition of [Type][google.spanner.v1.Type] for more information
    /// about SQL types.
    public var paramTypes: Dictionary<String,Google_Spanner_V1_Type> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
  }

  public init() {}

  fileprivate var _transaction: Google_Spanner_V1_TransactionSelector? = nil
}

/// The response for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml]. Contains a list
/// of [ResultSet][google.spanner.v1.ResultSet] messages, one for each DML statement that has successfully
/// executed, in the same order as the statements in the request. If a statement
/// fails, the status in the response body identifies the cause of the failure.
///
/// To check for DML statements that failed, use the following approach:
///
/// 1. Check the status in the response message. The [google.rpc.Code][google.rpc.Code] enum
///    value `OK` indicates that all statements were executed successfully.
/// 2. If the status was not `OK`, check the number of result sets in the
///    response. If the response contains `N` [ResultSet][google.spanner.v1.ResultSet] messages, then
///    statement `N+1` in the request failed.
///
/// Example 1:
///
/// * Request: 5 DML statements, all executed successfully.
/// * Response: 5 [ResultSet][google.spanner.v1.ResultSet] messages, with the status `OK`.
///
/// Example 2:
///
/// * Request: 5 DML statements. The third statement has a syntax error.
/// * Response: 2 [ResultSet][google.spanner.v1.ResultSet] messages, and a syntax error (`INVALID_ARGUMENT`)
///   status. The number of [ResultSet][google.spanner.v1.ResultSet] messages indicates that the third
///   statement failed, and the fourth and fifth statements were not executed.
public struct Google_Spanner_V1_ExecuteBatchDmlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// One [ResultSet][google.spanner.v1.ResultSet] for each statement in the request that ran successfully,
  /// in the same order as the statements in the request. Each [ResultSet][google.spanner.v1.ResultSet] does
  /// not contain any rows. The [ResultSetStats][google.spanner.v1.ResultSetStats] in each [ResultSet][google.spanner.v1.ResultSet] contain
  /// the number of rows modified by the statement.
  ///
  /// Only the first [ResultSet][google.spanner.v1.ResultSet] in the response contains valid
  /// [ResultSetMetadata][google.spanner.v1.ResultSetMetadata].
  public var resultSets: [Google_Spanner_V1_ResultSet] = []

  /// If all DML statements are executed successfully, the status is `OK`.
  /// Otherwise, the error status of the first failed statement.
  public var status: Google_Rpc_Status {
    get {return _status ?? Google_Rpc_Status()}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  public var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  public mutating func clearStatus() {self._status = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _status: Google_Rpc_Status? = nil
}

/// Options for a PartitionQueryRequest and
/// PartitionReadRequest.
public struct Google_Spanner_V1_PartitionOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// **Note:** This hint is currently ignored by PartitionQuery and
  /// PartitionRead requests.
  ///
  /// The desired data size for each partition generated.  The default for this
  /// option is currently 1 GiB.  This is only a hint. The actual size of each
  /// partition may be smaller or larger than this size request.
  public var partitionSizeBytes: Int64 = 0

  /// **Note:** This hint is currently ignored by PartitionQuery and
  /// PartitionRead requests.
  ///
  /// The desired maximum number of partitions to return.  For example, this may
  /// be set to the number of workers available.  The default for this option
  /// is currently 10,000. The maximum value is currently 200,000.  This is only
  /// a hint.  The actual number of partitions returned may be smaller or larger
  /// than this maximum count request.
  public var maxPartitions: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
public struct Google_Spanner_V1_PartitionQueryRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session used to create the partitions.
  public var session: String = String()

  /// Read only snapshot transactions are supported, read/write and single use
  /// transactions are not.
  public var transaction: Google_Spanner_V1_TransactionSelector {
    get {return _transaction ?? Google_Spanner_V1_TransactionSelector()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  /// Required. The query request to generate partitions for. The request will fail if
  /// the query is not root partitionable. The query plan of a root
  /// partitionable query has a single distributed union operator. A distributed
  /// union operator conceptually divides one or more tables into multiple
  /// splits, remotely evaluates a subquery independently on each split, and
  /// then unions all results.
  ///
  /// This must not contain DML commands, such as INSERT, UPDATE, or
  /// DELETE. Use [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] with a
  /// PartitionedDml transaction for large, partition-friendly DML operations.
  public var sql: String = String()

  /// Parameter names and values that bind to placeholders in the SQL string.
  ///
  /// A parameter placeholder consists of the `@` character followed by the
  /// parameter name (for example, `@firstName`). Parameter names can contain
  /// letters, numbers, and underscores.
  ///
  /// Parameters can appear anywhere that a literal value is expected.  The same
  /// parameter name can be used more than once, for example:
  ///
  /// `"WHERE id > @msg_id AND id < @msg_id + 100"`
  ///
  /// It is an error to execute a SQL statement with unbound parameters.
  public var params: SwiftProtobuf.Google_Protobuf_Struct {
    get {return _params ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_params = newValue}
  }
  /// Returns true if `params` has been explicitly set.
  public var hasParams: Bool {return self._params != nil}
  /// Clears the value of `params`. Subsequent reads from it will return its default value.
  public mutating func clearParams() {self._params = nil}

  /// It is not always possible for Cloud Spanner to infer the right SQL type
  /// from a JSON value.  For example, values of type `BYTES` and values
  /// of type `STRING` both appear in [params][google.spanner.v1.PartitionQueryRequest.params] as JSON strings.
  ///
  /// In these cases, `param_types` can be used to specify the exact
  /// SQL type for some or all of the SQL query parameters. See the
  /// definition of [Type][google.spanner.v1.Type] for more information
  /// about SQL types.
  public var paramTypes: Dictionary<String,Google_Spanner_V1_Type> = [:]

  /// Additional options that affect how many partitions are created.
  public var partitionOptions: Google_Spanner_V1_PartitionOptions {
    get {return _partitionOptions ?? Google_Spanner_V1_PartitionOptions()}
    set {_partitionOptions = newValue}
  }
  /// Returns true if `partitionOptions` has been explicitly set.
  public var hasPartitionOptions: Bool {return self._partitionOptions != nil}
  /// Clears the value of `partitionOptions`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionOptions() {self._partitionOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Google_Spanner_V1_TransactionSelector? = nil
  fileprivate var _params: SwiftProtobuf.Google_Protobuf_Struct? = nil
  fileprivate var _partitionOptions: Google_Spanner_V1_PartitionOptions? = nil
}

/// The request for [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
public struct Google_Spanner_V1_PartitionReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session used to create the partitions.
  public var session: String = String()

  /// Read only snapshot transactions are supported, read/write and single use
  /// transactions are not.
  public var transaction: Google_Spanner_V1_TransactionSelector {
    get {return _transaction ?? Google_Spanner_V1_TransactionSelector()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  /// Required. The name of the table in the database to be read.
  public var table: String = String()

  /// If non-empty, the name of an index on [table][google.spanner.v1.PartitionReadRequest.table]. This index is
  /// used instead of the table primary key when interpreting [key_set][google.spanner.v1.PartitionReadRequest.key_set]
  /// and sorting result rows. See [key_set][google.spanner.v1.PartitionReadRequest.key_set] for further information.
  public var index: String = String()

  /// The columns of [table][google.spanner.v1.PartitionReadRequest.table] to be returned for each row matching
  /// this request.
  public var columns: [String] = []

  /// Required. `key_set` identifies the rows to be yielded. `key_set` names the
  /// primary keys of the rows in [table][google.spanner.v1.PartitionReadRequest.table] to be yielded, unless [index][google.spanner.v1.PartitionReadRequest.index]
  /// is present. If [index][google.spanner.v1.PartitionReadRequest.index] is present, then [key_set][google.spanner.v1.PartitionReadRequest.key_set] instead names
  /// index keys in [index][google.spanner.v1.PartitionReadRequest.index].
  ///
  /// It is not an error for the `key_set` to name rows that do not
  /// exist in the database. Read yields nothing for nonexistent rows.
  public var keySet: Google_Spanner_V1_KeySet {
    get {return _keySet ?? Google_Spanner_V1_KeySet()}
    set {_keySet = newValue}
  }
  /// Returns true if `keySet` has been explicitly set.
  public var hasKeySet: Bool {return self._keySet != nil}
  /// Clears the value of `keySet`. Subsequent reads from it will return its default value.
  public mutating func clearKeySet() {self._keySet = nil}

  /// Additional options that affect how many partitions are created.
  public var partitionOptions: Google_Spanner_V1_PartitionOptions {
    get {return _partitionOptions ?? Google_Spanner_V1_PartitionOptions()}
    set {_partitionOptions = newValue}
  }
  /// Returns true if `partitionOptions` has been explicitly set.
  public var hasPartitionOptions: Bool {return self._partitionOptions != nil}
  /// Clears the value of `partitionOptions`. Subsequent reads from it will return its default value.
  public mutating func clearPartitionOptions() {self._partitionOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Google_Spanner_V1_TransactionSelector? = nil
  fileprivate var _keySet: Google_Spanner_V1_KeySet? = nil
  fileprivate var _partitionOptions: Google_Spanner_V1_PartitionOptions? = nil
}

/// Information returned for each partition returned in a
/// PartitionResponse.
public struct Google_Spanner_V1_Partition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This token can be passed to Read, StreamingRead, ExecuteSql, or
  /// ExecuteStreamingSql requests to restrict the results to those identified by
  /// this partition token.
  public var partitionToken: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
/// or [PartitionRead][google.spanner.v1.Spanner.PartitionRead]
public struct Google_Spanner_V1_PartitionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Partitions created by this request.
  public var partitions: [Google_Spanner_V1_Partition] = []

  /// Transaction created by this request.
  public var transaction: Google_Spanner_V1_Transaction {
    get {return _transaction ?? Google_Spanner_V1_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Google_Spanner_V1_Transaction? = nil
}

/// The request for [Read][google.spanner.v1.Spanner.Read] and
/// [StreamingRead][google.spanner.v1.Spanner.StreamingRead].
public struct Google_Spanner_V1_ReadRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session in which the read should be performed.
  public var session: String = String()

  /// The transaction to use. If none is provided, the default is a
  /// temporary read-only transaction with strong concurrency.
  public var transaction: Google_Spanner_V1_TransactionSelector {
    get {return _transaction ?? Google_Spanner_V1_TransactionSelector()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  /// Required. The name of the table in the database to be read.
  public var table: String = String()

  /// If non-empty, the name of an index on [table][google.spanner.v1.ReadRequest.table]. This index is
  /// used instead of the table primary key when interpreting [key_set][google.spanner.v1.ReadRequest.key_set]
  /// and sorting result rows. See [key_set][google.spanner.v1.ReadRequest.key_set] for further information.
  public var index: String = String()

  /// Required. The columns of [table][google.spanner.v1.ReadRequest.table] to be returned for each row matching
  /// this request.
  public var columns: [String] = []

  /// Required. `key_set` identifies the rows to be yielded. `key_set` names the
  /// primary keys of the rows in [table][google.spanner.v1.ReadRequest.table] to be yielded, unless [index][google.spanner.v1.ReadRequest.index]
  /// is present. If [index][google.spanner.v1.ReadRequest.index] is present, then [key_set][google.spanner.v1.ReadRequest.key_set] instead names
  /// index keys in [index][google.spanner.v1.ReadRequest.index].
  ///
  /// If the [partition_token][google.spanner.v1.ReadRequest.partition_token] field is empty, rows are yielded
  /// in table primary key order (if [index][google.spanner.v1.ReadRequest.index] is empty) or index key order
  /// (if [index][google.spanner.v1.ReadRequest.index] is non-empty).  If the [partition_token][google.spanner.v1.ReadRequest.partition_token] field is not
  /// empty, rows will be yielded in an unspecified order.
  ///
  /// It is not an error for the `key_set` to name rows that do not
  /// exist in the database. Read yields nothing for nonexistent rows.
  public var keySet: Google_Spanner_V1_KeySet {
    get {return _keySet ?? Google_Spanner_V1_KeySet()}
    set {_keySet = newValue}
  }
  /// Returns true if `keySet` has been explicitly set.
  public var hasKeySet: Bool {return self._keySet != nil}
  /// Clears the value of `keySet`. Subsequent reads from it will return its default value.
  public mutating func clearKeySet() {self._keySet = nil}

  /// If greater than zero, only the first `limit` rows are yielded. If `limit`
  /// is zero, the default is no limit. A limit cannot be specified if
  /// `partition_token` is set.
  public var limit: Int64 = 0

  /// If this request is resuming a previously interrupted read,
  /// `resume_token` should be copied from the last
  /// [PartialResultSet][google.spanner.v1.PartialResultSet] yielded before the interruption. Doing this
  /// enables the new read to resume where the last read left off. The
  /// rest of the request parameters must exactly match the request
  /// that yielded this token.
  public var resumeToken: Data = Data()

  /// If present, results will be restricted to the specified partition
  /// previously created using PartitionRead().    There must be an exact
  /// match for the values of fields common to this message and the
  /// PartitionReadRequest message used to create this partition_token.
  public var partitionToken: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Google_Spanner_V1_TransactionSelector? = nil
  fileprivate var _keySet: Google_Spanner_V1_KeySet? = nil
}

/// The request for [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].
public struct Google_Spanner_V1_BeginTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session in which the transaction runs.
  public var session: String = String()

  /// Required. Options for the new transaction.
  public var options: Google_Spanner_V1_TransactionOptions {
    get {return _options ?? Google_Spanner_V1_TransactionOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  public var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  public mutating func clearOptions() {self._options = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _options: Google_Spanner_V1_TransactionOptions? = nil
}

/// The request for [Commit][google.spanner.v1.Spanner.Commit].
public struct Google_Spanner_V1_CommitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session in which the transaction to be committed is running.
  public var session: String = String()

  /// Required. The transaction in which to commit.
  public var transaction: Google_Spanner_V1_CommitRequest.OneOf_Transaction? = nil

  /// Commit a previously-started transaction.
  public var transactionID: Data {
    get {
      if case .transactionID(let v)? = transaction {return v}
      return Data()
    }
    set {transaction = .transactionID(newValue)}
  }

  /// Execute mutations in a temporary transaction. Note that unlike
  /// commit of a previously-started transaction, commit with a
  /// temporary transaction is non-idempotent. That is, if the
  /// `CommitRequest` is sent to Cloud Spanner more than once (for
  /// instance, due to retries in the application, or in the
  /// transport library), it is possible that the mutations are
  /// executed more than once. If this is undesirable, use
  /// [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction] and
  /// [Commit][google.spanner.v1.Spanner.Commit] instead.
  public var singleUseTransaction: Google_Spanner_V1_TransactionOptions {
    get {
      if case .singleUseTransaction(let v)? = transaction {return v}
      return Google_Spanner_V1_TransactionOptions()
    }
    set {transaction = .singleUseTransaction(newValue)}
  }

  /// The mutations to be executed when this transaction commits. All
  /// mutations are applied atomically, in the order they appear in
  /// this list.
  public var mutations: [Google_Spanner_V1_Mutation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The transaction in which to commit.
  public enum OneOf_Transaction: Equatable {
    /// Commit a previously-started transaction.
    case transactionID(Data)
    /// Execute mutations in a temporary transaction. Note that unlike
    /// commit of a previously-started transaction, commit with a
    /// temporary transaction is non-idempotent. That is, if the
    /// `CommitRequest` is sent to Cloud Spanner more than once (for
    /// instance, due to retries in the application, or in the
    /// transport library), it is possible that the mutations are
    /// executed more than once. If this is undesirable, use
    /// [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction] and
    /// [Commit][google.spanner.v1.Spanner.Commit] instead.
    case singleUseTransaction(Google_Spanner_V1_TransactionOptions)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Spanner_V1_CommitRequest.OneOf_Transaction, rhs: Google_Spanner_V1_CommitRequest.OneOf_Transaction) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transactionID, .transactionID): return {
        guard case .transactionID(let l) = lhs, case .transactionID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.singleUseTransaction, .singleUseTransaction): return {
        guard case .singleUseTransaction(let l) = lhs, case .singleUseTransaction(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// The response for [Commit][google.spanner.v1.Spanner.Commit].
public struct Google_Spanner_V1_CommitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Cloud Spanner timestamp at which the transaction committed.
  public var commitTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTimestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTimestamp = newValue}
  }
  /// Returns true if `commitTimestamp` has been explicitly set.
  public var hasCommitTimestamp: Bool {return self._commitTimestamp != nil}
  /// Clears the value of `commitTimestamp`. Subsequent reads from it will return its default value.
  public mutating func clearCommitTimestamp() {self._commitTimestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _commitTimestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [Rollback][google.spanner.v1.Spanner.Rollback].
public struct Google_Spanner_V1_RollbackRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The session in which the transaction to roll back is running.
  public var session: String = String()

  /// Required. The transaction to roll back.
  public var transactionID: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.spanner.v1"

extension Google_Spanner_V1_CreateSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateSessionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "session"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._session) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if let v = self._session {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_CreateSessionRequest, rhs: Google_Spanner_V1_CreateSessionRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs._session != rhs._session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_BatchCreateSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateSessionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "session_template"),
    3: .standard(proto: "session_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sessionTemplate) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.sessionCount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if let v = self._sessionTemplate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.sessionCount != 0 {
      try visitor.visitSingularInt32Field(value: self.sessionCount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_BatchCreateSessionsRequest, rhs: Google_Spanner_V1_BatchCreateSessionsRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs._sessionTemplate != rhs._sessionTemplate {return false}
    if lhs.sessionCount != rhs.sessionCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_BatchCreateSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchCreateSessionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.session) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.session, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_BatchCreateSessionsResponse, rhs: Google_Spanner_V1_BatchCreateSessionsResponse) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_Session: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Session"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "labels"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "approximate_last_use_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._approximateLastUseTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 2)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._approximateLastUseTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_Session, rhs: Google_Spanner_V1_Session) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._approximateLastUseTime != rhs._approximateLastUseTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_GetSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSessionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_GetSessionRequest, rhs: Google_Spanner_V1_GetSessionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ListSessionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSessionsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ListSessionsRequest, rhs: Google_Spanner_V1_ListSessionsRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ListSessionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSessionsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sessions"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ListSessionsResponse, rhs: Google_Spanner_V1_ListSessionsResponse) -> Bool {
    if lhs.sessions != rhs.sessions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_DeleteSessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteSessionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_DeleteSessionRequest, rhs: Google_Spanner_V1_DeleteSessionRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ExecuteSqlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteSqlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "transaction"),
    3: .same(proto: "sql"),
    4: .same(proto: "params"),
    5: .standard(proto: "param_types"),
    6: .standard(proto: "resume_token"),
    7: .standard(proto: "query_mode"),
    8: .standard(proto: "partition_token"),
    9: .same(proto: "seqno"),
    10: .standard(proto: "query_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sql) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Spanner_V1_Type>.self, value: &self.paramTypes) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.resumeToken) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.queryMode) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.partitionToken) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.seqno) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._queryOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.sql.isEmpty {
      try visitor.visitSingularStringField(value: self.sql, fieldNumber: 3)
    }
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.paramTypes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Spanner_V1_Type>.self, value: self.paramTypes, fieldNumber: 5)
    }
    if !self.resumeToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.resumeToken, fieldNumber: 6)
    }
    if self.queryMode != .normal {
      try visitor.visitSingularEnumField(value: self.queryMode, fieldNumber: 7)
    }
    if !self.partitionToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.partitionToken, fieldNumber: 8)
    }
    if self.seqno != 0 {
      try visitor.visitSingularInt64Field(value: self.seqno, fieldNumber: 9)
    }
    if let v = self._queryOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ExecuteSqlRequest, rhs: Google_Spanner_V1_ExecuteSqlRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.sql != rhs.sql {return false}
    if lhs._params != rhs._params {return false}
    if lhs.paramTypes != rhs.paramTypes {return false}
    if lhs.resumeToken != rhs.resumeToken {return false}
    if lhs.queryMode != rhs.queryMode {return false}
    if lhs.partitionToken != rhs.partitionToken {return false}
    if lhs.seqno != rhs.seqno {return false}
    if lhs._queryOptions != rhs._queryOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ExecuteSqlRequest.QueryMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "PLAN"),
    2: .same(proto: "PROFILE"),
  ]
}

extension Google_Spanner_V1_ExecuteSqlRequest.QueryOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Spanner_V1_ExecuteSqlRequest.protoMessageName + ".QueryOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "optimizer_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.optimizerVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.optimizerVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.optimizerVersion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ExecuteSqlRequest.QueryOptions, rhs: Google_Spanner_V1_ExecuteSqlRequest.QueryOptions) -> Bool {
    if lhs.optimizerVersion != rhs.optimizerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ExecuteBatchDmlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteBatchDmlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "transaction"),
    3: .same(proto: "statements"),
    4: .same(proto: "seqno"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.statements) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.seqno) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.statements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.statements, fieldNumber: 3)
    }
    if self.seqno != 0 {
      try visitor.visitSingularInt64Field(value: self.seqno, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ExecuteBatchDmlRequest, rhs: Google_Spanner_V1_ExecuteBatchDmlRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.statements != rhs.statements {return false}
    if lhs.seqno != rhs.seqno {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ExecuteBatchDmlRequest.Statement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Spanner_V1_ExecuteBatchDmlRequest.protoMessageName + ".Statement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sql"),
    2: .same(proto: "params"),
    3: .standard(proto: "param_types"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sql) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Spanner_V1_Type>.self, value: &self.paramTypes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sql.isEmpty {
      try visitor.visitSingularStringField(value: self.sql, fieldNumber: 1)
    }
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.paramTypes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Spanner_V1_Type>.self, value: self.paramTypes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ExecuteBatchDmlRequest.Statement, rhs: Google_Spanner_V1_ExecuteBatchDmlRequest.Statement) -> Bool {
    if lhs.sql != rhs.sql {return false}
    if lhs._params != rhs._params {return false}
    if lhs.paramTypes != rhs.paramTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ExecuteBatchDmlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteBatchDmlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_sets"),
    2: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.resultSets) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resultSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resultSets, fieldNumber: 1)
    }
    if let v = self._status {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ExecuteBatchDmlResponse, rhs: Google_Spanner_V1_ExecuteBatchDmlResponse) -> Bool {
    if lhs.resultSets != rhs.resultSets {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_PartitionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "partition_size_bytes"),
    2: .standard(proto: "max_partitions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.partitionSizeBytes) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.maxPartitions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.partitionSizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.partitionSizeBytes, fieldNumber: 1)
    }
    if self.maxPartitions != 0 {
      try visitor.visitSingularInt64Field(value: self.maxPartitions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_PartitionOptions, rhs: Google_Spanner_V1_PartitionOptions) -> Bool {
    if lhs.partitionSizeBytes != rhs.partitionSizeBytes {return false}
    if lhs.maxPartitions != rhs.maxPartitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_PartitionQueryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionQueryRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "transaction"),
    3: .same(proto: "sql"),
    4: .same(proto: "params"),
    5: .standard(proto: "param_types"),
    6: .standard(proto: "partition_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sql) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._params) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Spanner_V1_Type>.self, value: &self.paramTypes) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._partitionOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.sql.isEmpty {
      try visitor.visitSingularStringField(value: self.sql, fieldNumber: 3)
    }
    if let v = self._params {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.paramTypes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Spanner_V1_Type>.self, value: self.paramTypes, fieldNumber: 5)
    }
    if let v = self._partitionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_PartitionQueryRequest, rhs: Google_Spanner_V1_PartitionQueryRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.sql != rhs.sql {return false}
    if lhs._params != rhs._params {return false}
    if lhs.paramTypes != rhs.paramTypes {return false}
    if lhs._partitionOptions != rhs._partitionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_PartitionReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionReadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "transaction"),
    3: .same(proto: "table"),
    4: .same(proto: "index"),
    5: .same(proto: "columns"),
    6: .standard(proto: "key_set"),
    9: .standard(proto: "partition_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.table) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.index) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.columns) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._keySet) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._partitionOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.table.isEmpty {
      try visitor.visitSingularStringField(value: self.table, fieldNumber: 3)
    }
    if !self.index.isEmpty {
      try visitor.visitSingularStringField(value: self.index, fieldNumber: 4)
    }
    if !self.columns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.columns, fieldNumber: 5)
    }
    if let v = self._keySet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._partitionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_PartitionReadRequest, rhs: Google_Spanner_V1_PartitionReadRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.table != rhs.table {return false}
    if lhs.index != rhs.index {return false}
    if lhs.columns != rhs.columns {return false}
    if lhs._keySet != rhs._keySet {return false}
    if lhs._partitionOptions != rhs._partitionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_Partition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Partition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "partition_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.partitionToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partitionToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.partitionToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_Partition, rhs: Google_Spanner_V1_Partition) -> Bool {
    if lhs.partitionToken != rhs.partitionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_PartitionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PartitionResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "partitions"),
    2: .same(proto: "transaction"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.partitions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.partitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.partitions, fieldNumber: 1)
    }
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_PartitionResponse, rhs: Google_Spanner_V1_PartitionResponse) -> Bool {
    if lhs.partitions != rhs.partitions {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_ReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReadRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "transaction"),
    3: .same(proto: "table"),
    4: .same(proto: "index"),
    5: .same(proto: "columns"),
    6: .standard(proto: "key_set"),
    8: .same(proto: "limit"),
    9: .standard(proto: "resume_token"),
    10: .standard(proto: "partition_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._transaction) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.table) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.index) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.columns) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._keySet) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.limit) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.resumeToken) }()
      case 10: try { try decoder.decodeSingularBytesField(value: &self.partitionToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.table.isEmpty {
      try visitor.visitSingularStringField(value: self.table, fieldNumber: 3)
    }
    if !self.index.isEmpty {
      try visitor.visitSingularStringField(value: self.index, fieldNumber: 4)
    }
    if !self.columns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.columns, fieldNumber: 5)
    }
    if let v = self._keySet {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if self.limit != 0 {
      try visitor.visitSingularInt64Field(value: self.limit, fieldNumber: 8)
    }
    if !self.resumeToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.resumeToken, fieldNumber: 9)
    }
    if !self.partitionToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.partitionToken, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_ReadRequest, rhs: Google_Spanner_V1_ReadRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs._transaction != rhs._transaction {return false}
    if lhs.table != rhs.table {return false}
    if lhs.index != rhs.index {return false}
    if lhs.columns != rhs.columns {return false}
    if lhs._keySet != rhs._keySet {return false}
    if lhs.limit != rhs.limit {return false}
    if lhs.resumeToken != rhs.resumeToken {return false}
    if lhs.partitionToken != rhs.partitionToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_BeginTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BeginTransactionRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .same(proto: "options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_BeginTransactionRequest, rhs: Google_Spanner_V1_BeginTransactionRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs._options != rhs._options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_CommitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "single_use_transaction"),
    4: .same(proto: "mutations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try {
        if self.transaction != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.transaction = .transactionID(v)}
      }()
      case 3: try {
        var v: Google_Spanner_V1_TransactionOptions?
        if let current = self.transaction {
          try decoder.handleConflictingOneOf()
          if case .singleUseTransaction(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.transaction = .singleUseTransaction(v)}
      }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.mutations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.transaction {
    case .transactionID?: try {
      guard case .transactionID(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }()
    case .singleUseTransaction?: try {
      guard case .singleUseTransaction(let v)? = self.transaction else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.mutations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mutations, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_CommitRequest, rhs: Google_Spanner_V1_CommitRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.mutations != rhs.mutations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_CommitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommitResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "commit_timestamp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._commitTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._commitTimestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_CommitResponse, rhs: Google_Spanner_V1_CommitResponse) -> Bool {
    if lhs._commitTimestamp != rhs._commitTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_V1_RollbackRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "session"),
    2: .standard(proto: "transaction_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.session) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.transactionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.session.isEmpty {
      try visitor.visitSingularStringField(value: self.session, fieldNumber: 1)
    }
    if !self.transactionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.transactionID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_V1_RollbackRequest, rhs: Google_Spanner_V1_RollbackRequest) -> Bool {
    if lhs.session != rhs.session {return false}
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

//
// DO NOT EDIT.
//
// Generated by the protocol buffer compiler.
// Source: google/spanner/v1/spanner.proto
//

//
// Copyright 2018, gRPC Authors All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
import GRPC
import NIO
import SwiftProtobuf


/// Usage: instantiate Google_Spanner_V1_SpannerClient, then call methods of this protocol to make API calls.
public protocol Google_Spanner_V1_SpannerClientProtocol: GRPCClient {
  func createSession(
    _ request: Google_Spanner_V1_CreateSessionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_CreateSessionRequest, Google_Spanner_V1_Session>

  func batchCreateSessions(
    _ request: Google_Spanner_V1_BatchCreateSessionsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_BatchCreateSessionsRequest, Google_Spanner_V1_BatchCreateSessionsResponse>

  func getSession(
    _ request: Google_Spanner_V1_GetSessionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_GetSessionRequest, Google_Spanner_V1_Session>

  func listSessions(
    _ request: Google_Spanner_V1_ListSessionsRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_ListSessionsRequest, Google_Spanner_V1_ListSessionsResponse>

  func deleteSession(
    _ request: Google_Spanner_V1_DeleteSessionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_DeleteSessionRequest, SwiftProtobuf.Google_Protobuf_Empty>

  func executeSql(
    _ request: Google_Spanner_V1_ExecuteSqlRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_ExecuteSqlRequest, Google_Spanner_V1_ResultSet>

  func executeStreamingSql(
    _ request: Google_Spanner_V1_ExecuteSqlRequest,
    callOptions: CallOptions?,
    handler: @escaping (Google_Spanner_V1_PartialResultSet) -> Void
  ) -> ServerStreamingCall<Google_Spanner_V1_ExecuteSqlRequest, Google_Spanner_V1_PartialResultSet>

  func executeBatchDml(
    _ request: Google_Spanner_V1_ExecuteBatchDmlRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_ExecuteBatchDmlRequest, Google_Spanner_V1_ExecuteBatchDmlResponse>

  func read(
    _ request: Google_Spanner_V1_ReadRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_ReadRequest, Google_Spanner_V1_ResultSet>

  func streamingRead(
    _ request: Google_Spanner_V1_ReadRequest,
    callOptions: CallOptions?,
    handler: @escaping (Google_Spanner_V1_PartialResultSet) -> Void
  ) -> ServerStreamingCall<Google_Spanner_V1_ReadRequest, Google_Spanner_V1_PartialResultSet>

  func beginTransaction(
    _ request: Google_Spanner_V1_BeginTransactionRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_BeginTransactionRequest, Google_Spanner_V1_Transaction>

  func commit(
    _ request: Google_Spanner_V1_CommitRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_CommitRequest, Google_Spanner_V1_CommitResponse>

  func rollback(
    _ request: Google_Spanner_V1_RollbackRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_RollbackRequest, SwiftProtobuf.Google_Protobuf_Empty>

  func partitionQuery(
    _ request: Google_Spanner_V1_PartitionQueryRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_PartitionQueryRequest, Google_Spanner_V1_PartitionResponse>

  func partitionRead(
    _ request: Google_Spanner_V1_PartitionReadRequest,
    callOptions: CallOptions?
  ) -> UnaryCall<Google_Spanner_V1_PartitionReadRequest, Google_Spanner_V1_PartitionResponse>

}

extension Google_Spanner_V1_SpannerClientProtocol {

  /// Creates a new session. A session can be used to perform
  /// transactions that read and/or modify data in a Cloud Spanner database.
  /// Sessions are meant to be reused for many consecutive
  /// transactions.
  ///
  /// Sessions can only execute one transaction at a time. To execute
  /// multiple concurrent read-write/write-only transactions, create
  /// multiple sessions. Note that standalone reads and queries use a
  /// transaction internally, and count toward the one transaction
  /// limit.
  ///
  /// Active sessions use additional server resources, so it is a good idea to
  /// delete idle and unneeded sessions.
  /// Aside from explicit deletes, Cloud Spanner may delete sessions for which no
  /// operations are sent for more than an hour. If a session is deleted,
  /// requests to it return `NOT_FOUND`.
  ///
  /// Idle sessions can be kept alive by sending a trivial SQL query
  /// periodically, e.g., `"SELECT 1"`.
  ///
  /// - Parameters:
  ///   - request: Request to send to CreateSession.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func createSession(
    _ request: Google_Spanner_V1_CreateSessionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_CreateSessionRequest, Google_Spanner_V1_Session> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/CreateSession",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Creates multiple new sessions.
  ///
  /// This API can be used to initialize a session cache on the clients.
  /// See https://goo.gl/TgSFN2 for best practices on session cache management.
  ///
  /// - Parameters:
  ///   - request: Request to send to BatchCreateSessions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func batchCreateSessions(
    _ request: Google_Spanner_V1_BatchCreateSessionsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_BatchCreateSessionsRequest, Google_Spanner_V1_BatchCreateSessionsResponse> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/BatchCreateSessions",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Gets a session. Returns `NOT_FOUND` if the session does not exist.
  /// This is mainly useful for determining whether a session is still
  /// alive.
  ///
  /// - Parameters:
  ///   - request: Request to send to GetSession.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func getSession(
    _ request: Google_Spanner_V1_GetSessionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_GetSessionRequest, Google_Spanner_V1_Session> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/GetSession",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Lists all sessions in a given database.
  ///
  /// - Parameters:
  ///   - request: Request to send to ListSessions.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func listSessions(
    _ request: Google_Spanner_V1_ListSessionsRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_ListSessionsRequest, Google_Spanner_V1_ListSessionsResponse> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/ListSessions",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Ends a session, releasing server resources associated with it. This will
  /// asynchronously trigger cancellation of any operations that are running with
  /// this session.
  ///
  /// - Parameters:
  ///   - request: Request to send to DeleteSession.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func deleteSession(
    _ request: Google_Spanner_V1_DeleteSessionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_DeleteSessionRequest, SwiftProtobuf.Google_Protobuf_Empty> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/DeleteSession",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Executes an SQL statement, returning all results in a single reply. This
  /// method cannot be used to return a result set larger than 10 MiB;
  /// if the query yields more data than that, the query fails with
  /// a `FAILED_PRECONDITION` error.
  ///
  /// Operations inside read-write transactions might return `ABORTED`. If
  /// this occurs, the application should restart the transaction from
  /// the beginning. See [Transaction][google.spanner.v1.Transaction] for more details.
  ///
  /// Larger result sets can be fetched in streaming fashion by calling
  /// [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] instead.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExecuteSql.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func executeSql(
    _ request: Google_Spanner_V1_ExecuteSqlRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_ExecuteSqlRequest, Google_Spanner_V1_ResultSet> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/ExecuteSql",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Like [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], except returns the result
  /// set as a stream. Unlike [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], there
  /// is no limit on the size of the returned result set. However, no
  /// individual row in the result set can exceed 100 MiB, and no
  /// column value can exceed 10 MiB.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExecuteStreamingSql.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func executeStreamingSql(
    _ request: Google_Spanner_V1_ExecuteSqlRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Google_Spanner_V1_PartialResultSet) -> Void
  ) -> ServerStreamingCall<Google_Spanner_V1_ExecuteSqlRequest, Google_Spanner_V1_PartialResultSet> {
    return self.makeServerStreamingCall(
      path: "/google.spanner.v1.Spanner/ExecuteStreamingSql",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      handler: handler
    )
  }

  /// Executes a batch of SQL DML statements. This method allows many statements
  /// to be run with lower latency than submitting them sequentially with
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].
  ///
  /// Statements are executed in sequential order. A request can succeed even if
  /// a statement fails. The [ExecuteBatchDmlResponse.status][google.spanner.v1.ExecuteBatchDmlResponse.status] field in the
  /// response provides information about the statement that failed. Clients must
  /// inspect this field to determine whether an error occurred.
  ///
  /// Execution stops after the first failed statement; the remaining statements
  /// are not executed.
  ///
  /// - Parameters:
  ///   - request: Request to send to ExecuteBatchDml.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func executeBatchDml(
    _ request: Google_Spanner_V1_ExecuteBatchDmlRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_ExecuteBatchDmlRequest, Google_Spanner_V1_ExecuteBatchDmlResponse> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/ExecuteBatchDml",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Reads rows from the database using key lookups and scans, as a
  /// simple key/value style alternative to
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].  This method cannot be used to
  /// return a result set larger than 10 MiB; if the read matches more
  /// data than that, the read fails with a `FAILED_PRECONDITION`
  /// error.
  ///
  /// Reads inside read-write transactions might return `ABORTED`. If
  /// this occurs, the application should restart the transaction from
  /// the beginning. See [Transaction][google.spanner.v1.Transaction] for more details.
  ///
  /// Larger result sets can be yielded in streaming fashion by calling
  /// [StreamingRead][google.spanner.v1.Spanner.StreamingRead] instead.
  ///
  /// - Parameters:
  ///   - request: Request to send to Read.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func read(
    _ request: Google_Spanner_V1_ReadRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_ReadRequest, Google_Spanner_V1_ResultSet> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/Read",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Like [Read][google.spanner.v1.Spanner.Read], except returns the result set as a
  /// stream. Unlike [Read][google.spanner.v1.Spanner.Read], there is no limit on the
  /// size of the returned result set. However, no individual row in
  /// the result set can exceed 100 MiB, and no column value can exceed
  /// 10 MiB.
  ///
  /// - Parameters:
  ///   - request: Request to send to StreamingRead.
  ///   - callOptions: Call options.
  ///   - handler: A closure called when each response is received from the server.
  /// - Returns: A `ServerStreamingCall` with futures for the metadata and status.
  public func streamingRead(
    _ request: Google_Spanner_V1_ReadRequest,
    callOptions: CallOptions? = nil,
    handler: @escaping (Google_Spanner_V1_PartialResultSet) -> Void
  ) -> ServerStreamingCall<Google_Spanner_V1_ReadRequest, Google_Spanner_V1_PartialResultSet> {
    return self.makeServerStreamingCall(
      path: "/google.spanner.v1.Spanner/StreamingRead",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions,
      handler: handler
    )
  }

  /// Begins a new transaction. This step can often be skipped:
  /// [Read][google.spanner.v1.Spanner.Read], [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
  /// [Commit][google.spanner.v1.Spanner.Commit] can begin a new transaction as a
  /// side-effect.
  ///
  /// - Parameters:
  ///   - request: Request to send to BeginTransaction.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func beginTransaction(
    _ request: Google_Spanner_V1_BeginTransactionRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_BeginTransactionRequest, Google_Spanner_V1_Transaction> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/BeginTransaction",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Commits a transaction. The request includes the mutations to be
  /// applied to rows in the database.
  ///
  /// `Commit` might return an `ABORTED` error. This can occur at any time;
  /// commonly, the cause is conflicts with concurrent
  /// transactions. However, it can also happen for a variety of other
  /// reasons. If `Commit` returns `ABORTED`, the caller should re-attempt
  /// the transaction from the beginning, re-using the same session.
  ///
  /// - Parameters:
  ///   - request: Request to send to Commit.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func commit(
    _ request: Google_Spanner_V1_CommitRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_CommitRequest, Google_Spanner_V1_CommitResponse> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/Commit",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Rolls back a transaction, releasing any locks it holds. It is a good
  /// idea to call this for any transaction that includes one or more
  /// [Read][google.spanner.v1.Spanner.Read] or [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] requests and
  /// ultimately decides not to commit.
  ///
  /// `Rollback` returns `OK` if it successfully aborts the transaction, the
  /// transaction was already aborted, or the transaction is not
  /// found. `Rollback` never returns `ABORTED`.
  ///
  /// - Parameters:
  ///   - request: Request to send to Rollback.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func rollback(
    _ request: Google_Spanner_V1_RollbackRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_RollbackRequest, SwiftProtobuf.Google_Protobuf_Empty> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/Rollback",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Creates a set of partition tokens that can be used to execute a query
  /// operation in parallel.  Each of the returned partition tokens can be used
  /// by [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] to specify a subset
  /// of the query result to read.  The same session and read-only transaction
  /// must be used by the PartitionQueryRequest used to create the
  /// partition tokens and the ExecuteSqlRequests that use the partition tokens.
  ///
  /// Partition tokens become invalid when the session used to create them
  /// is deleted, is idle for too long, begins a new transaction, or becomes too
  /// old.  When any of these happen, it is not possible to resume the query, and
  /// the whole operation must be restarted from the beginning.
  ///
  /// - Parameters:
  ///   - request: Request to send to PartitionQuery.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func partitionQuery(
    _ request: Google_Spanner_V1_PartitionQueryRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_PartitionQueryRequest, Google_Spanner_V1_PartitionResponse> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/PartitionQuery",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }

  /// Creates a set of partition tokens that can be used to execute a read
  /// operation in parallel.  Each of the returned partition tokens can be used
  /// by [StreamingRead][google.spanner.v1.Spanner.StreamingRead] to specify a subset of the read
  /// result to read.  The same session and read-only transaction must be used by
  /// the PartitionReadRequest used to create the partition tokens and the
  /// ReadRequests that use the partition tokens.  There are no ordering
  /// guarantees on rows returned among the returned partition tokens, or even
  /// within each individual StreamingRead call issued with a partition_token.
  ///
  /// Partition tokens become invalid when the session used to create them
  /// is deleted, is idle for too long, begins a new transaction, or becomes too
  /// old.  When any of these happen, it is not possible to resume the read, and
  /// the whole operation must be restarted from the beginning.
  ///
  /// - Parameters:
  ///   - request: Request to send to PartitionRead.
  ///   - callOptions: Call options.
  /// - Returns: A `UnaryCall` with futures for the metadata, status and response.
  public func partitionRead(
    _ request: Google_Spanner_V1_PartitionReadRequest,
    callOptions: CallOptions? = nil
  ) -> UnaryCall<Google_Spanner_V1_PartitionReadRequest, Google_Spanner_V1_PartitionResponse> {
    return self.makeUnaryCall(
      path: "/google.spanner.v1.Spanner/PartitionRead",
      request: request,
      callOptions: callOptions ?? self.defaultCallOptions
    )
  }
}

public final class Google_Spanner_V1_SpannerClient: Google_Spanner_V1_SpannerClientProtocol {
  public let channel: GRPCChannel
  public var defaultCallOptions: CallOptions

  /// Creates a client for the google.spanner.v1.Spanner service.
  ///
  /// - Parameters:
  ///   - channel: `GRPCChannel` to the service host.
  ///   - defaultCallOptions: Options to use for each service call if the user doesn't provide them.
  public init(channel: GRPCChannel, defaultCallOptions: CallOptions = CallOptions()) {
    self.channel = channel
    self.defaultCallOptions = defaultCallOptions
  }
}

/// To build a server, implement a class that conforms to this protocol.
public protocol Google_Spanner_V1_SpannerProvider: CallHandlerProvider {
  /// Creates a new session. A session can be used to perform
  /// transactions that read and/or modify data in a Cloud Spanner database.
  /// Sessions are meant to be reused for many consecutive
  /// transactions.
  ///
  /// Sessions can only execute one transaction at a time. To execute
  /// multiple concurrent read-write/write-only transactions, create
  /// multiple sessions. Note that standalone reads and queries use a
  /// transaction internally, and count toward the one transaction
  /// limit.
  ///
  /// Active sessions use additional server resources, so it is a good idea to
  /// delete idle and unneeded sessions.
  /// Aside from explicit deletes, Cloud Spanner may delete sessions for which no
  /// operations are sent for more than an hour. If a session is deleted,
  /// requests to it return `NOT_FOUND`.
  ///
  /// Idle sessions can be kept alive by sending a trivial SQL query
  /// periodically, e.g., `"SELECT 1"`.
  func createSession(request: Google_Spanner_V1_CreateSessionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_Session>
  /// Creates multiple new sessions.
  ///
  /// This API can be used to initialize a session cache on the clients.
  /// See https://goo.gl/TgSFN2 for best practices on session cache management.
  func batchCreateSessions(request: Google_Spanner_V1_BatchCreateSessionsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_BatchCreateSessionsResponse>
  /// Gets a session. Returns `NOT_FOUND` if the session does not exist.
  /// This is mainly useful for determining whether a session is still
  /// alive.
  func getSession(request: Google_Spanner_V1_GetSessionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_Session>
  /// Lists all sessions in a given database.
  func listSessions(request: Google_Spanner_V1_ListSessionsRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_ListSessionsResponse>
  /// Ends a session, releasing server resources associated with it. This will
  /// asynchronously trigger cancellation of any operations that are running with
  /// this session.
  func deleteSession(request: Google_Spanner_V1_DeleteSessionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<SwiftProtobuf.Google_Protobuf_Empty>
  /// Executes an SQL statement, returning all results in a single reply. This
  /// method cannot be used to return a result set larger than 10 MiB;
  /// if the query yields more data than that, the query fails with
  /// a `FAILED_PRECONDITION` error.
  ///
  /// Operations inside read-write transactions might return `ABORTED`. If
  /// this occurs, the application should restart the transaction from
  /// the beginning. See [Transaction][google.spanner.v1.Transaction] for more details.
  ///
  /// Larger result sets can be fetched in streaming fashion by calling
  /// [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] instead.
  func executeSql(request: Google_Spanner_V1_ExecuteSqlRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_ResultSet>
  /// Like [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], except returns the result
  /// set as a stream. Unlike [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql], there
  /// is no limit on the size of the returned result set. However, no
  /// individual row in the result set can exceed 100 MiB, and no
  /// column value can exceed 10 MiB.
  func executeStreamingSql(request: Google_Spanner_V1_ExecuteSqlRequest, context: StreamingResponseCallContext<Google_Spanner_V1_PartialResultSet>) -> EventLoopFuture<GRPCStatus>
  /// Executes a batch of SQL DML statements. This method allows many statements
  /// to be run with lower latency than submitting them sequentially with
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].
  ///
  /// Statements are executed in sequential order. A request can succeed even if
  /// a statement fails. The [ExecuteBatchDmlResponse.status][google.spanner.v1.ExecuteBatchDmlResponse.status] field in the
  /// response provides information about the statement that failed. Clients must
  /// inspect this field to determine whether an error occurred.
  ///
  /// Execution stops after the first failed statement; the remaining statements
  /// are not executed.
  func executeBatchDml(request: Google_Spanner_V1_ExecuteBatchDmlRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_ExecuteBatchDmlResponse>
  /// Reads rows from the database using key lookups and scans, as a
  /// simple key/value style alternative to
  /// [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].  This method cannot be used to
  /// return a result set larger than 10 MiB; if the read matches more
  /// data than that, the read fails with a `FAILED_PRECONDITION`
  /// error.
  ///
  /// Reads inside read-write transactions might return `ABORTED`. If
  /// this occurs, the application should restart the transaction from
  /// the beginning. See [Transaction][google.spanner.v1.Transaction] for more details.
  ///
  /// Larger result sets can be yielded in streaming fashion by calling
  /// [StreamingRead][google.spanner.v1.Spanner.StreamingRead] instead.
  func read(request: Google_Spanner_V1_ReadRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_ResultSet>
  /// Like [Read][google.spanner.v1.Spanner.Read], except returns the result set as a
  /// stream. Unlike [Read][google.spanner.v1.Spanner.Read], there is no limit on the
  /// size of the returned result set. However, no individual row in
  /// the result set can exceed 100 MiB, and no column value can exceed
  /// 10 MiB.
  func streamingRead(request: Google_Spanner_V1_ReadRequest, context: StreamingResponseCallContext<Google_Spanner_V1_PartialResultSet>) -> EventLoopFuture<GRPCStatus>
  /// Begins a new transaction. This step can often be skipped:
  /// [Read][google.spanner.v1.Spanner.Read], [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
  /// [Commit][google.spanner.v1.Spanner.Commit] can begin a new transaction as a
  /// side-effect.
  func beginTransaction(request: Google_Spanner_V1_BeginTransactionRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_Transaction>
  /// Commits a transaction. The request includes the mutations to be
  /// applied to rows in the database.
  ///
  /// `Commit` might return an `ABORTED` error. This can occur at any time;
  /// commonly, the cause is conflicts with concurrent
  /// transactions. However, it can also happen for a variety of other
  /// reasons. If `Commit` returns `ABORTED`, the caller should re-attempt
  /// the transaction from the beginning, re-using the same session.
  func commit(request: Google_Spanner_V1_CommitRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_CommitResponse>
  /// Rolls back a transaction, releasing any locks it holds. It is a good
  /// idea to call this for any transaction that includes one or more
  /// [Read][google.spanner.v1.Spanner.Read] or [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] requests and
  /// ultimately decides not to commit.
  ///
  /// `Rollback` returns `OK` if it successfully aborts the transaction, the
  /// transaction was already aborted, or the transaction is not
  /// found. `Rollback` never returns `ABORTED`.
  func rollback(request: Google_Spanner_V1_RollbackRequest, context: StatusOnlyCallContext) -> EventLoopFuture<SwiftProtobuf.Google_Protobuf_Empty>
  /// Creates a set of partition tokens that can be used to execute a query
  /// operation in parallel.  Each of the returned partition tokens can be used
  /// by [ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql] to specify a subset
  /// of the query result to read.  The same session and read-only transaction
  /// must be used by the PartitionQueryRequest used to create the
  /// partition tokens and the ExecuteSqlRequests that use the partition tokens.
  ///
  /// Partition tokens become invalid when the session used to create them
  /// is deleted, is idle for too long, begins a new transaction, or becomes too
  /// old.  When any of these happen, it is not possible to resume the query, and
  /// the whole operation must be restarted from the beginning.
  func partitionQuery(request: Google_Spanner_V1_PartitionQueryRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_PartitionResponse>
  /// Creates a set of partition tokens that can be used to execute a read
  /// operation in parallel.  Each of the returned partition tokens can be used
  /// by [StreamingRead][google.spanner.v1.Spanner.StreamingRead] to specify a subset of the read
  /// result to read.  The same session and read-only transaction must be used by
  /// the PartitionReadRequest used to create the partition tokens and the
  /// ReadRequests that use the partition tokens.  There are no ordering
  /// guarantees on rows returned among the returned partition tokens, or even
  /// within each individual StreamingRead call issued with a partition_token.
  ///
  /// Partition tokens become invalid when the session used to create them
  /// is deleted, is idle for too long, begins a new transaction, or becomes too
  /// old.  When any of these happen, it is not possible to resume the read, and
  /// the whole operation must be restarted from the beginning.
  func partitionRead(request: Google_Spanner_V1_PartitionReadRequest, context: StatusOnlyCallContext) -> EventLoopFuture<Google_Spanner_V1_PartitionResponse>
}

extension Google_Spanner_V1_SpannerProvider {
  public var serviceName: Substring { return "google.spanner.v1.Spanner" }

  /// Determines, calls and returns the appropriate request handler, depending on the request's method.
  /// Returns nil for methods not handled by this service.
  public func handleMethod(_ methodName: Substring, callHandlerContext: CallHandlerContext) -> GRPCCallHandler? {
    switch methodName {
    case "CreateSession":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.createSession(request: request, context: context)
        }
      }

    case "BatchCreateSessions":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.batchCreateSessions(request: request, context: context)
        }
      }

    case "GetSession":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.getSession(request: request, context: context)
        }
      }

    case "ListSessions":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.listSessions(request: request, context: context)
        }
      }

    case "DeleteSession":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.deleteSession(request: request, context: context)
        }
      }

    case "ExecuteSql":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.executeSql(request: request, context: context)
        }
      }

    case "ExecuteStreamingSql":
      return CallHandlerFactory.makeServerStreaming(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.executeStreamingSql(request: request, context: context)
        }
      }

    case "ExecuteBatchDml":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.executeBatchDml(request: request, context: context)
        }
      }

    case "Read":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.read(request: request, context: context)
        }
      }

    case "StreamingRead":
      return CallHandlerFactory.makeServerStreaming(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.streamingRead(request: request, context: context)
        }
      }

    case "BeginTransaction":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.beginTransaction(request: request, context: context)
        }
      }

    case "Commit":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.commit(request: request, context: context)
        }
      }

    case "Rollback":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.rollback(request: request, context: context)
        }
      }

    case "PartitionQuery":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.partitionQuery(request: request, context: context)
        }
      }

    case "PartitionRead":
      return CallHandlerFactory.makeUnary(callHandlerContext: callHandlerContext) { context in
        return { request in
          self.partitionRead(request: request, context: context)
        }
      }

    default: return nil
    }
  }
}


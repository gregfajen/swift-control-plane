// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/spanner/admin/database/v1/spanner_database_admin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Indicates the type of the restore source.
public enum Google_Spanner_Admin_Database_V1_RestoreSourceType: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// No restore associated.
  case typeUnspecified // = 0

  /// A backup was used as the source of the restore.
  case backup // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .typeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .typeUnspecified
    case 1: self = .backup
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .typeUnspecified: return 0
    case .backup: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Spanner_Admin_Database_V1_RestoreSourceType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Spanner_Admin_Database_V1_RestoreSourceType] = [
    .typeUnspecified,
    .backup,
  ]
}

#endif  // swift(>=4.2)

/// Information about the database restore.
public struct Google_Spanner_Admin_Database_V1_RestoreInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of the restore source.
  public var sourceType: Google_Spanner_Admin_Database_V1_RestoreSourceType = .typeUnspecified

  /// Information about the source used to restore the database.
  public var sourceInfo: Google_Spanner_Admin_Database_V1_RestoreInfo.OneOf_SourceInfo? = nil

  /// Information about the backup used to restore the database. The backup
  /// may no longer exist.
  public var backupInfo: Google_Spanner_Admin_Database_V1_BackupInfo {
    get {
      if case .backupInfo(let v)? = sourceInfo {return v}
      return Google_Spanner_Admin_Database_V1_BackupInfo()
    }
    set {sourceInfo = .backupInfo(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information about the source used to restore the database.
  public enum OneOf_SourceInfo: Equatable {
    /// Information about the backup used to restore the database. The backup
    /// may no longer exist.
    case backupInfo(Google_Spanner_Admin_Database_V1_BackupInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Spanner_Admin_Database_V1_RestoreInfo.OneOf_SourceInfo, rhs: Google_Spanner_Admin_Database_V1_RestoreInfo.OneOf_SourceInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.backupInfo, .backupInfo): return {
        guard case .backupInfo(let l) = lhs, case .backupInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// A Cloud Spanner database.
public struct Google_Spanner_Admin_Database_V1_Database {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the database. Values are of the form
  /// `projects/<project>/instances/<instance>/databases/<database>`,
  /// where `<database>` is as specified in the `CREATE DATABASE`
  /// statement. This name can be passed to other API methods to
  /// identify the database.
  public var name: String = String()

  /// Output only. The current database state.
  public var state: Google_Spanner_Admin_Database_V1_Database.State = .unspecified

  /// Output only. If exists, the time at which the database creation started.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Applicable only for restored databases. Contains information
  /// about the restore source.
  public var restoreInfo: Google_Spanner_Admin_Database_V1_RestoreInfo {
    get {return _restoreInfo ?? Google_Spanner_Admin_Database_V1_RestoreInfo()}
    set {_restoreInfo = newValue}
  }
  /// Returns true if `restoreInfo` has been explicitly set.
  public var hasRestoreInfo: Bool {return self._restoreInfo != nil}
  /// Clears the value of `restoreInfo`. Subsequent reads from it will return its default value.
  public mutating func clearRestoreInfo() {self._restoreInfo = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the current state of the database.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// The database is still being created. Operations on the database may fail
    /// with `FAILED_PRECONDITION` in this state.
    case creating // = 1

    /// The database is fully created and ready for use.
    case ready // = 2

    /// The database is fully created and ready for use, but is still
    /// being optimized for performance and cannot handle full load.
    ///
    /// In this state, the database still references the backup
    /// it was restore from, preventing the backup
    /// from being deleted. When optimizations are complete, the full performance
    /// of the database will be restored, and the database will transition to
    /// `READY` state.
    case readyOptimizing // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .ready
      case 3: self = .readyOptimizing
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .ready: return 2
      case .readyOptimizing: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _restoreInfo: Google_Spanner_Admin_Database_V1_RestoreInfo? = nil
}

#if swift(>=4.2)

extension Google_Spanner_Admin_Database_V1_Database.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Spanner_Admin_Database_V1_Database.State] = [
    .unspecified,
    .creating,
    .ready,
    .readyOptimizing,
  ]
}

#endif  // swift(>=4.2)

/// The request for [ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases].
public struct Google_Spanner_Admin_Database_V1_ListDatabasesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The instance whose databases should be listed.
  /// Values are of the form `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// Number of databases to be returned in the response. If 0 or less,
  /// defaults to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.admin.database.v1.ListDatabasesResponse.next_page_token] from a
  /// previous [ListDatabasesResponse][google.spanner.admin.database.v1.ListDatabasesResponse].
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases].
public struct Google_Spanner_Admin_Database_V1_ListDatabasesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Databases that matched the request.
  public var databases: [Google_Spanner_Admin_Database_V1_Database] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListDatabases][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabases] call to fetch more
  /// of the matching databases.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [CreateDatabase][google.spanner.admin.database.v1.DatabaseAdmin.CreateDatabase].
public struct Google_Spanner_Admin_Database_V1_CreateDatabaseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the instance that will serve the new database.
  /// Values are of the form `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// Required. A `CREATE DATABASE` statement, which specifies the ID of the
  /// new database.  The database ID must conform to the regular expression
  /// `[a-z][a-z0-9_\-]*[a-z0-9]` and be between 2 and 30 characters in length.
  /// If the database ID is a reserved word or if it contains a hyphen, the
  /// database ID must be enclosed in backticks (`` ` ``).
  public var createStatement: String = String()

  /// Optional. A list of DDL statements to run inside the newly created
  /// database. Statements can create tables, indexes, etc. These
  /// statements execute atomically with the creation of the database:
  /// if there is an error in any statement, the database is not created.
  public var extraStatements: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata type for the operation returned by
/// [CreateDatabase][google.spanner.admin.database.v1.DatabaseAdmin.CreateDatabase].
public struct Google_Spanner_Admin_Database_V1_CreateDatabaseMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database being created.
  public var database: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [GetDatabase][google.spanner.admin.database.v1.DatabaseAdmin.GetDatabase].
public struct Google_Spanner_Admin_Database_V1_GetDatabaseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the requested database. Values are of the form
  /// `projects/<project>/instances/<instance>/databases/<database>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Enqueues the given DDL statements to be applied, in order but not
/// necessarily all at once, to the database schema at some point (or
/// points) in the future. The server checks that the statements
/// are executable (syntactically valid, name tables that exist, etc.)
/// before enqueueing them, but they may still fail upon
/// later execution (e.g., if a statement from another batch of
/// statements is applied first and it conflicts in some way, or if
/// there is some data-related problem like a `NULL` value in a column to
/// which `NOT NULL` would be added). If a statement fails, all
/// subsequent statements in the batch are automatically cancelled.
///
/// Each batch of statements is assigned a name which can be used with
/// the [Operations][google.longrunning.Operations] API to monitor
/// progress. See the
/// [operation_id][google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.operation_id] field for more
/// details.
public struct Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database to update.
  public var database: String = String()

  /// Required. DDL statements to be applied to the database.
  public var statements: [String] = []

  /// If empty, the new update request is assigned an
  /// automatically-generated operation ID. Otherwise, `operation_id`
  /// is used to construct the name of the resulting
  /// [Operation][google.longrunning.Operation].
  ///
  /// Specifying an explicit operation ID simplifies determining
  /// whether the statements were executed in the event that the
  /// [UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl] call is replayed,
  /// or the return value is otherwise lost: the [database][google.spanner.admin.database.v1.UpdateDatabaseDdlRequest.database] and
  /// `operation_id` fields can be combined to form the
  /// [name][google.longrunning.Operation.name] of the resulting
  /// [longrunning.Operation][google.longrunning.Operation]: `<database>/operations/<operation_id>`.
  ///
  /// `operation_id` should be unique within the database, and must be
  /// a valid identifier: `[a-z][a-z0-9_]*`. Note that
  /// automatically-generated operation IDs always begin with an
  /// underscore. If the named operation already exists,
  /// [UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl] returns
  /// `ALREADY_EXISTS`.
  public var operationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata type for the operation returned by
/// [UpdateDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.UpdateDatabaseDdl].
public struct Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The database being modified.
  public var database: String = String()

  /// For an update this list contains all the statements. For an
  /// individual statement, this list contains only that statement.
  public var statements: [String] = []

  /// Reports the commit timestamps of all statements that have
  /// succeeded so far, where `commit_timestamps[i]` is the commit
  /// timestamp for the statement `statements[i]`.
  public var commitTimestamps: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [DropDatabase][google.spanner.admin.database.v1.DatabaseAdmin.DropDatabase].
public struct Google_Spanner_Admin_Database_V1_DropDatabaseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database to be dropped.
  public var database: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [GetDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseDdl].
public struct Google_Spanner_Admin_Database_V1_GetDatabaseDdlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The database whose schema we wish to get.
  public var database: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [GetDatabaseDdl][google.spanner.admin.database.v1.DatabaseAdmin.GetDatabaseDdl].
public struct Google_Spanner_Admin_Database_V1_GetDatabaseDdlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of formatted DDL statements defining the schema of the database
  /// specified in the request.
  public var statements: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for
/// [ListDatabaseOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabaseOperations].
public struct Google_Spanner_Admin_Database_V1_ListDatabaseOperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The instance of the database operations.
  /// Values are of the form `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// An expression that filters the list of returned operations.
  ///
  /// A filter expression consists of a field name, a
  /// comparison operator, and a value for filtering.
  /// The value must be a string, a number, or a boolean. The comparison operator
  /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
  /// Colon `:` is the contains operator. Filter rules are not case sensitive.
  ///
  /// The following fields in the [Operation][google.longrunning.Operation]
  /// are eligible for filtering:
  ///
  ///   * `name` - The name of the long-running operation
  ///   * `done` - False if the operation is in progress, else true.
  ///   * `metadata.@type` - the type of metadata. For example, the type string
  ///      for [RestoreDatabaseMetadata][google.spanner.admin.database.v1.RestoreDatabaseMetadata] is
  ///      `type.googleapis.com/google.spanner.admin.database.v1.RestoreDatabaseMetadata`.
  ///   * `metadata.<field_name>` - any field in metadata.value.
  ///   * `error` - Error associated with the long-running operation.
  ///   * `response.@type` - the type of response.
  ///   * `response.<field_name>` - any field in response.value.
  ///
  /// You can combine multiple expressions by enclosing each expression in
  /// parentheses. By default, expressions are combined with AND logic. However,
  /// you can specify AND, OR, and NOT logic explicitly.
  ///
  /// Here are a few examples:
  ///
  ///   * `done:true` - The operation is complete.
  ///   * `(metadata.@type=type.googleapis.com/google.spanner.admin.database.v1.RestoreDatabaseMetadata) AND` <br/>
  ///     `(metadata.source_type:BACKUP) AND` <br/>
  ///     `(metadata.backup_info.backup:backup_howl) AND` <br/>
  ///     `(metadata.name:restored_howl) AND` <br/>
  ///     `(metadata.progress.start_time < \"2018-03-28T14:50:00Z\") AND` <br/>
  ///     `(error:*)` - Return operations where:
  ///     * The operation's metadata type is [RestoreDatabaseMetadata][google.spanner.admin.database.v1.RestoreDatabaseMetadata].
  ///     * The database is restored from a backup.
  ///     * The backup name contains "backup_howl".
  ///     * The restored database's name contains "restored_howl".
  ///     * The operation started before 2018-03-28T14:50:00Z.
  ///     * The operation resulted in an error.
  public var filter: String = String()

  /// Number of operations to be returned in the response. If 0 or
  /// less, defaults to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.admin.database.v1.ListDatabaseOperationsResponse.next_page_token]
  /// from a previous [ListDatabaseOperationsResponse][google.spanner.admin.database.v1.ListDatabaseOperationsResponse] to the
  /// same `parent` and with the same `filter`.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for
/// [ListDatabaseOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabaseOperations].
public struct Google_Spanner_Admin_Database_V1_ListDatabaseOperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching database [long-running
  /// operations][google.longrunning.Operation]. Each operation's name will be
  /// prefixed by the database's name. The operation's
  /// [metadata][google.longrunning.Operation.metadata] field type
  /// `metadata.type_url` describes the type of the metadata.
  public var operations: [Google_Longrunning_Operation] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListDatabaseOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListDatabaseOperations]
  /// call to fetch more of the matching metadata.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for
/// [RestoreDatabase][google.spanner.admin.database.v1.DatabaseAdmin.RestoreDatabase].
public struct Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the instance in which to create the
  /// restored database. This instance must be in the same project and
  /// have the same instance configuration as the instance containing
  /// the source backup. Values are of the form
  /// `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// Required. The id of the database to create and restore to. This
  /// database must not already exist. The `database_id` appended to
  /// `parent` forms the full database name of the form
  /// `projects/<project>/instances/<instance>/databases/<database_id>`.
  public var databaseID: String = String()

  /// Required. The source from which to restore.
  public var source: Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest.OneOf_Source? = nil

  /// Name of the backup from which to restore.  Values are of the form
  /// `projects/<project>/instances/<instance>/backups/<backup>`.
  public var backup: String {
    get {
      if case .backup(let v)? = source {return v}
      return String()
    }
    set {source = .backup(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Required. The source from which to restore.
  public enum OneOf_Source: Equatable {
    /// Name of the backup from which to restore.  Values are of the form
    /// `projects/<project>/instances/<instance>/backups/<backup>`.
    case backup(String)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest.OneOf_Source, rhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest.OneOf_Source) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.backup, .backup): return {
        guard case .backup(let l) = lhs, case .backup(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}
}

/// Metadata type for the long-running operation returned by
/// [RestoreDatabase][google.spanner.admin.database.v1.DatabaseAdmin.RestoreDatabase].
public struct Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the database being created and restored to.
  public var name: String = String()

  /// The type of the restore source.
  public var sourceType: Google_Spanner_Admin_Database_V1_RestoreSourceType = .typeUnspecified

  /// Information about the source used to restore the database, as specified by
  /// `source` in [RestoreDatabaseRequest][google.spanner.admin.database.v1.RestoreDatabaseRequest].
  public var sourceInfo: Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata.OneOf_SourceInfo? = nil

  /// Information about the backup used to restore the database.
  public var backupInfo: Google_Spanner_Admin_Database_V1_BackupInfo {
    get {
      if case .backupInfo(let v)? = sourceInfo {return v}
      return Google_Spanner_Admin_Database_V1_BackupInfo()
    }
    set {sourceInfo = .backupInfo(newValue)}
  }

  /// The progress of the
  /// [RestoreDatabase][google.spanner.admin.database.v1.DatabaseAdmin.RestoreDatabase]
  /// operation.
  public var progress: Google_Spanner_Admin_Database_V1_OperationProgress {
    get {return _progress ?? Google_Spanner_Admin_Database_V1_OperationProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  /// The time at which cancellation of this operation was received.
  /// [Operations.CancelOperation][google.longrunning.Operations.CancelOperation]
  /// starts asynchronous cancellation on a long-running operation. The server
  /// makes a best effort to cancel the operation, but success is not guaranteed.
  /// Clients can use
  /// [Operations.GetOperation][google.longrunning.Operations.GetOperation] or
  /// other methods to check whether the cancellation succeeded or whether the
  /// operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with
  /// an [Operation.error][google.longrunning.Operation.error] value with a
  /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to `Code.CANCELLED`.
  public var cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _cancelTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_cancelTime = newValue}
  }
  /// Returns true if `cancelTime` has been explicitly set.
  public var hasCancelTime: Bool {return self._cancelTime != nil}
  /// Clears the value of `cancelTime`. Subsequent reads from it will return its default value.
  public mutating func clearCancelTime() {self._cancelTime = nil}

  /// If exists, the name of the long-running operation that will be used to
  /// track the post-restore optimization process to optimize the performance of
  /// the restored database, and remove the dependency on the restore source.
  /// The name is of the form
  /// `projects/<project>/instances/<instance>/databases/<database>/operations/<operation>`
  /// where the <database> is the name of database being created and restored to.
  /// The metadata type of the  long-running operation is
  /// [OptimizeRestoredDatabaseMetadata][google.spanner.admin.database.v1.OptimizeRestoredDatabaseMetadata]. This long-running operation will be
  /// automatically created by the system after the RestoreDatabase long-running
  /// operation completes successfully. This operation will not be created if the
  /// restore was not successful.
  public var optimizeDatabaseOperationName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Information about the source used to restore the database, as specified by
  /// `source` in [RestoreDatabaseRequest][google.spanner.admin.database.v1.RestoreDatabaseRequest].
  public enum OneOf_SourceInfo: Equatable {
    /// Information about the backup used to restore the database.
    case backupInfo(Google_Spanner_Admin_Database_V1_BackupInfo)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata.OneOf_SourceInfo, rhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata.OneOf_SourceInfo) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.backupInfo, .backupInfo): return {
        guard case .backupInfo(let l) = lhs, case .backupInfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  public init() {}

  fileprivate var _progress: Google_Spanner_Admin_Database_V1_OperationProgress? = nil
  fileprivate var _cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata type for the long-running operation used to track the progress
/// of optimizations performed on a newly restored database. This long-running
/// operation is automatically created by the system after the successful
/// completion of a database restore, and cannot be cancelled.
public struct Google_Spanner_Admin_Database_V1_OptimizeRestoredDatabaseMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the restored database being optimized.
  public var name: String = String()

  /// The progress of the post-restore optimizations.
  public var progress: Google_Spanner_Admin_Database_V1_OperationProgress {
    get {return _progress ?? Google_Spanner_Admin_Database_V1_OperationProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _progress: Google_Spanner_Admin_Database_V1_OperationProgress? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.spanner.admin.database.v1"

extension Google_Spanner_Admin_Database_V1_RestoreSourceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "BACKUP"),
  ]
}

extension Google_Spanner_Admin_Database_V1_RestoreInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_type"),
    2: .standard(proto: "backup_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      case 2: try {
        var v: Google_Spanner_Admin_Database_V1_BackupInfo?
        if let current = self.sourceInfo {
          try decoder.handleConflictingOneOf()
          if case .backupInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sourceInfo = .backupInfo(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceType != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 1)
    }
    if case .backupInfo(let v)? = self.sourceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_RestoreInfo, rhs: Google_Spanner_Admin_Database_V1_RestoreInfo) -> Bool {
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.sourceInfo != rhs.sourceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_Database: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Database"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "state"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "restore_info"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._restoreInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._restoreInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_Database, rhs: Google_Spanner_Admin_Database_V1_Database) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.state != rhs.state {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._restoreInfo != rhs._restoreInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_Database.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
    3: .same(proto: "READY_OPTIMIZING"),
  ]
}

extension Google_Spanner_Admin_Database_V1_ListDatabasesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatabasesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListDatabasesRequest, rhs: Google_Spanner_Admin_Database_V1_ListDatabasesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListDatabasesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatabasesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "databases"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.databases) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.databases.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.databases, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListDatabasesResponse, rhs: Google_Spanner_Admin_Database_V1_ListDatabasesResponse) -> Bool {
    if lhs.databases != rhs.databases {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_CreateDatabaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDatabaseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "create_statement"),
    3: .standard(proto: "extra_statements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.createStatement) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.extraStatements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.createStatement.isEmpty {
      try visitor.visitSingularStringField(value: self.createStatement, fieldNumber: 2)
    }
    if !self.extraStatements.isEmpty {
      try visitor.visitRepeatedStringField(value: self.extraStatements, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_CreateDatabaseRequest, rhs: Google_Spanner_Admin_Database_V1_CreateDatabaseRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.createStatement != rhs.createStatement {return false}
    if lhs.extraStatements != rhs.extraStatements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_CreateDatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateDatabaseMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_CreateDatabaseMetadata, rhs: Google_Spanner_Admin_Database_V1_CreateDatabaseMetadata) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_GetDatabaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatabaseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_GetDatabaseRequest, rhs: Google_Spanner_Admin_Database_V1_GetDatabaseRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDatabaseDdlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "statements"),
    3: .standard(proto: "operation_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.statements) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.statements.isEmpty {
      try visitor.visitRepeatedStringField(value: self.statements, fieldNumber: 2)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlRequest, rhs: Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.statements != rhs.statements {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateDatabaseDdlMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
    2: .same(proto: "statements"),
    3: .standard(proto: "commit_timestamps"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.statements) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.commitTimestamps) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    if !self.statements.isEmpty {
      try visitor.visitRepeatedStringField(value: self.statements, fieldNumber: 2)
    }
    if !self.commitTimestamps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.commitTimestamps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlMetadata, rhs: Google_Spanner_Admin_Database_V1_UpdateDatabaseDdlMetadata) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.statements != rhs.statements {return false}
    if lhs.commitTimestamps != rhs.commitTimestamps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_DropDatabaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DropDatabaseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_DropDatabaseRequest, rhs: Google_Spanner_Admin_Database_V1_DropDatabaseRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_GetDatabaseDdlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatabaseDdlRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "database"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.database) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_GetDatabaseDdlRequest, rhs: Google_Spanner_Admin_Database_V1_GetDatabaseDdlRequest) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_GetDatabaseDdlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDatabaseDdlResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "statements"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.statements) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.statements.isEmpty {
      try visitor.visitRepeatedStringField(value: self.statements, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_GetDatabaseDdlResponse, rhs: Google_Spanner_Admin_Database_V1_GetDatabaseDdlResponse) -> Bool {
    if lhs.statements != rhs.statements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListDatabaseOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatabaseOperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListDatabaseOperationsRequest, rhs: Google_Spanner_Admin_Database_V1_ListDatabaseOperationsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListDatabaseOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDatabaseOperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListDatabaseOperationsResponse, rhs: Google_Spanner_Admin_Database_V1_ListDatabaseOperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreDatabaseRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "database_id"),
    3: .same(proto: "backup"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.databaseID) }()
      case 3: try {
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .backup(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.databaseID.isEmpty {
      try visitor.visitSingularStringField(value: self.databaseID, fieldNumber: 2)
    }
    if case .backup(let v)? = self.source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest, rhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.databaseID != rhs.databaseID {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RestoreDatabaseMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "source_type"),
    3: .standard(proto: "backup_info"),
    4: .same(proto: "progress"),
    5: .standard(proto: "cancel_time"),
    6: .standard(proto: "optimize_database_operation_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.sourceType) }()
      case 3: try {
        var v: Google_Spanner_Admin_Database_V1_BackupInfo?
        if let current = self.sourceInfo {
          try decoder.handleConflictingOneOf()
          if case .backupInfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sourceInfo = .backupInfo(v)}
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cancelTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.optimizeDatabaseOperationName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.sourceType != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.sourceType, fieldNumber: 2)
    }
    if case .backupInfo(let v)? = self.sourceInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._cancelTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.optimizeDatabaseOperationName.isEmpty {
      try visitor.visitSingularStringField(value: self.optimizeDatabaseOperationName, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata, rhs: Google_Spanner_Admin_Database_V1_RestoreDatabaseMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.sourceType != rhs.sourceType {return false}
    if lhs.sourceInfo != rhs.sourceInfo {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs._cancelTime != rhs._cancelTime {return false}
    if lhs.optimizeDatabaseOperationName != rhs.optimizeDatabaseOperationName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_OptimizeRestoredDatabaseMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OptimizeRestoredDatabaseMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "progress"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_OptimizeRestoredDatabaseMetadata, rhs: Google_Spanner_Admin_Database_V1_OptimizeRestoredDatabaseMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/spanner/admin/database/v1/backup.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A backup of a Cloud Spanner database.
public struct Google_Spanner_Admin_Database_V1_Backup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required for the [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup] operation.
  /// Name of the database from which this backup was
  /// created. This needs to be in the same instance as the backup.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/databases/<database>`.
  public var database: String = String()

  /// Required for the [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup]
  /// operation. The expiration time of the backup, with microseconds
  /// granularity that must be at least 6 hours and at most 366 days
  /// from the time the CreateBackup request is processed. Once the `expire_time`
  /// has passed, the backup is eligible to be automatically deleted by Cloud
  /// Spanner to free the resources used by the backup.
  public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  public var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  public mutating func clearExpireTime() {self._expireTime = nil}

  /// Output only for the [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup] operation.
  /// Required for the [UpdateBackup][google.spanner.admin.database.v1.DatabaseAdmin.UpdateBackup] operation.
  ///
  /// A globally unique identifier for the backup which cannot be
  /// changed. Values are of the form
  /// `projects/<project>/instances/<instance>/backups/[a-z][a-z0-9_\-]*[a-z0-9]`
  /// The final segment of the name must be between 2 and 60 characters
  /// in length.
  ///
  /// The backup is stored in the location(s) specified in the instance
  /// configuration of the instance containing the backup, identified
  /// by the prefix of the backup name of the form
  /// `projects/<project>/instances/<instance>`.
  public var name: String = String()

  /// Output only. The backup will contain an externally consistent
  /// copy of the database at the timestamp specified by
  /// `create_time`. `create_time` is approximately the time the
  /// [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup] request is received.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. Size of the backup in bytes.
  public var sizeBytes: Int64 = 0

  /// Output only. The current state of the backup.
  public var state: Google_Spanner_Admin_Database_V1_Backup.State = .unspecified

  /// Output only. The names of the restored databases that reference the backup.
  /// The database names are of
  /// the form `projects/<project>/instances/<instance>/databases/<database>`.
  /// Referencing databases may exist in different instances. The existence of
  /// any referencing database prevents the backup from being deleted. When a
  /// restored database from the backup enters the `READY` state, the reference
  /// to the backup is removed.
  public var referencingDatabases: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the current state of the backup.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// The pending backup is still being created. Operations on the
    /// backup may fail with `FAILED_PRECONDITION` in this state.
    case creating // = 1

    /// The backup is complete and ready for use.
    case ready // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .ready
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .ready: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=4.2)

extension Google_Spanner_Admin_Database_V1_Backup.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Spanner_Admin_Database_V1_Backup.State] = [
    .unspecified,
    .creating,
    .ready,
  ]
}

#endif  // swift(>=4.2)

/// The request for [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup].
public struct Google_Spanner_Admin_Database_V1_CreateBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the instance in which the backup will be
  /// created. This must be the same instance that contains the database the
  /// backup will be created from. The backup will be stored in the
  /// location(s) specified in the instance configuration of this
  /// instance. Values are of the form
  /// `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// Required. The id of the backup to be created. The `backup_id` appended to
  /// `parent` forms the full backup name of the form
  /// `projects/<project>/instances/<instance>/backups/<backup_id>`.
  public var backupID: String = String()

  /// Required. The backup to create.
  public var backup: Google_Spanner_Admin_Database_V1_Backup {
    get {return _backup ?? Google_Spanner_Admin_Database_V1_Backup()}
    set {_backup = newValue}
  }
  /// Returns true if `backup` has been explicitly set.
  public var hasBackup: Bool {return self._backup != nil}
  /// Clears the value of `backup`. Subsequent reads from it will return its default value.
  public mutating func clearBackup() {self._backup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _backup: Google_Spanner_Admin_Database_V1_Backup? = nil
}

/// Metadata type for the operation returned by
/// [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup].
public struct Google_Spanner_Admin_Database_V1_CreateBackupMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the backup being created.
  public var name: String = String()

  /// The name of the database the backup is created from.
  public var database: String = String()

  /// The progress of the
  /// [CreateBackup][google.spanner.admin.database.v1.DatabaseAdmin.CreateBackup] operation.
  public var progress: Google_Spanner_Admin_Database_V1_OperationProgress {
    get {return _progress ?? Google_Spanner_Admin_Database_V1_OperationProgress()}
    set {_progress = newValue}
  }
  /// Returns true if `progress` has been explicitly set.
  public var hasProgress: Bool {return self._progress != nil}
  /// Clears the value of `progress`. Subsequent reads from it will return its default value.
  public mutating func clearProgress() {self._progress = nil}

  /// The time at which cancellation of this operation was received.
  /// [Operations.CancelOperation][google.longrunning.Operations.CancelOperation]
  /// starts asynchronous cancellation on a long-running operation. The server
  /// makes a best effort to cancel the operation, but success is not guaranteed.
  /// Clients can use
  /// [Operations.GetOperation][google.longrunning.Operations.GetOperation] or
  /// other methods to check whether the cancellation succeeded or whether the
  /// operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with
  /// an [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
  /// corresponding to `Code.CANCELLED`.
  public var cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _cancelTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_cancelTime = newValue}
  }
  /// Returns true if `cancelTime` has been explicitly set.
  public var hasCancelTime: Bool {return self._cancelTime != nil}
  /// Clears the value of `cancelTime`. Subsequent reads from it will return its default value.
  public mutating func clearCancelTime() {self._cancelTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _progress: Google_Spanner_Admin_Database_V1_OperationProgress? = nil
  fileprivate var _cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The request for [UpdateBackup][google.spanner.admin.database.v1.DatabaseAdmin.UpdateBackup].
public struct Google_Spanner_Admin_Database_V1_UpdateBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The backup to update. `backup.name`, and the fields to be updated
  /// as specified by `update_mask` are required. Other fields are ignored.
  /// Update is only supported for the following fields:
  ///  * `backup.expire_time`.
  public var backup: Google_Spanner_Admin_Database_V1_Backup {
    get {return _backup ?? Google_Spanner_Admin_Database_V1_Backup()}
    set {_backup = newValue}
  }
  /// Returns true if `backup` has been explicitly set.
  public var hasBackup: Bool {return self._backup != nil}
  /// Clears the value of `backup`. Subsequent reads from it will return its default value.
  public mutating func clearBackup() {self._backup = nil}

  /// Required. A mask specifying which fields (e.g. `expire_time`) in the
  /// Backup resource should be updated. This mask is relative to the Backup
  /// resource, not to the request message. The field mask must always be
  /// specified; this prevents any future fields from being erased accidentally
  /// by clients that do not know about them.
  public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  public var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  public mutating func clearUpdateMask() {self._updateMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _backup: Google_Spanner_Admin_Database_V1_Backup? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request for [GetBackup][google.spanner.admin.database.v1.DatabaseAdmin.GetBackup].
public struct Google_Spanner_Admin_Database_V1_GetBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the backup.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/backups/<backup>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [DeleteBackup][google.spanner.admin.database.v1.DatabaseAdmin.DeleteBackup].
public struct Google_Spanner_Admin_Database_V1_DeleteBackupRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Name of the backup to delete.
  /// Values are of the form
  /// `projects/<project>/instances/<instance>/backups/<backup>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [ListBackups][google.spanner.admin.database.v1.DatabaseAdmin.ListBackups].
public struct Google_Spanner_Admin_Database_V1_ListBackupsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The instance to list backups from.  Values are of the
  /// form `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// An expression that filters the list of returned backups.
  ///
  /// A filter expression consists of a field name, a comparison operator, and a
  /// value for filtering.
  /// The value must be a string, a number, or a boolean. The comparison operator
  /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
  /// Colon `:` is the contains operator. Filter rules are not case sensitive.
  ///
  /// The following fields in the [Backup][google.spanner.admin.database.v1.Backup] are eligible for filtering:
  ///
  ///   * `name`
  ///   * `database`
  ///   * `state`
  ///   * `create_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
  ///   * `expire_time` (and values are of the format YYYY-MM-DDTHH:MM:SSZ)
  ///   * `size_bytes`
  ///
  /// You can combine multiple expressions by enclosing each expression in
  /// parentheses. By default, expressions are combined with AND logic, but
  /// you can specify AND, OR, and NOT logic explicitly.
  ///
  /// Here are a few examples:
  ///
  ///   * `name:Howl` - The backup's name contains the string "howl".
  ///   * `database:prod`
  ///          - The database's name contains the string "prod".
  ///   * `state:CREATING` - The backup is pending creation.
  ///   * `state:READY` - The backup is fully created and ready for use.
  ///   * `(name:howl) AND (create_time < \"2018-03-28T14:50:00Z\")`
  ///          - The backup name contains the string "howl" and `create_time`
  ///              of the backup is before 2018-03-28T14:50:00Z.
  ///   * `expire_time < \"2018-03-28T14:50:00Z\"`
  ///          - The backup `expire_time` is before 2018-03-28T14:50:00Z.
  ///   * `size_bytes > 10000000000` - The backup's size is greater than 10GB
  public var filter: String = String()

  /// Number of backups to be returned in the response. If 0 or
  /// less, defaults to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.admin.database.v1.ListBackupsResponse.next_page_token] from a
  /// previous [ListBackupsResponse][google.spanner.admin.database.v1.ListBackupsResponse] to the same `parent` and with the same
  /// `filter`.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [ListBackups][google.spanner.admin.database.v1.DatabaseAdmin.ListBackups].
public struct Google_Spanner_Admin_Database_V1_ListBackupsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching backups. Backups returned are ordered by `create_time`
  /// in descending order, starting from the most recent `create_time`.
  public var backups: [Google_Spanner_Admin_Database_V1_Backup] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListBackups][google.spanner.admin.database.v1.DatabaseAdmin.ListBackups] call to fetch more
  /// of the matching backups.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for
/// [ListBackupOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListBackupOperations].
public struct Google_Spanner_Admin_Database_V1_ListBackupOperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The instance of the backup operations. Values are of
  /// the form `projects/<project>/instances/<instance>`.
  public var parent: String = String()

  /// An expression that filters the list of returned backup operations.
  ///
  /// A filter expression consists of a field name, a
  /// comparison operator, and a value for filtering.
  /// The value must be a string, a number, or a boolean. The comparison operator
  /// must be one of: `<`, `>`, `<=`, `>=`, `!=`, `=`, or `:`.
  /// Colon `:` is the contains operator. Filter rules are not case sensitive.
  ///
  /// The following fields in the [operation][google.longrunning.Operation]
  /// are eligible for filtering:
  ///
  ///   * `name` - The name of the long-running operation
  ///   * `done` - False if the operation is in progress, else true.
  ///   * `metadata.@type` - the type of metadata. For example, the type string
  ///      for [CreateBackupMetadata][google.spanner.admin.database.v1.CreateBackupMetadata] is
  ///      `type.googleapis.com/google.spanner.admin.database.v1.CreateBackupMetadata`.
  ///   * `metadata.<field_name>` - any field in metadata.value.
  ///   * `error` - Error associated with the long-running operation.
  ///   * `response.@type` - the type of response.
  ///   * `response.<field_name>` - any field in response.value.
  ///
  /// You can combine multiple expressions by enclosing each expression in
  /// parentheses. By default, expressions are combined with AND logic, but
  /// you can specify AND, OR, and NOT logic explicitly.
  ///
  /// Here are a few examples:
  ///
  ///   * `done:true` - The operation is complete.
  ///   * `metadata.database:prod` - The database the backup was taken from has
  ///      a name containing the string "prod".
  ///   * `(metadata.@type=type.googleapis.com/google.spanner.admin.database.v1.CreateBackupMetadata) AND` <br/>
  ///     `(metadata.name:howl) AND` <br/>
  ///     `(metadata.progress.start_time < \"2018-03-28T14:50:00Z\") AND` <br/>
  ///     `(error:*)` - Returns operations where:
  ///     * The operation's metadata type is [CreateBackupMetadata][google.spanner.admin.database.v1.CreateBackupMetadata].
  ///     * The backup name contains the string "howl".
  ///     * The operation started before 2018-03-28T14:50:00Z.
  ///     * The operation resulted in an error.
  public var filter: String = String()

  /// Number of operations to be returned in the response. If 0 or
  /// less, defaults to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.admin.database.v1.ListBackupOperationsResponse.next_page_token]
  /// from a previous [ListBackupOperationsResponse][google.spanner.admin.database.v1.ListBackupOperationsResponse] to the
  /// same `parent` and with the same `filter`.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for
/// [ListBackupOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListBackupOperations].
public struct Google_Spanner_Admin_Database_V1_ListBackupOperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of matching backup [long-running
  /// operations][google.longrunning.Operation]. Each operation's name will be
  /// prefixed by the backup's name and the operation's
  /// [metadata][google.longrunning.Operation.metadata] will be of type
  /// [CreateBackupMetadata][google.spanner.admin.database.v1.CreateBackupMetadata]. Operations returned include those that are
  /// pending or have completed/failed/canceled within the last 7 days.
  /// Operations returned are ordered by
  /// `operation.metadata.value.progress.start_time` in descending order starting
  /// from the most recently started operation.
  public var operations: [Google_Longrunning_Operation] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListBackupOperations][google.spanner.admin.database.v1.DatabaseAdmin.ListBackupOperations]
  /// call to fetch more of the matching metadata.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Information about a backup.
public struct Google_Spanner_Admin_Database_V1_BackupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the backup.
  public var backup: String = String()

  /// The backup contains an externally consistent copy of `source_database` at
  /// the timestamp specified by `create_time`.
  public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  public var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  public mutating func clearCreateTime() {self._createTime = nil}

  /// Name of the database the backup was created from.
  public var sourceDatabase: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.spanner.admin.database.v1"

extension Google_Spanner_Admin_Database_V1_Backup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Backup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "database"),
    3: .standard(proto: "expire_time"),
    1: .same(proto: "name"),
    4: .standard(proto: "create_time"),
    5: .standard(proto: "size_bytes"),
    6: .same(proto: "state"),
    7: .standard(proto: "referencing_databases"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.sizeBytes) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeRepeatedStringField(value: &self.referencingDatabases) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 2)
    }
    if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if self.sizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.sizeBytes, fieldNumber: 5)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if !self.referencingDatabases.isEmpty {
      try visitor.visitRepeatedStringField(value: self.referencingDatabases, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_Backup, rhs: Google_Spanner_Admin_Database_V1_Backup) -> Bool {
    if lhs.database != rhs.database {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.name != rhs.name {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.sizeBytes != rhs.sizeBytes {return false}
    if lhs.state != rhs.state {return false}
    if lhs.referencingDatabases != rhs.referencingDatabases {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_Backup.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
  ]
}

extension Google_Spanner_Admin_Database_V1_CreateBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "backup_id"),
    3: .same(proto: "backup"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.backupID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._backup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.backupID.isEmpty {
      try visitor.visitSingularStringField(value: self.backupID, fieldNumber: 2)
    }
    if let v = self._backup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_CreateBackupRequest, rhs: Google_Spanner_Admin_Database_V1_CreateBackupRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.backupID != rhs.backupID {return false}
    if lhs._backup != rhs._backup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_CreateBackupMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateBackupMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "database"),
    3: .same(proto: "progress"),
    4: .standard(proto: "cancel_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.database) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._progress) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._cancelTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.database.isEmpty {
      try visitor.visitSingularStringField(value: self.database, fieldNumber: 2)
    }
    if let v = self._progress {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._cancelTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_CreateBackupMetadata, rhs: Google_Spanner_Admin_Database_V1_CreateBackupMetadata) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.database != rhs.database {return false}
    if lhs._progress != rhs._progress {return false}
    if lhs._cancelTime != rhs._cancelTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_UpdateBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backup"),
    2: .standard(proto: "update_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._backup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._backup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_UpdateBackupRequest, rhs: Google_Spanner_Admin_Database_V1_UpdateBackupRequest) -> Bool {
    if lhs._backup != rhs._backup {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_GetBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_GetBackupRequest, rhs: Google_Spanner_Admin_Database_V1_GetBackupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_DeleteBackupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteBackupRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_DeleteBackupRequest, rhs: Google_Spanner_Admin_Database_V1_DeleteBackupRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListBackupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBackupsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListBackupsRequest, rhs: Google_Spanner_Admin_Database_V1_ListBackupsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListBackupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBackupsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backups"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.backups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.backups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.backups, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListBackupsResponse, rhs: Google_Spanner_Admin_Database_V1_ListBackupsResponse) -> Bool {
    if lhs.backups != rhs.backups {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListBackupOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBackupOperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListBackupOperationsRequest, rhs: Google_Spanner_Admin_Database_V1_ListBackupOperationsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_ListBackupOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBackupOperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_ListBackupOperationsResponse, rhs: Google_Spanner_Admin_Database_V1_ListBackupOperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Database_V1_BackupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BackupInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "backup"),
    2: .standard(proto: "create_time"),
    3: .standard(proto: "source_database"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.backup) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceDatabase) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.backup.isEmpty {
      try visitor.visitSingularStringField(value: self.backup, fieldNumber: 1)
    }
    if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.sourceDatabase.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceDatabase, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Database_V1_BackupInfo, rhs: Google_Spanner_Admin_Database_V1_BackupInfo) -> Bool {
    if lhs.backup != rhs.backup {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.sourceDatabase != rhs.sourceDatabase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/spanner/admin/instance/v1/spanner_instance_admin.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct Google_Spanner_Admin_Instance_V1_ReplicaInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The location of the serving resources, e.g. "us-central1".
  public var location: String = String()

  /// The type of replica.
  public var type: Google_Spanner_Admin_Instance_V1_ReplicaInfo.ReplicaType = .typeUnspecified

  /// If true, this location is designated as the default leader location where
  /// leader replicas are placed. See the [region types
  /// documentation](https://cloud.google.com/spanner/docs/instances#region_types)
  /// for more details.
  public var defaultLeaderLocation: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the type of replica.  See the [replica types
  /// documentation](https://cloud.google.com/spanner/docs/replication#replica_types)
  /// for more details.
  public enum ReplicaType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case typeUnspecified // = 0

    /// Read-write replicas support both reads and writes. These replicas:
    ///
    /// * Maintain a full copy of your data.
    /// * Serve reads.
    /// * Can vote whether to commit a write.
    /// * Participate in leadership election.
    /// * Are eligible to become a leader.
    case readWrite // = 1

    /// Read-only replicas only support reads (not writes). Read-only replicas:
    ///
    /// * Maintain a full copy of your data.
    /// * Serve reads.
    /// * Do not participate in voting to commit writes.
    /// * Are not eligible to become a leader.
    case readOnly // = 2

    /// Witness replicas don't support reads but do participate in voting to
    /// commit writes. Witness replicas:
    ///
    /// * Do not maintain a full copy of data.
    /// * Do not serve reads.
    /// * Vote whether to commit writes.
    /// * Participate in leader election but are not eligible to become leader.
    case witness // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .typeUnspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .typeUnspecified
      case 1: self = .readWrite
      case 2: self = .readOnly
      case 3: self = .witness
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .typeUnspecified: return 0
      case .readWrite: return 1
      case .readOnly: return 2
      case .witness: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Spanner_Admin_Instance_V1_ReplicaInfo.ReplicaType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Spanner_Admin_Instance_V1_ReplicaInfo.ReplicaType] = [
    .typeUnspecified,
    .readWrite,
    .readOnly,
    .witness,
  ]
}

#endif  // swift(>=4.2)

/// A possible configuration for a Cloud Spanner instance. Configurations
/// define the geographic placement of nodes and their replication.
public struct Google_Spanner_Admin_Instance_V1_InstanceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for the instance configuration.  Values
  /// are of the form
  /// `projects/<project>/instanceConfigs/[a-z][-a-z0-9]*`
  public var name: String = String()

  /// The name of this instance configuration as it appears in UIs.
  public var displayName: String = String()

  /// The geographic placement of nodes in this instance configuration and their
  /// replication properties.
  public var replicas: [Google_Spanner_Admin_Instance_V1_ReplicaInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// An isolated set of Cloud Spanner resources on which databases can be hosted.
public struct Google_Spanner_Admin_Instance_V1_Instance {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. A unique identifier for the instance, which cannot be changed
  /// after the instance is created. Values are of the form
  /// `projects/<project>/instances/[a-z][-a-z0-9]*[a-z0-9]`. The final
  /// segment of the name must be between 2 and 64 characters in length.
  public var name: String = String()

  /// Required. The name of the instance's configuration. Values are of the form
  /// `projects/<project>/instanceConfigs/<configuration>`. See
  /// also [InstanceConfig][google.spanner.admin.instance.v1.InstanceConfig] and
  /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
  public var config: String = String()

  /// Required. The descriptive name for this instance as it appears in UIs.
  /// Must be unique per project and between 4 and 30 characters in length.
  public var displayName: String = String()

  /// Required. The number of nodes allocated to this instance. This may be zero
  /// in API responses for instances that are not yet in state `READY`.
  ///
  /// See [the
  /// documentation](https://cloud.google.com/spanner/docs/instances#node_count)
  /// for more information about nodes.
  public var nodeCount: Int32 = 0

  /// Output only. The current instance state. For
  /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance], the state must be
  /// either omitted or set to `CREATING`. For
  /// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance], the state must be
  /// either omitted or set to `READY`.
  public var state: Google_Spanner_Admin_Instance_V1_Instance.State = .unspecified

  /// Cloud Labels are a flexible and lightweight mechanism for organizing cloud
  /// resources into groups that reflect a customer's organizational needs and
  /// deployment strategies. Cloud Labels can be used to filter collections of
  /// resources. They can be used to control how resource metrics are aggregated.
  /// And they can be used as arguments to policy management rules (e.g. route,
  /// firewall, load balancing, etc.).
  ///
  ///  * Label keys must be between 1 and 63 characters long and must conform to
  ///    the following regular expression: `[a-z]([-a-z0-9]*[a-z0-9])?`.
  ///  * Label values must be between 0 and 63 characters long and must conform
  ///    to the regular expression `([a-z]([-a-z0-9]*[a-z0-9])?)?`.
  ///  * No more than 64 labels can be associated with a given resource.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  ///
  /// If you plan to use labels in your own code, please note that additional
  /// characters may be allowed in the future. And so you are advised to use an
  /// internal label representation, such as JSON, which doesn't rely upon
  /// specific characters being disallowed.  For example, representing labels
  /// as the string:  name + "_" + value  would prove problematic if we were to
  /// allow "_" in a future release.
  public var labels: Dictionary<String,String> = [:]

  /// Deprecated. This field is not populated.
  public var endpointUris: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates the current state of the instance.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not specified.
    case unspecified // = 0

    /// The instance is still being created. Resources may not be
    /// available yet, and operations such as database creation may not
    /// work.
    case creating // = 1

    /// The instance is fully created and ready to do work such as
    /// creating databases.
    case ready // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .creating
      case 2: self = .ready
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .creating: return 1
      case .ready: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Spanner_Admin_Instance_V1_Instance.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Spanner_Admin_Instance_V1_Instance.State] = [
    .unspecified,
    .creating,
    .ready,
  ]
}

#endif  // swift(>=4.2)

/// The request for [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
public struct Google_Spanner_Admin_Instance_V1_ListInstanceConfigsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project for which a list of supported instance
  /// configurations is requested. Values are of the form
  /// `projects/<project>`.
  public var parent: String = String()

  /// Number of instance configurations to be returned in the response. If 0 or
  /// less, defaults to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.admin.instance.v1.ListInstanceConfigsResponse.next_page_token]
  /// from a previous [ListInstanceConfigsResponse][google.spanner.admin.instance.v1.ListInstanceConfigsResponse].
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs].
public struct Google_Spanner_Admin_Instance_V1_ListInstanceConfigsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of requested instance configurations.
  public var instanceConfigs: [Google_Spanner_Admin_Instance_V1_InstanceConfig] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListInstanceConfigs][google.spanner.admin.instance.v1.InstanceAdmin.ListInstanceConfigs] call to
  /// fetch more of the matching instance configurations.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for
/// [GetInstanceConfigRequest][google.spanner.admin.instance.v1.InstanceAdmin.GetInstanceConfig].
public struct Google_Spanner_Admin_Instance_V1_GetInstanceConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the requested instance configuration. Values are of
  /// the form `projects/<project>/instanceConfigs/<config>`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [GetInstance][google.spanner.admin.instance.v1.InstanceAdmin.GetInstance].
public struct Google_Spanner_Admin_Instance_V1_GetInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the requested instance. Values are of the form
  /// `projects/<project>/instances/<instance>`.
  public var name: String = String()

  /// If field_mask is present, specifies the subset of [Instance][google.spanner.admin.instance.v1.Instance] fields that
  /// should be returned.
  /// If absent, all [Instance][google.spanner.admin.instance.v1.Instance] fields are returned.
  public var fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldMask = newValue}
  }
  /// Returns true if `fieldMask` has been explicitly set.
  public var hasFieldMask: Bool {return self._fieldMask != nil}
  /// Clears the value of `fieldMask`. Subsequent reads from it will return its default value.
  public mutating func clearFieldMask() {self._fieldMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request for [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
public struct Google_Spanner_Admin_Instance_V1_CreateInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project in which to create the instance. Values
  /// are of the form `projects/<project>`.
  public var parent: String = String()

  /// Required. The ID of the instance to create.  Valid identifiers are of the
  /// form `[a-z][-a-z0-9]*[a-z0-9]` and must be between 2 and 64 characters in
  /// length.
  public var instanceID: String = String()

  /// Required. The instance to create.  The name may be omitted, but if
  /// specified must be `<parent>/instances/<instance_id>`.
  public var instance: Google_Spanner_Admin_Instance_V1_Instance {
    get {return _instance ?? Google_Spanner_Admin_Instance_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Google_Spanner_Admin_Instance_V1_Instance? = nil
}

/// The request for [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
public struct Google_Spanner_Admin_Instance_V1_ListInstancesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the project for which a list of instances is
  /// requested. Values are of the form `projects/<project>`.
  public var parent: String = String()

  /// Number of instances to be returned in the response. If 0 or less, defaults
  /// to the server's maximum allowed page size.
  public var pageSize: Int32 = 0

  /// If non-empty, `page_token` should contain a
  /// [next_page_token][google.spanner.admin.instance.v1.ListInstancesResponse.next_page_token] from a
  /// previous [ListInstancesResponse][google.spanner.admin.instance.v1.ListInstancesResponse].
  public var pageToken: String = String()

  /// An expression for filtering the results of the request. Filter rules are
  /// case insensitive. The fields eligible for filtering are:
  ///
  ///   * `name`
  ///   * `display_name`
  ///   * `labels.key` where key is the name of a label
  ///
  /// Some examples of using filters are:
  ///
  ///   * `name:*` --> The instance has a name.
  ///   * `name:Howl` --> The instance's name contains the string "howl".
  ///   * `name:HOWL` --> Equivalent to above.
  ///   * `NAME:howl` --> Equivalent to above.
  ///   * `labels.env:*` --> The instance has the label "env".
  ///   * `labels.env:dev` --> The instance has the label "env" and the value of
  ///                        the label contains the string "dev".
  ///   * `name:howl labels.env:dev` --> The instance's name contains "howl" and
  ///                                  it has the label "env" with its value
  ///                                  containing "dev".
  public var filter: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The response for [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances].
public struct Google_Spanner_Admin_Instance_V1_ListInstancesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of requested instances.
  public var instances: [Google_Spanner_Admin_Instance_V1_Instance] = []

  /// `next_page_token` can be sent in a subsequent
  /// [ListInstances][google.spanner.admin.instance.v1.InstanceAdmin.ListInstances] call to fetch more
  /// of the matching instances.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// The request for [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
public struct Google_Spanner_Admin_Instance_V1_UpdateInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The instance to update, which must always include the instance
  /// name.  Otherwise, only fields mentioned in [field_mask][google.spanner.admin.instance.v1.UpdateInstanceRequest.field_mask] need be included.
  public var instance: Google_Spanner_Admin_Instance_V1_Instance {
    get {return _instance ?? Google_Spanner_Admin_Instance_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// Required. A mask specifying which fields in [Instance][google.spanner.admin.instance.v1.Instance] should be updated.
  /// The field mask must always be specified; this prevents any future fields in
  /// [Instance][google.spanner.admin.instance.v1.Instance] from being erased accidentally by clients that do not know
  /// about them.
  public var fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _fieldMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_fieldMask = newValue}
  }
  /// Returns true if `fieldMask` has been explicitly set.
  public var hasFieldMask: Bool {return self._fieldMask != nil}
  /// Clears the value of `fieldMask`. Subsequent reads from it will return its default value.
  public mutating func clearFieldMask() {self._fieldMask = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Google_Spanner_Admin_Instance_V1_Instance? = nil
  fileprivate var _fieldMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// The request for [DeleteInstance][google.spanner.admin.instance.v1.InstanceAdmin.DeleteInstance].
public struct Google_Spanner_Admin_Instance_V1_DeleteInstanceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The name of the instance to be deleted. Values are of the form
  /// `projects/<project>/instances/<instance>`
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Metadata type for the operation returned by
/// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance].
public struct Google_Spanner_Admin_Instance_V1_CreateInstanceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance being created.
  public var instance: Google_Spanner_Admin_Instance_V1_Instance {
    get {return _instance ?? Google_Spanner_Admin_Instance_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// The time at which the
  /// [CreateInstance][google.spanner.admin.instance.v1.InstanceAdmin.CreateInstance] request was
  /// received.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time at which this operation was cancelled. If set, this operation is
  /// in the process of undoing itself (which is guaranteed to succeed) and
  /// cannot be cancelled again.
  public var cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _cancelTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_cancelTime = newValue}
  }
  /// Returns true if `cancelTime` has been explicitly set.
  public var hasCancelTime: Bool {return self._cancelTime != nil}
  /// Clears the value of `cancelTime`. Subsequent reads from it will return its default value.
  public mutating func clearCancelTime() {self._cancelTime = nil}

  /// The time at which this operation failed or was completed successfully.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Google_Spanner_Admin_Instance_V1_Instance? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Metadata type for the operation returned by
/// [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance].
public struct Google_Spanner_Admin_Instance_V1_UpdateInstanceMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The desired end state of the update.
  public var instance: Google_Spanner_Admin_Instance_V1_Instance {
    get {return _instance ?? Google_Spanner_Admin_Instance_V1_Instance()}
    set {_instance = newValue}
  }
  /// Returns true if `instance` has been explicitly set.
  public var hasInstance: Bool {return self._instance != nil}
  /// Clears the value of `instance`. Subsequent reads from it will return its default value.
  public mutating func clearInstance() {self._instance = nil}

  /// The time at which [UpdateInstance][google.spanner.admin.instance.v1.InstanceAdmin.UpdateInstance]
  /// request was received.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time at which this operation was cancelled. If set, this operation is
  /// in the process of undoing itself (which is guaranteed to succeed) and
  /// cannot be cancelled again.
  public var cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _cancelTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_cancelTime = newValue}
  }
  /// Returns true if `cancelTime` has been explicitly set.
  public var hasCancelTime: Bool {return self._cancelTime != nil}
  /// Clears the value of `cancelTime`. Subsequent reads from it will return its default value.
  public mutating func clearCancelTime() {self._cancelTime = nil}

  /// The time at which this operation failed or was completed successfully.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _instance: Google_Spanner_Admin_Instance_V1_Instance? = nil
  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _cancelTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.spanner.admin.instance.v1"

extension Google_Spanner_Admin_Instance_V1_ReplicaInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplicaInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "location"),
    2: .same(proto: "type"),
    3: .standard(proto: "default_leader_location"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.defaultLeaderLocation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 1)
    }
    if self.type != .typeUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    if self.defaultLeaderLocation != false {
      try visitor.visitSingularBoolField(value: self.defaultLeaderLocation, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_ReplicaInfo, rhs: Google_Spanner_Admin_Instance_V1_ReplicaInfo) -> Bool {
    if lhs.location != rhs.location {return false}
    if lhs.type != rhs.type {return false}
    if lhs.defaultLeaderLocation != rhs.defaultLeaderLocation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_ReplicaInfo.ReplicaType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "READ_WRITE"),
    2: .same(proto: "READ_ONLY"),
    3: .same(proto: "WITNESS"),
  ]
}

extension Google_Spanner_Admin_Instance_V1_InstanceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InstanceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "display_name"),
    3: .same(proto: "replicas"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.replicas) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 2)
    }
    if !self.replicas.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replicas, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_InstanceConfig, rhs: Google_Spanner_Admin_Instance_V1_InstanceConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.replicas != rhs.replicas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_Instance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Instance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "display_name"),
    5: .standard(proto: "node_count"),
    6: .same(proto: "state"),
    7: .same(proto: "labels"),
    8: .standard(proto: "endpoint_uris"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.config) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.nodeCount) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.endpointUris) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.config.isEmpty {
      try visitor.visitSingularStringField(value: self.config, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if self.nodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeCount, fieldNumber: 5)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 7)
    }
    if !self.endpointUris.isEmpty {
      try visitor.visitRepeatedStringField(value: self.endpointUris, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_Instance, rhs: Google_Spanner_Admin_Instance_V1_Instance) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.config != rhs.config {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.nodeCount != rhs.nodeCount {return false}
    if lhs.state != rhs.state {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.endpointUris != rhs.endpointUris {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_Instance.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_UNSPECIFIED"),
    1: .same(proto: "CREATING"),
    2: .same(proto: "READY"),
  ]
}

extension Google_Spanner_Admin_Instance_V1_ListInstanceConfigsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstanceConfigsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_ListInstanceConfigsRequest, rhs: Google_Spanner_Admin_Instance_V1_ListInstanceConfigsRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_ListInstanceConfigsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstanceConfigsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "instance_configs"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instanceConfigs) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instanceConfigs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instanceConfigs, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_ListInstanceConfigsResponse, rhs: Google_Spanner_Admin_Instance_V1_ListInstanceConfigsResponse) -> Bool {
    if lhs.instanceConfigs != rhs.instanceConfigs {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_GetInstanceConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInstanceConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_GetInstanceConfigRequest, rhs: Google_Spanner_Admin_Instance_V1_GetInstanceConfigRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_GetInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "field_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fieldMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._fieldMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_GetInstanceRequest, rhs: Google_Spanner_Admin_Instance_V1_GetInstanceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._fieldMask != rhs._fieldMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_CreateInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "instance_id"),
    3: .same(proto: "instance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.instanceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.instanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.instanceID, fieldNumber: 2)
    }
    if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_CreateInstanceRequest, rhs: Google_Spanner_Admin_Instance_V1_CreateInstanceRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.instanceID != rhs.instanceID {return false}
    if lhs._instance != rhs._instance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_ListInstancesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstancesRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .standard(proto: "page_size"),
    3: .standard(proto: "page_token"),
    4: .same(proto: "filter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_ListInstancesRequest, rhs: Google_Spanner_Admin_Instance_V1_ListInstancesRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_ListInstancesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListInstancesResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instances"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.instances) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.instances.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.instances, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_ListInstancesResponse, rhs: Google_Spanner_Admin_Instance_V1_ListInstancesResponse) -> Bool {
    if lhs.instances != rhs.instances {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_UpdateInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "field_mask"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fieldMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._fieldMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_UpdateInstanceRequest, rhs: Google_Spanner_Admin_Instance_V1_UpdateInstanceRequest) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs._fieldMask != rhs._fieldMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_DeleteInstanceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteInstanceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_DeleteInstanceRequest, rhs: Google_Spanner_Admin_Instance_V1_DeleteInstanceRequest) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_CreateInstanceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateInstanceMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "cancel_time"),
    4: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cancelTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._cancelTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_CreateInstanceMetadata, rhs: Google_Spanner_Admin_Instance_V1_CreateInstanceMetadata) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._cancelTime != rhs._cancelTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Spanner_Admin_Instance_V1_UpdateInstanceMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateInstanceMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "instance"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "cancel_time"),
    4: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._instance) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cancelTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._instance {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._cancelTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Spanner_Admin_Instance_V1_UpdateInstanceMetadata, rhs: Google_Spanner_Admin_Instance_V1_UpdateInstanceMetadata) -> Bool {
    if lhs._instance != rhs._instance {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._cancelTime != rhs._cancelTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

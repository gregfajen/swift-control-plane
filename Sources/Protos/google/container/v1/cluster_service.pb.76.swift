// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: google/container/v1/cluster_service.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Parameters that describe the nodes in a cluster.
public struct Google_Container_V1_NodeConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of a Google Compute Engine [machine
  /// type](https://cloud.google.com/compute/docs/machine-types) (e.g.
  /// `n1-standard-1`).
  ///
  /// If unspecified, the default machine type is
  /// `n1-standard-1`.
  public var machineType: String = String()

  /// Size of the disk attached to each node, specified in GB.
  /// The smallest allowed disk size is 10GB.
  ///
  /// If unspecified, the default disk size is 100GB.
  public var diskSizeGb: Int32 = 0

  /// The set of Google API scopes to be made available on all of the
  /// node VMs under the "default" service account.
  ///
  /// The following scopes are recommended, but not required, and by default are
  /// not included:
  ///
  /// * `https://www.googleapis.com/auth/compute` is required for mounting
  /// persistent storage on your nodes.
  /// * `https://www.googleapis.com/auth/devstorage.read_only` is required for
  /// communicating with **gcr.io**
  /// (the [Google Container Registry](https://cloud.google.com/container-registry/)).
  ///
  /// If unspecified, no scopes are added, unless Cloud Logging or Cloud
  /// Monitoring are enabled, in which case their required scopes will be added.
  public var oauthScopes: [String] = []

  /// The Google Cloud Platform Service Account to be used by the node VMs. If
  /// no Service Account is specified, the "default" service account is used.
  public var serviceAccount: String = String()

  /// The metadata key/value pairs assigned to instances in the cluster.
  ///
  /// Keys must conform to the regexp [a-zA-Z0-9-_]+ and be less than 128 bytes
  /// in length. These are reflected as part of a URL in the metadata server.
  /// Additionally, to avoid ambiguity, keys must not conflict with any other
  /// metadata keys for the project or be one of the reserved keys:
  ///  "cluster-location"
  ///  "cluster-name"
  ///  "cluster-uid"
  ///  "configure-sh"
  ///  "containerd-configure-sh"
  ///  "enable-os-login"
  ///  "gci-update-strategy"
  ///  "gci-ensure-gke-docker"
  ///  "instance-template"
  ///  "kube-env"
  ///  "startup-script"
  ///  "user-data"
  ///  "disable-address-manager"
  ///  "windows-startup-script-ps1"
  ///  "common-psm1"
  ///  "k8s-node-setup-psm1"
  ///  "install-ssh-psm1"
  ///  "user-profile-psm1"
  ///  "serial-port-logging-enable"
  ///
  /// Values are free-form strings, and only have meaning as interpreted by
  /// the image running in the instance. The only restriction placed on them is
  /// that each value's size must be less than or equal to 32 KB.
  ///
  /// The total size of all keys and values must be less than 512 KB.
  public var metadata: Dictionary<String,String> = [:]

  /// The image type to use for this node. Note that for a given image type,
  /// the latest version of it will be used.
  public var imageType: String = String()

  /// The map of Kubernetes labels (key/value pairs) to be applied to each node.
  /// These will added in addition to any default label(s) that
  /// Kubernetes may apply to the node.
  /// In case of conflict in label keys, the applied set may differ depending on
  /// the Kubernetes version -- it's best to assume the behavior is undefined
  /// and conflicts should be avoided.
  /// For more information, including usage and the valid values, see:
  /// https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  public var labels: Dictionary<String,String> = [:]

  /// The number of local SSD disks to be attached to the node.
  ///
  /// The limit for this value is dependent upon the maximum number of
  /// disks available on a machine per zone. See:
  /// https://cloud.google.com/compute/docs/disks/local-ssd
  /// for more information.
  public var localSsdCount: Int32 = 0

  /// The list of instance tags applied to all nodes. Tags are used to identify
  /// valid sources or targets for network firewalls and are specified by
  /// the client during cluster or node pool creation. Each tag within the list
  /// must comply with RFC1035.
  public var tags: [String] = []

  /// Whether the nodes are created as preemptible VM instances. See:
  /// https://cloud.google.com/compute/docs/instances/preemptible for more
  /// information about preemptible VM instances.
  public var preemptible: Bool = false

  /// A list of hardware accelerators to be attached to each node.
  /// See https://cloud.google.com/compute/docs/gpus for more information about
  /// support for GPUs.
  public var accelerators: [Google_Container_V1_AcceleratorConfig] = []

  /// Type of the disk attached to each node (e.g. 'pd-standard' or 'pd-ssd')
  ///
  /// If unspecified, the default disk type is 'pd-standard'
  public var diskType: String = String()

  /// Minimum CPU platform to be used by this instance. The instance may be
  /// scheduled on the specified or newer CPU platform. Applicable values are the
  /// friendly names of CPU platforms, such as
  /// <code>minCpuPlatform: &quot;Intel Haswell&quot;</code> or
  /// <code>minCpuPlatform: &quot;Intel Sandy Bridge&quot;</code>. For more
  /// information, read [how to specify min CPU
  /// platform](https://cloud.google.com/compute/docs/instances/specify-min-cpu-platform)
  public var minCpuPlatform: String = String()

  /// List of kubernetes taints to be applied to each node.
  ///
  /// For more information, including usage and the valid values, see:
  /// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  public var taints: [Google_Container_V1_NodeTaint] = []

  /// Shielded Instance options.
  public var shieldedInstanceConfig: Google_Container_V1_ShieldedInstanceConfig {
    get {return _shieldedInstanceConfig ?? Google_Container_V1_ShieldedInstanceConfig()}
    set {_shieldedInstanceConfig = newValue}
  }
  /// Returns true if `shieldedInstanceConfig` has been explicitly set.
  public var hasShieldedInstanceConfig: Bool {return self._shieldedInstanceConfig != nil}
  /// Clears the value of `shieldedInstanceConfig`. Subsequent reads from it will return its default value.
  public mutating func clearShieldedInstanceConfig() {self._shieldedInstanceConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _shieldedInstanceConfig: Google_Container_V1_ShieldedInstanceConfig? = nil
}

/// A set of Shielded Instance options.
public struct Google_Container_V1_ShieldedInstanceConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines whether the instance has Secure Boot enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails.
  public var enableSecureBoot: Bool = false

  /// Defines whether the instance has integrity monitoring enabled.
  ///
  /// Enables monitoring and attestation of the boot integrity of the instance.
  /// The attestation is performed against the integrity policy baseline. This
  /// baseline is initially derived from the implicitly trusted boot image when
  /// the instance is created.
  public var enableIntegrityMonitoring: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Kubernetes taint is comprised of three fields: key, value, and effect. Effect
/// can only be one of three types:  NoSchedule, PreferNoSchedule or NoExecute.
///
/// For more information, including usage and the valid values, see:
/// https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
public struct Google_Container_V1_NodeTaint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key for taint.
  public var key: String = String()

  /// Value for taint.
  public var value: String = String()

  /// Effect for taint.
  public var effect: Google_Container_V1_NodeTaint.Effect = .unspecified

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible values for Effect in taint.
  public enum Effect: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set
    case unspecified // = 0

    /// NoSchedule
    case noSchedule // = 1

    /// PreferNoSchedule
    case preferNoSchedule // = 2

    /// NoExecute
    case noExecute // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .noSchedule
      case 2: self = .preferNoSchedule
      case 3: self = .noExecute
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .noSchedule: return 1
      case .preferNoSchedule: return 2
      case .noExecute: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1_NodeTaint.Effect: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_NodeTaint.Effect] = [
    .unspecified,
    .noSchedule,
    .preferNoSchedule,
    .noExecute,
  ]
}

#endif  // swift(>=4.2)

/// The authentication information for accessing the master endpoint.
/// Authentication can be done using HTTP basic auth or using client
/// certificates.
public struct Google_Container_V1_MasterAuth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The username to use for HTTP basic authentication to the master endpoint.
  /// For clusters v1.6.0 and later, basic authentication can be disabled by
  /// leaving username unspecified (or setting it to the empty string).
  public var username: String = String()

  /// The password to use for HTTP basic authentication to the master endpoint.
  /// Because the master endpoint is open to the Internet, you should create a
  /// strong password.  If a password is provided for cluster creation, username
  /// must be non-empty.
  public var password: String = String()

  /// Configuration for client certificate authentication on the cluster. For
  /// clusters before v1.12, if no configuration is specified, a client
  /// certificate is issued.
  public var clientCertificateConfig: Google_Container_V1_ClientCertificateConfig {
    get {return _clientCertificateConfig ?? Google_Container_V1_ClientCertificateConfig()}
    set {_clientCertificateConfig = newValue}
  }
  /// Returns true if `clientCertificateConfig` has been explicitly set.
  public var hasClientCertificateConfig: Bool {return self._clientCertificateConfig != nil}
  /// Clears the value of `clientCertificateConfig`. Subsequent reads from it will return its default value.
  public mutating func clearClientCertificateConfig() {self._clientCertificateConfig = nil}

  /// [Output only] Base64-encoded public certificate that is the root of
  /// trust for the cluster.
  public var clusterCaCertificate: String = String()

  /// [Output only] Base64-encoded public certificate used by clients to
  /// authenticate to the cluster endpoint.
  public var clientCertificate: String = String()

  /// [Output only] Base64-encoded private key used by clients to authenticate
  /// to the cluster endpoint.
  public var clientKey: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _clientCertificateConfig: Google_Container_V1_ClientCertificateConfig? = nil
}

/// Configuration for client certificates on the cluster.
public struct Google_Container_V1_ClientCertificateConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Issue a client certificate.
  public var issueClientCertificate: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the addons that can be automatically spun up in the
/// cluster, enabling additional functionality.
public struct Google_Container_V1_AddonsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration for the HTTP (L7) load balancing controller addon, which
  /// makes it easy to set up HTTP load balancers for services in a cluster.
  public var httpLoadBalancing: Google_Container_V1_HttpLoadBalancing {
    get {return _httpLoadBalancing ?? Google_Container_V1_HttpLoadBalancing()}
    set {_httpLoadBalancing = newValue}
  }
  /// Returns true if `httpLoadBalancing` has been explicitly set.
  public var hasHTTPLoadBalancing: Bool {return self._httpLoadBalancing != nil}
  /// Clears the value of `httpLoadBalancing`. Subsequent reads from it will return its default value.
  public mutating func clearHTTPLoadBalancing() {self._httpLoadBalancing = nil}

  /// Configuration for the horizontal pod autoscaling feature, which
  /// increases or decreases the number of replica pods a replication controller
  /// has based on the resource usage of the existing pods.
  public var horizontalPodAutoscaling: Google_Container_V1_HorizontalPodAutoscaling {
    get {return _horizontalPodAutoscaling ?? Google_Container_V1_HorizontalPodAutoscaling()}
    set {_horizontalPodAutoscaling = newValue}
  }
  /// Returns true if `horizontalPodAutoscaling` has been explicitly set.
  public var hasHorizontalPodAutoscaling: Bool {return self._horizontalPodAutoscaling != nil}
  /// Clears the value of `horizontalPodAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearHorizontalPodAutoscaling() {self._horizontalPodAutoscaling = nil}

  /// Configuration for the Kubernetes Dashboard.
  /// This addon is deprecated, and will be disabled in 1.15. It is recommended
  /// to use the Cloud Console to manage and monitor your Kubernetes clusters,
  /// workloads and applications. For more information, see:
  /// https://cloud.google.com/kubernetes-engine/docs/concepts/dashboards
  public var kubernetesDashboard: Google_Container_V1_KubernetesDashboard {
    get {return _kubernetesDashboard ?? Google_Container_V1_KubernetesDashboard()}
    set {_kubernetesDashboard = newValue}
  }
  /// Returns true if `kubernetesDashboard` has been explicitly set.
  public var hasKubernetesDashboard: Bool {return self._kubernetesDashboard != nil}
  /// Clears the value of `kubernetesDashboard`. Subsequent reads from it will return its default value.
  public mutating func clearKubernetesDashboard() {self._kubernetesDashboard = nil}

  /// Configuration for NetworkPolicy. This only tracks whether the addon
  /// is enabled or not on the Master, it does not track whether network policy
  /// is enabled for the nodes.
  public var networkPolicyConfig: Google_Container_V1_NetworkPolicyConfig {
    get {return _networkPolicyConfig ?? Google_Container_V1_NetworkPolicyConfig()}
    set {_networkPolicyConfig = newValue}
  }
  /// Returns true if `networkPolicyConfig` has been explicitly set.
  public var hasNetworkPolicyConfig: Bool {return self._networkPolicyConfig != nil}
  /// Clears the value of `networkPolicyConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkPolicyConfig() {self._networkPolicyConfig = nil}

  /// Configuration for the Cloud Run addon, which allows the user to use a
  /// managed Knative service.
  public var cloudRunConfig: Google_Container_V1_CloudRunConfig {
    get {return _cloudRunConfig ?? Google_Container_V1_CloudRunConfig()}
    set {_cloudRunConfig = newValue}
  }
  /// Returns true if `cloudRunConfig` has been explicitly set.
  public var hasCloudRunConfig: Bool {return self._cloudRunConfig != nil}
  /// Clears the value of `cloudRunConfig`. Subsequent reads from it will return its default value.
  public mutating func clearCloudRunConfig() {self._cloudRunConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _httpLoadBalancing: Google_Container_V1_HttpLoadBalancing? = nil
  fileprivate var _horizontalPodAutoscaling: Google_Container_V1_HorizontalPodAutoscaling? = nil
  fileprivate var _kubernetesDashboard: Google_Container_V1_KubernetesDashboard? = nil
  fileprivate var _networkPolicyConfig: Google_Container_V1_NetworkPolicyConfig? = nil
  fileprivate var _cloudRunConfig: Google_Container_V1_CloudRunConfig? = nil
}

/// Configuration options for the HTTP (L7) load balancing controller addon,
/// which makes it easy to set up HTTP load balancers for services in a cluster.
public struct Google_Container_V1_HttpLoadBalancing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the HTTP Load Balancing controller is enabled in the cluster.
  /// When enabled, it runs a small pod in the cluster that manages the load
  /// balancers.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for the horizontal pod autoscaling feature, which
/// increases or decreases the number of replica pods a replication controller
/// has based on the resource usage of the existing pods.
public struct Google_Container_V1_HorizontalPodAutoscaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the Horizontal Pod Autoscaling feature is enabled in the cluster.
  /// When enabled, it ensures that a Heapster pod is running in the cluster,
  /// which is also used by the Cloud Monitoring service.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for the Kubernetes Dashboard.
public struct Google_Container_V1_KubernetesDashboard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the Kubernetes Dashboard is enabled for this cluster.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for NetworkPolicy. This only tracks whether the addon
/// is enabled or not on the Master, it does not track whether network policy
/// is enabled for the nodes.
public struct Google_Container_V1_NetworkPolicyConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether NetworkPolicy is enabled for this cluster.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for private clusters.
public struct Google_Container_V1_PrivateClusterConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether nodes have internal IP addresses only. If enabled, all nodes are
  /// given only RFC 1918 private addresses and communicate with the master via
  /// private networking.
  public var enablePrivateNodes: Bool = false

  /// Whether the master's internal IP address is used as the cluster endpoint.
  public var enablePrivateEndpoint: Bool = false

  /// The IP range in CIDR notation to use for the hosted master network. This
  /// range will be used for assigning internal IP addresses to the master or
  /// set of masters, as well as the ILB VIP. This range must not overlap with
  /// any other ranges in use within the cluster's network.
  public var masterIpv4CidrBlock: String = String()

  /// Output only. The internal IP address of this cluster's master endpoint.
  public var privateEndpoint: String = String()

  /// Output only. The external IP address of this cluster's master endpoint.
  public var publicEndpoint: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for returning group information from authenticators.
public struct Google_Container_V1_AuthenticatorGroupsConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether this cluster should return group membership lookups
  /// during authentication using a group of security groups.
  public var enabled: Bool = false

  /// The name of the security group-of-groups to be used. Only relevant
  /// if enabled = true.
  public var securityGroup: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for the Cloud Run feature.
public struct Google_Container_V1_CloudRunConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether Cloud Run addon is enabled for this cluster.
  public var disabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for the master authorized networks feature. Enabled
/// master authorized networks will disallow all external traffic to access
/// Kubernetes master through HTTPS except traffic from the given CIDR blocks,
/// Google Compute Engine Public IPs and Google Prod IPs.
public struct Google_Container_V1_MasterAuthorizedNetworksConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether or not master authorized networks is enabled.
  public var enabled: Bool = false

  /// cidr_blocks define up to 50 external networks that could access
  /// Kubernetes master through HTTPS.
  public var cidrBlocks: [Google_Container_V1_MasterAuthorizedNetworksConfig.CidrBlock] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// CidrBlock contains an optional name and one CIDR block.
  public struct CidrBlock {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// display_name is an optional field for users to identify CIDR blocks.
    public var displayName: String = String()

    /// cidr_block must be specified in CIDR notation.
    public var cidrBlock: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Configuration for the legacy Attribute Based Access Control authorization
/// mode.
public struct Google_Container_V1_LegacyAbac {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the ABAC authorizer is enabled for this cluster. When enabled,
  /// identities in the system, including service accounts, nodes, and
  /// controllers, will have statically granted permissions beyond those
  /// provided by the RBAC configuration or IAM.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration options for the NetworkPolicy feature.
/// https://kubernetes.io/docs/concepts/services-networking/networkpolicies/
public struct Google_Container_V1_NetworkPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The selected network policy provider.
  public var provider: Google_Container_V1_NetworkPolicy.Provider = .unspecified

  /// Whether network policy is enabled on the cluster.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Allowed Network Policy providers.
  public enum Provider: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set
    case unspecified // = 0

    /// Tigera (Calico Felix).
    case calico // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .calico
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .calico: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1_NetworkPolicy.Provider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_NetworkPolicy.Provider] = [
    .unspecified,
    .calico,
  ]
}

#endif  // swift(>=4.2)

/// Configuration for Binary Authorization.
public struct Google_Container_V1_BinaryAuthorization {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enable Binary Authorization for this cluster. If enabled, all container
  /// images will be validated by Binary Authorization.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for controlling how IPs are allocated in the cluster.
public struct Google_Container_V1_IPAllocationPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether alias IPs will be used for pod IPs in the cluster.
  public var useIpAliases: Bool = false

  /// Whether a new subnetwork will be created automatically for the cluster.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  public var createSubnetwork: Bool = false

  /// A custom subnetwork name to be used if `create_subnetwork` is true.  If
  /// this field is empty, then an automatic name will be chosen for the new
  /// subnetwork.
  public var subnetworkName: String = String()

  /// This field is deprecated, use cluster_ipv4_cidr_block.
  public var clusterIpv4Cidr: String = String()

  /// This field is deprecated, use node_ipv4_cidr_block.
  public var nodeIpv4Cidr: String = String()

  /// This field is deprecated, use services_ipv4_cidr_block.
  public var servicesIpv4Cidr: String = String()

  /// The name of the secondary range to be used for the cluster CIDR
  /// block.  The secondary range will be used for pod IP
  /// addresses. This must be an existing secondary range associated
  /// with the cluster subnetwork.
  ///
  /// This field is only applicable with use_ip_aliases is true and
  /// create_subnetwork is false.
  public var clusterSecondaryRangeName: String = String()

  /// The name of the secondary range to be used as for the services
  /// CIDR block.  The secondary range will be used for service
  /// ClusterIPs. This must be an existing secondary range associated
  /// with the cluster subnetwork.
  ///
  /// This field is only applicable with use_ip_aliases is true and
  /// create_subnetwork is false.
  public var servicesSecondaryRangeName: String = String()

  /// The IP address range for the cluster pod IPs. If this field is set, then
  /// `cluster.cluster_ipv4_cidr` must be left blank.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  ///
  /// Set to blank to have a range chosen with the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var clusterIpv4CidrBlock: String = String()

  /// The IP address range of the instance IPs in this cluster.
  ///
  /// This is applicable only if `create_subnetwork` is true.
  ///
  /// Set to blank to have a range chosen with the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var nodeIpv4CidrBlock: String = String()

  /// The IP address range of the services IPs in this cluster. If blank, a range
  /// will be automatically chosen with the default size.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  ///
  /// Set to blank to have a range chosen with the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var servicesIpv4CidrBlock: String = String()

  /// The IP address range of the Cloud TPUs in this cluster. If unspecified, a
  /// range will be automatically chosen with the default size.
  ///
  /// This field is only applicable when `use_ip_aliases` is true.
  ///
  /// If unspecified, the range will use the default size.
  ///
  /// Set to /netmask (e.g. `/14`) to have a range chosen with a specific
  /// netmask.
  ///
  /// Set to a
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`) from the RFC-1918 private networks (e.g.
  /// `10.0.0.0/8`, `172.16.0.0/12`, `192.168.0.0/16`) to pick a specific range
  /// to use.
  public var tpuIpv4CidrBlock: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A Google Kubernetes Engine cluster.
public struct Google_Container_V1_Cluster {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of this cluster. The name must be unique within this project
  /// and location (e.g. zone or region), and can be up to 40 characters with
  /// the following restrictions:
  ///
  /// * Lowercase letters, numbers, and hyphens only.
  /// * Must start with a letter.
  /// * Must end with a number or a letter.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// An optional description of this cluster.
  public var description_p: String {
    get {return _storage._description_p}
    set {_uniqueStorage()._description_p = newValue}
  }

  /// The number of nodes to create in this cluster. You must ensure that your
  /// Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
  /// is sufficient for this number of instances. You must also have available
  /// firewall and routes quota.
  /// For requests, this field should only be used in lieu of a
  /// "node_pool" object, since this configuration (along with the
  /// "node_config") will be used to create a "NodePool" object with an
  /// auto-generated name. Do not use this and a node_pool at the same time.
  ///
  /// This field is deprecated, use node_pool.initial_node_count instead.
  public var initialNodeCount: Int32 {
    get {return _storage._initialNodeCount}
    set {_uniqueStorage()._initialNodeCount = newValue}
  }

  /// Parameters used in creating the cluster's nodes.
  /// For requests, this field should only be used in lieu of a
  /// "node_pool" object, since this configuration (along with the
  /// "initial_node_count") will be used to create a "NodePool" object with an
  /// auto-generated name. Do not use this and a node_pool at the same time.
  /// For responses, this field will be populated with the node configuration of
  /// the first node pool. (For configuration of each node pool, see
  /// `node_pool.config`)
  ///
  /// If unspecified, the defaults are used.
  /// This field is deprecated, use node_pool.config instead.
  public var nodeConfig: Google_Container_V1_NodeConfig {
    get {return _storage._nodeConfig ?? Google_Container_V1_NodeConfig()}
    set {_uniqueStorage()._nodeConfig = newValue}
  }
  /// Returns true if `nodeConfig` has been explicitly set.
  public var hasNodeConfig: Bool {return _storage._nodeConfig != nil}
  /// Clears the value of `nodeConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNodeConfig() {_uniqueStorage()._nodeConfig = nil}

  /// The authentication information for accessing the master endpoint.
  /// If unspecified, the defaults are used:
  /// For clusters before v1.12, if master_auth is unspecified, `username` will
  /// be set to "admin", a random password will be generated, and a client
  /// certificate will be issued.
  public var masterAuth: Google_Container_V1_MasterAuth {
    get {return _storage._masterAuth ?? Google_Container_V1_MasterAuth()}
    set {_uniqueStorage()._masterAuth = newValue}
  }
  /// Returns true if `masterAuth` has been explicitly set.
  public var hasMasterAuth: Bool {return _storage._masterAuth != nil}
  /// Clears the value of `masterAuth`. Subsequent reads from it will return its default value.
  public mutating func clearMasterAuth() {_uniqueStorage()._masterAuth = nil}

  /// The logging service the cluster should use to write logs.
  /// Currently available options:
  ///
  /// * "logging.googleapis.com/kubernetes" - the Google Cloud Logging
  /// service with Kubernetes-native resource model
  /// * `logging.googleapis.com` - the Google Cloud Logging service.
  /// * `none` - no logs will be exported from the cluster.
  /// * if left as an empty string,`logging.googleapis.com` will be used.
  public var loggingService: String {
    get {return _storage._loggingService}
    set {_uniqueStorage()._loggingService = newValue}
  }

  /// The monitoring service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * `monitoring.googleapis.com` - the Google Cloud Monitoring service.
  /// * `none` - no metrics will be exported from the cluster.
  /// * if left as an empty string, `monitoring.googleapis.com` will be used.
  public var monitoringService: String {
    get {return _storage._monitoringService}
    set {_uniqueStorage()._monitoringService = newValue}
  }

  /// The name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks) to which the
  /// cluster is connected. If left unspecified, the `default` network
  /// will be used.
  public var network: String {
    get {return _storage._network}
    set {_uniqueStorage()._network = newValue}
  }

  /// The IP address range of the container pods in this cluster, in
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `10.96.0.0/14`). Leave blank to have
  /// one automatically chosen or specify a `/14` block in `10.0.0.0/8`.
  public var clusterIpv4Cidr: String {
    get {return _storage._clusterIpv4Cidr}
    set {_uniqueStorage()._clusterIpv4Cidr = newValue}
  }

  /// Configurations for the various addons available to run in the cluster.
  public var addonsConfig: Google_Container_V1_AddonsConfig {
    get {return _storage._addonsConfig ?? Google_Container_V1_AddonsConfig()}
    set {_uniqueStorage()._addonsConfig = newValue}
  }
  /// Returns true if `addonsConfig` has been explicitly set.
  public var hasAddonsConfig: Bool {return _storage._addonsConfig != nil}
  /// Clears the value of `addonsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAddonsConfig() {_uniqueStorage()._addonsConfig = nil}

  /// The name of the Google Compute Engine
  /// [subnetwork](https://cloud.google.com/compute/docs/subnetworks) to which the
  /// cluster is connected.
  public var subnetwork: String {
    get {return _storage._subnetwork}
    set {_uniqueStorage()._subnetwork = newValue}
  }

  /// The node pools associated with this cluster.
  /// This field should not be set if "node_config" or "initial_node_count" are
  /// specified.
  public var nodePools: [Google_Container_V1_NodePool] {
    get {return _storage._nodePools}
    set {_uniqueStorage()._nodePools = newValue}
  }

  /// The list of Google Compute Engine
  /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the cluster's nodes
  /// should be located.
  public var locations: [String] {
    get {return _storage._locations}
    set {_uniqueStorage()._locations = newValue}
  }

  /// Kubernetes alpha features are enabled on this cluster. This includes alpha
  /// API groups (e.g. v1alpha1) and features that may not be production ready in
  /// the kubernetes version of the master and nodes.
  /// The cluster has no SLA for uptime and master/node upgrades are disabled.
  /// Alpha enabled clusters are automatically deleted thirty days after
  /// creation.
  public var enableKubernetesAlpha: Bool {
    get {return _storage._enableKubernetesAlpha}
    set {_uniqueStorage()._enableKubernetesAlpha = newValue}
  }

  /// The resource labels for the cluster to use to annotate any related
  /// Google Compute Engine resources.
  public var resourceLabels: Dictionary<String,String> {
    get {return _storage._resourceLabels}
    set {_uniqueStorage()._resourceLabels = newValue}
  }

  /// The fingerprint of the set of labels for this cluster.
  public var labelFingerprint: String {
    get {return _storage._labelFingerprint}
    set {_uniqueStorage()._labelFingerprint = newValue}
  }

  /// Configuration for the legacy ABAC authorization mode.
  public var legacyAbac: Google_Container_V1_LegacyAbac {
    get {return _storage._legacyAbac ?? Google_Container_V1_LegacyAbac()}
    set {_uniqueStorage()._legacyAbac = newValue}
  }
  /// Returns true if `legacyAbac` has been explicitly set.
  public var hasLegacyAbac: Bool {return _storage._legacyAbac != nil}
  /// Clears the value of `legacyAbac`. Subsequent reads from it will return its default value.
  public mutating func clearLegacyAbac() {_uniqueStorage()._legacyAbac = nil}

  /// Configuration options for the NetworkPolicy feature.
  public var networkPolicy: Google_Container_V1_NetworkPolicy {
    get {return _storage._networkPolicy ?? Google_Container_V1_NetworkPolicy()}
    set {_uniqueStorage()._networkPolicy = newValue}
  }
  /// Returns true if `networkPolicy` has been explicitly set.
  public var hasNetworkPolicy: Bool {return _storage._networkPolicy != nil}
  /// Clears the value of `networkPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkPolicy() {_uniqueStorage()._networkPolicy = nil}

  /// Configuration for cluster IP allocation.
  public var ipAllocationPolicy: Google_Container_V1_IPAllocationPolicy {
    get {return _storage._ipAllocationPolicy ?? Google_Container_V1_IPAllocationPolicy()}
    set {_uniqueStorage()._ipAllocationPolicy = newValue}
  }
  /// Returns true if `ipAllocationPolicy` has been explicitly set.
  public var hasIpAllocationPolicy: Bool {return _storage._ipAllocationPolicy != nil}
  /// Clears the value of `ipAllocationPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearIpAllocationPolicy() {_uniqueStorage()._ipAllocationPolicy = nil}

  /// The configuration options for master authorized networks feature.
  public var masterAuthorizedNetworksConfig: Google_Container_V1_MasterAuthorizedNetworksConfig {
    get {return _storage._masterAuthorizedNetworksConfig ?? Google_Container_V1_MasterAuthorizedNetworksConfig()}
    set {_uniqueStorage()._masterAuthorizedNetworksConfig = newValue}
  }
  /// Returns true if `masterAuthorizedNetworksConfig` has been explicitly set.
  public var hasMasterAuthorizedNetworksConfig: Bool {return _storage._masterAuthorizedNetworksConfig != nil}
  /// Clears the value of `masterAuthorizedNetworksConfig`. Subsequent reads from it will return its default value.
  public mutating func clearMasterAuthorizedNetworksConfig() {_uniqueStorage()._masterAuthorizedNetworksConfig = nil}

  /// Configure the maintenance policy for this cluster.
  public var maintenancePolicy: Google_Container_V1_MaintenancePolicy {
    get {return _storage._maintenancePolicy ?? Google_Container_V1_MaintenancePolicy()}
    set {_uniqueStorage()._maintenancePolicy = newValue}
  }
  /// Returns true if `maintenancePolicy` has been explicitly set.
  public var hasMaintenancePolicy: Bool {return _storage._maintenancePolicy != nil}
  /// Clears the value of `maintenancePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearMaintenancePolicy() {_uniqueStorage()._maintenancePolicy = nil}

  /// Configuration for Binary Authorization.
  public var binaryAuthorization: Google_Container_V1_BinaryAuthorization {
    get {return _storage._binaryAuthorization ?? Google_Container_V1_BinaryAuthorization()}
    set {_uniqueStorage()._binaryAuthorization = newValue}
  }
  /// Returns true if `binaryAuthorization` has been explicitly set.
  public var hasBinaryAuthorization: Bool {return _storage._binaryAuthorization != nil}
  /// Clears the value of `binaryAuthorization`. Subsequent reads from it will return its default value.
  public mutating func clearBinaryAuthorization() {_uniqueStorage()._binaryAuthorization = nil}

  /// Cluster-level autoscaling configuration.
  public var autoscaling: Google_Container_V1_ClusterAutoscaling {
    get {return _storage._autoscaling ?? Google_Container_V1_ClusterAutoscaling()}
    set {_uniqueStorage()._autoscaling = newValue}
  }
  /// Returns true if `autoscaling` has been explicitly set.
  public var hasAutoscaling: Bool {return _storage._autoscaling != nil}
  /// Clears the value of `autoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscaling() {_uniqueStorage()._autoscaling = nil}

  /// Configuration for cluster networking.
  public var networkConfig: Google_Container_V1_NetworkConfig {
    get {return _storage._networkConfig ?? Google_Container_V1_NetworkConfig()}
    set {_uniqueStorage()._networkConfig = newValue}
  }
  /// Returns true if `networkConfig` has been explicitly set.
  public var hasNetworkConfig: Bool {return _storage._networkConfig != nil}
  /// Clears the value of `networkConfig`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkConfig() {_uniqueStorage()._networkConfig = nil}

  /// The default constraint on the maximum number of pods that can be run
  /// simultaneously on a node in the node pool of this cluster. Only honored
  /// if cluster created with IP Alias support.
  public var defaultMaxPodsConstraint: Google_Container_V1_MaxPodsConstraint {
    get {return _storage._defaultMaxPodsConstraint ?? Google_Container_V1_MaxPodsConstraint()}
    set {_uniqueStorage()._defaultMaxPodsConstraint = newValue}
  }
  /// Returns true if `defaultMaxPodsConstraint` has been explicitly set.
  public var hasDefaultMaxPodsConstraint: Bool {return _storage._defaultMaxPodsConstraint != nil}
  /// Clears the value of `defaultMaxPodsConstraint`. Subsequent reads from it will return its default value.
  public mutating func clearDefaultMaxPodsConstraint() {_uniqueStorage()._defaultMaxPodsConstraint = nil}

  /// Configuration for exporting resource usages. Resource usage export is
  /// disabled when this config is unspecified.
  public var resourceUsageExportConfig: Google_Container_V1_ResourceUsageExportConfig {
    get {return _storage._resourceUsageExportConfig ?? Google_Container_V1_ResourceUsageExportConfig()}
    set {_uniqueStorage()._resourceUsageExportConfig = newValue}
  }
  /// Returns true if `resourceUsageExportConfig` has been explicitly set.
  public var hasResourceUsageExportConfig: Bool {return _storage._resourceUsageExportConfig != nil}
  /// Clears the value of `resourceUsageExportConfig`. Subsequent reads from it will return its default value.
  public mutating func clearResourceUsageExportConfig() {_uniqueStorage()._resourceUsageExportConfig = nil}

  /// Configuration controlling RBAC group membership information.
  public var authenticatorGroupsConfig: Google_Container_V1_AuthenticatorGroupsConfig {
    get {return _storage._authenticatorGroupsConfig ?? Google_Container_V1_AuthenticatorGroupsConfig()}
    set {_uniqueStorage()._authenticatorGroupsConfig = newValue}
  }
  /// Returns true if `authenticatorGroupsConfig` has been explicitly set.
  public var hasAuthenticatorGroupsConfig: Bool {return _storage._authenticatorGroupsConfig != nil}
  /// Clears the value of `authenticatorGroupsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAuthenticatorGroupsConfig() {_uniqueStorage()._authenticatorGroupsConfig = nil}

  /// Configuration for private cluster.
  public var privateClusterConfig: Google_Container_V1_PrivateClusterConfig {
    get {return _storage._privateClusterConfig ?? Google_Container_V1_PrivateClusterConfig()}
    set {_uniqueStorage()._privateClusterConfig = newValue}
  }
  /// Returns true if `privateClusterConfig` has been explicitly set.
  public var hasPrivateClusterConfig: Bool {return _storage._privateClusterConfig != nil}
  /// Clears the value of `privateClusterConfig`. Subsequent reads from it will return its default value.
  public mutating func clearPrivateClusterConfig() {_uniqueStorage()._privateClusterConfig = nil}

  /// Configuration of etcd encryption.
  public var databaseEncryption: Google_Container_V1_DatabaseEncryption {
    get {return _storage._databaseEncryption ?? Google_Container_V1_DatabaseEncryption()}
    set {_uniqueStorage()._databaseEncryption = newValue}
  }
  /// Returns true if `databaseEncryption` has been explicitly set.
  public var hasDatabaseEncryption: Bool {return _storage._databaseEncryption != nil}
  /// Clears the value of `databaseEncryption`. Subsequent reads from it will return its default value.
  public mutating func clearDatabaseEncryption() {_uniqueStorage()._databaseEncryption = nil}

  /// Cluster-level Vertical Pod Autoscaling configuration.
  public var verticalPodAutoscaling: Google_Container_V1_VerticalPodAutoscaling {
    get {return _storage._verticalPodAutoscaling ?? Google_Container_V1_VerticalPodAutoscaling()}
    set {_uniqueStorage()._verticalPodAutoscaling = newValue}
  }
  /// Returns true if `verticalPodAutoscaling` has been explicitly set.
  public var hasVerticalPodAutoscaling: Bool {return _storage._verticalPodAutoscaling != nil}
  /// Clears the value of `verticalPodAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearVerticalPodAutoscaling() {_uniqueStorage()._verticalPodAutoscaling = nil}

  /// [Output only] Server-defined URL for the resource.
  public var selfLink: String {
    get {return _storage._selfLink}
    set {_uniqueStorage()._selfLink = newValue}
  }

  /// [Output only] The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field is deprecated, use location instead.
  public var zone: String {
    get {return _storage._zone}
    set {_uniqueStorage()._zone = newValue}
  }

  /// [Output only] The IP address of this cluster's master endpoint.
  /// The endpoint can be accessed from the internet at
  /// `https://username:password@endpoint/`.
  ///
  /// See the `masterAuth` property of this resource for username and
  /// password information.
  public var endpoint: String {
    get {return _storage._endpoint}
    set {_uniqueStorage()._endpoint = newValue}
  }

  /// The initial Kubernetes version for this cluster.  Valid versions are those
  /// found in validMasterVersions returned by getServerConfig.  The version can
  /// be upgraded over time; such upgrades are reflected in
  /// currentMasterVersion and currentNodeVersion.
  ///
  /// Users may specify either explicit versions offered by
  /// Kubernetes Engine or version aliases, which have the following behavior:
  ///
  /// - "latest": picks the highest valid Kubernetes version
  /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
  /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
  /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
  /// - "","-": picks the default Kubernetes version
  public var initialClusterVersion: String {
    get {return _storage._initialClusterVersion}
    set {_uniqueStorage()._initialClusterVersion = newValue}
  }

  /// [Output only] The current software version of the master endpoint.
  public var currentMasterVersion: String {
    get {return _storage._currentMasterVersion}
    set {_uniqueStorage()._currentMasterVersion = newValue}
  }

  /// [Output only] Deprecated, use
  /// [NodePools.version](https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools)
  /// instead. The current version of the node software components. If they are
  /// currently at multiple versions because they're in the process of being
  /// upgraded, this reflects the minimum version of all nodes.
  public var currentNodeVersion: String {
    get {return _storage._currentNodeVersion}
    set {_uniqueStorage()._currentNodeVersion = newValue}
  }

  /// [Output only] The time the cluster was created, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var createTime: String {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// [Output only] The current status of this cluster.
  public var status: Google_Container_V1_Cluster.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// [Output only] Additional information about the current status of this
  /// cluster, if available.
  public var statusMessage: String {
    get {return _storage._statusMessage}
    set {_uniqueStorage()._statusMessage = newValue}
  }

  /// [Output only] The size of the address space on each node for hosting
  /// containers. This is provisioned from within the `container_ipv4_cidr`
  /// range. This field will only be set when cluster is in route-based network
  /// mode.
  public var nodeIpv4CidrSize: Int32 {
    get {return _storage._nodeIpv4CidrSize}
    set {_uniqueStorage()._nodeIpv4CidrSize = newValue}
  }

  /// [Output only] The IP address range of the Kubernetes services in
  /// this cluster, in
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `1.2.3.4/29`). Service addresses are
  /// typically put in the last `/16` from the container CIDR.
  public var servicesIpv4Cidr: String {
    get {return _storage._servicesIpv4Cidr}
    set {_uniqueStorage()._servicesIpv4Cidr = newValue}
  }

  /// Deprecated. Use node_pools.instance_group_urls.
  public var instanceGroupUrls: [String] {
    get {return _storage._instanceGroupUrls}
    set {_uniqueStorage()._instanceGroupUrls = newValue}
  }

  /// [Output only]  The number of nodes currently in the cluster. Deprecated.
  /// Call Kubernetes API directly to retrieve node information.
  public var currentNodeCount: Int32 {
    get {return _storage._currentNodeCount}
    set {_uniqueStorage()._currentNodeCount = newValue}
  }

  /// [Output only] The time the cluster will be automatically
  /// deleted in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var expireTime: String {
    get {return _storage._expireTime}
    set {_uniqueStorage()._expireTime = newValue}
  }

  /// [Output only] The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) or
  /// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) in which
  /// the cluster resides.
  public var location: String {
    get {return _storage._location}
    set {_uniqueStorage()._location = newValue}
  }

  /// Enable the ability to use Cloud TPUs in this cluster.
  public var enableTpu: Bool {
    get {return _storage._enableTpu}
    set {_uniqueStorage()._enableTpu = newValue}
  }

  /// [Output only] The IP address range of the Cloud TPUs in this cluster, in
  /// [CIDR](http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)
  /// notation (e.g. `1.2.3.4/29`).
  public var tpuIpv4CidrBlock: String {
    get {return _storage._tpuIpv4CidrBlock}
    set {_uniqueStorage()._tpuIpv4CidrBlock = newValue}
  }

  /// Which conditions caused the current cluster state.
  public var conditions: [Google_Container_V1_StatusCondition] {
    get {return _storage._conditions}
    set {_uniqueStorage()._conditions = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current status of the cluster.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The PROVISIONING state indicates the cluster is being created.
    case provisioning // = 1

    /// The RUNNING state indicates the cluster has been created and is fully
    /// usable.
    case running // = 2

    /// The RECONCILING state indicates that some work is actively being done on
    /// the cluster, such as upgrading the master or node software. Details can
    /// be found in the `statusMessage` field.
    case reconciling // = 3

    /// The STOPPING state indicates the cluster is being deleted.
    case stopping // = 4

    /// The ERROR state indicates the cluster may be unusable. Details
    /// can be found in the `statusMessage` field.
    case error // = 5

    /// The DEGRADED state indicates the cluster requires user action to restore
    /// full functionality. Details can be found in the `statusMessage` field.
    case degraded // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .provisioning
      case 2: self = .running
      case 3: self = .reconciling
      case 4: self = .stopping
      case 5: self = .error
      case 6: self = .degraded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .provisioning: return 1
      case .running: return 2
      case .reconciling: return 3
      case .stopping: return 4
      case .error: return 5
      case .degraded: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Container_V1_Cluster.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_Cluster.Status] = [
    .unspecified,
    .provisioning,
    .running,
    .reconciling,
    .stopping,
    .error,
    .degraded,
  ]
}

#endif  // swift(>=4.2)

/// ClusterUpdate describes an update to the cluster. Exactly one update can
/// be applied to a cluster with each request, so at most one field can be
/// provided.
public struct Google_Container_V1_ClusterUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Kubernetes version to change the nodes to (typically an
  /// upgrade).
  ///
  /// Users may specify either explicit versions offered by
  /// Kubernetes Engine or version aliases, which have the following behavior:
  ///
  /// - "latest": picks the highest valid Kubernetes version
  /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
  /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
  /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
  /// - "-": picks the Kubernetes master version
  public var desiredNodeVersion: String {
    get {return _storage._desiredNodeVersion}
    set {_uniqueStorage()._desiredNodeVersion = newValue}
  }

  /// The monitoring service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * "monitoring.googleapis.com/kubernetes" - the Google Cloud Monitoring
  /// service with Kubernetes-native resource model
  /// * "monitoring.googleapis.com" - the Google Cloud Monitoring service
  /// * "none" - no metrics will be exported from the cluster
  public var desiredMonitoringService: String {
    get {return _storage._desiredMonitoringService}
    set {_uniqueStorage()._desiredMonitoringService = newValue}
  }

  /// Configurations for the various addons available to run in the cluster.
  public var desiredAddonsConfig: Google_Container_V1_AddonsConfig {
    get {return _storage._desiredAddonsConfig ?? Google_Container_V1_AddonsConfig()}
    set {_uniqueStorage()._desiredAddonsConfig = newValue}
  }
  /// Returns true if `desiredAddonsConfig` has been explicitly set.
  public var hasDesiredAddonsConfig: Bool {return _storage._desiredAddonsConfig != nil}
  /// Clears the value of `desiredAddonsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredAddonsConfig() {_uniqueStorage()._desiredAddonsConfig = nil}

  /// The node pool to be upgraded. This field is mandatory if
  /// "desired_node_version", "desired_image_family" or
  /// "desired_node_pool_autoscaling" is specified and there is more than one
  /// node pool on the cluster.
  public var desiredNodePoolID: String {
    get {return _storage._desiredNodePoolID}
    set {_uniqueStorage()._desiredNodePoolID = newValue}
  }

  /// The desired image type for the node pool.
  /// NOTE: Set the "desired_node_pool" field as well.
  public var desiredImageType: String {
    get {return _storage._desiredImageType}
    set {_uniqueStorage()._desiredImageType = newValue}
  }

  /// Configuration of etcd encryption.
  public var desiredDatabaseEncryption: Google_Container_V1_DatabaseEncryption {
    get {return _storage._desiredDatabaseEncryption ?? Google_Container_V1_DatabaseEncryption()}
    set {_uniqueStorage()._desiredDatabaseEncryption = newValue}
  }
  /// Returns true if `desiredDatabaseEncryption` has been explicitly set.
  public var hasDesiredDatabaseEncryption: Bool {return _storage._desiredDatabaseEncryption != nil}
  /// Clears the value of `desiredDatabaseEncryption`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredDatabaseEncryption() {_uniqueStorage()._desiredDatabaseEncryption = nil}

  /// Autoscaler configuration for the node pool specified in
  /// desired_node_pool_id. If there is only one pool in the
  /// cluster and desired_node_pool_id is not provided then
  /// the change applies to that single node pool.
  public var desiredNodePoolAutoscaling: Google_Container_V1_NodePoolAutoscaling {
    get {return _storage._desiredNodePoolAutoscaling ?? Google_Container_V1_NodePoolAutoscaling()}
    set {_uniqueStorage()._desiredNodePoolAutoscaling = newValue}
  }
  /// Returns true if `desiredNodePoolAutoscaling` has been explicitly set.
  public var hasDesiredNodePoolAutoscaling: Bool {return _storage._desiredNodePoolAutoscaling != nil}
  /// Clears the value of `desiredNodePoolAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredNodePoolAutoscaling() {_uniqueStorage()._desiredNodePoolAutoscaling = nil}

  /// The desired list of Google Compute Engine
  /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the cluster's nodes
  /// should be located. Changing the locations a cluster is in will result
  /// in nodes being either created or removed from the cluster, depending on
  /// whether locations are being added or removed.
  ///
  /// This list must always include the cluster's primary zone.
  public var desiredLocations: [String] {
    get {return _storage._desiredLocations}
    set {_uniqueStorage()._desiredLocations = newValue}
  }

  /// The desired configuration options for master authorized networks feature.
  public var desiredMasterAuthorizedNetworksConfig: Google_Container_V1_MasterAuthorizedNetworksConfig {
    get {return _storage._desiredMasterAuthorizedNetworksConfig ?? Google_Container_V1_MasterAuthorizedNetworksConfig()}
    set {_uniqueStorage()._desiredMasterAuthorizedNetworksConfig = newValue}
  }
  /// Returns true if `desiredMasterAuthorizedNetworksConfig` has been explicitly set.
  public var hasDesiredMasterAuthorizedNetworksConfig: Bool {return _storage._desiredMasterAuthorizedNetworksConfig != nil}
  /// Clears the value of `desiredMasterAuthorizedNetworksConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredMasterAuthorizedNetworksConfig() {_uniqueStorage()._desiredMasterAuthorizedNetworksConfig = nil}

  /// Cluster-level autoscaling configuration.
  public var desiredClusterAutoscaling: Google_Container_V1_ClusterAutoscaling {
    get {return _storage._desiredClusterAutoscaling ?? Google_Container_V1_ClusterAutoscaling()}
    set {_uniqueStorage()._desiredClusterAutoscaling = newValue}
  }
  /// Returns true if `desiredClusterAutoscaling` has been explicitly set.
  public var hasDesiredClusterAutoscaling: Bool {return _storage._desiredClusterAutoscaling != nil}
  /// Clears the value of `desiredClusterAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredClusterAutoscaling() {_uniqueStorage()._desiredClusterAutoscaling = nil}

  /// The desired configuration options for the Binary Authorization feature.
  public var desiredBinaryAuthorization: Google_Container_V1_BinaryAuthorization {
    get {return _storage._desiredBinaryAuthorization ?? Google_Container_V1_BinaryAuthorization()}
    set {_uniqueStorage()._desiredBinaryAuthorization = newValue}
  }
  /// Returns true if `desiredBinaryAuthorization` has been explicitly set.
  public var hasDesiredBinaryAuthorization: Bool {return _storage._desiredBinaryAuthorization != nil}
  /// Clears the value of `desiredBinaryAuthorization`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredBinaryAuthorization() {_uniqueStorage()._desiredBinaryAuthorization = nil}

  /// The logging service the cluster should use to write logs.
  /// Currently available options:
  ///
  /// * "logging.googleapis.com/kubernetes" - the Google Cloud Logging
  /// service with Kubernetes-native resource model
  /// * "logging.googleapis.com" - the Google Cloud Logging service
  /// * "none" - no logs will be exported from the cluster
  public var desiredLoggingService: String {
    get {return _storage._desiredLoggingService}
    set {_uniqueStorage()._desiredLoggingService = newValue}
  }

  /// The desired configuration for exporting resource usage.
  public var desiredResourceUsageExportConfig: Google_Container_V1_ResourceUsageExportConfig {
    get {return _storage._desiredResourceUsageExportConfig ?? Google_Container_V1_ResourceUsageExportConfig()}
    set {_uniqueStorage()._desiredResourceUsageExportConfig = newValue}
  }
  /// Returns true if `desiredResourceUsageExportConfig` has been explicitly set.
  public var hasDesiredResourceUsageExportConfig: Bool {return _storage._desiredResourceUsageExportConfig != nil}
  /// Clears the value of `desiredResourceUsageExportConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredResourceUsageExportConfig() {_uniqueStorage()._desiredResourceUsageExportConfig = nil}

  /// Cluster-level Vertical Pod Autoscaling configuration.
  public var desiredVerticalPodAutoscaling: Google_Container_V1_VerticalPodAutoscaling {
    get {return _storage._desiredVerticalPodAutoscaling ?? Google_Container_V1_VerticalPodAutoscaling()}
    set {_uniqueStorage()._desiredVerticalPodAutoscaling = newValue}
  }
  /// Returns true if `desiredVerticalPodAutoscaling` has been explicitly set.
  public var hasDesiredVerticalPodAutoscaling: Bool {return _storage._desiredVerticalPodAutoscaling != nil}
  /// Clears the value of `desiredVerticalPodAutoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredVerticalPodAutoscaling() {_uniqueStorage()._desiredVerticalPodAutoscaling = nil}

  /// The desired config of Intra-node visibility.
  public var desiredIntraNodeVisibilityConfig: Google_Container_V1_IntraNodeVisibilityConfig {
    get {return _storage._desiredIntraNodeVisibilityConfig ?? Google_Container_V1_IntraNodeVisibilityConfig()}
    set {_uniqueStorage()._desiredIntraNodeVisibilityConfig = newValue}
  }
  /// Returns true if `desiredIntraNodeVisibilityConfig` has been explicitly set.
  public var hasDesiredIntraNodeVisibilityConfig: Bool {return _storage._desiredIntraNodeVisibilityConfig != nil}
  /// Clears the value of `desiredIntraNodeVisibilityConfig`. Subsequent reads from it will return its default value.
  public mutating func clearDesiredIntraNodeVisibilityConfig() {_uniqueStorage()._desiredIntraNodeVisibilityConfig = nil}

  /// The Kubernetes version to change the master to.
  ///
  /// Users may specify either explicit versions offered by
  /// Kubernetes Engine or version aliases, which have the following behavior:
  ///
  /// - "latest": picks the highest valid Kubernetes version
  /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
  /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
  /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
  /// - "-": picks the default Kubernetes version
  public var desiredMasterVersion: String {
    get {return _storage._desiredMasterVersion}
    set {_uniqueStorage()._desiredMasterVersion = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// This operation resource represents operations that may have happened or are
/// happening on the cluster. All fields are output only.
public struct Google_Container_V1_Operation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The server-assigned ID for the operation.
  public var name: String = String()

  /// The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the operation
  /// is taking place.
  /// This field is deprecated, use location instead.
  public var zone: String = String()

  /// The operation type.
  public var operationType: Google_Container_V1_Operation.TypeEnum = .unspecified

  /// The current status of the operation.
  public var status: Google_Container_V1_Operation.Status = .unspecified

  /// Detailed operation progress, if available.
  public var detail: String = String()

  /// If an error has occurred, a textual description of the error.
  public var statusMessage: String = String()

  /// Server-defined URL for the resource.
  public var selfLink: String = String()

  /// Server-defined URL for the target of the operation.
  public var targetLink: String = String()

  /// [Output only] The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) or
  /// [region](https://cloud.google.com/compute/docs/regions-zones/regions-zones#available) in which
  /// the cluster resides.
  public var location: String = String()

  /// [Output only] The time the operation started, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var startTime: String = String()

  /// [Output only] The time the operation completed, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var endTime: String = String()

  /// Which conditions caused the current cluster state.
  public var clusterConditions: [Google_Container_V1_StatusCondition] = []

  /// Which conditions caused the current node pool state.
  public var nodepoolConditions: [Google_Container_V1_StatusCondition] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Current status of the operation.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The operation has been created.
    case pending // = 1

    /// The operation is currently running.
    case running // = 2

    /// The operation is done, either cancelled or completed.
    case done // = 3

    /// The operation is aborting.
    case aborting // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pending
      case 2: self = .running
      case 3: self = .done
      case 4: self = .aborting
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pending: return 1
      case .running: return 2
      case .done: return 3
      case .aborting: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Operation type.
  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// Cluster create.
    case createCluster // = 1

    /// Cluster delete.
    case deleteCluster // = 2

    /// A master upgrade.
    case upgradeMaster // = 3

    /// A node upgrade.
    case upgradeNodes // = 4

    /// Cluster repair.
    case repairCluster // = 5

    /// Cluster update.
    case updateCluster // = 6

    /// Node pool create.
    case createNodePool // = 7

    /// Node pool delete.
    case deleteNodePool // = 8

    /// Set node pool management.
    case setNodePoolManagement // = 9

    /// Automatic node pool repair.
    case autoRepairNodes // = 10

    /// Automatic node upgrade.
    case autoUpgradeNodes // = 11

    /// Set labels.
    case setLabels // = 12

    /// Set/generate master auth materials
    case setMasterAuth // = 13

    /// Set node pool size.
    case setNodePoolSize // = 14

    /// Updates network policy for a cluster.
    case setNetworkPolicy // = 15

    /// Set the maintenance policy.
    case setMaintenancePolicy // = 16
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .createCluster
      case 2: self = .deleteCluster
      case 3: self = .upgradeMaster
      case 4: self = .upgradeNodes
      case 5: self = .repairCluster
      case 6: self = .updateCluster
      case 7: self = .createNodePool
      case 8: self = .deleteNodePool
      case 9: self = .setNodePoolManagement
      case 10: self = .autoRepairNodes
      case 11: self = .autoUpgradeNodes
      case 12: self = .setLabels
      case 13: self = .setMasterAuth
      case 14: self = .setNodePoolSize
      case 15: self = .setNetworkPolicy
      case 16: self = .setMaintenancePolicy
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .createCluster: return 1
      case .deleteCluster: return 2
      case .upgradeMaster: return 3
      case .upgradeNodes: return 4
      case .repairCluster: return 5
      case .updateCluster: return 6
      case .createNodePool: return 7
      case .deleteNodePool: return 8
      case .setNodePoolManagement: return 9
      case .autoRepairNodes: return 10
      case .autoUpgradeNodes: return 11
      case .setLabels: return 12
      case .setMasterAuth: return 13
      case .setNodePoolSize: return 14
      case .setNetworkPolicy: return 15
      case .setMaintenancePolicy: return 16
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1_Operation.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_Operation.Status] = [
    .unspecified,
    .pending,
    .running,
    .done,
    .aborting,
  ]
}

extension Google_Container_V1_Operation.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_Operation.TypeEnum] = [
    .unspecified,
    .createCluster,
    .deleteCluster,
    .upgradeMaster,
    .upgradeNodes,
    .repairCluster,
    .updateCluster,
    .createNodePool,
    .deleteNodePool,
    .setNodePoolManagement,
    .autoRepairNodes,
    .autoUpgradeNodes,
    .setLabels,
    .setMasterAuth,
    .setNodePoolSize,
    .setNetworkPolicy,
    .setMaintenancePolicy,
  ]
}

#endif  // swift(>=4.2)

/// CreateClusterRequest creates a cluster.
public struct Google_Container_V1_CreateClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the parent field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the parent field.
  public var zone: String = String()

  /// Required. A [cluster
  /// resource](https://cloud.google.com/container-engine/reference/rest/v1/projects.zones.clusters)
  public var cluster: Google_Container_V1_Cluster {
    get {return _cluster ?? Google_Container_V1_Cluster()}
    set {_cluster = newValue}
  }
  /// Returns true if `cluster` has been explicitly set.
  public var hasCluster: Bool {return self._cluster != nil}
  /// Clears the value of `cluster`. Subsequent reads from it will return its default value.
  public mutating func clearCluster() {self._cluster = nil}

  /// The parent (project and location) where the cluster will be created.
  /// Specified in the format `projects/*/locations/*`.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cluster: Google_Container_V1_Cluster? = nil
}

/// GetClusterRequest gets the settings of a cluster.
public struct Google_Container_V1_GetClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to retrieve.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// The name (project, location, cluster) of the cluster to retrieve.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UpdateClusterRequest updates the settings of a cluster.
public struct Google_Container_V1_UpdateClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. A description of the update.
  public var update: Google_Container_V1_ClusterUpdate {
    get {return _update ?? Google_Container_V1_ClusterUpdate()}
    set {_update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return self._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {self._update = nil}

  /// The name (project, location, cluster) of the cluster to update.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _update: Google_Container_V1_ClusterUpdate? = nil
}

/// UpdateNodePoolRequests update a node pool's image and/or version.
public struct Google_Container_V1_UpdateNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// Required. The Kubernetes version to change the nodes to (typically an
  /// upgrade).
  ///
  /// Users may specify either explicit versions offered by Kubernetes Engine or
  /// version aliases, which have the following behavior:
  ///
  /// - "latest": picks the highest valid Kubernetes version
  /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
  /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
  /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
  /// - "-": picks the Kubernetes master version
  public var nodeVersion: String = String()

  /// Required. The desired image type for the node pool.
  public var imageType: String = String()

  /// The name (project, location, cluster, node pool) of the node pool to
  /// update. Specified in the format
  /// `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetNodePoolAutoscalingRequest sets the autoscaler settings of a node pool.
public struct Google_Container_V1_SetNodePoolAutoscalingRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// Required. Autoscaling configuration for the node pool.
  public var autoscaling: Google_Container_V1_NodePoolAutoscaling {
    get {return _autoscaling ?? Google_Container_V1_NodePoolAutoscaling()}
    set {_autoscaling = newValue}
  }
  /// Returns true if `autoscaling` has been explicitly set.
  public var hasAutoscaling: Bool {return self._autoscaling != nil}
  /// Clears the value of `autoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscaling() {self._autoscaling = nil}

  /// The name (project, location, cluster, node pool) of the node pool to set
  /// autoscaler settings. Specified in the format
  /// `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _autoscaling: Google_Container_V1_NodePoolAutoscaling? = nil
}

/// SetLoggingServiceRequest sets the logging service of a cluster.
public struct Google_Container_V1_SetLoggingServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The logging service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * "logging.googleapis.com" - the Google Cloud Logging service
  /// * "none" - no metrics will be exported from the cluster
  public var loggingService: String = String()

  /// The name (project, location, cluster) of the cluster to set logging.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetMonitoringServiceRequest sets the monitoring service of a cluster.
public struct Google_Container_V1_SetMonitoringServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The monitoring service the cluster should use to write metrics.
  /// Currently available options:
  ///
  /// * "monitoring.googleapis.com/kubernetes" - the Google Cloud Monitoring
  /// service with Kubernetes-native resource model
  /// * "monitoring.googleapis.com" - the Google Cloud Monitoring service
  /// * "none" - no metrics will be exported from the cluster
  public var monitoringService: String = String()

  /// The name (project, location, cluster) of the cluster to set monitoring.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetAddonsConfigRequest sets the addons associated with the cluster.
public struct Google_Container_V1_SetAddonsConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The desired configurations for the various addons available to run in the
  /// cluster.
  public var addonsConfig: Google_Container_V1_AddonsConfig {
    get {return _addonsConfig ?? Google_Container_V1_AddonsConfig()}
    set {_addonsConfig = newValue}
  }
  /// Returns true if `addonsConfig` has been explicitly set.
  public var hasAddonsConfig: Bool {return self._addonsConfig != nil}
  /// Clears the value of `addonsConfig`. Subsequent reads from it will return its default value.
  public mutating func clearAddonsConfig() {self._addonsConfig = nil}

  /// The name (project, location, cluster) of the cluster to set addons.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _addonsConfig: Google_Container_V1_AddonsConfig? = nil
}

/// SetLocationsRequest sets the locations of the cluster.
public struct Google_Container_V1_SetLocationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The desired list of Google Compute Engine
  /// [zones](https://cloud.google.com/compute/docs/zones#available) in which the cluster's nodes
  /// should be located. Changing the locations a cluster is in will result
  /// in nodes being either created or removed from the cluster, depending on
  /// whether locations are being added or removed.
  ///
  /// This list must always include the cluster's primary zone.
  public var locations: [String] = []

  /// The name (project, location, cluster) of the cluster to set locations.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// UpdateMasterRequest updates the master of the cluster.
public struct Google_Container_V1_UpdateMasterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The Kubernetes version to change the master to.
  ///
  /// Users may specify either explicit versions offered by Kubernetes Engine or
  /// version aliases, which have the following behavior:
  ///
  /// - "latest": picks the highest valid Kubernetes version
  /// - "1.X": picks the highest valid patch+gke.N patch in the 1.X version
  /// - "1.X.Y": picks the highest valid gke.N patch in the 1.X.Y version
  /// - "1.X.Y-gke.N": picks an explicit Kubernetes version
  /// - "-": picks the default Kubernetes version
  public var masterVersion: String = String()

  /// The name (project, location, cluster) of the cluster to update.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetMasterAuthRequest updates the admin password of a cluster.
public struct Google_Container_V1_SetMasterAuthRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to upgrade.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The exact form of action to be taken on the master auth.
  public var action: Google_Container_V1_SetMasterAuthRequest.Action = .unknown

  /// Required. A description of the update.
  public var update: Google_Container_V1_MasterAuth {
    get {return _update ?? Google_Container_V1_MasterAuth()}
    set {_update = newValue}
  }
  /// Returns true if `update` has been explicitly set.
  public var hasUpdate: Bool {return self._update != nil}
  /// Clears the value of `update`. Subsequent reads from it will return its default value.
  public mutating func clearUpdate() {self._update = nil}

  /// The name (project, location, cluster) of the cluster to set auth.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operation type: what type update to perform.
  public enum Action: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Operation is unknown and will error out.
    case unknown // = 0

    /// Set the password to a user generated value.
    case setPassword // = 1

    /// Generate a new password and set it to that.
    case generatePassword // = 2

    /// Set the username.  If an empty username is provided, basic authentication
    /// is disabled for the cluster.  If a non-empty username is provided, basic
    /// authentication is enabled, with either a provided password or a generated
    /// one.
    case setUsername // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .setPassword
      case 2: self = .generatePassword
      case 3: self = .setUsername
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .setPassword: return 1
      case .generatePassword: return 2
      case .setUsername: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _update: Google_Container_V1_MasterAuth? = nil
}

#if swift(>=4.2)

extension Google_Container_V1_SetMasterAuthRequest.Action: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_SetMasterAuthRequest.Action] = [
    .unknown,
    .setPassword,
    .generatePassword,
    .setUsername,
  ]
}

#endif  // swift(>=4.2)

/// DeleteClusterRequest deletes a cluster.
public struct Google_Container_V1_DeleteClusterRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to delete.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// The name (project, location, cluster) of the cluster to delete.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListClustersRequest lists clusters.
public struct Google_Container_V1_ListClustersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the parent field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides, or "-" for all zones.
  /// This field has been deprecated and replaced by the parent field.
  public var zone: String = String()

  /// The parent (project and location) where the clusters will be listed.
  /// Specified in the format `projects/*/locations/*`.
  /// Location "-" matches all zones and all regions.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListClustersResponse is the result of ListClustersRequest.
public struct Google_Container_V1_ListClustersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of clusters in the project in the specified zone, or
  /// across all ones.
  public var clusters: [Google_Container_V1_Cluster] = []

  /// If any zones are listed here, the list of clusters returned
  /// may be missing those zones.
  public var missingZones: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetOperationRequest gets a single operation.
public struct Google_Container_V1_GetOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The server-assigned `name` of the operation.
  /// This field has been deprecated and replaced by the name field.
  public var operationID: String = String()

  /// The name (project, location, operation id) of the operation to get.
  /// Specified in the format `projects/*/locations/*/operations/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListOperationsRequest lists operations.
public struct Google_Container_V1_ListOperationsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the parent field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) to return operations for, or `-` for
  /// all zones. This field has been deprecated and replaced by the parent field.
  public var zone: String = String()

  /// The parent (project and location) where the operations will be listed.
  /// Specified in the format `projects/*/locations/*`.
  /// Location "-" matches all zones and all regions.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CancelOperationRequest cancels a single operation.
public struct Google_Container_V1_CancelOperationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the operation resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The server-assigned `name` of the operation.
  /// This field has been deprecated and replaced by the name field.
  public var operationID: String = String()

  /// The name (project, location, operation id) of the operation to cancel.
  /// Specified in the format `projects/*/locations/*/operations/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListOperationsResponse is the result of ListOperationsRequest.
public struct Google_Container_V1_ListOperationsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of operations in the project in the specified zone.
  public var operations: [Google_Container_V1_Operation] = []

  /// If any zones are listed here, the list of operations returned
  /// may be missing the operations from those zones.
  public var missingZones: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Gets the current Kubernetes Engine service configuration.
public struct Google_Container_V1_GetServerConfigRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) to return operations for.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// The name (project and location) of the server config to get,
  /// specified in the format `projects/*/locations/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Kubernetes Engine service configuration.
public struct Google_Container_V1_ServerConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of Kubernetes the service deploys by default.
  public var defaultClusterVersion: String = String()

  /// List of valid node upgrade target versions.
  public var validNodeVersions: [String] = []

  /// Default image type.
  public var defaultImageType: String = String()

  /// List of valid image types.
  public var validImageTypes: [String] = []

  /// List of valid master versions.
  public var validMasterVersions: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CreateNodePoolRequest creates a node pool for a cluster.
public struct Google_Container_V1_CreateNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the parent field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the parent field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the parent field.
  public var clusterID: String = String()

  /// Required. The node pool to create.
  public var nodePool: Google_Container_V1_NodePool {
    get {return _nodePool ?? Google_Container_V1_NodePool()}
    set {_nodePool = newValue}
  }
  /// Returns true if `nodePool` has been explicitly set.
  public var hasNodePool: Bool {return self._nodePool != nil}
  /// Clears the value of `nodePool`. Subsequent reads from it will return its default value.
  public mutating func clearNodePool() {self._nodePool = nil}

  /// The parent (project, location, cluster id) where the node pool will be
  /// created. Specified in the format
  /// `projects/*/locations/*/clusters/*`.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nodePool: Google_Container_V1_NodePool? = nil
}

/// DeleteNodePoolRequest deletes a node pool for a cluster.
public struct Google_Container_V1_DeleteNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool to delete.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// The name (project, location, cluster, node pool id) of the node pool to
  /// delete. Specified in the format
  /// `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListNodePoolsRequest lists the node pool(s) for a cluster.
public struct Google_Container_V1_ListNodePoolsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the parent field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the parent field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the parent field.
  public var clusterID: String = String()

  /// The parent (project, location, cluster id) where the node pools will be
  /// listed. Specified in the format `projects/*/locations/*/clusters/*`.
  public var parent: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// GetNodePoolRequest retrieves a node pool for a cluster.
public struct Google_Container_V1_GetNodePoolRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// The name (project, location, cluster, node pool id) of the node pool to
  /// get. Specified in the format
  /// `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NodePool contains the name and configuration for a cluster's node pool.
/// Node pools are a set of nodes (i.e. VM's), with a common configuration and
/// specification, under the control of the cluster master. They may have a set
/// of Kubernetes labels applied to them, which may be used to reference them
/// during pod scheduling. They may also be resized up or down, to accommodate
/// the workload.
public struct Google_Container_V1_NodePool {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the node pool.
  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The node configuration of the pool.
  public var config: Google_Container_V1_NodeConfig {
    get {return _storage._config ?? Google_Container_V1_NodeConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  public var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  public mutating func clearConfig() {_uniqueStorage()._config = nil}

  /// The initial node count for the pool. You must ensure that your
  /// Compute Engine [resource quota](https://cloud.google.com/compute/quotas)
  /// is sufficient for this number of instances. You must also have available
  /// firewall and routes quota.
  public var initialNodeCount: Int32 {
    get {return _storage._initialNodeCount}
    set {_uniqueStorage()._initialNodeCount = newValue}
  }

  /// [Output only] Server-defined URL for the resource.
  public var selfLink: String {
    get {return _storage._selfLink}
    set {_uniqueStorage()._selfLink = newValue}
  }

  /// The version of the Kubernetes of this node.
  public var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// [Output only] The resource URLs of the [managed instance
  /// groups](https://cloud.google.com/compute/docs/instance-groups/creating-groups-of-managed-instances)
  /// associated with this node pool.
  public var instanceGroupUrls: [String] {
    get {return _storage._instanceGroupUrls}
    set {_uniqueStorage()._instanceGroupUrls = newValue}
  }

  /// [Output only] The status of the nodes in this pool instance.
  public var status: Google_Container_V1_NodePool.Status {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// [Output only] Additional information about the current status of this
  /// node pool instance, if available.
  public var statusMessage: String {
    get {return _storage._statusMessage}
    set {_uniqueStorage()._statusMessage = newValue}
  }

  /// Autoscaler configuration for this NodePool. Autoscaler is enabled
  /// only if a valid configuration is present.
  public var autoscaling: Google_Container_V1_NodePoolAutoscaling {
    get {return _storage._autoscaling ?? Google_Container_V1_NodePoolAutoscaling()}
    set {_uniqueStorage()._autoscaling = newValue}
  }
  /// Returns true if `autoscaling` has been explicitly set.
  public var hasAutoscaling: Bool {return _storage._autoscaling != nil}
  /// Clears the value of `autoscaling`. Subsequent reads from it will return its default value.
  public mutating func clearAutoscaling() {_uniqueStorage()._autoscaling = nil}

  /// NodeManagement configuration for this NodePool.
  public var management: Google_Container_V1_NodeManagement {
    get {return _storage._management ?? Google_Container_V1_NodeManagement()}
    set {_uniqueStorage()._management = newValue}
  }
  /// Returns true if `management` has been explicitly set.
  public var hasManagement: Bool {return _storage._management != nil}
  /// Clears the value of `management`. Subsequent reads from it will return its default value.
  public mutating func clearManagement() {_uniqueStorage()._management = nil}

  /// The constraint on the maximum number of pods that can be run
  /// simultaneously on a node in the node pool.
  public var maxPodsConstraint: Google_Container_V1_MaxPodsConstraint {
    get {return _storage._maxPodsConstraint ?? Google_Container_V1_MaxPodsConstraint()}
    set {_uniqueStorage()._maxPodsConstraint = newValue}
  }
  /// Returns true if `maxPodsConstraint` has been explicitly set.
  public var hasMaxPodsConstraint: Bool {return _storage._maxPodsConstraint != nil}
  /// Clears the value of `maxPodsConstraint`. Subsequent reads from it will return its default value.
  public mutating func clearMaxPodsConstraint() {_uniqueStorage()._maxPodsConstraint = nil}

  /// Which conditions caused the current node pool state.
  public var conditions: [Google_Container_V1_StatusCondition] {
    get {return _storage._conditions}
    set {_uniqueStorage()._conditions = newValue}
  }

  /// [Output only] The pod CIDR block size per node in this node pool.
  public var podIpv4CidrSize: Int32 {
    get {return _storage._podIpv4CidrSize}
    set {_uniqueStorage()._podIpv4CidrSize = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The current status of the node pool instance.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Not set.
    case unspecified // = 0

    /// The PROVISIONING state indicates the node pool is being created.
    case provisioning // = 1

    /// The RUNNING state indicates the node pool has been created
    /// and is fully usable.
    case running // = 2

    /// The RUNNING_WITH_ERROR state indicates the node pool has been created
    /// and is partially usable. Some error state has occurred and some
    /// functionality may be impaired. Customer may need to reissue a request
    /// or trigger a new update.
    case runningWithError // = 3

    /// The RECONCILING state indicates that some work is actively being done on
    /// the node pool, such as upgrading node software. Details can
    /// be found in the `statusMessage` field.
    case reconciling // = 4

    /// The STOPPING state indicates the node pool is being deleted.
    case stopping // = 5

    /// The ERROR state indicates the node pool may be unusable. Details
    /// can be found in the `statusMessage` field.
    case error // = 6
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .provisioning
      case 2: self = .running
      case 3: self = .runningWithError
      case 4: self = .reconciling
      case 5: self = .stopping
      case 6: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .provisioning: return 1
      case .running: return 2
      case .runningWithError: return 3
      case .reconciling: return 4
      case .stopping: return 5
      case .error: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Google_Container_V1_NodePool.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_NodePool.Status] = [
    .unspecified,
    .provisioning,
    .running,
    .runningWithError,
    .reconciling,
    .stopping,
    .error,
  ]
}

#endif  // swift(>=4.2)

/// NodeManagement defines the set of node management services turned on for the
/// node pool.
public struct Google_Container_V1_NodeManagement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A flag that specifies whether node auto-upgrade is enabled for the node
  /// pool. If enabled, node auto-upgrade helps keep the nodes in your node pool
  /// up to date with the latest release version of Kubernetes.
  public var autoUpgrade: Bool = false

  /// A flag that specifies whether the node auto-repair is enabled for the node
  /// pool. If enabled, the nodes in this node pool will be monitored and, if
  /// they fail health checks too many times, an automatic repair action will be
  /// triggered.
  public var autoRepair: Bool = false

  /// Specifies the Auto Upgrade knobs for the node pool.
  public var upgradeOptions: Google_Container_V1_AutoUpgradeOptions {
    get {return _upgradeOptions ?? Google_Container_V1_AutoUpgradeOptions()}
    set {_upgradeOptions = newValue}
  }
  /// Returns true if `upgradeOptions` has been explicitly set.
  public var hasUpgradeOptions: Bool {return self._upgradeOptions != nil}
  /// Clears the value of `upgradeOptions`. Subsequent reads from it will return its default value.
  public mutating func clearUpgradeOptions() {self._upgradeOptions = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _upgradeOptions: Google_Container_V1_AutoUpgradeOptions? = nil
}

/// AutoUpgradeOptions defines the set of options for the user to control how
/// the Auto Upgrades will proceed.
public struct Google_Container_V1_AutoUpgradeOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// [Output only] This field is set when upgrades are about to commence
  /// with the approximate start time for the upgrades, in
  /// [RFC3339](https://www.ietf.org/rfc/rfc3339.txt) text format.
  public var autoUpgradeStartTime: String = String()

  /// [Output only] This field is set when upgrades are about to commence
  /// with the description of the upgrade.
  public var description_p: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// MaintenancePolicy defines the maintenance policy to be used for the cluster.
public struct Google_Container_V1_MaintenancePolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies the maintenance window in which maintenance may be performed.
  public var window: Google_Container_V1_MaintenanceWindow {
    get {return _window ?? Google_Container_V1_MaintenanceWindow()}
    set {_window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return self._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {self._window = nil}

  /// A hash identifying the version of this policy, so that updates to fields of
  /// the policy won't accidentally undo intermediate changes (and so that users
  /// of the API unaware of some fields won't accidentally remove other fields).
  /// Make a <code>get()</code> request to the cluster to get the current
  /// resource version and include it with requests to set the policy.
  public var resourceVersion: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _window: Google_Container_V1_MaintenanceWindow? = nil
}

/// MaintenanceWindow defines the maintenance window to be used for the cluster.
public struct Google_Container_V1_MaintenanceWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var policy: Google_Container_V1_MaintenanceWindow.OneOf_Policy? = nil

  /// DailyMaintenanceWindow specifies a daily maintenance operation window.
  public var dailyMaintenanceWindow: Google_Container_V1_DailyMaintenanceWindow {
    get {
      if case .dailyMaintenanceWindow(let v)? = policy {return v}
      return Google_Container_V1_DailyMaintenanceWindow()
    }
    set {policy = .dailyMaintenanceWindow(newValue)}
  }

  /// RecurringWindow specifies some number of recurring time periods for
  /// maintenance to occur. The time windows may be overlapping. If no
  /// maintenance windows are set, maintenance can occur at any time.
  public var recurringWindow: Google_Container_V1_RecurringTimeWindow {
    get {
      if case .recurringWindow(let v)? = policy {return v}
      return Google_Container_V1_RecurringTimeWindow()
    }
    set {policy = .recurringWindow(newValue)}
  }

  /// Exceptions to maintenance window. Non-emergency maintenance should not
  /// occur in these windows.
  public var maintenanceExclusions: Dictionary<String,Google_Container_V1_TimeWindow> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Policy: Equatable {
    /// DailyMaintenanceWindow specifies a daily maintenance operation window.
    case dailyMaintenanceWindow(Google_Container_V1_DailyMaintenanceWindow)
    /// RecurringWindow specifies some number of recurring time periods for
    /// maintenance to occur. The time windows may be overlapping. If no
    /// maintenance windows are set, maintenance can occur at any time.
    case recurringWindow(Google_Container_V1_RecurringTimeWindow)

  #if !swift(>=4.1)
    public static func ==(lhs: Google_Container_V1_MaintenanceWindow.OneOf_Policy, rhs: Google_Container_V1_MaintenanceWindow.OneOf_Policy) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dailyMaintenanceWindow, .dailyMaintenanceWindow): return {
        guard case .dailyMaintenanceWindow(let l) = lhs, case .dailyMaintenanceWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.recurringWindow, .recurringWindow): return {
        guard case .recurringWindow(let l) = lhs, case .recurringWindow(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Represents an arbitrary window of time.
public struct Google_Container_V1_TimeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time that the window first starts.
  public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The time that the window ends. The end time should take place after the
  /// start time.
  public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  public var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  public mutating func clearEndTime() {self._endTime = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Represents an arbitrary window of time that recurs.
public struct Google_Container_V1_RecurringTimeWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The window of the first recurrence.
  public var window: Google_Container_V1_TimeWindow {
    get {return _window ?? Google_Container_V1_TimeWindow()}
    set {_window = newValue}
  }
  /// Returns true if `window` has been explicitly set.
  public var hasWindow: Bool {return self._window != nil}
  /// Clears the value of `window`. Subsequent reads from it will return its default value.
  public mutating func clearWindow() {self._window = nil}

  /// An RRULE (https://tools.ietf.org/html/rfc5545#section-3.8.5.3) for how
  /// this window reccurs. They go on for the span of time between the start and
  /// end time.
  ///
  /// For example, to have something repeat every weekday, you'd use:
  ///   <code>FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR</code>
  /// To repeat some window daily (equivalent to the DailyMaintenanceWindow):
  ///   <code>FREQ=DAILY</code>
  /// For the first weekend of every month:
  ///   <code>FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU</code>
  /// This specifies how frequently the window starts. Eg, if you wanted to have
  /// a 9-5 UTC-4 window every weekday, you'd use something like:
  /// <code>
  ///   start time = 2019-01-01T09:00:00-0400
  ///   end time = 2019-01-01T17:00:00-0400
  ///   recurrence = FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR
  /// </code>
  /// Windows can span multiple days. Eg, to make the window encompass every
  /// weekend from midnight Saturday till the last minute of Sunday UTC:
  /// <code>
  ///   start time = 2019-01-05T00:00:00Z
  ///   end time = 2019-01-07T23:59:00Z
  ///   recurrence = FREQ=WEEKLY;BYDAY=SA
  /// </code>
  /// Note the start and end time's specific dates are largely arbitrary except
  /// to specify duration of the window and when it first starts.
  /// The FREQ values of HOURLY, MINUTELY, and SECONDLY are not supported.
  public var recurrence: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _window: Google_Container_V1_TimeWindow? = nil
}

/// Time window specified for daily maintenance operations.
public struct Google_Container_V1_DailyMaintenanceWindow {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time within the maintenance window to start the maintenance operations.
  /// Time format should be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
  /// format "HH:MM", where HH : [00-23] and MM : [00-59] GMT.
  public var startTime: String = String()

  /// [Output only] Duration of the time window, automatically chosen to be
  /// smallest possible in the given scenario.
  /// Duration will be in [RFC3339](https://www.ietf.org/rfc/rfc3339.txt)
  /// format "PTnHnMnS".
  public var duration: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetNodePoolManagementRequest sets the node management properties of a node
/// pool.
public struct Google_Container_V1_SetNodePoolManagementRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to update.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool to update.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// Required. NodeManagement configuration for the node pool.
  public var management: Google_Container_V1_NodeManagement {
    get {return _management ?? Google_Container_V1_NodeManagement()}
    set {_management = newValue}
  }
  /// Returns true if `management` has been explicitly set.
  public var hasManagement: Bool {return self._management != nil}
  /// Clears the value of `management`. Subsequent reads from it will return its default value.
  public mutating func clearManagement() {self._management = nil}

  /// The name (project, location, cluster, node pool id) of the node pool to set
  /// management properties. Specified in the format
  /// `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _management: Google_Container_V1_NodeManagement? = nil
}

/// SetNodePoolSizeRequest sets the size a node
/// pool.
public struct Google_Container_V1_SetNodePoolSizeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to update.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool to update.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// Required. The desired node count for the pool.
  public var nodeCount: Int32 = 0

  /// The name (project, location, cluster, node pool id) of the node pool to set
  /// size.
  /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// RollbackNodePoolUpgradeRequest rollbacks the previously Aborted or Failed
/// NodePool upgrade. This will be an no-op if the last upgrade successfully
/// completed.
public struct Google_Container_V1_RollbackNodePoolUpgradeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to rollback.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Deprecated. The name of the node pool to rollback.
  /// This field has been deprecated and replaced by the name field.
  public var nodePoolID: String = String()

  /// The name (project, location, cluster, node pool id) of the node poll to
  /// rollback upgrade.
  /// Specified in the format `projects/*/locations/*/clusters/*/nodePools/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListNodePoolsResponse is the result of ListNodePoolsRequest.
public struct Google_Container_V1_ListNodePoolsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of node pools for a cluster.
  public var nodePools: [Google_Container_V1_NodePool] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ClusterAutoscaling contains global, per-cluster information
/// required by Cluster Autoscaler to automatically adjust
/// the size of the cluster and create/delete
/// node pools based on the current needs.
public struct Google_Container_V1_ClusterAutoscaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enables automatic node pool creation and deletion.
  public var enableNodeAutoprovisioning: Bool = false

  /// Contains global constraints regarding minimum and maximum
  /// amount of resources in the cluster.
  public var resourceLimits: [Google_Container_V1_ResourceLimit] = []

  /// AutoprovisioningNodePoolDefaults contains defaults for a node pool
  /// created by NAP.
  public var autoprovisioningNodePoolDefaults: Google_Container_V1_AutoprovisioningNodePoolDefaults {
    get {return _autoprovisioningNodePoolDefaults ?? Google_Container_V1_AutoprovisioningNodePoolDefaults()}
    set {_autoprovisioningNodePoolDefaults = newValue}
  }
  /// Returns true if `autoprovisioningNodePoolDefaults` has been explicitly set.
  public var hasAutoprovisioningNodePoolDefaults: Bool {return self._autoprovisioningNodePoolDefaults != nil}
  /// Clears the value of `autoprovisioningNodePoolDefaults`. Subsequent reads from it will return its default value.
  public mutating func clearAutoprovisioningNodePoolDefaults() {self._autoprovisioningNodePoolDefaults = nil}

  /// The list of Google Compute Engine [zones](https://cloud.google.com/compute/docs/zones#available)
  /// in which the NodePool's nodes can be created by NAP.
  public var autoprovisioningLocations: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _autoprovisioningNodePoolDefaults: Google_Container_V1_AutoprovisioningNodePoolDefaults? = nil
}

/// AutoprovisioningNodePoolDefaults contains defaults for a node pool created
/// by NAP.
public struct Google_Container_V1_AutoprovisioningNodePoolDefaults {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Scopes that are used by NAP when creating node pools. If oauth_scopes are
  /// specified, service_account should be empty.
  public var oauthScopes: [String] = []

  /// The Google Cloud Platform Service Account to be used by the node VMs. If
  /// service_account is specified, scopes should be empty.
  public var serviceAccount: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Contains information about amount of some resource in the cluster.
/// For memory, value should be in GB.
public struct Google_Container_V1_ResourceLimit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Resource name "cpu", "memory" or gpu-specific string.
  public var resourceType: String = String()

  /// Minimum amount of the resource in the cluster.
  public var minimum: Int64 = 0

  /// Maximum amount of the resource in the cluster.
  public var maximum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// NodePoolAutoscaling contains information required by cluster autoscaler to
/// adjust the size of the node pool to the current cluster usage.
public struct Google_Container_V1_NodePoolAutoscaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is autoscaling enabled for this node pool.
  public var enabled: Bool = false

  /// Minimum number of nodes in the NodePool. Must be >= 1 and <=
  /// max_node_count.
  public var minNodeCount: Int32 = 0

  /// Maximum number of nodes in the NodePool. Must be >= min_node_count. There
  /// has to enough quota to scale up the cluster.
  public var maxNodeCount: Int32 = 0

  /// Can this node pool be deleted automatically.
  public var autoprovisioned: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetLabelsRequest sets the Google Cloud Platform labels on a Google Container
/// Engine cluster, which will in turn set them for Google Compute Engine
/// resources used by that cluster
public struct Google_Container_V1_SetLabelsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. The labels to set for that cluster.
  public var resourceLabels: Dictionary<String,String> = [:]

  /// Required. The fingerprint of the previous set of labels for this resource,
  /// used to detect conflicts. The fingerprint is initially generated by
  /// Kubernetes Engine and changes after every request to modify or update
  /// labels. You must always provide an up-to-date fingerprint hash when
  /// updating or changing labels. Make a <code>get()</code> request to the
  /// resource to get the latest fingerprint.
  public var labelFingerprint: String = String()

  /// The name (project, location, cluster id) of the cluster to set labels.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetLegacyAbacRequest enables or disables the ABAC authorization mechanism for
/// a cluster.
public struct Google_Container_V1_SetLegacyAbacRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster to update.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. Whether ABAC authorization will be enabled in the cluster.
  public var enabled: Bool = false

  /// The name (project, location, cluster id) of the cluster to set legacy abac.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// StartIPRotationRequest creates a new IP for the cluster and then performs
/// a node upgrade on each node pool to point to the new IP.
public struct Google_Container_V1_StartIPRotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// The name (project, location, cluster id) of the cluster to start IP
  /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  /// Whether to rotate credentials during IP rotation.
  public var rotateCredentials: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// CompleteIPRotationRequest moves the cluster master back into single-IP mode.
public struct Google_Container_V1_CompleteIPRotationRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// The name (project, location, cluster id) of the cluster to complete IP
  /// rotation. Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// AcceleratorConfig represents a Hardware Accelerator request.
public struct Google_Container_V1_AcceleratorConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of the accelerator cards exposed to an instance.
  public var acceleratorCount: Int64 = 0

  /// The accelerator type resource name. List of supported accelerators
  /// [here](https://cloud.google.com/compute/docs/gpus)
  public var acceleratorType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// SetNetworkPolicyRequest enables/disables network policy for a cluster.
public struct Google_Container_V1_SetNetworkPolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. The Google Developers Console [project ID or project
  /// number](https://developers.google.com/console/help/new/#projectnumber).
  /// This field has been deprecated and replaced by the name field.
  public var projectID: String = String()

  /// Deprecated. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  /// This field has been deprecated and replaced by the name field.
  public var zone: String = String()

  /// Deprecated. The name of the cluster.
  /// This field has been deprecated and replaced by the name field.
  public var clusterID: String = String()

  /// Required. Configuration options for the NetworkPolicy feature.
  public var networkPolicy: Google_Container_V1_NetworkPolicy {
    get {return _networkPolicy ?? Google_Container_V1_NetworkPolicy()}
    set {_networkPolicy = newValue}
  }
  /// Returns true if `networkPolicy` has been explicitly set.
  public var hasNetworkPolicy: Bool {return self._networkPolicy != nil}
  /// Clears the value of `networkPolicy`. Subsequent reads from it will return its default value.
  public mutating func clearNetworkPolicy() {self._networkPolicy = nil}

  /// The name (project, location, cluster id) of the cluster to set networking
  /// policy. Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _networkPolicy: Google_Container_V1_NetworkPolicy? = nil
}

/// SetMaintenancePolicyRequest sets the maintenance policy for a cluster.
public struct Google_Container_V1_SetMaintenancePolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. The Google Developers Console [project ID or project
  /// number](https://support.google.com/cloud/answer/6158840).
  public var projectID: String = String()

  /// Required. The name of the Google Compute Engine
  /// [zone](https://cloud.google.com/compute/docs/zones#available) in which the cluster
  /// resides.
  public var zone: String = String()

  /// Required. The name of the cluster to update.
  public var clusterID: String = String()

  /// Required. The maintenance policy to be set for the cluster. An empty field
  /// clears the existing maintenance policy.
  public var maintenancePolicy: Google_Container_V1_MaintenancePolicy {
    get {return _maintenancePolicy ?? Google_Container_V1_MaintenancePolicy()}
    set {_maintenancePolicy = newValue}
  }
  /// Returns true if `maintenancePolicy` has been explicitly set.
  public var hasMaintenancePolicy: Bool {return self._maintenancePolicy != nil}
  /// Clears the value of `maintenancePolicy`. Subsequent reads from it will return its default value.
  public mutating func clearMaintenancePolicy() {self._maintenancePolicy = nil}

  /// The name (project, location, cluster id) of the cluster to set maintenance
  /// policy.
  /// Specified in the format `projects/*/locations/*/clusters/*`.
  public var name: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _maintenancePolicy: Google_Container_V1_MaintenancePolicy? = nil
}

/// StatusCondition describes why a cluster or a node pool has a certain status
/// (e.g., ERROR or DEGRADED).
public struct Google_Container_V1_StatusCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Machine-friendly representation of the condition
  public var code: Google_Container_V1_StatusCondition.Code = .unknown

  /// Human-friendly representation of the condition
  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Code for each condition
  public enum Code: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// UNKNOWN indicates a generic condition.
    case unknown // = 0

    /// GCE_STOCKOUT indicates a Google Compute Engine stockout.
    case gceStockout // = 1

    /// GKE_SERVICE_ACCOUNT_DELETED indicates that the user deleted their robot
    /// service account.
    case gkeServiceAccountDeleted // = 2

    /// Google Compute Engine quota was exceeded.
    case gceQuotaExceeded // = 3

    /// Cluster state was manually changed by an SRE due to a system logic error.
    case setByOperator // = 4

    /// Unable to perform an encrypt operation against the CloudKMS key used for
    /// etcd level encryption.
    /// More codes TBA
    case cloudKmsKeyError // = 7
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .gceStockout
      case 2: self = .gkeServiceAccountDeleted
      case 3: self = .gceQuotaExceeded
      case 4: self = .setByOperator
      case 7: self = .cloudKmsKeyError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .gceStockout: return 1
      case .gkeServiceAccountDeleted: return 2
      case .gceQuotaExceeded: return 3
      case .setByOperator: return 4
      case .cloudKmsKeyError: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1_StatusCondition.Code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_StatusCondition.Code] = [
    .unknown,
    .gceStockout,
    .gkeServiceAccountDeleted,
    .gceQuotaExceeded,
    .setByOperator,
    .cloudKmsKeyError,
  ]
}

#endif  // swift(>=4.2)

/// NetworkConfig reports the relative names of network & subnetwork.
public struct Google_Container_V1_NetworkConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Output only. The relative name of the Google Compute Engine
  /// [network][google.container.v1.NetworkConfig.network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks) to which
  /// the cluster is connected.
  /// Example: projects/my-project/global/networks/my-network
  public var network: String = String()

  /// Output only. The relative name of the Google Compute Engine
  /// [subnetwork](https://cloud.google.com/compute/docs/vpc) to which the cluster is connected.
  /// Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
  public var subnetwork: String = String()

  /// Whether Intra-node visibility is enabled for this cluster.
  /// This makes same node pod to pod traffic visible for VPC network.
  public var enableIntraNodeVisibility: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// IntraNodeVisibilityConfig contains the desired config of the intra-node
/// visibility on this cluster.
public struct Google_Container_V1_IntraNodeVisibilityConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enables intra node visibility for this cluster.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Constraints applied to pods.
public struct Google_Container_V1_MaxPodsConstraint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Constraint enforced on the max num of pods per node.
  public var maxPodsPerNode: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration of etcd encryption.
public struct Google_Container_V1_DatabaseEncryption {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Denotes the state of etcd encryption.
  public var state: Google_Container_V1_DatabaseEncryption.State = .unknown

  /// Name of CloudKMS key to use for the encryption of secrets in etcd.
  /// Ex. projects/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key
  public var keyName: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// State of etcd encryption.
  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// Should never be set
    case unknown // = 0

    /// Secrets in etcd are encrypted.
    case encrypted // = 1

    /// Secrets in etcd are stored in plain text (at etcd level) - this is
    /// unrelated to GCE level full disk encryption.
    case decrypted // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .encrypted
      case 2: self = .decrypted
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .encrypted: return 1
      case .decrypted: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1_DatabaseEncryption.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_DatabaseEncryption.State] = [
    .unknown,
    .encrypted,
    .decrypted,
  ]
}

#endif  // swift(>=4.2)

/// ListUsableSubnetworksRequest requests the list of usable subnetworks
/// available to a user for creating clusters.
public struct Google_Container_V1_ListUsableSubnetworksRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The parent project where subnetworks are usable.
  /// Specified in the format `projects/*`.
  public var parent: String = String()

  /// Filtering currently only supports equality on the networkProjectId and must
  /// be in the form: "networkProjectId=[PROJECTID]", where `networkProjectId`
  /// is the project which owns the listed subnetworks. This defaults to the
  /// parent project ID.
  public var filter: String = String()

  /// The max number of results per page that should be returned. If the number
  /// of available results is larger than `page_size`, a `next_page_token` is
  /// returned which can be used to get the next page of results in subsequent
  /// requests. Acceptable values are 0 to 500, inclusive. (Default: 500)
  public var pageSize: Int32 = 0

  /// Specifies a page token to use. Set this to the nextPageToken returned by
  /// previous list requests to get the next page of results.
  public var pageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// ListUsableSubnetworksResponse is the response of
/// ListUsableSubnetworksRequest.
public struct Google_Container_V1_ListUsableSubnetworksResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of usable subnetworks in the specified network project.
  public var subnetworks: [Google_Container_V1_UsableSubnetwork] = []

  /// This token allows you to get the next page of results for list requests.
  /// If the number of results is larger than `page_size`, use the
  /// `next_page_token` as a value for the query parameter `page_token` in the
  /// next request. The value will become empty when there are no more pages.
  public var nextPageToken: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Secondary IP range of a usable subnetwork.
public struct Google_Container_V1_UsableSubnetworkSecondaryRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name associated with this subnetwork secondary range, used when adding
  /// an alias IP range to a VM instance.
  public var rangeName: String = String()

  /// The range of IP addresses belonging to this subnetwork secondary range.
  public var ipCidrRange: String = String()

  /// This field is to determine the status of the secondary range programmably.
  public var status: Google_Container_V1_UsableSubnetworkSecondaryRange.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Status shows the current usage of a secondary IP range.
  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// UNKNOWN is the zero value of the Status enum. It's not a valid status.
    case unknown // = 0

    /// UNUSED denotes that this range is unclaimed by any cluster.
    case unused // = 1

    /// IN_USE_SERVICE denotes that this range is claimed by a cluster for
    /// services. It cannot be used for other clusters.
    case inUseService // = 2

    /// IN_USE_SHAREABLE_POD denotes this range was created by the network admin
    /// and is currently claimed by a cluster for pods. It can only be used by
    /// other clusters as a pod range.
    case inUseShareablePod // = 3

    /// IN_USE_MANAGED_POD denotes this range was created by GKE and is claimed
    /// for pods. It cannot be used for other clusters.
    case inUseManagedPod // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .unused
      case 2: self = .inUseService
      case 3: self = .inUseShareablePod
      case 4: self = .inUseManagedPod
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .unused: return 1
      case .inUseService: return 2
      case .inUseShareablePod: return 3
      case .inUseManagedPod: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Google_Container_V1_UsableSubnetworkSecondaryRange.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Google_Container_V1_UsableSubnetworkSecondaryRange.Status] = [
    .unknown,
    .unused,
    .inUseService,
    .inUseShareablePod,
    .inUseManagedPod,
  ]
}

#endif  // swift(>=4.2)

/// UsableSubnetwork resource returns the subnetwork name, its associated network
/// and the primary CIDR range.
public struct Google_Container_V1_UsableSubnetwork {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Subnetwork Name.
  /// Example: projects/my-project/regions/us-central1/subnetworks/my-subnet
  public var subnetwork: String = String()

  /// Network Name.
  /// Example: projects/my-project/global/networks/my-network
  public var network: String = String()

  /// The range of internal addresses that are owned by this subnetwork.
  public var ipCidrRange: String = String()

  /// Secondary IP ranges.
  public var secondaryIpRanges: [Google_Container_V1_UsableSubnetworkSecondaryRange] = []

  /// A human readable status message representing the reasons for cases where
  /// the caller cannot use the secondary ranges under the subnet. For example if
  /// the secondary_ip_ranges is empty due to a permission issue, an insufficient
  /// permission message will be given by status_message.
  public var statusMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Configuration for exporting cluster resource usages.
public struct Google_Container_V1_ResourceUsageExportConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Configuration to use BigQuery as usage export destination.
  public var bigqueryDestination: Google_Container_V1_ResourceUsageExportConfig.BigQueryDestination {
    get {return _bigqueryDestination ?? Google_Container_V1_ResourceUsageExportConfig.BigQueryDestination()}
    set {_bigqueryDestination = newValue}
  }
  /// Returns true if `bigqueryDestination` has been explicitly set.
  public var hasBigqueryDestination: Bool {return self._bigqueryDestination != nil}
  /// Clears the value of `bigqueryDestination`. Subsequent reads from it will return its default value.
  public mutating func clearBigqueryDestination() {self._bigqueryDestination = nil}

  /// Whether to enable network egress metering for this cluster. If enabled, a
  /// daemonset will be created in the cluster to meter network egress traffic.
  public var enableNetworkEgressMetering: Bool = false

  /// Configuration to enable resource consumption metering.
  public var consumptionMeteringConfig: Google_Container_V1_ResourceUsageExportConfig.ConsumptionMeteringConfig {
    get {return _consumptionMeteringConfig ?? Google_Container_V1_ResourceUsageExportConfig.ConsumptionMeteringConfig()}
    set {_consumptionMeteringConfig = newValue}
  }
  /// Returns true if `consumptionMeteringConfig` has been explicitly set.
  public var hasConsumptionMeteringConfig: Bool {return self._consumptionMeteringConfig != nil}
  /// Clears the value of `consumptionMeteringConfig`. Subsequent reads from it will return its default value.
  public mutating func clearConsumptionMeteringConfig() {self._consumptionMeteringConfig = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Parameters for using BigQuery as the destination of resource usage export.
  public struct BigQueryDestination {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of a BigQuery Dataset.
    public var datasetID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  /// Parameters for controlling consumption metering.
  public struct ConsumptionMeteringConfig {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Whether to enable consumption metering for this cluster. If enabled, a
    /// second BigQuery table will be created to hold resource consumption
    /// records.
    public var enabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _bigqueryDestination: Google_Container_V1_ResourceUsageExportConfig.BigQueryDestination? = nil
  fileprivate var _consumptionMeteringConfig: Google_Container_V1_ResourceUsageExportConfig.ConsumptionMeteringConfig? = nil
}

/// VerticalPodAutoscaling contains global, per-cluster information
/// required by Vertical Pod Autoscaler to automatically adjust
/// the resources of pods controlled by it.
public struct Google_Container_V1_VerticalPodAutoscaling {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enables vertical pod autoscaling.
  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.container.v1"

extension Google_Container_V1_NodeConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "machine_type"),
    2: .standard(proto: "disk_size_gb"),
    3: .standard(proto: "oauth_scopes"),
    9: .standard(proto: "service_account"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "image_type"),
    6: .same(proto: "labels"),
    7: .standard(proto: "local_ssd_count"),
    8: .same(proto: "tags"),
    10: .same(proto: "preemptible"),
    11: .same(proto: "accelerators"),
    12: .standard(proto: "disk_type"),
    13: .standard(proto: "min_cpu_platform"),
    15: .same(proto: "taints"),
    20: .standard(proto: "shielded_instance_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.machineType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.diskSizeGb) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.oauthScopes) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.imageType) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.localSsdCount) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.serviceAccount) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.preemptible) }()
      case 11: try { try decoder.decodeRepeatedMessageField(value: &self.accelerators) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.diskType) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.minCpuPlatform) }()
      case 15: try { try decoder.decodeRepeatedMessageField(value: &self.taints) }()
      case 20: try { try decoder.decodeSingularMessageField(value: &self._shieldedInstanceConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.machineType.isEmpty {
      try visitor.visitSingularStringField(value: self.machineType, fieldNumber: 1)
    }
    if self.diskSizeGb != 0 {
      try visitor.visitSingularInt32Field(value: self.diskSizeGb, fieldNumber: 2)
    }
    if !self.oauthScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.oauthScopes, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.metadata, fieldNumber: 4)
    }
    if !self.imageType.isEmpty {
      try visitor.visitSingularStringField(value: self.imageType, fieldNumber: 5)
    }
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 6)
    }
    if self.localSsdCount != 0 {
      try visitor.visitSingularInt32Field(value: self.localSsdCount, fieldNumber: 7)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 8)
    }
    if !self.serviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccount, fieldNumber: 9)
    }
    if self.preemptible != false {
      try visitor.visitSingularBoolField(value: self.preemptible, fieldNumber: 10)
    }
    if !self.accelerators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accelerators, fieldNumber: 11)
    }
    if !self.diskType.isEmpty {
      try visitor.visitSingularStringField(value: self.diskType, fieldNumber: 12)
    }
    if !self.minCpuPlatform.isEmpty {
      try visitor.visitSingularStringField(value: self.minCpuPlatform, fieldNumber: 13)
    }
    if !self.taints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taints, fieldNumber: 15)
    }
    if let v = self._shieldedInstanceConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NodeConfig, rhs: Google_Container_V1_NodeConfig) -> Bool {
    if lhs.machineType != rhs.machineType {return false}
    if lhs.diskSizeGb != rhs.diskSizeGb {return false}
    if lhs.oauthScopes != rhs.oauthScopes {return false}
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.localSsdCount != rhs.localSsdCount {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.preemptible != rhs.preemptible {return false}
    if lhs.accelerators != rhs.accelerators {return false}
    if lhs.diskType != rhs.diskType {return false}
    if lhs.minCpuPlatform != rhs.minCpuPlatform {return false}
    if lhs.taints != rhs.taints {return false}
    if lhs._shieldedInstanceConfig != rhs._shieldedInstanceConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ShieldedInstanceConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShieldedInstanceConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_secure_boot"),
    2: .standard(proto: "enable_integrity_monitoring"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableSecureBoot) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableIntegrityMonitoring) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableSecureBoot != false {
      try visitor.visitSingularBoolField(value: self.enableSecureBoot, fieldNumber: 1)
    }
    if self.enableIntegrityMonitoring != false {
      try visitor.visitSingularBoolField(value: self.enableIntegrityMonitoring, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ShieldedInstanceConfig, rhs: Google_Container_V1_ShieldedInstanceConfig) -> Bool {
    if lhs.enableSecureBoot != rhs.enableSecureBoot {return false}
    if lhs.enableIntegrityMonitoring != rhs.enableIntegrityMonitoring {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NodeTaint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeTaint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "effect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.effect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.effect != .unspecified {
      try visitor.visitSingularEnumField(value: self.effect, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NodeTaint, rhs: Google_Container_V1_NodeTaint) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.effect != rhs.effect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NodeTaint.Effect: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EFFECT_UNSPECIFIED"),
    1: .same(proto: "NO_SCHEDULE"),
    2: .same(proto: "PREFER_NO_SCHEDULE"),
    3: .same(proto: "NO_EXECUTE"),
  ]
}

extension Google_Container_V1_MasterAuth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterAuth"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "username"),
    2: .same(proto: "password"),
    3: .standard(proto: "client_certificate_config"),
    100: .standard(proto: "cluster_ca_certificate"),
    101: .standard(proto: "client_certificate"),
    102: .standard(proto: "client_key"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.username) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.password) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._clientCertificateConfig) }()
      case 100: try { try decoder.decodeSingularStringField(value: &self.clusterCaCertificate) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self.clientCertificate) }()
      case 102: try { try decoder.decodeSingularStringField(value: &self.clientKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 1)
    }
    if !self.password.isEmpty {
      try visitor.visitSingularStringField(value: self.password, fieldNumber: 2)
    }
    if let v = self._clientCertificateConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.clusterCaCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterCaCertificate, fieldNumber: 100)
    }
    if !self.clientCertificate.isEmpty {
      try visitor.visitSingularStringField(value: self.clientCertificate, fieldNumber: 101)
    }
    if !self.clientKey.isEmpty {
      try visitor.visitSingularStringField(value: self.clientKey, fieldNumber: 102)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_MasterAuth, rhs: Google_Container_V1_MasterAuth) -> Bool {
    if lhs.username != rhs.username {return false}
    if lhs.password != rhs.password {return false}
    if lhs._clientCertificateConfig != rhs._clientCertificateConfig {return false}
    if lhs.clusterCaCertificate != rhs.clusterCaCertificate {return false}
    if lhs.clientCertificate != rhs.clientCertificate {return false}
    if lhs.clientKey != rhs.clientKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ClientCertificateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClientCertificateConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "issue_client_certificate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.issueClientCertificate) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.issueClientCertificate != false {
      try visitor.visitSingularBoolField(value: self.issueClientCertificate, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ClientCertificateConfig, rhs: Google_Container_V1_ClientCertificateConfig) -> Bool {
    if lhs.issueClientCertificate != rhs.issueClientCertificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_AddonsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddonsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "http_load_balancing"),
    2: .standard(proto: "horizontal_pod_autoscaling"),
    3: .standard(proto: "kubernetes_dashboard"),
    4: .standard(proto: "network_policy_config"),
    7: .standard(proto: "cloud_run_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._httpLoadBalancing) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._horizontalPodAutoscaling) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._kubernetesDashboard) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._networkPolicyConfig) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._cloudRunConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._httpLoadBalancing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._horizontalPodAutoscaling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._kubernetesDashboard {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._networkPolicyConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._cloudRunConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_AddonsConfig, rhs: Google_Container_V1_AddonsConfig) -> Bool {
    if lhs._httpLoadBalancing != rhs._httpLoadBalancing {return false}
    if lhs._horizontalPodAutoscaling != rhs._horizontalPodAutoscaling {return false}
    if lhs._kubernetesDashboard != rhs._kubernetesDashboard {return false}
    if lhs._networkPolicyConfig != rhs._networkPolicyConfig {return false}
    if lhs._cloudRunConfig != rhs._cloudRunConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_HttpLoadBalancing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HttpLoadBalancing"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_HttpLoadBalancing, rhs: Google_Container_V1_HttpLoadBalancing) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_HorizontalPodAutoscaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HorizontalPodAutoscaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_HorizontalPodAutoscaling, rhs: Google_Container_V1_HorizontalPodAutoscaling) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_KubernetesDashboard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KubernetesDashboard"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_KubernetesDashboard, rhs: Google_Container_V1_KubernetesDashboard) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NetworkPolicyConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkPolicyConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NetworkPolicyConfig, rhs: Google_Container_V1_NetworkPolicyConfig) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_PrivateClusterConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateClusterConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_private_nodes"),
    2: .standard(proto: "enable_private_endpoint"),
    3: .standard(proto: "master_ipv4_cidr_block"),
    4: .standard(proto: "private_endpoint"),
    5: .standard(proto: "public_endpoint"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enablePrivateNodes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enablePrivateEndpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.masterIpv4CidrBlock) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.privateEndpoint) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.publicEndpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enablePrivateNodes != false {
      try visitor.visitSingularBoolField(value: self.enablePrivateNodes, fieldNumber: 1)
    }
    if self.enablePrivateEndpoint != false {
      try visitor.visitSingularBoolField(value: self.enablePrivateEndpoint, fieldNumber: 2)
    }
    if !self.masterIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.masterIpv4CidrBlock, fieldNumber: 3)
    }
    if !self.privateEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.privateEndpoint, fieldNumber: 4)
    }
    if !self.publicEndpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.publicEndpoint, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_PrivateClusterConfig, rhs: Google_Container_V1_PrivateClusterConfig) -> Bool {
    if lhs.enablePrivateNodes != rhs.enablePrivateNodes {return false}
    if lhs.enablePrivateEndpoint != rhs.enablePrivateEndpoint {return false}
    if lhs.masterIpv4CidrBlock != rhs.masterIpv4CidrBlock {return false}
    if lhs.privateEndpoint != rhs.privateEndpoint {return false}
    if lhs.publicEndpoint != rhs.publicEndpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_AuthenticatorGroupsConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticatorGroupsConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "security_group"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.securityGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.securityGroup, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_AuthenticatorGroupsConfig, rhs: Google_Container_V1_AuthenticatorGroupsConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.securityGroup != rhs.securityGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_CloudRunConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CloudRunConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "disabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_CloudRunConfig, rhs: Google_Container_V1_CloudRunConfig) -> Bool {
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_MasterAuthorizedNetworksConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MasterAuthorizedNetworksConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "cidr_blocks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cidrBlocks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if !self.cidrBlocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cidrBlocks, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_MasterAuthorizedNetworksConfig, rhs: Google_Container_V1_MasterAuthorizedNetworksConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.cidrBlocks != rhs.cidrBlocks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_MasterAuthorizedNetworksConfig.CidrBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Container_V1_MasterAuthorizedNetworksConfig.protoMessageName + ".CidrBlock"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "display_name"),
    2: .standard(proto: "cidr_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cidrBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    if !self.cidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.cidrBlock, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_MasterAuthorizedNetworksConfig.CidrBlock, rhs: Google_Container_V1_MasterAuthorizedNetworksConfig.CidrBlock) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs.cidrBlock != rhs.cidrBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_LegacyAbac: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LegacyAbac"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_LegacyAbac, rhs: Google_Container_V1_LegacyAbac) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NetworkPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
    2: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.provider) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.provider != .unspecified {
      try visitor.visitSingularEnumField(value: self.provider, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NetworkPolicy, rhs: Google_Container_V1_NetworkPolicy) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NetworkPolicy.Provider: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROVIDER_UNSPECIFIED"),
    1: .same(proto: "CALICO"),
  ]
}

extension Google_Container_V1_BinaryAuthorization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BinaryAuthorization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_BinaryAuthorization, rhs: Google_Container_V1_BinaryAuthorization) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_IPAllocationPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IPAllocationPolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "use_ip_aliases"),
    2: .standard(proto: "create_subnetwork"),
    3: .standard(proto: "subnetwork_name"),
    4: .standard(proto: "cluster_ipv4_cidr"),
    5: .standard(proto: "node_ipv4_cidr"),
    6: .standard(proto: "services_ipv4_cidr"),
    7: .standard(proto: "cluster_secondary_range_name"),
    8: .standard(proto: "services_secondary_range_name"),
    9: .standard(proto: "cluster_ipv4_cidr_block"),
    10: .standard(proto: "node_ipv4_cidr_block"),
    11: .standard(proto: "services_ipv4_cidr_block"),
    13: .standard(proto: "tpu_ipv4_cidr_block"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.useIpAliases) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.createSubnetwork) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subnetworkName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.clusterIpv4Cidr) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nodeIpv4Cidr) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.servicesIpv4Cidr) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.clusterSecondaryRangeName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.servicesSecondaryRangeName) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.clusterIpv4CidrBlock) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.nodeIpv4CidrBlock) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.servicesIpv4CidrBlock) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.tpuIpv4CidrBlock) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.useIpAliases != false {
      try visitor.visitSingularBoolField(value: self.useIpAliases, fieldNumber: 1)
    }
    if self.createSubnetwork != false {
      try visitor.visitSingularBoolField(value: self.createSubnetwork, fieldNumber: 2)
    }
    if !self.subnetworkName.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetworkName, fieldNumber: 3)
    }
    if !self.clusterIpv4Cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterIpv4Cidr, fieldNumber: 4)
    }
    if !self.nodeIpv4Cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeIpv4Cidr, fieldNumber: 5)
    }
    if !self.servicesIpv4Cidr.isEmpty {
      try visitor.visitSingularStringField(value: self.servicesIpv4Cidr, fieldNumber: 6)
    }
    if !self.clusterSecondaryRangeName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterSecondaryRangeName, fieldNumber: 7)
    }
    if !self.servicesSecondaryRangeName.isEmpty {
      try visitor.visitSingularStringField(value: self.servicesSecondaryRangeName, fieldNumber: 8)
    }
    if !self.clusterIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterIpv4CidrBlock, fieldNumber: 9)
    }
    if !self.nodeIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeIpv4CidrBlock, fieldNumber: 10)
    }
    if !self.servicesIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.servicesIpv4CidrBlock, fieldNumber: 11)
    }
    if !self.tpuIpv4CidrBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.tpuIpv4CidrBlock, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_IPAllocationPolicy, rhs: Google_Container_V1_IPAllocationPolicy) -> Bool {
    if lhs.useIpAliases != rhs.useIpAliases {return false}
    if lhs.createSubnetwork != rhs.createSubnetwork {return false}
    if lhs.subnetworkName != rhs.subnetworkName {return false}
    if lhs.clusterIpv4Cidr != rhs.clusterIpv4Cidr {return false}
    if lhs.nodeIpv4Cidr != rhs.nodeIpv4Cidr {return false}
    if lhs.servicesIpv4Cidr != rhs.servicesIpv4Cidr {return false}
    if lhs.clusterSecondaryRangeName != rhs.clusterSecondaryRangeName {return false}
    if lhs.servicesSecondaryRangeName != rhs.servicesSecondaryRangeName {return false}
    if lhs.clusterIpv4CidrBlock != rhs.clusterIpv4CidrBlock {return false}
    if lhs.nodeIpv4CidrBlock != rhs.nodeIpv4CidrBlock {return false}
    if lhs.servicesIpv4CidrBlock != rhs.servicesIpv4CidrBlock {return false}
    if lhs.tpuIpv4CidrBlock != rhs.tpuIpv4CidrBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_Cluster: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cluster"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .standard(proto: "initial_node_count"),
    4: .standard(proto: "node_config"),
    5: .standard(proto: "master_auth"),
    6: .standard(proto: "logging_service"),
    7: .standard(proto: "monitoring_service"),
    8: .same(proto: "network"),
    9: .standard(proto: "cluster_ipv4_cidr"),
    10: .standard(proto: "addons_config"),
    11: .same(proto: "subnetwork"),
    12: .standard(proto: "node_pools"),
    13: .same(proto: "locations"),
    14: .standard(proto: "enable_kubernetes_alpha"),
    15: .standard(proto: "resource_labels"),
    16: .standard(proto: "label_fingerprint"),
    18: .standard(proto: "legacy_abac"),
    19: .standard(proto: "network_policy"),
    20: .standard(proto: "ip_allocation_policy"),
    22: .standard(proto: "master_authorized_networks_config"),
    23: .standard(proto: "maintenance_policy"),
    24: .standard(proto: "binary_authorization"),
    26: .same(proto: "autoscaling"),
    27: .standard(proto: "network_config"),
    30: .standard(proto: "default_max_pods_constraint"),
    33: .standard(proto: "resource_usage_export_config"),
    34: .standard(proto: "authenticator_groups_config"),
    37: .standard(proto: "private_cluster_config"),
    38: .standard(proto: "database_encryption"),
    39: .standard(proto: "vertical_pod_autoscaling"),
    100: .standard(proto: "self_link"),
    101: .same(proto: "zone"),
    102: .same(proto: "endpoint"),
    103: .standard(proto: "initial_cluster_version"),
    104: .standard(proto: "current_master_version"),
    105: .standard(proto: "current_node_version"),
    106: .standard(proto: "create_time"),
    107: .same(proto: "status"),
    108: .standard(proto: "status_message"),
    109: .standard(proto: "node_ipv4_cidr_size"),
    110: .standard(proto: "services_ipv4_cidr"),
    111: .standard(proto: "instance_group_urls"),
    112: .standard(proto: "current_node_count"),
    113: .standard(proto: "expire_time"),
    114: .same(proto: "location"),
    115: .standard(proto: "enable_tpu"),
    116: .standard(proto: "tpu_ipv4_cidr_block"),
    118: .same(proto: "conditions"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _description_p: String = String()
    var _initialNodeCount: Int32 = 0
    var _nodeConfig: Google_Container_V1_NodeConfig? = nil
    var _masterAuth: Google_Container_V1_MasterAuth? = nil
    var _loggingService: String = String()
    var _monitoringService: String = String()
    var _network: String = String()
    var _clusterIpv4Cidr: String = String()
    var _addonsConfig: Google_Container_V1_AddonsConfig? = nil
    var _subnetwork: String = String()
    var _nodePools: [Google_Container_V1_NodePool] = []
    var _locations: [String] = []
    var _enableKubernetesAlpha: Bool = false
    var _resourceLabels: Dictionary<String,String> = [:]
    var _labelFingerprint: String = String()
    var _legacyAbac: Google_Container_V1_LegacyAbac? = nil
    var _networkPolicy: Google_Container_V1_NetworkPolicy? = nil
    var _ipAllocationPolicy: Google_Container_V1_IPAllocationPolicy? = nil
    var _masterAuthorizedNetworksConfig: Google_Container_V1_MasterAuthorizedNetworksConfig? = nil
    var _maintenancePolicy: Google_Container_V1_MaintenancePolicy? = nil
    var _binaryAuthorization: Google_Container_V1_BinaryAuthorization? = nil
    var _autoscaling: Google_Container_V1_ClusterAutoscaling? = nil
    var _networkConfig: Google_Container_V1_NetworkConfig? = nil
    var _defaultMaxPodsConstraint: Google_Container_V1_MaxPodsConstraint? = nil
    var _resourceUsageExportConfig: Google_Container_V1_ResourceUsageExportConfig? = nil
    var _authenticatorGroupsConfig: Google_Container_V1_AuthenticatorGroupsConfig? = nil
    var _privateClusterConfig: Google_Container_V1_PrivateClusterConfig? = nil
    var _databaseEncryption: Google_Container_V1_DatabaseEncryption? = nil
    var _verticalPodAutoscaling: Google_Container_V1_VerticalPodAutoscaling? = nil
    var _selfLink: String = String()
    var _zone: String = String()
    var _endpoint: String = String()
    var _initialClusterVersion: String = String()
    var _currentMasterVersion: String = String()
    var _currentNodeVersion: String = String()
    var _createTime: String = String()
    var _status: Google_Container_V1_Cluster.Status = .unspecified
    var _statusMessage: String = String()
    var _nodeIpv4CidrSize: Int32 = 0
    var _servicesIpv4Cidr: String = String()
    var _instanceGroupUrls: [String] = []
    var _currentNodeCount: Int32 = 0
    var _expireTime: String = String()
    var _location: String = String()
    var _enableTpu: Bool = false
    var _tpuIpv4CidrBlock: String = String()
    var _conditions: [Google_Container_V1_StatusCondition] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _description_p = source._description_p
      _initialNodeCount = source._initialNodeCount
      _nodeConfig = source._nodeConfig
      _masterAuth = source._masterAuth
      _loggingService = source._loggingService
      _monitoringService = source._monitoringService
      _network = source._network
      _clusterIpv4Cidr = source._clusterIpv4Cidr
      _addonsConfig = source._addonsConfig
      _subnetwork = source._subnetwork
      _nodePools = source._nodePools
      _locations = source._locations
      _enableKubernetesAlpha = source._enableKubernetesAlpha
      _resourceLabels = source._resourceLabels
      _labelFingerprint = source._labelFingerprint
      _legacyAbac = source._legacyAbac
      _networkPolicy = source._networkPolicy
      _ipAllocationPolicy = source._ipAllocationPolicy
      _masterAuthorizedNetworksConfig = source._masterAuthorizedNetworksConfig
      _maintenancePolicy = source._maintenancePolicy
      _binaryAuthorization = source._binaryAuthorization
      _autoscaling = source._autoscaling
      _networkConfig = source._networkConfig
      _defaultMaxPodsConstraint = source._defaultMaxPodsConstraint
      _resourceUsageExportConfig = source._resourceUsageExportConfig
      _authenticatorGroupsConfig = source._authenticatorGroupsConfig
      _privateClusterConfig = source._privateClusterConfig
      _databaseEncryption = source._databaseEncryption
      _verticalPodAutoscaling = source._verticalPodAutoscaling
      _selfLink = source._selfLink
      _zone = source._zone
      _endpoint = source._endpoint
      _initialClusterVersion = source._initialClusterVersion
      _currentMasterVersion = source._currentMasterVersion
      _currentNodeVersion = source._currentNodeVersion
      _createTime = source._createTime
      _status = source._status
      _statusMessage = source._statusMessage
      _nodeIpv4CidrSize = source._nodeIpv4CidrSize
      _servicesIpv4Cidr = source._servicesIpv4Cidr
      _instanceGroupUrls = source._instanceGroupUrls
      _currentNodeCount = source._currentNodeCount
      _expireTime = source._expireTime
      _location = source._location
      _enableTpu = source._enableTpu
      _tpuIpv4CidrBlock = source._tpuIpv4CidrBlock
      _conditions = source._conditions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._description_p) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._initialNodeCount) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._nodeConfig) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._masterAuth) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._loggingService) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._monitoringService) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._network) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._clusterIpv4Cidr) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._addonsConfig) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._subnetwork) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._nodePools) }()
        case 13: try { try decoder.decodeRepeatedStringField(value: &_storage._locations) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._enableKubernetesAlpha) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._resourceLabels) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._labelFingerprint) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._legacyAbac) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._networkPolicy) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._ipAllocationPolicy) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._masterAuthorizedNetworksConfig) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._maintenancePolicy) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._binaryAuthorization) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._autoscaling) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._networkConfig) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._defaultMaxPodsConstraint) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._resourceUsageExportConfig) }()
        case 34: try { try decoder.decodeSingularMessageField(value: &_storage._authenticatorGroupsConfig) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._privateClusterConfig) }()
        case 38: try { try decoder.decodeSingularMessageField(value: &_storage._databaseEncryption) }()
        case 39: try { try decoder.decodeSingularMessageField(value: &_storage._verticalPodAutoscaling) }()
        case 100: try { try decoder.decodeSingularStringField(value: &_storage._selfLink) }()
        case 101: try { try decoder.decodeSingularStringField(value: &_storage._zone) }()
        case 102: try { try decoder.decodeSingularStringField(value: &_storage._endpoint) }()
        case 103: try { try decoder.decodeSingularStringField(value: &_storage._initialClusterVersion) }()
        case 104: try { try decoder.decodeSingularStringField(value: &_storage._currentMasterVersion) }()
        case 105: try { try decoder.decodeSingularStringField(value: &_storage._currentNodeVersion) }()
        case 106: try { try decoder.decodeSingularStringField(value: &_storage._createTime) }()
        case 107: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 108: try { try decoder.decodeSingularStringField(value: &_storage._statusMessage) }()
        case 109: try { try decoder.decodeSingularInt32Field(value: &_storage._nodeIpv4CidrSize) }()
        case 110: try { try decoder.decodeSingularStringField(value: &_storage._servicesIpv4Cidr) }()
        case 111: try { try decoder.decodeRepeatedStringField(value: &_storage._instanceGroupUrls) }()
        case 112: try { try decoder.decodeSingularInt32Field(value: &_storage._currentNodeCount) }()
        case 113: try { try decoder.decodeSingularStringField(value: &_storage._expireTime) }()
        case 114: try { try decoder.decodeSingularStringField(value: &_storage._location) }()
        case 115: try { try decoder.decodeSingularBoolField(value: &_storage._enableTpu) }()
        case 116: try { try decoder.decodeSingularStringField(value: &_storage._tpuIpv4CidrBlock) }()
        case 118: try { try decoder.decodeRepeatedMessageField(value: &_storage._conditions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._description_p.isEmpty {
        try visitor.visitSingularStringField(value: _storage._description_p, fieldNumber: 2)
      }
      if _storage._initialNodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._initialNodeCount, fieldNumber: 3)
      }
      if let v = _storage._nodeConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._masterAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._loggingService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._loggingService, fieldNumber: 6)
      }
      if !_storage._monitoringService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._monitoringService, fieldNumber: 7)
      }
      if !_storage._network.isEmpty {
        try visitor.visitSingularStringField(value: _storage._network, fieldNumber: 8)
      }
      if !_storage._clusterIpv4Cidr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterIpv4Cidr, fieldNumber: 9)
      }
      if let v = _storage._addonsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
      if !_storage._subnetwork.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subnetwork, fieldNumber: 11)
      }
      if !_storage._nodePools.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nodePools, fieldNumber: 12)
      }
      if !_storage._locations.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._locations, fieldNumber: 13)
      }
      if _storage._enableKubernetesAlpha != false {
        try visitor.visitSingularBoolField(value: _storage._enableKubernetesAlpha, fieldNumber: 14)
      }
      if !_storage._resourceLabels.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._resourceLabels, fieldNumber: 15)
      }
      if !_storage._labelFingerprint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._labelFingerprint, fieldNumber: 16)
      }
      if let v = _storage._legacyAbac {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }
      if let v = _storage._networkPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._ipAllocationPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._masterAuthorizedNetworksConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._maintenancePolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }
      if let v = _storage._binaryAuthorization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }
      if let v = _storage._autoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._networkConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }
      if let v = _storage._defaultMaxPodsConstraint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }
      if let v = _storage._resourceUsageExportConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }
      if let v = _storage._authenticatorGroupsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }
      if let v = _storage._privateClusterConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }
      if let v = _storage._databaseEncryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }
      if let v = _storage._verticalPodAutoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }
      if !_storage._selfLink.isEmpty {
        try visitor.visitSingularStringField(value: _storage._selfLink, fieldNumber: 100)
      }
      if !_storage._zone.isEmpty {
        try visitor.visitSingularStringField(value: _storage._zone, fieldNumber: 101)
      }
      if !_storage._endpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endpoint, fieldNumber: 102)
      }
      if !_storage._initialClusterVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._initialClusterVersion, fieldNumber: 103)
      }
      if !_storage._currentMasterVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentMasterVersion, fieldNumber: 104)
      }
      if !_storage._currentNodeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currentNodeVersion, fieldNumber: 105)
      }
      if !_storage._createTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createTime, fieldNumber: 106)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 107)
      }
      if !_storage._statusMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusMessage, fieldNumber: 108)
      }
      if _storage._nodeIpv4CidrSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nodeIpv4CidrSize, fieldNumber: 109)
      }
      if !_storage._servicesIpv4Cidr.isEmpty {
        try visitor.visitSingularStringField(value: _storage._servicesIpv4Cidr, fieldNumber: 110)
      }
      if !_storage._instanceGroupUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instanceGroupUrls, fieldNumber: 111)
      }
      if _storage._currentNodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentNodeCount, fieldNumber: 112)
      }
      if !_storage._expireTime.isEmpty {
        try visitor.visitSingularStringField(value: _storage._expireTime, fieldNumber: 113)
      }
      if !_storage._location.isEmpty {
        try visitor.visitSingularStringField(value: _storage._location, fieldNumber: 114)
      }
      if _storage._enableTpu != false {
        try visitor.visitSingularBoolField(value: _storage._enableTpu, fieldNumber: 115)
      }
      if !_storage._tpuIpv4CidrBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tpuIpv4CidrBlock, fieldNumber: 116)
      }
      if !_storage._conditions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditions, fieldNumber: 118)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_Cluster, rhs: Google_Container_V1_Cluster) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._description_p != rhs_storage._description_p {return false}
        if _storage._initialNodeCount != rhs_storage._initialNodeCount {return false}
        if _storage._nodeConfig != rhs_storage._nodeConfig {return false}
        if _storage._masterAuth != rhs_storage._masterAuth {return false}
        if _storage._loggingService != rhs_storage._loggingService {return false}
        if _storage._monitoringService != rhs_storage._monitoringService {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._clusterIpv4Cidr != rhs_storage._clusterIpv4Cidr {return false}
        if _storage._addonsConfig != rhs_storage._addonsConfig {return false}
        if _storage._subnetwork != rhs_storage._subnetwork {return false}
        if _storage._nodePools != rhs_storage._nodePools {return false}
        if _storage._locations != rhs_storage._locations {return false}
        if _storage._enableKubernetesAlpha != rhs_storage._enableKubernetesAlpha {return false}
        if _storage._resourceLabels != rhs_storage._resourceLabels {return false}
        if _storage._labelFingerprint != rhs_storage._labelFingerprint {return false}
        if _storage._legacyAbac != rhs_storage._legacyAbac {return false}
        if _storage._networkPolicy != rhs_storage._networkPolicy {return false}
        if _storage._ipAllocationPolicy != rhs_storage._ipAllocationPolicy {return false}
        if _storage._masterAuthorizedNetworksConfig != rhs_storage._masterAuthorizedNetworksConfig {return false}
        if _storage._maintenancePolicy != rhs_storage._maintenancePolicy {return false}
        if _storage._binaryAuthorization != rhs_storage._binaryAuthorization {return false}
        if _storage._autoscaling != rhs_storage._autoscaling {return false}
        if _storage._networkConfig != rhs_storage._networkConfig {return false}
        if _storage._defaultMaxPodsConstraint != rhs_storage._defaultMaxPodsConstraint {return false}
        if _storage._resourceUsageExportConfig != rhs_storage._resourceUsageExportConfig {return false}
        if _storage._authenticatorGroupsConfig != rhs_storage._authenticatorGroupsConfig {return false}
        if _storage._privateClusterConfig != rhs_storage._privateClusterConfig {return false}
        if _storage._databaseEncryption != rhs_storage._databaseEncryption {return false}
        if _storage._verticalPodAutoscaling != rhs_storage._verticalPodAutoscaling {return false}
        if _storage._selfLink != rhs_storage._selfLink {return false}
        if _storage._zone != rhs_storage._zone {return false}
        if _storage._endpoint != rhs_storage._endpoint {return false}
        if _storage._initialClusterVersion != rhs_storage._initialClusterVersion {return false}
        if _storage._currentMasterVersion != rhs_storage._currentMasterVersion {return false}
        if _storage._currentNodeVersion != rhs_storage._currentNodeVersion {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusMessage != rhs_storage._statusMessage {return false}
        if _storage._nodeIpv4CidrSize != rhs_storage._nodeIpv4CidrSize {return false}
        if _storage._servicesIpv4Cidr != rhs_storage._servicesIpv4Cidr {return false}
        if _storage._instanceGroupUrls != rhs_storage._instanceGroupUrls {return false}
        if _storage._currentNodeCount != rhs_storage._currentNodeCount {return false}
        if _storage._expireTime != rhs_storage._expireTime {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._enableTpu != rhs_storage._enableTpu {return false}
        if _storage._tpuIpv4CidrBlock != rhs_storage._tpuIpv4CidrBlock {return false}
        if _storage._conditions != rhs_storage._conditions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_Cluster.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "PROVISIONING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "RECONCILING"),
    4: .same(proto: "STOPPING"),
    5: .same(proto: "ERROR"),
    6: .same(proto: "DEGRADED"),
  ]
}

extension Google_Container_V1_ClusterUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "desired_node_version"),
    5: .standard(proto: "desired_monitoring_service"),
    6: .standard(proto: "desired_addons_config"),
    7: .standard(proto: "desired_node_pool_id"),
    8: .standard(proto: "desired_image_type"),
    46: .standard(proto: "desired_database_encryption"),
    9: .standard(proto: "desired_node_pool_autoscaling"),
    10: .standard(proto: "desired_locations"),
    12: .standard(proto: "desired_master_authorized_networks_config"),
    15: .standard(proto: "desired_cluster_autoscaling"),
    16: .standard(proto: "desired_binary_authorization"),
    19: .standard(proto: "desired_logging_service"),
    21: .standard(proto: "desired_resource_usage_export_config"),
    22: .standard(proto: "desired_vertical_pod_autoscaling"),
    26: .standard(proto: "desired_intra_node_visibility_config"),
    100: .standard(proto: "desired_master_version"),
  ]

  fileprivate class _StorageClass {
    var _desiredNodeVersion: String = String()
    var _desiredMonitoringService: String = String()
    var _desiredAddonsConfig: Google_Container_V1_AddonsConfig? = nil
    var _desiredNodePoolID: String = String()
    var _desiredImageType: String = String()
    var _desiredDatabaseEncryption: Google_Container_V1_DatabaseEncryption? = nil
    var _desiredNodePoolAutoscaling: Google_Container_V1_NodePoolAutoscaling? = nil
    var _desiredLocations: [String] = []
    var _desiredMasterAuthorizedNetworksConfig: Google_Container_V1_MasterAuthorizedNetworksConfig? = nil
    var _desiredClusterAutoscaling: Google_Container_V1_ClusterAutoscaling? = nil
    var _desiredBinaryAuthorization: Google_Container_V1_BinaryAuthorization? = nil
    var _desiredLoggingService: String = String()
    var _desiredResourceUsageExportConfig: Google_Container_V1_ResourceUsageExportConfig? = nil
    var _desiredVerticalPodAutoscaling: Google_Container_V1_VerticalPodAutoscaling? = nil
    var _desiredIntraNodeVisibilityConfig: Google_Container_V1_IntraNodeVisibilityConfig? = nil
    var _desiredMasterVersion: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _desiredNodeVersion = source._desiredNodeVersion
      _desiredMonitoringService = source._desiredMonitoringService
      _desiredAddonsConfig = source._desiredAddonsConfig
      _desiredNodePoolID = source._desiredNodePoolID
      _desiredImageType = source._desiredImageType
      _desiredDatabaseEncryption = source._desiredDatabaseEncryption
      _desiredNodePoolAutoscaling = source._desiredNodePoolAutoscaling
      _desiredLocations = source._desiredLocations
      _desiredMasterAuthorizedNetworksConfig = source._desiredMasterAuthorizedNetworksConfig
      _desiredClusterAutoscaling = source._desiredClusterAutoscaling
      _desiredBinaryAuthorization = source._desiredBinaryAuthorization
      _desiredLoggingService = source._desiredLoggingService
      _desiredResourceUsageExportConfig = source._desiredResourceUsageExportConfig
      _desiredVerticalPodAutoscaling = source._desiredVerticalPodAutoscaling
      _desiredIntraNodeVisibilityConfig = source._desiredIntraNodeVisibilityConfig
      _desiredMasterVersion = source._desiredMasterVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._desiredNodeVersion) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._desiredMonitoringService) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._desiredAddonsConfig) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._desiredNodePoolID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._desiredImageType) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._desiredNodePoolAutoscaling) }()
        case 10: try { try decoder.decodeRepeatedStringField(value: &_storage._desiredLocations) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._desiredMasterAuthorizedNetworksConfig) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._desiredClusterAutoscaling) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._desiredBinaryAuthorization) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._desiredLoggingService) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._desiredResourceUsageExportConfig) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._desiredVerticalPodAutoscaling) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._desiredIntraNodeVisibilityConfig) }()
        case 46: try { try decoder.decodeSingularMessageField(value: &_storage._desiredDatabaseEncryption) }()
        case 100: try { try decoder.decodeSingularStringField(value: &_storage._desiredMasterVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._desiredNodeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desiredNodeVersion, fieldNumber: 4)
      }
      if !_storage._desiredMonitoringService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desiredMonitoringService, fieldNumber: 5)
      }
      if let v = _storage._desiredAddonsConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if !_storage._desiredNodePoolID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desiredNodePoolID, fieldNumber: 7)
      }
      if !_storage._desiredImageType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desiredImageType, fieldNumber: 8)
      }
      if let v = _storage._desiredNodePoolAutoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }
      if !_storage._desiredLocations.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._desiredLocations, fieldNumber: 10)
      }
      if let v = _storage._desiredMasterAuthorizedNetworksConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._desiredClusterAutoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._desiredBinaryAuthorization {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if !_storage._desiredLoggingService.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desiredLoggingService, fieldNumber: 19)
      }
      if let v = _storage._desiredResourceUsageExportConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }
      if let v = _storage._desiredVerticalPodAutoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }
      if let v = _storage._desiredIntraNodeVisibilityConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if let v = _storage._desiredDatabaseEncryption {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }
      if !_storage._desiredMasterVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._desiredMasterVersion, fieldNumber: 100)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ClusterUpdate, rhs: Google_Container_V1_ClusterUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._desiredNodeVersion != rhs_storage._desiredNodeVersion {return false}
        if _storage._desiredMonitoringService != rhs_storage._desiredMonitoringService {return false}
        if _storage._desiredAddonsConfig != rhs_storage._desiredAddonsConfig {return false}
        if _storage._desiredNodePoolID != rhs_storage._desiredNodePoolID {return false}
        if _storage._desiredImageType != rhs_storage._desiredImageType {return false}
        if _storage._desiredDatabaseEncryption != rhs_storage._desiredDatabaseEncryption {return false}
        if _storage._desiredNodePoolAutoscaling != rhs_storage._desiredNodePoolAutoscaling {return false}
        if _storage._desiredLocations != rhs_storage._desiredLocations {return false}
        if _storage._desiredMasterAuthorizedNetworksConfig != rhs_storage._desiredMasterAuthorizedNetworksConfig {return false}
        if _storage._desiredClusterAutoscaling != rhs_storage._desiredClusterAutoscaling {return false}
        if _storage._desiredBinaryAuthorization != rhs_storage._desiredBinaryAuthorization {return false}
        if _storage._desiredLoggingService != rhs_storage._desiredLoggingService {return false}
        if _storage._desiredResourceUsageExportConfig != rhs_storage._desiredResourceUsageExportConfig {return false}
        if _storage._desiredVerticalPodAutoscaling != rhs_storage._desiredVerticalPodAutoscaling {return false}
        if _storage._desiredIntraNodeVisibilityConfig != rhs_storage._desiredIntraNodeVisibilityConfig {return false}
        if _storage._desiredMasterVersion != rhs_storage._desiredMasterVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Operation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "zone"),
    3: .standard(proto: "operation_type"),
    4: .same(proto: "status"),
    8: .same(proto: "detail"),
    5: .standard(proto: "status_message"),
    6: .standard(proto: "self_link"),
    7: .standard(proto: "target_link"),
    9: .same(proto: "location"),
    10: .standard(proto: "start_time"),
    11: .standard(proto: "end_time"),
    13: .standard(proto: "cluster_conditions"),
    14: .standard(proto: "nodepool_conditions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.operationType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusMessage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.selfLink) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.targetLink) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.detail) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.location) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.endTime) }()
      case 13: try { try decoder.decodeRepeatedMessageField(value: &self.clusterConditions) }()
      case 14: try { try decoder.decodeRepeatedMessageField(value: &self.nodepoolConditions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if self.operationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.operationType, fieldNumber: 3)
    }
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    if !self.statusMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMessage, fieldNumber: 5)
    }
    if !self.selfLink.isEmpty {
      try visitor.visitSingularStringField(value: self.selfLink, fieldNumber: 6)
    }
    if !self.targetLink.isEmpty {
      try visitor.visitSingularStringField(value: self.targetLink, fieldNumber: 7)
    }
    if !self.detail.isEmpty {
      try visitor.visitSingularStringField(value: self.detail, fieldNumber: 8)
    }
    if !self.location.isEmpty {
      try visitor.visitSingularStringField(value: self.location, fieldNumber: 9)
    }
    if !self.startTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startTime, fieldNumber: 10)
    }
    if !self.endTime.isEmpty {
      try visitor.visitSingularStringField(value: self.endTime, fieldNumber: 11)
    }
    if !self.clusterConditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusterConditions, fieldNumber: 13)
    }
    if !self.nodepoolConditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodepoolConditions, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_Operation, rhs: Google_Container_V1_Operation) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.operationType != rhs.operationType {return false}
    if lhs.status != rhs.status {return false}
    if lhs.detail != rhs.detail {return false}
    if lhs.statusMessage != rhs.statusMessage {return false}
    if lhs.selfLink != rhs.selfLink {return false}
    if lhs.targetLink != rhs.targetLink {return false}
    if lhs.location != rhs.location {return false}
    if lhs.startTime != rhs.startTime {return false}
    if lhs.endTime != rhs.endTime {return false}
    if lhs.clusterConditions != rhs.clusterConditions {return false}
    if lhs.nodepoolConditions != rhs.nodepoolConditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_Operation.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "PENDING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "DONE"),
    4: .same(proto: "ABORTING"),
  ]
}

extension Google_Container_V1_Operation.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TYPE_UNSPECIFIED"),
    1: .same(proto: "CREATE_CLUSTER"),
    2: .same(proto: "DELETE_CLUSTER"),
    3: .same(proto: "UPGRADE_MASTER"),
    4: .same(proto: "UPGRADE_NODES"),
    5: .same(proto: "REPAIR_CLUSTER"),
    6: .same(proto: "UPDATE_CLUSTER"),
    7: .same(proto: "CREATE_NODE_POOL"),
    8: .same(proto: "DELETE_NODE_POOL"),
    9: .same(proto: "SET_NODE_POOL_MANAGEMENT"),
    10: .same(proto: "AUTO_REPAIR_NODES"),
    11: .same(proto: "AUTO_UPGRADE_NODES"),
    12: .same(proto: "SET_LABELS"),
    13: .same(proto: "SET_MASTER_AUTH"),
    14: .same(proto: "SET_NODE_POOL_SIZE"),
    15: .same(proto: "SET_NETWORK_POLICY"),
    16: .same(proto: "SET_MAINTENANCE_POLICY"),
  ]
}

extension Google_Container_V1_CreateClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .same(proto: "cluster"),
    5: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._cluster) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if let v = self._cluster {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_CreateClusterRequest, rhs: Google_Container_V1_CreateClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs._cluster != rhs._cluster {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_GetClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_GetClusterRequest, rhs: Google_Container_V1_GetClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_UpdateClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "update"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_UpdateClusterRequest, rhs: Google_Container_V1_UpdateClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._update != rhs._update {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_UpdateNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .standard(proto: "node_version"),
    6: .standard(proto: "image_type"),
    8: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.nodeVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageType) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.nodeVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.nodeVersion, fieldNumber: 5)
    }
    if !self.imageType.isEmpty {
      try visitor.visitSingularStringField(value: self.imageType, fieldNumber: 6)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_UpdateNodePoolRequest, rhs: Google_Container_V1_UpdateNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.nodeVersion != rhs.nodeVersion {return false}
    if lhs.imageType != rhs.imageType {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetNodePoolAutoscalingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNodePoolAutoscalingRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .same(proto: "autoscaling"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._autoscaling) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if let v = self._autoscaling {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetNodePoolAutoscalingRequest, rhs: Google_Container_V1_SetNodePoolAutoscalingRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs._autoscaling != rhs._autoscaling {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetLoggingServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLoggingServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "logging_service"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.loggingService) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.loggingService.isEmpty {
      try visitor.visitSingularStringField(value: self.loggingService, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetLoggingServiceRequest, rhs: Google_Container_V1_SetLoggingServiceRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.loggingService != rhs.loggingService {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetMonitoringServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMonitoringServiceRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "monitoring_service"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.monitoringService) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.monitoringService.isEmpty {
      try visitor.visitSingularStringField(value: self.monitoringService, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetMonitoringServiceRequest, rhs: Google_Container_V1_SetMonitoringServiceRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.monitoringService != rhs.monitoringService {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetAddonsConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetAddonsConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "addons_config"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._addonsConfig) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._addonsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetAddonsConfigRequest, rhs: Google_Container_V1_SetAddonsConfigRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._addonsConfig != rhs._addonsConfig {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetLocationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLocationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "locations"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.locations) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.locations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.locations, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetLocationsRequest, rhs: Google_Container_V1_SetLocationsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.locations != rhs.locations {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_UpdateMasterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateMasterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "master_version"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.masterVersion) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.masterVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.masterVersion, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_UpdateMasterRequest, rhs: Google_Container_V1_UpdateMasterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.masterVersion != rhs.masterVersion {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetMasterAuthRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMasterAuthRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "action"),
    5: .same(proto: "update"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._update) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if self.action != .unknown {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    if let v = self._update {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetMasterAuthRequest, rhs: Google_Container_V1_SetMasterAuthRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.action != rhs.action {return false}
    if lhs._update != rhs._update {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetMasterAuthRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SET_PASSWORD"),
    2: .same(proto: "GENERATE_PASSWORD"),
    3: .same(proto: "SET_USERNAME"),
  ]
}

extension Google_Container_V1_DeleteClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteClusterRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_DeleteClusterRequest, rhs: Google_Container_V1_DeleteClusterRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    4: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListClustersRequest, rhs: Google_Container_V1_ListClustersRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListClustersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "clusters"),
    2: .standard(proto: "missing_zones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.missingZones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    if !self.missingZones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missingZones, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListClustersResponse, rhs: Google_Container_V1_ListClustersResponse) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.missingZones != rhs.missingZones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_GetOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "operation_id"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_GetOperationRequest, rhs: Google_Container_V1_GetOperationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOperationsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    4: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListOperationsRequest, rhs: Google_Container_V1_ListOperationsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_CancelOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CancelOperationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "operation_id"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_CancelOperationRequest, rhs: Google_Container_V1_CancelOperationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOperationsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operations"),
    2: .standard(proto: "missing_zones"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.missingZones) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 1)
    }
    if !self.missingZones.isEmpty {
      try visitor.visitRepeatedStringField(value: self.missingZones, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListOperationsResponse, rhs: Google_Container_V1_ListOperationsResponse) -> Bool {
    if lhs.operations != rhs.operations {return false}
    if lhs.missingZones != rhs.missingZones {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_GetServerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServerConfigRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    4: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_GetServerConfigRequest, rhs: Google_Container_V1_GetServerConfigRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ServerConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "default_cluster_version"),
    3: .standard(proto: "valid_node_versions"),
    4: .standard(proto: "default_image_type"),
    5: .standard(proto: "valid_image_types"),
    6: .standard(proto: "valid_master_versions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.defaultClusterVersion) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.validNodeVersions) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.defaultImageType) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.validImageTypes) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.validMasterVersions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.defaultClusterVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultClusterVersion, fieldNumber: 1)
    }
    if !self.validNodeVersions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validNodeVersions, fieldNumber: 3)
    }
    if !self.defaultImageType.isEmpty {
      try visitor.visitSingularStringField(value: self.defaultImageType, fieldNumber: 4)
    }
    if !self.validImageTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validImageTypes, fieldNumber: 5)
    }
    if !self.validMasterVersions.isEmpty {
      try visitor.visitRepeatedStringField(value: self.validMasterVersions, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ServerConfig, rhs: Google_Container_V1_ServerConfig) -> Bool {
    if lhs.defaultClusterVersion != rhs.defaultClusterVersion {return false}
    if lhs.validNodeVersions != rhs.validNodeVersions {return false}
    if lhs.defaultImageType != rhs.defaultImageType {return false}
    if lhs.validImageTypes != rhs.validImageTypes {return false}
    if lhs.validMasterVersions != rhs.validMasterVersions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_CreateNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool"),
    6: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nodePool) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._nodePool {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_CreateNodePoolRequest, rhs: Google_Container_V1_CreateNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._nodePool != rhs._nodePool {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_DeleteNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_DeleteNodePoolRequest, rhs: Google_Container_V1_DeleteNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListNodePoolsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNodePoolsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    5: .same(proto: "parent"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListNodePoolsRequest, rhs: Google_Container_V1_ListNodePoolsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.parent != rhs.parent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_GetNodePoolRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNodePoolRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_GetNodePoolRequest, rhs: Google_Container_V1_GetNodePoolRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NodePool: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodePool"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "config"),
    3: .standard(proto: "initial_node_count"),
    100: .standard(proto: "self_link"),
    101: .same(proto: "version"),
    102: .standard(proto: "instance_group_urls"),
    103: .same(proto: "status"),
    104: .standard(proto: "status_message"),
    4: .same(proto: "autoscaling"),
    5: .same(proto: "management"),
    6: .standard(proto: "max_pods_constraint"),
    105: .same(proto: "conditions"),
    7: .standard(proto: "pod_ipv4_cidr_size"),
  ]

  fileprivate class _StorageClass {
    var _name: String = String()
    var _config: Google_Container_V1_NodeConfig? = nil
    var _initialNodeCount: Int32 = 0
    var _selfLink: String = String()
    var _version: String = String()
    var _instanceGroupUrls: [String] = []
    var _status: Google_Container_V1_NodePool.Status = .unspecified
    var _statusMessage: String = String()
    var _autoscaling: Google_Container_V1_NodePoolAutoscaling? = nil
    var _management: Google_Container_V1_NodeManagement? = nil
    var _maxPodsConstraint: Google_Container_V1_MaxPodsConstraint? = nil
    var _conditions: [Google_Container_V1_StatusCondition] = []
    var _podIpv4CidrSize: Int32 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _config = source._config
      _initialNodeCount = source._initialNodeCount
      _selfLink = source._selfLink
      _version = source._version
      _instanceGroupUrls = source._instanceGroupUrls
      _status = source._status
      _statusMessage = source._statusMessage
      _autoscaling = source._autoscaling
      _management = source._management
      _maxPodsConstraint = source._maxPodsConstraint
      _conditions = source._conditions
      _podIpv4CidrSize = source._podIpv4CidrSize
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._initialNodeCount) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._autoscaling) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._management) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._maxPodsConstraint) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._podIpv4CidrSize) }()
        case 100: try { try decoder.decodeSingularStringField(value: &_storage._selfLink) }()
        case 101: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 102: try { try decoder.decodeRepeatedStringField(value: &_storage._instanceGroupUrls) }()
        case 103: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 104: try { try decoder.decodeSingularStringField(value: &_storage._statusMessage) }()
        case 105: try { try decoder.decodeRepeatedMessageField(value: &_storage._conditions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if _storage._initialNodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._initialNodeCount, fieldNumber: 3)
      }
      if let v = _storage._autoscaling {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._management {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._maxPodsConstraint {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }
      if _storage._podIpv4CidrSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._podIpv4CidrSize, fieldNumber: 7)
      }
      if !_storage._selfLink.isEmpty {
        try visitor.visitSingularStringField(value: _storage._selfLink, fieldNumber: 100)
      }
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 101)
      }
      if !_storage._instanceGroupUrls.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._instanceGroupUrls, fieldNumber: 102)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 103)
      }
      if !_storage._statusMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._statusMessage, fieldNumber: 104)
      }
      if !_storage._conditions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._conditions, fieldNumber: 105)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NodePool, rhs: Google_Container_V1_NodePool) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._initialNodeCount != rhs_storage._initialNodeCount {return false}
        if _storage._selfLink != rhs_storage._selfLink {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._instanceGroupUrls != rhs_storage._instanceGroupUrls {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._statusMessage != rhs_storage._statusMessage {return false}
        if _storage._autoscaling != rhs_storage._autoscaling {return false}
        if _storage._management != rhs_storage._management {return false}
        if _storage._maxPodsConstraint != rhs_storage._maxPodsConstraint {return false}
        if _storage._conditions != rhs_storage._conditions {return false}
        if _storage._podIpv4CidrSize != rhs_storage._podIpv4CidrSize {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NodePool.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_UNSPECIFIED"),
    1: .same(proto: "PROVISIONING"),
    2: .same(proto: "RUNNING"),
    3: .same(proto: "RUNNING_WITH_ERROR"),
    4: .same(proto: "RECONCILING"),
    5: .same(proto: "STOPPING"),
    6: .same(proto: "ERROR"),
  ]
}

extension Google_Container_V1_NodeManagement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeManagement"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_upgrade"),
    2: .standard(proto: "auto_repair"),
    10: .standard(proto: "upgrade_options"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.autoUpgrade) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.autoRepair) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._upgradeOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.autoUpgrade != false {
      try visitor.visitSingularBoolField(value: self.autoUpgrade, fieldNumber: 1)
    }
    if self.autoRepair != false {
      try visitor.visitSingularBoolField(value: self.autoRepair, fieldNumber: 2)
    }
    if let v = self._upgradeOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NodeManagement, rhs: Google_Container_V1_NodeManagement) -> Bool {
    if lhs.autoUpgrade != rhs.autoUpgrade {return false}
    if lhs.autoRepair != rhs.autoRepair {return false}
    if lhs._upgradeOptions != rhs._upgradeOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_AutoUpgradeOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutoUpgradeOptions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "auto_upgrade_start_time"),
    2: .same(proto: "description"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.autoUpgradeStartTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.autoUpgradeStartTime.isEmpty {
      try visitor.visitSingularStringField(value: self.autoUpgradeStartTime, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_AutoUpgradeOptions, rhs: Google_Container_V1_AutoUpgradeOptions) -> Bool {
    if lhs.autoUpgradeStartTime != rhs.autoUpgradeStartTime {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_MaintenancePolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaintenancePolicy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "window"),
    3: .standard(proto: "resource_version"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._window) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._window {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_MaintenancePolicy, rhs: Google_Container_V1_MaintenancePolicy) -> Bool {
    if lhs._window != rhs._window {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_MaintenanceWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaintenanceWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "daily_maintenance_window"),
    3: .standard(proto: "recurring_window"),
    4: .standard(proto: "maintenance_exclusions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Google_Container_V1_DailyMaintenanceWindow?
        if let current = self.policy {
          try decoder.handleConflictingOneOf()
          if case .dailyMaintenanceWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policy = .dailyMaintenanceWindow(v)}
      }()
      case 3: try {
        var v: Google_Container_V1_RecurringTimeWindow?
        if let current = self.policy {
          try decoder.handleConflictingOneOf()
          if case .recurringWindow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.policy = .recurringWindow(v)}
      }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Container_V1_TimeWindow>.self, value: &self.maintenanceExclusions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.policy {
    case .dailyMaintenanceWindow?: try {
      guard case .dailyMaintenanceWindow(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .recurringWindow?: try {
      guard case .recurringWindow(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.maintenanceExclusions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Container_V1_TimeWindow>.self, value: self.maintenanceExclusions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_MaintenanceWindow, rhs: Google_Container_V1_MaintenanceWindow) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.maintenanceExclusions != rhs.maintenanceExclusions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_TimeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_time"),
    2: .standard(proto: "end_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_TimeWindow, rhs: Google_Container_V1_TimeWindow) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_RecurringTimeWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecurringTimeWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "window"),
    2: .same(proto: "recurrence"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._window) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recurrence) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._window {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.recurrence.isEmpty {
      try visitor.visitSingularStringField(value: self.recurrence, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_RecurringTimeWindow, rhs: Google_Container_V1_RecurringTimeWindow) -> Bool {
    if lhs._window != rhs._window {return false}
    if lhs.recurrence != rhs.recurrence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_DailyMaintenanceWindow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DailyMaintenanceWindow"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "start_time"),
    3: .same(proto: "duration"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.startTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.duration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startTime.isEmpty {
      try visitor.visitSingularStringField(value: self.startTime, fieldNumber: 2)
    }
    if !self.duration.isEmpty {
      try visitor.visitSingularStringField(value: self.duration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_DailyMaintenanceWindow, rhs: Google_Container_V1_DailyMaintenanceWindow) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetNodePoolManagementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNodePoolManagementRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .same(proto: "management"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._management) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if let v = self._management {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetNodePoolManagementRequest, rhs: Google_Container_V1_SetNodePoolManagementRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs._management != rhs._management {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetNodePoolSizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNodePoolSizeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    5: .standard(proto: "node_count"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.nodeCount) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if self.nodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.nodeCount, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetNodePoolSizeRequest, rhs: Google_Container_V1_SetNodePoolSizeRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.nodeCount != rhs.nodeCount {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_RollbackNodePoolUpgradeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RollbackNodePoolUpgradeRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "node_pool_id"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nodePoolID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.nodePoolID.isEmpty {
      try visitor.visitSingularStringField(value: self.nodePoolID, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_RollbackNodePoolUpgradeRequest, rhs: Google_Container_V1_RollbackNodePoolUpgradeRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.nodePoolID != rhs.nodePoolID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListNodePoolsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNodePoolsResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_pools"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.nodePools) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodePools.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nodePools, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListNodePoolsResponse, rhs: Google_Container_V1_ListNodePoolsResponse) -> Bool {
    if lhs.nodePools != rhs.nodePools {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ClusterAutoscaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterAutoscaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "enable_node_autoprovisioning"),
    2: .standard(proto: "resource_limits"),
    4: .standard(proto: "autoprovisioning_node_pool_defaults"),
    5: .standard(proto: "autoprovisioning_locations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableNodeAutoprovisioning) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.resourceLimits) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._autoprovisioningNodePoolDefaults) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.autoprovisioningLocations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableNodeAutoprovisioning != false {
      try visitor.visitSingularBoolField(value: self.enableNodeAutoprovisioning, fieldNumber: 1)
    }
    if !self.resourceLimits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resourceLimits, fieldNumber: 2)
    }
    if let v = self._autoprovisioningNodePoolDefaults {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.autoprovisioningLocations.isEmpty {
      try visitor.visitRepeatedStringField(value: self.autoprovisioningLocations, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ClusterAutoscaling, rhs: Google_Container_V1_ClusterAutoscaling) -> Bool {
    if lhs.enableNodeAutoprovisioning != rhs.enableNodeAutoprovisioning {return false}
    if lhs.resourceLimits != rhs.resourceLimits {return false}
    if lhs._autoprovisioningNodePoolDefaults != rhs._autoprovisioningNodePoolDefaults {return false}
    if lhs.autoprovisioningLocations != rhs.autoprovisioningLocations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_AutoprovisioningNodePoolDefaults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AutoprovisioningNodePoolDefaults"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oauth_scopes"),
    2: .standard(proto: "service_account"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.oauthScopes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.serviceAccount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.oauthScopes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.oauthScopes, fieldNumber: 1)
    }
    if !self.serviceAccount.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_AutoprovisioningNodePoolDefaults, rhs: Google_Container_V1_AutoprovisioningNodePoolDefaults) -> Bool {
    if lhs.oauthScopes != rhs.oauthScopes {return false}
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ResourceLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceLimit"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "resource_type"),
    2: .same(proto: "minimum"),
    3: .same(proto: "maximum"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.resourceType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.minimum) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maximum) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.resourceType.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceType, fieldNumber: 1)
    }
    if self.minimum != 0 {
      try visitor.visitSingularInt64Field(value: self.minimum, fieldNumber: 2)
    }
    if self.maximum != 0 {
      try visitor.visitSingularInt64Field(value: self.maximum, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ResourceLimit, rhs: Google_Container_V1_ResourceLimit) -> Bool {
    if lhs.resourceType != rhs.resourceType {return false}
    if lhs.minimum != rhs.minimum {return false}
    if lhs.maximum != rhs.maximum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_NodePoolAutoscaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodePoolAutoscaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
    2: .standard(proto: "min_node_count"),
    3: .standard(proto: "max_node_count"),
    4: .same(proto: "autoprovisioned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minNodeCount) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxNodeCount) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.autoprovisioned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.minNodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.minNodeCount, fieldNumber: 2)
    }
    if self.maxNodeCount != 0 {
      try visitor.visitSingularInt32Field(value: self.maxNodeCount, fieldNumber: 3)
    }
    if self.autoprovisioned != false {
      try visitor.visitSingularBoolField(value: self.autoprovisioned, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NodePoolAutoscaling, rhs: Google_Container_V1_NodePoolAutoscaling) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.minNodeCount != rhs.minNodeCount {return false}
    if lhs.maxNodeCount != rhs.maxNodeCount {return false}
    if lhs.autoprovisioned != rhs.autoprovisioned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetLabelsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLabelsRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "resource_labels"),
    5: .standard(proto: "label_fingerprint"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.resourceLabels) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.labelFingerprint) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.resourceLabels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.resourceLabels, fieldNumber: 4)
    }
    if !self.labelFingerprint.isEmpty {
      try visitor.visitSingularStringField(value: self.labelFingerprint, fieldNumber: 5)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetLabelsRequest, rhs: Google_Container_V1_SetLabelsRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.resourceLabels != rhs.resourceLabels {return false}
    if lhs.labelFingerprint != rhs.labelFingerprint {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetLegacyAbacRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetLegacyAbacRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .same(proto: "enabled"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetLegacyAbacRequest, rhs: Google_Container_V1_SetLegacyAbacRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_StartIPRotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartIPRotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    6: .same(proto: "name"),
    7: .standard(proto: "rotate_credentials"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.rotateCredentials) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    if self.rotateCredentials != false {
      try visitor.visitSingularBoolField(value: self.rotateCredentials, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_StartIPRotationRequest, rhs: Google_Container_V1_StartIPRotationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.rotateCredentials != rhs.rotateCredentials {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_CompleteIPRotationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CompleteIPRotationRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    7: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_CompleteIPRotationRequest, rhs: Google_Container_V1_CompleteIPRotationRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_AcceleratorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AcceleratorConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "accelerator_count"),
    2: .standard(proto: "accelerator_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.acceleratorCount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.acceleratorType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.acceleratorCount != 0 {
      try visitor.visitSingularInt64Field(value: self.acceleratorCount, fieldNumber: 1)
    }
    if !self.acceleratorType.isEmpty {
      try visitor.visitSingularStringField(value: self.acceleratorType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_AcceleratorConfig, rhs: Google_Container_V1_AcceleratorConfig) -> Bool {
    if lhs.acceleratorCount != rhs.acceleratorCount {return false}
    if lhs.acceleratorType != rhs.acceleratorType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetNetworkPolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetNetworkPolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "network_policy"),
    6: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._networkPolicy) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._networkPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetNetworkPolicyRequest, rhs: Google_Container_V1_SetNetworkPolicyRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._networkPolicy != rhs._networkPolicy {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_SetMaintenancePolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetMaintenancePolicyRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "project_id"),
    2: .same(proto: "zone"),
    3: .standard(proto: "cluster_id"),
    4: .standard(proto: "maintenance_policy"),
    5: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.projectID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.zone) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._maintenancePolicy) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.projectID.isEmpty {
      try visitor.visitSingularStringField(value: self.projectID, fieldNumber: 1)
    }
    if !self.zone.isEmpty {
      try visitor.visitSingularStringField(value: self.zone, fieldNumber: 2)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 3)
    }
    if let v = self._maintenancePolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_SetMaintenancePolicyRequest, rhs: Google_Container_V1_SetMaintenancePolicyRequest) -> Bool {
    if lhs.projectID != rhs.projectID {return false}
    if lhs.zone != rhs.zone {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs._maintenancePolicy != rhs._maintenancePolicy {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_StatusCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StatusCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != .unknown {
      try visitor.visitSingularEnumField(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_StatusCondition, rhs: Google_Container_V1_StatusCondition) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_StatusCondition.Code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "GCE_STOCKOUT"),
    2: .same(proto: "GKE_SERVICE_ACCOUNT_DELETED"),
    3: .same(proto: "GCE_QUOTA_EXCEEDED"),
    4: .same(proto: "SET_BY_OPERATOR"),
    7: .same(proto: "CLOUD_KMS_KEY_ERROR"),
  ]
}

extension Google_Container_V1_NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NetworkConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "subnetwork"),
    5: .standard(proto: "enable_intra_node_visibility"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.subnetwork) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.enableIntraNodeVisibility) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 1)
    }
    if !self.subnetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetwork, fieldNumber: 2)
    }
    if self.enableIntraNodeVisibility != false {
      try visitor.visitSingularBoolField(value: self.enableIntraNodeVisibility, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_NetworkConfig, rhs: Google_Container_V1_NetworkConfig) -> Bool {
    if lhs.network != rhs.network {return false}
    if lhs.subnetwork != rhs.subnetwork {return false}
    if lhs.enableIntraNodeVisibility != rhs.enableIntraNodeVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_IntraNodeVisibilityConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IntraNodeVisibilityConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_IntraNodeVisibilityConfig, rhs: Google_Container_V1_IntraNodeVisibilityConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_MaxPodsConstraint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MaxPodsConstraint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_pods_per_node"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxPodsPerNode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxPodsPerNode != 0 {
      try visitor.visitSingularInt64Field(value: self.maxPodsPerNode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_MaxPodsConstraint, rhs: Google_Container_V1_MaxPodsConstraint) -> Bool {
    if lhs.maxPodsPerNode != rhs.maxPodsPerNode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_DatabaseEncryption: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DatabaseEncryption"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "state"),
    1: .standard(proto: "key_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyName) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyName.isEmpty {
      try visitor.visitSingularStringField(value: self.keyName, fieldNumber: 1)
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_DatabaseEncryption, rhs: Google_Container_V1_DatabaseEncryption) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.keyName != rhs.keyName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_DatabaseEncryption.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ENCRYPTED"),
    2: .same(proto: "DECRYPTED"),
  ]
}

extension Google_Container_V1_ListUsableSubnetworksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUsableSubnetworksRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "parent"),
    2: .same(proto: "filter"),
    3: .standard(proto: "page_size"),
    4: .standard(proto: "page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.parent) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.filter) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.parent.isEmpty {
      try visitor.visitSingularStringField(value: self.parent, fieldNumber: 1)
    }
    if !self.filter.isEmpty {
      try visitor.visitSingularStringField(value: self.filter, fieldNumber: 2)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListUsableSubnetworksRequest, rhs: Google_Container_V1_ListUsableSubnetworksRequest) -> Bool {
    if lhs.parent != rhs.parent {return false}
    if lhs.filter != rhs.filter {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ListUsableSubnetworksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListUsableSubnetworksResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subnetworks"),
    2: .standard(proto: "next_page_token"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.subnetworks) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subnetworks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.subnetworks, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ListUsableSubnetworksResponse, rhs: Google_Container_V1_ListUsableSubnetworksResponse) -> Bool {
    if lhs.subnetworks != rhs.subnetworks {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_UsableSubnetworkSecondaryRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsableSubnetworkSecondaryRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "range_name"),
    2: .standard(proto: "ip_cidr_range"),
    3: .same(proto: "status"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.rangeName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ipCidrRange) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rangeName.isEmpty {
      try visitor.visitSingularStringField(value: self.rangeName, fieldNumber: 1)
    }
    if !self.ipCidrRange.isEmpty {
      try visitor.visitSingularStringField(value: self.ipCidrRange, fieldNumber: 2)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_UsableSubnetworkSecondaryRange, rhs: Google_Container_V1_UsableSubnetworkSecondaryRange) -> Bool {
    if lhs.rangeName != rhs.rangeName {return false}
    if lhs.ipCidrRange != rhs.ipCidrRange {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_UsableSubnetworkSecondaryRange.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "UNUSED"),
    2: .same(proto: "IN_USE_SERVICE"),
    3: .same(proto: "IN_USE_SHAREABLE_POD"),
    4: .same(proto: "IN_USE_MANAGED_POD"),
  ]
}

extension Google_Container_V1_UsableSubnetwork: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UsableSubnetwork"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subnetwork"),
    2: .same(proto: "network"),
    3: .standard(proto: "ip_cidr_range"),
    4: .standard(proto: "secondary_ip_ranges"),
    5: .standard(proto: "status_message"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.subnetwork) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipCidrRange) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.secondaryIpRanges) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subnetwork.isEmpty {
      try visitor.visitSingularStringField(value: self.subnetwork, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 2)
    }
    if !self.ipCidrRange.isEmpty {
      try visitor.visitSingularStringField(value: self.ipCidrRange, fieldNumber: 3)
    }
    if !self.secondaryIpRanges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.secondaryIpRanges, fieldNumber: 4)
    }
    if !self.statusMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.statusMessage, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_UsableSubnetwork, rhs: Google_Container_V1_UsableSubnetwork) -> Bool {
    if lhs.subnetwork != rhs.subnetwork {return false}
    if lhs.network != rhs.network {return false}
    if lhs.ipCidrRange != rhs.ipCidrRange {return false}
    if lhs.secondaryIpRanges != rhs.secondaryIpRanges {return false}
    if lhs.statusMessage != rhs.statusMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ResourceUsageExportConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceUsageExportConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bigquery_destination"),
    2: .standard(proto: "enable_network_egress_metering"),
    3: .standard(proto: "consumption_metering_config"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bigqueryDestination) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableNetworkEgressMetering) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consumptionMeteringConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bigqueryDestination {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.enableNetworkEgressMetering != false {
      try visitor.visitSingularBoolField(value: self.enableNetworkEgressMetering, fieldNumber: 2)
    }
    if let v = self._consumptionMeteringConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ResourceUsageExportConfig, rhs: Google_Container_V1_ResourceUsageExportConfig) -> Bool {
    if lhs._bigqueryDestination != rhs._bigqueryDestination {return false}
    if lhs.enableNetworkEgressMetering != rhs.enableNetworkEgressMetering {return false}
    if lhs._consumptionMeteringConfig != rhs._consumptionMeteringConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ResourceUsageExportConfig.BigQueryDestination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Container_V1_ResourceUsageExportConfig.protoMessageName + ".BigQueryDestination"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dataset_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.datasetID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.datasetID.isEmpty {
      try visitor.visitSingularStringField(value: self.datasetID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ResourceUsageExportConfig.BigQueryDestination, rhs: Google_Container_V1_ResourceUsageExportConfig.BigQueryDestination) -> Bool {
    if lhs.datasetID != rhs.datasetID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_ResourceUsageExportConfig.ConsumptionMeteringConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Google_Container_V1_ResourceUsageExportConfig.protoMessageName + ".ConsumptionMeteringConfig"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_ResourceUsageExportConfig.ConsumptionMeteringConfig, rhs: Google_Container_V1_ResourceUsageExportConfig.ConsumptionMeteringConfig) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Container_V1_VerticalPodAutoscaling: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VerticalPodAutoscaling"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Google_Container_V1_VerticalPodAutoscaling, rhs: Google_Container_V1_VerticalPodAutoscaling) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
